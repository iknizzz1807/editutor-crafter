{"html":"<h1 id=\"kubernetes-operator-design-document\">Kubernetes Operator: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This system implements a Kubernetes operator that extends the cluster API with custom resources and automated reconciliation logic. The key architectural challenge is building a robust controller that watches cluster state, maintains desired configuration, and handles the complexities of distributed system failures while integrating seamlessly with Kubernetes&#39; declarative model.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - provides foundational understanding for the entire operator pattern</p>\n</blockquote>\n<p>Managing applications in Kubernetes can quickly become overwhelming as systems grow in complexity. While Kubernetes provides excellent primitives for deploying and running containers, it lacks built-in knowledge about how specific applications should behave, how they should respond to failures, or how they should be configured for optimal performance. This gap between Kubernetes&#39; generic container orchestration and application-specific operational knowledge creates significant challenges for platform teams and application developers.</p>\n<p>The fundamental problem is that <strong>operational knowledge</strong> - the accumulated wisdom about how to run, monitor, upgrade, backup, and troubleshoot applications - typically exists only in documentation, runbooks, and the minds of experienced operators. When incidents occur at 3 AM, or when applications need to be scaled or upgraded, human operators must manually translate this knowledge into a series of kubectl commands, configuration changes, and monitoring checks. This approach doesn&#39;t scale as organizations grow their Kubernetes footprint or as applications become more sophisticated.</p>\n<p>Consider a typical scenario: deploying a stateful application like a database cluster requires not just creating Deployments and Services, but also configuring persistent volumes, setting up replication, managing leader election, coordinating rolling updates without data loss, implementing backup schedules, monitoring cluster health, and handling various failure scenarios. Each of these operations requires deep understanding of both Kubernetes APIs and the application&#39;s specific requirements. When done manually, this process is error-prone, time-consuming, and difficult to reproduce consistently across environments.</p>\n<h3 id=\"mental-model-the-tireless-system-administrator\">Mental Model: The Tireless System Administrator</h3>\n<p>To understand what Kubernetes operators provide, imagine the most experienced system administrator on your team - someone who has managed complex applications for years, knows every configuration nuance, never makes typos, never forgets steps in procedures, and never needs sleep. This administrator sits in front of a terminal 24/7, continuously monitoring the state of all applications under their care.</p>\n<p>When this tireless administrator notices that a database replica has failed, they immediately spring into action: checking the health of remaining replicas, determining if the failure affects the primary, deciding whether to promote a new replica or wait for the failed one to recover, updating load balancer configurations if needed, sending alerts to the appropriate teams, and documenting the incident. They perform these actions not by following a rigid script, but by understanding the current state of the system, comparing it to the desired state, and taking the minimal necessary actions to close the gap.</p>\n<p>This administrator never gets overwhelmed by multiple simultaneous issues because they process each situation methodically, always working from first principles: &quot;What should the system look like?&quot; and &quot;What&#39;s the smallest change I can make to get closer to that goal?&quot; They don&#39;t panic during outages, they don&#39;t skip steps during routine maintenance, and they learn from each incident to improve their procedures.</p>\n<p>A <strong>Kubernetes operator</strong> is essentially this tireless system administrator encoded as software. It continuously watches the actual state of resources in your cluster, compares that state to your declared intentions, and takes corrective actions when gaps are detected. It never gets tired, never forgets to check on things, and can manage dozens or hundreds of application instances simultaneously with perfect consistency.</p>\n<p>The operator doesn&#39;t just monitor and react - it also embodies years of operational wisdom about the applications it manages. It knows that when scaling up a database cluster, replicas should be added one at a time with health checks between each addition. It understands that certain configuration changes require rolling restarts while others can be applied dynamically. It recognizes the difference between temporary network hiccups and genuine failures that require intervention.</p>\n<p>Most importantly, this tireless administrator is <strong>declarative</strong> rather than <strong>imperative</strong>. Instead of being told &quot;scale the database to 5 replicas, then update the configuration, then restart the monitoring agent,&quot; the operator is simply told &quot;I want a database cluster with 5 replicas running version 2.4.1 with monitoring enabled.&quot; The operator figures out the sequence of operations needed to make that desire a reality, handles any errors or unexpected conditions that arise, and continues working until the actual state matches the declared intent.</p>\n<h3 id=\"existing-approaches-comparison\">Existing Approaches Comparison</h3>\n<p>Before diving into why operators represent a superior approach, it&#39;s important to understand the landscape of existing solutions and their limitations. Each approach addresses part of the operational complexity problem, but none provides the complete solution that operators enable.</p>\n<h4 id=\"manual-kubectl-operations\">Manual kubectl Operations</h4>\n<p>The most basic approach to managing Kubernetes applications involves manually crafting YAML manifests and applying them with kubectl. This approach gives operators complete control and transparency - every action is explicit and visible.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Strengths</th>\n<th>Weaknesses</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Control</strong></td>\n<td>Complete visibility into every operation; no hidden abstractions</td>\n<td>Requires deep Kubernetes expertise; prone to human error</td>\n</tr>\n<tr>\n<td><strong>Debugging</strong></td>\n<td>Easy to trace exactly what resources exist and how they were created</td>\n<td>No history of changes; difficult to understand why resources are in current state</td>\n</tr>\n<tr>\n<td><strong>Scalability</strong></td>\n<td>Works well for simple applications with few resources</td>\n<td>Doesn&#39;t scale beyond small numbers of applications or environments</td>\n</tr>\n<tr>\n<td><strong>Consistency</strong></td>\n<td>Can achieve perfect consistency if procedures are followed exactly</td>\n<td>Relies entirely on human discipline; no enforcement of procedures</td>\n</tr>\n<tr>\n<td><strong>Error Handling</strong></td>\n<td>Operator can immediately see and respond to errors</td>\n<td>All error detection and recovery is manual; easy to miss problems</td>\n</tr>\n</tbody></table>\n<p>The fundamental limitation of manual operations is that they require constant human attention and perfect execution. Consider managing a multi-environment deployment: ensuring that the same sequence of operations is performed correctly in development, staging, and production environments requires meticulous documentation and discipline. When problems arise - a pod fails to start, a service becomes unreachable, or a configuration change has unexpected side effects - human operators must diagnose the issue and determine appropriate remediation steps.</p>\n<p>As the number of applications and environments grows, manual operations become increasingly unsustainable. Teams spend more time on routine operational tasks and less time on developing new features or improving system reliability.</p>\n<h4 id=\"helm-charts-and-package-managers\">Helm Charts and Package Managers</h4>\n<p>Helm represents a significant improvement over manual operations by introducing templating, dependency management, and release lifecycle management. Helm charts package application resources into reusable units that can be customized for different environments through values files.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Strengths</th>\n<th>Weaknesses</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Reusability</strong></td>\n<td>Charts can be shared and reused across teams and organizations</td>\n<td>Limited to deployment-time configuration; no runtime adaptation</td>\n</tr>\n<tr>\n<td><strong>Templating</strong></td>\n<td>Values files enable environment-specific customization</td>\n<td>Complex applications require complex templating logic</td>\n</tr>\n<tr>\n<td><strong>Versioning</strong></td>\n<td>Release management with rollback capabilities</td>\n<td>Rollbacks are coarse-grained; can&#39;t handle partial failures gracefully</td>\n</tr>\n<tr>\n<td><strong>Ecosystem</strong></td>\n<td>Large ecosystem of pre-built charts for common applications</td>\n<td>Charts often make assumptions that don&#39;t fit specific use cases</td>\n</tr>\n<tr>\n<td><strong>Day-2 Operations</strong></td>\n<td>Good for initial deployment and major updates</td>\n<td>No ongoing lifecycle management; no automatic problem resolution</td>\n</tr>\n</tbody></table>\n<p>Helm excels at solving the <strong>deployment</strong> problem - packaging applications in a way that makes them easy to install, configure, and upgrade. However, Helm charts are fundamentally <strong>installation tools</strong>, not <strong>operational tools</strong>. Once a Helm release is deployed, it doesn&#39;t continue monitoring the application, responding to failures, or adapting to changing conditions.</p>\n<p>For example, a Helm chart can deploy a database cluster with appropriate initial configuration, but it can&#39;t automatically scale the cluster based on load, replace failed replicas, perform routine maintenance tasks, or coordinate complex upgrade procedures that require specific sequences of operations.</p>\n<h4 id=\"custom-scripts-and-automation\">Custom Scripts and Automation</h4>\n<p>Many organizations bridge the gap between manual operations and full automation by developing custom scripts, often integrated with CI/CD pipelines or scheduled as cron jobs. These scripts encode operational procedures and can perform routine maintenance tasks automatically.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Strengths</th>\n<th>Weaknesses</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Customization</strong></td>\n<td>Scripts can encode organization-specific procedures perfectly</td>\n<td>High maintenance overhead; scripts break as systems evolve</td>\n</tr>\n<tr>\n<td><strong>Integration</strong></td>\n<td>Can integrate with existing monitoring and alerting systems</td>\n<td>Often fragile and difficult to debug when problems occur</td>\n</tr>\n<tr>\n<td><strong>Automation</strong></td>\n<td>Reduces manual toil for routine operations</td>\n<td>Usually imperative; difficult to ensure idempotency</td>\n</tr>\n<tr>\n<td><strong>Knowledge Capture</strong></td>\n<td>Procedures are documented in code rather than runbooks</td>\n<td>Knowledge is scattered across many scripts with no unified model</td>\n</tr>\n<tr>\n<td><strong>Error Recovery</strong></td>\n<td>Can include error handling and retry logic</td>\n<td>Error handling is ad-hoc; difficult to handle all edge cases</td>\n</tr>\n</tbody></table>\n<p>The primary challenge with custom scripts is that they tend to be <strong>imperative</strong> rather than <strong>declarative</strong>. A script might contain logic like &quot;if the database has fewer than 3 replicas, create a new one,&quot; but scripts struggle with more complex scenarios like &quot;ensure the database cluster is healthy and properly configured according to this specification.&quot;</p>\n<p>Scripts also suffer from the <strong>coordination problem</strong>: multiple scripts running simultaneously can interfere with each other, leading to race conditions and inconsistent state. Without a unified control plane, it&#39;s difficult to ensure that all automation is working toward the same goals.</p>\n<h3 id=\"why-the-operator-pattern\">Why the Operator Pattern</h3>\n<p>The operator pattern addresses the fundamental limitations of existing approaches by treating <strong>operational knowledge as code</strong> and integrating deeply with Kubernetes&#39; declarative architecture. Rather than viewing automation as a collection of scripts or deployment tools, operators embody the principle that application management should be as declarative and self-healing as the underlying Kubernetes platform.</p>\n<blockquote>\n<p><strong>Design Insight:</strong> The operator pattern succeeds because it aligns with Kubernetes&#39; core philosophy: desired state should be declared, and the system should continuously work to make reality match that declaration. Operators extend this philosophy from basic Kubernetes resources to application-specific concerns.</p>\n</blockquote>\n<h4 id=\"encoding-operational-knowledge\">Encoding Operational Knowledge</h4>\n<p>The most significant advantage of operators is their ability to <strong>encode operational knowledge directly into the control plane</strong>. Instead of documenting procedures in runbooks that humans must execute, operators embed this knowledge into software that can execute procedures consistently and reliably.</p>\n<p>Consider the operational knowledge required to manage a database cluster:</p>\n<table>\n<thead>\n<tr>\n<th>Operational Concern</th>\n<th>Traditional Approach</th>\n<th>Operator Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Scaling</strong></td>\n<td>Runbook: &quot;Add replicas one at a time, wait for sync, update load balancer&quot;</td>\n<td>Code: Reconciliation loop that creates replicas, monitors readiness, updates services</td>\n</tr>\n<tr>\n<td><strong>Failure Recovery</strong></td>\n<td>Alert → Human investigates → Manual recovery steps</td>\n<td>Automated detection → Self-healing → Human notified of resolution</td>\n</tr>\n<tr>\n<td><strong>Upgrades</strong></td>\n<td>Maintenance window → Manual coordination → Hope nothing breaks</td>\n<td>Rolling upgrade with automated rollback on failure detection</td>\n</tr>\n<tr>\n<td><strong>Configuration Changes</strong></td>\n<td>Change management → Careful manual application → Monitor for issues</td>\n<td>Declarative configuration → Automatic application → Drift detection</td>\n</tr>\n<tr>\n<td><strong>Backup Management</strong></td>\n<td>Scheduled scripts → Manual verification → Hope backups work</td>\n<td>Integrated backup scheduling → Automatic validation → Recovery testing</td>\n</tr>\n</tbody></table>\n<p>This knowledge encoding provides several critical benefits:</p>\n<p><strong>Consistency</strong>: The same operational procedures are executed identically every time, regardless of which team member initiated the action or what time of day it occurs. There&#39;s no variation in procedure execution based on operator experience or stress levels.</p>\n<p><strong>Auditability</strong>: All operational actions are taken through the Kubernetes API and can be logged, monitored, and audited. The decision-making process is transparent and reproducible.</p>\n<p><strong>Testability</strong>: Operational procedures can be tested in development environments before being applied to production. Complex scenarios like failure recovery can be validated through chaos engineering approaches.</p>\n<p><strong>Evolution</strong>: Operational knowledge improves over time as the operator code is refined. Lessons learned from incidents can be encoded into the operator, making the entire system more resilient.</p>\n<h4 id=\"self-healing-infrastructure\">Self-Healing Infrastructure</h4>\n<p>Operators enable <strong>self-healing infrastructure</strong> by continuously monitoring actual state and taking corrective actions when deviations from desired state are detected. This goes far beyond simple resource creation and deletion to include application-specific health checks, performance optimization, and failure recovery procedures.</p>\n<blockquote>\n<p><strong>Decision: Continuous Reconciliation vs Event-Driven Reactions</strong></p>\n<ul>\n<li><strong>Context</strong>: Systems can respond to changes either by continuously checking state or by reacting to specific events</li>\n<li><strong>Options Considered</strong>: Event-driven (webhook-based), polling-based, hybrid approach with informers</li>\n<li><strong>Decision</strong>: Kubernetes informer pattern with continuous reconciliation loops</li>\n<li><strong>Rationale</strong>: Event-driven systems can miss events or become inconsistent during network partitions; continuous reconciliation provides eventual consistency guarantees and can detect/correct drift from any source</li>\n<li><strong>Consequences</strong>: Higher resource usage but much stronger consistency guarantees and better failure recovery</li>\n</ul>\n</blockquote>\n<p>The self-healing capabilities of operators manifest in several ways:</p>\n<p><strong>Automatic Problem Detection</strong>: Operators continuously monitor not just whether resources exist, but whether they&#39;re functioning correctly according to application-specific criteria. A database operator might check not only that pods are running, but that replication is working, that performance metrics are within acceptable ranges, and that backup processes are completing successfully.</p>\n<p><strong>Intelligent Recovery</strong>: When problems are detected, operators can take application-aware corrective actions. Rather than simply restarting failed components, an operator might determine whether a failure affects service availability, attempt graceful recovery procedures first, and coordinate complex recovery processes that involve multiple components.</p>\n<p><strong>Drift Prevention</strong>: Operators detect and correct configuration drift, ensuring that the actual system configuration always matches the declared specification. This prevents the gradual degradation that often occurs in manually managed systems as small changes accumulate over time.</p>\n<p><strong>Adaptive Behavior</strong>: Advanced operators can adapt their behavior based on observed conditions. For example, an operator might automatically adjust resource allocations based on load patterns, or modify backup frequencies based on data change rates.</p>\n<h4 id=\"integration-with-kubernetes-ecosystem\">Integration with Kubernetes Ecosystem</h4>\n<p>Operators integrate seamlessly with the broader Kubernetes ecosystem, leveraging existing tooling, monitoring, and operational practices rather than requiring entirely new approaches.</p>\n<table>\n<thead>\n<tr>\n<th>Integration Point</th>\n<th>Benefit</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>kubectl and API</strong></td>\n<td>Operators are managed using standard Kubernetes tools</td>\n<td><code>kubectl get databases</code> shows all database instances with custom columns</td>\n</tr>\n<tr>\n<td><strong>RBAC</strong></td>\n<td>Standard Kubernetes security model applies</td>\n<td>Database operator can be restricted to specific namespaces or resource types</td>\n</tr>\n<tr>\n<td><strong>Monitoring</strong></td>\n<td>Prometheus metrics, events, and logging work naturally</td>\n<td>Operator exposes application-specific metrics alongside infrastructure metrics</td>\n</tr>\n<tr>\n<td><strong>GitOps</strong></td>\n<td>Custom resources can be managed through Git workflows</td>\n<td>Database configurations versioned and deployed through standard GitOps practices</td>\n</tr>\n<tr>\n<td><strong>Networking</strong></td>\n<td>Application networking integrates with Kubernetes services and ingress</td>\n<td>Operator manages service discovery and load balancing using native mechanisms</td>\n</tr>\n</tbody></table>\n<p>This integration means that adopting operators doesn&#39;t require teams to learn entirely new toolsets or abandon existing operational practices. Instead, operators enhance and extend existing Kubernetes workflows with application-specific intelligence.</p>\n<p>The operator pattern represents a fundamental shift from <strong>reactive operational practices</strong> to <strong>proactive declarative management</strong>. Rather than waiting for problems to occur and then responding, operators continuously work to maintain desired state and prevent problems from arising in the first place. This shift enables organizations to manage complex applications at scale while reducing operational toil and improving system reliability.</p>\n<blockquote>\n<p><strong>Key Insight:</strong> Operators don&#39;t just automate existing manual procedures - they enable entirely new approaches to system management that aren&#39;t practical with manual operations. The continuous reconciliation model allows for levels of consistency and reliability that are impossible to achieve through human-driven processes.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Understanding the operator pattern conceptually is the first step; implementing operators successfully requires careful technology choices and project structure decisions. This section provides concrete guidance for teams building their first Kubernetes operator.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Operator Framework</strong></td>\n<td>Operator SDK with Helm or Ansible</td>\n<td>Kubebuilder with controller-runtime</td>\n</tr>\n<tr>\n<td><strong>Language Runtime</strong></td>\n<td>Go 1.21+ with controller-runtime</td>\n<td>Go with custom client-go usage</td>\n</tr>\n<tr>\n<td><strong>Custom Resource Generation</strong></td>\n<td>Kubebuilder markers and code generation</td>\n<td>Hand-written OpenAPI v3 schemas</td>\n</tr>\n<tr>\n<td><strong>Testing Framework</strong></td>\n<td>Envtest with Ginkgo/Gomega</td>\n<td>Custom test harness with kind clusters</td>\n</tr>\n<tr>\n<td><strong>Admission Webhooks</strong></td>\n<td>controller-runtime webhook builder</td>\n<td>Custom HTTP servers with admission review handling</td>\n</tr>\n<tr>\n<td><strong>Certificate Management</strong></td>\n<td>cert-manager with self-signed issuer</td>\n<td>External certificate authority integration</td>\n</tr>\n</tbody></table>\n<p>For teams new to operator development, <strong>Kubebuilder with controller-runtime</strong> provides the optimal balance of power and ease of use. It generates substantial boilerplate code, provides excellent testing utilities, and follows Kubernetes community best practices.</p>\n<h4 id=\"recommended-project-structure\">Recommended Project Structure</h4>\n<p>Organizing operator code properly from the beginning prevents architectural debt and makes the codebase maintainable as features are added:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>database-operator/\n├── cmd/\n│   └── main.go                    ← Entry point and flag parsing\n├── api/\n│   └── v1/\n│       ├── database_types.go      ← Custom resource type definitions\n│       ├── groupversion_info.go   ← API group and version metadata\n│       └── zz_generated.deepcopy.go ← Generated code (do not edit)\n├── controllers/\n│   ├── database_controller.go     ← Main reconciliation logic\n│   └── database_controller_test.go ← Controller unit tests\n├── internal/\n│   ├── resources/                 ← Resource creation and management\n│   │   ├── deployment.go          ← Database deployment logic\n│   │   ├── service.go             ← Service creation and updates\n│   │   └── configmap.go           ← Configuration management\n│   ├── status/                    ← Status calculation and updates\n│   │   └── conditions.go          ← Status condition management\n│   └── webhooks/                  ← Admission webhook implementations\n│       ├── validator.go           ← Validation webhook logic\n│       └── defaulter.go           ← Defaulting webhook logic\n├── config/\n│   ├── crd/                       ← Custom resource definitions\n│   ├── rbac/                      ← Role and binding manifests\n│   ├── webhook/                   ← Webhook configuration\n│   └── samples/                   ← Example custom resources\n└── hack/\n    └── boilerplate.go.txt         ← License header for generated files</code></pre></div>\n\n<p>This structure separates concerns clearly: API definitions remain stable in the <code>api/</code> directory, business logic lives in <code>controllers/</code>, and implementation details are encapsulated in <code>internal/</code> packages.</p>\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p>The following code provides a complete foundation for operator development. Copy this code and modify it according to your specific requirements rather than building everything from scratch.</p>\n<p><strong>Main Entry Point (cmd/main.go):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> main</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">flag</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    utilruntime </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/util/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    clientgoscheme </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/client-go/kubernetes/scheme</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/healthz</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/log/zap</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    databasev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/yourorg/database-operator/api/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/yourorg/database-operator/controllers</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scheme   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> runtime.</span><span style=\"color:#B392F0\">NewScheme</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    setupLog </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ctrl.Log.</span><span style=\"color:#B392F0\">WithName</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"setup\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> init</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    utilruntime.</span><span style=\"color:#B392F0\">Must</span><span style=\"color:#E1E4E8\">(clientgoscheme.</span><span style=\"color:#B392F0\">AddToScheme</span><span style=\"color:#E1E4E8\">(scheme))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    utilruntime.</span><span style=\"color:#B392F0\">Must</span><span style=\"color:#E1E4E8\">(databasev1.</span><span style=\"color:#B392F0\">AddToScheme</span><span style=\"color:#E1E4E8\">(scheme))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> metricsAddr </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> enableLeaderElection </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> probeAddr </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">StringVar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">metricsAddr, </span><span style=\"color:#9ECBFF\">\"metrics-bind-address\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\":8080\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"The address the metric endpoint binds to.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">StringVar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">probeAddr, </span><span style=\"color:#9ECBFF\">\"health-probe-bind-address\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\":8081\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"The address the probe endpoint binds to.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">BoolVar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">enableLeaderElection, </span><span style=\"color:#9ECBFF\">\"leader-elect\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Enable leader election for controller manager.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    opts </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> zap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Options</span><span style=\"color:#E1E4E8\">{Development: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    opts.</span><span style=\"color:#B392F0\">BindFlags</span><span style=\"color:#E1E4E8\">(flag.CommandLine)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">Parse</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl.</span><span style=\"color:#B392F0\">SetLogger</span><span style=\"color:#E1E4E8\">(zap.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(zap.</span><span style=\"color:#B392F0\">UseFlagOptions</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">opts)))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mgr, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ctrl.</span><span style=\"color:#B392F0\">NewManager</span><span style=\"color:#E1E4E8\">(ctrl.</span><span style=\"color:#B392F0\">GetConfigOrDie</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#B392F0\">ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Options</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Scheme:                 scheme,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        MetricsBindAddress:     metricsAddr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Port:                   </span><span style=\"color:#79B8FF\">9443</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        HealthProbeBindAddress: probeAddr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LeaderElection:         enableLeaderElection,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LeaderElectionID:       </span><span style=\"color:#9ECBFF\">\"database-operator-lock\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        setupLog.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"unable to start manager\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">controllers</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Client: mgr.</span><span style=\"color:#B392F0\">GetClient</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Scheme: mgr.</span><span style=\"color:#B392F0\">GetScheme</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }).</span><span style=\"color:#B392F0\">SetupWithManager</span><span style=\"color:#E1E4E8\">(mgr); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        setupLog.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"unable to create controller\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"controller\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Database\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> mgr.</span><span style=\"color:#B392F0\">AddHealthzCheck</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"healthz\"</span><span style=\"color:#E1E4E8\">, healthz.Ping); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        setupLog.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"unable to set up health check\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> mgr.</span><span style=\"color:#B392F0\">AddReadyzCheck</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"readyz\"</span><span style=\"color:#E1E4E8\">, healthz.Ping); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        setupLog.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"unable to set up ready check\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    setupLog.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"starting manager\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> mgr.</span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(ctrl.</span><span style=\"color:#B392F0\">SetupSignalHandler</span><span style=\"color:#E1E4E8\">()); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        setupLog.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"problem running manager\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Basic Custom Resource Type (api/v1/database_types.go):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> v1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metav1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/apis/meta/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DatabaseSpec defines the desired state of Database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseSpec</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Define your custom resource specification fields here</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Examples:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Replicas     *int32  `json:\"replicas,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Version      string  `json:\"version\"`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // StorageSize  string  `json:\"storageSize,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DatabaseStatus defines the observed state of Database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseStatus</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Define your status fields here</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Examples:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Conditions       []metav1.Condition `json:\"conditions,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ReadyReplicas    int32              `json:\"readyReplicas,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ObservedGeneration int64            `json:\"observedGeneration,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:object:root=true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:subresource:status</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Database is the Schema for the databases API</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Database</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TypeMeta</span><span style=\"color:#9ECBFF\">   `json:\",inline\"`</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ObjectMeta</span><span style=\"color:#9ECBFF\"> `json:\"metadata,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Spec   </span><span style=\"color:#B392F0\">DatabaseSpec</span><span style=\"color:#9ECBFF\">   `json:\"spec,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status </span><span style=\"color:#B392F0\">DatabaseStatus</span><span style=\"color:#9ECBFF\"> `json:\"status,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:object:root=true</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DatabaseList contains a list of Database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseList</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TypeMeta</span><span style=\"color:#9ECBFF\"> `json:\",inline\"`</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ListMeta</span><span style=\"color:#9ECBFF\"> `json:\"metadata,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Items           []</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#9ECBFF\"> `json:\"items\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> init</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SchemeBuilder.</span><span style=\"color:#B392F0\">Register</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">DatabaseList</span><span style=\"color:#E1E4E8\">{})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton\">Core Logic Skeleton</h4>\n<p>The following skeleton provides the structure for implementing your reconciliation logic. Fill in the TODO sections based on your specific application requirements:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> controllers</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/client</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    databasev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/yourorg/database-operator/api/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DatabaseReconciler reconciles a Database object</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseReconciler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    client</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Scheme </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Scheme</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=database.example.com,resources=databases,verbs=get;list;watch;create;update;patch;delete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=database.example.com,resources=databases/status,verbs=get;update;patch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=database.example.com,resources=databases/finalizers,verbs=update</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Reconcile implements the main reconciliation logic for Database resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Reconcile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> log.</span><span style=\"color:#B392F0\">FromContext</span><span style=\"color:#E1E4E8\">(ctx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Fetch the Database instance from the API server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use r.Get() to retrieve the resource by namespaced name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle not-found errors gracefully (resource may have been deleted)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if the resource is being deleted (DeletionTimestamp is set)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If deleting and has finalizers, perform cleanup operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Remove finalizers when cleanup is complete to allow deletion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add finalizer if not already present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Finalizers ensure cleanup logic runs before resource deletion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use controllerutil.AddFinalizer() helper function</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Reconcile owned resources (Deployments, Services, ConfigMaps, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Compare desired state (from spec) with actual state (from cluster)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create, update, or delete resources as needed to match desired state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update the Database status based on owned resource states</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate readiness, error conditions, and other status information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use r.Status().Update() to write status back to API server</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Determine requeue behavior</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return ctrl.Result{} for no requeue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return ctrl.Result{RequeueAfter: 30*time.Second} for periodic reconciliation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return ctrl.Result{Requeue: true} for immediate requeue on recoverable errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"reconciliation completed successfully\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetupWithManager sets up the controller with the Manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetupWithManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mgr</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ctrl.</span><span style=\"color:#B392F0\">NewControllerManagedBy</span><span style=\"color:#E1E4E8\">(mgr).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        For</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">{}).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Add Owns() calls for resources created by this controller</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Example: Owns(&#x26;appsv1.Deployment{}).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Complete</span><span style=\"color:#E1E4E8\">(r)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>Go-Specific Best Practices:</strong></p>\n<ul>\n<li>Use <code>sigs.k8s.io/controller-runtime/pkg/client</code> instead of raw client-go for better ergonomics</li>\n<li>Always check <code>errors.IsNotFound()</code> when fetching resources that might not exist</li>\n<li>Use <code>controllerutil.SetControllerReference()</code> to establish owner relationships</li>\n<li>Leverage <code>kubebuilder</code> markers for RBAC and webhook generation rather than hand-writing manifests</li>\n<li>Use structured logging with <code>logr.Logger</code> instead of standard library logging</li>\n</ul>\n<p><strong>Error Handling Patterns:</strong></p>\n<ul>\n<li>Distinguish between permanent errors (bad configuration) and transient errors (network timeouts)</li>\n<li>Use <code>ctrl.Result{Requeue: true}</code> for transient errors that should retry immediately</li>\n<li>Use <code>ctrl.Result{RequeueAfter: duration}</code> for rate-limited retries or periodic reconciliation</li>\n<li>Log errors with sufficient context for debugging, but don&#39;t log expected conditions like &quot;resource not found&quot;</li>\n</ul>\n<p><strong>Performance Considerations:</strong></p>\n<ul>\n<li>Cache frequently accessed data in the controller struct rather than fetching repeatedly</li>\n<li>Use client.Reader for read-only operations to leverage informer caches</li>\n<li>Batch related operations when possible to reduce API server load</li>\n<li>Consider using predicates to filter events that don&#39;t require reconciliation</li>\n</ul>\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>After implementing each major component, verify functionality with these checkpoints:</p>\n<p><strong>Custom Resource Definition Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Apply your CRD to a cluster</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> config/crd/bases/</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify the CRD is registered</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> crd</span><span style=\"color:#9ECBFF\"> databases.database.example.com</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test custom resource creation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> config/samples/database_v1_database.yaml</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify custom columns are displayed</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> databases</span></span></code></pre></div>\n\n<p><strong>Controller Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run the controller locally</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> install</span><span style=\"color:#9ECBFF\"> run</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># In another terminal, create a test resource</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> config/samples/database_v1_database.yaml</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify reconciliation occurs (check controller logs)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should see \"reconciliation completed successfully\" messages</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify status is updated</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> database</span><span style=\"color:#9ECBFF\"> sample-database</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> yaml</span></span></code></pre></div>\n\n<p><strong>Webhook Checkpoint:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Install cert-manager for webhook certificates</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Deploy webhooks</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> deploy-webhooks</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test validation webhook with invalid resource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should receive admission denied error</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test defaulting webhook by omitting optional fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Resource should be created with default values populated</span></span></code></pre></div>\n\n<p>Expected signs that implementation is working correctly:</p>\n<ul>\n<li>Controller logs show reconciliation events for resource changes</li>\n<li>Custom resources display appropriate status conditions and custom columns</li>\n<li>Owned resources (Deployments, Services) are created and updated appropriately</li>\n<li>Webhook validation prevents invalid resources from being created</li>\n<li>Resource deletion triggers proper cleanup and finalizer removal</li>\n</ul>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - defines the scope and boundaries that guide implementation decisions across CRD design, controller logic, webhooks, testing, and deployment</p>\n</blockquote>\n<p>Building a Kubernetes operator requires clear boundaries around what problems it will solve and what complexities it will deliberately avoid. Think of this goals definition as <strong>drawing the blueprint before breaking ground</strong> - it prevents scope creep, guides architectural decisions, and sets realistic expectations for both implementers and users. Without clear goals, operators often evolve into sprawling systems that try to solve every operational problem, leading to complexity that undermines the very automation they were meant to provide.</p>\n<p>The operator pattern excels at codifying repetitive operational procedures, but not every operational task belongs in an operator. Some problems are better solved with existing Kubernetes primitives, external tools, or manual intervention. By explicitly defining what this operator will and will not handle, we create focused software that does its intended job well rather than attempting to be a universal solution.</p>\n<h3 id=\"functional-goals\">Functional Goals</h3>\n<p>The <strong>functional goals</strong> define the specific automation capabilities our operator will provide. These represent the core value proposition - the repetitive operational tasks that the operator will handle automatically, reducing manual intervention and human error.</p>\n<h4 id=\"primary-resource-management-capabilities\">Primary Resource Management Capabilities</h4>\n<p>Our operator will provide automated lifecycle management for database instances through custom resources. The primary functional goals center around the <code>Database</code> custom resource and its associated operational workflows.</p>\n<table>\n<thead>\n<tr>\n<th>Capability</th>\n<th>Description</th>\n<th>Automation Level</th>\n<th>User Interaction</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database Provisioning</td>\n<td>Create new database instances with specified configuration</td>\n<td>Fully Automated</td>\n<td>User creates Database resource</td>\n</tr>\n<tr>\n<td>Replica Management</td>\n<td>Scale database replicas up/down based on spec changes</td>\n<td>Fully Automated</td>\n<td>User updates replicas field</td>\n</tr>\n<tr>\n<td>Version Upgrades</td>\n<td>Perform rolling upgrades to new database versions</td>\n<td>Semi-Automated</td>\n<td>User updates version field, operator handles rollout</td>\n</tr>\n<tr>\n<td>Storage Management</td>\n<td>Provision and resize persistent volumes for database storage</td>\n<td>Fully Automated</td>\n<td>User specifies storageSize, operator manages PVCs</td>\n</tr>\n<tr>\n<td>Configuration Updates</td>\n<td>Apply configuration changes without service interruption</td>\n<td>Semi-Automated</td>\n<td>User updates config, operator validates and applies</td>\n</tr>\n<tr>\n<td>Health Monitoring</td>\n<td>Continuously monitor database health and update status</td>\n<td>Fully Automated</td>\n<td>Status conditions updated automatically</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Database-Focused Domain Model</strong></p>\n<ul>\n<li><strong>Context</strong>: Operators work best with a specific domain rather than generic resource management. We need concrete use cases to drive meaningful automation.</li>\n<li><strong>Options Considered</strong>: Generic application operator, database-specific operator, multi-application operator</li>\n<li><strong>Decision</strong>: Database-specific operator with concrete database management workflows</li>\n<li><strong>Rationale</strong>: Database management has well-understood operational patterns (provisioning, scaling, backup, upgrade) that translate naturally to declarative automation. This provides concrete requirements for testing reconciliation logic without getting lost in abstract scenarios.</li>\n<li><strong>Consequences</strong>: Focused scope enables deeper automation but limits reusability across application types</li>\n</ul>\n</blockquote>\n<p>The operator will manage <strong>owned resources</strong> - Kubernetes resources created and controlled by the operator to implement the desired database configuration. These owned resources form the actual infrastructure that delivers the database service.</p>\n<table>\n<thead>\n<tr>\n<th>Owned Resource Type</th>\n<th>Purpose</th>\n<th>Lifecycle Management</th>\n<th>Status Reflection</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>StatefulSet</td>\n<td>Manages database pods with stable identity and storage</td>\n<td>Created, updated, and scaled based on Database spec</td>\n<td>Ready replicas count reflected in Database status</td>\n</tr>\n<tr>\n<td>Service</td>\n<td>Provides stable network endpoint for database access</td>\n<td>Created with appropriate ports and selectors</td>\n<td>Service endpoints reflected in Database status</td>\n</tr>\n<tr>\n<td>ConfigMap</td>\n<td>Holds database configuration files and initialization scripts</td>\n<td>Updated when Database spec.config changes</td>\n<td>Configuration hash tracked in status</td>\n</tr>\n<tr>\n<td>PersistentVolumeClaim</td>\n<td>Provides durable storage for database data</td>\n<td>Created and resized based on spec.storageSize</td>\n<td>Storage capacity reflected in status</td>\n</tr>\n<tr>\n<td>Secret</td>\n<td>Manages database credentials and TLS certificates</td>\n<td>Created with generated passwords, rotated on demand</td>\n<td>Credential generation timestamp in status</td>\n</tr>\n</tbody></table>\n<h4 id=\"declarative-configuration-management\">Declarative Configuration Management</h4>\n<p>The operator will support <strong>declarative configuration</strong> where users specify the desired end state through the <code>DatabaseSpec</code>, and the operator continuously works to achieve and maintain that state through reconciliation.</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Aspect</th>\n<th>Declarative Behavior</th>\n<th>Validation Rules</th>\n<th>Default Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Replica Count</td>\n<td>Scale StatefulSet to match spec.replicas</td>\n<td>Must be positive integer, maximum of 10</td>\n<td>Defaults to 1 if omitted</td>\n</tr>\n<tr>\n<td>Database Version</td>\n<td>Perform rolling upgrade to spec.version</td>\n<td>Must be supported version from allowed list</td>\n<td>Defaults to latest stable version</td>\n</tr>\n<tr>\n<td>Storage Size</td>\n<td>Resize PVC to match spec.storageSize</td>\n<td>Cannot decrease, must use valid resource quantities</td>\n<td>Defaults to &quot;10Gi&quot;</td>\n</tr>\n<tr>\n<td>Resource Requirements</td>\n<td>Update container resources in StatefulSet</td>\n<td>Must fit within namespace resource quotas</td>\n<td>Defaults to moderate CPU/memory requests</td>\n</tr>\n<tr>\n<td>Configuration Parameters</td>\n<td>Update ConfigMap with spec.config values</td>\n<td>Validate against database-specific schema</td>\n<td>Applies sensible production defaults</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>The Desired State Principle</strong></p>\n<p>The operator embodies Kubernetes&#39; core principle that users declare what they want, not how to achieve it. When a user creates a <code>Database</code> resource requesting 3 replicas with 50Gi storage, they shouldn&#39;t need to know about StatefulSets, PVCs, or rolling update strategies. The operator translates high-level intent into low-level Kubernetes resource management.</p>\n</blockquote>\n<h4 id=\"status-reporting-and-observability\">Status Reporting and Observability</h4>\n<p>The operator will provide comprehensive status reporting through the <code>DatabaseStatus</code> subresource, giving users visibility into the current state of their database instances without requiring knowledge of the underlying Kubernetes resources.</p>\n<table>\n<thead>\n<tr>\n<th>Status Information</th>\n<th>Update Frequency</th>\n<th>Status Conditions</th>\n<th>Troubleshooting Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Ready Replica Count</td>\n<td>Every reconciliation cycle</td>\n<td>Ready, Progressing, Degraded</td>\n<td>Indicates scaling progress and health</td>\n</tr>\n<tr>\n<td>Current Version</td>\n<td>On version change completion</td>\n<td>VersionUpgrading, VersionReady</td>\n<td>Shows upgrade progress and rollback status</td>\n</tr>\n<tr>\n<td>Storage Utilization</td>\n<td>Periodic polling (configurable)</td>\n<td>StorageWarning, StorageCritical</td>\n<td>Enables proactive capacity planning</td>\n</tr>\n<tr>\n<td>Connection Information</td>\n<td>On service endpoint changes</td>\n<td>ServiceReady, ServiceUnavailable</td>\n<td>Provides connection details for applications</td>\n</tr>\n<tr>\n<td>Last Reconciliation</td>\n<td>Every reconciliation attempt</td>\n<td>ReconcileSuccess, ReconcileError</td>\n<td>Shows operator activity and error states</td>\n</tr>\n</tbody></table>\n<h3 id=\"non-functional-goals\">Non-Functional Goals</h3>\n<p>The <strong>non-functional goals</strong> define quality attributes that constrain how the operator implements its functional capabilities. These goals ensure the operator behaves reliably in production environments and integrates smoothly with Kubernetes operational practices.</p>\n<h4 id=\"reliability-and-fault-tolerance\">Reliability and Fault Tolerance</h4>\n<p>The operator must handle the distributed system challenges inherent in Kubernetes environments, where network partitions, node failures, and API server unavailability are routine operational realities.</p>\n<table>\n<thead>\n<tr>\n<th>Reliability Aspect</th>\n<th>Target Behavior</th>\n<th>Failure Handling</th>\n<th>Recovery Mechanism</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Controller Availability</td>\n<td>99.9% uptime during cluster operation</td>\n<td>Leader election prevents split-brain scenarios</td>\n<td>Automatic failover to standby controller replica</td>\n</tr>\n<tr>\n<td>Reconciliation Consistency</td>\n<td>All reconciliation operations are idempotent</td>\n<td>Partial failures don&#39;t leave resources in inconsistent states</td>\n<td>Full state reconstruction from cluster resources</td>\n</tr>\n<tr>\n<td>API Server Connectivity</td>\n<td>Graceful handling of connection interruptions</td>\n<td>Exponential backoff on API failures</td>\n<td>Automatic reconnection with informer resync</td>\n</tr>\n<tr>\n<td>Resource Conflict Resolution</td>\n<td>Handle concurrent updates from multiple sources</td>\n<td>Optimistic locking prevents conflicting changes</td>\n<td>Retry with latest resource version on conflicts</td>\n</tr>\n<tr>\n<td>Data Durability</td>\n<td>Never lose user-specified configuration</td>\n<td>All spec changes persisted before processing</td>\n<td>Status updates use separate API calls to prevent overwrites</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Eventual Consistency Model</strong></p>\n<ul>\n<li><strong>Context</strong>: Kubernetes operates on eventual consistency - cluster state changes propagate asynchronously through informers and caches</li>\n<li><strong>Options Considered</strong>: Strong consistency with distributed locking, eventual consistency with convergence, manual consistency checking</li>\n<li><strong>Decision</strong>: Embrace eventual consistency with robust reconciliation convergence</li>\n<li><strong>Rationale</strong>: Fighting Kubernetes&#39; eventual consistency model leads to complex synchronization code that&#39;s prone to deadlocks. Designing for convergence through idempotent operations aligns with Kubernetes patterns and provides better fault tolerance.</li>\n<li><strong>Consequences</strong>: Simpler controller logic and better failure recovery, but requires careful status reporting to avoid user confusion during convergence periods</li>\n</ul>\n</blockquote>\n<h4 id=\"performance-and-scalability\">Performance and Scalability</h4>\n<p>The operator should handle reasonable numbers of database instances without consuming excessive cluster resources or causing performance degradation.</p>\n<table>\n<thead>\n<tr>\n<th>Performance Metric</th>\n<th>Target Value</th>\n<th>Measurement Method</th>\n<th>Scaling Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Reconciliation Latency</td>\n<td>&lt; 30 seconds for spec changes</td>\n<td>Time from Database update to owned resource convergence</td>\n<td>Linear scaling with number of owned resources per Database</td>\n</tr>\n<tr>\n<td>Resource Consumption</td>\n<td>&lt; 100MB memory, &lt; 0.1 CPU cores per 100 Database resources</td>\n<td>Metrics exported via Prometheus endpoints</td>\n<td>Memory usage grows with informer cache size</td>\n</tr>\n<tr>\n<td>API Server Load</td>\n<td>&lt; 10 QPS per controller replica</td>\n<td>Rate limiting on client requests</td>\n<td>Batched status updates reduce API call frequency</td>\n</tr>\n<tr>\n<td>Webhook Response Time</td>\n<td>&lt; 5 seconds for validation/mutation</td>\n<td>Admission review processing time</td>\n<td>Independent of cluster size for validation rules</td>\n</tr>\n<tr>\n<td>Controller Startup Time</td>\n<td>&lt; 60 seconds to ready state</td>\n<td>Time from pod start to processing first reconciliation</td>\n<td>Informer cache sync time dominates startup</td>\n</tr>\n</tbody></table>\n<h4 id=\"operational-integration\">Operational Integration</h4>\n<p>The operator must integrate seamlessly with standard Kubernetes operational practices and tooling used by platform teams.</p>\n<table>\n<thead>\n<tr>\n<th>Integration Aspect</th>\n<th>Standard Compliance</th>\n<th>Tooling Compatibility</th>\n<th>Operational Benefit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>RBAC Authorization</td>\n<td>Principle of least privilege for all permissions</td>\n<td>Compatible with namespace-scoped and cluster-scoped deployments</td>\n<td>Security audit compliance and permission isolation</td>\n</tr>\n<tr>\n<td>Resource Labeling</td>\n<td>Consistent labels for owned resources with operator identification</td>\n<td>Works with label selectors in monitoring and debugging tools</td>\n<td>Clear ownership tracking and troubleshooting</td>\n</tr>\n<tr>\n<td>Event Recording</td>\n<td>Kubernetes events for all significant operator actions</td>\n<td>Visible in kubectl describe and event aggregation systems</td>\n<td>Audit trail and debugging information</td>\n</tr>\n<tr>\n<td>Metrics Export</td>\n<td>Prometheus metrics for controller performance and resource counts</td>\n<td>Integrates with existing monitoring infrastructure</td>\n<td>Operational visibility and alerting capability</td>\n</tr>\n<tr>\n<td>Logging Structure</td>\n<td>Structured JSON logs with consistent fields</td>\n<td>Compatible with log aggregation systems like ELK or Loki</td>\n<td>Centralized logging and log-based alerting</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Operational Transparency Principle</strong></p>\n<p>Platform teams need visibility into operator behavior to debug issues, plan capacity, and maintain security compliance. The operator should export its internal state and decision-making process through standard Kubernetes observability mechanisms rather than requiring specialized knowledge or tools.</p>\n</blockquote>\n<h3 id=\"explicit-non-goals\">Explicit Non-Goals</h3>\n<p>The <strong>explicit non-goals</strong> define complexities and capabilities that this operator implementation will deliberately exclude. These boundaries prevent scope creep and ensure the operator remains focused on its core value proposition while avoiding areas where other tools provide better solutions.</p>\n<h4 id=\"data-management-and-backup-operations\">Data Management and Backup Operations</h4>\n<p>While the operator manages database infrastructure, it will not implement data-level backup, restore, or migration capabilities.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Capability</th>\n<th>Rationale</th>\n<th>Recommended Alternative</th>\n<th>Interface Boundary</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Automated Backup Scheduling</td>\n<td>Database backup strategies vary significantly by database type and organizational requirements</td>\n<td>Use dedicated backup operators like Velero or database-specific backup tools</td>\n<td>Operator provisions storage; external tools handle data backup</td>\n</tr>\n<tr>\n<td>Point-in-Time Recovery</td>\n<td>Recovery procedures require database-specific knowledge and operational context</td>\n<td>Database-native tools with organization-specific recovery procedures</td>\n<td>Operator provides persistent storage; DBA tools handle recovery</td>\n</tr>\n<tr>\n<td>Cross-Cluster Data Migration</td>\n<td>Migration involves network, security, and data governance concerns beyond infrastructure</td>\n<td>Specialized migration tools with proper data governance workflow</td>\n<td>Operator manages instances; migration tools handle data movement</td>\n</tr>\n<tr>\n<td>Data Encryption at Rest</td>\n<td>Encryption requirements vary by compliance framework and key management infrastructure</td>\n<td>Kubernetes storage encryption or database-native encryption features</td>\n<td>Operator specifies storage requirements; platform provides encryption</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Infrastructure vs Data Layer Separation</strong></p>\n<ul>\n<li><strong>Context</strong>: Operators can manage infrastructure (pods, services, storage) or data-level operations (backup, migration, schema changes)</li>\n<li><strong>Options Considered</strong>: Full data lifecycle management, infrastructure-only management, hybrid approach with pluggable data operations</li>\n<li><strong>Decision</strong>: Infrastructure-only management with clear boundaries at the data layer</li>\n<li><strong>Rationale</strong>: Data operations require database-specific expertise, compliance considerations, and organizational procedures that vary significantly across environments. Infrastructure management has consistent patterns across database types.</li>\n<li><strong>Consequences</strong>: Simpler operator implementation and clearer separation of concerns, but users need additional tools for data operations</li>\n</ul>\n</blockquote>\n<h4 id=\"advanced-deployment-strategies\">Advanced Deployment Strategies</h4>\n<p>The operator will not implement complex deployment patterns that require sophisticated orchestration beyond basic rolling updates.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Pattern</th>\n<th>Complexity Reason</th>\n<th>Standard Alternative</th>\n<th>Operator Boundary</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Blue-Green Deployments</td>\n<td>Requires maintaining parallel full environments and traffic switching logic</td>\n<td>Use service mesh or ingress controllers for traffic management</td>\n<td>Operator manages single environment; traffic tools handle switching</td>\n</tr>\n<tr>\n<td>Canary Deployments</td>\n<td>Requires traffic percentage routing and automated rollback based on metrics</td>\n<td>Use progressive delivery tools like Flagger or Argo Rollouts</td>\n<td>Operator performs rolling updates; specialized tools handle canary logic</td>\n</tr>\n<tr>\n<td>Multi-Region Replication</td>\n<td>Cross-region networking, latency, and consistency concerns</td>\n<td>Use database-native replication or service mesh multi-cluster features</td>\n<td>Operator manages single-cluster instances; platform handles multi-region</td>\n</tr>\n<tr>\n<td>Disaster Recovery Automation</td>\n<td>Requires integration with backup systems, DNS switching, and recovery procedures</td>\n<td>Use comprehensive DR orchestration tools with organizational runbooks</td>\n<td>Operator provisions instances; DR tools coordinate full recovery</td>\n</tr>\n</tbody></table>\n<h4 id=\"security-and-access-control\">Security and Access Control</h4>\n<p>While the operator follows security best practices, it will not implement application-level security features that belong in specialized security tools.</p>\n<table>\n<thead>\n<tr>\n<th>Security Aspect</th>\n<th>Exclusion Rationale</th>\n<th>Recommended Approach</th>\n<th>Responsibility Boundary</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>User Authentication</td>\n<td>Database user management involves organizational identity systems</td>\n<td>Use external authentication providers or database-native user management</td>\n<td>Operator creates database infrastructure; identity systems handle users</td>\n</tr>\n<tr>\n<td>Network Policies</td>\n<td>Network security requirements vary by organizational policy and compliance framework</td>\n<td>Use Kubernetes NetworkPolicy resources or service mesh security features</td>\n<td>Operator labels resources for policy targeting; network tools enforce policies</td>\n</tr>\n<tr>\n<td>Secret Rotation</td>\n<td>Credential rotation involves integration with organizational secret management systems</td>\n<td>Use external secret operators like External Secrets Operator or Vault integration</td>\n<td>Operator consumes secrets; secret management tools handle rotation</td>\n</tr>\n<tr>\n<td>Compliance Auditing</td>\n<td>Audit requirements vary by regulatory framework and organizational procedures</td>\n<td>Use specialized compliance tools like OPA Gatekeeper or audit logging systems</td>\n<td>Operator generates audit events; compliance tools enforce policies</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Scope Creep Through Security Requirements</strong></p>\n<p>Security requirements often drive scope expansion as stakeholders request &quot;just one more security feature.&quot; Establishing clear boundaries early prevents the operator from becoming a monolithic security solution. Instead, design clean interfaces for integration with specialized security tools.</p>\n</blockquote>\n<h4 id=\"performance-tuning-and-optimization\">Performance Tuning and Optimization</h4>\n<p>The operator will not implement database-specific performance tuning or optimization features that require deep database expertise.</p>\n<table>\n<thead>\n<tr>\n<th>Performance Aspect</th>\n<th>Exclusion Reason</th>\n<th>Alternative Solution</th>\n<th>Integration Point</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Query Performance Tuning</td>\n<td>Requires database-specific knowledge and workload analysis</td>\n<td>Use database monitoring tools and DBA expertise</td>\n<td>Operator provisions resources; DBAs tune performance</td>\n</tr>\n<tr>\n<td>Automatic Index Management</td>\n<td>Index strategies depend on application query patterns and data characteristics</td>\n<td>Use database-native optimization features or specialized tuning tools</td>\n<td>Operator manages database infrastructure; applications manage schema</td>\n</tr>\n<tr>\n<td>Workload-Based Resource Scaling</td>\n<td>Requires metrics analysis and workload prediction beyond basic replica scaling</td>\n<td>Use Horizontal Pod Autoscaler or Vertical Pod Autoscaler with custom metrics</td>\n<td>Operator handles manual scaling; autoscaling tools handle automatic scaling</td>\n</tr>\n<tr>\n<td>Connection Pool Management</td>\n<td>Connection pooling strategies vary by application architecture and traffic patterns</td>\n<td>Use application-level connection pooling or proxy tools like PgBouncer</td>\n<td>Operator provides database endpoints; applications handle connection management</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-scope-summary\">Implementation Scope Summary</h3>\n<p>These goals and non-goals create a <strong>focused operator implementation</strong> that provides real value while maintaining reasonable complexity. The operator will excel at infrastructure lifecycle management - the operational tasks that follow predictable patterns and can be reliably automated through Kubernetes primitives.</p>\n<table>\n<thead>\n<tr>\n<th>In Scope</th>\n<th>Out of Scope</th>\n<th>Interface/Integration Point</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database infrastructure provisioning and scaling</td>\n<td>Database schema management and migrations</td>\n<td>Operator provides stable endpoints for schema tools</td>\n</tr>\n<tr>\n<td>Resource lifecycle management (pods, services, storage)</td>\n<td>Application deployment and configuration</td>\n<td>Applications connect to operator-managed database services</td>\n</tr>\n<tr>\n<td>Basic health monitoring and status reporting</td>\n<td>Advanced performance monitoring and alerting</td>\n<td>Operator exports metrics for monitoring systems</td>\n</tr>\n<tr>\n<td>Rolling updates for version changes</td>\n<td>Complex deployment strategies and traffic management</td>\n<td>Operator performs updates; traffic tools handle advanced routing</td>\n</tr>\n<tr>\n<td>Infrastructure-level configuration management</td>\n<td>Database-specific tuning and optimization</td>\n<td>Operator provides base configuration; DBAs handle tuning</td>\n</tr>\n</tbody></table>\n<p>This scope definition guides every implementation decision from CRD schema design through controller logic to testing strategies. When faced with feature requests or implementation choices, refer back to these goals to maintain focus and deliver a robust, maintainable operator that solves its intended problems well.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The goals and non-goals defined above directly influence the technical implementation approach and technology choices throughout the operator development process. This guidance translates the high-level goals into concrete implementation decisions and project structure recommendations.</p>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Recommendation for Learning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Operator Framework</td>\n<td>Kubebuilder with basic scaffolding</td>\n<td>Operator SDK with advanced features and scorecard</td>\n<td>Kubebuilder - cleaner generated code, better documentation</td>\n</tr>\n<tr>\n<td>Custom Resource Schema</td>\n<td>Basic OpenAPI v3 schema validation</td>\n<td>CEL expressions with cross-field validation</td>\n<td>Start with OpenAPI, add CEL for complex validation</td>\n</tr>\n<tr>\n<td>Controller Runtime</td>\n<td>Controller-runtime with basic manager</td>\n<td>Custom controller with shared informers</td>\n<td>Controller-runtime - handles boilerplate and follows patterns</td>\n</tr>\n<tr>\n<td>Webhook Framework</td>\n<td>Controller-runtime webhook builder</td>\n<td>Custom webhook server with admission review handling</td>\n<td>Controller-runtime webhook builder - integrated TLS and registration</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>Fake client for unit tests only</td>\n<td>Envtest for integration testing with real API server</td>\n<td>Both - fake client for fast unit tests, envtest for end-to-end validation</td>\n</tr>\n<tr>\n<td>Deployment Method</td>\n<td>Static YAML manifests</td>\n<td>Helm charts with configurable values</td>\n<td>Start with static YAML, migrate to Helm for production deployment</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-project-structure\">Recommended Project Structure</h4>\n<p>The project structure should reflect the goals&#39; emphasis on focused domain logic while maintaining clear separation between infrastructure concerns and business logic:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>database-operator/\n├── cmd/\n│   └── manager/\n│       └── main.go                    ← Entry point with manager setup\n├── apis/\n│   └── database/\n│       └── v1/\n│           ├── database_types.go      ← Database CRD definition with spec/status\n│           ├── database_webhook.go    ← Validation and mutation logic\n│           └── zz_generated.deepcopy.go ← Generated by controller-gen\n├── controllers/\n│   └── database/\n│       ├── database_controller.go     ← Core reconciliation logic\n│       ├── database_controller_test.go ← Unit tests with fake client\n│       └── suite_test.go              ← Envtest integration test setup\n├── internal/\n│   ├── resources/                     ← Owned resource management (non-goals boundary)\n│   │   ├── statefulset.go            ← StatefulSet creation and updates\n│   │   ├── service.go                ← Service endpoint management\n│   │   ├── configmap.go              ← Configuration management\n│   │   └── secret.go                 ← Credential handling\n│   └── database/                      ← Database-specific logic (extensibility point)\n│       ├── postgres.go               ← PostgreSQL-specific configuration\n│       └── mysql.go                  ← MySQL-specific configuration (future)\n├── config/\n│   ├── crd/                          ← CRD manifests and kustomization\n│   ├── rbac/                         ← RBAC role definitions following least privilege\n│   ├── webhook/                      ← Webhook configuration and TLS setup\n│   └── manager/                      ← Controller deployment manifests\n└── hack/\n    ├── boilerplate.go.txt           ← License header for generated files\n    └── tools.go                     ← Tool dependencies for go mod</code></pre></div>\n\n<p>This structure supports the functional goals by separating domain-specific logic (<code>internal/database/</code>) from generic Kubernetes resource management (<code>internal/resources/</code>), making it easy to extend support for additional database types without violating the infrastructure vs data management boundary.</p>\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Manager Setup (cmd/manager/main.go)</strong> - Complete working foundation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> main</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">flag</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    clientgoscheme </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/client-go/kubernetes/scheme</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/healthz</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/log/zap</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    databasev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/example/database-operator/apis/database/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    databasecontrollers </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/example/database-operator/controllers/database</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scheme   </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> runtime.</span><span style=\"color:#B392F0\">NewScheme</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    setupLog </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ctrl.Log.</span><span style=\"color:#B392F0\">WithName</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"setup\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> init</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> clientgoscheme.</span><span style=\"color:#B392F0\">AddToScheme</span><span style=\"color:#E1E4E8\">(scheme)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> databasev1.</span><span style=\"color:#B392F0\">AddToScheme</span><span style=\"color:#E1E4E8\">(scheme)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> metricsAddr </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> probeAddr </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> enableLeaderElection </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> syncPeriod </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">StringVar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">metricsAddr, </span><span style=\"color:#9ECBFF\">\"metrics-bind-address\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\":8080\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"The address the metric endpoint binds to.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">StringVar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">probeAddr, </span><span style=\"color:#9ECBFF\">\"health-probe-bind-address\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\":8081\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"The address the probe endpoint binds to.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">BoolVar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">enableLeaderElection, </span><span style=\"color:#9ECBFF\">\"leader-elect\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Enable leader election for controller manager.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">DurationVar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">syncPeriod, </span><span style=\"color:#9ECBFF\">\"sync-period\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">time.Minute, </span><span style=\"color:#9ECBFF\">\"Minimum frequency at which watched resources are reconciled.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    opts </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> zap</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Options</span><span style=\"color:#E1E4E8\">{Development: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    opts.</span><span style=\"color:#B392F0\">BindFlags</span><span style=\"color:#E1E4E8\">(flag.CommandLine)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">Parse</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl.</span><span style=\"color:#B392F0\">SetLogger</span><span style=\"color:#E1E4E8\">(zap.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(zap.</span><span style=\"color:#B392F0\">UseFlagOptions</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">opts)))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mgr, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ctrl.</span><span style=\"color:#B392F0\">NewManager</span><span style=\"color:#E1E4E8\">(ctrl.</span><span style=\"color:#B392F0\">GetConfigOrDie</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#B392F0\">ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Options</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Scheme:                 scheme,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        MetricsBindAddress:     metricsAddr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Port:                   </span><span style=\"color:#79B8FF\">9443</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// Webhook server port</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        HealthProbeBindAddress: probeAddr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LeaderElection:         enableLeaderElection,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LeaderElectionID:       </span><span style=\"color:#9ECBFF\">\"database-operator-leader-election\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        SyncPeriod:             </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">syncPeriod,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        setupLog.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"unable to start manager\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Register controller - learner implements the reconciliation logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">databasecontrollers</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Client: mgr.</span><span style=\"color:#B392F0\">GetClient</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Scheme: mgr.</span><span style=\"color:#B392F0\">GetScheme</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Log:    ctrl.Log.</span><span style=\"color:#B392F0\">WithName</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"controllers\"</span><span style=\"color:#E1E4E8\">).</span><span style=\"color:#B392F0\">WithName</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Database\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }).</span><span style=\"color:#B392F0\">SetupWithManager</span><span style=\"color:#E1E4E8\">(mgr); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        setupLog.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"unable to create controller\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"controller\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Database\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Register webhooks - learner implements validation and mutation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">{}).</span><span style=\"color:#B392F0\">SetupWebhookWithManager</span><span style=\"color:#E1E4E8\">(mgr); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        setupLog.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"unable to create webhook\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"webhook\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Database\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Health and readiness endpoints</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> mgr.</span><span style=\"color:#B392F0\">AddHealthzCheck</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"healthz\"</span><span style=\"color:#E1E4E8\">, healthz.Ping); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        setupLog.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"unable to set up health check\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> mgr.</span><span style=\"color:#B392F0\">AddReadyzCheck</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"readyz\"</span><span style=\"color:#E1E4E8\">, healthz.Ping); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        setupLog.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"unable to set up ready check\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    setupLog.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"starting manager\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> mgr.</span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(ctrl.</span><span style=\"color:#B392F0\">SetupSignalHandler</span><span style=\"color:#E1E4E8\">()); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        setupLog.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"problem running manager\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Resource Helper Utilities (internal/resources/common.go)</strong> - Infrastructure code supporting non-functional goals:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> resources</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    corev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/core/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metav1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/apis/meta/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    databasev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/example/database-operator/apis/database/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Labels for owned resource identification (supports operational integration goals)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ManagedByLabelKey</span><span style=\"color:#F97583\">   =</span><span style=\"color:#9ECBFF\"> \"app.kubernetes.io/managed-by\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ManagedByLabelValue</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"database-operator\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NameLabelKey</span><span style=\"color:#F97583\">        =</span><span style=\"color:#9ECBFF\"> \"app.kubernetes.io/name\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ComponentLabelKey</span><span style=\"color:#F97583\">   =</span><span style=\"color:#9ECBFF\"> \"app.kubernetes.io/component\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    InstanceLabelKey</span><span style=\"color:#F97583\">    =</span><span style=\"color:#9ECBFF\"> \"app.kubernetes.io/instance\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CommonLabels returns the standard labels for all owned resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Supports operational integration goal for resource identification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> CommonLabels</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">database</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">component</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ManagedByLabelKey: ManagedByLabelValue,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        NameLabelKey:      </span><span style=\"color:#9ECBFF\">\"database\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ComponentLabelKey: component,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        InstanceLabelKey:  database.Name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetOwnerReference establishes owner reference for garbage collection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Supports reliability goal for automatic cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> SetOwnerReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">owner</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">controlled</span><span style=\"color:#B392F0\"> metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Object</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">scheme</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Scheme</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ctrl.</span><span style=\"color:#B392F0\">SetControllerReference</span><span style=\"color:#E1E4E8\">(owner, controlled, scheme)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ResourceName generates consistent naming for owned resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ResourceName</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">database</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">suffix</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> suffix </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> database.Name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">-</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, database.Name, suffix)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CommonAnnotations returns standard annotations for owned resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> CommonAnnotations</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">database</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"database.example.com/managed-by-operator\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"true\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"database.example.com/owner-generation\"</span><span style=\"color:#E1E4E8\">:   fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, database.Generation),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Database Reconciler (controllers/database/database_controller.go)</strong> - Core logic that learners implement:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> database</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    appsv1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/apps/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    corev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/core/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/api/errors</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/client</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    databasev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/example/database-operator/apis/database/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/example/database-operator/internal/resources</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    REQUEUE_AFTER_DURATION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FINALIZER_NAME</span><span style=\"color:#F97583\">         =</span><span style=\"color:#9ECBFF\"> \"database.example.com/finalizer\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DatabaseReconciler reconciles a Database object</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseReconciler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    client</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Scheme </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Scheme</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Log    </span><span style=\"color:#B392F0\">logr</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=database.example.com,resources=databases,verbs=get;list;watch;create;update;patch;delete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=database.example.com,resources=databases/status,verbs=get;update;patch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=database.example.com,resources=databases/finalizers,verbs=update</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=get;list;watch;create;update;patch;delete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=\"\",resources=services;configmaps;secrets,verbs=get;list;watch;create;update;patch;delete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=\"\",resources=persistentvolumeclaims,verbs=get;list;watch;create;update;patch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=\"\",resources=events,verbs=create;patch</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Reconcile implements the main reconciliation logic comparing desired vs actual state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Reconcile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.Log.</span><span style=\"color:#B392F0\">WithValues</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"database\"</span><span style=\"color:#E1E4E8\">, req.NamespacedName)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Fetch the Database resource from the API server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use r.Client.Get() with the req.NamespacedName</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle the case where the resource might have been deleted (errors.IsNotFound)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Handle deletion case if DeletionTimestamp is set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if database.DeletionTimestamp != nil</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If deletion is in progress, call r.handleDeletion() and return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add finalizer if not present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if FINALIZER_NAME is in database.Finalizers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If missing, add it using controllerutil.AddFinalizer and update the resource</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Reconcile owned resources to match desired state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Call r.reconcileStatefulSet(), r.reconcileService(), r.reconcileConfigMap()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Each function should return error if reconciliation fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update status based on current state of owned resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Fetch current StatefulSet status and update database.Status.ReadyReplicas</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set appropriate conditions in database.Status.Conditions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use r.Status().Update() to persist status changes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Determine requeue behavior</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return ctrl.Result{RequeueAfter: REQUEUE_AFTER_DURATION} for periodic reconciliation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return ctrl.Result{} with no requeue if everything is in desired state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return error if reconciliation failed and should be retried with backoff</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleDeletion processes Database resource deletion with cleanup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleDeletion</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">database</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.Log.</span><span style=\"color:#B392F0\">WithValues</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"database\"</span><span style=\"color:#E1E4E8\">, database.Name, </span><span style=\"color:#9ECBFF\">\"namespace\"</span><span style=\"color:#E1E4E8\">, database.Namespace)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Perform cleanup operations before allowing deletion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This might include draining connections, backing up data, etc.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // For this implementation, we rely on owner references for cascade deletion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Remove finalizer to allow deletion to proceed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use controllerutil.RemoveFinalizer() and update the resource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return any errors from the update operation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// reconcileStatefulSet ensures the StatefulSet matches the Database spec</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">reconcileStatefulSet</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">database</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Define desired StatefulSet based on Database spec</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use resources.NewStatefulSet() helper to create desired state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set replica count from database.Spec.Replicas</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set container image from database.Spec.Version</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configure storage from database.Spec.StorageSize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if StatefulSet already exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use r.Client.Get() to fetch existing StatefulSet</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle both \"exists\" and \"not found\" cases</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create StatefulSet if it doesn't exist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set owner reference using resources.SetOwnerReference()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use r.Client.Create() to create the StatefulSet</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update StatefulSet if it exists but doesn't match desired state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Compare existing spec with desired spec</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use r.Client.Update() to apply changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle update conflicts by refetching and retrying</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetupWithManager registers the controller with the manager and configures watches</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetupWithManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mgr</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ctrl.</span><span style=\"color:#B392F0\">NewControllerManagedBy</span><span style=\"color:#E1E4E8\">(mgr).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        For</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">{}).                    </span><span style=\"color:#6A737D\">// Primary resource to watch</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Owns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">appsv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">StatefulSet</span><span style=\"color:#E1E4E8\">{}).                    </span><span style=\"color:#6A737D\">// Watch owned StatefulSets</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Owns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">corev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Service</span><span style=\"color:#E1E4E8\">{}).                        </span><span style=\"color:#6A737D\">// Watch owned Services</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Owns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">corev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ConfigMap</span><span style=\"color:#E1E4E8\">{}).                      </span><span style=\"color:#6A737D\">// Watch owned ConfigMaps</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Owns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">corev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Secret</span><span style=\"color:#E1E4E8\">{}).                         </span><span style=\"color:#6A737D\">// Watch owned Secrets</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Complete</span><span style=\"color:#E1E4E8\">(r)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>Go-Specific Implementation Guidance:</strong></p>\n<ul>\n<li>Use <code>sigs.k8s.io/controller-runtime/pkg/controller/controllerutil</code> for finalizer management (<code>AddFinalizer</code>, <code>RemoveFinalizer</code>)</li>\n<li>Import <code>k8s.io/apimachinery/pkg/api/errors</code> for handling API server errors like <code>IsNotFound</code>, <code>IsConflict</code></li>\n<li>Use <code>context.Context</code> throughout for cancellation and timeouts - never ignore the context parameter</li>\n<li>Leverage <code>k8s.io/apimachinery/pkg/types.NamespacedName</code> for resource identification in client calls</li>\n<li>Use <code>sigs.k8s.io/controller-runtime/pkg/log</code> for structured logging with key-value pairs</li>\n<li>Import specific API group packages like <code>appsv1 &quot;k8s.io/api/apps/v1&quot;</code> to avoid conflicts</li>\n</ul>\n<p><strong>Client Usage Patterns:</strong></p>\n<ul>\n<li>Use <code>r.Client.Get(ctx, namespacedName, &amp;resource)</code> for fetching resources</li>\n<li>Use <code>r.Client.Create(ctx, &amp;resource)</code> for creating new resources</li>\n<li>Use <code>r.Client.Update(ctx, &amp;resource)</code> for updating existing resources</li>\n<li>Use <code>r.Status().Update(ctx, &amp;resource)</code> for status-only updates</li>\n<li>Always check <code>errors.IsNotFound(err)</code> when fetching resources that might not exist</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the goals and non-goals framework:</p>\n<p><strong>Validation Command:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Verify project structure matches recommendations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">find</span><span style=\"color:#9ECBFF\"> .</span><span style=\"color:#79B8FF\"> -name</span><span style=\"color:#9ECBFF\"> \"*.go\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> head</span><span style=\"color:#79B8FF\"> -10</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check that generated code compiles</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> mod</span><span style=\"color:#9ECBFF\"> tidy</span><span style=\"color:#E1E4E8\"> &#x26;&#x26; </span><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> build</span><span style=\"color:#9ECBFF\"> ./cmd/manager</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify RBAC markers are present</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">grep</span><span style=\"color:#79B8FF\"> -r</span><span style=\"color:#9ECBFF\"> \"kubebuilder:rbac\"</span><span style=\"color:#9ECBFF\"> controllers/</span></span></code></pre></div>\n\n<p><strong>Expected Behavior:</strong></p>\n<ul>\n<li>Project compiles without errors</li>\n<li>Manager binary starts (may exit due to missing CRDs, but should parse flags)</li>\n<li>RBAC markers generate appropriate permissions</li>\n<li>File structure follows recommended organization</li>\n</ul>\n<p><strong>Signs of Problems:</strong></p>\n<ul>\n<li>Import cycle errors → Check for circular dependencies between packages</li>\n<li>Missing scheme registration → Verify <code>AddToScheme</code> calls in main.go</li>\n<li>RBAC permission errors → Check that controller has necessary resource access</li>\n</ul>\n<p>This implementation guidance translates the high-level goals into actionable development steps while maintaining the boundaries defined in the non-goals section.</p>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (Custom Resource Definition), Milestone 2 (Controller Setup) - this section establishes the foundational architecture that guides CRD design and controller implementation</p>\n</blockquote>\n<p>Building a Kubernetes operator is like constructing a sophisticated automation system that integrates seamlessly with an existing orchestration platform. Think of it as adding a specialized department to a large corporation - the new department must understand the company&#39;s communication protocols, follow established procedures, and coordinate effectively with existing teams while bringing its own domain expertise to automate previously manual processes.</p>\n<p>The operator architecture consists of four primary components that work together to extend Kubernetes with domain-specific automation capabilities. These components - custom resources, controllers, admission webhooks, and supporting infrastructure - form a cohesive system that integrates with the Kubernetes API machinery while maintaining separation of concerns and operational reliability.</p>\n<p><img src=\"/api/project/kubernetes-operator/architecture-doc/asset?path=diagrams%2Foperator-architecture.svg\" alt=\"Operator Architecture Overview\"></p>\n<h3 id=\"component-overview\">Component Overview</h3>\n<p>The operator follows the standard Kubernetes extension pattern, leveraging the platform&#39;s built-in extensibility mechanisms to add new resource types and automated management logic. Understanding how these components interact helps establish the mental model for implementing each piece correctly.</p>\n<p><strong>Custom Resources serve as the API contract</strong> between users and the operator. These are not just data structures - they represent the declarative interface through which users express their desired state for managed applications. The <code>Database</code> custom resource, for example, encapsulates all the configuration parameters needed to describe a database instance, from basic settings like replicas and storage size to advanced configuration like backup schedules and monitoring endpoints.</p>\n<p>The custom resource design follows Kubernetes conventions with distinct <code>spec</code> and <code>status</code> subresources. The <code>spec</code> contains the user&#39;s desired configuration and remains immutable once set (except for explicit updates). The <code>status</code> reflects the current observed state of the managed resources and gets updated continuously by the controller as it reconciles the actual state with the desired state.</p>\n<table>\n<thead>\n<tr>\n<th>Custom Resource Component</th>\n<th>Purpose</th>\n<th>Ownership</th>\n<th>Update Pattern</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DatabaseSpec</code></td>\n<td>User&#39;s desired state declaration</td>\n<td>User via kubectl/API</td>\n<td>Explicit updates only</td>\n</tr>\n<tr>\n<td><code>DatabaseStatus</code></td>\n<td>Controller&#39;s observed state report</td>\n<td>Controller exclusively</td>\n<td>Continuous reconciliation updates</td>\n</tr>\n<tr>\n<td>Metadata annotations</td>\n<td>Operational hints and user labels</td>\n<td>Mixed (user + controller)</td>\n<td>Additive updates</td>\n</tr>\n<tr>\n<td>Finalizers</td>\n<td>Cleanup coordination mechanism</td>\n<td>Controller exclusively</td>\n<td>Added on creation, removed on cleanup completion</td>\n</tr>\n</tbody></table>\n<p><strong>Controllers implement the reconciliation logic</strong> that continuously works to make the actual state match the desired state declared in custom resources. Think of a controller as a tireless system administrator who never sleeps, constantly checking that everything is configured correctly and taking corrective action when things drift from the desired configuration.</p>\n<p>The <code>DatabaseReconciler</code> watches for changes to <code>Database</code> custom resources and responds by examining the current state of all related Kubernetes resources (StatefulSets, Services, ConfigMaps, Secrets) and taking whatever actions are necessary to align them with the specification. This might involve creating new resources, updating existing ones, or cleaning up resources that are no longer needed.</p>\n<p>Controllers operate through an event-driven architecture built on Kubernetes&#39; watch mechanism. Rather than polling for changes, controllers receive notifications when resources are created, updated, or deleted. This allows them to respond quickly to changes while minimizing unnecessary API server load.</p>\n<table>\n<thead>\n<tr>\n<th>Controller Component</th>\n<th>Function</th>\n<th>Input</th>\n<th>Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Informer</code></td>\n<td>Maintains local cache of watched resources</td>\n<td>API server events</td>\n<td>Cached resource state</td>\n</tr>\n<tr>\n<td><code>WorkQueue</code></td>\n<td>Buffers reconciliation requests with rate limiting</td>\n<td>Resource change events</td>\n<td>Serialized reconcile requests</td>\n</tr>\n<tr>\n<td><code>Reconciler</code></td>\n<td>Compares desired vs actual state and takes action</td>\n<td>Reconcile request</td>\n<td>Resource mutations + status updates</td>\n</tr>\n<tr>\n<td><code>EventRecorder</code></td>\n<td>Provides observability into controller actions</td>\n<td>Controller decisions</td>\n<td>Kubernetes events</td>\n</tr>\n</tbody></table>\n<p><strong>Admission Webhooks provide validation and mutation capabilities</strong> that execute during the resource admission process, before resources are stored in etcd. These webhooks act as gatekeepers, ensuring that only valid resources enter the system and automatically applying default values or transformations to improve the user experience.</p>\n<p>Validation webhooks implement business rules that go beyond what can be expressed in OpenAPI schema validation. For example, while the schema can enforce that a storage size is a valid quantity, a validation webhook can enforce that storage size increases are allowed but decreases are prohibited (since they could cause data loss).</p>\n<p>Mutating webhooks enhance the user experience by automatically filling in reasonable defaults and applying organizational policies. When a user creates a <code>Database</code> resource with minimal configuration, the mutating webhook can inject appropriate resource limits, security contexts, and monitoring configurations based on organizational standards.</p>\n<table>\n<thead>\n<tr>\n<th>Webhook Type</th>\n<th>Execution Phase</th>\n<th>Purpose</th>\n<th>Common Use Cases</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Mutating</td>\n<td>Before validation and storage</td>\n<td>Apply defaults and transformations</td>\n<td>Inject resource limits, add labels, set security policies</td>\n</tr>\n<tr>\n<td>Validating</td>\n<td>After mutation, before storage</td>\n<td>Enforce business rules and constraints</td>\n<td>Validate field combinations, check quotas, verify dependencies</td>\n</tr>\n</tbody></table>\n<p><strong>Supporting Infrastructure</strong> provides the operational foundation that enables the core components to function reliably in production environments. This includes observability tools, security configurations, and deployment mechanisms that ensure the operator can be operated safely at scale.</p>\n<p>The infrastructure layer handles cross-cutting concerns like leader election (ensuring only one controller replica actively reconciles resources), TLS certificate management for webhook endpoints, RBAC configuration for secure API access, and monitoring integrations that provide visibility into operator health and performance.</p>\n<h3 id=\"kubernetes-api-integration\">Kubernetes API Integration</h3>\n<p>The operator extends Kubernetes by leveraging the platform&#39;s built-in extensibility mechanisms rather than working around them. This integration approach ensures that the operator feels like a natural part of the Kubernetes ecosystem, with custom resources appearing in <code>kubectl get</code> output, audit logs, and administrative tools just like built-in resources.</p>\n<p><strong>API Server Extension through Custom Resource Definitions</strong> allows the operator to register new resource types that become first-class citizens in the Kubernetes API. When a Custom Resource Definition (CRD) is applied to a cluster, the API server automatically provides REST endpoints for the new resource type, complete with validation, versioning, and all the standard Kubernetes API features.</p>\n<p>The CRD registration process creates API endpoints following Kubernetes conventions: <code>/api/v1/namespaces/{namespace}/databases</code> for namespaced resources or <code>/api/v1/databases</code> for cluster-scoped resources. These endpoints support all standard HTTP verbs (GET, POST, PUT, PATCH, DELETE) and integrate with existing tooling like <code>kubectl</code>, client libraries, and administrative dashboards.</p>\n<blockquote>\n<p><strong>Decision: Namespaced vs Cluster-scoped Resources</strong></p>\n<ul>\n<li><strong>Context</strong>: Database resources could be deployed at namespace level (tenant isolation) or cluster level (shared infrastructure)</li>\n<li><strong>Options Considered</strong>: Namespaced only, cluster-scoped only, hybrid with both types</li>\n<li><strong>Decision</strong>: Namespaced resources with cluster-scoped operator</li>\n<li><strong>Rationale</strong>: Namespaced resources provide tenant isolation and align with Kubernetes RBAC patterns, while cluster-scoped operator deployment simplifies operational management</li>\n<li><strong>Consequences</strong>: Enables multi-tenancy and role-based access control, but requires cluster admin privileges for operator installation</li>\n</ul>\n</blockquote>\n<p><strong>Controller Integration with the Control Plane</strong> follows the established controller pattern used by Kubernetes itself. The operator&#39;s controller uses the same client-go library that built-in controllers use, ensuring consistent behavior and reliability characteristics.</p>\n<p>The controller registers with the API server to watch specific resource types and receives a stream of events (create, update, delete) through efficient long-polling connections. When the connection is interrupted, the client-go library automatically reconnects and reestablishes the watch, ensuring the controller doesn&#39;t miss events during network partitions or API server restarts.</p>\n<p>Controllers maintain an eventually consistent local cache of relevant cluster state through informers. This cache serves two critical purposes: it reduces load on the API server by serving read requests locally, and it provides a consistent snapshot of related resources during reconciliation, preventing race conditions that could occur if the controller made individual API calls for each resource.</p>\n<table>\n<thead>\n<tr>\n<th>API Integration Component</th>\n<th>Purpose</th>\n<th>Kubernetes Integration Point</th>\n<th>Reliability Features</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Custom Resource Definition</td>\n<td>Extends API with new resource types</td>\n<td>API server schema registration</td>\n<td>Version conversion, validation, storage</td>\n</tr>\n<tr>\n<td>Controller Watch Streams</td>\n<td>Receives resource change notifications</td>\n<td>API server watch mechanism</td>\n<td>Automatic reconnection, bookmark events</td>\n</tr>\n<tr>\n<td>Informer Cache</td>\n<td>Local eventually-consistent state replica</td>\n<td>List/watch with resync</td>\n<td>Cache invalidation, index optimization</td>\n</tr>\n<tr>\n<td>Admission Webhooks</td>\n<td>Intercepts resource mutations</td>\n<td>API server admission chain</td>\n<td>Timeout handling, failure policies</td>\n</tr>\n</tbody></table>\n<p><strong>Admission Webhook Integration</strong> occurs within the API server&#39;s request processing pipeline, specifically during the admission phase after authentication and authorization but before persistence to etcd. This timing allows webhooks to validate and transform requests while ensuring that security policies have already been enforced.</p>\n<p>The API server sends admission review requests to webhook endpoints over HTTPS, providing the full context of the operation including the resource being created or updated, the user making the request, and relevant metadata. Webhooks respond with admission review responses that either allow the operation (possibly with modifications) or deny it with an explanatory message.</p>\n<p>Webhook integration requires careful attention to reliability and security. The API server enforces timeout limits on webhook calls to prevent cluster availability issues, and webhook failure policies determine whether failures result in request denial (fail-closed) or request acceptance (fail-open). TLS certificate management ensures secure communication and prevents man-in-the-middle attacks.</p>\n<blockquote>\n<p><strong>Critical Design Insight</strong>: The operator doesn&#39;t replace Kubernetes mechanisms - it extends them. Every interaction goes through standard Kubernetes APIs, ensuring compatibility with existing tools, security policies, and operational procedures.</p>\n</blockquote>\n<p><strong>Event Recording and Observability</strong> integrate with Kubernetes&#39; standard observability mechanisms to provide visibility into operator actions. When the controller takes actions like creating StatefulSets or handling errors, it records events that appear in <code>kubectl describe</code> output and cluster monitoring systems.</p>\n<p>The controller uses the Kubernetes event recording mechanism to document its decision-making process, providing an audit trail of actions taken during reconciliation. These events help both users and operators understand why certain actions were taken and provide debugging information when things don&#39;t work as expected.</p>\n<h3 id=\"recommended-project-structure\">Recommended Project Structure</h3>\n<p>Organizing the operator codebase follows established Go and Kubernetes conventions that promote maintainability, testing, and collaboration. The structure separates concerns clearly while keeping related functionality together, making it easier for team members to understand and modify the system.</p>\n<p><strong>Top-Level Organization</strong> follows the standard Go project layout with <code>cmd/</code> for executable entry points, <code>internal/</code> for private implementation code, and <code>api/</code> for public API definitions. This structure makes it immediately clear what parts of the codebase are intended for external consumption versus internal implementation details.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>database-operator/\n├── cmd/\n│   └── manager/\n│       └── main.go                 ← Operator entry point with flag parsing and setup\n├── api/\n│   └── v1/\n│       ├── database_types.go       ← Database custom resource definition\n│       ├── groupversion_info.go    ← API group and version metadata\n│       └── zz_generated.deepcopy.go ← Generated code (do not edit)\n├── internal/\n│   └── controller/\n│       ├── database_controller.go  ← DatabaseReconciler implementation\n│       └── database_controller_test.go ← Controller unit tests\n├── config/\n│   ├── crd/\n│   │   └── bases/                  ← Generated CRD manifests\n│   ├── rbac/                       ← RBAC role definitions\n│   ├── webhook/                    ← Webhook configuration manifests\n│   └── manager/                    ← Controller manager deployment\n└── webhooks/\n    ├── database_defaulting.go      ← Mutating webhook implementation\n    ├── database_validation.go      ← Validating webhook implementation\n    └── webhook_suite_test.go       ← Webhook integration tests</code></pre></div>\n\n<p><strong>API Package Organization</strong> separates the public API definitions from the implementation logic, making it easier to generate client libraries and ensuring that API changes are deliberate and well-considered. The <code>api/v1/</code> package contains only type definitions and generated code, with no business logic.</p>\n<p>The API package structure supports versioning from the beginning, even if only one version exists initially. This forward-thinking approach makes it much easier to add new API versions later without requiring major refactoring. The versioned packages also align with Kubernetes&#39; own API organization patterns.</p>\n<table>\n<thead>\n<tr>\n<th>Directory</th>\n<th>Contents</th>\n<th>Ownership</th>\n<th>Generation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>api/v1/</code></td>\n<td>Type definitions and API metadata</td>\n<td>Manual implementation</td>\n<td>Partial (deepcopy methods)</td>\n</tr>\n<tr>\n<td><code>config/crd/bases/</code></td>\n<td>CRD YAML manifests</td>\n<td>Generated from Go types</td>\n<td>Fully generated</td>\n</tr>\n<tr>\n<td><code>config/rbac/</code></td>\n<td>Role and RoleBinding manifests</td>\n<td>Manual configuration</td>\n<td>Manual</td>\n</tr>\n<tr>\n<td><code>config/webhook/</code></td>\n<td>Webhook configuration YAML</td>\n<td>Generated with manual TLS setup</td>\n<td>Mixed</td>\n</tr>\n</tbody></table>\n<p><strong>Internal Package Structure</strong> organizes implementation code by function rather than by layer, keeping related functionality together. The <code>internal/controller/</code> package contains all controller-related logic, while webhook implementations live in a separate <code>webhooks/</code> package at the top level (since they may be shared across multiple operators).</p>\n<p>Controller organization separates the reconciliation logic from the Kubernetes integration machinery. The controller file focuses on the business logic of comparing desired state with actual state and deciding what actions to take. Integration concerns like informer setup, work queue configuration, and manager registration are handled in setup functions that keep the core reconciliation logic clean and testable.</p>\n<blockquote>\n<p><strong>Decision: Single Package vs Multi-Package Controller Organization</strong></p>\n<ul>\n<li><strong>Context</strong>: Controller code can be organized in one package or split across multiple packages by concern</li>\n<li><strong>Options Considered</strong>: Single controller package, separate packages for reconciler/setup/types, layered packages</li>\n<li><strong>Decision</strong>: Single controller package with clear function separation</li>\n<li><strong>Rationale</strong>: Reduces cognitive overhead for small-to-medium operators, keeps related code together, aligns with controller-runtime patterns</li>\n<li><strong>Consequences</strong>: May need refactoring if controller grows very large, but provides simpler navigation and testing</li>\n</ul>\n</blockquote>\n<p><strong>Configuration and Deployment Structure</strong> separates generated manifests from manually maintained configuration, making it clear what should be edited directly versus what gets regenerated from code. The <code>config/</code> directory contains all Kubernetes manifests needed to deploy the operator, organized by function.</p>\n<p>The configuration structure supports both development and production deployments through Kustomize overlays. The base configuration in <code>config/</code> provides a working deployment that can be customized for specific environments without modifying the original files. This approach enables GitOps workflows where environment-specific configurations are maintained in separate repositories or directories.</p>\n<p><strong>Testing Organization</strong> co-locates unit tests with the code they test while providing separate integration test suites that exercise the full system. Controller unit tests focus on the reconciliation logic using fake clients, while integration tests in the <code>webhooks/</code> package exercise the full admission webhook flow including TLS certificate handling.</p>\n<p>The testing structure supports both fast unit testing during development and comprehensive integration testing in CI/CD pipelines. Unit tests can run without a Kubernetes cluster and complete in seconds, while integration tests use envtest to run against a real API server but still complete quickly enough for regular execution.</p>\n<table>\n<thead>\n<tr>\n<th>Test Type</th>\n<th>Location</th>\n<th>Dependencies</th>\n<th>Execution Time</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unit Tests</td>\n<td><code>*_test.go</code> next to implementation</td>\n<td>Fake clients only</td>\n<td>&lt; 1 second per test</td>\n</tr>\n<tr>\n<td>Controller Integration</td>\n<td><code>internal/controller/suite_test.go</code></td>\n<td>envtest with real API server</td>\n<td>&lt; 10 seconds per test</td>\n</tr>\n<tr>\n<td>Webhook Integration</td>\n<td><code>webhooks/webhook_suite_test.go</code></td>\n<td>envtest with webhook server</td>\n<td>&lt; 15 seconds per test</td>\n</tr>\n<tr>\n<td>End-to-End Tests</td>\n<td><code>test/e2e/</code></td>\n<td>Full cluster deployment</td>\n<td>1-5 minutes per test</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Mixing API definitions with implementation logic</strong> - New operator developers often put business logic directly in the API package alongside type definitions. This creates circular dependencies and makes it difficult to generate clean client libraries. Keep the <code>api/</code> package focused solely on type definitions and generated code. Business logic belongs in <code>internal/controller/</code> or other implementation packages.</p>\n<p>⚠️ <strong>Pitfall: Ignoring the controller-runtime project structure</strong> - The controller-runtime framework expects a specific project organization, and deviating from it breaks code generation and scaffolding tools. Use <code>kubebuilder init</code> to create the initial project structure and follow the conventions it establishes. This ensures compatibility with the broader Kubernetes tooling ecosystem.</p>\n<p>⚠️ <strong>Pitfall: Not planning for API versioning from the start</strong> - Even if you only need one API version initially, organizing code as if multiple versions will exist makes future evolution much easier. Create the <code>api/v1/</code> package structure immediately rather than using an unversioned <code>api/</code> package that will require refactoring later.</p>\n<p>⚠️ <strong>Pitfall: Coupling controllers too tightly to specific custom resources</strong> - Controllers should be designed to work with interface types when possible, making them more testable and reusable. Avoid directly importing custom resource types in controller business logic; instead, define interfaces that capture the required behavior and use type assertions only at the boundaries.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The architecture implementation follows cloud-native patterns and leverages the controller-runtime framework to minimize boilerplate code while maintaining flexibility for customization.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Project Scaffolding</td>\n<td>Kubebuilder v3 with default settings</td>\n<td>Operator SDK with custom templates</td>\n</tr>\n<tr>\n<td>API Code Generation</td>\n<td>controller-gen with basic markers</td>\n<td>controller-gen with comprehensive OpenAPI markers</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>Ginkgo/Gomega with envtest</td>\n<td>Ginkgo/Gomega with real cluster integration</td>\n</tr>\n<tr>\n<td>Configuration Management</td>\n<td>Kustomize with simple overlays</td>\n<td>Helm with complex value templating</td>\n</tr>\n<tr>\n<td>Observability</td>\n<td>Standard Go logging with controller-runtime</td>\n<td>Structured logging with Prometheus metrics</td>\n</tr>\n</tbody></table>\n<h4 id=\"file-structure-setup\">File Structure Setup</h4>\n<p>Initialize the project structure using kubebuilder to ensure alignment with Kubernetes conventions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Initialize project with domain and repository</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubebuilder</span><span style=\"color:#9ECBFF\"> init</span><span style=\"color:#79B8FF\"> --domain</span><span style=\"color:#9ECBFF\"> example.com</span><span style=\"color:#79B8FF\"> --repo</span><span style=\"color:#9ECBFF\"> github.com/yourorg/database-operator</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create API and controller scaffolding</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubebuilder</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#9ECBFF\"> api</span><span style=\"color:#79B8FF\"> --group</span><span style=\"color:#9ECBFF\"> database</span><span style=\"color:#79B8FF\"> --version</span><span style=\"color:#9ECBFF\"> v1</span><span style=\"color:#79B8FF\"> --kind</span><span style=\"color:#9ECBFF\"> Database</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create webhook scaffolding</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubebuilder</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#9ECBFF\"> webhook</span><span style=\"color:#79B8FF\"> --group</span><span style=\"color:#9ECBFF\"> database</span><span style=\"color:#79B8FF\"> --version</span><span style=\"color:#9ECBFF\"> v1</span><span style=\"color:#79B8FF\"> --kind</span><span style=\"color:#9ECBFF\"> Database</span><span style=\"color:#79B8FF\"> --defaulting</span><span style=\"color:#79B8FF\"> --programmatic-validation</span></span></code></pre></div>\n\n<h4 id=\"core-type-definitions\">Core Type Definitions</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// api/v1/database_types.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> v1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metav1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/apis/meta/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DatabaseSpec defines the desired state of Database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseSpec</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Replicas is the number of database instances to run</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +kubebuilder:validation:Minimum=1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +kubebuilder:validation:Maximum=10</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +kubebuilder:default=1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Replicas </span><span style=\"color:#F97583\">int32</span><span style=\"color:#9ECBFF\"> `json:\"replicas,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Version specifies the database version to deploy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +kubebuilder:validation:Pattern=^[0-9]+\\.[0-9]+\\.[0-9]+$</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Version </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"version\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // StorageSize defines the persistent storage size for each replica</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +kubebuilder:validation:Pattern=^[0-9]+[KMGT]i$</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StorageSize </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"storageSize\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add configuration fields like backup schedule, monitoring settings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add networking configuration for service exposure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add security settings like TLS and authentication</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DatabaseStatus defines the observed state of Database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseStatus</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Conditions represent the latest available observations of the database state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Conditions []</span><span style=\"color:#B392F0\">metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Condition</span><span style=\"color:#9ECBFF\"> `json:\"conditions,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ReadyReplicas is the number of database instances that are ready to serve requests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ReadyReplicas </span><span style=\"color:#F97583\">int32</span><span style=\"color:#9ECBFF\"> `json:\"readyReplicas,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ObservedGeneration reflects the generation of the most recently observed Database spec</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObservedGeneration </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\"> `json:\"observedGeneration,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add status fields for backup status, connection endpoints</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add metrics like storage usage, connection count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// +kubebuilder:object:root=true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// +kubebuilder:subresource:status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// +kubebuilder:printcolumn:name=\"Replicas\",type=\"integer\",JSONPath=\".spec.replicas\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// +kubebuilder:printcolumn:name=\"Ready\",type=\"integer\",JSONPath=\".status.readyReplicas\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// +kubebuilder:printcolumn:name=\"Version\",type=\"string\",JSONPath=\".spec.version\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Database is the Schema for the databases API</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Database</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TypeMeta</span><span style=\"color:#9ECBFF\">   `json:\",inline\"`</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ObjectMeta</span><span style=\"color:#9ECBFF\"> `json:\"metadata,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Spec   </span><span style=\"color:#B392F0\">DatabaseSpec</span><span style=\"color:#9ECBFF\">   `json:\"spec,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status </span><span style=\"color:#B392F0\">DatabaseStatus</span><span style=\"color:#9ECBFF\"> `json:\"status,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// +kubebuilder:object:root=true</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DatabaseList contains a list of Database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseList</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TypeMeta</span><span style=\"color:#9ECBFF\"> `json:\",inline\"`</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ListMeta</span><span style=\"color:#9ECBFF\"> `json:\"metadata,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Items           []</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#9ECBFF\"> `json:\"items\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> init</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SchemeBuilder.</span><span style=\"color:#B392F0\">Register</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">DatabaseList</span><span style=\"color:#E1E4E8\">{})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"controller-foundation\">Controller Foundation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/controller/database_controller.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> controller</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/client</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    databasev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/yourorg/database-operator/api/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    REQUEUE_AFTER_DURATION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FINALIZER_NAME</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"database.example.com/finalizer\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DatabaseReconciler reconciles a Database object</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseReconciler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    client</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Scheme </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Scheme</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// +kubebuilder:rbac:groups=database.example.com,resources=databases,verbs=get;list;watch;create;update;patch;delete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// +kubebuilder:rbac:groups=database.example.com,resources=databases/status,verbs=get;update;patch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// +kubebuilder:rbac:groups=database.example.com,resources=databases/finalizers,verbs=update</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// +kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=get;list;watch;create;update;patch;delete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// +kubebuilder:rbac:groups=\"\",resources=services,verbs=get;list;watch;create;update;patch;delete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// +kubebuilder:rbac:groups=\"\",resources=configmaps,verbs=get;list;watch;create;update;patch;delete</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Reconcile compares the state specified by the Database object against the actual cluster state,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// and performs operations to make the cluster state reflect the state specified by the user.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Reconcile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> log.</span><span style=\"color:#B392F0\">FromContext</span><span style=\"color:#E1E4E8\">(ctx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Fetch the Database instance from the cluster</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Handle deletion by checking if DeletionTimestamp is set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add finalizer if not present to ensure cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Reconcile StatefulSet to match spec.replicas and spec.version</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Reconcile Service for database connectivity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Reconcile ConfigMap with database configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update Database status with current ready replicas and conditions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Return appropriate requeue strategy based on current state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Reconciling Database\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"database\"</span><span style=\"color:#E1E4E8\">, req.NamespacedName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">{RequeueAfter: REQUEUE_AFTER_DURATION}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetupWithManager sets up the controller with the Manager.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetupWithManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mgr</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ctrl.</span><span style=\"color:#B392F0\">NewControllerManagedBy</span><span style=\"color:#E1E4E8\">(mgr).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        For</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">{}).</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Add watches for owned resources (StatefulSet, Service, ConfigMap)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Configure predicates to filter unnecessary reconciliation triggers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Set up event handler for better observability</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Complete</span><span style=\"color:#E1E4E8\">(r)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"webhook-skeleton\">Webhook Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// webhooks/database_validation.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> webhooks</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/webhook</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/webhook/admission</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    databasev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/yourorg/database-operator/api/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// +kubebuilder:webhook:path=/validate-database-example-com-v1-database,mutating=false,failurePolicy=fail,groups=database.example.com,resources=databases,verbs=create;update,versions=v1,name=vdatabase.kb.io,sideEffects=None,admissionReviewVersions=v1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DatabaseValidator validates Database resources using custom business rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseValidator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateCreate implements webhook.Validator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateCreate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">obj</span><span style=\"color:#B392F0\"> runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Object</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">admission</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Warnings</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    database </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> obj.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate that storage size is not below minimum threshold</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate that version string matches supported database versions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate that replica count doesn't exceed cluster capacity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check for naming conflicts with existing databases</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateUpdate implements webhook.Validator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateUpdate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">oldObj</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">newObj</span><span style=\"color:#B392F0\"> runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Object</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">admission</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Warnings</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newDatabase </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> newObj.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    oldDatabase </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> oldObj.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Prevent storage size decreases that could cause data loss</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate version upgrade paths (no downgrades, supported migrations)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Ensure replica count changes are within acceptable bounds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateDelete implements webhook.Validator  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateDelete</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">obj</span><span style=\"color:#B392F0\"> runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Object</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">admission</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Warnings</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if database contains data that should be backed up</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate that dependent applications are prepared for deletion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetupWebhookWithManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mgr</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ctrl.</span><span style=\"color:#B392F0\">NewWebhookManagedBy</span><span style=\"color:#E1E4E8\">(mgr).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        For</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">{}).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        WithValidator</span><span style=\"color:#E1E4E8\">(v).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Complete</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-development-tips\">Language-Specific Development Tips</h4>\n<p><strong>Go-Specific Implementation Guidance:</strong></p>\n<ul>\n<li>Use <code>sigs.k8s.io/controller-runtime/pkg/client</code> for all Kubernetes API interactions - it provides automatic retries and rate limiting</li>\n<li>Leverage <code>k8s.io/apimachinery/pkg/api/errors</code> for proper error handling that distinguishes between different failure types</li>\n<li>Use <code>controllerutil.SetControllerReference</code> to establish owner relationships that enable garbage collection</li>\n<li>Implement the <code>Defaulter</code> and <code>Validator</code> interfaces on your custom resource types for webhook functionality</li>\n<li>Use <code>k8s.io/utils/pointer</code> for safely creating pointers to primitive values in Kubernetes objects</li>\n</ul>\n<p><strong>RBAC Configuration Guidelines:</strong>\nThe generated RBAC markers in the controller comments will create appropriate permissions, but verify that they include:</p>\n<ul>\n<li>Read/write access to your custom resources and their status subresources</li>\n<li>Read/write access to all Kubernetes resources your controller manages (StatefulSets, Services, etc.)</li>\n<li>Read access to resources you need to watch but don&#39;t own (Nodes, StorageClasses for validation)</li>\n</ul>\n<p><strong>Debugging and Development Workflow:</strong></p>\n<ol>\n<li>Run <code>make generate</code> after modifying API types to regenerate deepcopy methods</li>\n<li>Run <code>make manifests</code> to regenerate CRDs and RBAC from code annotations  </li>\n<li>Use <code>make install</code> to apply CRDs to your development cluster</li>\n<li>Test controller logic with <code>make run</code> for local development with real cluster access</li>\n<li>Use <code>make docker-build</code> and <code>make deploy</code> for full integration testing in the cluster</li>\n</ol>\n<h2 id=\"data-model-and-custom-resources\">Data Model and Custom Resources</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (Custom Resource Definition), Milestone 3 (Reconciliation Loop) - defines the API schema and status structures that the controller reconciles, and Milestone 4 (Webhooks) - establishes validation rules enforced by admission control</p>\n</blockquote>\n<h3 id=\"mental-model-the-application-blueprint\">Mental Model: The Application Blueprint</h3>\n<p>Think of a <strong>custom resource definition</strong> as an architectural blueprint for buildings. Just as a blueprint defines the structure, dimensions, materials, and specifications that every building of that type must follow, a CRD defines the schema, validation rules, and structural requirements that every instance of your custom resource must conform to. The blueprint doesn&#39;t create buildings—it defines what valid buildings look like. Similarly, the CRD doesn&#39;t create application instances—it defines what valid application configurations look like.</p>\n<p>When an architect designs a blueprint, they specify required elements (foundation, load-bearing walls), optional elements (balconies, decorative features), and validation rules (minimum ceiling height, maximum occupancy). The CRD schema works the same way: it specifies required fields that every resource must have, optional fields that provide additional configuration, and validation rules that prevent invalid configurations from being accepted.</p>\n<p>The <strong>status subresource</strong> acts like a building inspector&#39;s report. While the blueprint (spec) describes what the building should look like, the inspector&#39;s report (status) describes the current state of construction: which floors are complete, what problems have been encountered, and whether the building is ready for occupancy. Just as the architect doesn&#39;t write the inspector&#39;s report, users don&#39;t directly modify the status—only the controller (acting as the inspector) updates the status based on what it observes.</p>\n<p><img src=\"/api/project/kubernetes-operator/architecture-doc/asset?path=diagrams%2Fcrd-data-model.svg\" alt=\"Custom Resource Data Model\"></p>\n<p>The data model forms the contract between users who describe their desired application state and controllers that make that state reality. This contract must be precise enough to prevent ambiguous configurations, flexible enough to accommodate diverse use cases, and evolvable enough to support future requirements without breaking existing deployments.</p>\n<h3 id=\"custom-resource-definition-schema\">Custom Resource Definition Schema</h3>\n<p>The OpenAPI v3 schema structure defines the shape and validation rules for custom resources. Unlike simple configuration files, CRD schemas provide strong typing, comprehensive validation, and automatic documentation generation. The schema serves multiple purposes: it validates user input at the API level, generates client code for type-safe programming, provides auto-completion in kubectl and IDEs, and documents the API for users and operators.</p>\n<p><strong>Database Custom Resource Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>apiVersion</code></td>\n<td>string</td>\n<td>Yes</td>\n<td>Always &quot;example.com/v1&quot; for this resource type</td>\n</tr>\n<tr>\n<td><code>kind</code></td>\n<td>string</td>\n<td>Yes</td>\n<td>Always &quot;Database&quot; for this resource type</td>\n</tr>\n<tr>\n<td><code>metadata</code></td>\n<td>ObjectMeta</td>\n<td>Yes</td>\n<td>Standard Kubernetes metadata including name, namespace, labels, annotations</td>\n</tr>\n<tr>\n<td><code>spec</code></td>\n<td>DatabaseSpec</td>\n<td>Yes</td>\n<td>User-specified desired state configuration</td>\n</tr>\n<tr>\n<td><code>status</code></td>\n<td>DatabaseStatus</td>\n<td>No</td>\n<td>Controller-managed current state information</td>\n</tr>\n</tbody></table>\n<p>The separation between <code>spec</code> and <code>status</code> reflects Kubernetes&#39; declarative model. Users declare their intent in the spec, while controllers report reality in the status. This separation enables optimistic concurrency control and clear ownership boundaries.</p>\n<p><strong>DatabaseSpec Field Definitions:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Required</th>\n<th>Validation</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>replicas</code></td>\n<td>int32</td>\n<td>Yes</td>\n<td>minimum: 1, maximum: 10</td>\n<td>Number of database instances to maintain</td>\n</tr>\n<tr>\n<td><code>version</code></td>\n<td>string</td>\n<td>Yes</td>\n<td>pattern: &quot;^[0-9]+\\.[0-9]+\\.[0-9]+$&quot;</td>\n<td>Semantic version of database software</td>\n</tr>\n<tr>\n<td><code>storageSize</code></td>\n<td>string</td>\n<td>Yes</td>\n<td>pattern: &quot;^[0-9]+[KMGT]i?$&quot;</td>\n<td>Storage capacity using Kubernetes quantity format</td>\n</tr>\n<tr>\n<td><code>backupSchedule</code></td>\n<td>string</td>\n<td>No</td>\n<td>pattern: &quot;^(@(annually|yearly|monthly|weekly|daily|hourly|reboot))|(@every (\\d+(ns|us|µs|ms|s|m|h))+)|((\\d+|\\<em>)(/(\\d+))? (\\d+|\\</em>)(/(\\d+))? (\\d+|\\<em>)(/(\\d+))? (\\d+|\\</em>)(/(\\d+))? (\\d+|\\*)(/(\\d+))?)$&quot;</td>\n<td>Optional cron expression for automated backups</td>\n</tr>\n<tr>\n<td><code>resources</code></td>\n<td>ResourceRequirements</td>\n<td>No</td>\n<td>-</td>\n<td>CPU and memory resource requests and limits</td>\n</tr>\n<tr>\n<td><code>config</code></td>\n<td>map[string]string</td>\n<td>No</td>\n<td>maxProperties: 20</td>\n<td>Database-specific configuration parameters</td>\n</tr>\n</tbody></table>\n<p>The validation patterns serve as compile-time checks that prevent invalid configurations from entering the system. The <code>version</code> field uses semantic versioning to ensure upgrade compatibility. The <code>storageSize</code> field accepts Kubernetes quantity formats like &quot;10Gi&quot; or &quot;500Mi&quot; for consistency with other Kubernetes resources.</p>\n<p><strong>DatabaseStatus Field Definitions:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>conditions</code></td>\n<td>[]Condition</td>\n<td>No</td>\n<td>Array of condition objects describing the current state</td>\n</tr>\n<tr>\n<td><code>readyReplicas</code></td>\n<td>int32</td>\n<td>No</td>\n<td>Number of database instances currently serving traffic</td>\n</tr>\n<tr>\n<td><code>observedGeneration</code></td>\n<td>int64</td>\n<td>No</td>\n<td>Generation of spec that was last processed by controller</td>\n</tr>\n<tr>\n<td><code>phase</code></td>\n<td>string</td>\n<td>No</td>\n<td>High-level status: Pending, Running, Failed, Terminating</td>\n</tr>\n<tr>\n<td><code>lastBackupTime</code></td>\n<td>*metav1.Time</td>\n<td>No</td>\n<td>Timestamp of most recent successful backup</td>\n</tr>\n<tr>\n<td><code>endpoints</code></td>\n<td>[]string</td>\n<td>No</td>\n<td>Connection endpoints for client applications</td>\n</tr>\n<tr>\n<td><code>message</code></td>\n<td>string</td>\n<td>No</td>\n<td>Human-readable message describing current status</td>\n</tr>\n</tbody></table>\n<p>The <code>observedGeneration</code> field enables controllers to track whether they&#39;ve processed the latest spec changes. When <code>metadata.generation</code> exceeds <code>status.observedGeneration</code>, the controller knows new changes are pending. The <code>conditions</code> array provides detailed status information that tools like kubectl can interpret and display.</p>\n<p><strong>Condition Structure for Status Reporting:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>type</code></td>\n<td>string</td>\n<td>Yes</td>\n<td>Condition type: Ready, Available, Progressing, Degraded</td>\n</tr>\n<tr>\n<td><code>status</code></td>\n<td>string</td>\n<td>Yes</td>\n<td>Condition status: True, False, Unknown</td>\n</tr>\n<tr>\n<td><code>lastTransitionTime</code></td>\n<td>metav1.Time</td>\n<td>Yes</td>\n<td>Time when condition last changed status</td>\n</tr>\n<tr>\n<td><code>reason</code></td>\n<td>string</td>\n<td>Yes</td>\n<td>Machine-readable reason code for the condition</td>\n</tr>\n<tr>\n<td><code>message</code></td>\n<td>string</td>\n<td>Yes</td>\n<td>Human-readable message explaining the condition</td>\n</tr>\n<tr>\n<td><code>observedGeneration</code></td>\n<td>int64</td>\n<td>No</td>\n<td>Generation when this condition was last updated</td>\n</tr>\n</tbody></table>\n<p>Conditions provide structured status information that both humans and machines can interpret. The <code>Ready</code> condition indicates whether the resource is fully operational. The <code>Available</code> condition indicates whether the resource is accepting traffic. The <code>Progressing</code> condition indicates whether changes are being applied. The <code>Degraded</code> condition indicates whether the resource is running but with reduced functionality.</p>\n<blockquote>\n<p><strong>Decision: Status Subresource Separation</strong></p>\n<ul>\n<li><strong>Context</strong>: Controllers need to update status independently from user spec changes to avoid conflicts</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Store status in spec alongside user fields</li>\n<li>Use separate status subresource with independent update path</li>\n<li>Store status in annotations or separate custom resources</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use separate status subresource with independent update path</li>\n<li><strong>Rationale</strong>: Prevents update conflicts between user changes and controller status updates, enables proper RBAC separation, follows Kubernetes conventions</li>\n<li><strong>Consequences</strong>: Requires two API calls for create+status update, but eliminates race conditions and follows established patterns</li>\n</ul>\n</blockquote>\n<h3 id=\"validation-and-defaulting-strategy\">Validation and Defaulting Strategy</h3>\n<p>Kubernetes provides multiple layers of validation and defaulting that work together to ensure resource integrity. These layers operate at different points in the request lifecycle, each serving specific purposes and handling different classes of validation problems.</p>\n<p><strong>Schema-Level Validation</strong> occurs first, using OpenAPI v3 schema definitions embedded in the CRD. This validation runs inside the API server and provides basic type checking, format validation, and structural constraints. Schema validation is fast and deterministic but limited to single-field constraints and simple cross-field relationships.</p>\n<p><strong>Admission Webhook Validation</strong> provides custom business logic validation that can examine the entire resource, query external systems, and enforce complex cross-field constraints. Validating admission webhooks receive the complete resource and can reject requests with detailed error messages. This validation is more flexible but requires additional infrastructure and introduces latency and availability dependencies.</p>\n<p><strong>Common Expression Language (CEL) Validation</strong> bridges the gap between schema validation and webhook validation. CEL expressions run inside the API server but can access multiple fields and perform complex logic. CEL provides better performance than webhooks while supporting more sophisticated validation than basic schema constraints.</p>\n<p><strong>Validation Strategy Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Validation Type</th>\n<th>Performance</th>\n<th>Complexity</th>\n<th>Use Cases</th>\n<th>Failure Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OpenAPI Schema</td>\n<td>Fastest</td>\n<td>Low</td>\n<td>Type checking, format validation, required fields</td>\n<td>Request rejected immediately</td>\n</tr>\n<tr>\n<td>CEL Expressions</td>\n<td>Fast</td>\n<td>Medium</td>\n<td>Cross-field validation, business rules</td>\n<td>Request rejected immediately</td>\n</tr>\n<tr>\n<td>Admission Webhooks</td>\n<td>Slower</td>\n<td>High</td>\n<td>External validation, complex business logic</td>\n<td>Request rejected or webhook timeout</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Layered Validation Approach</strong></p>\n<ul>\n<li><strong>Context</strong>: Need comprehensive validation without sacrificing performance or availability</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Schema validation only for maximum performance</li>\n<li>Webhook validation only for maximum flexibility  </li>\n<li>Layered approach combining schema, CEL, and selective webhook validation</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Layered approach combining all three validation mechanisms</li>\n<li><strong>Rationale</strong>: Schema catches basic errors fast, CEL handles cross-field logic efficiently, webhooks reserved for complex cases requiring external data</li>\n<li><strong>Consequences</strong>: More complex validation setup, but better user experience and system reliability</li>\n</ul>\n</blockquote>\n<p><strong>CEL Expression Examples for Database Resource:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field Combination</th>\n<th>CEL Expression</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Replicas and Storage</td>\n<td>`self.replicas &lt;= 3</td>\n<td></td>\n</tr>\n<tr>\n<td>Version and Config</td>\n<td><code>self.version.startsWith(&#39;5.&#39;) ? !has(self.config.legacy_mode) : true</code></td>\n<td>Prevent legacy configuration on modern versions</td>\n</tr>\n<tr>\n<td>Backup Schedule</td>\n<td><code>has(self.backupSchedule) ? self.replicas &gt;= 2 : true</code></td>\n<td>Require multiple replicas when backups are enabled</td>\n</tr>\n<tr>\n<td>Resource Limits</td>\n<td><code>has(self.resources.limits.memory) ? self.resources.limits.memory &gt;= self.resources.requests.memory : true</code></td>\n<td>Ensure limits are not less than requests</td>\n</tr>\n</tbody></table>\n<p>CEL expressions have access to the entire resource through <code>self</code> and can use built-in functions for string manipulation, arithmetic, and collection operations. The expressions must return boolean values, where <code>true</code> means validation passes and <code>false</code> means the request should be rejected.</p>\n<p><strong>Defaulting Strategy Implementation:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Default Value</th>\n<th>Condition</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>replicas</code></td>\n<td>1</td>\n<td>Always applied if not specified</td>\n<td>Single instance is minimum viable configuration</td>\n</tr>\n<tr>\n<td><code>version</code></td>\n<td>&quot;5.7.0&quot;</td>\n<td>Only for new resources</td>\n<td>Provides stable default for users who don&#39;t specify</td>\n</tr>\n<tr>\n<td><code>storageSize</code></td>\n<td>&quot;10Gi&quot;</td>\n<td>Always applied if not specified</td>\n<td>Reasonable default that works for development and testing</td>\n</tr>\n<tr>\n<td><code>resources.requests.cpu</code></td>\n<td>&quot;100m&quot;</td>\n<td>When resources section exists but cpu not specified</td>\n<td>Prevents resource starvation</td>\n</tr>\n<tr>\n<td><code>resources.requests.memory</code></td>\n<td>&quot;256Mi&quot;</td>\n<td>When resources section exists but memory not specified</td>\n<td>Reasonable baseline for database workloads</td>\n</tr>\n</tbody></table>\n<p>Defaulting occurs through mutating admission webhooks that modify incoming requests before validation. The webhook examines each field and injects appropriate defaults based on the current resource state and user-provided configuration. Defaults are applied only when fields are completely missing, not when they are explicitly set to empty values.</p>\n<p><strong>Validation Webhook Request Processing:</strong></p>\n<ol>\n<li><strong>Request Reception</strong>: Webhook receives AdmissionReview containing the resource and operation type (CREATE, UPDATE)</li>\n<li><strong>Context Extraction</strong>: Extract the Database resource from the admission request payload</li>\n<li><strong>Business Rule Validation</strong>: Apply complex validation rules that span multiple fields or require external data</li>\n<li><strong>Cross-Resource Validation</strong>: Query API server for related resources if validation depends on cluster state</li>\n<li><strong>Response Generation</strong>: Create AdmissionResponse with allowed/denied decision and detailed messages</li>\n<li><strong>Error Handling</strong>: Return structured error responses that kubectl can display meaningfully to users</li>\n</ol>\n<p>The webhook must complete validation within the configured timeout (typically 10-30 seconds) or the API server will fail the request. This timeout constraint requires careful design of validation logic to avoid external dependencies that could cause unpredictable delays.</p>\n<h3 id=\"api-versioning-and-evolution\">API Versioning and Evolution</h3>\n<p>Kubernetes custom resources evolve over time as requirements change, new features are added, and operational experience reveals design improvements. The API versioning system provides backward compatibility while enabling forward progress. Unlike traditional API versioning that maintains separate endpoints, Kubernetes CRDs support multiple versions of the same resource type with automatic conversion between versions.</p>\n<p><strong>Version Evolution Mental Model</strong>: Think of API versioning like building renovation. When you renovate a house, you don&#39;t build a completely separate house—you modify the existing structure while keeping it livable. You might add new rooms (fields), remove outdated fixtures (deprecated fields), or reorganize the layout (restructure data). During renovation, you need temporary bridges or conversion tools so people can move between the old layout and new layout. Similarly, API versioning adds new fields and restructures existing ones while providing conversion mechanisms so existing clients continue working.</p>\n<p><strong>Versioning Strategy Overview:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Version</th>\n<th>Status</th>\n<th>Purpose</th>\n<th>Conversion Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>v1alpha1</td>\n<td>Deprecated</td>\n<td>Initial experimental API</td>\n<td>Yes - to v1beta1 and v1</td>\n</tr>\n<tr>\n<td>v1beta1</td>\n<td>Active</td>\n<td>Stable API with minor additions</td>\n<td>Yes - to v1</td>\n</tr>\n<tr>\n<td>v1</td>\n<td>Storage Version</td>\n<td>Production-ready API</td>\n<td>No - other versions convert to this</td>\n</tr>\n</tbody></table>\n<p>The <strong>storage version</strong> is the canonical representation used in etcd. All other versions are converted to and from the storage version when resources are created, updated, or retrieved. This hub-and-spoke conversion model simplifies the conversion matrix compared to requiring direct conversion between every version pair.</p>\n<blockquote>\n<p><strong>Decision: Hub and Spoke Conversion Model</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to support multiple API versions without exponential conversion complexity</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Direct conversion between every version pair (N² complexity)</li>\n<li>Hub and spoke with storage version as hub (2N complexity)</li>\n<li>Version deprecation forcing users to migrate immediately</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Hub and spoke conversion model with v1 as storage version</li>\n<li><strong>Rationale</strong>: Minimizes conversion code maintenance, provides single source of truth, enables gradual migration</li>\n<li><strong>Consequences</strong>: All versions must be convertible to/from storage version, but total complexity remains manageable</li>\n</ul>\n</blockquote>\n<p><strong>Version Migration Example: v1alpha1 to v1beta1:</strong></p>\n<table>\n<thead>\n<tr>\n<th>v1alpha1 Field</th>\n<th>v1beta1 Field</th>\n<th>Conversion Logic</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>size</code> (string)</td>\n<td><code>replicas</code> (int32)</td>\n<td>Parse string number, convert to int32</td>\n</tr>\n<tr>\n<td><code>dbVersion</code> (string)</td>\n<td><code>version</code> (string)</td>\n<td>Direct field rename, no transformation</td>\n</tr>\n<tr>\n<td><code>storage</code> (string)</td>\n<td><code>storageSize</code> (string)</td>\n<td>Direct field rename, no transformation</td>\n</tr>\n<tr>\n<td><code>backup</code> (bool)</td>\n<td><code>backupSchedule</code> (string)</td>\n<td>If true, default to &quot;@daily&quot;; if false, omit field</td>\n</tr>\n<tr>\n<td>N/A</td>\n<td><code>resources</code> (ResourceRequirements)</td>\n<td>New field, populate with empty object</td>\n</tr>\n</tbody></table>\n<p><strong>Conversion Webhook Architecture:</strong></p>\n<p>The conversion webhook acts as a translator between API versions. When a user requests a resource in version A but it&#39;s stored in version B, the API server sends the stored version to the conversion webhook, which transforms it to the requested version. This process is transparent to clients—they see the version they requested without knowing about storage version differences.</p>\n<p><strong>Conversion Webhook Processing Steps:</strong></p>\n<ol>\n<li><strong>Request Analysis</strong>: Webhook receives ConversionReview with desired version and current resource data</li>\n<li><strong>Version Detection</strong>: Determine source version from resource apiVersion field and target version from request</li>\n<li><strong>Conversion Path Selection</strong>: Choose appropriate conversion function based on source and target versions</li>\n<li><strong>Field Mapping</strong>: Transform fields according to version-specific mapping rules</li>\n<li><strong>Validation</strong>: Ensure converted resource passes target version&#39;s schema validation</li>\n<li><strong>Response Generation</strong>: Return ConversionResponse with converted resource or error details</li>\n</ol>\n<p><strong>Backward Compatibility Guarantees:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Compatibility Type</th>\n<th>Guarantee Level</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Field Addition</td>\n<td>Full</td>\n<td>New optional fields can be added without breaking existing clients</td>\n</tr>\n<tr>\n<td>Field Deprecation</td>\n<td>Gradual</td>\n<td>Deprecated fields continue working with warning messages for at least one version</td>\n</tr>\n<tr>\n<td>Field Removal</td>\n<td>Breaking</td>\n<td>Removed fields cause validation errors and require client updates</td>\n</tr>\n<tr>\n<td>Field Type Change</td>\n<td>Breaking</td>\n<td>Changing field types requires new version and conversion logic</td>\n</tr>\n<tr>\n<td>Default Value Change</td>\n<td>Potentially Breaking</td>\n<td>May affect resources that rely on previous defaults</td>\n</tr>\n</tbody></table>\n<p><strong>Storage Version Migration Process:</strong></p>\n<p>When changing the storage version from v1beta1 to v1, existing resources in etcd must be migrated to the new format. This migration happens lazily—resources are converted when they&#39;re next read or updated—or can be triggered explicitly using the storage version migrator tool.</p>\n<p><strong>Migration State Tracking:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Resource State</th>\n<th>Description</th>\n<th>Action Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Native Storage</td>\n<td>Resource stored in current storage version</td>\n<td>No action needed</td>\n</tr>\n<tr>\n<td>Conversion Pending</td>\n<td>Resource stored in old version, needs conversion on access</td>\n<td>Automatic conversion on read/write</td>\n</tr>\n<tr>\n<td>Conversion Failed</td>\n<td>Resource cannot be converted due to data incompatibility</td>\n<td>Manual intervention required</td>\n</tr>\n<tr>\n<td>Schema Violation</td>\n<td>Converted resource fails new version validation</td>\n<td>Manual correction needed</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Breaking Conversion Assumptions</strong></p>\n<p>A common mistake is assuming that conversion is always reversible. When converting from a newer version to an older version, information loss may occur if the newer version contains fields that don&#39;t exist in the older version. This information loss means that converting v1→v1alpha1→v1 might not produce the same result as the original v1 resource.</p>\n<p><strong>Solution</strong>: Design conversion functions to preserve as much information as possible, use annotations to store unconvertible data, and test round-trip conversions to verify data integrity.</p>\n<p>⚠️ <strong>Pitfall: Storage Version Migration Timing</strong></p>\n<p>Changing the storage version in a CRD immediately affects how new resources are stored, but existing resources remain in their original format until converted. This can create inconsistency where identical resources have different storage representations.</p>\n<p><strong>Solution</strong>: Plan storage version migration carefully, use gradual rollout with monitoring, and consider running explicit migration jobs to convert existing resources proactively rather than waiting for lazy conversion.</p>\n<p><strong>Version Deprecation Process:</strong></p>\n<ol>\n<li><strong>Deprecation Announcement</strong>: Mark version as deprecated in CRD status and release notes</li>\n<li><strong>Warning Generation</strong>: API server returns warning headers when deprecated versions are used</li>\n<li><strong>Grace Period</strong>: Maintain deprecated version for at least two minor releases</li>\n<li><strong>Usage Monitoring</strong>: Track deprecated version usage through metrics and audit logs</li>\n<li><strong>Removal Planning</strong>: Coordinate with users to migrate before version removal</li>\n<li><strong>Final Removal</strong>: Remove deprecated version from CRD and update conversion webhooks</li>\n</ol>\n<p>This structured deprecation process ensures users have adequate time to migrate while providing clear signals about upcoming changes. The warning system allows automated detection of deprecated version usage in continuous integration pipelines and monitoring systems.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Schema Validation</td>\n<td>OpenAPI v3 in CRD manifest</td>\n<td>CEL expressions + admission webhooks</td>\n</tr>\n<tr>\n<td>Defaulting</td>\n<td>Static defaults in CRD schema</td>\n<td>Dynamic defaults via mutating webhook</td>\n</tr>\n<tr>\n<td>Versioning</td>\n<td>Single stable version</td>\n<td>Multiple versions with conversion webhooks</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td>kubectl dry-run validation</td>\n<td>CRD validation test suite with controller-runtime</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>operator-project/\n├── config/\n│   ├── crd/\n│   │   ├── bases/\n│   │   │   └── example.com_databases.yaml     ← Generated CRD manifest\n│   │   └── kustomization.yaml\n│   └── samples/\n│       └── example_v1_database.yaml           ← Example custom resource\n├── api/\n│   └── v1/\n│       ├── database_types.go                   ← Database struct definitions\n│       ├── database_webhook.go                 ← Admission webhook logic\n│       ├── groupversion_info.go               ← API group registration\n│       └── zz_generated.deepcopy.go           ← Generated deep copy methods\n└── internal/\n    └── controller/\n        └── database_controller.go             ← Controller reconciliation logic</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code:</strong></p>\n<p>Complete CRD manifest generation configuration:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// api/v1/database_types.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> v1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metav1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/apis/meta/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/api/resource</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    corev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/core/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DatabaseSpec defines the desired state of Database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseSpec</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +kubebuilder:validation:Minimum=1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +kubebuilder:validation:Maximum=10</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +kubebuilder:default=1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Replicas </span><span style=\"color:#F97583\">int32</span><span style=\"color:#9ECBFF\"> `json:\"replicas\"`</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +kubebuilder:validation:Pattern=\"^[0-9]+\\.[0-9]+\\.[0-9]+$\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +kubebuilder:default=\"5.7.0\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Version </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"version\"`</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +kubebuilder:validation:Pattern=\"^[0-9]+[KMGT]i?$\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +kubebuilder:default=\"10Gi\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StorageSize </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"storageSize\"`</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +kubebuilder:validation:Pattern=\"^(@(annually|yearly|monthly|weekly|daily|hourly|reboot))|(@every (\\\\d+(ns|us|µs|ms|s|m|h))+)|((\\\\d+|\\\\*)(/(\\\\d+))? (\\\\d+|\\\\*)(/(\\\\d+))? (\\\\d+|\\\\*)(/(\\\\d+))? (\\\\d+|\\\\*)(/(\\\\d+))? (\\\\d+|\\\\*)(/(\\\\d+))?)$\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BackupSchedule </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"backupSchedule,omitempty\"`</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Resources </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">corev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResourceRequirements</span><span style=\"color:#9ECBFF\"> `json:\"resources,omitempty\"`</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +kubebuilder:validation:MaxProperties=20</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Config </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"config,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DatabaseStatus defines the observed state of Database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseStatus</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Conditions []</span><span style=\"color:#B392F0\">metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Condition</span><span style=\"color:#9ECBFF\"> `json:\"conditions,omitempty\"`</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ReadyReplicas </span><span style=\"color:#F97583\">int32</span><span style=\"color:#9ECBFF\"> `json:\"readyReplicas,omitempty\"`</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ObservedGeneration </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\"> `json:\"observedGeneration,omitempty\"`</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +kubebuilder:validation:Enum=Pending;Running;Failed;Terminating</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Phase </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"phase,omitempty\"`</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastBackupTime </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"lastBackupTime,omitempty\"`</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Endpoints []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"endpoints,omitempty\"`</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // +optional</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Message </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"message,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:object:root=true</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:subresource:status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:resource:shortName=db</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:printcolumn:name=\"Replicas\",type=integer,JSONPath=`.spec.replicas`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:printcolumn:name=\"Ready\",type=integer,JSONPath=`.status.readyReplicas`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:printcolumn:name=\"Version\",type=string,JSONPath=`.spec.version`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:printcolumn:name=\"Phase\",type=string,JSONPath=`.status.phase`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:printcolumn:name=\"Age\",type=date,JSONPath=`.metadata.creationTimestamp`</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Database is the Schema for the databases API</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Database</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TypeMeta</span><span style=\"color:#9ECBFF\">   `json:\",inline\"`</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ObjectMeta</span><span style=\"color:#9ECBFF\"> `json:\"metadata,omitempty\"`</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Spec   </span><span style=\"color:#B392F0\">DatabaseSpec</span><span style=\"color:#9ECBFF\">   `json:\"spec,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status </span><span style=\"color:#B392F0\">DatabaseStatus</span><span style=\"color:#9ECBFF\"> `json:\"status,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:object:root=true</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DatabaseList contains a list of Database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseList</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TypeMeta</span><span style=\"color:#9ECBFF\"> `json:\",inline\"`</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ListMeta</span><span style=\"color:#9ECBFF\"> `json:\"metadata,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Items           []</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#9ECBFF\"> `json:\"items\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> init</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SchemeBuilder.</span><span style=\"color:#B392F0\">Register</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">DatabaseList</span><span style=\"color:#E1E4E8\">{})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code:</strong></p>\n<p>Admission webhook implementation template:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// api/v1/database_webhook.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> v1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    apierrors </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/api/errors</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime/schema</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/util/validation/field</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/webhook</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetupWebhookWithManager registers the webhook with the manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetupWebhookWithManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mgr</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ctrl.</span><span style=\"color:#B392F0\">NewWebhookManagedBy</span><span style=\"color:#E1E4E8\">(mgr).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        For</span><span style=\"color:#E1E4E8\">(r).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Complete</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:webhook:path=/mutate-example-com-v1-database,mutating=true,failurePolicy=fail,sideEffects=None,groups=example.com,resources=databases,verbs=create;update,versions=v1,name=mdatabase.kb.io,admissionReviewVersions=v1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#B392F0\">webhook</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Defaulter</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Default implements webhook.Defaulter so a webhook will be registered for the type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Default</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Set default replica count if not specified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set default version if not specified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set default storage size if not specified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Set default resource requests if resources specified but requests missing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use pointer fields to detect when values are not set vs set to zero</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:webhook:path=/validate-example-com-v1-database,mutating=false,failurePolicy=fail,sideEffects=None,groups=example.com,resources=databases,verbs=create;update,versions=v1,name=vdatabase.kb.io,admissionReviewVersions=v1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#B392F0\">webhook</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Validator</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateCreate implements webhook.Validator so a webhook will be registered for the type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateCreate</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate replica count is reasonable for storage size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate version format and ensure it's a supported version</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate backup schedule cron expression if provided</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate resource requests are less than or equal to limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Validate configuration parameters are valid for the specified version</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">validateDatabase</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateUpdate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">old</span><span style=\"color:#B392F0\"> runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Object</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    oldDB </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> old.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Prevent downgrading to older versions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Prevent reducing storage size (data loss risk)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate replica count changes are within safe limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Ensure configuration changes are compatible with current version</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">validateDatabase</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateDelete implements webhook.Validator so a webhook will be registered for the type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateDelete</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if database has active connections (would require external check)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify backup is recent if backup schedule is configured</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Implement additional deletion safety checks as needed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">validateDatabase</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> allErrs </span><span style=\"color:#B392F0\">field</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ErrorList</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add field-specific validation logic here</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use field.ErrorList to collect multiple validation errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return apierrors.NewInvalid() with collected errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(allErrs) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> apierrors.</span><span style=\"color:#B392F0\">NewInvalid</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        schema</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">GroupKind</span><span style=\"color:#E1E4E8\">{Group: </span><span style=\"color:#9ECBFF\">\"example.com\"</span><span style=\"color:#E1E4E8\">, Kind: </span><span style=\"color:#9ECBFF\">\"Database\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        r.Name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        allErrs,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints:</strong></p>\n<ul>\n<li>Use <code>kubebuilder</code> markers (<code>//+kubebuilder:validation:</code>) for generating OpenAPI schema validation</li>\n<li>Use <code>controller-gen</code> to generate CRD manifests from Go struct definitions</li>\n<li>Use <code>k8s.io/apimachinery/pkg/util/validation/field</code> for structured validation error reporting</li>\n<li>Use pointer fields (<code>*string</code>, <code>*int32</code>) to distinguish between unset and zero values</li>\n<li>Use <code>omitempty</code> JSON tags for optional fields to keep manifests clean</li>\n<li>Use <code>sigs.k8s.io/controller-runtime/pkg/webhook</code> for admission webhook infrastructure</li>\n</ul>\n<p><strong>F. Milestone Checkpoint:</strong></p>\n<p>After implementing the CRD and webhooks, verify the following behavior:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Generate and apply CRD</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">make</span><span style=\"color:#9ECBFF\"> manifests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> config/crd/bases/</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test schema validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> -</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#9ECBFF\">EOF</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">apiVersion: example.com/v1</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">kind: Database</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">metadata:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  name: test-invalid</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">spec:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  replicas: 0  # Should fail validation (minimum 1)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  version: \"invalid\"  # Should fail pattern validation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  storageSize: \"bad-format\"  # Should fail pattern validation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">EOF</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test successful creation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> -</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#9ECBFF\">EOF</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">apiVersion: example.com/v1</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">kind: Database</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">metadata:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  name: test-valid</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">spec:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  replicas: 3</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  version: \"5.7.0\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  storageSize: \"20Gi\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">EOF</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify printer columns work</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> databases</span></span></code></pre></div>\n\n<p>Expected output should show validation errors for invalid resource and successful creation with custom columns for valid resource.</p>\n<p><strong>G. Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CRD not found error</td>\n<td>CRD manifest not applied or malformed</td>\n<td><code>kubectl get crd databases.example.com -o yaml</code></td>\n<td>Apply CRD manifest with <code>kubectl apply -f</code></td>\n</tr>\n<tr>\n<td>Schema validation not working</td>\n<td>Kubebuilder markers incorrect or CRD not regenerated</td>\n<td>Check CRD openAPIV3Schema section</td>\n<td>Run <code>make manifests</code> and reapply CRD</td>\n</tr>\n<tr>\n<td>Webhook not called</td>\n<td>Webhook configuration missing or service unreachable</td>\n<td><code>kubectl get validatingwebhookconfiguration,mutatingwebhookconfiguration</code></td>\n<td>Verify webhook configuration and service</td>\n</tr>\n<tr>\n<td>Certificate errors</td>\n<td>TLS certificates expired or malformed</td>\n<td>Check webhook pod logs for certificate errors</td>\n<td>Regenerate certificates or check cert-manager</td>\n</tr>\n<tr>\n<td>Status updates fail</td>\n<td>Status subresource not enabled in CRD</td>\n<td>Check CRD for <code>subresources: status:</code></td>\n<td>Add status subresource to CRD spec</td>\n</tr>\n</tbody></table>\n<h2 id=\"controller-and-reconciliation-engine\">Controller and Reconciliation Engine</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 (Controller Setup), Milestone 3 (Reconciliation Loop) - implements the core controller logic that watches custom resources and maintains desired state through continuous reconciliation</p>\n</blockquote>\n<p>The controller is the beating heart of any Kubernetes operator. While custom resources define the API and webhooks validate incoming requests, the controller provides the intelligence that continuously monitors the cluster and takes action to maintain the desired state. This section details how to build a robust controller that can handle the complexities of distributed systems while integrating seamlessly with Kubernetes&#39; declarative model.</p>\n<h3 id=\"mental-model-the-control-system\">Mental Model: The Control System</h3>\n<p>Think of the Kubernetes controller as an <strong>automatic thermostat for your infrastructure</strong>. Just as a thermostat continuously measures the current temperature, compares it to the desired temperature setting, and adjusts the heating or cooling system to eliminate the difference, a Kubernetes controller continuously observes the actual state of resources, compares it to the desired state declared in custom resources, and takes corrective actions to eliminate any drift.</p>\n<p>This analogy reveals several key insights about controller design. First, the controller operates on a <strong>feedback loop</strong> - it measures, compares, acts, and then measures again. The system is inherently reactive rather than predictive. Second, the controller must be <strong>level-triggered rather than edge-triggered</strong> - it doesn&#39;t just respond to change events, but continuously ensures the system remains in the correct state even after transient failures or external modifications. Third, like a good thermostat, the controller should be <strong>patient and persistent</strong> - it doesn&#39;t panic when the temperature is wrong, but steadily works to correct it over time.</p>\n<p>The control theory perspective also highlights the importance of <strong>convergence and stability</strong>. A poorly designed thermostat might oscillate wildly, turning the heat on and off rapidly without ever settling at the target temperature. Similarly, a poorly designed controller might create resources, delete them, recreate them, and never reach a stable state. The reconciliation algorithm must be designed to converge toward the desired state and remain stable once reached.</p>\n<p>Unlike a simple thermostat, however, a Kubernetes controller operates in a <strong>distributed system with partial failures</strong>. The &quot;temperature sensor&quot; (informer cache) might be stale, the &quot;heating system&quot; (Kubernetes API) might be temporarily unavailable, or multiple &quot;thermostats&quot; (controller replicas) might be running simultaneously. The controller must be designed to handle these complexities gracefully while still maintaining the core feedback loop behavior.</p>\n<h3 id=\"informer-and-caching-architecture\">Informer and Caching Architecture</h3>\n<p>The informer architecture is the foundation that makes efficient Kubernetes controllers possible. Without informers, controllers would need to constantly poll the API server to check for changes, creating excessive load and introducing latency. The informer pattern solves this by maintaining a <strong>local, eventually consistent cache</strong> of resources that the controller cares about.</p>\n<p>Think of the informer as a <strong>dedicated research assistant</strong> who maintains a constantly updated filing system of all relevant documents. Instead of the controller running to the library (API server) every time it needs to check something, the research assistant watches for new publications, updates the local files, and notifies the controller when something important changes. This allows the controller to work efficiently from local information while still staying current with the authoritative source.</p>\n<p>The informer architecture consists of several key components working together. The <strong>SharedIndexInformer</strong> is the core component that watches a specific resource type and maintains a local cache. It uses the Kubernetes <strong>list-and-watch</strong> protocol to efficiently stay synchronized with the API server. The informer first performs a list operation to get the current state of all resources, then establishes a watch stream to receive incremental updates.</p>\n<table>\n<thead>\n<tr>\n<th>Informer Component</th>\n<th>Purpose</th>\n<th>Key Responsibilities</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SharedIndexInformer</td>\n<td>Core caching and watching</td>\n<td>Maintains local cache, watches for changes, triggers event handlers</td>\n</tr>\n<tr>\n<td>Reflector</td>\n<td>API server communication</td>\n<td>Implements list-and-watch protocol, handles connection failures</td>\n</tr>\n<tr>\n<td>DeltaFIFO</td>\n<td>Event queuing</td>\n<td>Queues resource changes, deduplicates events, provides ordering</td>\n</tr>\n<tr>\n<td>Store</td>\n<td>Local cache storage</td>\n<td>Indexes resources for efficient lookup, thread-safe access</td>\n</tr>\n<tr>\n<td>ResourceEventHandler</td>\n<td>Change notification</td>\n<td>Receives add/update/delete events, enqueues work items</td>\n</tr>\n</tbody></table>\n<p>The <strong>SharedIndexInformer</strong> uses several sophisticated mechanisms to provide reliable caching. The informer maintains multiple indexes on the cached data, allowing efficient lookups by different criteria. For example, it can quickly find all resources in a specific namespace or all resources owned by a particular parent object. The informer also handles <strong>resync periods</strong> - even without changes, it periodically re-examines all cached resources to ensure the controller processes any items that might have been missed due to transient failures.</p>\n<blockquote>\n<p><strong>Critical Insight</strong>: The informer cache is eventually consistent, not strongly consistent. There&#39;s always a window where the local cache might not reflect the latest API server state. Controllers must be designed to handle this gracefully by making their operations idempotent and tolerating stale information.</p>\n</blockquote>\n<p>Event handling in the informer architecture follows a specific pattern designed for reliability and performance. When the informer detects a change, it doesn&#39;t immediately call the controller&#39;s reconciliation logic. Instead, it calls a <strong>ResourceEventHandler</strong> that typically just enqueues a work item into a rate-limited work queue. This decoupling is essential for several reasons: it prevents slow reconciliation logic from blocking the informer&#39;s watch stream, it allows for batching and deduplication of rapid changes to the same resource, and it enables sophisticated retry and backoff strategies.</p>\n<table>\n<thead>\n<tr>\n<th>Event Handler Method</th>\n<th>When Called</th>\n<th>Typical Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OnAdd</td>\n<td>Resource created or informer started</td>\n<td>Enqueue resource key for reconciliation</td>\n</tr>\n<tr>\n<td>OnUpdate</td>\n<td>Resource spec or status changed</td>\n<td>Compare old vs new, enqueue if meaningful change</td>\n</tr>\n<tr>\n<td>OnDelete</td>\n<td>Resource deleted</td>\n<td>Enqueue resource key for cleanup reconciliation</td>\n</tr>\n</tbody></table>\n<p>The work queue used with informers provides several critical capabilities for robust controller operation. The <strong>RateLimitingInterface</strong> prevents controllers from overwhelming the API server with rapid requests when resources are changing frequently. The queue implements <strong>exponential backoff</strong> - if reconciling a resource fails, the queue will wait increasingly longer periods before retrying the same resource. The queue also provides <strong>deduplication</strong> - if the same resource changes multiple times before the controller processes it, only one reconciliation is triggered.</p>\n<blockquote>\n<p><strong>Decision: SharedIndexInformer vs Direct API Calls</strong>  </p>\n<ul>\n<li><strong>Context</strong>: Controllers need to read resource state frequently during reconciliation. Direct API calls would create excessive load and latency.  </li>\n<li><strong>Options Considered</strong>: Direct API calls for each read, local caching without watches, SharedIndexInformer pattern  </li>\n<li><strong>Decision</strong>: Use SharedIndexInformer for all resource reads  </li>\n<li><strong>Rationale</strong>: Provides efficient local caching, automatic synchronization, built-in indexing, and integrates with controller-runtime patterns. Reduces API server load by orders of magnitude while providing sub-second change notification.  </li>\n<li><strong>Consequences</strong>: Controller logic must handle eventually consistent data and implement idempotent operations. Memory usage increases with number of cached resources.</li>\n</ul>\n</blockquote>\n<p>The informer lifecycle requires careful management to ensure proper startup and shutdown behavior. During controller startup, the informer must complete its initial <strong>cache synchronization</strong> before the controller begins processing work items. This ensures that the local cache contains a complete view of existing resources before reconciliation begins. The <code>cache.WaitForCacheSync</code> function provides this capability, blocking until the informer has completed its initial list operation and is ready to serve requests.</p>\n<table>\n<thead>\n<tr>\n<th>Informer Lifecycle Phase</th>\n<th>Actions Required</th>\n<th>Common Pitfalls</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Startup</td>\n<td>Start informer, wait for cache sync</td>\n<td>Processing events before sync complete</td>\n</tr>\n<tr>\n<td>Running</td>\n<td>Process events, handle watch errors</td>\n<td>Blocking event handlers with slow operations</td>\n</tr>\n<tr>\n<td>Shutdown</td>\n<td>Stop informer, drain work queue</td>\n<td>Goroutine leaks from improper cleanup</td>\n</tr>\n</tbody></table>\n<h3 id=\"reconciliation-algorithm\">Reconciliation Algorithm</h3>\n<p>The reconciliation algorithm is where the controller&#39;s intelligence lives. This algorithm implements the core feedback loop that compares desired state (from the custom resource spec) with actual state (from the cluster) and takes corrective actions to eliminate any differences. The algorithm must be <strong>idempotent</strong>, <strong>convergent</strong>, and <strong>robust</strong> in the face of partial failures and concurrent modifications.</p>\n<p>The reconciliation process follows a well-defined sequence of steps that ensures consistent and reliable behavior. Each step builds upon the previous one, creating a logical progression from observation through decision-making to action. Understanding this sequence is crucial for implementing correct controller behavior.</p>\n<p><strong>Step 1: Resource Retrieval and Validation</strong></p>\n<p>The reconciliation begins by retrieving the current state of the custom resource that triggered the reconciliation. This involves fetching the resource from the local informer cache (not directly from the API server) and performing basic validation to ensure the resource is in a state that can be reconciled.</p>\n<p>During this phase, the controller must handle several edge cases. The resource might have been deleted between the time it was enqueued and when reconciliation begins. The resource might be in the middle of being deleted (having a non-zero deletion timestamp) but still have finalizers that prevent actual removal. The resource might have been modified by another client, changing its generation number since it was last processed.</p>\n<p><strong>Step 2: Current State Discovery</strong></p>\n<p>Once the target resource is validated, the controller must discover the current state of all resources that should exist to satisfy the desired configuration. This typically involves querying for Deployments, Services, ConfigMaps, and other Kubernetes resources that the operator manages on behalf of the custom resource.</p>\n<p>This discovery phase uses <strong>owner references</strong> to identify managed resources. Each resource created by the controller should have an owner reference pointing back to the custom resource that caused its creation. This enables both discovery (finding all owned resources) and automatic garbage collection (when the owner is deleted, Kubernetes automatically removes owned resources).</p>\n<table>\n<thead>\n<tr>\n<th>Resource Discovery Pattern</th>\n<th>Query Method</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>List with label selectors</td>\n<td><code>client.List(ctx, &amp;list, client.MatchingLabels{...})</code></td>\n<td>Find resources with specific labels</td>\n</tr>\n<tr>\n<td>List with owner references</td>\n<td><code>client.List(ctx, &amp;list, client.MatchingFields{&quot;.metadata.ownerReferences.uid&quot;: owner.UID})</code></td>\n<td>Find all resources owned by custom resource</td>\n</tr>\n<tr>\n<td>Direct name lookup</td>\n<td><code>client.Get(ctx, namespacedName, &amp;resource)</code></td>\n<td>Check existence of expected resource</td>\n</tr>\n</tbody></table>\n<p><strong>Step 3: Desired State Computation</strong></p>\n<p>With the current state known, the controller must compute what the desired state should look like based on the custom resource&#39;s spec. This computation transforms the high-level desired configuration into specific Kubernetes resources with complete specifications.</p>\n<p>This step often involves complex logic specific to the application being managed. For a database operator, it might involve determining the appropriate container images, computing resource requirements, generating configuration files, and deciding on networking configuration. The key principle is that this computation should be <strong>deterministic</strong> - given the same input spec, it should always produce the same desired resource configurations.</p>\n<p><strong>Step 4: Difference Analysis</strong></p>\n<p>The heart of the reconciliation algorithm is comparing the current state with the desired state to identify what changes need to be made. This comparison must be sophisticated enough to distinguish between meaningful differences that require action and insignificant differences that should be ignored.</p>\n<p>Some fields in Kubernetes resources are modified by the system after creation and should not be considered during difference analysis. For example, the <code>resourceVersion</code> field changes with every update, and many fields have default values set by admission controllers. The controller must know which fields are significant for its purposes and focus only on those during comparison.</p>\n<table>\n<thead>\n<tr>\n<th>Difference Type</th>\n<th>Action Required</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Missing resource</td>\n<td>Create with desired spec</td>\n<td>Deployment doesn&#39;t exist but should</td>\n</tr>\n<tr>\n<td>Extra resource</td>\n<td>Delete unwanted resource</td>\n<td>Service exists but shouldn&#39;t based on current spec</td>\n</tr>\n<tr>\n<td>Configuration drift</td>\n<td>Update to match desired spec</td>\n<td>Container image version differs from spec</td>\n</tr>\n<tr>\n<td>Status-only changes</td>\n<td>No action (status-only update)</td>\n<td>Ready replicas count changed</td>\n</tr>\n</tbody></table>\n<p><strong>Step 5: Corrective Actions</strong></p>\n<p>Based on the difference analysis, the controller takes corrective actions to move the actual state toward the desired state. These actions typically involve creating, updating, or deleting Kubernetes resources through the client library.</p>\n<p>The order of operations matters significantly during this phase. Resources with dependencies should be created in the correct order (ConfigMaps before Deployments that reference them), and deletions should happen in reverse dependency order. The controller should also be prepared for operations to fail partially and leave the system in an intermediate state.</p>\n<p><strong>Step 6: Status Update</strong></p>\n<p>After attempting corrective actions, the controller updates the custom resource&#39;s status to reflect the current state of reconciliation. This provides visibility to users about what the controller has accomplished and whether any problems were encountered.</p>\n<p>The status update should include several types of information: overall conditions indicating the health and progress of reconciliation, specific metrics like the number of ready replicas, and detailed messages about any errors encountered. This information is crucial for debugging and monitoring operator behavior.</p>\n<table>\n<thead>\n<tr>\n<th>Status Field</th>\n<th>Purpose</th>\n<th>Example Values</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Conditions</td>\n<td>Overall health and progress</td>\n<td>Ready=True, Progressing=False</td>\n</tr>\n<tr>\n<td>ReadyReplicas</td>\n<td>Current operational capacity</td>\n<td>3 (out of 3 desired replicas)</td>\n</tr>\n<tr>\n<td>ObservedGeneration</td>\n<td>Last spec version processed</td>\n<td>matches metadata.generation when up-to-date</td>\n</tr>\n<tr>\n<td>Phase</td>\n<td>High-level lifecycle state</td>\n<td>Pending, Ready, Failed</td>\n</tr>\n<tr>\n<td>Message</td>\n<td>Human-readable status description</td>\n<td>&quot;All replicas are ready and serving traffic&quot;</td>\n</tr>\n</tbody></table>\n<p>The complete reconciliation algorithm can be expressed as the following decision flow:</p>\n<ol>\n<li><p><strong>Retrieve target custom resource from cache</strong></p>\n<ul>\n<li>If not found, log and return (resource was deleted)</li>\n<li>If deletion timestamp set, proceed with cleanup logic</li>\n<li>If generation unchanged and conditions current, return early (optimization)</li>\n</ul>\n</li>\n<li><p><strong>Discovery current owned resources</strong></p>\n<ul>\n<li>Query for all resources with owner references to this custom resource</li>\n<li>Query for resources matching expected names and labels</li>\n<li>Build map of current resource state keyed by resource type and name</li>\n</ul>\n</li>\n<li><p><strong>Compute desired resource specifications</strong></p>\n<ul>\n<li>Transform custom resource spec into concrete Kubernetes resource specs</li>\n<li>Apply naming conventions, labels, owner references</li>\n<li>Generate configurations, secrets, and other derived resources</li>\n</ul>\n</li>\n<li><p><strong>Perform three-way diff analysis</strong></p>\n<ul>\n<li>Compare desired vs current for each resource type</li>\n<li>Identify resources to create, update, or delete</li>\n<li>Filter out insignificant differences (system-managed fields)</li>\n</ul>\n</li>\n<li><p><strong>Execute corrective actions in dependency order</strong></p>\n<ul>\n<li>Create missing dependencies first (ConfigMaps, Secrets)</li>\n<li>Create or update primary resources (Deployments, Services)</li>\n<li>Delete obsolete resources last</li>\n<li>Handle partial failures gracefully</li>\n</ul>\n</li>\n<li><p><strong>Update custom resource status</strong></p>\n<ul>\n<li>Set conditions based on reconciliation success/failure</li>\n<li>Update metrics (ready replicas, observed generation)</li>\n<li>Record detailed error messages for debugging</li>\n<li>Use status subresource to avoid update conflicts</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Reconciliation Frequency Strategy</strong>  </p>\n<ul>\n<li><strong>Context</strong>: Controllers need to balance responsiveness with efficiency, ensuring timely updates without overwhelming the API server  </li>\n<li><strong>Options Considered</strong>: Continuous polling, event-driven only, hybrid approach with periodic resync  </li>\n<li><strong>Decision</strong>: Event-driven reconciliation with configurable resync period (default 10 hours)  </li>\n<li><strong>Rationale</strong>: Event-driven provides immediate response to changes while periodic resync catches missed events and handles external modifications. Long resync period minimizes unnecessary work while providing eventual consistency guarantees.  </li>\n<li><strong>Consequences</strong>: Enables efficient resource usage while maintaining strong consistency. Requires careful event handler implementation to avoid missing important changes.</li>\n</ul>\n</blockquote>\n<h3 id=\"error-handling-and-requeue-strategy\">Error Handling and Requeue Strategy</h3>\n<p>Robust error handling is what separates production-ready controllers from toy implementations. In distributed systems, failures are not exceptional - they are expected and must be handled gracefully. A well-designed controller can distinguish between different types of failures and respond appropriately to each category.</p>\n<p>The fundamental insight for controller error handling is that <strong>most failures are transient</strong> and will resolve themselves if the controller simply waits and retries. Network connectivity issues, temporary API server overload, and resource conflicts during concurrent updates all fall into this category. However, some failures are <strong>permanent</strong> and will never succeed no matter how many times they are retried. Attempting to create a resource with an invalid name or referencing a non-existent secret will fail consistently until the underlying problem is fixed.</p>\n<p><strong>Transient vs Permanent Error Classification</strong></p>\n<p>The controller&#39;s error handling strategy begins with correctly classifying errors as transient or permanent. This classification determines whether the controller should retry the operation automatically or surface the error to users for manual intervention.</p>\n<table>\n<thead>\n<tr>\n<th>Error Category</th>\n<th>Examples</th>\n<th>Handling Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Transient Network</td>\n<td>Connection timeout, DNS resolution failure</td>\n<td>Exponential backoff retry</td>\n</tr>\n<tr>\n<td>Transient API Server</td>\n<td>Rate limiting, temporary overload</td>\n<td>Exponential backoff with jitter</td>\n</tr>\n<tr>\n<td>Transient Resource</td>\n<td>Update conflicts, temporary resource constraints</td>\n<td>Linear backoff retry</td>\n</tr>\n<tr>\n<td>Permanent Configuration</td>\n<td>Invalid resource names, malformed specs</td>\n<td>Surface error, no retry</td>\n</tr>\n<tr>\n<td>Permanent Permission</td>\n<td>RBAC denials, forbidden operations</td>\n<td>Surface error, log for admin</td>\n</tr>\n<tr>\n<td>Permanent Dependency</td>\n<td>Non-existent secrets, missing CRDs</td>\n<td>Surface error, watch for dependency</td>\n</tr>\n</tbody></table>\n<p>Transient errors should trigger <strong>automatic retry with backoff</strong>. The controller enqueues the resource for reprocessing after a delay, with the delay increasing on subsequent failures. This prevents the controller from overwhelming struggling components while still providing timely retry when conditions improve.</p>\n<p>Permanent errors should <strong>not trigger automatic retry</strong>. Instead, the controller should update the resource status with a detailed error message, emit a warning event, and wait for external action to resolve the underlying problem. Continuing to retry permanent failures wastes resources and creates excessive log noise.</p>\n<p><strong>Exponential Backoff Implementation</strong></p>\n<p>The work queue provides sophisticated retry mechanisms that implement exponential backoff automatically. When the controller returns an error from the <code>Reconcile</code> function, the controller-runtime framework interprets this as a request to retry the operation after a delay.</p>\n<p>The backoff algorithm starts with a base delay (typically 1 second) and doubles the delay after each failure, up to a maximum delay (typically 16 minutes). This exponential growth ensures that transient issues get resolved quickly while preventing permanent failures from consuming excessive resources.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Count</th>\n<th>Retry Delay</th>\n<th>Cumulative Time</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>1 second</td>\n<td>1 second</td>\n<td>Quick recovery for brief glitches</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2 seconds</td>\n<td>3 seconds</td>\n<td>Still responsive for short outages</td>\n</tr>\n<tr>\n<td>3</td>\n<td>4 seconds</td>\n<td>7 seconds</td>\n<td>Moderate backing off</td>\n</tr>\n<tr>\n<td>4</td>\n<td>8 seconds</td>\n<td>15 seconds</td>\n<td>Reduced load during longer issues</td>\n</tr>\n<tr>\n<td>5</td>\n<td>16 seconds</td>\n<td>31 seconds</td>\n<td>Significant backoff</td>\n</tr>\n<tr>\n<td>10</td>\n<td>16 minutes</td>\n<td>~17 minutes</td>\n<td>Maximum delay prevents resource waste</td>\n</tr>\n</tbody></table>\n<p><strong>Jitter</strong> is added to the backoff delays to prevent <strong>thundering herd</strong> problems when many controllers are retrying simultaneously. Without jitter, if the API server becomes unavailable and then recovers, all controllers would retry at exactly the same time, potentially overwhelming the server again. Jitter adds randomness to spread out the retry attempts.</p>\n<p><strong>Requeue Strategies</strong></p>\n<p>The controller-runtime framework provides several mechanisms for requesting that a resource be reprocessed:</p>\n<table>\n<thead>\n<tr>\n<th>Requeue Method</th>\n<th>When to Use</th>\n<th>Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>return ctrl.Result{}, err</code></td>\n<td>Transient error occurred</td>\n<td>Exponential backoff based on error count</td>\n</tr>\n<tr>\n<td><code>return ctrl.Result{RequeueAfter: duration}, nil</code></td>\n<td>Need to check again after specific time</td>\n<td>Fixed delay, resets error count</td>\n</tr>\n<tr>\n<td><code>return ctrl.Result{Requeue: true}, nil</code></td>\n<td>Need immediate reprocessing</td>\n<td>Immediate enqueue, resets error count</td>\n</tr>\n<tr>\n<td><code>return ctrl.Result{}, nil</code></td>\n<td>Reconciliation successful</td>\n<td>No requeue, wait for next event</td>\n</tr>\n</tbody></table>\n<p>The choice between these requeue strategies depends on the specific situation encountered during reconciliation. Transient errors should use the error return to trigger exponential backoff. Situations where the controller needs to wait for an external condition (like waiting for a deployment to become ready) should use <code>RequeueAfter</code> with an appropriate delay. Immediate requeue should be used sparingly and only when the controller knows that conditions have changed and reconciliation should succeed.</p>\n<p><strong>Reconciliation Result Patterns</strong></p>\n<p>Different reconciliation outcomes require different result patterns to ensure optimal controller behavior:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>// Successful reconciliation, no further action needed\nreturn ctrl.Result{}, nil\n\n// Transient error, use exponential backoff\nif isTransientError(err) {\n    return ctrl.Result{}, err\n}\n\n// Permanent error, update status and don't retry\nr.updateErrorStatus(ctx, database, err)\nreturn ctrl.Result{}, nil\n\n// Waiting for external condition, check again in 30 seconds\nif !allResourcesReady {\n    return ctrl.Result{RequeueAfter: REQUEUE_AFTER_DURATION}, nil\n}\n\n// Configuration changed during reconciliation, reprocess immediately\nif resourceModified {\n    return ctrl.Result{Requeue: true}, nil\n}</code></pre></div>\n\n<p><strong>Status Condition Management</strong></p>\n<p>Error handling integrates closely with status condition management. The controller should maintain conditions that reflect the current state of reconciliation, including any errors encountered. Well-designed conditions provide both programmatic and human-readable information about controller state.</p>\n<table>\n<thead>\n<tr>\n<th>Condition Type</th>\n<th>Status</th>\n<th>Reason</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Ready</td>\n<td>True</td>\n<td>AllResourcesReady</td>\n<td>Reconciliation successful, all resources operational</td>\n</tr>\n<tr>\n<td>Ready</td>\n<td>False</td>\n<td>ReconciliationInProgress</td>\n<td>Reconciliation in progress, resources not yet ready</td>\n</tr>\n<tr>\n<td>Ready</td>\n<td>False</td>\n<td>ReconciliationFailed</td>\n<td>Permanent error prevents successful reconciliation</td>\n</tr>\n<tr>\n<td>Progressing</td>\n<td>True</td>\n<td>CreatingResources</td>\n<td>Controller actively working to reach desired state</td>\n</tr>\n<tr>\n<td>Progressing</td>\n<td>False</td>\n<td>ReconciledSuccessfully</td>\n<td>Desired state achieved, no work in progress</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Error Classification Strategy</strong>  </p>\n<ul>\n<li><strong>Context</strong>: Controllers must distinguish between errors that should trigger retry vs errors that require human intervention  </li>\n<li><strong>Options Considered</strong>: Retry all errors, never retry errors, classify by error type and HTTP status  </li>\n<li><strong>Decision</strong>: Classify errors by HTTP status code and error type, with configurable retry limits  </li>\n<li><strong>Rationale</strong>: HTTP 4xx errors (except 408, 429) are typically permanent while 5xx errors are transient. Specific error types (validation failures) can be classified regardless of HTTP status. Retry limits prevent infinite loops on misclassified errors.  </li>\n<li><strong>Consequences</strong>: Enables efficient resource usage and faster recovery from transient issues. Requires careful error classification logic and monitoring of retry patterns.</li>\n</ul>\n</blockquote>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Processing Events Before Cache Sync</strong></p>\n<p>A common mistake is starting the reconciliation loop before the informer cache has completed its initial synchronization. This can lead to creating duplicate resources because the controller doesn&#39;t see existing resources in its empty cache. Always wait for <code>cache.WaitForCacheSync</code> to return true before starting worker goroutines.</p>\n<p>⚠️ <strong>Pitfall: Blocking Event Handlers</strong></p>\n<p>Event handlers (<code>OnAdd</code>, <code>OnUpdate</code>, <code>OnDelete</code>) run in the informer&#39;s goroutine and must not block. Performing expensive operations or API calls directly in event handlers will block the informer&#39;s watch stream, preventing it from processing new events. Event handlers should only enqueue work items and return quickly.</p>\n<p>⚠️ <strong>Pitfall: Not Implementing Idempotent Operations</strong></p>\n<p>Controllers may reconcile the same resource multiple times due to retries, cache inconsistencies, or multiple events. All reconciliation operations must be idempotent - applying the same reconciliation multiple times should produce the same result. This requires checking existing resource state before creating new resources.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Owner References</strong></p>\n<p>Without proper owner references, the controller cannot reliably discover resources it created, and garbage collection will not work correctly. Every resource created by the controller must have an owner reference pointing to the custom resource that caused its creation. Use <code>controllerutil.SetControllerReference</code> to set these correctly.</p>\n<p>⚠️ <strong>Pitfall: Status Update Conflicts</strong></p>\n<p>Updating both spec and status fields in the same operation can cause update conflicts with other clients. Use the status subresource (<code>client.Status().Update()</code>) to update status independently from spec changes. This allows the controller to update status without conflicting with user spec modifications.</p>\n<p>⚠️ <strong>Pitfall: Infinite Reconciliation Loops</strong></p>\n<p>If the controller modifies resources in a way that triggers its own event handlers, it can create infinite reconciliation loops. Be careful when updating resources that the controller watches. Use proper condition checking to avoid unnecessary updates, and ensure that status updates don&#39;t trigger spec changes.</p>\n<p>⚠️ <strong>Pitfall: Not Handling Finalizers Properly</strong></p>\n<p>When using finalizers for cleanup, controllers must remove the finalizer after successful cleanup, or the resource will be stuck in deletion state forever. Always implement finalizer removal logic and test deletion scenarios thoroughly.</p>\n<p><img src=\"/api/project/kubernetes-operator/architecture-doc/asset?path=diagrams%2Foperator-architecture.svg\" alt=\"Operator Architecture Overview\"></p>\n<p><img src=\"/api/project/kubernetes-operator/architecture-doc/asset?path=diagrams%2Freconciliation-state-machine.svg\" alt=\"Resource Reconciliation State Machine\"></p>\n<p><img src=\"/api/project/kubernetes-operator/architecture-doc/asset?path=diagrams%2Freconciliation-algorithm-flow.svg\" alt=\"Reconciliation Algorithm Flowchart\"></p>\n<p><img src=\"/api/project/kubernetes-operator/architecture-doc/asset?path=diagrams%2Ferror-recovery-flow.svg\" alt=\"Error Handling and Recovery Flow\"></p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete code patterns and infrastructure to implement the controller architecture described above. The focus is on providing complete, working infrastructure code while leaving the core business logic for you to implement.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Controller Framework</td>\n<td>controller-runtime (kubebuilder style)</td>\n<td>Custom controller with client-go directly</td>\n</tr>\n<tr>\n<td>Client Library</td>\n<td>controller-runtime client (unified interface)</td>\n<td>Separate typed and dynamic clients</td>\n</tr>\n<tr>\n<td>Work Queue</td>\n<td>controller-runtime managed queues</td>\n<td>Manual workqueue.RateLimitingInterface</td>\n</tr>\n<tr>\n<td>Informer Setup</td>\n<td>controller-runtime managed informers</td>\n<td>Manual shared informer factory</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>controller-runtime envtest</td>\n<td>Custom test cluster setup</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/controller/\n  database_controller.go           ← main controller implementation\n  database_controller_test.go      ← unit tests with fake client\n  suite_test.go                    ← integration test suite setup\ninternal/resources/\n  deployment.go                    ← deployment resource builder\n  service.go                       ← service resource builder  \n  configmap.go                     ← configmap resource builder\nconfig/\n  samples/                         ← example custom resources\n    database_v1_database.yaml\n  manager/\n    manager.yaml                   ← controller deployment</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete Controller Structure (internal/controller/database_controller.go):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> controller</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    appsv1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/apps/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    corev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/core/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/api/errors</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/client</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/controller/controllerutil</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    databasev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/example/database-operator/api/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    REQUEUE_AFTER_DURATION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FINALIZER_NAME</span><span style=\"color:#F97583\">         =</span><span style=\"color:#9ECBFF\"> \"database.example.com/finalizer\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DatabaseReconciler reconciles a Database object</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseReconciler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    client</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Scheme </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Scheme</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=database.example.com,resources=databases,verbs=get;list;watch;create;update;patch;delete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=database.example.com,resources=databases/status,verbs=get;update;patch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=database.example.com,resources=databases/finalizers,verbs=update</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=\"\",resources=services,verbs=get;list;watch;create;update;patch;delete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=\"\",resources=configmaps,verbs=get;list;watch;create;update;patch;delete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">//+kubebuilder:rbac:groups=\"\",resources=events,verbs=create;patch</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetupWithManager sets up the controller with the Manager.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetupWithManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mgr</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ctrl.</span><span style=\"color:#B392F0\">NewControllerManagedBy</span><span style=\"color:#E1E4E8\">(mgr).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        For</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">{}).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Owns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">appsv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Deployment</span><span style=\"color:#E1E4E8\">{}).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Owns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">corev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Service</span><span style=\"color:#E1E4E8\">{}).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Owns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">corev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ConfigMap</span><span style=\"color:#E1E4E8\">{}).</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Complete</span><span style=\"color:#E1E4E8\">(r)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Work Queue and Event Handling Infrastructure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ConditionType represents the type of condition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ConditionType</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ConditionTypeReady</span><span style=\"color:#B392F0\">      ConditionType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"Ready\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ConditionTypeProgressing</span><span style=\"color:#B392F0\"> ConditionType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"Progressing\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ConditionStatus represents the status of a condition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ConditionStatus</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ConditionStatusTrue</span><span style=\"color:#B392F0\">    ConditionStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"True\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ConditionStatusFalse</span><span style=\"color:#B392F0\">   ConditionStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"False\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ConditionStatusUnknown</span><span style=\"color:#B392F0\"> ConditionStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"Unknown\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// updateCondition updates or adds a condition to the Database status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">updateCondition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">database</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">conditionType</span><span style=\"color:#B392F0\"> ConditionType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">status</span><span style=\"color:#B392F0\"> ConditionStatus</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    condition </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Condition</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Type:               </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(conditionType),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Status:             </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">(status),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LastTransitionTime: metav1.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Reason:             reason,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Message:            message,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObservedGeneration: database.Generation,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find existing condition of same type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, existing </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> database.Status.Conditions {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> existing.Type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> condition.Type {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Only update if status changed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> existing.Status </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> condition.Status {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                database.Status.Conditions[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> condition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Update message but keep transition time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                database.Status.Conditions[i].Message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                database.Status.Conditions[i].Reason </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> reason</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                database.Status.Conditions[i].ObservedGeneration </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> database.Generation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add new condition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    database.Status.Conditions </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(database.Status.Conditions, condition)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// isErrorRetryable determines if an error should trigger exponential backoff retry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> isErrorRetryable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">IsTimeout</span><span style=\"color:#E1E4E8\">(err) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">IsServerTimeout</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">IsServiceUnavailable</span><span style=\"color:#E1E4E8\">(err) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">IsInternalError</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">IsTooManyRequests</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">IsConflict</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> true</span><span style=\"color:#6A737D\"> // Resource conflicts are typically transient</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4xx errors (except above) are typically permanent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">IsNotFound</span><span style=\"color:#E1E4E8\">(err) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">IsAlreadyExists</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">IsBadRequest</span><span style=\"color:#E1E4E8\">(err) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">IsInvalid</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">IsForbidden</span><span style=\"color:#E1E4E8\">(err) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">IsUnauthorized</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Default to retryable for unknown errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Main Reconciliation Logic (implement this yourself):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Reconcile is part of the main kubernetes reconciliation loop which aims to</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// move the current state of the cluster closer to the desired state.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Reconcile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> log.</span><span style=\"color:#B392F0\">FromContext</span><span style=\"color:#E1E4E8\">(ctx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Starting reconciliation\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"database\"</span><span style=\"color:#E1E4E8\">, req.NamespacedName)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Fetch the Database instance from the cache</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use r.Get(ctx, req.NamespacedName, &#x26;database) to retrieve the resource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If not found, return success (resource was deleted)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use errors.IsNotFound(err) to check for not found errors</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Handle deletion logic if deletion timestamp is set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if database.DeletionTimestamp != nil</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If deleting and has finalizer, perform cleanup and remove finalizer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return after handling deletion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use controllerutil.ContainsFinalizer() and controllerutil.RemoveFinalizer()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add finalizer if not present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if finalizer is present using controllerutil.ContainsFinalizer()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If missing, add it using controllerutil.AddFinalizer() and update resource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: This ensures cleanup logic runs before deletion</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Discover current state of all owned resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find existing Deployment, Service, ConfigMap using owner references</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Build a map of current resources keyed by type and name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use client.List with owner reference field selector or label selectors</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Compute desired state based on Database spec</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Call helper functions to generate desired Deployment, Service, ConfigMap specs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Apply naming conventions, labels, and owner references</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use controllerutil.SetControllerReference to set owner references</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Perform three-way diff and apply changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Compare current vs desired for each resource type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create missing resources, update modified resources, delete obsolete resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle partial failures gracefully - update what you can</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use r.createOrUpdateResource() helper for each resource</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update Database status based on reconciliation results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set conditions (Ready, Progressing) based on success/failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update ReadyReplicas from Deployment status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set ObservedGeneration to database.Generation when fully reconciled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use r.Status().Update() to persist status changes</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Determine appropriate return value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return error for transient failures (triggers exponential backoff)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return RequeueAfter for waiting on external conditions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return success (empty Result) when reconciliation complete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use isErrorRetryable() to classify errors</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Resource Management Helper (implement this yourself):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// createOrUpdateResource creates or updates a Kubernetes resource to match desired state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">createOrUpdateResource</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">desired</span><span style=\"color:#B392F0\"> client</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Object</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">database</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> log.</span><span style=\"color:#B392F0\">FromContext</span><span style=\"color:#E1E4E8\">(ctx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if resource already exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create a new instance of the same type as desired</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use r.Get() to fetch existing resource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle both found and not found cases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use errors.IsNotFound() to distinguish cases</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If resource doesn't exist, create it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set owner reference to the Database resource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use r.Create() to create the resource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Log creation and return any errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use controllerutil.SetControllerReference()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If resource exists, check if update is needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Compare significant fields between existing and desired</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Skip fields that are modified by the system (resourceVersion, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Decide whether an update is necessary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Focus on spec fields, ignore status and metadata</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update resource if changes detected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Copy desired spec into existing resource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Preserve system-managed fields (resourceVersion, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use r.Update() to persist changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Log update and return any errors</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Status Management Helper (implement this yourself):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// updateDatabaseStatus updates the Database status subresource with current state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">updateDatabaseStatus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">database</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    log </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> log.</span><span style=\"color:#B392F0\">FromContext</span><span style=\"color:#E1E4E8\">(ctx)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Fetch current Deployment status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Look up the Deployment owned by this Database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Extract ready replicas, total replicas, and conditions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle case where Deployment doesn't exist yet</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use same naming convention as resource creation</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update Database status fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set ReadyReplicas from Deployment status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set ObservedGeneration to database.Generation when fully processed  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Determine overall Phase (Pending, Ready, Failed)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update Endpoints if Service exists</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Update status conditions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set Ready condition based on whether all resources are operational</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set Progressing condition based on whether work is in progress</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Include detailed messages for debugging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use r.updateCondition() helper</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Persist status changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use r.Status().Update() to update only status subresource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This avoids conflicts with spec changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return any update errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Status updates use different RBAC permissions</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">Status</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(ctx, database)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<ul>\n<li>Use <code>sigs.k8s.io/controller-runtime/pkg/client</code> for all API operations - it provides caching and works with both typed and untyped resources</li>\n<li>Use <code>controllerutil.SetControllerReference()</code> to establish owner relationships - this enables automatic garbage collection</li>\n<li>Use <code>errors.IsNotFound()</code>, <code>errors.IsConflict()</code>, etc. for proper error classification rather than string matching</li>\n<li>Use <code>ctrl.Request.NamespacedName</code> type for resource keys - it&#39;s the standard way to identify resources</li>\n<li>Use <code>metav1.Now()</code> for condition timestamps to ensure consistent time format</li>\n<li>Use <code>runtime.Object</code> interface for generic resource handling in helper functions</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the controller logic:</p>\n<p><strong>Test Command</strong>: <code>go test ./internal/controller/... -v</code></p>\n<p><strong>Expected Behavior</strong>:</p>\n<ul>\n<li>Controller starts and waits for cache sync before processing</li>\n<li>Creating a Database resource triggers reconciliation</li>\n<li>Owned Deployment, Service, and ConfigMap are created with proper owner references  </li>\n<li>Database status is updated with Ready condition and replica counts</li>\n<li>Deleting Database triggers finalizer cleanup before actual deletion</li>\n<li>Status subresource updates don&#39;t conflict with spec changes</li>\n</ul>\n<p><strong>Manual Verification</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create test Database resource</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> config/samples/database_v1_database.yaml</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify owned resources were created</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> deployments,services,configmaps</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#9ECBFF\"> app.kubernetes.io/name=database-sample</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check Database status</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> database</span><span style=\"color:#9ECBFF\"> database-sample</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> yaml</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -A</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#9ECBFF\"> status:</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify owner references are set</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> deployment</span><span style=\"color:#9ECBFF\"> database-sample-deployment</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> yaml</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#79B8FF\"> -A</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#9ECBFF\"> ownerReferences:</span></span></code></pre></div>\n\n<p><strong>Signs Something is Wrong</strong>:</p>\n<ul>\n<li>&quot;cache not started&quot; errors → informer not properly initialized</li>\n<li>Resources created without owner references → garbage collection won&#39;t work</li>\n<li>Status updates causing &quot;conflict&quot; errors → not using status subresource</li>\n<li>Reconciliation not triggered by resource changes → event handlers not configured</li>\n<li>Controller processing before cache sync → missing WaitForCacheSync</li>\n</ul>\n<h2 id=\"admission-control-with-webhooks\">Admission Control with Webhooks</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 4 (Webhooks) - implements admission webhooks for validation and mutation that intercept resource operations before they reach storage</p>\n</blockquote>\n<p>Admission webhooks represent one of the most powerful extensibility mechanisms in Kubernetes, allowing operators to implement custom business logic that executes during the resource lifecycle. These webhooks act as gatekeepers that can inspect, validate, and modify resources before they are persisted to etcd, providing a critical control point for enforcing organizational policies and ensuring data consistency.</p>\n<h3 id=\"mental-model-the-gatekeeper\">Mental Model: The Gatekeeper</h3>\n<p>Think of admission webhooks as security guards at the entrance to a high-security building. Just as every person entering the building must pass through a checkpoint where guards verify credentials, check for prohibited items, and potentially provide visitor badges, every resource entering the Kubernetes API must pass through admission control where webhooks can validate the request, reject invalid operations, and inject required metadata.</p>\n<p>The analogy extends further: just as there might be multiple checkpoints with different responsibilities (one guard checks identification, another performs security screening, a third issues access badges), Kubernetes runs multiple webhook types in a specific order. <strong>Mutating webhooks</strong> act like the badge-issuing station - they can add required information to requests (like default values or labels). <strong>Validating webhooks</strong> act like the final security checkpoint - they perform comprehensive validation and can deny entry entirely if something is wrong.</p>\n<p>The critical insight is that these gatekeepers operate synchronously in the request path. When a user runs <code>kubectl apply</code>, their request doesn&#39;t go directly to storage - it first passes through this entire admission chain. If any webhook rejects the request, the operation fails immediately and nothing gets stored. This provides strong consistency guarantees that manual validation processes cannot match.</p>\n<blockquote>\n<p><strong>Decision: Synchronous vs Asynchronous Webhook Processing</strong></p>\n<ul>\n<li><strong>Context</strong>: Admission webhooks could potentially operate asynchronously to avoid blocking the API request path, but this would require complex coordination mechanisms</li>\n<li><strong>Options Considered</strong>: Synchronous processing during admission, asynchronous processing with eventual validation, hybrid approach with fast-path synchronous and slow-path asynchronous</li>\n<li><strong>Decision</strong>: Synchronous processing during admission control</li>\n<li><strong>Rationale</strong>: Provides immediate feedback to users, ensures invalid resources never reach storage, and maintains strong consistency without complex reconciliation logic for validation failures</li>\n<li><strong>Consequences</strong>: Webhook latency directly impacts API response time, requires careful timeout configuration, but provides superior user experience and data integrity guarantees</li>\n</ul>\n</blockquote>\n<h3 id=\"validating-webhook-implementation\">Validating Webhook Implementation</h3>\n<p>Validating admission webhooks implement business rule validation that goes beyond what OpenAPI schema validation can express in the Custom Resource Definition. While CRD schemas excel at structural validation (ensuring fields have correct types, required fields are present), validating webhooks handle cross-field validation, external dependency checks, and complex business logic that requires computational evaluation.</p>\n<p>The webhook receives an <code>AdmissionReview</code> request containing the proposed resource and must return an <code>AdmissionResponse</code> indicating whether to allow or deny the operation. The webhook has access to both the new resource (for create operations) and the old resource (for update operations), enabling sophisticated change validation that can prevent invalid state transitions.</p>\n<p><strong>AdmissionReview Request Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>kind</code></td>\n<td>string</td>\n<td>Always &quot;AdmissionReview&quot;</td>\n</tr>\n<tr>\n<td><code>apiVersion</code></td>\n<td>string</td>\n<td>API version of the admission review (admission.k8s.io/v1)</td>\n</tr>\n<tr>\n<td><code>request.uid</code></td>\n<td>string</td>\n<td>Unique identifier for this admission request - must be included in response</td>\n</tr>\n<tr>\n<td><code>request.kind</code></td>\n<td>GroupVersionKind</td>\n<td>The resource type being validated (e.g., Database)</td>\n</tr>\n<tr>\n<td><code>request.namespace</code></td>\n<td>string</td>\n<td>Namespace of the resource being created/updated</td>\n</tr>\n<tr>\n<td><code>request.operation</code></td>\n<td>string</td>\n<td>CREATE, UPDATE, or DELETE</td>\n</tr>\n<tr>\n<td><code>request.object</code></td>\n<td>runtime.RawExtension</td>\n<td>The new resource being created or updated (JSON-encoded)</td>\n</tr>\n<tr>\n<td><code>request.oldObject</code></td>\n<td>runtime.RawExtension</td>\n<td>The existing resource (only present for UPDATE operations)</td>\n</tr>\n<tr>\n<td><code>request.userInfo</code></td>\n<td>UserInfo</td>\n<td>Information about the user making the request</td>\n</tr>\n<tr>\n<td><code>request.dryRun</code></td>\n<td>bool</td>\n<td>True if this is a dry-run operation (kubectl apply --dry-run)</td>\n</tr>\n</tbody></table>\n<p><strong>AdmissionResponse Structure:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>uid</code></td>\n<td>string</td>\n<td>Must match the request UID</td>\n</tr>\n<tr>\n<td><code>allowed</code></td>\n<td>bool</td>\n<td>Whether the operation should be permitted</td>\n</tr>\n<tr>\n<td><code>result.status</code></td>\n<td>string</td>\n<td>&quot;Success&quot; for allowed operations, &quot;Failure&quot; for denied</td>\n</tr>\n<tr>\n<td><code>result.message</code></td>\n<td>string</td>\n<td>Human-readable explanation for denial</td>\n</tr>\n<tr>\n<td><code>result.reason</code></td>\n<td>string</td>\n<td>Machine-readable reason code</td>\n</tr>\n<tr>\n<td><code>result.code</code></td>\n<td>int32</td>\n<td>HTTP status code (400 for validation errors, 403 for policy violations)</td>\n</tr>\n</tbody></table>\n<p>The validation logic should be <strong>idempotent</strong> and <strong>stateless</strong> - the same resource should always produce the same validation result regardless of when the webhook is called. This is critical because Kubernetes may call the webhook multiple times for the same resource during retries or internal processing.</p>\n<p><strong>Database Validation Rules Implementation:</strong></p>\n<p>Consider implementing these validation rules for the <code>Database</code> custom resource:</p>\n<ol>\n<li><strong>Version Compatibility Validation</strong>: Ensure the requested database version is supported and that version downgrades follow safe migration paths</li>\n<li><strong>Resource Constraint Validation</strong>: Verify that CPU and memory requests are within organizational limits and that storage size is appropriate for the database version</li>\n<li><strong>Backup Schedule Validation</strong>: Validate cron expressions in <code>BackupSchedule</code> and ensure backup frequency meets compliance requirements</li>\n<li><strong>Configuration Validation</strong>: Check that database configuration parameters in the <code>Config</code> map are valid for the specified version</li>\n<li><strong>Update Path Validation</strong>: For UPDATE operations, ensure changes don&#39;t violate constraints (e.g., storage size cannot be decreased, replica count changes follow safe scaling patterns)</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Client-Side vs Server-Side Validation Balance</strong></p>\n<ul>\n<li><strong>Context</strong>: Validation can occur in multiple places - CRD schema, admission webhooks, and reconciliation logic</li>\n<li><strong>Options Considered</strong>: All validation in webhooks, all validation in reconciliation, layered validation with different concerns at each level</li>\n<li><strong>Decision</strong>: Layered validation with schema for structure, webhooks for business rules, reconciliation for runtime constraints</li>\n<li><strong>Rationale</strong>: Schema validation provides immediate feedback with minimal latency, webhooks handle complex business logic synchronously, reconciliation handles constraints that depend on cluster state</li>\n<li><strong>Consequences</strong>: Multiple validation layers require careful coordination, but provides optimal user experience and strong consistency guarantees</li>\n</ul>\n</blockquote>\n<p><strong>Common Validation Patterns:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Validation Type</th>\n<th>Implementation Approach</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cross-field validation</td>\n<td>Compare multiple fields in same resource</td>\n<td>Validate that memory limits are greater than memory requests</td>\n</tr>\n<tr>\n<td>Enumeration validation</td>\n<td>Check field values against allowed lists</td>\n<td>Ensure database version is in supported versions list</td>\n</tr>\n<tr>\n<td>External dependency validation</td>\n<td>Query external systems or APIs</td>\n<td>Verify that specified storage class exists and is available</td>\n</tr>\n<tr>\n<td>Policy compliance validation</td>\n<td>Apply organizational rules and constraints</td>\n<td>Check that resource requests don&#39;t exceed namespace quotas</td>\n</tr>\n<tr>\n<td>Change safety validation</td>\n<td>Compare old and new resources for updates</td>\n<td>Prevent scaling down below minimum replica count</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Webhook Validation Loops</strong></p>\n<p>A common mistake is implementing validation logic that can change its decision based on external factors like current time or cluster state. For example, validating that &quot;backups can only be scheduled during maintenance windows&quot; might reject the same resource at different times of day. This creates confusing user experiences where <code>kubectl apply</code> succeeds at one time but fails at another for the same YAML.</p>\n<p>Instead, validate the structural correctness of the schedule but let the controller&#39;s reconciliation logic handle timing-based decisions. The webhook should ensure the cron expression is valid, but the controller should skip backups that fall outside maintenance windows.</p>\n<p><strong>Error Response Best Practices:</strong></p>\n<p>When rejecting a resource, provide actionable error messages that help users fix the problem:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>❌ Bad: &quot;Invalid configuration&quot;\n✅ Good: &quot;spec.config.max_connections: value 10000 exceeds maximum allowed value of 1000 for database version 14.x&quot;\n\n❌ Bad: &quot;Update not allowed&quot;  \n✅ Good: &quot;spec.replicas: cannot decrease replica count from 5 to 2 in a single operation. Scale down gradually by reducing count by at most 1 replica per operation.&quot;</code></pre></div>\n\n<h3 id=\"mutating-webhook-implementation\">Mutating Webhook Implementation</h3>\n<p>Mutating admission webhooks modify incoming resources by injecting default values, adding required metadata, and transforming fields to ensure consistency across the cluster. These webhooks run before validating webhooks in the admission chain, allowing them to normalize resources before validation occurs.</p>\n<p>The mutation process uses <strong>JSON Patch</strong> operations to describe changes to the incoming resource. Rather than returning a modified copy of the entire resource, the webhook returns a list of patch operations that the API server applies to the original request. This approach is more efficient and provides better conflict resolution when multiple mutating webhooks modify the same resource.</p>\n<p><strong>JSON Patch Operations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Purpose</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>add</code></td>\n<td>Insert new field or array element</td>\n<td>Add default storage size</td>\n</tr>\n<tr>\n<td><code>replace</code></td>\n<td>Change value of existing field</td>\n<td>Normalize version string format</td>\n</tr>\n<tr>\n<td><code>remove</code></td>\n<td>Delete field or array element</td>\n<td>Remove deprecated fields</td>\n</tr>\n<tr>\n<td><code>move</code></td>\n<td>Relocate field within document</td>\n<td>Reorganize configuration structure</td>\n</tr>\n<tr>\n<td><code>copy</code></td>\n<td>Duplicate field value to another location</td>\n<td>Copy name to display name</td>\n</tr>\n<tr>\n<td><code>test</code></td>\n<td>Verify field has expected value</td>\n<td>Ensure field hasn&#39;t changed since mutation started</td>\n</tr>\n</tbody></table>\n<p><strong>Default Value Injection Strategy:</strong></p>\n<p>The <code>Default</code> method should implement smart defaulting that considers the environment and context:</p>\n<ol>\n<li><strong>Environment-Aware Defaults</strong>: Set different default resource requests for development vs production namespaces</li>\n<li><strong>Version-Appropriate Defaults</strong>: Apply defaults that are appropriate for the specified database version</li>\n<li><strong>Organizational Policy Defaults</strong>: Inject standard labels, annotations, and configuration that align with organizational policies</li>\n<li><strong>Resource-Dependent Defaults</strong>: Set memory requests based on storage size, adjust replica counts based on resource tier</li>\n</ol>\n<p><strong>Database Default Values Implementation:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Default Logic</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>spec.replicas</code></td>\n<td>1 for development namespaces, 3 for production</td>\n<td>Ensures high availability in production while keeping development lightweight</td>\n</tr>\n<tr>\n<td><code>spec.version</code></td>\n<td>Latest stable version from supported versions list</td>\n<td>Provides security updates while avoiding bleeding-edge releases</td>\n</tr>\n<tr>\n<td><code>spec.storageSize</code></td>\n<td>&quot;20Gi&quot; for single replica, &quot;100Gi&quot; for multi-replica</td>\n<td>Scales storage allocation with expected load</td>\n</tr>\n<tr>\n<td><code>spec.backupSchedule</code></td>\n<td>&quot;0 2 * * *&quot; (daily at 2 AM) if not specified</td>\n<td>Ensures data protection without manual configuration</td>\n</tr>\n<tr>\n<td><code>spec.resources.requests.memory</code></td>\n<td>Calculated as storageSize / 10</td>\n<td>Provides reasonable memory allocation based on database size</td>\n</tr>\n<tr>\n<td><code>spec.resources.requests.cpu</code></td>\n<td>&quot;500m&quot; for development, &quot;2&quot; for production</td>\n<td>Balances performance with resource efficiency</td>\n</tr>\n</tbody></table>\n<p>The mutation logic should be <strong>deterministic</strong> - given the same input resource and cluster state, it should always produce the same mutations. This ensures that repeated applications of the same YAML file don&#39;t cause unnecessary updates.</p>\n<blockquote>\n<p><strong>Decision: Default Value Source Hierarchy</strong></p>\n<ul>\n<li><strong>Context</strong>: Default values can come from multiple sources: CRD schema defaults, mutating webhooks, controller logic, or external configuration</li>\n<li><strong>Options Considered</strong>: CRD schema defaults only, webhook-based defaulting, external configuration service, hybrid approach</li>\n<li><strong>Decision</strong>: Hybrid approach with CRD schema for simple defaults, webhook for context-aware defaults</li>\n<li><strong>Rationale</strong>: CRD schema defaults work well for static values but cannot consider namespace, user context, or organizational policies. Webhooks can implement sophisticated defaulting logic.</li>\n<li><strong>Consequences</strong>: More complex implementation but enables smart defaults that improve user experience and enforce organizational standards</li>\n</ul>\n</blockquote>\n<p><strong>Mutation Ordering Considerations:</strong></p>\n<p>When multiple mutating webhooks are registered for the same resource type, Kubernetes calls them in alphabetical order by webhook name. This ordering is critical because later webhooks see the mutations applied by earlier webhooks. Design your webhook names carefully to ensure proper ordering:</p>\n<ul>\n<li><code>000-baseline-defaults</code>: Sets fundamental default values</li>\n<li><code>500-policy-injection</code>: Adds organizational policy requirements  </li>\n<li><code>900-finalization</code>: Performs final transformations and cleanup</li>\n</ul>\n<p><strong>Field Transformation Patterns:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Transformation Type</th>\n<th>Use Case</th>\n<th>Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Normalization</td>\n<td>Convert user input to canonical format</td>\n<td>Transform &quot;postgres:14&quot; to &quot;postgresql-14.6&quot;</td>\n</tr>\n<tr>\n<td>Policy Injection</td>\n<td>Add required organizational metadata</td>\n<td>Inject cost center labels, security scanning annotations</td>\n</tr>\n<tr>\n<td>Resource Calculation</td>\n<td>Derive resource requirements from high-level specs</td>\n<td>Calculate memory requests from connection pool size</td>\n</tr>\n<tr>\n<td>Configuration Generation</td>\n<td>Generate complex config from simple parameters</td>\n<td>Build database configuration map from performance tier</td>\n</tr>\n<tr>\n<td>Cross-Resource References</td>\n<td>Establish relationships between resources</td>\n<td>Set owner references, add finalizers</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Mutation Conflicts and Overwrites</strong></p>\n<p>When implementing mutating webhooks, be careful not to overwrite values that users explicitly set. A common mistake is unconditionally setting default values without checking if the field is already populated:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>❌ Bad: Always set spec.replicas = 3 for production\n✅ Good: Set spec.replicas = 3 only if spec.replicas is nil and namespace has production label</code></pre></div>\n\n<p>This ensures that users can override defaults when needed while still getting sensible default behavior for most cases.</p>\n<h3 id=\"tls-certificate-management\">TLS Certificate Management</h3>\n<p>Admission webhooks require HTTPS communication between the Kubernetes API server and the webhook endpoint. This requirement exists because webhooks handle sensitive resource data and admission decisions that affect cluster security. The API server validates webhook certificates against a trusted CA certificate, making certificate management a critical operational concern.</p>\n<p>The webhook server must present a valid TLS certificate that matches its service name and is signed by a Certificate Authority that the API server trusts. Kubernetes provides several approaches for managing these certificates, each with different complexity and automation characteristics.</p>\n<p><strong>Certificate Management Approaches:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Best For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cert-manager</td>\n<td>Automatic renewal, industry standard, handles CA distribution</td>\n<td>Additional dependency, requires cert-manager installation</td>\n<td>Production deployments</td>\n</tr>\n<tr>\n<td>Self-signed certificates</td>\n<td>No external dependencies, simple for development</td>\n<td>Manual renewal, complex CA distribution, security concerns</td>\n<td>Development and testing</td>\n</tr>\n<tr>\n<td>External CA integration</td>\n<td>Integrates with organizational PKI, auditable</td>\n<td>Complex setup, requires external CA access</td>\n<td>Enterprise environments</td>\n</tr>\n<tr>\n<td>Kubernetes CSR API</td>\n<td>Built into Kubernetes, no external dependencies</td>\n<td>Manual approval workflow, limited automation</td>\n<td>Controlled environments</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Certificate Management Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Webhook TLS certificates need provisioning, renewal, and distribution to API server configuration</li>\n<li><strong>Options Considered</strong>: Manual certificate management, cert-manager automation, Kubernetes CSR API, external CA integration</li>\n<li><strong>Decision</strong>: cert-manager for production, self-signed for development</li>\n<li><strong>Rationale</strong>: cert-manager provides robust automation with industry-standard ACME protocol support, while self-signed certificates reduce dependencies during development</li>\n<li><strong>Consequences</strong>: Production deployments require cert-manager installation, but operational overhead is minimal once configured</li>\n</ul>\n</blockquote>\n<p><strong>cert-manager Integration:</strong></p>\n<p>cert-manager automates the certificate lifecycle by creating <code>Certificate</code> resources that define the desired certificate properties. The cert-manager controller provisions certificates from various issuers (Let&#39;s Encrypt, HashiCorp Vault, self-signed CA) and automatically renews them before expiration.</p>\n<p><strong>Certificate Resource Configuration:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Value</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>spec.secretName</code></td>\n<td><code>database-webhook-certs</code></td>\n<td>Secret where certificate and key are stored</td>\n</tr>\n<tr>\n<td><code>spec.issuerRef.name</code></td>\n<td><code>selfsigned-issuer</code></td>\n<td>Certificate issuer (CA) to use for signing</td>\n</tr>\n<tr>\n<td><code>spec.issuerRef.kind</code></td>\n<td><code>ClusterIssuer</code></td>\n<td>Cluster-wide or namespace-scoped issuer</td>\n</tr>\n<tr>\n<td><code>spec.dnsNames</code></td>\n<td><code>[database-webhook.system.svc, database-webhook.system.svc.cluster.local]</code></td>\n<td>DNS names that certificate should be valid for</td>\n</tr>\n<tr>\n<td><code>spec.duration</code></td>\n<td><code>8760h</code> (1 year)</td>\n<td>Certificate validity period</td>\n</tr>\n<tr>\n<td><code>spec.renewBefore</code></td>\n<td><code>720h</code> (30 days)</td>\n<td>How long before expiry to renew</td>\n</tr>\n</tbody></table>\n<p><strong>Webhook Configuration TLS Setup:</strong></p>\n<p>The <code>ValidatingAdmissionWebhook</code> and <code>MutatingAdmissionWebhook</code> configurations must reference the CA certificate that signed the webhook&#39;s TLS certificate. cert-manager can automatically inject this CA bundle using the <code>cert-manager.io/inject-ca-from</code> annotation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">yaml</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#85E89D\">metadata</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  annotations</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    cert-manager.io/inject-ca-from</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">system/selfsigned-issuer</span></span></code></pre></div>\n\n<p>This annotation instructs cert-manager to populate the <code>caBundle</code> field in the webhook configuration with the appropriate CA certificate, ensuring the API server can validate the webhook&#39;s TLS certificate.</p>\n<p><strong>Certificate Rotation and High Availability:</strong></p>\n<p>Certificate rotation happens automatically when cert-manager renews certificates. The controller updates the secret containing the certificate and private key, and the webhook server must reload these certificates without downtime. Implement certificate reloading by:</p>\n<ol>\n<li><strong>Watching the certificate secret</strong> for changes using a Kubernetes informer</li>\n<li><strong>Gracefully reloading</strong> the TLS configuration without dropping existing connections  </li>\n<li><strong>Health checking</strong> the new certificate before switching to ensure validity</li>\n<li><strong>Logging certificate events</strong> for operational visibility and debugging</li>\n</ol>\n<p>For high availability deployments with multiple webhook replicas, ensure that certificate updates propagate to all instances consistently. Use a shared secret for certificate storage and implement proper leader election if coordination is needed during certificate transitions.</p>\n<p><strong>Development Certificate Setup:</strong></p>\n<p>For development environments, self-signed certificates provide a simpler alternative that avoids external dependencies:</p>\n<ol>\n<li><strong>Generate a CA key and certificate</strong> for signing webhook certificates</li>\n<li><strong>Create a webhook certificate</strong> signed by the development CA with appropriate DNS names</li>\n<li><strong>Store certificates in Kubernetes secrets</strong> using the same naming conventions as production</li>\n<li><strong>Configure webhook registration</strong> with the CA bundle for validation</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Certificate DNS Name Mismatches</strong></p>\n<p>A common certificate error occurs when the webhook certificate doesn&#39;t include all the DNS names that the API server might use to connect to the webhook service. The certificate must include:</p>\n<ul>\n<li><code>service-name.namespace.svc</code> (standard service DNS name)</li>\n<li><code>service-name.namespace.svc.cluster.local</code> (fully qualified service DNS name)  </li>\n<li>Any additional DNS names if using custom networking or ingress</li>\n</ul>\n<p>Missing DNS names in the certificate cause connection failures with TLS verification errors that can be difficult to diagnose.</p>\n<p><strong>Certificate Monitoring and Observability:</strong></p>\n<p>Implement monitoring for certificate health to prevent webhook failures due to certificate expiration:</p>\n<table>\n<thead>\n<tr>\n<th>Metric</th>\n<th>Purpose</th>\n<th>Alert Threshold</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Certificate expiry time</td>\n<td>Track time until certificate expiration</td>\n<td>Alert 7 days before expiry</td>\n</tr>\n<tr>\n<td>Certificate renewal success</td>\n<td>Monitor automatic renewal operations</td>\n<td>Alert on renewal failures</td>\n</tr>\n<tr>\n<td>Webhook TLS handshake errors</td>\n<td>Track TLS connection failures</td>\n<td>Alert on increased error rate</td>\n</tr>\n<tr>\n<td>cert-manager controller health</td>\n<td>Ensure cert-manager is running properly</td>\n<td>Alert on controller downtime</td>\n</tr>\n</tbody></table>\n<p>Certificate-related webhook failures often manifest as cryptic TLS errors in API server logs. Establish clear runbooks for certificate troubleshooting that cover common scenarios like expired certificates, CA bundle mismatches, and renewal failures.</p>\n<p><img src=\"/api/project/kubernetes-operator/architecture-doc/asset?path=diagrams%2Fresource-creation-sequence.svg\" alt=\"Resource Creation and Validation Sequence\"></p>\n<p><img src=\"/api/project/kubernetes-operator/architecture-doc/asset?path=diagrams%2Fwebhook-request-flow.svg\" alt=\"Admission Webhook Request Flow\"></p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Building admission webhooks requires careful attention to HTTP server implementation, JSON processing, and certificate management. This section provides complete infrastructure code and implementation skeletons that handle the operational complexities while leaving the core validation and mutation logic for you to implement.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP Server</td>\n<td>net/http with standard library</td>\n<td>controller-runtime webhook server</td>\n</tr>\n<tr>\n<td>JSON Processing</td>\n<td>encoding/json for AdmissionReview</td>\n<td>controller-runtime admission package</td>\n</tr>\n<tr>\n<td>Certificate Management</td>\n<td>Self-signed certificates with openssl</td>\n<td>cert-manager with Certificate resources</td>\n</tr>\n<tr>\n<td>TLS Configuration</td>\n<td>tls.LoadX509KeyPair for static certificates</td>\n<td>Dynamic certificate reloading with fsnotify</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>httptest for webhook endpoint testing</td>\n<td>envtest with real admission controller</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/webhooks/\n  admission.go              ← AdmissionReview request/response handling\n  database_defaulter.go     ← Mutating webhook implementation\n  database_validator.go     ← Validating webhook implementation\n  webhook_server.go         ← HTTP server and certificate management\n  admission_test.go         ← Unit tests for webhook logic\nconfig/webhook/\n  manifests.yaml           ← Webhook registration YAML\n  certificate.yaml         ← cert-manager Certificate resource\ndeploy/certificates/\n  ca.crt                   ← Development CA certificate\n  tls.crt                  ← Development webhook certificate  \n  tls.key                  ← Development webhook private key</code></pre></div>\n\n<p><strong>Complete Admission Infrastructure (admission.go):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> webhooks</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    admissionv1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/admission/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metav1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/apis/meta/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime/serializer</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    utilruntime </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/util/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/webhook/admission</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scheme </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> runtime.</span><span style=\"color:#B392F0\">NewScheme</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    codecs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> serializer.</span><span style=\"color:#B392F0\">NewCodecFactory</span><span style=\"color:#E1E4E8\">(scheme)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> init</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    utilruntime.</span><span style=\"color:#B392F0\">Must</span><span style=\"color:#E1E4E8\">(admissionv1.</span><span style=\"color:#B392F0\">AddToScheme</span><span style=\"color:#E1E4E8\">(scheme))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AdmissionHandler wraps validation and mutation logic in HTTP handler</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AdmissionHandler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    decoder </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">admission</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Decoder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewAdmissionHandler creates an admission handler with proper decoding setup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewAdmissionHandler</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdmissionHandler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">AdmissionHandler</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        decoder: admission.</span><span style=\"color:#B392F0\">NewDecoder</span><span style=\"color:#E1E4E8\">(scheme),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ServeHTTP handles incoming admission review requests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdmissionHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ServeHTTP</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> log.</span><span style=\"color:#B392F0\">FromContext</span><span style=\"color:#E1E4E8\">(r.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parse AdmissionReview from request body</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    body </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, r.ContentLength)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.Body.</span><span style=\"color:#B392F0\">Read</span><span style=\"color:#E1E4E8\">(body); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"Failed to read request body\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        http.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(w, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(), http.StatusBadRequest)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> admissionReview </span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionReview</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(body, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">admissionReview); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"Failed to unmarshal AdmissionReview\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        http.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(w, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(), http.StatusBadRequest)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Process the admission request</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">processAdmissionReview</span><span style=\"color:#E1E4E8\">(r.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">admissionReview)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Send AdmissionReview response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    responseBytes, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Marshal</span><span style=\"color:#E1E4E8\">(response)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"Failed to marshal AdmissionResponse\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        http.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(w, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(), http.StatusInternalServerError)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Write</span><span style=\"color:#E1E4E8\">(responseBytes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdmissionHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">processAdmissionReview</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    review</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionReview</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionReview</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    req </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> review.Request</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        UID: req.UID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Allowed: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Route to appropriate handler based on operation and resource</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> req.Kind.Kind </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"Database\"</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> req.Operation </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> admissionv1.Create:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        response </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">handleDatabaseCreate</span><span style=\"color:#E1E4E8\">(ctx, req)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> req.Kind.Kind </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"Database\"</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> req.Operation </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> admissionv1.Update:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        response </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">handleDatabaseUpdate</span><span style=\"color:#E1E4E8\">(ctx, req)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> req.Kind.Kind </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"Database\"</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> req.Operation </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> admissionv1.Delete:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        response </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">handleDatabaseDelete</span><span style=\"color:#E1E4E8\">(ctx, req)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Allow operations on unknown resources</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        response.Allowed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionReview</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TypeMeta: </span><span style=\"color:#B392F0\">metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TypeMeta</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            APIVersion: </span><span style=\"color:#9ECBFF\">\"admission.k8s.io/v1\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Kind:       </span><span style=\"color:#9ECBFF\">\"AdmissionReview\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Response: response,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Validation Logic Skeleton (database_validator.go):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> webhooks</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strconv</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strings</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    admissionv1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/admission/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metav1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/apis/meta/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    databasev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/example/database-operator/api/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleDatabaseCreate validates new Database resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdmissionHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleDatabaseCreate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    req</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionRequest</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> database </span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(req.Object.Raw, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">database); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            UID: req.UID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Allowed: </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Result: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Status</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Message: fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to decode Database: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate spec.version is in supported versions list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Define supportedVersions = []string{\"14.6\", \"15.1\", \"15.2\"}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate spec.storageSize format and minimum size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use resource.ParseQuantity() and compare against minimum (1Gi)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate spec.replicas is within allowed range (1-10)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check database.Spec.Replicas >= 1 &#x26;&#x26; database.Spec.Replicas &#x3C;= 10</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate spec.backupSchedule cron expression if provided</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use \"github.com/robfig/cron/v3\" parser.Parse()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Validate spec.config map contains only allowed keys</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Define allowedConfigKeys and check all keys in database.Spec.Config</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        UID: req.UID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Allowed: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleDatabaseUpdate validates changes to existing Database resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdmissionHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleDatabaseUpdate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    req</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionRequest</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> oldDatabase, newDatabase </span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(req.OldObject.Raw, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">oldDatabase); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            UID: req.UID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Allowed: </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Result: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Status</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Message: fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to decode old Database: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(req.Object.Raw, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">newDatabase); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            UID: req.UID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Allowed: </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Result: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Status</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Message: fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to decode new Database: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate storage size is not decreased</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Parse both sizes and compare: newSize >= oldSize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate version changes are upgrade-only (no downgrades)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Compare version numbers, reject if newVersion &#x3C; oldVersion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate replica scaling follows safe patterns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Allow scaling up freely, but limit scaling down to max 1 replica per operation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate immutable fields haven't changed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check that critical fields like database name/type remain unchanged</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        UID: req.UID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Allowed: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleDatabaseDelete validates Database deletion requests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdmissionHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleDatabaseDelete</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    req</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionRequest</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if database has dependent resources that need cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Look for finalizers that indicate cleanup is required</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate deletion is allowed based on database state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Prevent deletion if database is in \"backup-in-progress\" state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check for protection annotations that prevent deletion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Look for \"database.example.com/protect: true\" annotation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        UID: req.UID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Allowed: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Mutation Logic Skeleton (database_defaulter.go):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> webhooks</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    admissionv1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/admission/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    corev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/core/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/api/resource</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metav1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/apis/meta/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    databasev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/example/database-operator/api/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleDatabaseDefaulting applies default values to new Database resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdmissionHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleDatabaseDefaulting</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    req</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionRequest</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> database </span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(req.Object.Raw, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">database); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            UID: req.UID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Allowed: </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Result: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Status</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Message: fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to decode Database: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> patches []</span><span style=\"color:#B392F0\">JSONPatch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Set default replicas based on namespace environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check namespace labels for \"environment=production\" → 3 replicas, else 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set default version to latest stable if not specified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: if database.Spec.Version == \"\" { patches = append(...) }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set default storage size based on replica count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Single replica → 20Gi, Multiple replicas → 100Gi</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Generate default backup schedule if not provided</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use \"0 2 * * *\" for daily backups at 2 AM</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Calculate default resource requests based on storage size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Memory = StorageSize / 10, CPU = \"500m\" for dev, \"2\" for prod</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Inject organizational labels and annotations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Add cost-center, team, and monitoring labels</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(patches) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            UID: req.UID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Allowed: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    patchBytes, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Marshal</span><span style=\"color:#E1E4E8\">(patches)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            UID: req.UID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Allowed: </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Result: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Status</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Message: fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to marshal patches: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    patchType </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> admissionv1.PatchTypeJSONPatch</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        UID: req.UID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Allowed: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Patch: patchBytes,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PatchType: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">patchType,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// JSONPatch represents a JSON patch operation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> JSONPatch</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Op    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"op\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Path  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Value </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"value,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper function to create an \"add\" patch operation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> createAddPatch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#B392F0\">JSONPatch</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> JSONPatch</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Op:    </span><span style=\"color:#9ECBFF\">\"add\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Path:  path,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Value: value,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper function to create a \"replace\" patch operation  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> createReplacePatch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">path</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#B392F0\">JSONPatch</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> JSONPatch</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Op:    </span><span style=\"color:#9ECBFF\">\"replace\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Path:  path,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Value: value,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Complete Webhook Server Setup (webhook_server.go):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> webhooks</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/tls</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/util/wait</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/healthz</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/manager</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/webhook</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WebhookPort</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 9443</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CertDir</span><span style=\"color:#F97583\">     =</span><span style=\"color:#9ECBFF\"> \"/tmp/k8s-webhook-server/serving-certs\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CertName</span><span style=\"color:#F97583\">    =</span><span style=\"color:#9ECBFF\"> \"tls.crt\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    KeyName</span><span style=\"color:#F97583\">     =</span><span style=\"color:#9ECBFF\"> \"tls.key\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetupWebhookServer configures the webhook server with TLS and health checks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> SetupWebhookServer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mgr</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hookServer </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> mgr.</span><span style=\"color:#B392F0\">GetWebhookServer</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configure TLS certificate paths</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hookServer.Port </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> WebhookPort</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hookServer.CertDir </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CertDir</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hookServer.CertName </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> CertName</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hookServer.KeyName </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> KeyName</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Register admission handlers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    admissionHandler </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewAdmissionHandler</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hookServer.</span><span style=\"color:#B392F0\">Register</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/mutate\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">webhook</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Admission</span><span style=\"color:#E1E4E8\">{Handler: admissionHandler})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hookServer.</span><span style=\"color:#B392F0\">Register</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/validate\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">webhook</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Admission</span><span style=\"color:#E1E4E8\">{Handler: admissionHandler})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add health check endpoints</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> mgr.</span><span style=\"color:#B392F0\">AddHealthzCheck</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"webhook\"</span><span style=\"color:#E1E4E8\">, healthz.Ping); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to add health check: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> mgr.</span><span style=\"color:#B392F0\">AddReadyzCheck</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"webhook\"</span><span style=\"color:#E1E4E8\">, healthz.Ping); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to add ready check: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CertificateReloader handles dynamic certificate reloading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CertificateReloader</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    certPath </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    keyPath  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cert     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">tls</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Certificate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewCertificateReloader creates a certificate reloader for the given paths</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCertificateReloader</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">certPath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">keyPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CertificateReloader</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    reloader </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CertificateReloader</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        certPath: certPath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keyPath:  keyPath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> reloader.</span><span style=\"color:#B392F0\">loadCertificate</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to load initial certificate: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> reloader, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CertificateReloader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">loadCertificate</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cert, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tls.</span><span style=\"color:#B392F0\">LoadX509KeyPair</span><span style=\"color:#E1E4E8\">(r.certPath, r.keyPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r.cert </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">cert</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetCertificate returns the current certificate (implements tls.Config.GetCertificate)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CertificateReloader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetCertificate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">tls</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ClientHelloInfo</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">tls</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Certificate</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> r.cert, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Start begins watching for certificate changes and reloading automatically</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CertificateReloader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> log.</span><span style=\"color:#B392F0\">FromContext</span><span style=\"color:#E1E4E8\">(ctx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> wait.</span><span style=\"color:#B392F0\">PollImmediateUntil</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">time.Second, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">loadCertificate</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            logger.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"Failed to reload certificate\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#6A737D\"> // Continue polling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Certificate reloaded successfully\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#6A737D\"> // Continue polling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Implementation Hints:</strong></p>\n<ul>\n<li><strong>JSON Patch Operations</strong>: Use the <code>JSONPatch</code> struct to build mutation operations. The <code>path</code> field uses JSON Pointer syntax (e.g., <code>/spec/replicas</code>, <code>/metadata/labels/environment</code>)</li>\n<li><strong>AdmissionReview Handling</strong>: Always copy the request UID to the response UID - this is required for proper request tracking</li>\n<li><strong>Error Response Formatting</strong>: Use <code>metav1.Status</code> for structured error responses with appropriate HTTP status codes (400 for validation errors, 500 for internal errors)</li>\n<li><strong>TLS Certificate Loading</strong>: Use <code>tls.LoadX509KeyPair()</code> for loading certificates and implement <code>GetCertificate</code> callback for dynamic reloading</li>\n<li><strong>Resource Quantity Parsing</strong>: Use <code>resource.ParseQuantity()</code> for validating storage sizes and resource limits</li>\n</ul>\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing the webhook logic, verify the following behavior:</p>\n<ol>\n<li><strong>Webhook Registration</strong>: <code>kubectl get validatingadmissionwebhooks</code> and <code>kubectl get mutatingadmissionwebhooks</code> show your webhooks</li>\n<li><strong>Certificate Validation</strong>: Check that webhook pod logs show successful TLS certificate loading</li>\n<li><strong>Mutation Behavior</strong>: Create a <code>Database</code> resource with minimal spec and verify defaults are applied</li>\n<li><strong>Validation Behavior</strong>: Try creating invalid <code>Database</code> resources and verify they are rejected with clear error messages</li>\n<li><strong>Update Validation</strong>: Try invalid updates (like decreasing storage size) and verify they are properly blocked</li>\n</ol>\n<p><strong>Common Debugging Scenarios:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;connection refused&quot; errors</td>\n<td>Webhook server not running or wrong port</td>\n<td>Check pod logs and service endpoints</td>\n<td>Verify webhook server is listening on correct port</td>\n</tr>\n<tr>\n<td>&quot;certificate verification failed&quot;</td>\n<td>CA bundle mismatch or expired certificate</td>\n<td>Check webhook configuration caBundle vs actual cert</td>\n<td>Update caBundle or renew certificate</td>\n</tr>\n<tr>\n<td>&quot;webhook timeout&quot; errors</td>\n<td>Webhook processing too slow or hanging</td>\n<td>Check webhook response time and goroutine leaks</td>\n<td>Optimize validation logic, add timeouts</td>\n</tr>\n<tr>\n<td>&quot;admission webhook denied&quot; without clear reason</td>\n<td>Poor error message formatting</td>\n<td>Check AdmissionResponse.Result.Message field</td>\n<td>Improve error message content and structure</td>\n</tr>\n<tr>\n<td>Mutations not being applied</td>\n<td>Webhook called but patches malformed</td>\n<td>Check JSON patch syntax and field paths</td>\n<td>Validate patch operations against JSON Pointer spec</td>\n</tr>\n</tbody></table>\n<h2 id=\"component-interactions-and-data-flow\">Component Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3 (Reconciliation Loop), Milestone 4 (Webhooks), Milestone 5 (Testing &amp; Deployment) - demonstrates the orchestrated behavior between controller, webhooks, and API server during complete resource lifecycle operations</p>\n</blockquote>\n<p>The interaction between the operator&#39;s components creates a sophisticated orchestration that maintains system consistency while handling the complexities of distributed operations. Understanding these interaction patterns is crucial for building operators that behave predictably under both normal conditions and failure scenarios.</p>\n<h3 id=\"mental-model-the-orchestra-conductor\">Mental Model: The Orchestra Conductor</h3>\n<p>Think of the Kubernetes API server as an orchestra conductor coordinating multiple musicians (the controller and webhooks). When someone in the audience (a user) requests a song (creates a resource), the conductor first asks the first violin section (mutating webhooks) to tune their instruments (apply defaults), then asks the brass section (validating webhooks) to confirm they can play the piece (validate the request). Only after everyone agrees does the conductor store the sheet music (persist the resource) and signal the orchestra to begin playing (trigger controller reconciliation). Throughout the performance, musicians continuously watch the conductor for tempo changes (status updates) and adjust their playing accordingly.</p>\n<p>This mental model helps explain why webhook failures can block resource creation (the brass section refusing to play stops the entire orchestra) and why controller reconciliation happens asynchronously (the orchestra continues playing even if some audience members leave).</p>\n<p><img src=\"/api/project/kubernetes-operator/architecture-doc/asset?path=diagrams%2Freconciliation-state-machine.svg\" alt=\"Resource Reconciliation State Machine\"></p>\n<p><img src=\"/api/project/kubernetes-operator/architecture-doc/asset?path=diagrams%2Fresource-creation-sequence.svg\" alt=\"Resource Creation and Validation Sequence\"></p>\n<h3 id=\"resource-creation-flow\">Resource Creation Flow</h3>\n<p>The resource creation flow represents the most complex interaction pattern in the operator ecosystem, involving multiple validation and processing stages that must complete successfully before the controller begins reconciliation. This flow demonstrates how Kubernetes&#39; admission control system provides strong consistency guarantees while allowing operators to extend the platform&#39;s behavior.</p>\n<h4 id=\"pre-storage-validation-pipeline\">Pre-Storage Validation Pipeline</h4>\n<p>When a user submits a <code>Database</code> resource through <code>kubectl apply</code>, the API server initiates a multi-stage validation pipeline before the resource reaches persistent storage. This pipeline ensures that only valid, properly configured resources enter the cluster state, preventing downstream controller errors and maintaining system integrity.</p>\n<p>The API server first performs schema validation against the CRD&#39;s OpenAPI v3 specification, rejecting resources that violate basic type constraints or required field rules. This validation catches structural errors like missing required fields, incorrect field types, or values that exceed defined string length limits. Schema validation provides the first line of defense against malformed resources, ensuring that subsequent processing stages can assume basic structural correctness.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Stage</th>\n<th>Purpose</th>\n<th>Failure Impact</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Schema Validation</td>\n<td>Type safety and required fields</td>\n<td>Immediate rejection with schema error</td>\n<td>Fix resource definition and reapply</td>\n</tr>\n<tr>\n<td>Mutating Webhook</td>\n<td>Default value injection</td>\n<td>Webhook timeout or denial</td>\n<td>Check webhook pod logs and certificate</td>\n</tr>\n<tr>\n<td>Validating Webhook</td>\n<td>Business rule enforcement</td>\n<td>Resource creation blocked</td>\n<td>Address validation error and resubmit</td>\n</tr>\n<tr>\n<td>Storage Layer</td>\n<td>Optimistic concurrency control</td>\n<td>Conflict on resource version</td>\n<td>Retry with fresh resource version</td>\n</tr>\n</tbody></table>\n<p>After schema validation succeeds, the API server invokes any configured mutating webhooks in the order specified by their admission registration. The mutating webhook receives an <code>AdmissionReview</code> containing the proposed resource and can modify field values before storage occurs. Common mutations include injecting default values for optional fields, adding labels or annotations for operational tracking, or transforming user-friendly field values into internal representations.</p>\n<blockquote>\n<p><strong>Design Insight: Mutation Order Matters</strong></p>\n<p>Multiple mutating webhooks execute in a defined sequence, with each webhook receiving the potentially modified resource from previous webhooks. This creates a pipeline where early webhooks can set defaults that later webhooks can validate or further modify. Operators must consider this ordering when designing webhook logic to avoid conflicts or unexpected interactions between different mutation policies.</p>\n</blockquote>\n<h4 id=\"mutating-webhook-processing\">Mutating Webhook Processing</h4>\n<p>The mutating webhook implementation receives admission review requests containing the raw resource JSON along with metadata about the operation context. The webhook deserializes this JSON into the <code>Database</code> struct, applies default values for any unspecified optional fields, and returns a JSON patch describing the required modifications.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Mutating Webhook Request Processing:\n1. API server serializes Database resource to JSON\n2. API server constructs AdmissionReview with resource JSON and operation metadata  \n3. API server sends HTTPS POST to webhook endpoint with AdmissionReview\n4. Webhook deserializes AdmissionReview and extracts Database resource\n5. Webhook applies defaulting logic to populate missing optional fields\n6. Webhook generates JSON patch operations for modified fields\n7. Webhook returns AdmissionResponse with patch and admission decision\n8. API server applies patch to original resource JSON\n9. Modified resource proceeds to validating webhook stage</code></pre></div>\n\n<p>The JSON patch format provides precise control over field modifications, supporting operations like adding missing fields, replacing existing values, or removing unwanted elements. This precision ensures that webhooks only modify their intended fields without accidentally affecting other resource properties.</p>\n<table>\n<thead>\n<tr>\n<th>Default Field</th>\n<th>Condition</th>\n<th>Applied Value</th>\n<th>Justification</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>StorageSize</code></td>\n<td>If empty or unspecified</td>\n<td>&quot;10Gi&quot;</td>\n<td>Reasonable default for development databases</td>\n</tr>\n<tr>\n<td><code>Replicas</code></td>\n<td>If zero or negative</td>\n<td>1</td>\n<td>Single replica provides basic functionality</td>\n</tr>\n<tr>\n<td><code>Version</code></td>\n<td>If empty string</td>\n<td>&quot;14.5&quot;</td>\n<td>Current stable PostgreSQL release</td>\n</tr>\n<tr>\n<td><code>Resources.Limits</code></td>\n<td>If nil</td>\n<td>CPU: &quot;500m&quot;, Memory: &quot;512Mi&quot;</td>\n<td>Prevent resource exhaustion</td>\n</tr>\n<tr>\n<td><code>Config</code></td>\n<td>If nil</td>\n<td><code>map[string]string{&quot;shared_buffers&quot;: &quot;256MB&quot;}</code></td>\n<td>Basic performance tuning</td>\n</tr>\n</tbody></table>\n<h4 id=\"validating-webhook-processing\">Validating Webhook Processing</h4>\n<p>After successful mutation, the API server invokes validating webhooks to enforce business rules and cross-field validation constraints that cannot be expressed in the OpenAPI schema. Unlike mutating webhooks, validating webhooks cannot modify the resource but can reject the entire operation by returning a denial response.</p>\n<p>The validating webhook performs comprehensive business logic validation, checking constraints like database version compatibility, resource requirement feasibility, and configuration parameter validity. These validations often require external knowledge or complex logic that exceeds the capabilities of declarative schema validation.</p>\n<p>Common validation scenarios include verifying that the requested <code>StorageSize</code> is larger than any existing persistent volume claims, ensuring that the specified <code>Version</code> is compatible with upgrade paths from currently running versions, and validating that custom configuration parameters in the <code>Config</code> map use valid PostgreSQL settings with appropriate values.</p>\n<blockquote>\n<p><strong>Decision: Webhook vs Schema Validation Split</strong></p>\n<ul>\n<li><strong>Context</strong>: Complex validation logic can be implemented in webhooks or expressed in CRD schemas using CEL expressions</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Implement all validation in admission webhooks with full programming flexibility</li>\n<li>Use CEL expressions in CRD schema for all validation logic</li>\n<li>Hybrid approach with schema validation for simple rules and webhooks for complex logic</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Hybrid approach with simple validations in schema and complex business rules in webhooks</li>\n<li><strong>Rationale</strong>: Schema validation provides faster feedback and better error messages for simple constraints, while webhooks handle complex logic requiring external state or computations</li>\n<li><strong>Consequences</strong>: Reduces webhook load for simple validation failures while maintaining flexibility for sophisticated business rules</li>\n</ul>\n</blockquote>\n<h4 id=\"storage-and-initial-status\">Storage and Initial Status</h4>\n<p>Once all webhook validations pass, the API server commits the resource to etcd storage and initializes the status subresource with default condition values. The newly stored resource receives a unique <code>resourceVersion</code> that enables optimistic concurrency control for subsequent updates.</p>\n<p>The initial status includes a <code>Progressing</code> condition set to <code>True</code> with a reason of &quot;ResourceCreated&quot;, indicating that the controller should begin reconciliation processing. The <code>ObservedGeneration</code> field initializes to zero, signaling that no controller reconciliation has occurred yet.</p>\n<table>\n<thead>\n<tr>\n<th>Initial Status Field</th>\n<th>Value</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Conditions</code></td>\n<td><code>[{Type: &quot;Progressing&quot;, Status: &quot;True&quot;, Reason: &quot;ResourceCreated&quot;}]</code></td>\n<td>Indicates pending reconciliation</td>\n</tr>\n<tr>\n<td><code>ReadyReplicas</code></td>\n<td>0</td>\n<td>No workloads created yet</td>\n</tr>\n<tr>\n<td><code>ObservedGeneration</code></td>\n<td>0</td>\n<td>No reconciliation completed</td>\n</tr>\n<tr>\n<td><code>Phase</code></td>\n<td>&quot;Pending&quot;</td>\n<td>Resource awaiting controller processing</td>\n</tr>\n<tr>\n<td><code>Message</code></td>\n<td>&quot;Resource created, awaiting reconciliation&quot;</td>\n<td>Human-readable status</td>\n</tr>\n</tbody></table>\n<h3 id=\"update-and-reconciliation-flow\">Update and Reconciliation Flow</h3>\n<p>The update and reconciliation flow demonstrates how the operator maintains system consistency when users modify existing resources or when external conditions change the actual cluster state. This flow showcases the declarative nature of Kubernetes operators, where controllers continuously work to align actual state with desired state regardless of what triggered the divergence.</p>\n<h4 id=\"spec-change-detection\">Spec Change Detection</h4>\n<p>When users modify a <code>Database</code> resource specification, the API server increments the resource&#39;s <code>generation</code> field and processes the update through the same webhook pipeline used during creation. However, validating webhooks receive both the old and new resource versions, enabling validation logic that considers the implications of specific changes.</p>\n<p>The controller&#39;s informer cache detects the specification change through its watch connection to the API server. The shared informer compares the new resource version against its cached copy and triggers an update event that enqueues the resource key for reconciliation processing.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Update Detection and Queuing:\n1. User submits resource update via kubectl apply or API call\n2. API server processes update through mutating and validating webhooks  \n3. API server increments generation field and stores modified resource\n4. Controller informer receives watch event with updated resource\n5. Event handler compares new generation against cached generation\n6. If generation changed, handler enqueues resource key in work queue\n7. Controller worker goroutine dequeues key and begins reconciliation\n8. Reconciler fetches fresh resource version from cache\n9. Reconciler compares generation vs observedGeneration to detect changes</code></pre></div>\n\n<p>The controller uses generation comparison to distinguish between user-initiated spec changes and controller-initiated status updates. Only when <code>metadata.generation</code> exceeds <code>status.observedGeneration</code> does the controller recognize that new reconciliation work is required.</p>\n<h4 id=\"incremental-reconciliation-strategy\">Incremental Reconciliation Strategy</h4>\n<p>Rather than recreating all owned resources during every reconciliation, the controller implements incremental updates that modify only the specific resources affected by the spec change. This approach minimizes disruption to running workloads and reduces the risk of cascading failures during updates.</p>\n<p>The reconciler fetches the current state of all owned resources and compares their configuration against the desired state derived from the updated spec. For each owned resource, the controller determines whether creation, update, or deletion is required to align with the new desired state.</p>\n<table>\n<thead>\n<tr>\n<th>Change Type</th>\n<th>Affected Resources</th>\n<th>Reconciliation Action</th>\n<th>Disruption Level</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Replica count increase</td>\n<td>StatefulSet, Service</td>\n<td>Update StatefulSet replicas field</td>\n<td>Rolling scale-up</td>\n</tr>\n<tr>\n<td>Replica count decrease</td>\n<td>StatefulSet, Service</td>\n<td>Update StatefulSet replicas field</td>\n<td>Rolling scale-down</td>\n</tr>\n<tr>\n<td>Storage size increase</td>\n<td>PersistentVolumeClaim</td>\n<td>Create new PVC, migrate data</td>\n<td>High disruption</td>\n</tr>\n<tr>\n<td>Version upgrade</td>\n<td>StatefulSet, ConfigMap</td>\n<td>Update image and configuration</td>\n<td>Rolling restart</td>\n</tr>\n<tr>\n<td>Configuration change</td>\n<td>ConfigMap, StatefulSet</td>\n<td>Update ConfigMap, restart pods</td>\n<td>Controlled restart</td>\n</tr>\n<tr>\n<td>Resource limits change</td>\n<td>StatefulSet</td>\n<td>Update pod template resources</td>\n<td>Rolling restart</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Insight: Storage Size Immutability</strong></p>\n<p>Kubernetes PersistentVolumeClaims cannot be resized in all storage classes, and decreasing storage size is never supported. The controller must detect storage size changes and implement appropriate strategies like creating new volumes and orchestrating data migration rather than attempting in-place PVC modifications that will fail.</p>\n</blockquote>\n<h4 id=\"status-update-propagation\">Status Update Propagation</h4>\n<p>After completing reconciliation actions, the controller updates the <code>Database</code> status subresource to reflect the current state of owned resources and the progress of the reconciliation operation. Status updates use a separate API call to the status subresource, preventing race conditions between controller status updates and user spec modifications.</p>\n<p>The controller aggregates status information from all owned resources, computing values like <code>ReadyReplicas</code> from the StatefulSet status and updating condition states based on the overall health of the database deployment. The <code>ObservedGeneration</code> field advances to match the current <code>metadata.generation</code>, indicating that reconciliation has processed the latest spec changes.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Status Update Process:\n1. Controller completes reconciliation actions for owned resources\n2. Controller queries current status of all owned resources  \n3. Controller aggregates health information from StatefulSet, Services, PVCs\n4. Controller computes overall readiness state and condition values\n5. Controller constructs updated DatabaseStatus with current state\n6. Controller calls status subresource API to persist status changes\n7. Controller sets ObservedGeneration to current metadata.generation\n8. Controller updates LastTransitionTime for any changed conditions\n9. Updated status becomes visible to users via kubectl get database</code></pre></div>\n\n<p>The status update includes human-readable messages that help users understand the current state and any issues that might prevent successful reconciliation. These messages appear in <code>kubectl describe</code> output and provide valuable debugging information when troubleshooting deployment problems.</p>\n<h3 id=\"deletion-and-cleanup-flow\">Deletion and Cleanup Flow</h3>\n<p>The deletion and cleanup flow represents the most complex interaction pattern because it must coordinate resource cleanup across multiple Kubernetes objects while respecting dependency relationships and handling potential failures during the cleanup process. This flow demonstrates how finalizers provide deletion safety in distributed systems where cleanup operations may take significant time or encounter transient failures.</p>\n<h4 id=\"finalizer-protected-deletion\">Finalizer-Protected Deletion</h4>\n<p>When users delete a <code>Database</code> resource, Kubernetes does not immediately remove the resource from storage if finalizers are present in the <code>metadata.finalizers</code> array. Instead, the API server sets the <code>metadata.deletionTimestamp</code> field and waits for controllers to remove their finalizers after completing cleanup operations.</p>\n<p>The <code>DatabaseReconciler</code> adds the <code>FINALIZER_NAME</code> to newly created resources during their first reconciliation, ensuring that deletion cannot proceed without controller involvement. This finalizer acts as a safety mechanism that prevents orphaned resources when users delete the parent <code>Database</code> object.</p>\n<table>\n<thead>\n<tr>\n<th>Finalizer</th>\n<th>Purpose</th>\n<th>Cleanup Responsibility</th>\n<th>Removal Condition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>database.example.com/finalizer</code></td>\n<td>Owned resource cleanup</td>\n<td>Delete StatefulSet, Services, ConfigMaps, PVCs</td>\n<td>All owned resources successfully deleted</td>\n</tr>\n<tr>\n<td><code>database.example.com/backup-finalizer</code></td>\n<td>Backup completion</td>\n<td>Ensure backup job completes or fails</td>\n<td>Backup job reaches terminal state</td>\n</tr>\n<tr>\n<td><code>external-secrets.io/finalizer</code></td>\n<td>Secret cleanup</td>\n<td>Remove database credentials from external systems</td>\n<td>External secret deletion confirmed</td>\n</tr>\n</tbody></table>\n<p>The controller detects deletion requests by checking for the presence of <code>metadata.deletionTimestamp</code> during reconciliation. When this timestamp is set, the controller switches from normal reconciliation logic to deletion processing, focusing exclusively on cleanup operations rather than maintaining desired state.</p>\n<h4 id=\"ordered-resource-cleanup\">Ordered Resource Cleanup</h4>\n<p>The cleanup process follows a specific order designed to minimize data loss risk and prevent dependency violations. The controller begins by stopping new connections to the database, then drains existing connections, performs final backups, and finally removes storage resources.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Deletion Processing Order:\n1. Controller detects deletionTimestamp is set on Database resource\n2. Controller updates status phase to &quot;Terminating&quot; \n3. Controller initiates graceful shutdown of database pods via StatefulSet\n4. Controller waits for active connections to drain (with timeout)\n5. Controller triggers final backup job if backup schedule configured\n6. Controller waits for backup completion or timeout\n7. Controller deletes Service resources to prevent new connections  \n8. Controller deletes StatefulSet and waits for pod termination\n9. Controller deletes ConfigMaps and Secrets\n10. Controller deletes PersistentVolumeClaims (if policy allows)\n11. Controller removes finalizer from Database resource\n12. Kubernetes completes resource deletion automatically</code></pre></div>\n\n<p>Each cleanup step includes timeout handling to prevent indefinite blocking on failing operations. The controller maintains detailed status messages throughout the deletion process, helping users understand cleanup progress and identify any issues that require manual intervention.</p>\n<blockquote>\n<p><strong>Decision: PVC Deletion Policy</strong></p>\n<ul>\n<li><strong>Context</strong>: Database PersistentVolumeClaims contain critical data that users might want to preserve after operator deletion</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Always delete PVCs automatically during cleanup</li>\n<li>Never delete PVCs, leaving cleanup to administrators</li>\n<li>Configurable deletion policy per Database instance</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Configurable deletion policy with annotation-based control</li>\n<li><strong>Rationale</strong>: Provides flexibility for both development environments (auto-cleanup) and production environments (manual cleanup)</li>\n<li><strong>Consequences</strong>: Requires clear documentation about PVC lifecycle and potential storage costs from orphaned volumes</li>\n</ul>\n</blockquote>\n<h4 id=\"backup-and-data-protection\">Backup and Data Protection</h4>\n<p>Before deleting storage resources, the controller creates a final backup job to preserve database contents. This backup operation runs asynchronously while the controller monitors job status to determine when cleanup can proceed safely.</p>\n<p>The backup job creation follows the same owner reference pattern used for other owned resources, ensuring that backup jobs are cleaned up automatically if the Database deletion process fails and requires restart. The controller includes backup metadata in the Database status, providing users with information about backup location and completion status.</p>\n<table>\n<thead>\n<tr>\n<th>Backup Stage</th>\n<th>Duration Estimate</th>\n<th>Failure Handling</th>\n<th>User Visibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Job Creation</td>\n<td>&lt; 1 second</td>\n<td>Retry with exponential backoff</td>\n<td>Status: &quot;Creating backup job&quot;</td>\n</tr>\n<tr>\n<td>Backup Execution</td>\n<td>Varies by data size</td>\n<td>Monitor job status, timeout after 1 hour</td>\n<td>Status: &quot;Backing up data&quot;</td>\n</tr>\n<tr>\n<td>Backup Verification</td>\n<td>&lt; 30 seconds</td>\n<td>Check backup file existence and size</td>\n<td>Status: &quot;Verifying backup&quot;</td>\n</tr>\n<tr>\n<td>Cleanup Continuation</td>\n<td>&lt; 10 seconds</td>\n<td>Proceed with resource deletion</td>\n<td>Status: &quot;Backup complete, cleaning up&quot;</td>\n</tr>\n</tbody></table>\n<h4 id=\"cleanup-failure-recovery\">Cleanup Failure Recovery</h4>\n<p>The deletion flow includes comprehensive error handling for scenarios where cleanup operations fail due to temporary issues like network connectivity problems, insufficient permissions, or resource conflicts. The controller uses exponential backoff retry logic to handle transient failures while providing escape mechanisms for permanent failure conditions.</p>\n<p>When cleanup operations encounter errors, the controller updates the Database status with detailed error information and requeues the reconciliation request for retry. The exponential backoff algorithm prevents overwhelming failing systems while ensuring that temporary issues resolve automatically once underlying conditions improve.</p>\n<p>Common cleanup failures include PersistentVolumeClaims that cannot be deleted due to active pod mounts, backup jobs that fail due to storage connectivity issues, and StatefulSets that hang during termination due to pod disruption budgets or resource constraints.</p>\n<p>⚠️ <strong>Pitfall: Incomplete Finalizer Removal</strong></p>\n<p>Controllers must remove their finalizers only after ALL cleanup operations complete successfully. Removing finalizers prematurely allows Kubernetes to complete resource deletion, potentially orphaning external resources or causing data loss. Always implement comprehensive error checking before finalizer removal, and prefer leaving finalizers in place during uncertain failure conditions rather than risking incomplete cleanup.</p>\n<h4 id=\"graceful-shutdown-coordination\">Graceful Shutdown Coordination</h4>\n<p>The StatefulSet deletion process includes graceful shutdown coordination to ensure that database processes have sufficient time to flush pending writes, close connections cleanly, and perform other shutdown procedures. The controller configures appropriate <code>terminationGracePeriodSeconds</code> values based on the database type and expected shutdown duration.</p>\n<p>During StatefulSet deletion, the controller monitors pod termination status and can extend grace periods if shutdown operations require additional time. This monitoring prevents forceful pod termination that could corrupt database files or lose pending transactions.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Graceful Shutdown Monitoring:\n1. Controller initiates StatefulSet deletion with configured grace period\n2. Controller watches for pod termination events from informer\n3. Controller checks database process status via readiness probes  \n4. If shutdown exceeds grace period, controller logs warning\n5. Controller waits for all pods to reach Terminated phase\n6. Controller verifies no orphaned persistent connections remain\n7. Controller proceeds with next cleanup phase</code></pre></div>\n\n<p>The graceful shutdown process includes health checks that verify database processes have stopped completely before proceeding to delete storage resources. These checks prevent data corruption scenarios where storage cleanup occurs while database processes are still writing data files.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Webhook Timeout During Resource Creation</strong></p>\n<p>Admission webhooks have strict timeout limits (typically 10-30 seconds) enforced by the API server. Complex validation logic or external API calls in webhooks can exceed these timeouts, causing resource creation to fail with cryptic timeout errors. Implement webhook logic with fast execution paths and avoid synchronous external dependencies. Use caching for expensive validations and prefer eventual consistency models where immediate validation is not critical.</p>\n<p>⚠️ <strong>Pitfall: Status Update Race Conditions</strong></p>\n<p>Controllers that update status frequently can encounter race conditions where multiple status updates attempt to modify the same resource version simultaneously. This causes &quot;conflict&quot; errors that appear as reconciliation failures. Always fetch fresh resource versions before status updates, implement retry logic for conflict errors, and consider batching multiple status changes into single update operations.</p>\n<p>⚠️ <strong>Pitfall: Finalizer Deadlock Scenarios</strong></p>\n<p>Multiple controllers adding finalizers to the same resource can create deadlock situations where each controller waits for others to complete cleanup before removing their own finalizers. Design finalizer cleanup logic to be independent of other finalizers and implement timeout mechanisms that allow emergency finalizer removal during administrative intervention.</p>\n<p>⚠️ <strong>Pitfall: Informer Cache Staleness</strong></p>\n<p>Controllers making decisions based on informer cache data may operate on stale information that doesn&#39;t reflect recent cluster changes. Critical decisions like resource creation or deletion should fetch fresh data from the API server rather than relying solely on cache contents. Use <code>client.Get()</code> calls for authoritative state checks before irreversible operations.</p>\n<p>⚠️ <strong>Pitfall: Webhook Certificate Expiration</strong></p>\n<p>Admission webhooks require valid TLS certificates for HTTPS communication with the API server. Certificate expiration causes immediate webhook failures that block all resource operations. Implement automated certificate rotation using cert-manager or similar tools, monitor certificate expiration dates, and establish emergency procedures for manual certificate renewal during outages.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP Client</td>\n<td><code>net/http</code> with retry logic</td>\n<td><code>controller-runtime/pkg/client</code> with built-in retries</td>\n</tr>\n<tr>\n<td>JSON Processing</td>\n<td><code>encoding/json</code> with struct tags</td>\n<td><code>sigs.k8s.io/controller-runtime/pkg/webhook/admission</code> decoder</td>\n</tr>\n<tr>\n<td>Status Updates</td>\n<td>Direct client calls to status subresource</td>\n<td><code>controller-runtime/pkg/client</code> with <code>SubResource()</code></td>\n</tr>\n<tr>\n<td>Event Recording</td>\n<td><code>client-go/tools/record</code> EventRecorder</td>\n<td>Controller-runtime manager event recorder</td>\n</tr>\n<tr>\n<td>Certificate Management</td>\n<td>Manual certificate creation</td>\n<td><code>cert-manager.io</code> automatic certificate lifecycle</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/controller/\n  database_controller.go          ← Main reconciliation logic\n  database_controller_test.go     ← Reconciliation unit tests\n  status_updater.go               ← Status management utilities\n  finalizer_manager.go            ← Finalizer addition/removal logic\n\ninternal/webhook/\n  database_webhook.go             ← Admission webhook handlers\n  database_webhook_test.go        ← Webhook validation tests\n  certificate_manager.go          ← TLS certificate management\n  admission_handler.go            ← Webhook HTTP server setup\n\ninternal/resources/\n  statefulset.go                  ← StatefulSet creation and updates\n  service.go                      ← Service resource management\n  configmap.go                    ← ConfigMap generation logic\n  pvc.go                          ← PersistentVolumeClaim handling\n\nconfig/webhook/\n  manifests.yaml                  ← ValidatingAdmissionWebhook configuration\n  kustomization.yaml              ← Webhook resource overlay\n  certificate.yaml                ← Certificate resource for cert-manager</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete HTTP Server for Admission Webhooks:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> webhook</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/tls</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    admissionv1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/admission/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metav1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/apis/meta/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/webhook/admission</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AdmissionHandler processes admission review requests for Database resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AdmissionHandler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    decoder </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">admission</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Decoder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scheme  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Scheme</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewAdmissionHandler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">decoder</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">admission</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Decoder</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">scheme</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Scheme</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdmissionHandler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">AdmissionHandler</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        decoder: decoder,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        scheme:  scheme,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdmissionHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ServeHTTP</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> log.</span><span style=\"color:#B392F0\">FromContext</span><span style=\"color:#E1E4E8\">(r.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> review </span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionReview</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">NewDecoder</span><span style=\"color:#E1E4E8\">(r.Body).</span><span style=\"color:#B392F0\">Decode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">review); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"Failed to decode admission review request\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        http.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(w, </span><span style=\"color:#9ECBFF\">\"Invalid admission review\"</span><span style=\"color:#E1E4E8\">, http.StatusBadRequest)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">processAdmissionReview</span><span style=\"color:#E1E4E8\">(r.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">review)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    review.Response </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    review.Response.UID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> review.Request.UID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">Header</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">NewEncoder</span><span style=\"color:#E1E4E8\">(w).</span><span style=\"color:#B392F0\">Encode</span><span style=\"color:#E1E4E8\">(review); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"Failed to encode admission review response\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        http.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(w, </span><span style=\"color:#9ECBFF\">\"Internal server error\"</span><span style=\"color:#E1E4E8\">, http.StatusInternalServerError)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdmissionHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">processAdmissionReview</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">review</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionReview</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    req </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> review.Request</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> req.Kind.Kind {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"Database\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        switch</span><span style=\"color:#E1E4E8\"> req.Operation {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> admissionv1.Create:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">handleDatabaseCreate</span><span style=\"color:#E1E4E8\">(ctx, req)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> admissionv1.Update:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">handleDatabaseUpdate</span><span style=\"color:#E1E4E8\">(ctx, req)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> admissionv1.Delete:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">handleDatabaseDelete</span><span style=\"color:#E1E4E8\">(ctx, req)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Allowed: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Result: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Status</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Code: http.StatusOK,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Complete TLS Certificate Manager:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> webhook</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/tls</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CertificateReloader manages TLS certificate lifecycle for webhook servers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CertificateReloader</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    certPath </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    keyPath  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cert     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">tls</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Certificate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex    </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCertificateReloader</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">certPath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">keyPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CertificateReloader</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CertificateReloader</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        certPath: certPath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keyPath:  keyPath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cr </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CertificateReloader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetCertificate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">tls</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ClientHelloInfo</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">tls</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Certificate</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cr.mutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> cr.mutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> cr.cert </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"certificate not loaded\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> cr.cert, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cr </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CertificateReloader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">loadCertificate</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cert, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tls.</span><span style=\"color:#B392F0\">LoadX509KeyPair</span><span style=\"color:#E1E4E8\">(cr.certPath, cr.keyPath)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to load certificate: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cr.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cr.cert </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">cert</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cr.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cr </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CertificateReloader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initial certificate load</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cr.</span><span style=\"color:#B392F0\">loadCertificate</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Watch for certificate file changes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ticker </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">NewTicker</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">30</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> ticker.</span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> ctx.</span><span style=\"color:#B392F0\">Err</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ticker.C:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cr.</span><span style=\"color:#B392F0\">loadCertificate</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Log error but continue watching</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Main Reconciliation Flow:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Reconcile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> log.</span><span style=\"color:#B392F0\">FromContext</span><span style=\"color:#E1E4E8\">(ctx)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Fetch the Database resource from the API server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use r.Get() to retrieve the current resource state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle NotFound errors by returning successful result (resource deleted)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if resource is being deleted (deletionTimestamp set)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If deletion detected, call handleDeletion() and return</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Deletion flow bypasses normal reconciliation logic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Add finalizer if not present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if FINALIZER_NAME exists in metadata.finalizers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Add finalizer and update resource if missing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check if reconciliation is needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Compare metadata.generation with status.observedGeneration  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Skip reconciliation if generations match (no spec changes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Fetch current state of owned resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Get StatefulSet, Service, ConfigMap, PVC owned by this Database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use owner reference labels for efficient resource discovery</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Compute desired state from spec</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Generate desired StatefulSet, Service, ConfigMap based on Database spec</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Apply configuration templates with values from spec fields</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Reconcile each owned resource type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Call createOrUpdateResource() for StatefulSet, Service, ConfigMap</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle creation, updates, and error scenarios</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Wait for StatefulSet readiness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check StatefulSet status.readyReplicas vs spec.replicas</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return requeue if StatefulSet not ready yet</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Update Database status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set conditions, readyReplicas, phase based on owned resource status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update observedGeneration to current metadata.generation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Return appropriate result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return ctrl.Result{} for success, ctrl.Result{RequeueAfter: duration} for retry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return error for permanent failures that need exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Database Validation Logic:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdmissionHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleDatabaseCreate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionRequest</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> db </span><span style=\"color:#B392F0\">Database</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Decode the Database resource from admission request</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use h.decoder.DecodeRaw() to convert req.Object into Database struct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle JSON decode errors with appropriate error response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate replica count constraints</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check if db.Spec.Replicas is between 1 and maximum allowed (e.g., 5)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return denial response for invalid replica counts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate storage size format and minimum</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parse db.Spec.StorageSize using resource.ParseQuantity()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Ensure storage size meets minimum requirements (e.g., 1Gi)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate PostgreSQL version format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check db.Spec.Version matches expected version pattern (major.minor)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verify version is in supported versions list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Validate resource requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check db.Spec.Resources.Limits and Requests for reasonable values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Ensure memory limits are sufficient for database operation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Validate configuration parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Iterate through db.Spec.Config map entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Check parameter names against allowed PostgreSQL settings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Validate parameter values are within acceptable ranges</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return admission response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return &#x26;admissionv1.AdmissionResponse{Allowed: true} for valid resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Return denial response with detailed error message for validation failures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Status Update Logic:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">updateDatabaseStatus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">sts</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">appsv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">StatefulSet</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create updated status object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Initialize new DatabaseStatus struct with current field values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Preserve existing status fields that should not change</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update ready replica count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set status.ReadyReplicas from sts.Status.ReadyReplicas</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle case where StatefulSet is nil (not created yet)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Determine current phase</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set status.Phase based on StatefulSet status and readiness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use phases: \"Pending\", \"Progressing\", \"Ready\", \"Failed\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update Ready condition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set Ready condition to True if readyReplicas == spec.replicas</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set Ready condition to False if StatefulSet has errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set Ready condition to Unknown during initial deployment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update Progressing condition  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set Progressing to True during rollouts or scaling operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set Progressing to False when deployment reaches stable state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Include reason and message describing current operation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Set observed generation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update status.ObservedGeneration to current metadata.generation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This signals that reconciliation has processed latest spec changes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update last reconciliation timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Set status.LastReconcileTime to current time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Provides visibility into reconciliation activity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Persist status update</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Use r.Status().Update() to save status changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle conflict errors with retry logic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p><strong>After Milestone 3 Implementation:</strong></p>\n<p>Run the following commands to verify complete resource lifecycle:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test resource creation flow</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> config/samples/database_v1_database.yaml</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> database</span><span style=\"color:#9ECBFF\"> sample-database</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> yaml</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify webhook processing</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> describe</span><span style=\"color:#9ECBFF\"> database</span><span style=\"color:#9ECBFF\"> sample-database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show defaulted values and validation success</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test update and reconciliation flow  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> patch</span><span style=\"color:#9ECBFF\"> database</span><span style=\"color:#9ECBFF\"> sample-database</span><span style=\"color:#79B8FF\"> --type=</span><span style=\"color:#9ECBFF\">'merge'</span><span style=\"color:#79B8FF\"> -p=</span><span style=\"color:#9ECBFF\">'{\"spec\":{\"replicas\":3}}'</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> database</span><span style=\"color:#9ECBFF\"> sample-database</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> jsonpath='{.status.readyReplicas}'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test deletion and cleanup flow</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> delete</span><span style=\"color:#9ECBFF\"> database</span><span style=\"color:#9ECBFF\"> sample-database</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> statefulset,service,pvc</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should show progressive cleanup of owned resources</span></span></code></pre></div>\n\n<p><strong>Expected Behavior:</strong></p>\n<ul>\n<li>Resource creation triggers mutating webhook defaulting followed by validating webhook checks</li>\n<li>Controller reconciliation creates StatefulSet, Service, and ConfigMap with owner references</li>\n<li>Status updates show progression from Pending → Progressing → Ready phases</li>\n<li>Replica count changes trigger StatefulSet updates and status reflects new ready count</li>\n<li>Resource deletion initiates finalizer-controlled cleanup sequence</li>\n<li>All owned resources are removed before Database deletion completes</li>\n</ul>\n<p><strong>Signs of Issues:</strong></p>\n<ul>\n<li>Webhook timeouts indicate certificate or networking problems</li>\n<li>Reconciliation stuck in Progressing phase suggests StatefulSet creation failures</li>\n<li>Status never updates indicates RBAC permission issues</li>\n<li>Finalizer not removed indicates cleanup operation failures</li>\n</ul>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Resource creation hangs</td>\n<td>Webhook timeout</td>\n<td>Check webhook pod logs and certificate validity</td>\n<td>Restart webhook pods, renew certificates</td>\n</tr>\n<tr>\n<td>Validation rejected with unclear message</td>\n<td>Webhook validation logic error</td>\n<td>Examine admission response details in kubectl output</td>\n<td>Review webhook validation code, add detailed error messages</td>\n</tr>\n<tr>\n<td>Controller reconciliation never triggers</td>\n<td>Informer cache sync failure</td>\n<td>Check controller manager logs for watch errors</td>\n<td>Verify RBAC permissions, restart controller</td>\n</tr>\n<tr>\n<td>Status updates fail with conflict errors</td>\n<td>Concurrent status modifications</td>\n<td>Enable verbose logging to see resource version conflicts</td>\n<td>Implement retry logic with fresh resource fetches</td>\n</tr>\n<tr>\n<td>Finalizer cleanup stuck</td>\n<td>External resource deletion failure</td>\n<td>Check Database status message and owned resource states</td>\n<td>Manually clean up stuck resources, remove finalizer</td>\n</tr>\n<tr>\n<td>Owned resources not deleted</td>\n<td>Missing owner references</td>\n<td>Verify owner reference metadata on StatefulSet, Service</td>\n<td>Add proper owner references during resource creation</td>\n</tr>\n</tbody></table>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3 (Reconciliation Loop), Milestone 4 (Webhooks), Milestone 5 (Testing &amp; Deployment) - addresses robust error handling across controller reconciliation, webhook processing, and production deployment scenarios</p>\n</blockquote>\n<h3 id=\"mental-model-the-resilient-orchestra-conductor\">Mental Model: The Resilient Orchestra Conductor</h3>\n<p>Think of a Kubernetes operator as an orchestra conductor who must keep the music playing even when instruments malfunction, sheet music gets lost, or the concert hall loses power. A resilient conductor doesn&#39;t panic when the violin section misses an entrance—they calmly adjust the tempo, signal the missed cue again, and ensure the overall performance continues. Similarly, our operator must gracefully handle API server outages, webhook timeouts, and resource conflicts while maintaining the declarative promises made to users.</p>\n<p>The key insight is that distributed systems failures are not exceptional—they are normal operating conditions. Just as a professional conductor expects and prepares for missed cues, a well-designed operator anticipates network partitions, transient errors, and partial failures as part of its standard repertoire.</p>\n<p><img src=\"/api/project/kubernetes-operator/architecture-doc/asset?path=diagrams%2Ferror-recovery-flow.svg\" alt=\"Error Handling and Recovery Flow\"></p>\n<h2 id=\"common-failure-modes\">Common Failure Modes</h2>\n<p>Understanding failure modes is crucial for building resilient operators. Each failure mode requires different detection, classification, and recovery strategies. The operator must distinguish between transient errors that will resolve themselves with retry and permanent errors that require human intervention or alternative approaches.</p>\n<h3 id=\"api-server-connectivity-failures\">API Server Connectivity Failures</h3>\n<p>API server connectivity issues are among the most common failures in Kubernetes environments. These can range from brief network hiccups to extended outages during cluster maintenance or infrastructure failures.</p>\n<p><strong>Connection Loss During Informer Operations</strong></p>\n<p>When the informer loses its connection to the API server, it stops receiving resource events and its local cache becomes stale. The controller might continue processing items from its work queue, but it cannot fetch current resource state or update resource status. This creates a dangerous situation where the controller operates on outdated information.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Scenario</th>\n<th>Symptoms</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Network partition</td>\n<td>Informer stops receiving events</td>\n<td>Connection error logs, cache staleness</td>\n<td>Exponential backoff reconnection with jitter</td>\n</tr>\n<tr>\n<td>API server restart</td>\n<td>HTTP 503 responses</td>\n<td>Failed API calls with server unavailable</td>\n<td>Wait for server readiness, rebuild cache</td>\n</tr>\n<tr>\n<td>Certificate expiration</td>\n<td>TLS handshake failures</td>\n<td>Certificate validation errors</td>\n<td>Automatic certificate reload or rotation</td>\n</tr>\n<tr>\n<td>Resource quota exhaustion</td>\n<td>API calls rejected</td>\n<td>HTTP 429 or quota exceeded errors</td>\n<td>Back off and alert, may require manual intervention</td>\n</tr>\n</tbody></table>\n<p>The informer&#39;s shared index cache provides some protection during brief outages, allowing read operations to continue using cached data. However, the controller must be aware that cached data may be stale and avoid making destructive decisions based on potentially outdated information.</p>\n<blockquote>\n<p><strong>Decision: Informer Cache Staleness Handling</strong></p>\n<ul>\n<li><strong>Context</strong>: When API server connectivity is lost, the informer cache becomes stale but remains readable</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Stop all reconciliation during connectivity loss</li>\n<li>Continue reconciliation with stale cache data</li>\n<li>Limit reconciliation to read-only operations during outages</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Continue reconciliation with stale cache but avoid destructive operations</li>\n<li><strong>Rationale</strong>: Stopping completely would prevent recovery when connectivity returns, but destructive operations on stale data could cause cascading failures</li>\n<li><strong>Consequences</strong>: Requires careful classification of operations as safe/unsafe with stale data</li>\n</ul>\n</blockquote>\n<p><strong>API Call Failures During Reconciliation</strong></p>\n<p>Individual API calls within the reconciliation loop can fail for various reasons, from temporary network issues to resource conflicts with concurrent operations. The controller must handle these failures gracefully without corrupting the overall reconciliation state.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Reconciliation Error Classification:\n1. Check if error indicates stale cache (NotFound for recently created resource)\n2. Classify as transient (network timeout) or permanent (validation failure)\n3. For transient errors: requeue with exponential backoff\n4. For permanent errors: update status with error condition, stop retrying\n5. For cache staleness: force cache refresh and retry once</code></pre></div>\n\n<h3 id=\"webhook-processing-failures\">Webhook Processing Failures</h3>\n<p>Admission webhooks introduce additional failure points in the resource creation and update pipeline. Webhook failures can block all resource operations, making them particularly critical to handle correctly.</p>\n<p><strong>Webhook Timeout and Unavailability</strong></p>\n<p>The Kubernetes API server has a default 10-second timeout for webhook calls. If the webhook service is unavailable or overloaded, these timeouts can block all operations on the affected resource types.</p>\n<table>\n<thead>\n<tr>\n<th>Timeout Scenario</th>\n<th>Impact</th>\n<th>Detection</th>\n<th>Mitigation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Webhook pod not ready</td>\n<td>All resource operations fail</td>\n<td>Pod status, readiness probes</td>\n<td>Failure policy configuration, multiple replicas</td>\n</tr>\n<tr>\n<td>Network latency spikes</td>\n<td>Intermittent timeouts</td>\n<td>Response time monitoring</td>\n<td>Reduce webhook processing time, increase timeout</td>\n</tr>\n<tr>\n<td>Webhook overloaded</td>\n<td>Cascading timeout failures</td>\n<td>Queue depth metrics, CPU/memory usage</td>\n<td>Horizontal scaling, request rate limiting</td>\n</tr>\n<tr>\n<td>Certificate issues</td>\n<td>TLS handshake failures</td>\n<td>Certificate validation logs</td>\n<td>Automated certificate management with cert-manager</td>\n</tr>\n</tbody></table>\n<p>The webhook configuration&#39;s <code>failurePolicy</code> setting determines whether operations should be allowed or denied when the webhook is unreachable. This represents a fundamental trade-off between availability and security enforcement.</p>\n<blockquote>\n<p><strong>Decision: Webhook Failure Policy Configuration</strong></p>\n<ul>\n<li><strong>Context</strong>: Webhook unavailability can block all resource operations</li>\n<li><strong>Options Considered</strong>:<ol>\n<li><code>failurePolicy: Fail</code> - deny operations when webhook unavailable (secure but less available)</li>\n<li><code>failurePolicy: Ignore</code> - allow operations when webhook unavailable (available but less secure)</li>\n<li>Hybrid approach with different policies for validation vs mutation</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use <code>Fail</code> for critical validations, <code>Ignore</code> for optional mutations</li>\n<li><strong>Rationale</strong>: Critical business rules must be enforced even at the cost of availability, but optional enhancements shouldn&#39;t block operations</li>\n<li><strong>Consequences</strong>: Requires careful classification of webhook logic as critical vs optional</li>\n</ul>\n</blockquote>\n<p><strong>Webhook Processing Errors</strong></p>\n<p>Even when the webhook service is reachable, processing errors within the webhook logic can cause admission failures. These errors must be handled gracefully with appropriate error messages for users.</p>\n<p>The webhook&#39;s error handling affects user experience significantly. A webhook that returns a generic &quot;internal error&quot; message leaves users unable to diagnose or fix their resource definitions, while clear, actionable error messages enable self-service problem resolution.</p>\n<h3 id=\"controller-process-failures\">Controller Process Failures</h3>\n<p>Controller crashes and restarts are inevitable in distributed environments. The controller must be designed to recover gracefully from failures without losing track of resources or corrupting reconciliation state.</p>\n<p><strong>Controller Crash Recovery</strong></p>\n<p>When a controller process crashes and restarts, it loses all in-memory state including work queue contents and ongoing reconciliation progress. The controller must reconstruct its understanding of the world from the persistent state stored in the Kubernetes API server.</p>\n<table>\n<thead>\n<tr>\n<th>Recovery Aspect</th>\n<th>Challenge</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Work queue state</td>\n<td>In-memory queue contents lost on crash</td>\n<td>Rebuild from informer full sync on startup</td>\n</tr>\n<tr>\n<td>Ongoing reconciliations</td>\n<td>Partial operations may be incomplete</td>\n<td>Implement idempotent reconciliation logic</td>\n</tr>\n<tr>\n<td>Finalizer cleanup</td>\n<td>Resources may be stuck in deletion</td>\n<td>Check for stale finalizers on startup scan</td>\n</tr>\n<tr>\n<td>Status updates</td>\n<td>Status may not reflect current state</td>\n<td>Recompute and update status during reconciliation</td>\n</tr>\n</tbody></table>\n<p>The informer&#39;s resync mechanism provides a safety net by periodically re-enqueueing all resources, ensuring that any missed events or incomplete reconciliations are eventually processed.</p>\n<p><strong>Leader Election Failures</strong></p>\n<p>In high-availability deployments with multiple controller replicas, leader election ensures only one replica actively reconciles resources. Leader election failures can result in split-brain scenarios or periods with no active leader.</p>\n<p>Leader election uses Kubernetes lease resources with time-based renewal. The leader must continuously renew its lease, and followers must monitor for lease expiration to detect when they should attempt to acquire leadership.</p>\n<h3 id=\"resource-conflict-scenarios\">Resource Conflict Scenarios</h3>\n<p>Multiple controllers or external actors can modify the same Kubernetes resources concurrently, leading to conflicts that must be resolved without data loss or inconsistent state.</p>\n<p><strong>Optimistic Locking Conflicts</strong></p>\n<p>Kubernetes uses optimistic locking through resource versions to detect concurrent modifications. When a controller attempts to update a resource that has been modified since it was last read, the API server returns a conflict error.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Optimistic Locking Conflict Resolution:\n1. Attempt resource update with current resource version\n2. If conflict error occurs, re-read resource from API server\n3. Merge local changes with current state (if possible)\n4. Retry update with new resource version\n5. If conflicts persist, implement exponential backoff\n6. Alert if conflicts indicate systematic issues</code></pre></div>\n\n<p>The controller&#39;s reconciliation logic must be designed to handle resource version conflicts gracefully by re-reading current state and recomputing desired changes.</p>\n<p><strong>Concurrent Controller Modifications</strong></p>\n<p>When multiple controllers manage different aspects of the same resource, coordination becomes essential to prevent conflicts and ensure coherent behavior.</p>\n<table>\n<thead>\n<tr>\n<th>Conflict Type</th>\n<th>Example</th>\n<th>Resolution Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Field ownership</td>\n<td>Two controllers updating same field</td>\n<td>Use Server-Side Apply with field management</td>\n</tr>\n<tr>\n<td>Resource creation</td>\n<td>Multiple controllers creating same resource</td>\n<td>Use owner references and naming conventions</td>\n</tr>\n<tr>\n<td>Status updates</td>\n<td>Concurrent status field modifications</td>\n<td>Use status subresource with separate resource versions</td>\n</tr>\n<tr>\n<td>Finalizer management</td>\n<td>Multiple controllers adding/removing finalizers</td>\n<td>Coordinate finalizer names and removal order</td>\n</tr>\n</tbody></table>\n<h2 id=\"recovery-and-self-healing\">Recovery and Self-Healing</h2>\n<p>The operator&#39;s recovery mechanisms must be automatic, reliable, and comprehensive enough to handle the full spectrum of failure scenarios without human intervention for common cases.</p>\n<h3 id=\"automatic-retry-logic\">Automatic Retry Logic</h3>\n<p>The retry strategy forms the foundation of the operator&#39;s resilience. Different types of errors require different retry approaches, and the strategy must prevent overwhelming failing systems while ensuring rapid recovery when conditions improve.</p>\n<p><strong>Exponential Backoff Implementation</strong></p>\n<p>Exponential backoff prevents the controller from overwhelming a struggling API server or webhook service with repeated failed requests. The backoff algorithm increases delay between retries exponentially, with jitter to prevent thundering herd problems.</p>\n<table>\n<thead>\n<tr>\n<th>Retry Attempt</th>\n<th>Base Delay</th>\n<th>Jitter Range</th>\n<th>Total Delay Range</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>1s</td>\n<td>±0.5s</td>\n<td>0.5s - 1.5s</td>\n</tr>\n<tr>\n<td>2</td>\n<td>2s</td>\n<td>±1s</td>\n<td>1s - 3s</td>\n</tr>\n<tr>\n<td>3</td>\n<td>4s</td>\n<td>±2s</td>\n<td>2s - 6s</td>\n</tr>\n<tr>\n<td>4</td>\n<td>8s</td>\n<td>±4s</td>\n<td>4s - 12s</td>\n</tr>\n<tr>\n<td>5</td>\n<td>16s</td>\n<td>±8s</td>\n<td>8s - 24s</td>\n</tr>\n<tr>\n<td>Max</td>\n<td>300s</td>\n<td>±150s</td>\n<td>150s - 450s</td>\n</tr>\n</tbody></table>\n<p>The controller-runtime&#39;s rate-limiting work queue provides built-in exponential backoff with configurable parameters. The <code>isErrorRetryable</code> function classifies errors to determine whether retry is appropriate.</p>\n<p><strong>Error Classification for Retry Decisions</strong></p>\n<p>Not all errors should trigger automatic retries. Permanent errors like validation failures will not resolve through retry and should be reported to users immediately rather than consuming retry capacity.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Error Classification Algorithm:\n1. Check error type and HTTP status code\n2. Transient errors (network timeouts, 5xx responses): retry with backoff\n3. Retryable client errors (409 conflicts, 429 rate limits): retry with backoff\n4. Permanent client errors (400 validation, 403 permission): report immediately\n5. Resource not found errors: check if resource was recently deleted, may retry once\n6. Unknown errors: default to transient classification for safety</code></pre></div>\n\n<p>The classification function must be conservative, erring on the side of retrying potentially recoverable errors rather than giving up prematurely.</p>\n<h3 id=\"leader-election-failover\">Leader Election Failover</h3>\n<p>High-availability deployments require seamless failover when the current leader becomes unavailable. The leader election mechanism must detect failures quickly while preventing split-brain scenarios.</p>\n<p><strong>Leader Health Monitoring</strong></p>\n<p>The active leader must continuously prove its health by renewing its lease before expiration. The lease renewal interval must be shorter than the lease duration to provide a safety margin for network delays and processing time.</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Parameter</th>\n<th>Value</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Lease Duration</td>\n<td>15s</td>\n<td>Long enough to survive brief network hiccups</td>\n</tr>\n<tr>\n<td>Renew Deadline</td>\n<td>10s</td>\n<td>Provides 5s safety margin before lease expiration</td>\n</tr>\n<tr>\n<td>Retry Period</td>\n<td>2s</td>\n<td>Allows multiple renewal attempts within deadline</td>\n</tr>\n</tbody></table>\n<p>Followers monitor the leader&#39;s lease and attempt to acquire leadership when the lease expires without renewal. The acquisition process uses atomic compare-and-swap operations to prevent multiple followers from becoming leader simultaneously.</p>\n<p><strong>Graceful Leadership Transition</strong></p>\n<p>When leadership changes, the new leader must reconstruct the controller state and resume reconciliation without missing resources or duplicating operations. This requires careful coordination between the outgoing and incoming leaders.</p>\n<p>The incoming leader performs a full informer resync to rebuild its local cache and work queue, ensuring it processes all resources regardless of what the previous leader may have missed. This approach trades some performance for reliability and simplicity.</p>\n<h3 id=\"state-reconstruction-from-cluster-state\">State Reconstruction from Cluster State</h3>\n<p>After failures or leadership changes, the controller must reconstruct its understanding of the world from the authoritative state stored in the Kubernetes API server. This reconstruction must be complete and accurate to prevent inconsistencies.</p>\n<p><strong>Full Reconciliation Sweep</strong></p>\n<p>The informer&#39;s initial cache sync triggers reconciliation for all existing custom resources, allowing the controller to verify that actual state matches desired state and correct any drift that may have occurred during downtime.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>State Reconstruction Process:\n1. Start informer and wait for initial cache sync completion\n2. Controller receives reconcile requests for all existing resources\n3. Each reconciliation compares actual state with desired state\n4. Controller corrects any drift by creating, updating, or deleting owned resources\n5. Status is updated to reflect current reconciliation state\n6. Normal event-driven reconciliation resumes</code></pre></div>\n\n<p>This approach ensures that the controller can recover from extended downtime, configuration changes, or external modifications to owned resources.</p>\n<p><strong>Finalizer Cleanup Verification</strong></p>\n<p>During startup, the controller must verify that all finalizers under its management are still needed and remove any stale finalizers that may prevent resource deletion. This prevents resources from becoming stuck in deletion state due to controller failures or configuration changes.</p>\n<p>The controller scans all resources with its finalizer and verifies that cleanup operations are complete. If cleanup has already been performed (perhaps by a previous controller instance), the finalizer is removed to allow deletion to proceed.</p>\n<h2 id=\"consistency-and-conflict-resolution\">Consistency and Conflict Resolution</h2>\n<p>Distributed systems like Kubernetes provide eventual consistency rather than strong consistency, requiring operators to handle concurrent modifications and conflicting updates gracefully.</p>\n<h3 id=\"handling-concurrent-updates\">Handling Concurrent Updates</h3>\n<p>Multiple actors may attempt to modify the same Kubernetes resource simultaneously, including the operator itself, other controllers, and human administrators using <code>kubectl</code>. The operator must coordinate these updates without losing data or creating inconsistent state.</p>\n<p><strong>Resource Version Conflicts</strong></p>\n<p>Every Kubernetes resource includes a <code>resourceVersion</code> field that changes with each modification. When updating a resource, the client must provide the current resource version, and the API server rejects updates that specify an outdated version.</p>\n<table>\n<thead>\n<tr>\n<th>Conflict Resolution Step</th>\n<th>Action</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. Read current resource</td>\n<td><code>GET /api/v1/namespaces/{ns}/databases/{name}</code></td>\n<td>Obtain latest resourceVersion</td>\n</tr>\n<tr>\n<td>2. Compute desired changes</td>\n<td>Compare spec with actual state</td>\n<td>Determine required modifications</td>\n</tr>\n<tr>\n<td>3. Apply changes</td>\n<td><code>PUT</code> or <code>PATCH</code> with resourceVersion</td>\n<td>Attempt atomic update</td>\n</tr>\n<tr>\n<td>4. Handle conflict</td>\n<td>If 409 Conflict, retry from step 1</td>\n<td>Resolve concurrent modifications</td>\n</tr>\n<tr>\n<td>5. Update work queue</td>\n<td>Requeue with exponential backoff if needed</td>\n<td>Prevent overwhelming API server</td>\n</tr>\n</tbody></table>\n<p>The controller&#39;s reconciliation logic must be prepared to restart the reconciliation process when conflicts occur, ensuring that it operates on current resource state rather than stale cached data.</p>\n<p><strong>Server-Side Apply for Field Management</strong></p>\n<p>Server-Side Apply provides a more sophisticated approach to handling concurrent updates by tracking field ownership and allowing controllers to declare which fields they manage. This prevents accidental overwrites of fields managed by other controllers or users.</p>\n<p>Each controller declares its identity as a field manager and specifies exactly which fields it wants to control. The API server automatically resolves conflicts by preserving fields owned by other managers while applying only the requesting controller&#39;s managed fields.</p>\n<blockquote>\n<p><strong>Decision: Update Strategy Selection</strong></p>\n<ul>\n<li><strong>Context</strong>: Controllers must handle concurrent updates to shared resources</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Traditional Update (PUT) with conflict retry - simple but can overwrite other controllers&#39; changes</li>\n<li>Strategic Merge Patch - better than PUT but still can conflict</li>\n<li>JSON Patch - precise but fragile to concurrent changes</li>\n<li>Server-Side Apply - most sophisticated but requires field management design</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use Server-Side Apply for spec updates, traditional Update for status</li>\n<li><strong>Rationale</strong>: Spec updates often conflict with user or other controller changes, while status is typically owned by single controller</li>\n<li><strong>Consequences</strong>: Requires defining field management policies and handling field ownership conflicts</li>\n</ul>\n</blockquote>\n<h3 id=\"optimistic-locking-patterns\">Optimistic Locking Patterns</h3>\n<p>Optimistic locking assumes that conflicts are rare and allows multiple readers to access data concurrently, detecting conflicts only when writes occur. This provides better performance than pessimistic locking but requires careful conflict resolution logic.</p>\n<p><strong>Read-Modify-Write Cycles</strong></p>\n<p>The controller&#39;s typical update pattern follows a read-modify-write cycle where it reads the current resource state, computes required changes, and attempts to write the updated resource back to the API server.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Optimistic Locking Pattern:\n1. Read resource and note resourceVersion (e.g., &quot;12345&quot;)\n2. Compute desired changes based on current state\n3. Modify resource object with intended changes\n4. Attempt update with resourceVersion: &quot;12345&quot;\n5. If successful: operation complete\n6. If conflict (409): another actor modified resource, restart from step 1\n7. If other error: classify and handle according to retry policy</code></pre></div>\n\n<p>The key insight is that the controller must be prepared to discard its computed changes and restart the reconciliation process with fresh data when conflicts occur.</p>\n<p><strong>Idempotent Reconciliation Design</strong></p>\n<p>Idempotent reconciliation ensures that applying the same desired state multiple times produces the same result, making conflict resolution and retry logic safe and predictable.</p>\n<table>\n<thead>\n<tr>\n<th>Idempotency Principle</th>\n<th>Example</th>\n<th>Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Create operations are idempotent</td>\n<td>Creating a Deployment</td>\n<td>Check if resource exists before creating, or use <code>kubectl apply</code> semantics</td>\n</tr>\n<tr>\n<td>Update operations are idempotent</td>\n<td>Scaling replicas from 2 to 3</td>\n<td>Set absolute values rather than relative changes</td>\n</tr>\n<tr>\n<td>Delete operations are idempotent</td>\n<td>Removing a Service</td>\n<td>Check if resource exists before deletion, handle NotFound gracefully</td>\n</tr>\n<tr>\n<td>Status updates are idempotent</td>\n<td>Setting Ready condition</td>\n<td>Compare current status, update only if different</td>\n</tr>\n</tbody></table>\n<p>Idempotent design allows the controller to safely retry operations after conflicts without worrying about double-application of changes or accumulating errors.</p>\n<h3 id=\"eventual-consistency-expectations\">Eventual Consistency Expectations</h3>\n<p>Kubernetes provides eventual consistency, meaning that changes propagate through the system over time but may not be immediately visible to all observers. The operator must account for this consistency model in its design and expectations.</p>\n<p><strong>Informer Cache Lag</strong></p>\n<p>The informer&#39;s local cache may lag behind the authoritative state in the API server, particularly during periods of high change volume or network issues. The controller must handle cases where its cache doesn&#39;t yet reflect recent changes made by other actors.</p>\n<p>A common scenario occurs when the controller creates a resource (like a Deployment) and immediately queries its informer cache to check the resource&#39;s status. The cache may not yet contain the newly created resource, leading to incorrect decisions if the controller assumes the resource doesn&#39;t exist.</p>\n<blockquote>\n<p>The critical insight here is that informer caches provide <strong>eventually consistent</strong> views of cluster state, not <strong>immediately consistent</strong> views. Controllers must design their logic to handle cache lag gracefully rather than assuming instant consistency.</p>\n</blockquote>\n<p><strong>Cross-Resource Dependency Timing</strong></p>\n<p>When the operator manages multiple related resources (like a Deployment, Service, and ConfigMap), the timing of their creation and readiness can vary. The controller must handle scenarios where dependencies aren&#39;t yet available or haven&#39;t reached their desired state.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Dependency Handling Strategy:\n1. Create all owned resources in dependency order (ConfigMap → Deployment → Service)\n2. Check readiness of dependencies before proceeding with dependent resources\n3. Use owner references to ensure garbage collection if parent resource is deleted\n4. Implement timeout and retry logic for dependency readiness checks\n5. Update status with detailed progress information for troubleshooting</code></pre></div>\n\n<p>The <code>updateCondition</code> function maintains detailed status information about dependency progress, allowing users and debugging tools to understand why reconciliation may be incomplete.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Assuming Immediate Consistency After Creates</strong>\nMany developers assume that after successfully creating a resource via the API server, it will immediately be visible in the informer cache. This leads to race conditions where the controller makes incorrect decisions based on stale cache data. The fix is to either use direct API server queries for recently created resources or implement retry logic that handles temporary cache inconsistency.</p>\n<p>⚠️ <strong>Pitfall: Not Implementing Proper Resource Version Handling</strong>\nSome controllers ignore resource version conflicts and keep retrying with the original resource version, leading to permanent update failures. The correct approach is to re-read the resource after each conflict and recompute changes based on the current state rather than the original state.</p>\n<p>⚠️ <strong>Pitfall: Blocking Reconciliation on Transient Errors</strong>\nControllers that fail fast on any error, including transient network issues, provide poor user experience. The operator should distinguish between permanent errors (validation failures) that require user intervention and transient errors (network timeouts) that should be retried automatically with exponential backoff.</p>\n<p>⚠️ <strong>Pitfall: Missing Finalizer Cleanup in Error Scenarios</strong>\nIf the controller adds a finalizer but crashes before completing cleanup, the resource becomes stuck in deletion state. The controller must implement startup logic that scans for stale finalizers and completes any pending cleanup operations to prevent resources from being permanently stuck.</p>\n<p>⚠️ <strong>Pitfall: Not Handling Webhook Unavailability Gracefully</strong>\nWebhook services that crash or become unavailable can block all operations on their resource types if configured with <code>failurePolicy: Fail</code>. While this prevents bypassing validation, it can make the entire system unusable. The solution is to implement webhook high availability with multiple replicas, health checks, and careful consideration of failure policy settings.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Understanding error handling concepts is only half the battle—implementing robust error handling requires careful attention to Go&#39;s error handling patterns, controller-runtime&#39;s retry mechanisms, and Kubernetes API conventions.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Classification</td>\n<td>Basic type assertions and string matching</td>\n<td>Custom error types with structured classification</td>\n</tr>\n<tr>\n<td>Retry Logic</td>\n<td>controller-runtime&#39;s default rate limiter</td>\n<td>Custom rate limiter with circuit breaker patterns</td>\n</tr>\n<tr>\n<td>Monitoring</td>\n<td>Standard Go logging with structured fields</td>\n<td>Prometheus metrics with custom error counters</td>\n</tr>\n<tr>\n<td>Leader Election</td>\n<td>controller-runtime&#39;s built-in leader election</td>\n<td>Custom leader election with health checks</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/controller/\n  database_controller.go           ← main reconciliation logic with error handling\n  database_controller_test.go      ← tests including error scenarios\n  error_handling.go               ← error classification and retry logic\n  finalizer_cleanup.go            ← startup cleanup and recovery logic\n  status_manager.go               ← status update logic with conflict handling\ninternal/webhook/\n  admission_handler.go            ← webhook error handling and timeout management\n  tls_manager.go                  ← certificate management and rotation\ninternal/metrics/\n  error_metrics.go               ← error tracking and alerting</code></pre></div>\n\n<h4 id=\"error-classification-infrastructure\">Error Classification Infrastructure</h4>\n<p>This complete error classification system provides the foundation for intelligent retry decisions throughout the operator:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> controller</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">errors</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    apierrors </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/api/errors</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/reconcile</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ErrorClassification represents different types of errors and their handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ErrorClassification</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ErrorTransient</span><span style=\"color:#B392F0\"> ErrorClassification</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span><span style=\"color:#6A737D\">  // Retry with exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ErrorRetryable</span><span style=\"color:#6A737D\">                            // Retry immediately or with short delay</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ErrorPermanent</span><span style=\"color:#6A737D\">                            // Don't retry, update status with error</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ErrorConflict</span><span style=\"color:#6A737D\">                             // Special handling for optimistic locking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ClassifyError determines how an error should be handled during reconciliation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ClassifyError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ErrorClassification</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ErrorTransient </span><span style=\"color:#6A737D\">// Should not happen, but safe default</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Kubernetes API errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> apierrors.</span><span style=\"color:#B392F0\">IsConflict</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ErrorConflict</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> apierrors.</span><span style=\"color:#B392F0\">IsNotFound</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ErrorRetryable </span><span style=\"color:#6A737D\">// May be cache lag</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> apierrors.</span><span style=\"color:#B392F0\">IsServerTimeout</span><span style=\"color:#E1E4E8\">(err) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> apierrors.</span><span style=\"color:#B392F0\">IsTimeout</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ErrorTransient</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> apierrors.</span><span style=\"color:#B392F0\">IsTooManyRequests</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ErrorTransient</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> apierrors.</span><span style=\"color:#B392F0\">IsInternalError</span><span style=\"color:#E1E4E8\">(err) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> apierrors.</span><span style=\"color:#B392F0\">IsServiceUnavailable</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ErrorTransient</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> apierrors.</span><span style=\"color:#B392F0\">IsBadRequest</span><span style=\"color:#E1E4E8\">(err) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> apierrors.</span><span style=\"color:#B392F0\">IsInvalid</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ErrorPermanent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> apierrors.</span><span style=\"color:#B392F0\">IsForbidden</span><span style=\"color:#E1E4E8\">(err) </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> apierrors.</span><span style=\"color:#B392F0\">IsUnauthorized</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ErrorPermanent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Network errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> netErr </span><span style=\"color:#B392F0\">net</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">As</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">netErr) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> netErr.</span><span style=\"color:#B392F0\">Timeout</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> ErrorTransient</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ErrorTransient </span><span style=\"color:#6A737D\">// Most network errors are transient</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Default to transient for safety</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ErrorTransient</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandleReconcileError processes errors according to their classification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HandleReconcileError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">reconcile</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    classification </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">ClassifyError</span><span style=\"color:#E1E4E8\">(err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> classification {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ErrorTransient:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Let controller-runtime handle exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        r.</span><span style=\"color:#B392F0\">updateCondition</span><span style=\"color:#E1E4E8\">(db, ConditionTypeReady, </span><span style=\"color:#9ECBFF\">\"False\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"TransientError\"</span><span style=\"color:#E1E4E8\">, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> reconcile</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">{}, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ErrorRetryable:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Quick retry, might be cache staleness</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        r.</span><span style=\"color:#B392F0\">updateCondition</span><span style=\"color:#E1E4E8\">(db, ConditionTypeReady, </span><span style=\"color:#9ECBFF\">\"False\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"RetryableError\"</span><span style=\"color:#E1E4E8\">, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> reconcile</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">{RequeueAfter: </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ErrorConflict:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Resource version conflict - retry immediately</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> reconcile</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">{Requeue: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> ErrorPermanent:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Don't retry, update status with error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        r.</span><span style=\"color:#B392F0\">updateCondition</span><span style=\"color:#E1E4E8\">(db, ConditionTypeReady, </span><span style=\"color:#9ECBFF\">\"False\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"PermanentError\"</span><span style=\"color:#E1E4E8\">, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> reconcile</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#6A737D\"> // Don't return error to avoid retry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> reconcile</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">{}, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"robust-reconciliation-loop-skeleton\">Robust Reconciliation Loop Skeleton</h4>\n<p>This skeleton implements the complete error handling patterns discussed in the design section:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Reconcile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#B392F0\"> reconcile</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">reconcile</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.Log.</span><span style=\"color:#B392F0\">WithValues</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"database\"</span><span style=\"color:#E1E4E8\">, req.NamespacedName)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Fetch the Database resource with error handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Handle NotFound errors gracefully - resource may have been deleted</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> db </span><span style=\"color:#B392F0\">Database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(ctx, req.NamespacedName, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">db); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> apierrors.</span><span style=\"color:#B392F0\">IsNotFound</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Resource deleted, stop reconciliation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#B392F0\"> reconcile</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">HandleReconcileError</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">db, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Handle finalizer logic for deletion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check if deletion timestamp is set, add/remove finalizers accordingly</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">db.DeletionTimestamp.</span><span style=\"color:#B392F0\">IsZero</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">handleDeletion</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">db)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">controllerutil.</span><span style=\"color:#B392F0\">ContainsFinalizer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">db, FINALIZER_NAME) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        controllerutil.</span><span style=\"color:#B392F0\">AddFinalizer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">db, FINALIZER_NAME)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> reconcile</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">{Requeue: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">}, r.</span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">db)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Get current state of owned resources with conflict handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use Get() calls with proper error classification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentState, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">getCurrentState</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">db)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">HandleReconcileError</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">db, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Compare desired state from spec with current state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Implement comparison logic that's resilient to cache staleness</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    desiredState </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">computeDesiredState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">db)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    changes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">computeChanges</span><span style=\"color:#E1E4E8\">(currentState, desiredState)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Apply changes with proper error handling and conflict resolution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use Server-Side Apply for spec updates, handle conflicts gracefully</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, change </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> changes {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">applyChange</span><span style=\"color:#E1E4E8\">(ctx, change); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">ClassifyError</span><span style=\"color:#E1E4E8\">(err) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ErrorConflict {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Immediate retry for conflicts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#B392F0\"> reconcile</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">{Requeue: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">HandleReconcileError</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">db, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update status with current conditions and state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use status subresource, handle conflicts by re-reading and retrying</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">updateDatabaseStatus</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">db, currentState)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"webhook-error-handling-infrastructure\">Webhook Error Handling Infrastructure</h4>\n<p>Complete webhook error handling that addresses timeout and certificate issues:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> webhook</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/tls</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    admissionv1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/admission/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metav1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/apis/meta/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AdmissionHandler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    decoder </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">admission</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Decoder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    certReloader </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CertificateReloader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ServeHTTP handles admission review requests with comprehensive error handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdmissionHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ServeHTTP</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Set reasonable timeout for webhook processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Kubernetes has 10s default timeout, leave buffer for response</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithTimeout</span><span style=\"color:#E1E4E8\">(r.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">time.Second)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#B392F0\"> cancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Parse admission review request with error handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Handle malformed requests gracefully with proper HTTP status codes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    review, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">parseAdmissionReview</span><span style=\"color:#E1E4E8\">(r)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        h.</span><span style=\"color:#B392F0\">sendErrorResponse</span><span style=\"color:#E1E4E8\">(w, http.StatusBadRequest, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to parse admission review: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Process admission review with timeout handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check context deadline and return partial response if needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">processAdmissionReview</span><span style=\"color:#E1E4E8\">(ctx, review)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Send response with proper error handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Set appropriate HTTP status codes and content types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    h.</span><span style=\"color:#B392F0\">sendAdmissionResponse</span><span style=\"color:#E1E4E8\">(w, response)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// processAdmissionReview routes requests to appropriate handlers with error recovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">h </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdmissionHandler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">processAdmissionReview</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    review</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionReview</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionReview</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check context deadline before processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Return admission denial if insufficient time remains</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> deadline, ok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ctx.</span><span style=\"color:#B392F0\">Deadline</span><span style=\"color:#E1E4E8\">(); ok </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Until</span><span style=\"color:#E1E4E8\">(deadline) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">time.Second {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">timeoutResponse</span><span style=\"color:#E1E4E8\">(review, </span><span style=\"color:#9ECBFF\">\"Webhook processing timeout\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Route to appropriate handler based on operation and kind</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use type switches and handle unknown operations gracefully</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    req </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> review.Request</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> response </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionResponse</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> req.Kind.Kind </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"Database\"</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> req.Operation </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> admissionv1.Create:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        response </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">handleDatabaseCreate</span><span style=\"color:#E1E4E8\">(ctx, req)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> req.Kind.Kind </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"Database\"</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> req.Operation </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> admissionv1.Update:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        response </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">handleDatabaseUpdate</span><span style=\"color:#E1E4E8\">(ctx, req)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> req.Kind.Kind </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"Database\"</span><span style=\"color:#F97583\"> &#x26;&#x26;</span><span style=\"color:#E1E4E8\"> req.Operation </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> admissionv1.Delete:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        response </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">handleDatabaseDelete</span><span style=\"color:#E1E4E8\">(ctx, req)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        response </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> h.</span><span style=\"color:#B392F0\">allowResponse</span><span style=\"color:#E1E4E8\">(req.UID, </span><span style=\"color:#9ECBFF\">\"Operation not handled by this webhook\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create admission review response with proper metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Preserve request UID and API version information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">admissionv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AdmissionReview</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TypeMeta: </span><span style=\"color:#B392F0\">metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TypeMeta</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            APIVersion: </span><span style=\"color:#9ECBFF\">\"admission.k8s.io/v1\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Kind:       </span><span style=\"color:#9ECBFF\">\"AdmissionReview\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Response: response,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"tls-certificate-management\">TLS Certificate Management</h4>\n<p>Robust certificate handling that prevents webhook outages due to certificate issues:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CertificateReloader</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    certPath </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    keyPath  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cert     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">tls</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Certificate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    certTime </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    keyTime  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewCertificateReloader</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">certPath</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">keyPath</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CertificateReloader</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CertificateReloader</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        certPath: certPath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        keyPath:  keyPath,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetCertificate returns current certificate, reloading if files have changed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cr </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CertificateReloader</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetCertificate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">tls</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ClientHelloInfo</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">tls</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Certificate</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if certificate files have been modified</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use os.Stat to check modification times, reload if changed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Load certificate with proper error handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Don't update stored cert if loading fails, return previous cert</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate certificate expiration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Log warnings if certificate expires soon, return error if expired</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> cr.cert, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Checkpoint 1: Error Classification Testing</strong>\nRun this test to verify error classification works correctly:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/controller</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestErrorClassification</span></span></code></pre></div>\n<p>Expected behavior: All Kubernetes API error types are correctly classified as transient, retryable, or permanent. Network errors are classified as transient. Unknown errors default to transient.</p>\n<p><strong>Checkpoint 2: Reconciliation Error Handling</strong>\nCreate a Database resource with invalid configuration and verify the controller updates status with appropriate error condition instead of retrying indefinitely.</p>\n<p><strong>Checkpoint 3: Webhook Timeout Simulation</strong>\nAdd artificial delays to webhook processing and verify that requests near the timeout deadline are handled gracefully with appropriate admission responses.</p>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Resources stuck in pending state</td>\n<td>Controller crashing on reconciliation errors</td>\n<td>Check controller logs for panic stacktraces</td>\n<td>Add error handling and classification to reconciliation loop</td>\n</tr>\n<tr>\n<td>Webhook blocking all operations</td>\n<td>Certificate expired or webhook pod not ready</td>\n<td>Check webhook service endpoints and certificate validity</td>\n<td>Implement certificate reloading and webhook health checks</td>\n</tr>\n<tr>\n<td>Status never updates after errors</td>\n<td>Status update conflicts not handled</td>\n<td>Look for 409 Conflict errors in logs during status updates</td>\n<td>Implement conflict retry in status update logic</td>\n</tr>\n<tr>\n<td>Controller consuming excessive CPU</td>\n<td>Infinite reconciliation loop from missing error handling</td>\n<td>Monitor reconciliation frequency for specific resources</td>\n<td>Add proper requeue delays and error classification</td>\n</tr>\n<tr>\n<td>Resources stuck in deletion</td>\n<td>Finalizer not removed due to cleanup errors</td>\n<td>Check for resources with finalizers but no owning controller</td>\n<td>Implement finalizer cleanup verification on controller startup</td>\n</tr>\n</tbody></table>\n<p>The error handling and recovery mechanisms form the foundation of operator reliability. By implementing comprehensive error classification, intelligent retry logic, and robust conflict resolution, the operator can provide consistent behavior even in the face of network partitions, API server outages, and concurrent modifications that are inherent in distributed Kubernetes environments.</p>\n<h2 id=\"testing-strategy-and-validation\">Testing Strategy and Validation</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 5 (Testing &amp; Deployment) - provides comprehensive testing approaches for unit testing, integration testing, and milestone validation checkpoints that ensure the operator functions correctly at each development stage</p>\n</blockquote>\n<p>Testing a Kubernetes operator presents unique challenges that differ significantly from testing traditional applications. The operator must interact correctly with the Kubernetes API server, handle distributed system failures gracefully, and maintain consistent behavior across different cluster states. A robust testing strategy requires multiple layers of validation, from isolated unit tests that verify individual functions to full integration tests that exercise the complete controller lifecycle against a real API server.</p>\n<h3 id=\"mental-model-the-quality-assurance-laboratory\">Mental Model: The Quality Assurance Laboratory</h3>\n<p>Think of operator testing like a medical laboratory that validates treatments at multiple levels. Unit tests are like testing individual chemical reactions in isolation - they verify that specific functions produce expected outputs when given controlled inputs. Integration tests resemble clinical trials that test the complete treatment protocol on live subjects - they validate that the entire operator behaves correctly when interacting with a real Kubernetes environment. Finally, milestone validation checkpoints are like regulatory approval processes that ensure each development phase meets safety and efficacy standards before proceeding to the next phase.</p>\n<p>Just as medical testing requires both controlled laboratory conditions and real-world clinical validation, operator testing demands both isolated unit tests with predictable fake clients and comprehensive integration tests against actual Kubernetes API servers. Each testing layer catches different categories of defects and provides different types of confidence in the system&#39;s correctness.</p>\n<h2 id=\"unit-testing-with-fake-clients\">Unit Testing with Fake Clients</h2>\n<p>Unit testing forms the foundation of operator validation by testing individual controller functions in complete isolation from external dependencies. The controller-runtime library provides sophisticated fake client implementations that simulate Kubernetes API behavior without requiring an actual cluster. These fake clients maintain in-memory representations of cluster state and respond to client operations with realistic behavior, including resource versioning, conflict detection, and validation.</p>\n<p><strong>Fake clients excel at testing reconciliation logic</strong> because they provide deterministic, controllable environments where specific error conditions can be simulated reliably. Unlike integration tests that may exhibit timing-dependent behavior, unit tests with fake clients produce identical results on every execution, making them ideal for testing edge cases and error scenarios that would be difficult to reproduce consistently in real clusters.</p>\n<p>The fake client architecture maintains separate storage for each resource type, implementing the same optimistic locking semantics as the real Kubernetes API server. When a test creates a <code>Database</code> resource with the fake client, subsequent <code>Get</code> operations return the exact object with proper resource versions and generation fields. Updates that specify outdated resource versions fail with conflict errors, allowing tests to verify that the controller handles concurrent modifications correctly.</p>\n<h3 id=\"core-testing-components\">Core Testing Components</h3>\n<p>The unit testing infrastructure relies on several key components that work together to provide comprehensive test coverage:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>fake.NewClientBuilder()</code></td>\n<td>Client Builder</td>\n<td>Creates configurable fake Kubernetes client instances</td>\n</tr>\n<tr>\n<td><code>scheme.Scheme</code></td>\n<td>Runtime Scheme</td>\n<td>Defines known resource types for client serialization</td>\n</tr>\n<tr>\n<td><code>envtest.Environment</code></td>\n<td>Test Environment</td>\n<td>Provides real API server for integration tests</td>\n</tr>\n<tr>\n<td><code>reconcile.Request</code></td>\n<td>Reconciliation Request</td>\n<td>Represents controller work queue items</td>\n</tr>\n<tr>\n<td><code>ctrl.Result</code></td>\n<td>Reconciliation Result</td>\n<td>Indicates requeue behavior and timing</td>\n</tr>\n</tbody></table>\n<h3 id=\"testing-reconciliation-logic\">Testing Reconciliation Logic</h3>\n<p>The core of unit testing focuses on validating the <code>Reconcile</code> method behavior under various scenarios. Each test case should establish a known cluster state using the fake client, trigger reconciliation for a specific resource, and verify both the returned result and the resulting cluster state changes.</p>\n<p><strong>Testing successful reconciliation</strong> requires creating a <code>Database</code> resource with a valid specification, calling the reconciler, and verifying that owned resources are created with correct configurations. The test must check that the <code>Database</code> status is updated with appropriate conditions and that the reconciliation result indicates successful completion without requeue requirements.</p>\n<p><strong>Testing error conditions</strong> involves simulating various failure modes and verifying that the controller responds appropriately. This includes testing scenarios where owned resources cannot be created due to API server errors, where resource specifications contain invalid configurations, and where external dependencies are unavailable.</p>\n<p><strong>Testing idempotent behavior</strong> ensures that repeated reconciliation of the same resource produces identical results. This critical property guarantees that controller restarts or duplicate events do not cause unintended side effects or resource duplication.</p>\n<h3 id=\"fake-client-configuration-and-setup\">Fake Client Configuration and Setup</h3>\n<p>Proper fake client configuration requires careful attention to scheme registration and resource type definitions. The fake client must understand all custom resource types that the controller manages, requiring explicit registration of CRDs in the runtime scheme.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Example scheme registration (Implementation Guidance will show complete code)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">scheme.</span><span style=\"color:#B392F0\">AddToScheme</span><span style=\"color:#E1E4E8\">(DatabaseCRD)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">scheme.</span><span style=\"color:#B392F0\">AddToScheme</span><span style=\"color:#E1E4E8\">(SecretCRD)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">fakeClient </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fake.</span><span style=\"color:#B392F0\">NewClientBuilder</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">WithScheme</span><span style=\"color:#E1E4E8\">(scheme).</span><span style=\"color:#B392F0\">Build</span><span style=\"color:#E1E4E8\">()</span></span></code></pre></div>\n\n<p>The fake client supports advanced features like resource generation tracking, owner reference validation, and finalizer processing. Tests can configure the fake client to simulate specific API server behaviors, such as temporary unavailability or resource quota enforcement.</p>\n<p><strong>Initial state setup</strong> involves creating prerequisite resources that the controller expects to exist. This might include <code>ConfigMap</code> resources containing default configurations, <code>Secret</code> resources with authentication credentials, or <code>Namespace</code> resources that own the custom resources being tested.</p>\n<h3 id=\"status-update-validation\">Status Update Validation</h3>\n<p>Testing status updates requires careful verification that the controller correctly writes status information without affecting the resource specification. The fake client maintains separate tracking for spec and status subresources, allowing tests to verify that status updates do not inadvertently modify the desired state.</p>\n<table>\n<thead>\n<tr>\n<th>Status Field</th>\n<th>Test Verification</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Conditions</code></td>\n<td>Contains expected condition types with correct status values</td>\n<td>Communicates current reconciliation state</td>\n</tr>\n<tr>\n<td><code>ReadyReplicas</code></td>\n<td>Matches number of ready owned resources</td>\n<td>Indicates operational capacity</td>\n</tr>\n<tr>\n<td><code>ObservedGeneration</code></td>\n<td>Equals metadata generation of reconciled resource</td>\n<td>Shows which spec version was processed</td>\n</tr>\n<tr>\n<td><code>Phase</code></td>\n<td>Reflects current lifecycle stage</td>\n<td>Provides high-level status summary</td>\n</tr>\n<tr>\n<td><code>LastBackupTime</code></td>\n<td>Updated when backup operations complete</td>\n<td>Tracks operational activities</td>\n</tr>\n<tr>\n<td><code>Endpoints</code></td>\n<td>Lists accessible service endpoints</td>\n<td>Provides connectivity information</td>\n</tr>\n</tbody></table>\n<p><strong>Condition testing</strong> focuses on verifying that the controller creates appropriate condition entries for different scenarios. Ready conditions should indicate when all owned resources are operational, while progressing conditions should appear during active reconciliation activities. Error conditions must provide clear, actionable messages that help users understand and resolve issues.</p>\n<h3 id=\"error-handling-and-requeue-testing\">Error Handling and Requeue Testing</h3>\n<p>Unit tests must thoroughly validate the controller&#39;s error handling behavior, ensuring that different error types trigger appropriate responses. Transient errors should result in exponential backoff requeue behavior, while permanent errors should update the resource status without scheduling automatic retries.</p>\n<p>The fake client can be configured to return specific error types for different operations, allowing tests to verify controller behavior in response to various failure modes:</p>\n<table>\n<thead>\n<tr>\n<th>Error Scenario</th>\n<th>Expected Behavior</th>\n<th>Test Validation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>API server unavailable</td>\n<td>Return error with immediate requeue</td>\n<td>Verify <code>Result.Requeue</code> is true</td>\n</tr>\n<tr>\n<td>Resource already exists</td>\n<td>Continue reconciliation normally</td>\n<td>Verify no error returned</td>\n</tr>\n<tr>\n<td>Invalid resource configuration</td>\n<td>Update status with error condition</td>\n<td>Verify condition type and message</td>\n</tr>\n<tr>\n<td>Insufficient permissions</td>\n<td>Return error without requeue</td>\n<td>Verify <code>Result.RequeueAfter</code> is zero</td>\n</tr>\n<tr>\n<td>Resource conflict</td>\n<td>Return error with short requeue delay</td>\n<td>Verify <code>Result.RequeueAfter</code> &lt; 1 minute</td>\n</tr>\n</tbody></table>\n<p><strong>Requeue timing validation</strong> ensures that the controller requests appropriate delays between reconciliation attempts. Immediate requeues should be reserved for situations where external state changes are expected quickly, while longer delays should be used for scenarios requiring user intervention or external system recovery.</p>\n<h3 id=\"testing-finalizer-logic\">Testing Finalizer Logic</h3>\n<p>Finalizer processing represents one of the most critical and error-prone aspects of operator behavior. Unit tests must verify that finalizers are added during resource creation, that cleanup operations execute correctly during deletion, and that finalizers are removed only after successful cleanup completion.</p>\n<p><strong>Testing finalizer addition</strong> involves creating a new <code>Database</code> resource and verifying that the controller adds the appropriate finalizer during initial reconciliation. The test should confirm that the finalizer appears in the resource metadata and that subsequent reconciliation recognizes the finalizer&#39;s presence.</p>\n<p><strong>Testing deletion and cleanup</strong> requires setting a deletion timestamp on a resource with finalizers and verifying that cleanup operations execute in the correct order. The controller should delete all owned resources, wait for deletion completion, and only then remove the finalizer to allow garbage collection.</p>\n<p><strong>Testing cleanup failures</strong> ensures that incomplete cleanup operations do not remove finalizers prematurely. If owned resource deletion fails, the controller should leave finalizers in place and report error conditions in the resource status.</p>\n<h3 id=\"common-unit-testing-pitfalls\">Common Unit Testing Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Not Configuring Fake Client Scheme Properly</strong></p>\n<p>Tests frequently fail because the fake client doesn&#39;t understand custom resource types that the controller attempts to manipulate. This manifests as serialization errors or &quot;no kind is registered&quot; panics during test execution. The fix requires explicitly adding all relevant CRDs and built-in Kubernetes types to the fake client&#39;s scheme during test setup.</p>\n<p>⚠️ <strong>Pitfall: Testing Only Happy Path Scenarios</strong></p>\n<p>Many unit test suites focus exclusively on successful reconciliation scenarios while ignoring error conditions and edge cases. This creates false confidence in controller reliability because real-world environments frequently encounter API server unavailability, resource conflicts, and configuration errors. Comprehensive test suites should include more error scenarios than success scenarios.</p>\n<p>⚠️ <strong>Pitfall: Not Verifying Status Updates Separately</strong></p>\n<p>Tests often check that reconciliation completes successfully but fail to verify that status updates contain correct information. Since status subresources update independently from spec changes, tests must explicitly fetch and validate status fields after reconciliation completion. Missing status validation can hide bugs where controllers perform correct actions but provide incorrect feedback to users.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Resource Version and Generation Fields</strong></p>\n<p>Fake clients properly implement optimistic locking through resource versions, but tests that don&#39;t account for these fields may pass artificially. Real controllers must handle resource version conflicts and generation tracking correctly, so unit tests should verify that these mechanisms work properly by attempting concurrent modifications and checking generation-based condition logic.</p>\n<h2 id=\"integration-testing-with-envtest\">Integration Testing with Envtest</h2>\n<p>Integration testing validates operator behavior against real Kubernetes API servers, providing confidence that the controller works correctly within actual cluster environments. The <code>envtest</code> framework creates lightweight Kubernetes control planes that include <code>etcd</code> and <code>kube-apiserver</code> components without the overhead of full cluster deployments. These test environments support all standard Kubernetes API operations while running quickly enough for automated testing pipelines.</p>\n<p><strong>Envtest bridges the gap between unit tests and full cluster testing</strong> by providing real API server behavior while maintaining test isolation and repeatability. Unlike fake clients that simulate API responses, envtest environments process requests through actual Kubernetes controllers, including garbage collection, owner reference processing, and admission controller execution.</p>\n<p>The envtest environment supports advanced Kubernetes features that fake clients cannot replicate, such as server-side apply, strategic merge patches, and admission webhook processing. This comprehensive API compatibility ensures that operators tested with envtest behave identically in production clusters, reducing the likelihood of integration issues during deployment.</p>\n<h3 id=\"envtest-environment-setup\">Envtest Environment Setup</h3>\n<p>Envtest environments require careful configuration to match production cluster characteristics while maintaining test performance. The environment setup process involves downloading Kubernetes binaries, configuring API server options, and establishing client connections with appropriate authentication credentials.</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Option</th>\n<th>Purpose</th>\n<th>Typical Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>KubernetesVersion</code></td>\n<td>Specifies API server version</td>\n<td>&quot;1.28.0&quot;</td>\n</tr>\n<tr>\n<td><code>CRDInstallOptions.Paths</code></td>\n<td>Locations of CRD YAML files</td>\n<td>[&quot;./config/crd/bases&quot;]</td>\n</tr>\n<tr>\n<td><code>UseExistingCluster</code></td>\n<td>Connect to running cluster instead of creating new one</td>\n<td>false for CI, true for debugging</td>\n</tr>\n<tr>\n<td><code>AttachControlPlaneOutput</code></td>\n<td>Show API server logs during tests</td>\n<td>true for debugging</td>\n</tr>\n<tr>\n<td><code>ControlPlaneStartTimeout</code></td>\n<td>Maximum time to wait for startup</td>\n<td>60 * time.Second</td>\n</tr>\n<tr>\n<td><code>ControlPlaneStopTimeout</code></td>\n<td>Maximum time to wait for shutdown</td>\n<td>60 * time.Second</td>\n</tr>\n</tbody></table>\n<p><strong>CRD installation</strong> happens automatically during environment startup when CRD paths are configured correctly. The envtest framework reads YAML files from specified directories and creates custom resource definitions before starting the test API server. This process ensures that custom resources are available immediately when tests begin execution.</p>\n<p><strong>Client configuration</strong> uses the same controller-runtime managers and clients that production operators employ. This consistency ensures that integration tests exercise identical code paths to production environments, including client-side caching, informer behavior, and work queue processing.</p>\n<h3 id=\"controller-manager-integration\">Controller Manager Integration</h3>\n<p>Integration tests run complete controller managers that include informers, work queues, and reconciliation loops. This comprehensive testing approach validates not only individual reconciliation logic but also the interactions between different controller components and their behavior under concurrent load.</p>\n<p>The controller manager setup process involves registering custom resource schemes, configuring controller options, and starting background processing goroutines. Integration tests must carefully coordinate controller startup with test execution to ensure that informer caches are populated and event processing is active before triggering test scenarios.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Example controller manager setup (complete implementation in Implementation Guidance)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">mgr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ctrl.</span><span style=\"color:#B392F0\">NewManager</span><span style=\"color:#E1E4E8\">(cfg, </span><span style=\"color:#B392F0\">ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Options</span><span style=\"color:#E1E4E8\">{Scheme: scheme})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">reconciler </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">{Client: mgr.</span><span style=\"color:#B392F0\">GetClient</span><span style=\"color:#E1E4E8\">(), Scheme: scheme}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">reconciler.</span><span style=\"color:#B392F0\">SetupWithManager</span><span style=\"color:#E1E4E8\">(mgr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithCancel</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\"> mgr.</span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(ctx)</span></span></code></pre></div>\n\n<p><strong>Manager lifecycle coordination</strong> requires proper startup sequencing and graceful shutdown handling. Tests must wait for manager readiness before executing test scenarios and must trigger clean shutdown to prevent goroutine leaks between test cases.</p>\n<p><strong>Informer cache synchronization</strong> introduces timing considerations that don&#39;t exist in unit tests. Integration tests must wait for informer caches to populate with initial resource state before verifying controller behavior, as controllers operating with empty caches may exhibit different behavior than those with fully synchronized state.</p>\n<h3 id=\"end-to-end-reconciliation-testing\">End-to-End Reconciliation Testing</h3>\n<p>Integration tests validate complete reconciliation cycles by creating custom resources, waiting for controller processing, and verifying that both owned resources and status updates reflect the expected final state. These tests provide confidence that all components work together correctly under realistic conditions.</p>\n<p><strong>Resource creation testing</strong> involves applying <code>Database</code> resources to the envtest cluster and monitoring both the reconciliation process and its outcomes. Tests must account for asynchronous processing by polling resource status until reconciliation completes or timeout periods expire.</p>\n<p><strong>Owned resource verification</strong> ensures that controllers create, configure, and manage owned resources correctly. Integration tests should verify not only that owned resources exist but also that they contain correct specifications, labels, annotations, and owner references that enable proper garbage collection.</p>\n<p><strong>Status progression tracking</strong> monitors how resource status evolves during reconciliation cycles. Tests should verify that progressing conditions appear during active reconciliation, that ready conditions indicate successful completion, and that error conditions provide actionable diagnostic information.</p>\n<h3 id=\"testing-concurrent-reconciliation\">Testing Concurrent Reconciliation</h3>\n<p>Integration tests can validate controller behavior under concurrent load by creating multiple custom resources simultaneously and verifying that reconciliation proceeds correctly for all resources. This testing approach reveals race conditions, resource contention issues, and queue processing problems that single-resource tests cannot detect.</p>\n<p><strong>Multiple resource testing</strong> creates several <code>Database</code> resources with different configurations and verifies that each resource reconciles independently without interference. These tests should confirm that controller scaling works correctly and that individual resource failures do not affect processing of other resources.</p>\n<p><strong>Resource update testing</strong> modifies existing resources while reconciliation is active, simulating real-world scenarios where users update specifications while controllers are processing previous changes. Tests should verify that controllers handle spec changes gracefully and that status updates reflect the most recent reconciliation results.</p>\n<p><strong>Concurrent modification testing</strong> attempts to modify resources from multiple clients simultaneously, verifying that controllers handle resource version conflicts and retry operations appropriately. These tests ensure that operators behave correctly in multi-user environments where administrative operations may overlap with controller activities.</p>\n<h3 id=\"webhook-integration-testing\">Webhook Integration Testing</h3>\n<p>Integration tests with envtest can validate admission webhook behavior by configuring webhook endpoints and processing admission review requests through the test API server. This comprehensive testing approach ensures that webhooks integrate correctly with the Kubernetes admission control system.</p>\n<p><strong>Webhook server setup</strong> involves starting HTTPS servers with appropriate TLS certificates and registering admission webhook configurations with the test API server. The envtest framework supports webhook testing through proper certificate management and admission controller configuration.</p>\n<p><strong>Validation webhook testing</strong> creates resources with invalid specifications and verifies that admission webhooks reject requests with appropriate error messages. Tests should confirm that validation logic correctly identifies invalid field combinations and provides clear diagnostic information to users.</p>\n<p><strong>Mutation webhook testing</strong> creates resources with minimal specifications and verifies that mutating webhooks inject appropriate default values. Tests should confirm that mutation logic produces consistent results and that mutated resources pass subsequent validation checks.</p>\n<h3 id=\"performance-and-load-testing\">Performance and Load Testing</h3>\n<p>Integration tests can evaluate operator performance characteristics by creating large numbers of resources and measuring reconciliation throughput, memory usage, and response times. These measurements provide baseline performance expectations and help identify scalability limitations.</p>\n<p><strong>Throughput testing</strong> creates batches of resources and measures how quickly the controller processes them to completion. These tests help establish capacity planning guidelines and identify performance bottlenecks in reconciliation logic.</p>\n<p><strong>Memory usage testing</strong> monitors controller memory consumption while processing various workloads to identify memory leaks or excessive resource usage. Long-running tests can reveal gradual memory growth that would not be apparent in short-duration scenarios.</p>\n<p><strong>Response time testing</strong> measures the delay between resource creation and reconciliation completion, providing insights into user experience and system responsiveness. These measurements help establish appropriate timeout values and requeue intervals.</p>\n<h3 id=\"common-integration-testing-pitfalls\">Common Integration Testing Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Not Waiting for Controller Readiness</strong></p>\n<p>Integration tests frequently fail because they attempt to validate controller behavior before informer caches are fully synchronized or before controllers have registered their watches. This manifests as tests that pass when run individually but fail when executed as part of larger test suites. The fix requires implementing proper readiness checks that wait for manager startup completion and informer cache synchronization.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Asynchronous Processing</strong></p>\n<p>Many integration tests assume that reconciliation completes immediately after resource creation, leading to race conditions where tests check results before processing finishes. Real controllers process events asynchronously through work queues, requiring tests to poll for expected conditions with appropriate timeout values rather than checking results immediately.</p>\n<p>⚠️ <strong>Pitfall: Not Cleaning Up Resources Between Tests</strong></p>\n<p>Integration tests that don&#39;t properly clean up created resources can exhibit order-dependent failures where previous test state affects subsequent test execution. Since envtest environments persist resources across individual test cases within a suite, tests must explicitly delete created resources or use unique namespaces to ensure isolation.</p>\n<p>⚠️ <strong>Pitfall: Insufficient Timeout Values</strong></p>\n<p>Integration tests often use timeout values that work during local development but fail in resource-constrained CI environments. Envtest startup, controller initialization, and reconciliation processing all require sufficient time to complete, particularly when running on shared infrastructure with limited CPU resources.</p>\n<h2 id=\"milestone-validation-checkpoints\">Milestone Validation Checkpoints</h2>\n<p>Each development milestone requires specific validation checkpoints that verify correct implementation before proceeding to subsequent phases. These checkpoints combine automated testing with manual verification to ensure that foundational components work correctly before adding additional complexity.</p>\n<p><strong>Milestone validation provides confidence gates</strong> that prevent cascading failures where issues in early milestones cause confusing symptoms in later development phases. By establishing clear success criteria for each milestone, developers can focus on one set of challenges at a time while building incrementally toward a complete operator implementation.</p>\n<p>The validation checkpoints include both positive testing that verifies expected behavior and negative testing that confirms appropriate error handling. Each checkpoint also includes performance expectations and operational characteristics that should be observable during testing.</p>\n<h3 id=\"milestone-1-custom-resource-definition-validation\">Milestone 1: Custom Resource Definition Validation</h3>\n<p>The first milestone focuses on validating that custom resource definitions are properly configured with appropriate schema validation, status subresources, and versioning support. These foundational elements must work correctly before controller implementation begins.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Check</th>\n<th>Expected Behavior</th>\n<th>Verification Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CRD Installation</td>\n<td>CRD appears in cluster and accepts valid resources</td>\n<td><code>kubectl get crd databases.example.com</code></td>\n</tr>\n<tr>\n<td>Schema Validation</td>\n<td>Invalid resources are rejected with clear error messages</td>\n<td><code>kubectl apply</code> with invalid YAML</td>\n</tr>\n<tr>\n<td>Status Subresource</td>\n<td>Status updates don&#39;t affect spec fields</td>\n<td>Separate <code>kubectl patch</code> operations</td>\n</tr>\n<tr>\n<td>Printer Columns</td>\n<td>Custom columns appear in <code>kubectl get</code> output</td>\n<td><code>kubectl get databases</code> shows custom fields</td>\n</tr>\n<tr>\n<td>OpenAPI Integration</td>\n<td>API discovery includes CRD schema information</td>\n<td><code>kubectl explain database.spec</code></td>\n</tr>\n<tr>\n<td>Multiple Versions</td>\n<td>Both v1alpha1 and v1beta1 versions are accepted</td>\n<td>Create resources with different apiVersions</td>\n</tr>\n</tbody></table>\n<p><strong>Schema validation testing</strong> involves creating <code>Database</code> resources with various invalid configurations and verifying that the API server rejects them with helpful error messages. Tests should cover missing required fields, invalid enum values, and constraint violations like negative replica counts.</p>\n<p><strong>Status subresource testing</strong> confirms that status updates operate independently from spec modifications. This involves patching status fields directly and verifying that the resource generation field doesn&#39;t increment, indicating that spec changes and status updates are properly isolated.</p>\n<p><strong>Version conversion testing</strong> creates resources using older API versions and verifies that they can be retrieved using newer versions, with appropriate field mapping and default value injection occurring during conversion.</p>\n<h3 id=\"milestone-2-controller-setup-validation\">Milestone 2: Controller Setup Validation</h3>\n<p>The second milestone validates that the controller infrastructure is properly configured with working client connections, informer caches, and work queue processing. These components must function correctly before implementing reconciliation logic.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Check</th>\n<th>Expected Behavior</th>\n<th>Verification Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Client Connection</td>\n<td>Controller can list and watch custom resources</td>\n<td>Log messages show successful connection</td>\n</tr>\n<tr>\n<td>Informer Startup</td>\n<td>Informer cache synchronizes with API server state</td>\n<td>Ready condition in manager status</td>\n</tr>\n<tr>\n<td>Event Processing</td>\n<td>Resource changes trigger work queue entries</td>\n<td>Debug logs show enqueued reconciliation requests</td>\n</tr>\n<tr>\n<td>Worker Goroutines</td>\n<td>Multiple reconciliation requests process concurrently</td>\n<td>Concurrent processing visible in logs</td>\n</tr>\n<tr>\n<td>Leader Election</td>\n<td>Only one controller replica processes events</td>\n<td>Multiple replicas with one active leader</td>\n</tr>\n<tr>\n<td>RBAC Permissions</td>\n<td>Controller can read, create, update, and delete required resources</td>\n<td>No permission denied errors</td>\n</tr>\n</tbody></table>\n<p><strong>Client functionality testing</strong> creates, updates, and deletes resources using the controller&#39;s Kubernetes client to verify that authentication and authorization work correctly. This includes testing both cached reads through informers and direct API calls for write operations.</p>\n<p><strong>Informer behavior testing</strong> creates resources outside the controller and verifies that informer caches reflect changes within reasonable time periods. Tests should also verify that informer resync operations occur at configured intervals.</p>\n<p><strong>Work queue testing</strong> triggers rapid resource changes and verifies that work queue processing handles the load without dropping events or creating excessive goroutines. Rate limiting behavior should be observable during high-frequency updates.</p>\n<h3 id=\"milestone-3-reconciliation-loop-validation\">Milestone 3: Reconciliation Loop Validation</h3>\n<p>The third milestone validates that reconciliation logic correctly compares desired versus actual state and takes appropriate corrective actions. This represents the core operator functionality and requires comprehensive testing across various scenarios.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Check</th>\n<th>Expected Behavior</th>\n<th>Verification Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Resource Creation</td>\n<td>New Database resources trigger owned resource creation</td>\n<td>Deployment and Service objects appear</td>\n</tr>\n<tr>\n<td>Resource Updates</td>\n<td>Spec changes propagate to owned resources</td>\n<td>Modified owned resources match new spec</td>\n</tr>\n<tr>\n<td>Resource Deletion</td>\n<td>Finalizer processing cleans up owned resources</td>\n<td>Owned resources deleted before Database removal</td>\n</tr>\n<tr>\n<td>Status Updates</td>\n<td>Status reflects current reconciliation state</td>\n<td>Conditions indicate progress and completion</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Reconciliation failures update status appropriately</td>\n<td>Error conditions with diagnostic messages</td>\n</tr>\n<tr>\n<td>Idempotent Operations</td>\n<td>Repeated reconciliation produces identical results</td>\n<td>Multiple reconcile calls show no changes</td>\n</tr>\n</tbody></table>\n<p><strong>State comparison testing</strong> modifies owned resources directly and verifies that the controller detects differences and restores desired state. This includes testing configuration drift scenarios where external processes modify controller-managed resources.</p>\n<p><strong>Reconciliation timing testing</strong> measures how quickly controllers detect changes and complete reconciliation cycles. Response times should be consistent and appropriate for the complexity of managed resources.</p>\n<p><strong>Error recovery testing</strong> introduces various failure conditions and verifies that controllers handle them gracefully with appropriate status reporting and retry behavior. This includes testing API server unavailability, resource conflicts, and invalid configurations.</p>\n<h3 id=\"milestone-4-webhook-validation\">Milestone 4: Webhook Validation</h3>\n<p>The fourth milestone validates that admission webhooks correctly validate and mutate resources according to business rules and policy requirements. Webhook behavior must be thoroughly tested because admission failures can prevent resource creation entirely.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Check</th>\n<th>Expected Behavior</th>\n<th>Verification Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Webhook Registration</td>\n<td>Admission webhook configurations appear in cluster</td>\n<td><code>kubectl get validatingwebhookconfiguration</code></td>\n</tr>\n<tr>\n<td>TLS Certificate Setup</td>\n<td>Webhook server accepts HTTPS connections</td>\n<td>Certificate validation in server logs</td>\n</tr>\n<tr>\n<td>Validation Logic</td>\n<td>Invalid resources are rejected with clear messages</td>\n<td><code>kubectl apply</code> with policy violations</td>\n</tr>\n<tr>\n<td>Mutation Logic</td>\n<td>Default values are injected into new resources</td>\n<td>Compare applied vs original resource content</td>\n</tr>\n<tr>\n<td>Webhook Availability</td>\n<td>Admission processing continues during webhook updates</td>\n<td>No service disruption during deployment</td>\n</tr>\n<tr>\n<td>Error Responses</td>\n<td>Admission failures include actionable error messages</td>\n<td>Clear feedback about validation failures</td>\n</tr>\n</tbody></table>\n<p><strong>Validation testing</strong> attempts to create resources that violate business rules and verifies that webhooks reject them with informative error messages. Tests should cover both simple field validation and complex cross-field business logic.</p>\n<p><strong>Mutation testing</strong> creates resources with minimal specifications and verifies that webhooks inject appropriate default values and computed fields. The resulting resources should be valid and functionally complete.</p>\n<p><strong>Certificate management testing</strong> verifies that webhook certificates are properly provisioned, renewed before expiration, and updated without service disruption. This includes testing both cert-manager integration and manual certificate management approaches.</p>\n<h3 id=\"milestone-5-testing-and-deployment-validation\">Milestone 5: Testing and Deployment Validation</h3>\n<p>The final milestone validates that the complete operator functions correctly in production-like environments with proper security configuration, monitoring integration, and operational procedures. This comprehensive validation ensures that the operator is ready for production deployment.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Check</th>\n<th>Expected Behavior</th>\n<th>Verification Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unit Test Coverage</td>\n<td>All reconciliation paths have comprehensive test coverage</td>\n<td>Code coverage reports show &gt;80% coverage</td>\n</tr>\n<tr>\n<td>Integration Tests</td>\n<td>End-to-end scenarios pass consistently</td>\n<td>Automated test suite passes in CI</td>\n</tr>\n<tr>\n<td>Container Image Build</td>\n<td>Operator image builds successfully with proper labeling</td>\n<td><code>docker build</code> produces tagged image</td>\n</tr>\n<tr>\n<td>RBAC Configuration</td>\n<td>Deployed operator has minimal required permissions</td>\n<td>Security audit of ClusterRole permissions</td>\n</tr>\n<tr>\n<td>High Availability</td>\n<td>Multiple operator replicas with leader election work correctly</td>\n<td>Pod failures don&#39;t interrupt reconciliation</td>\n</tr>\n<tr>\n<td>Monitoring Integration</td>\n<td>Metrics and logs provide operational visibility</td>\n<td>Prometheus metrics and structured logs</td>\n</tr>\n</tbody></table>\n<p><strong>End-to-end testing</strong> deploys the operator to test clusters and validates that complete user workflows function correctly from resource creation through deletion. These tests should simulate real user interactions and verify that all features work together seamlessly.</p>\n<p><strong>Production readiness testing</strong> evaluates the operator under production-like conditions including resource constraints, network partitions, and concurrent user activity. These tests identify potential issues that might not appear under ideal testing conditions.</p>\n<p><strong>Operational testing</strong> verifies that administrative procedures like operator upgrades, certificate rotation, and backup/restore operations work correctly without disrupting managed applications.</p>\n<h3 id=\"common-milestone-validation-pitfalls\">Common Milestone Validation Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Skipping Negative Testing</strong></p>\n<p>Many validation checkpoints focus only on verifying that expected behaviors work correctly while ignoring error conditions and edge cases. Production environments frequently encounter unexpected inputs, network failures, and resource constraints that can expose untested code paths. Comprehensive validation requires testing both success and failure scenarios at each milestone.</p>\n<p>⚠️ <strong>Pitfall: Not Testing Real-World Conditions</strong></p>\n<p>Validation that works in clean, isolated test environments may fail when deployed to production clusters with existing workloads, resource quotas, and security policies. Effective milestone validation should include testing under conditions that approximate production environments, including limited resources and competing workloads.</p>\n<p>⚠️ <strong>Pitfall: Insufficient Soak Testing</strong></p>\n<p>Many operators that pass short-duration tests exhibit issues like memory leaks, performance degradation, or state corruption over longer periods. Milestone validation should include extended testing periods that allow time-dependent issues to manifest, particularly for controllers that process high event volumes.</p>\n<p>⚠️ <strong>Pitfall: Not Validating User Experience</strong></p>\n<p>Technical validation often focuses on internal correctness while ignoring the user experience aspects like error message clarity, documentation accuracy, and operational complexity. Production operators must provide excellent user experiences, requiring validation that includes usability testing from the perspective of actual users.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides practical implementation details for building comprehensive testing infrastructure that supports effective operator development and validation.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Testing Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unit Testing Framework</td>\n<td>Go&#39;s built-in <code>testing</code> package</td>\n<td>Ginkgo + Gomega for BDD-style testing</td>\n</tr>\n<tr>\n<td>Integration Testing</td>\n<td>controller-runtime&#39;s <code>envtest</code> package</td>\n<td>Kind clusters for full Kubernetes features</td>\n</tr>\n<tr>\n<td>Mock Generation</td>\n<td>Manual fake implementations</td>\n<td><code>go generate</code> with <code>counterfeiter</code> or <code>gomock</code></td>\n</tr>\n<tr>\n<td>Test Data Management</td>\n<td>Hard-coded YAML strings</td>\n<td>External YAML files with template processing</td>\n</tr>\n<tr>\n<td>Assertion Library</td>\n<td>Basic Go comparisons</td>\n<td><code>testify/assert</code> for rich assertion methods</td>\n</tr>\n<tr>\n<td>Coverage Analysis</td>\n<td><code>go test -cover</code> built-in coverage</td>\n<td><code>gocov</code> + <code>gocov-html</code> for detailed reports</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  controllers/\n    database_controller.go           ← main controller implementation\n    database_controller_test.go      ← unit tests with fake client\n    suite_test.go                    ← integration test suite setup\n  webhooks/\n    database_webhook.go              ← admission webhook implementation\n    database_webhook_test.go         ← unit tests for webhook logic\n    webhook_suite_test.go            ← integration tests with envtest\n  testdata/\n    valid-database.yaml              ← test resource manifests\n    invalid-database.yaml            ← resources for validation testing\n    webhook-certificates/            ← test TLS certificates\n      tls.crt\n      tls.key\n  hack/\n    setup-envtest.sh                 ← script to install envtest binaries\n    run-integration-tests.sh         ← script for CI integration testing</code></pre></div>\n\n<h4 id=\"complete-unit-testing-infrastructure\">Complete Unit Testing Infrastructure</h4>\n<p>This infrastructure provides a complete foundation for unit testing with fake clients:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// controllers/suite_test.go - Complete unit test setup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> controllers</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    . </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/onsi/ginkgo/v2</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    . </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/onsi/gomega</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    corev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/core/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metav1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/apis/meta/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/client-go/kubernetes/scheme</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/client</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/client/fake</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/envtest</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/log/zap</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    examplev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/example/database-operator/api/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    k8sClient </span><span style=\"color:#B392F0\">client</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    testEnv   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">envtest</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Environment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx       </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cancel    </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CancelFunc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestControllers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    RegisterFailHandler</span><span style=\"color:#E1E4E8\">(Fail)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    RunSpecs</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#9ECBFF\">\"Controller Suite\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> BeforeSuite</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl.</span><span style=\"color:#B392F0\">SetLogger</span><span style=\"color:#E1E4E8\">(zap.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(zap.</span><span style=\"color:#B392F0\">WriteTo</span><span style=\"color:#E1E4E8\">(GinkgoWriter), zap.</span><span style=\"color:#B392F0\">UseDevMode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">)))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx, cancel </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithCancel</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    By</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"bootstrapping test environment\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    testEnv </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">envtest</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Environment</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CRDDirectoryPaths:     []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"..\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"config\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"crd\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"bases\"</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ErrorIfCRDPathMissing: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cfg, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> testEnv.</span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Expect</span><span style=\"color:#E1E4E8\">(err).</span><span style=\"color:#B392F0\">NotTo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">HaveOccurred</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Expect</span><span style=\"color:#E1E4E8\">(cfg).</span><span style=\"color:#B392F0\">NotTo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BeNil</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> examplev1.</span><span style=\"color:#B392F0\">AddToScheme</span><span style=\"color:#E1E4E8\">(scheme.Scheme)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Expect</span><span style=\"color:#E1E4E8\">(err).</span><span style=\"color:#B392F0\">NotTo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">HaveOccurred</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    k8sClient, err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> client.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(cfg, </span><span style=\"color:#B392F0\">client</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Options</span><span style=\"color:#E1E4E8\">{Scheme: scheme.Scheme})</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Expect</span><span style=\"color:#E1E4E8\">(err).</span><span style=\"color:#B392F0\">NotTo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">HaveOccurred</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Expect</span><span style=\"color:#E1E4E8\">(k8sClient).</span><span style=\"color:#B392F0\">NotTo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BeNil</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> AfterSuite</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    By</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"tearing down the test environment\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> testEnv.</span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Expect</span><span style=\"color:#E1E4E8\">(err).</span><span style=\"color:#B392F0\">NotTo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">HaveOccurred</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Test helper functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> CreateTestNamespace</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">corev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Namespace</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ns </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">corev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Namespace</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectMeta: </span><span style=\"color:#B392F0\">metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ObjectMeta</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            GenerateName: </span><span style=\"color:#9ECBFF\">\"test-\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Expect</span><span style=\"color:#E1E4E8\">(k8sClient.</span><span style=\"color:#B392F0\">Create</span><span style=\"color:#E1E4E8\">(ctx, ns)).</span><span style=\"color:#B392F0\">To</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Succeed</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ns</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> CreateTestDatabase</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">namespace</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">name</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">examplev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">examplev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ObjectMeta: </span><span style=\"color:#B392F0\">metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ObjectMeta</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Name:      name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Namespace: namespace,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Spec: </span><span style=\"color:#B392F0\">examplev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DatabaseSpec</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Replicas:    </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Version:     </span><span style=\"color:#9ECBFF\">\"13.0\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            StorageSize: </span><span style=\"color:#9ECBFF\">\"10Gi\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Expect</span><span style=\"color:#E1E4E8\">(k8sClient.</span><span style=\"color:#B392F0\">Create</span><span style=\"color:#E1E4E8\">(ctx, db)).</span><span style=\"color:#B392F0\">To</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Succeed</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> db</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-reconciliation-test-skeleton\">Core Reconciliation Test Skeleton</h4>\n<p>This skeleton provides the structure for comprehensive reconciliation testing:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// controllers/database_controller_test.go - Reconciliation test template</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> controllers</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    . </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/onsi/ginkgo/v2</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    . </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/onsi/gomega</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    corev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/core/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metav1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/apis/meta/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/client/fake</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    examplev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/example/database-operator/api/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Describe</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Database Controller\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        reconciler </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        namespace  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">corev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        database   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">examplev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    BeforeEach</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        namespace </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> CreateTestNamespace</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        reconciler </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Client: k8sClient,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Scheme: scheme.Scheme,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"When creating a new Database\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        BeforeEach</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            database </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> CreateTestDatabase</span><span style=\"color:#E1E4E8\">(namespace.Name, </span><span style=\"color:#9ECBFF\">\"test-db\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        It</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Should create owned resources successfully\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Call reconciler.Reconcile() with appropriate request</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Verify that Deployment and Service resources are created</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Check that owner references are set correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Validate that finalizers are added to the Database resource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Confirm that status conditions indicate successful creation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        It</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Should handle missing namespace gracefully\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Delete the namespace before reconciliation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Call reconciler.Reconcile() and expect appropriate error handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Verify that status conditions indicate the error state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Confirm that no owned resources are created in invalid state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"When updating an existing Database\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        BeforeEach</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            database </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> CreateTestDatabase</span><span style=\"color:#E1E4E8\">(namespace.Name, </span><span style=\"color:#9ECBFF\">\"test-db\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Wait for initial reconciliation to complete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Verify that owned resources exist and are ready</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        It</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Should propagate spec changes to owned resources\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Update database spec (e.g., change replica count)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Call reconciler.Reconcile() with update event</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Verify that owned Deployment reflects new replica count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Check that status indicates progressing state during update</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Confirm that ready condition updates after completion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        It</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Should detect and correct configuration drift\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Manually modify an owned resource (e.g., change Deployment image)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Call reconciler.Reconcile() to trigger drift detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Verify that controller restores correct configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Check that no unnecessary updates occur for correct resources</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Context</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"When deleting a Database\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        BeforeEach</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            database </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> CreateTestDatabase</span><span style=\"color:#E1E4E8\">(namespace.Name, </span><span style=\"color:#9ECBFF\">\"test-db\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Wait for reconciliation to create owned resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Set deletion timestamp on database resource</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        It</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Should clean up owned resources before finalizer removal\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Call reconciler.Reconcile() with deletion event</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Verify that owned resources are deleted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Check that finalizers remain until cleanup completes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Confirm finalizer removal after successful cleanup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        It</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Should handle cleanup failures gracefully\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Configure fake client to return errors for delete operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Call reconciler.Reconcile() and expect error result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Verify that finalizers are not removed on cleanup failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Check that status conditions indicate cleanup error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">})</span></span></code></pre></div>\n\n<h4 id=\"integration-testing-with-controller-manager\">Integration Testing with Controller Manager</h4>\n<p>This template demonstrates full integration testing with running controllers:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// controllers/integration_test.go - Full integration test template</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> controllers</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    . </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/onsi/ginkgo/v2</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    . </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/onsi/gomega</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    appsv1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/apps/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    corev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/core/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metav1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/apis/meta/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    examplev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/example/database-operator/api/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> Describe</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Database Integration\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mgr       </span><span style=\"color:#B392F0\">ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        namespace </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">corev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        database  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">examplev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    BeforeEach</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        var</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mgr, err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ctrl.</span><span style=\"color:#B392F0\">NewManager</span><span style=\"color:#E1E4E8\">(cfg, </span><span style=\"color:#B392F0\">ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Options</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Scheme: scheme.Scheme,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Port:   </span><span style=\"color:#79B8FF\">9443</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// webhook port</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Expect</span><span style=\"color:#E1E4E8\">(err).</span><span style=\"color:#B392F0\">ToNot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">HaveOccurred</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        reconciler </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Client: mgr.</span><span style=\"color:#B392F0\">GetClient</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Scheme: mgr.</span><span style=\"color:#B392F0\">GetScheme</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> reconciler.</span><span style=\"color:#B392F0\">SetupWithManager</span><span style=\"color:#E1E4E8\">(mgr)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Expect</span><span style=\"color:#E1E4E8\">(err).</span><span style=\"color:#B392F0\">ToNot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">HaveOccurred</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">        go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            defer</span><span style=\"color:#B392F0\"> GinkgoRecover</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mgr.</span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">(ctx)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            Expect</span><span style=\"color:#E1E4E8\">(err).</span><span style=\"color:#B392F0\">ToNot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">HaveOccurred</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#9ECBFF\">\"failed to run manager\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        namespace </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> CreateTestNamespace</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    It</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Should reconcile Database resources end-to-end\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        By</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Creating a Database resource\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        database </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">examplev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ObjectMeta: </span><span style=\"color:#B392F0\">metav1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ObjectMeta</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Name:      </span><span style=\"color:#9ECBFF\">\"integration-test-db\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Namespace: namespace.Name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Spec: </span><span style=\"color:#B392F0\">examplev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DatabaseSpec</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Replicas:    </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Version:     </span><span style=\"color:#9ECBFF\">\"13.0\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                StorageSize: </span><span style=\"color:#9ECBFF\">\"5Gi\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Expect</span><span style=\"color:#E1E4E8\">(k8sClient.</span><span style=\"color:#B392F0\">Create</span><span style=\"color:#E1E4E8\">(ctx, database)).</span><span style=\"color:#B392F0\">To</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Succeed</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        By</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Waiting for owned resources to be created\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        deployment </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">appsv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Deployment</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Eventually</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> k8sClient.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NamespacedName</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Name:      database.Name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Namespace: database.Namespace,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }, deployment)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }, time.Minute, time.Second).</span><span style=\"color:#B392F0\">Should</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Succeed</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        By</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Verifying Deployment configuration\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Expect</span><span style=\"color:#E1E4E8\">(deployment.Spec.Replicas).</span><span style=\"color:#B392F0\">To</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">int32Ptr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Expect</span><span style=\"color:#E1E4E8\">(deployment.OwnerReferences).</span><span style=\"color:#B392F0\">To</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">HaveLen</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Expect</span><span style=\"color:#E1E4E8\">(deployment.OwnerReferences[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].Name).</span><span style=\"color:#B392F0\">To</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(database.Name))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        By</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Waiting for Database status to indicate readiness\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        Eventually</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> k8sClient.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NamespacedName</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Name:      database.Name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                Namespace: database.Namespace,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }, database)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> database.Status.Phase </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"Ready\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }, time.Minute, time.Second).</span><span style=\"color:#B392F0\">Should</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BeTrue</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> int32Ptr</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">i</span><span style=\"color:#F97583\"> int32</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*int32</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">i</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"webhook-testing-infrastructure\">Webhook Testing Infrastructure</h4>\n<p>This infrastructure enables comprehensive webhook testing:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// webhooks/webhook_suite_test.go - Webhook testing setup</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> webhooks</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/tls</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">path/filepath</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    . </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/onsi/ginkgo/v2</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    . </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/onsi/gomega</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    admissionv1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/admission/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metav1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/apis/meta/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/client-go/kubernetes/scheme</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctrl </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/client</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/envtest</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/webhook</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/webhook/admission</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    examplev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/example/database-operator/api/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    k8sClient </span><span style=\"color:#B392F0\">client</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    testEnv   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">envtest</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Environment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx       </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cancel    </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CancelFunc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestWebhooks</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    RegisterFailHandler</span><span style=\"color:#E1E4E8\">(Fail)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    RunSpecs</span><span style=\"color:#E1E4E8\">(t, </span><span style=\"color:#9ECBFF\">\"Webhook Suite\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> BeforeSuite</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx, cancel </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithCancel</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    By</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"bootstrapping test environment\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    testEnv </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">envtest</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Environment</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CRDDirectoryPaths:     []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"..\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"config\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"crd\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"bases\"</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ErrorIfCRDPathMissing: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        WebhookInstallOptions: </span><span style=\"color:#B392F0\">envtest</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">WebhookInstallOptions</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Paths: []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{filepath.</span><span style=\"color:#B392F0\">Join</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"..\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"config\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"webhook\"</span><span style=\"color:#E1E4E8\">)},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cfg, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> testEnv.</span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Expect</span><span style=\"color:#E1E4E8\">(err).</span><span style=\"color:#B392F0\">NotTo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">HaveOccurred</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Expect</span><span style=\"color:#E1E4E8\">(cfg).</span><span style=\"color:#B392F0\">NotTo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BeNil</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> examplev1.</span><span style=\"color:#B392F0\">AddToScheme</span><span style=\"color:#E1E4E8\">(scheme.Scheme)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Expect</span><span style=\"color:#E1E4E8\">(err).</span><span style=\"color:#B392F0\">NotTo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">HaveOccurred</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    k8sClient, err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> client.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(cfg, </span><span style=\"color:#B392F0\">client</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Options</span><span style=\"color:#E1E4E8\">{Scheme: scheme.Scheme})</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Expect</span><span style=\"color:#E1E4E8\">(err).</span><span style=\"color:#B392F0\">NotTo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">HaveOccurred</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start webhook server</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    webhookInstallOptions </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">testEnv.WebhookInstallOptions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mgr, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ctrl.</span><span style=\"color:#B392F0\">NewManager</span><span style=\"color:#E1E4E8\">(cfg, </span><span style=\"color:#B392F0\">ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Options</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Scheme:             scheme.Scheme,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Host:               webhookInstallOptions.LocalServingHost,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Port:               webhookInstallOptions.LocalServingPort,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CertDir:            webhookInstallOptions.LocalServingCertDir,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LeaderElection:     </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        MetricsBindAddress: </span><span style=\"color:#9ECBFF\">\"0\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Expect</span><span style=\"color:#E1E4E8\">(err).</span><span style=\"color:#B392F0\">NotTo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">HaveOccurred</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Setup webhook handlers with manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Start manager in goroutine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> AfterSuite</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    cancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    By</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"tearing down the test environment\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> testEnv.</span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Expect</span><span style=\"color:#E1E4E8\">(err).</span><span style=\"color:#B392F0\">NotTo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">HaveOccurred</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">})</span></span></code></pre></div>\n\n<h4 id=\"milestone-validation-checkpoints\">Milestone Validation Checkpoints</h4>\n<p>Each milestone includes specific commands and expected outputs for validation:</p>\n<p><strong>Milestone 1 Checkpoint Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Verify CRD installation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> crd</span><span style=\"color:#9ECBFF\"> databases.example.com</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> yaml</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test schema validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> testdata/invalid-database.yaml</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: validation error with specific field requirements</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test status subresource</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> patch</span><span style=\"color:#9ECBFF\"> database</span><span style=\"color:#9ECBFF\"> test-db</span><span style=\"color:#79B8FF\"> --subresource=status</span><span style=\"color:#79B8FF\"> --type=merge</span><span style=\"color:#79B8FF\"> -p=</span><span style=\"color:#9ECBFF\">'{\"status\":{\"phase\":\"Testing\"}}'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: status updated without spec generation increment</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Checkpoint Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start controller with debug logging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> ./cmd/main.go</span><span style=\"color:#79B8FF\"> --zap-log-level=debug</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create test resource and watch logs</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> testdata/valid-database.yaml</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: reconciliation request logged within 5 seconds</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test concurrent processing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..10}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span><span style=\"color:#B392F0\"> kubectl</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> testdata/database-</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">.yaml</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: multiple concurrent reconciliation logs</span></span></code></pre></div>\n\n<p><strong>Language-Specific Testing Hints:</strong></p>\n<ul>\n<li>Use <code>testify/suite</code> for complex test setup with BeforeTest/AfterTest hooks</li>\n<li>Leverage <code>t.Parallel()</code> for unit tests that don&#39;t share state</li>\n<li>Use <code>go test -race</code> to detect race conditions in controller code</li>\n<li>Configure <code>KUBEBUILDER_ASSETS</code> environment variable for envtest binary location</li>\n<li>Use <code>Eventually()</code> and <code>Consistently()</code> from Gomega for asynchronous assertions</li>\n<li>Mock external dependencies using <code>testify/mock</code> or <code>counterfeiter</code></li>\n<li>Use <code>t.Helper()</code> in test utility functions to improve error reporting</li>\n<li>Configure test timeouts appropriately: unit tests 10s, integration tests 60s</li>\n</ul>\n<p><strong>Common Debugging Scenarios:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unit tests panic with &quot;no kind is registered&quot;</td>\n<td>Missing scheme registration</td>\n<td>Check fake client scheme setup</td>\n<td>Add all CRDs to scheme.Scheme</td>\n</tr>\n<tr>\n<td>Integration tests timeout waiting for resources</td>\n<td>Controller not running or not watching</td>\n<td>Check manager startup and controller registration</td>\n<td>Verify SetupWithManager() call</td>\n</tr>\n<tr>\n<td>Webhook tests fail with certificate errors</td>\n<td>TLS configuration incorrect</td>\n<td>Check certificate paths and validity</td>\n<td>Regenerate test certificates</td>\n</tr>\n<tr>\n<td>Tests pass individually but fail in suite</td>\n<td>Resource cleanup between tests</td>\n<td>Check for resource leakage</td>\n<td>Add proper cleanup in AfterEach</td>\n</tr>\n<tr>\n<td>Flaky test failures in CI</td>\n<td>Race conditions or insufficient timeouts</td>\n<td>Increase timeout values and add synchronization</td>\n<td>Use Eventually() with longer durations</td>\n</tr>\n</tbody></table>\n<h2 id=\"deployment-and-operations\">Deployment and Operations</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 5 (Testing &amp; Deployment) - covers packaging the operator as container images, RBAC configuration, and production deployment strategies</p>\n</blockquote>\n<p>Moving a Kubernetes operator from development to production requires careful attention to security, packaging, and operational concerns. Think of deploying an operator like installing a new resident admin in your apartment building - they need the right keys (RBAC permissions), their own secure apartment (container packaging), and a backup admin available if they get sick (high availability). Unlike regular applications that just process requests, operators have elevated privileges to manage cluster resources, making security and reliability critical considerations.</p>\n<p>The deployment phase transforms your operator from a development artifact into a production-ready service that can safely manage workloads at scale. This involves three key challenges: ensuring the operator has exactly the permissions it needs and no more (RBAC), packaging it as a container with proper configuration management (container packaging), and ensuring it remains available even during node failures or rolling updates (high availability).</p>\n<p><img src=\"/api/project/kubernetes-operator/architecture-doc/asset?path=diagrams%2Fdeployment-architecture.svg\" alt=\"Production Deployment Architecture\"></p>\n<h3 id=\"rbac-and-security-model\">RBAC and Security Model</h3>\n<p><strong>Mental Model: The Building Superintendent&#39;s Keys</strong></p>\n<p>Think of Kubernetes RBAC like a building superintendent&#39;s key ring. A good superintendent has keys to common areas (cluster-scoped resources) and individual apartments they manage (namespace-scoped resources), but they don&#39;t have keys to the bank vault next door (unrelated cluster resources) or other buildings entirely (other clusters). Each key serves a specific purpose, and losing or misusing any key has clear consequences. Your operator needs exactly the right keys to do its job effectively without creating security risks.</p>\n<p>The <strong>principle of least privilege</strong> governs operator RBAC design. Rather than granting broad permissions like <code>cluster-admin</code>, operators should receive only the specific permissions required for their reconciliation logic. This approach limits the blast radius if the operator is compromised and makes security auditing more straightforward.</p>\n<blockquote>\n<p><strong>Decision: Namespace-Scoped vs Cluster-Scoped Permissions</strong></p>\n<ul>\n<li><strong>Context</strong>: Operators can be deployed with cluster-wide permissions or restricted to specific namespaces</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Cluster-scoped with ClusterRole and ClusterRoleBinding</li>\n<li>Namespace-scoped with Role and RoleBinding</li>\n<li>Hybrid approach with multiple permission levels</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Start with namespace-scoped permissions and escalate to cluster-scoped only when required</li>\n<li><strong>Rationale</strong>: Namespace-scoped permissions provide better security isolation, easier multi-tenancy, and clearer audit trails. Many operators only need to manage resources within specific namespaces.</li>\n<li><strong>Consequences</strong>: Requires more complex permission modeling for cross-namespace operations but provides stronger security boundaries</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Permission Scope</th>\n<th>Resource Types</th>\n<th>Use Cases</th>\n<th>Security Trade-offs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cluster-scoped</td>\n<td>ClusterRole, ClusterRoleBinding, CRDs</td>\n<td>Managing cluster-wide resources, cross-namespace operations</td>\n<td>Broad permissions, single point of failure, harder to audit</td>\n</tr>\n<tr>\n<td>Namespace-scoped</td>\n<td>Role, RoleBinding within target namespaces</td>\n<td>Application-specific operators, multi-tenant environments</td>\n<td>Limited blast radius, easier isolation, more complex setup</td>\n</tr>\n<tr>\n<td>Hybrid</td>\n<td>Multiple roles with different scopes</td>\n<td>Operators managing both namespace and cluster resources</td>\n<td>Balanced approach, requires careful permission design</td>\n</tr>\n</tbody></table>\n<p>The <code>DatabaseReconciler</code> requires specific permissions to manage its custom resources and owned Kubernetes resources. These permissions are defined through a combination of RBAC resources that work together to grant the operator&#39;s ServiceAccount the necessary access.</p>\n<table>\n<thead>\n<tr>\n<th>RBAC Component</th>\n<th>Purpose</th>\n<th>Scope</th>\n<th>Example Resource</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ServiceAccount</td>\n<td>Identity for operator pods</td>\n<td>Namespace</td>\n<td><code>database-operator-service-account</code></td>\n</tr>\n<tr>\n<td>Role/ClusterRole</td>\n<td>Permission definitions</td>\n<td>Namespace/Cluster</td>\n<td>Rules for Database CRD, Secrets, Services</td>\n</tr>\n<tr>\n<td>RoleBinding/ClusterRoleBinding</td>\n<td>Links ServiceAccount to permissions</td>\n<td>Namespace/Cluster</td>\n<td>Grants operator ServiceAccount the defined roles</td>\n</tr>\n</tbody></table>\n<h4 id=\"core-permission-requirements\">Core Permission Requirements</h4>\n<p>The <code>DatabaseReconciler</code> needs specific permissions to perform its reconciliation duties. These permissions should be carefully scoped to prevent privilege escalation while enabling full operator functionality.</p>\n<table>\n<thead>\n<tr>\n<th>Resource Type</th>\n<th>Operations Needed</th>\n<th>Justification</th>\n<th>Example Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>databases.example.com</code></td>\n<td>get, list, watch, update, patch</td>\n<td>Monitor custom resources and update status</td>\n<td>Watch Database resource changes, update status subresource</td>\n</tr>\n<tr>\n<td><code>secrets</code></td>\n<td>get, list, watch, create, update, patch, delete</td>\n<td>Manage database credentials and TLS certificates</td>\n<td>Create admin passwords, manage backup encryption keys</td>\n</tr>\n<tr>\n<td><code>services</code></td>\n<td>get, list, watch, create, update, patch, delete</td>\n<td>Expose database instances</td>\n<td>Create ClusterIP services for database connectivity</td>\n</tr>\n<tr>\n<td><code>deployments</code></td>\n<td>get, list, watch, create, update, patch, delete</td>\n<td>Manage database workloads</td>\n<td>Deploy database pods with specified replica counts</td>\n</tr>\n<tr>\n<td><code>persistentvolumeclaims</code></td>\n<td>get, list, watch, create, update, patch, delete</td>\n<td>Manage database storage</td>\n<td>Provision storage volumes for database data</td>\n</tr>\n<tr>\n<td><code>configmaps</code></td>\n<td>get, list, watch, create, update, patch, delete</td>\n<td>Manage database configuration</td>\n<td>Store database config files, backup scripts</td>\n</tr>\n<tr>\n<td><code>events</code></td>\n<td>create, patch</td>\n<td>Record operator activities</td>\n<td>Log reconciliation events for debugging</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The critical insight here is that every permission must map to a specific reconciliation action. If you cannot explain why the operator needs a particular permission by pointing to specific reconciliation logic, that permission should be removed.</p>\n</blockquote>\n<h4 id=\"owner-references-and-garbage-collection\">Owner References and Garbage Collection</h4>\n<p>Owner references establish parent-child relationships between custom resources and their managed Kubernetes resources. This mechanism enables automatic garbage collection when custom resources are deleted, reducing the operator&#39;s cleanup burden and preventing resource leaks.</p>\n<table>\n<thead>\n<tr>\n<th>Owner Reference Field</th>\n<th>Purpose</th>\n<th>Example Value</th>\n<th>Behavior on Deletion</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>apiVersion</code></td>\n<td>API version of parent resource</td>\n<td><code>example.com/v1</code></td>\n<td>Links to specific API version</td>\n</tr>\n<tr>\n<td><code>kind</code></td>\n<td>Resource type of parent</td>\n<td><code>Database</code></td>\n<td>Identifies parent resource type</td>\n</tr>\n<tr>\n<td><code>name</code></td>\n<td>Name of parent resource</td>\n<td><code>production-postgres</code></td>\n<td>Links to specific resource instance</td>\n</tr>\n<tr>\n<td><code>uid</code></td>\n<td>Unique identifier of parent</td>\n<td><code>abc123-def456-...</code></td>\n<td>Ensures precise parent identification</td>\n</tr>\n<tr>\n<td><code>controller</code></td>\n<td>Indicates controlling owner</td>\n<td><code>true</code></td>\n<td>Triggers cascading deletion</td>\n</tr>\n<tr>\n<td><code>blockOwnerDeletion</code></td>\n<td>Blocks parent deletion until child is removed</td>\n<td><code>false</code></td>\n<td>Allows graceful cleanup ordering</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Missing Owner References Leading to Resource Leaks</strong></p>\n<p>Forgetting to set owner references on managed resources causes them to persist after the custom resource is deleted. This creates orphaned resources that consume cluster capacity and complicate cleanup. Always set owner references when creating managed resources, and verify garbage collection behavior in your tests.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// WRONG: Creating resource without owner reference</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">service </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">corev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Service</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.Client.</span><span style=\"color:#B392F0\">Create</span><span style=\"color:#E1E4E8\">(ctx, service)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CORRECT: Setting owner reference for garbage collection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">service </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">corev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Service</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#F97583\">...</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ctrl.</span><span style=\"color:#B392F0\">SetControllerReference</span><span style=\"color:#E1E4E8\">(database, service, r.Scheme)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">{}, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> r.Client.</span><span style=\"color:#B392F0\">Create</span><span style=\"color:#E1E4E8\">(ctx, service)</span></span></code></pre></div>\n\n<h4 id=\"webhook-rbac-requirements\">Webhook RBAC Requirements</h4>\n<p>Admission webhooks require additional RBAC permissions beyond the controller&#39;s reconciliation needs. These permissions enable webhook registration, certificate management, and admission review processing.</p>\n<table>\n<thead>\n<tr>\n<th>Webhook Component</th>\n<th>Required Permissions</th>\n<th>Resource Types</th>\n<th>Justification</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ValidatingAdmissionWebhook registration</td>\n<td>create, update, patch</td>\n<td><code>validatingadmissionwebhooks.admissionregistration.k8s.io</code></td>\n<td>Register webhook with API server</td>\n</tr>\n<tr>\n<td>MutatingAdmissionWebhook registration</td>\n<td>create, update, patch</td>\n<td><code>mutatingadmissionwebhooks.admissionregistration.k8s.io</code></td>\n<td>Register webhook with API server</td>\n</tr>\n<tr>\n<td>Certificate management</td>\n<td>get, list, watch, create, update</td>\n<td><code>secrets</code> (for TLS certificates)</td>\n<td>Manage webhook TLS certificates</td>\n</tr>\n<tr>\n<td>Service management</td>\n<td>get, list, watch, create, update</td>\n<td><code>services</code> (for webhook endpoints)</td>\n<td>Expose webhook HTTPS endpoints</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Webhook Certificate Management Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Webhooks require TLS certificates for HTTPS communication with the API server</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Self-signed certificates generated at startup</li>\n<li>cert-manager for automatic certificate lifecycle management</li>\n<li>External certificate authority with manual certificate provision</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use cert-manager for production deployments with self-signed fallback for development</li>\n<li><strong>Rationale</strong>: cert-manager provides automatic renewal, proper CA trust chains, and integrates well with Kubernetes RBAC. Self-signed certificates work for development but require manual rotation in production.</li>\n<li><strong>Consequences</strong>: Adds cert-manager dependency but eliminates certificate management toil and reduces security risks from expired certificates</li>\n</ul>\n</blockquote>\n<h3 id=\"container-packaging-and-deployment\">Container Packaging and Deployment</h3>\n<p><strong>Mental Model: The Shipping Container</strong></p>\n<p>Think of packaging your operator like preparing a shipping container for international transport. The container must be self-contained with all dependencies included, properly labeled with version and contents, and standardized so it runs the same way whether deployed in development, staging, or production. Like shipping containers, operator images should be immutable, versioned, and contain everything needed to run in any compliant Kubernetes cluster.</p>\n<p>Container packaging transforms your operator from source code into a deployable artifact that can be distributed, versioned, and deployed consistently across environments. This process involves building container images, organizing deployment manifests, and creating configuration management systems that handle environment-specific variations.</p>\n<h4 id=\"container-image-strategy\">Container Image Strategy</h4>\n<p>The operator container image serves as the fundamental deployment unit, containing the compiled binary, runtime dependencies, and configuration templates. Image design affects security, deployment speed, and operational complexity.</p>\n<table>\n<thead>\n<tr>\n<th>Image Characteristic</th>\n<th>Development Approach</th>\n<th>Production Approach</th>\n<th>Trade-offs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Base image</td>\n<td>Full OS (ubuntu, centos)</td>\n<td>Minimal (alpine, distroless)</td>\n<td>Debug tools vs. attack surface</td>\n</tr>\n<tr>\n<td>Binary packaging</td>\n<td>Debug builds with symbols</td>\n<td>Optimized builds stripped</td>\n<td>Debugging capability vs. image size</td>\n</tr>\n<tr>\n<td>Dependency management</td>\n<td>Package manager installs</td>\n<td>Multi-stage builds</td>\n<td>Build simplicity vs. reproducibility</td>\n</tr>\n<tr>\n<td>User permissions</td>\n<td>Root user</td>\n<td>Non-root user</td>\n<td>Convenience vs. security</td>\n</tr>\n<tr>\n<td>Layer optimization</td>\n<td>Single layer builds</td>\n<td>Multi-stage with layer caching</td>\n<td>Build speed vs. image efficiency</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Multi-Stage Build with Distroless Base Image</strong></p>\n<ul>\n<li><strong>Context</strong>: Operator images need to be secure, small, and fast to deploy while containing all required dependencies</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Single-stage build with full OS base image</li>\n<li>Multi-stage build with minimal base image</li>\n<li>Scratch base image with static binary</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Multi-stage build with Google&#39;s distroless base image</li>\n<li><strong>Rationale</strong>: Distroless images contain only the application and runtime dependencies, reducing attack surface while maintaining compatibility. Multi-stage builds separate build dependencies from runtime dependencies.</li>\n<li><strong>Consequences</strong>: Smaller image size, improved security posture, but more complex Dockerfile and potential debugging challenges</li>\n</ul>\n</blockquote>\n<p>The operator container requires careful dependency management to ensure consistent behavior across environments. All required certificates, configuration schemas, and runtime dependencies must be included in the image or mounted at runtime.</p>\n<table>\n<thead>\n<tr>\n<th>Container Component</th>\n<th>Purpose</th>\n<th>Location</th>\n<th>Management Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Operator binary</td>\n<td>Main application executable</td>\n<td><code>/usr/local/bin/operator</code></td>\n<td>Compiled during image build</td>\n</tr>\n<tr>\n<td>CA certificates</td>\n<td>TLS certificate validation</td>\n<td><code>/etc/ssl/certs/</code></td>\n<td>Included in base image or mounted</td>\n</tr>\n<tr>\n<td>CRD schemas</td>\n<td>OpenAPI validation schemas</td>\n<td><code>/etc/operator/crds/</code></td>\n<td>Embedded in image or mounted as ConfigMap</td>\n</tr>\n<tr>\n<td>Default configurations</td>\n<td>Fallback operator settings</td>\n<td><code>/etc/operator/config/</code></td>\n<td>Embedded with environment variable overrides</td>\n</tr>\n<tr>\n<td>Health check scripts</td>\n<td>Liveness and readiness probes</td>\n<td><code>/usr/local/bin/health</code></td>\n<td>Embedded shell scripts or HTTP endpoints</td>\n</tr>\n</tbody></table>\n<h4 id=\"helm-chart-organization\">Helm Chart Organization</h4>\n<p>Helm charts provide templating and configuration management for operator deployments, enabling environment-specific customization while maintaining consistency across clusters. Chart organization affects maintainability, user experience, and upgrade reliability.</p>\n<table>\n<thead>\n<tr>\n<th>Chart Component</th>\n<th>Purpose</th>\n<th>Template Location</th>\n<th>Configuration Source</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Deployment</td>\n<td>Operator pod specification</td>\n<td><code>templates/deployment.yaml</code></td>\n<td><code>values.yaml</code> replicas, image, resources</td>\n</tr>\n<tr>\n<td>RBAC resources</td>\n<td>ServiceAccount, Role, RoleBinding</td>\n<td><code>templates/rbac.yaml</code></td>\n<td><code>values.yaml</code> rbac.create, serviceAccount.name</td>\n</tr>\n<tr>\n<td>CRD definitions</td>\n<td>Custom resource schemas</td>\n<td><code>templates/crds/</code></td>\n<td>Static files or <code>values.yaml</code> schema overrides</td>\n</tr>\n<tr>\n<td>Webhook configuration</td>\n<td>AdmissionWebhook registration</td>\n<td><code>templates/webhooks.yaml</code></td>\n<td><code>values.yaml</code> webhook.enabled, certificate settings</td>\n</tr>\n<tr>\n<td>Service definitions</td>\n<td>Webhook and metrics endpoints</td>\n<td><code>templates/services.yaml</code></td>\n<td><code>values.yaml</code> service ports and types</td>\n</tr>\n<tr>\n<td>ConfigMap resources</td>\n<td>Operator configuration</td>\n<td><code>templates/configmap.yaml</code></td>\n<td><code>values.yaml</code> config section</td>\n</tr>\n</tbody></table>\n<p>The Helm chart must handle upgrade scenarios gracefully, particularly when CRD schemas change or when webhook configurations are modified. CRD upgrades require special attention because Helm cannot handle CRD lifecycle management automatically.</p>\n<table>\n<thead>\n<tr>\n<th>Upgrade Scenario</th>\n<th>Challenge</th>\n<th>Helm Solution</th>\n<th>Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CRD schema changes</td>\n<td>Helm doesn&#39;t update CRDs automatically</td>\n<td><code>crds/</code> directory for install-only, hooks for updates</td>\n<td>May require manual <code>kubectl apply</code> for CRD updates</td>\n</tr>\n<tr>\n<td>Webhook endpoint changes</td>\n<td>API server caches webhook configuration</td>\n<td>Rolling update with readiness probes</td>\n<td>Temporary admission failures during rollout</td>\n</tr>\n<tr>\n<td>RBAC permission changes</td>\n<td>Existing pods use old ServiceAccount tokens</td>\n<td>Restart operator pods after RBAC update</td>\n<td>Plan for brief reconciliation pause</td>\n</tr>\n<tr>\n<td>Image updates</td>\n<td>Container registry authentication</td>\n<td>imagePullSecrets configuration</td>\n<td>Ensure registry access before update</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Separate CRD Management from Operator Lifecycle</strong></p>\n<ul>\n<li><strong>Context</strong>: CRDs have different lifecycle requirements than the operator deployment, particularly around upgrades and versioning</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Include CRDs in Helm chart templates/ directory</li>\n<li>Use Helm CRDs/ directory for install-only management</li>\n<li>Separate CRD management with dedicated tooling</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use Helm crds/ directory for installation with separate CRD upgrade procedures</li>\n<li><strong>Rationale</strong>: Helm&#39;s CRD handling has limitations around updates, but storing CRDs in the chart ensures they&#39;re installed with the operator. Separate upgrade procedures provide better control.</li>\n<li><strong>Consequences</strong>: Requires documented CRD upgrade procedures and coordination between chart updates and CRD changes</li>\n</ul>\n</blockquote>\n<h4 id=\"environment-configuration-management\">Environment Configuration Management</h4>\n<p>Operators must adapt to different environments (development, staging, production) without requiring image rebuilds. Configuration management strategies affect operational complexity, security, and deployment reliability.</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Source</th>\n<th>Use Cases</th>\n<th>Examples</th>\n<th>Security Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Environment variables</td>\n<td>Simple runtime settings</td>\n<td>Log levels, feature flags, timeouts</td>\n<td>Visible in pod specifications and process lists</td>\n</tr>\n<tr>\n<td>ConfigMaps</td>\n<td>Structured configuration files</td>\n<td>JSON/YAML configs, template files</td>\n<td>Visible to users with ConfigMap read permissions</td>\n</tr>\n<tr>\n<td>Secrets</td>\n<td>Sensitive configuration</td>\n<td>Database passwords, API keys, certificates</td>\n<td>Encrypted at rest, base64 encoded in transit</td>\n</tr>\n<tr>\n<td>Command-line flags</td>\n<td>Override settings</td>\n<td>Debug modes, alternative config paths</td>\n<td>Visible in process arguments and pod specs</td>\n</tr>\n<tr>\n<td>File mounts</td>\n<td>Large configuration files</td>\n<td>Custom CRD schemas, policy definitions</td>\n<td>Requires volume management and file watching</td>\n</tr>\n</tbody></table>\n<p>Configuration precedence establishes clear override behavior when multiple sources provide the same setting. A well-defined precedence order prevents configuration conflicts and enables predictable behavior across environments.</p>\n<table>\n<thead>\n<tr>\n<th>Precedence Level</th>\n<th>Configuration Source</th>\n<th>Override Scope</th>\n<th>Example Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1 (Highest)</td>\n<td>Command-line flags</td>\n<td>Specific settings for debugging or testing</td>\n<td><code>--log-level=debug</code> for development environments</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Environment variables</td>\n<td>Runtime overrides for deployment-specific settings</td>\n<td><code>RECONCILE_TIMEOUT=30s</code> for slower clusters</td>\n</tr>\n<tr>\n<td>3</td>\n<td>ConfigMap mounted files</td>\n<td>Environment-specific structured configuration</td>\n<td>Different resource limits per environment</td>\n</tr>\n<tr>\n<td>4 (Lowest)</td>\n<td>Built-in defaults</td>\n<td>Fallback values when no override is provided</td>\n<td>Default replica counts, timeout values</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Sensitive Information in Environment Variables</strong></p>\n<p>Avoid passing sensitive information like passwords or API keys through environment variables, as they&#39;re visible in pod specifications, process lists, and kubectl describe output. Use Kubernetes Secrets with volume mounts or the Secrets API instead.</p>\n<h3 id=\"high-availability-and-leader-election\">High Availability and Leader Election</h3>\n<p><strong>Mental Model: The Night Shift Manager System</strong></p>\n<p>Think of leader election like managing night shift supervisors at a 24/7 factory. You need multiple qualified supervisors available (multiple operator replicas), but only one should be actively making decisions at any time (leader election). If the active supervisor has an emergency and can&#39;t continue (pod failure), another supervisor should immediately take over (leadership transfer) without missing any critical tasks (reconciliation continuity). The transition should be seamless to workers on the factory floor (managed resources).</p>\n<p>High availability ensures your operator continues managing workloads even during node failures, rolling updates, or unexpected crashes. Unlike stateless applications where you can simply run multiple replicas behind a load balancer, operators require coordination to prevent multiple controllers from conflicting with each other while reconciling the same resources.</p>\n<h4 id=\"leader-election-mechanics\">Leader Election Mechanics</h4>\n<p>Leader election coordinates multiple operator replicas to ensure only one actively reconciles resources at any time. This coordination prevents race conditions, conflicting updates, and split-brain scenarios where multiple controllers attempt to manage the same resources simultaneously.</p>\n<table>\n<thead>\n<tr>\n<th>Election Component</th>\n<th>Purpose</th>\n<th>Storage Location</th>\n<th>Update Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Lock resource</td>\n<td>Stores current leader identity and lease information</td>\n<td>ConfigMap or Lease resource</td>\n<td>Atomic updates with resource version checking</td>\n</tr>\n<tr>\n<td>Leader identity</td>\n<td>Identifies which replica currently holds the lock</td>\n<td>Lock resource annotations</td>\n<td>Pod name and namespace for leader identification</td>\n</tr>\n<tr>\n<td>Lease duration</td>\n<td>How long a leader can hold the lock without renewal</td>\n<td>Lock resource spec</td>\n<td>Configurable, typically 15-30 seconds</td>\n</tr>\n<tr>\n<td>Renew deadline</td>\n<td>How often the leader must update the lock</td>\n<td>Controller configuration</td>\n<td>Typically lease duration / 3</td>\n</tr>\n<tr>\n<td>Retry period</td>\n<td>How often non-leaders check for lock availability</td>\n<td>Controller configuration</td>\n<td>Typically renew deadline / 2</td>\n</tr>\n</tbody></table>\n<p>The leader election algorithm follows a simple but robust protocol that handles network partitions, process crashes, and clock skew gracefully. Understanding this protocol helps debug leadership issues and tune performance for different cluster characteristics.</p>\n<table>\n<thead>\n<tr>\n<th>Election State</th>\n<th>Replica Behavior</th>\n<th>Lock Resource Action</th>\n<th>Transition Conditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Startup</td>\n<td>Attempt to acquire lock</td>\n<td>Read current lock, try to claim if expired</td>\n<td>Becomes leader if successful, follower if failed</td>\n</tr>\n<tr>\n<td>Leader</td>\n<td>Continuously renew lock, perform reconciliation</td>\n<td>Update lock resource within renew deadline</td>\n<td>Becomes follower if renewal fails</td>\n</tr>\n<tr>\n<td>Follower</td>\n<td>Watch lock status, attempt takeover if leader fails</td>\n<td>Periodically check lock expiration</td>\n<td>Becomes leader if lock expires and successfully claimed</td>\n</tr>\n<tr>\n<td>Takeover</td>\n<td>Attempting to claim expired lock</td>\n<td>Atomic update with resource version check</td>\n<td>Becomes leader if successful, remains follower if conflict</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The critical insight here is that leader election provides coordination, not load balancing. Only one replica does the work while others remain on standby, unlike horizontally scaled stateless applications.</p>\n</blockquote>\n<h4 id=\"leader-election-configuration\">Leader Election Configuration</h4>\n<p>Proper leader election configuration balances failover speed against cluster load and stability. Aggressive timers provide faster failover but increase API server load and susceptibility to network glitches.</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Parameter</th>\n<th>Conservative Setting</th>\n<th>Aggressive Setting</th>\n<th>Trade-offs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Lease duration</td>\n<td>60 seconds</td>\n<td>15 seconds</td>\n<td>Failover speed vs. stability during network issues</td>\n</tr>\n<tr>\n<td>Renew deadline</td>\n<td>20 seconds</td>\n<td>5 seconds</td>\n<td>Leader renewal frequency vs. API server load</td>\n</tr>\n<tr>\n<td>Retry period</td>\n<td>10 seconds</td>\n<td>2 seconds</td>\n<td>Lock acquisition speed vs. election overhead</td>\n</tr>\n<tr>\n<td>Lock resource type</td>\n<td>ConfigMap</td>\n<td>Lease</td>\n<td>API server compatibility vs. semantic clarity</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Lease Resources with 15-Second Lease Duration</strong></p>\n<ul>\n<li><strong>Context</strong>: Leader election requires storage for coordination data and appropriate timing for failover scenarios</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>ConfigMap with 60-second lease duration for conservative failover</li>\n<li>Lease resource with 15-second lease duration for faster failover</li>\n<li>Custom resource for lock storage with application-specific timing</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use Kubernetes Lease resources with 15-second lease duration</li>\n<li><strong>Rationale</strong>: Lease resources are designed specifically for leader election, reducing semantic confusion. 15-second duration provides reasonable failover speed without excessive API server load.</li>\n<li><strong>Consequences</strong>: Requires Kubernetes 1.14+ for Lease API availability, but provides optimal balance of failover speed and stability</li>\n</ul>\n</blockquote>\n<h4 id=\"failover-and-recovery-behavior\">Failover and Recovery Behavior</h4>\n<p>When leadership changes occur, the operator must handle the transition gracefully to maintain reconciliation continuity. Both outgoing and incoming leaders have responsibilities during the transition period.</p>\n<table>\n<thead>\n<tr>\n<th>Failover Scenario</th>\n<th>Detection Mechanism</th>\n<th>Recovery Actions</th>\n<th>Expected Downtime</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Graceful shutdown</td>\n<td>Leader releases lock before termination</td>\n<td>Immediate lock release, follower takeover</td>\n<td>0-2 retry periods</td>\n</tr>\n<tr>\n<td>Process crash</td>\n<td>Lock renewal timeout</td>\n<td>Automatic lock expiration, follower takeover</td>\n<td>1 lease duration + retry period</td>\n</tr>\n<tr>\n<td>Network partition</td>\n<td>Leader cannot reach API server for renewal</td>\n<td>Lock expires, follower on connected side takes over</td>\n<td>1 lease duration + retry period</td>\n</tr>\n<tr>\n<td>Node failure</td>\n<td>Lock renewal timeout + pod rescheduling</td>\n<td>Lock expiration, new pod startup, leadership claim</td>\n<td>Pod scheduling time + lease duration</td>\n</tr>\n</tbody></table>\n<p>The operator must handle leadership transitions without losing reconciliation state or creating resource conflicts. This requires careful design of the reconciliation loop and state management.</p>\n<table>\n<thead>\n<tr>\n<th>Transition Phase</th>\n<th>Leader Responsibilities</th>\n<th>Follower Responsibilities</th>\n<th>State Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Leadership loss</td>\n<td>Stop reconciliation immediately, release in-flight operations</td>\n<td>Monitor lock status, prepare for takeover</td>\n<td>Avoid partial updates that could conflict</td>\n</tr>\n<tr>\n<td>Leadership acquisition</td>\n<td>Start reconciliation loop, scan for pending work</td>\n<td>Continue monitoring for future leadership opportunities</td>\n<td>Resume from cluster state, not in-memory state</td>\n</tr>\n<tr>\n<td>Steady state</td>\n<td>Maintain lock renewal, perform normal reconciliation</td>\n<td>Stay ready for immediate takeover</td>\n<td>Keep reconciliation idempotent and stateless</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Continuing Reconciliation After Losing Leadership</strong></p>\n<p>A common mistake is failing to stop reconciliation immediately when leadership is lost. This can cause multiple controllers to simultaneously modify the same resources, leading to conflicts, inconsistent state, and resource thrashing. Always check leadership status before performing any write operations.</p>\n<h4 id=\"monitoring-and-observability-for-ha-deployments\">Monitoring and Observability for HA Deployments</h4>\n<p>High availability deployments require additional monitoring to track leadership status, failover events, and replica health. This observability helps diagnose performance issues and verify that failover mechanisms work correctly.</p>\n<table>\n<thead>\n<tr>\n<th>Metric Category</th>\n<th>Key Metrics</th>\n<th>Purpose</th>\n<th>Alert Conditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Leadership status</td>\n<td>Current leader identity, lease age, renewal success rate</td>\n<td>Track which replica is active and leadership stability</td>\n<td>No active leader for &gt;lease duration</td>\n</tr>\n<tr>\n<td>Failover events</td>\n<td>Leadership transitions, takeover frequency, transition duration</td>\n<td>Monitor failover reliability and performance</td>\n<td>Frequent leadership changes (&gt;1/hour)</td>\n</tr>\n<tr>\n<td>Reconciliation health</td>\n<td>Reconciliation rate, error rate, queue depth per replica</td>\n<td>Verify only leader is working, followers are idle</td>\n<td>Non-leader performing reconciliation</td>\n</tr>\n<tr>\n<td>Resource utilization</td>\n<td>CPU, memory, API server requests per replica</td>\n<td>Optimize resource allocation and detect resource leaks</td>\n<td>High resource usage on follower replicas</td>\n</tr>\n</tbody></table>\n<p>The operator should expose Prometheus metrics for leadership status and reconciliation health. These metrics enable alerting on split-brain conditions, failed failovers, and performance degradation.</p>\n<table>\n<thead>\n<tr>\n<th>Metric Name</th>\n<th>Type</th>\n<th>Labels</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>operator_leader_election_status</code></td>\n<td>Gauge</td>\n<td><code>instance</code>, <code>leader</code></td>\n<td>1 if this replica is leader, 0 if follower</td>\n</tr>\n<tr>\n<td><code>operator_leadership_changes_total</code></td>\n<td>Counter</td>\n<td><code>instance</code></td>\n<td>Total number of leadership transitions for this replica</td>\n</tr>\n<tr>\n<td><code>operator_lease_renewal_duration_seconds</code></td>\n<td>Histogram</td>\n<td><code>instance</code></td>\n<td>Time taken to renew leadership lease</td>\n</tr>\n<tr>\n<td><code>operator_reconciliation_rate</code></td>\n<td>Gauge</td>\n<td><code>instance</code>, <code>resource_type</code></td>\n<td>Number of reconciliations per second (should be 0 for followers)</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Overly Broad RBAC Permissions</strong></p>\n<p>Granting <code>cluster-admin</code> or wildcard permissions (<code>*</code>) makes security auditing impossible and creates significant security risks. If an operator with broad permissions is compromised, attackers gain access to the entire cluster. Instead, enumerate specific permissions required for each reconciliation action and grant only those permissions.</p>\n<p>⚠️ <strong>Pitfall: Missing Resource Version Conflicts in Leader Election</strong></p>\n<p>Failing to handle resource version conflicts during leader election can cause split-brain scenarios where multiple replicas believe they are the leader. Always use conditional updates with resource version checking when claiming or renewing leadership locks.</p>\n<p>⚠️ <strong>Pitfall: Hardcoded Configuration in Container Images</strong></p>\n<p>Embedding environment-specific configuration (URLs, credentials, timeouts) in container images prevents image reuse across environments and requires image rebuilds for configuration changes. Use environment variables, ConfigMaps, and Secrets for all environment-specific settings.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Webhook Certificate Expiration</strong></p>\n<p>Self-signed certificates or manually provisioned certificates will eventually expire, causing webhook failures that prevent resource creation and updates. Implement certificate monitoring and automatic renewal, preferably using cert-manager or similar automated certificate management systems.</p>\n<p>⚠️ <strong>Pitfall: Leader Election with Inappropriate Timing</strong></p>\n<p>Setting lease durations too short causes leadership thrashing during network hiccups, while setting them too long delays failover during actual failures. Test leader election behavior under various network conditions and adjust timing parameters based on your cluster characteristics and recovery time objectives.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete implementation details for deploying the Database Operator with proper RBAC configuration, container packaging, and high availability setup.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Container Build</td>\n<td><code>docker build</code> with multi-stage Dockerfile</td>\n<td>Buildpacks with Cloud Native Buildpacks</td>\n</tr>\n<tr>\n<td>Image Registry</td>\n<td>Docker Hub public registry</td>\n<td>Private registry with Harbor or ECR</td>\n</tr>\n<tr>\n<td>RBAC Management</td>\n<td>Static YAML manifests with <code>kubectl apply</code></td>\n<td>Helm charts with templated RBAC</td>\n</tr>\n<tr>\n<td>Certificate Management</td>\n<td>Self-signed certificates with OpenSSL</td>\n<td>cert-manager with Let&#39;s Encrypt or private CA</td>\n</tr>\n<tr>\n<td>Configuration Management</td>\n<td>Environment variables with ConfigMaps</td>\n<td>Helm values with environment-specific overrides</td>\n</tr>\n<tr>\n<td>Deployment Strategy</td>\n<td>kubectl apply with manual manifests</td>\n<td>GitOps with ArgoCD or Flux</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>operator-deployment/\n├── docker/\n│   ├── Dockerfile              ← Multi-stage build definition\n│   └── .dockerignore           ← Exclude unnecessary files from build context\n├── helm/\n│   ├── Chart.yaml              ← Helm chart metadata\n│   ├── values.yaml             ← Default configuration values\n│   ├── values-dev.yaml         ← Development environment overrides\n│   ├── values-prod.yaml        ← Production environment overrides\n│   ├── templates/\n│   │   ├── deployment.yaml     ← Operator pod specification\n│   │   ├── rbac.yaml           ← ServiceAccount, Role, RoleBinding\n│   │   ├── webhooks.yaml       ← Admission webhook configuration\n│   │   ├── service.yaml        ← Webhook and metrics services\n│   │   └── configmap.yaml      ← Operator configuration\n│   └── crds/\n│       └── databases.yaml      ← CRD definitions (install-only)\n├── manifests/\n│   ├── namespace.yaml          ← Operator namespace\n│   ├── crd.yaml               ← Raw CRD for kubectl apply\n│   └── rbac.yaml              ← Minimal RBAC for development\n└── scripts/\n    ├── build.sh               ← Container build script\n    ├── deploy.sh              ← Helm deployment script\n    └── undeploy.sh            ← Cleanup script</code></pre></div>\n\n<h4 id=\"complete-rbac-configuration\">Complete RBAC Configuration</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">yaml</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># ServiceAccount for operator pods</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">apiVersion</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">v1</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">kind</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">ServiceAccount</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">metadata</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">database-operator-controller-manager</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  namespace</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">database-operator-system</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">---</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ClusterRole with minimal required permissions</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">apiVersion</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">rbac.authorization.k8s.io/v1</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">kind</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">ClusterRole</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">metadata</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">database-operator-manager-role</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">rules</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">- </span><span style=\"color:#85E89D\">apiGroups</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">\"\"</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  resources</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">configmaps</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">events</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">persistentvolumeclaims</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">secrets</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">services</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  verbs</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">create</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">delete</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">get</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">patch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">update</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">watch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">- </span><span style=\"color:#85E89D\">apiGroups</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">apps</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  resources</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">deployments</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  verbs</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">create</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">delete</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">get</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">patch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">update</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">watch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">- </span><span style=\"color:#85E89D\">apiGroups</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">example.com</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  resources</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">databases</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  verbs</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">create</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">delete</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">get</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">patch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">update</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">watch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">- </span><span style=\"color:#85E89D\">apiGroups</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">example.com</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  resources</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">databases/status</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  verbs</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">get</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">patch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">update</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">- </span><span style=\"color:#85E89D\">apiGroups</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">coordination.k8s.io</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  resources</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">leases</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  verbs</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">create</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">get</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  - </span><span style=\"color:#9ECBFF\">update</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">---</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># ClusterRoleBinding linking ServiceAccount to permissions</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">apiVersion</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">rbac.authorization.k8s.io/v1</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">kind</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">ClusterRoleBinding</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">metadata</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">database-operator-manager-rolebinding</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">roleRef</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  apiGroup</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">rbac.authorization.k8s.io</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  kind</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">ClusterRole</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">database-operator-manager-role</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">subjects</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">- </span><span style=\"color:#85E89D\">kind</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">ServiceAccount</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">database-operator-controller-manager</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  namespace</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">database-operator-system</span></span></code></pre></div>\n\n<h4 id=\"complete-deployment-configuration\">Complete Deployment Configuration</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">yaml</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#85E89D\">apiVersion</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">apps/v1</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">kind</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">Deployment</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">metadata</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">database-operator-controller-manager</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  namespace</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">database-operator-system</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  labels</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    app.kubernetes.io/name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">database-operator</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    app.kubernetes.io/component</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">manager</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">spec</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  replicas</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#6A737D\">  # High availability with leader election</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  selector</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    matchLabels</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      app.kubernetes.io/name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">database-operator</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      app.kubernetes.io/component</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">manager</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">  template</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    metadata</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      labels</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        app.kubernetes.io/name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">database-operator</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        app.kubernetes.io/component</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">manager</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">    spec</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      serviceAccountName</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">database-operator-controller-manager</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      securityContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        runAsNonRoot</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        runAsUser</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">65532</span><span style=\"color:#6A737D\">  # Distroless nonroot user</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      containers</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      - </span><span style=\"color:#85E89D\">name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">manager</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        image</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">database-operator:latest</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        command</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        - </span><span style=\"color:#9ECBFF\">/manager</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        args</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        - </span><span style=\"color:#9ECBFF\">--leader-elect</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        - </span><span style=\"color:#9ECBFF\">--leader-elect-lease-duration=15s</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        - </span><span style=\"color:#9ECBFF\">--leader-elect-renew-deadline=5s</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        - </span><span style=\"color:#9ECBFF\">--leader-elect-retry-period=2s</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        ports</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        - </span><span style=\"color:#85E89D\">containerPort</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">9443</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">webhook-server</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          protocol</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">TCP</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        - </span><span style=\"color:#85E89D\">containerPort</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">8080</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">metrics</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          protocol</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">TCP</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        - </span><span style=\"color:#85E89D\">containerPort</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">8081</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">health-probe</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          protocol</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">TCP</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        env</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        - </span><span style=\"color:#85E89D\">name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">POD_NAMESPACE</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          valueFrom</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">            fieldRef</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">              fieldPath</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">metadata.namespace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        - </span><span style=\"color:#85E89D\">name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">POD_NAME</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          valueFrom</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">            fieldRef</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">              fieldPath</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">metadata.name</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        livenessProbe</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          httpGet</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">            path</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">/healthz</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">            port</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">8081</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          initialDelaySeconds</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">15</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          periodSeconds</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">20</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        readinessProbe</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          httpGet</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">            path</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">/readyz</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">            port</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">8081</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          initialDelaySeconds</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">5</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          periodSeconds</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">10</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        resources</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          limits</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">            cpu</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">500m</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">            memory</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">128Mi</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          requests</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">            cpu</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">10m</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">            memory</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">64Mi</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        securityContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          allowPrivilegeEscalation</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">false</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          capabilities</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">            drop</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            - </span><span style=\"color:#9ECBFF\">ALL</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          readOnlyRootFilesystem</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        volumeMounts</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        - </span><span style=\"color:#85E89D\">mountPath</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">/tmp/k8s-webhook-server/serving-certs</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">cert</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          readOnly</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">true</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      volumes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      - </span><span style=\"color:#85E89D\">name</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">cert</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">        secret</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          defaultMode</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">420</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">          secretName</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">webhook-server-certs</span></span>\n<span class=\"line\"><span style=\"color:#85E89D\">      terminationGracePeriodSeconds</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">10</span></span></code></pre></div>\n\n<h4 id=\"core-leader-election-implementation\">Core Leader Election Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Manager setup with leader election enabled</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> enableLeaderElection </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> leaseDuration </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> renewDeadline </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> retryPeriod </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">BoolVar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">enableLeaderElection, </span><span style=\"color:#9ECBFF\">\"leader-elect\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"Enable leader election for controller manager\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">DurationVar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">leaseDuration, </span><span style=\"color:#9ECBFF\">\"leader-elect-lease-duration\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">15</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"The duration that non-leader candidates will wait after observing a leadership renewal\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">DurationVar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">renewDeadline, </span><span style=\"color:#9ECBFF\">\"leader-elect-renew-deadline\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"The interval between attempts by the acting master to renew a leadership slot\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">DurationVar</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">retryPeriod, </span><span style=\"color:#9ECBFF\">\"leader-elect-retry-period\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"The duration the clients should wait between attempting acquisition and renewal\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">Parse</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mgr, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ctrl.</span><span style=\"color:#B392F0\">NewManager</span><span style=\"color:#E1E4E8\">(ctrl.</span><span style=\"color:#B392F0\">GetConfigOrDie</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#B392F0\">ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Options</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Scheme:                 scheme,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        MetricsBindAddress:     </span><span style=\"color:#9ECBFF\">\":8080\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Port:                   </span><span style=\"color:#79B8FF\">9443</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        HealthProbeBindAddress: </span><span style=\"color:#9ECBFF\">\":8081\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LeaderElection:         enableLeaderElection,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LeaderElectionID:       </span><span style=\"color:#9ECBFF\">\"database.example.com\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LeaseDuration:          </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">leaseDuration,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        RenewDeadline:          </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">renewDeadline,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        RetryPeriod:            </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">retryPeriod,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LeaderElectionResourceLock: </span><span style=\"color:#9ECBFF\">\"leases\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LeaderElectionNamespace: os.</span><span style=\"color:#B392F0\">Getenv</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"POD_NAMESPACE\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        setupLog.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(err, </span><span style=\"color:#9ECBFF\">\"unable to start manager\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Register controllers and webhooks with manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add health and readiness checks  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Start manager with graceful shutdown on SIGTERM</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"container-build-configuration\">Container Build Configuration</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">dockerfile</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Multi-stage build for minimal production image</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> golang:1.21 </span><span style=\"color:#F97583\">AS</span><span style=\"color:#E1E4E8\"> builder</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">WORKDIR</span><span style=\"color:#E1E4E8\"> /workspace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Copy go mod files for dependency caching</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">COPY</span><span style=\"color:#E1E4E8\"> go.mod go.sum ./</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">RUN</span><span style=\"color:#E1E4E8\"> go mod download</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Copy source code</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">COPY</span><span style=\"color:#E1E4E8\"> cmd/ cmd/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">COPY</span><span style=\"color:#E1E4E8\"> internal/ internal/</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">COPY</span><span style=\"color:#E1E4E8\"> api/ api/</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Build the operator binary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">RUN</span><span style=\"color:#E1E4E8\"> CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -a -o manager cmd/main.go</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Production image with minimal attack surface</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">FROM</span><span style=\"color:#E1E4E8\"> gcr.io/distroless/static:nonroot</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">WORKDIR</span><span style=\"color:#E1E4E8\"> /</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">COPY</span><span style=\"color:#E1E4E8\"> --from=builder /workspace/manager .</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">USER</span><span style=\"color:#E1E4E8\"> 65532:65532</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">ENTRYPOINT</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"/manager\"</span><span style=\"color:#E1E4E8\">]</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the deployment configuration:</p>\n<ol>\n<li><strong>RBAC Verification</strong>: Deploy the operator and verify it can perform required operations:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   kubectl</span><span style=\"color:#9ECBFF\"> auth</span><span style=\"color:#9ECBFF\"> can-i</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#9ECBFF\"> databases</span><span style=\"color:#79B8FF\"> --as=system:serviceaccount:database-operator-system:database-operator-controller-manager</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   kubectl</span><span style=\"color:#9ECBFF\"> auth</span><span style=\"color:#9ECBFF\"> can-i</span><span style=\"color:#9ECBFF\"> update</span><span style=\"color:#9ECBFF\"> secrets</span><span style=\"color:#79B8FF\"> --as=system:serviceaccount:database-operator-system:database-operator-controller-manager</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Leader Election Testing</strong>: Deploy multiple replicas and verify only one performs reconciliation:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   kubectl</span><span style=\"color:#9ECBFF\"> scale</span><span style=\"color:#9ECBFF\"> deployment</span><span style=\"color:#9ECBFF\"> database-operator-controller-manager</span><span style=\"color:#79B8FF\"> --replicas=3</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   kubectl</span><span style=\"color:#9ECBFF\"> logs</span><span style=\"color:#79B8FF\"> -l</span><span style=\"color:#9ECBFF\"> app.kubernetes.io/name=database-operator</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> \"leader election\"</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><p><strong>Failover Validation</strong>: Delete the leader pod and verify another replica takes over within the lease duration.</p>\n</li>\n<li><p><strong>Expected Behavior</strong>: </p>\n<ul>\n<li>Only one replica should show &quot;Starting EventSource&quot; and &quot;Starting Controller&quot; in logs</li>\n<li>Other replicas should show &quot;Waiting for leader election&quot; or similar</li>\n<li>After leader pod deletion, a new leader should be elected within 15-20 seconds</li>\n<li>Reconciliation should continue without interruption during leadership transitions</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Forbidden&quot; errors during reconciliation</td>\n<td>Missing RBAC permissions</td>\n<td>Check <code>kubectl auth can-i</code> for required operations</td>\n<td>Add missing permissions to ClusterRole</td>\n</tr>\n<tr>\n<td>Multiple replicas reconciling simultaneously</td>\n<td>Leader election not working</td>\n<td>Check logs for &quot;acquired lease&quot; messages from multiple pods</td>\n<td>Verify leader election configuration and lease resource creation</td>\n</tr>\n<tr>\n<td>Webhook admission failures</td>\n<td>Certificate issues or service misconfiguration</td>\n<td>Check webhook service endpoints and certificate validity</td>\n<td>Verify cert-manager setup or regenerate self-signed certificates</td>\n</tr>\n<tr>\n<td>Operator not starting after deployment</td>\n<td>Image pull failures or resource constraints</td>\n<td>Check pod events and resource utilization</td>\n<td>Verify image registry access and resource requests</td>\n</tr>\n<tr>\n<td>Slow failover during leader crashes</td>\n<td>Lease duration too long</td>\n<td>Monitor leadership transition timing</td>\n<td>Reduce lease duration while avoiding election thrashing</td>\n</tr>\n</tbody></table>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 (Controller Setup), Milestone 3 (Reconciliation Loop), Milestone 4 (Webhooks), Milestone 5 (Testing &amp; Deployment) - provides troubleshooting guidance for common issues across controller implementation, webhook configuration, and RBAC setup</p>\n</blockquote>\n<p>Building a Kubernetes operator involves complex interactions between custom controllers, admission webhooks, informers, workqueues, and the Kubernetes API server. When these components don&#39;t work as expected, the symptoms can be confusing and the root causes non-obvious. This section provides a systematic debugging guide organized around the three most common problem areas developers encounter when building operators.</p>\n<p><strong>Mental Model: The Detective&#39;s Toolkit</strong> - Think of debugging an operator like being a detective investigating a complex case. You have multiple witnesses (logs), physical evidence (resource states), and timelines (event sequences). Just as a detective follows leads and eliminates suspects, debugging operators requires gathering evidence from multiple sources, forming hypotheses about root causes, and systematically testing those theories. The key is knowing what evidence to look for and how to interpret the clues.</p>\n<p>The debugging process typically follows this pattern: observe the symptoms (what&#39;s not working), gather evidence from logs and cluster state, form hypotheses about potential causes, test each hypothesis with targeted debugging techniques, and implement fixes. This guide provides the diagnostic toolkit and investigative procedures for each category of problems.</p>\n<p>Operator debugging is particularly challenging because problems often manifest as cascading failures. A simple RBAC misconfiguration can cause controller crashes, which leads to failed reconciliation, which results in outdated status conditions, which confuses end users about the actual problem. The key is learning to trace problems back to their root causes rather than treating symptoms.</p>\n<h3 id=\"controller-and-reconciliation-issues\">Controller and Reconciliation Issues</h3>\n<p>Controller and reconciliation problems are among the most common issues operators face. These manifest as resources stuck in pending states, infinite reconciliation loops, or controllers that appear to be &quot;doing nothing&quot; despite resource changes. Understanding the controller&#39;s internal state machine and information flow is crucial for effective debugging.</p>\n<p><strong>Mental Model: The Broken Assembly Line</strong> - Think of the controller as an assembly line with several stations: the informer (receives raw materials), the workqueue (buffers work items), and the reconcile function (processes each item). When the assembly line breaks down, products either pile up at one station, get stuck in processing, or come out defective. By examining each station&#39;s health and throughput, you can identify where the bottleneck or failure occurs.</p>\n<h4 id=\"reconciliation-loop-problems\">Reconciliation Loop Problems</h4>\n<p>Reconciliation loops can fail in several distinct patterns, each with characteristic symptoms and root causes. The most common failure modes involve infinite loops, stalled reconciliation, and partial reconciliation failures that leave resources in inconsistent states.</p>\n<p><strong>Infinite Reconciliation Loops</strong></p>\n<p>Infinite reconciliation loops occur when the <code>Reconcile</code> function continuously requeues the same resource without making progress toward the desired state. This typically happens when the reconciler incorrectly determines that the current state doesn&#39;t match the desired state, even though they are actually equivalent.</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Evidence</th>\n<th>Root Cause</th>\n<th>Diagnostic Method</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>High CPU usage on controller pods</td>\n<td>Metrics show constant reconciliation rate</td>\n<td>Spec comparison logic treats equivalent states as different</td>\n<td>Add debug logging to state comparison logic</td>\n<td>Fix comparison logic to handle semantic equivalence</td>\n</tr>\n<tr>\n<td>Resource status never reaches &quot;Ready&quot;</td>\n<td>Status shows rapid condition updates</td>\n<td>Reconciler updates owned resources on every loop</td>\n<td>Log owned resource hashes before/after comparison</td>\n<td>Implement proper resource comparison with strategic merge</td>\n</tr>\n<tr>\n<td>Exponentially growing log volume</td>\n<td>Same resource appears repeatedly in logs</td>\n<td>Missing break condition in reconciliation logic</td>\n<td>Trace reconciliation decision tree for specific resource</td>\n<td>Add idempotency checks and proper exit conditions</td>\n</tr>\n<tr>\n<td>API server rate limiting errors</td>\n<td>Controller logs show 429 responses</td>\n<td>Excessive API calls from repeated reconciliation</td>\n<td>Monitor API call patterns with request counting</td>\n<td>Implement client-side rate limiting and backoff</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Resource Comparison Without Strategic Merge</strong>\nMany infinite loops result from comparing resources without accounting for Kubernetes&#39; strategic merge patch behavior. When you create a <code>Deployment</code> with <code>replicas: 3</code>, Kubernetes may add default fields like <code>progressDeadlineSeconds: 600</code>. If your reconciler compares the original spec (without defaults) to the current state (with defaults), it will always detect differences and attempt updates.</p>\n<p><strong>Stalled Reconciliation</strong></p>\n<p>Stalled reconciliation occurs when the controller stops processing resources entirely, even though new events are occurring. This typically indicates problems with the informer cache, workqueue processing, or controller startup sequence.</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Evidence</th>\n<th>Root Cause</th>\n<th>Diagnostic Method</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Resources stuck in &quot;Pending&quot; state</td>\n<td>No reconciliation logs for affected resources</td>\n<td>Informer cache not synced before processing started</td>\n<td>Check informer sync status in controller startup</td>\n<td>Add proper cache sync wait before starting workers</td>\n</tr>\n<tr>\n<td>Controller appears healthy but ignores changes</td>\n<td>Resource updates don&#39;t trigger reconciliation</td>\n<td>Event handlers not properly registered</td>\n<td>Verify SetupWithManager includes all watch configurations</td>\n<td>Add missing watch statements for owned resources</td>\n</tr>\n<tr>\n<td>Some resources reconcile, others don&#39;t</td>\n<td>Selective resource processing failures</td>\n<td>Workqueue filtering or malformed resource keys</td>\n<td>Examine workqueue contents and key generation logic</td>\n<td>Fix resource key generation and queue filtering</td>\n</tr>\n<tr>\n<td>Fresh resources process, old ones don&#39;t</td>\n<td>Controller restart resolves some stuck resources</td>\n<td>Informer resync period too long or disabled</td>\n<td>Check resync configuration and cache staleness</td>\n<td>Configure appropriate resync period or force cache refresh</td>\n</tr>\n</tbody></table>\n<p><strong>Partial Reconciliation Failures</strong></p>\n<p>Partial reconciliation failures occur when the reconciler successfully processes some owned resources but fails on others, leaving the system in an inconsistent state. This is particularly dangerous because the overall status may appear healthy while critical components are actually broken.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Example Failure Sequence:\n1. Database resource specifies: replicas=3, version=14.5\n2. Reconciler successfully creates StatefulSet with 3 replicas  \n3. Reconciler fails to create ConfigMap with version 14.5 config\n4. Status shows &quot;Ready: True&quot; based on StatefulSet status\n5. Pods start but fail to launch due to missing ConfigMap\n6. User sees &quot;Ready&quot; status but database is actually down</code></pre></div>\n\n<p>The challenge with partial failures is that the reconciler must decide whether to report success (some resources are healthy) or failure (the overall system is broken). The solution is implementing transactional reconciliation with proper rollback and status reporting.</p>\n<h4 id=\"informer-and-cache-problems\">Informer and Cache Problems</h4>\n<p>The informer and cache system provides the controller with a local, eventually consistent view of cluster state. When this system malfunctions, controllers may operate on stale data, miss important events, or crash due to unexpected cache states.</p>\n<p><strong>Cache Synchronization Issues</strong></p>\n<p>Cache synchronization problems occur when the local informer cache diverges from the actual API server state, leading to reconciliation decisions based on outdated information.</p>\n<table>\n<thead>\n<tr>\n<th>Problem Type</th>\n<th>Symptoms</th>\n<th>Detection Method</th>\n<th>Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Stale cache data</td>\n<td>Reconciler operates on deleted resources</td>\n<td>Compare cache contents with direct API calls</td>\n<td>Increase resync period or force cache refresh</td>\n</tr>\n<tr>\n<td>Missing recent updates</td>\n<td>Controller ignores recent resource changes</td>\n<td>Check event sequence timestamps vs cache timestamps</td>\n<td>Verify watch connection health and restart if needed</td>\n</tr>\n<tr>\n<td>Cache memory pressure</td>\n<td>High memory usage, frequent GC pauses</td>\n<td>Monitor informer cache size and growth patterns</td>\n<td>Implement cache size limits or namespace filtering</td>\n</tr>\n<tr>\n<td>Watch connection drops</td>\n<td>Periodic reconciliation gaps in logs</td>\n<td>Monitor watch connection errors and reconnections</td>\n<td>Add connection monitoring and exponential backoff</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Starting Workers Before Cache Sync</strong>\nA common mistake is starting workqueue processing goroutines before the informer cache has fully synchronized with the API server. This causes the controller to process events based on incomplete cache data, leading to incorrect reconciliation decisions and potential data corruption.</p>\n<p><strong>Event Handler Registration Problems</strong></p>\n<p>Event handlers translate informer cache events (add, update, delete) into workqueue items for reconciliation. Misconfigured event handlers can cause the controller to miss important events or process irrelevant changes.</p>\n<table>\n<thead>\n<tr>\n<th>Handler Issue</th>\n<th>Behavior</th>\n<th>Investigation</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Missing update handlers</td>\n<td>Resource changes ignored</td>\n<td>Verify all SetupWithManager watch configurations</td>\n<td>Add missing Controller.Watches() calls</td>\n</tr>\n<tr>\n<td>Incorrect filtering</td>\n<td>Wrong resources trigger reconciliation</td>\n<td>Log event handler invocations with resource details</td>\n<td>Fix OwnerReference or label selectors in watches</td>\n</tr>\n<tr>\n<td>Handler panics</td>\n<td>Controller crashes on specific events</td>\n<td>Check event handler code for nil pointer dereferences</td>\n<td>Add nil checks and error handling in handlers</td>\n</tr>\n<tr>\n<td>Duplicate event processing</td>\n<td>Same resource reconciled multiple times per change</td>\n<td>Monitor workqueue items and deduplication</td>\n<td>Ensure proper resource key generation and dedup logic</td>\n</tr>\n</tbody></table>\n<h4 id=\"workqueue-and-rate-limiting-issues\">Workqueue and Rate Limiting Issues</h4>\n<p>The workqueue buffers reconciliation requests and implements rate limiting to prevent overwhelming the controller or API server. Workqueue problems typically manifest as delayed processing, resource starvation, or memory growth from unbounded queues.</p>\n<p><strong>Rate Limiting and Backoff Problems</strong></p>\n<p>Rate limiting protects the system from overload but can cause delays when misconfigured. Understanding the backoff algorithms and tuning parameters is essential for optimal controller performance.</p>\n<p>The default controller-runtime rate limiter uses exponential backoff with jitter: initial delay of 5ms, doubling on each retry, up to a maximum of 16 minutes. For transient errors, this provides good protection. However, permanent errors (like RBAC denials) will continue consuming rate limiter capacity without making progress.</p>\n<table>\n<thead>\n<tr>\n<th>Rate Limiting Issue</th>\n<th>Observable Effects</th>\n<th>Tuning Approach</th>\n<th>Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Aggressive backoff delays critical updates</td>\n<td>Important resources take minutes to reconcile</td>\n<td>Reduce base delay and maximum interval</td>\n<td>Configure custom ItemBasedRateLimiter with lower bounds</td>\n</tr>\n<tr>\n<td>Rate limiter overwhelmed by error resources</td>\n<td>Healthy resources delayed behind failing ones</td>\n<td>Separate rate limiting for different error types</td>\n<td>Implement multi-tier rate limiting based on error classification</td>\n</tr>\n<tr>\n<td>Memory growth from queued items</td>\n<td>Controller memory usage grows without bound</td>\n<td>Add queue depth monitoring and circuit breakers</td>\n<td>Set maximum queue length and reject new items when full</td>\n</tr>\n<tr>\n<td>Hot resource monopolizes queue capacity</td>\n<td>Single misbehaving resource blocks others</td>\n<td>Implement per-resource rate limiting</td>\n<td>Use BucketRateLimiter with separate buckets per resource</td>\n</tr>\n</tbody></table>\n<p><strong>Workqueue Shutdown and Goroutine Leaks</strong></p>\n<p>Proper workqueue shutdown is critical for clean controller termination and preventing goroutine leaks in testing scenarios. Shutdown problems often manifest as hanging tests or controllers that can&#39;t be cleanly restarted.</p>\n<p>The workqueue shutdown sequence must be carefully orchestrated: stop accepting new items, drain existing items, signal worker goroutines to exit, and wait for all workers to complete. Skipping any step can cause deadlocks or resource leaks.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Proper Shutdown Sequence:\n1. Call workqueue.ShutDown() to stop accepting new items\n2. Worker goroutines check Done() channel and exit gracefully  \n3. Call workqueue.ShutDownWithDrain() to process remaining items\n4. Use sync.WaitGroup to wait for all workers to finish\n5. Close any additional channels or cleanup resources</code></pre></div>\n\n<h3 id=\"webhook-and-admission-problems\">Webhook and Admission Problems</h3>\n<p>Admission webhooks introduce additional complexity because they operate synchronously in the request path between the client and API server. When webhooks malfunction, they can block all resource operations, cause timeouts, or silently fail validation. Webhook debugging requires understanding HTTPS certificate management, admission review processing, and failure policy configuration.</p>\n<p><strong>Mental Model: The Security Checkpoint</strong> - Think of admission webhooks like airport security checkpoints. Every passenger (resource) must pass through security (webhook validation) before boarding the plane (being stored in etcd). If security is down, flights get delayed or canceled. If security is too slow, passengers miss connections. If security has wrong information, innocent passengers get detained while threats slip through. The key is ensuring the checkpoint is fast, reliable, and has current information.</p>\n<h4 id=\"certificate-and-tls-issues\">Certificate and TLS Issues</h4>\n<p>Admission webhooks must serve HTTPS traffic with valid TLS certificates that the API server can verify. Certificate problems are among the most common webhook issues and can be particularly frustrating because they often work in development but fail in production due to different certificate authorities or hostname verification.</p>\n<p><strong>Certificate Provisioning and Validation</strong></p>\n<p>The API server must trust the webhook&#39;s TLS certificate and verify that the certificate&#39;s subject matches the service hostname. This requires proper certificate generation, distribution, and rotation mechanisms.</p>\n<table>\n<thead>\n<tr>\n<th>Certificate Problem</th>\n<th>Symptoms</th>\n<th>Verification Steps</th>\n<th>Solution Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Self-signed certificate not trusted</td>\n<td>Webhook admission review requests fail with TLS errors</td>\n<td>Check API server logs for certificate validation errors</td>\n<td>Use cert-manager or add CA bundle to webhook configuration</td>\n</tr>\n<tr>\n<td>Hostname mismatch in certificate</td>\n<td>TLS handshake failures despite valid certificates</td>\n<td>Verify certificate SAN includes service DNS names</td>\n<td>Regenerate certificate with correct Subject Alternative Names</td>\n</tr>\n<tr>\n<td>Expired certificates</td>\n<td>Intermittent webhook failures, particularly after time jumps</td>\n<td>Check certificate expiration dates with openssl</td>\n<td>Implement automatic certificate rotation with cert-manager</td>\n</tr>\n<tr>\n<td>Certificate not readable by webhook pod</td>\n<td>Webhook server fails to start with TLS initialization errors</td>\n<td>Verify certificate file permissions and volume mounts</td>\n<td>Fix service account permissions and secret volume configuration</td>\n</tr>\n</tbody></table>\n<p>The certificate Subject Alternative Name (SAN) field must include all DNS names that the API server might use to reach the webhook service. For a webhook service named <code>database-webhook</code> in namespace <code>operator-system</code>, the SAN should include: <code>database-webhook.operator-system.svc</code>, <code>database-webhook.operator-system.svc.cluster.local</code>, and potentially the service IP address.</p>\n<p>⚠️ <strong>Pitfall: Certificate Rotation During Webhook Processing</strong>\nCertificate rotation can cause admission request failures if certificates change while the API server still has cached connections. The webhook server must implement graceful certificate reloading without dropping active connections, and the API server may need time to refresh its certificate cache.</p>\n<p><strong>TLS Configuration and Cipher Suites</strong></p>\n<p>The webhook server must support TLS versions and cipher suites that the API server accepts. Mismatched TLS configurations can cause connection failures that are difficult to diagnose because they occur during the initial handshake.</p>\n<p>Modern Kubernetes API servers typically require TLS 1.2 or higher and prefer Forward Secrecy cipher suites. The webhook server should support a compatible set of protocols and ciphers while maintaining reasonable security standards.</p>\n<h4 id=\"admission-review-processing\">Admission Review Processing</h4>\n<p>Admission review processing involves unmarshaling the admission request, validating or mutating the resource, and returning a properly formatted admission response. Problems in this pipeline can cause webhook timeouts, malformed responses, or incorrect admission decisions.</p>\n<p><strong>Request Deserialization and Validation</strong></p>\n<p>The admission review request contains the resource data in JSON format, along with metadata about the operation type, user information, and admission context. Proper deserialization requires handling different API versions, unknown fields, and malformed input.</p>\n<table>\n<thead>\n<tr>\n<th>Processing Issue</th>\n<th>Error Manifestation</th>\n<th>Debugging Approach</th>\n<th>Implementation Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unsupported admission review version</td>\n<td>Webhook returns 400 Bad Request</td>\n<td>Log admission review version in request handler</td>\n<td>Add support for multiple admissionregistration API versions</td>\n</tr>\n<tr>\n<td>Resource deserialization failures</td>\n<td>Webhook denies all requests with decode errors</td>\n<td>Log raw admission request JSON for analysis</td>\n<td>Add proper error handling and version-aware deserialization</td>\n</tr>\n<tr>\n<td>Missing required fields in admission request</td>\n<td>Webhook crashes or returns malformed responses</td>\n<td>Validate admission request structure before processing</td>\n<td>Add comprehensive input validation with clear error messages</td>\n</tr>\n<tr>\n<td>Memory exhaustion from large resources</td>\n<td>Webhook becomes unresponsive or crashes</td>\n<td>Monitor memory usage during large resource processing</td>\n<td>Implement request size limits and streaming deserialization</td>\n</tr>\n</tbody></table>\n<p><strong>Mutation Response Formatting</strong></p>\n<p>Mutating webhooks must return JSON Patch operations that describe the changes to apply to the resource. Malformed patches can cause admission failures or unintended modifications.</p>\n<p>JSON Patch operations must specify the exact path to modify, the operation type (add, replace, remove), and the new value with correct typing. Path specifications use JSON Pointer syntax, which has specific escaping rules for field names containing special characters.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Example Mutation Scenarios:\n- Adding a default value to an empty field: {&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/spec/replicas&quot;, &quot;value&quot;: 1}\n- Replacing an existing array element: {&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/spec/containers/0/image&quot;, &quot;value&quot;: &quot;new-image:v2&quot;}  \n- Removing a field: {&quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/metadata/annotations/old-annotation&quot;}\n- Adding to an array: {&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/spec/containers/-&quot;, &quot;value&quot;: {...}}</code></pre></div>\n\n<p>⚠️ <strong>Pitfall: JSON Patch Path Escaping</strong>\nJSON Pointer paths require escaping special characters in field names. A field named <code>example.com/annotation</code> must be referenced as <code>/metadata/annotations/example.com~1annotation</code> (where <code>~1</code> represents the <code>/</code> character). Incorrect escaping causes patch application failures.</p>\n<h4 id=\"webhook-timeout-and-performance-issues\">Webhook Timeout and Performance Issues</h4>\n<p>Admission webhooks operate in the synchronous request path, so performance problems directly impact user operations. The default admission timeout is 10 seconds, after which the API server either admits or denies the request based on the configured failure policy.</p>\n<p><strong>Response Time Optimization</strong></p>\n<p>Webhook response time affects the user experience for all resource operations. Slow webhooks make <code>kubectl apply</code> commands feel sluggish and can cause client timeouts on large batch operations.</p>\n<p>Common performance bottlenecks include: external API calls during validation (such as checking license servers or external databases), complex validation logic with nested loops, large resource deserialization, and cold start delays in serverless environments.</p>\n<table>\n<thead>\n<tr>\n<th>Performance Issue</th>\n<th>User Impact</th>\n<th>Measurement Method</th>\n<th>Optimization Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Slow validation logic</td>\n<td>kubectl commands take several seconds</td>\n<td>Add timing metrics to webhook handlers</td>\n<td>Cache validation results and optimize algorithms</td>\n</tr>\n<tr>\n<td>External API dependencies</td>\n<td>Webhooks fail when external services are unavailable</td>\n<td>Monitor external service response times</td>\n<td>Implement circuit breakers and local caching</td>\n</tr>\n<tr>\n<td>Large resource processing</td>\n<td>Memory pressure and slow response for big resources</td>\n<td>Profile memory allocation during large resource handling</td>\n<td>Stream processing and implement size limits</td>\n</tr>\n<tr>\n<td>Cold start delays</td>\n<td>First requests after deployment are very slow</td>\n<td>Measure time-to-first-response after pod startup</td>\n<td>Add readiness probes and pre-warm caches</td>\n</tr>\n</tbody></table>\n<p><strong>Failure Policy and Degraded Mode Operation</strong></p>\n<p>Webhook failure policies determine what happens when the webhook is unavailable, times out, or returns errors. The two options are <code>Fail</code> (deny admission on webhook failure) and <code>Ignore</code> (allow admission on webhook failure). Both have significant operational implications.</p>\n<p>A <code>Fail</code> policy provides security guarantees by ensuring no unvalidated resources enter the cluster, but it creates availability risks if the webhook becomes unavailable. An <code>Ignore</code> policy maintains cluster availability during webhook outages but allows potentially invalid resources to be created.</p>\n<blockquote>\n<p><strong>Decision: Webhook Failure Policy Selection</strong>  </p>\n<ul>\n<li><strong>Context</strong>: Webhook failures can either block all resource operations (Fail policy) or allow unvalidated resources (Ignore policy)  </li>\n<li><strong>Options Considered</strong>: Always Fail, Always Ignore, Dynamic policy based on validation criticality  </li>\n<li><strong>Decision</strong>: Use Fail policy for validating webhooks, Ignore policy for mutating webhooks with non-critical defaults  </li>\n<li><strong>Rationale</strong>: Validation failures indicate policy violations that should block admission. Mutation failures for defaults are less critical than availability  </li>\n<li><strong>Consequences</strong>: Validation webhook outages block resource creation, requiring high availability deployment. Mutation webhook outages allow resources without defaults but maintain system operation</li>\n</ul>\n</blockquote>\n<h3 id=\"rbac-and-permissions-debugging\">RBAC and Permissions Debugging</h3>\n<p>Role-Based Access Control (RBAC) governs what operations the operator&#39;s service account can perform against the Kubernetes API. RBAC problems typically manifest as &quot;permission denied&quot; errors, but diagnosing the specific missing permissions and configuring minimal privilege access requires understanding Kubernetes&#39; multi-layered permission model.</p>\n<p><strong>Mental Model: The Credential Hierarchy</strong> - Think of Kubernetes RBAC like a corporate security system with keycards and access levels. Each service account has a keycard (identity), roles define what areas each keycard can access (permissions), and role bindings connect keycards to access levels (authorization). When access is denied, you need to trace through the entire chain: does the keycard exist, does the role have the right permissions, is the binding connecting them correctly, and is the request happening in the right location (namespace).</p>\n<h4 id=\"service-account-and-role-configuration\">Service Account and Role Configuration</h4>\n<p>Service accounts provide identity for pods, while roles and role bindings define and grant permissions. The interaction between these components creates a complex permission matrix that can be difficult to debug when misconfigured.</p>\n<p><strong>Service Account Identity Issues</strong></p>\n<p>Service accounts must exist and be properly mounted into pods before they can be used for API authentication. Missing or misconfigured service accounts cause immediate authentication failures.</p>\n<table>\n<thead>\n<tr>\n<th>Service Account Problem</th>\n<th>Error Pattern</th>\n<th>Investigation Steps</th>\n<th>Resolution Path</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Service account doesn&#39;t exist</td>\n<td>HTTP 401 Unauthorized errors on all API calls</td>\n<td>Check if service account exists in the correct namespace</td>\n<td>Create service account with proper metadata</td>\n</tr>\n<tr>\n<td>Service account token not mounted</td>\n<td>Authentication works in pod but fails for specific operations</td>\n<td>Verify automountServiceAccountToken is not disabled</td>\n<td>Enable service account token mounting or use manual token</td>\n</tr>\n<tr>\n<td>Wrong service account specified in deployment</td>\n<td>Pod uses default service account instead of operator account</td>\n<td>Compare Deployment serviceAccountName with actual pod spec</td>\n<td>Update Deployment to reference correct service account</td>\n</tr>\n<tr>\n<td>Service account in wrong namespace</td>\n<td>Permission denied errors despite correct role bindings</td>\n<td>Verify service account and role binding namespaces match</td>\n<td>Move service account or update role binding namespace</td>\n</tr>\n</tbody></table>\n<p><strong>Role Definition and Scope Problems</strong></p>\n<p>Roles define the specific permissions (verbs and resources) that can be granted to service accounts. Incorrect role definitions are a common source of permission errors, particularly when operators need to manage multiple resource types or perform administrative operations.</p>\n<p>The principle of least privilege suggests granting only the minimum permissions necessary for operation. However, operators often require broad permissions across multiple resources, creating tension between security and functionality.</p>\n<table>\n<thead>\n<tr>\n<th>Permission Issue</th>\n<th>Manifestation</th>\n<th>Diagnosis Technique</th>\n<th>Correction Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Missing resource permissions</td>\n<td>Permission denied on specific resource types</td>\n<td>Check role definition against error messages</td>\n<td>Add required resources to role rules</td>\n</tr>\n<tr>\n<td>Insufficient verbs for operations</td>\n<td>Create works but update/delete fails</td>\n<td>Map operation types to required verbs (get, list, watch, create, update, patch, delete)</td>\n<td>Expand verb list in role rules</td>\n</tr>\n<tr>\n<td>API group mismatches</td>\n<td>Permission denied for custom resources</td>\n<td>Verify apiGroups in role match CRD group</td>\n<td>Update role apiGroups to include custom resource groups</td>\n</tr>\n<tr>\n<td>Namespace scope limitations</td>\n<td>Cluster-wide operations fail with namespace-scoped roles</td>\n<td>Determine if operator needs cluster-wide or namespace-scoped access</td>\n<td>Convert Role to ClusterRole or add namespace-specific roles</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Custom Resource API Groups in RBAC</strong>\nCustom resources use different API groups than built-in Kubernetes resources. A <code>Database</code> custom resource in the <code>database.example.com</code> API group requires RBAC rules with <code>apiGroups: [&quot;database.example.com&quot;]</code>, not the empty string used for core resources. Forgetting to include the custom API group causes permission denied errors for all custom resource operations.</p>\n<h4 id=\"permission-scope-and-binding-issues\">Permission Scope and Binding Issues</h4>\n<p>Role bindings connect service accounts to roles, creating the actual permission grants. Binding problems can be subtle because they often involve namespace boundaries, subject references, or binding scope mismatches.</p>\n<p><strong>Namespace Boundary and Scope Mismatches</strong></p>\n<p>Kubernetes uses both namespace-scoped (Role, RoleBinding) and cluster-scoped (ClusterRole, ClusterRoleBinding) RBAC objects. Mismatching scopes between roles and bindings, or between operator needs and binding scope, causes permission failures that can be difficult to diagnose.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>RBAC Scope Combinations:\n- Role + RoleBinding: namespace-scoped permissions within a specific namespace  \n- ClusterRole + RoleBinding: cluster-wide permissions applied to a specific namespace\n- ClusterRole + ClusterRoleBinding: cluster-wide permissions applied cluster-wide\n- Role + ClusterRoleBinding: Invalid - ClusterRoleBindings cannot reference Roles</code></pre></div>\n\n<p>The most common scope mismatch occurs when operators need to watch resources across all namespaces but are configured with namespace-scoped role bindings. This causes the operator to successfully process resources in its own namespace while failing silently on resources in other namespaces.</p>\n<p><strong>Subject Reference and Binding Validation</strong></p>\n<p>Role bindings must correctly reference the service account using the proper subject format. Incorrect subject references cause the binding to be ineffective, even though it appears correctly configured.</p>\n<table>\n<thead>\n<tr>\n<th>Binding Problem</th>\n<th>Symptoms</th>\n<th>Validation Method</th>\n<th>Fix Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Incorrect subject name</td>\n<td>Permission denied despite apparently correct bindings</td>\n<td>Compare binding subjects with actual service account names</td>\n<td>Update binding subject name to match service account</td>\n</tr>\n<tr>\n<td>Wrong subject namespace</td>\n<td>Binding exists but doesn&#39;t grant permissions</td>\n<td>Verify binding subject namespace matches service account namespace</td>\n<td>Update subject namespace in role binding</td>\n</tr>\n<tr>\n<td>Invalid subject kind</td>\n<td>Binding appears correct but permissions not granted</td>\n<td>Ensure subject kind is &quot;ServiceAccount&quot; not &quot;User&quot; or &quot;Group&quot;</td>\n<td>Correct subject kind in binding specification</td>\n</tr>\n<tr>\n<td>Multiple conflicting bindings</td>\n<td>Inconsistent permission behavior across operations</td>\n<td>List all role bindings affecting the service account</td>\n<td>Consolidate bindings and remove conflicting rules</td>\n</tr>\n</tbody></table>\n<h4 id=\"runtime-permission-verification\">Runtime Permission Verification</h4>\n<p>Runtime permission verification involves testing actual API operations to confirm that RBAC configuration grants the expected access. This is particularly important during operator development and deployment because RBAC misconfigurations often only surface when specific operations are attempted.</p>\n<p><strong>Permission Testing and Validation</strong></p>\n<p>The <code>kubectl auth can-i</code> command provides a way to test permissions without attempting actual operations. This is useful for validating RBAC configuration before deploying operators or troubleshooting permission issues in production.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Permission Testing Examples:\nkubectl auth can-i create databases.database.example.com --as=system:serviceaccount:operator-system:database-controller\nkubectl auth can-i update deployments --as=system:serviceaccount:operator-system:database-controller -n production  \nkubectl auth can-i list secrets --as=system:serviceaccount:operator-system:database-controller --all-namespaces\nkubectl auth can-i delete persistentvolumeclaims --as=system:serviceaccount:operator-system:database-controller</code></pre></div>\n\n<p>These tests should be performed for all operations the operator needs to perform, across all relevant namespaces and resource types.</p>\n<p><strong>Minimal Privilege Validation</strong></p>\n<p>Operators should follow the principle of least privilege, granting only the minimum permissions necessary for correct operation. However, determining the exact minimum set of permissions requires careful analysis of all operator operations and their corresponding RBAC requirements.</p>\n<p>The process involves: cataloging all API operations the operator performs (from controller reconciliation and webhook processing), mapping each operation to required RBAC verbs and resources, grouping permissions by functional area to create focused roles, and testing that the minimal permission set supports all operator functionality.</p>\n<table>\n<thead>\n<tr>\n<th>Operation Type</th>\n<th>Required Permissions</th>\n<th>Rationale</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Custom resource reconciliation</td>\n<td>get, list, watch, update, patch on custom resources</td>\n<td>Controller needs to read current state and update status</td>\n<td>Test reconciliation loop with minimal permissions</td>\n</tr>\n<tr>\n<td>Owned resource management</td>\n<td>get, list, watch, create, update, patch, delete on owned types</td>\n<td>Controller creates and manages Deployments, Services, etc.</td>\n<td>Test resource creation, updates, and cleanup</td>\n</tr>\n<tr>\n<td>Event recording</td>\n<td>create on events</td>\n<td>Controller reports status and errors through events</td>\n<td>Test event creation during normal and error scenarios</td>\n</tr>\n<tr>\n<td>Leader election</td>\n<td>get, create, update on leases or configmaps</td>\n<td>High availability requires leader election coordination</td>\n<td>Test controller startup with multiple replicas</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>The critical insight here is that RBAC debugging requires understanding the complete request context - not just the service account and permissions, but also the namespace scope, API group, and specific operation being performed. Each element must align correctly for authorization to succeed.</strong></p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This debugging toolkit provides practical techniques for diagnosing and resolving the most common operator development issues. The goal is enabling developers to quickly identify root causes and apply targeted fixes rather than spending hours on trial-and-error debugging.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Debugging Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Log Analysis</td>\n<td>Basic kubectl logs with grep</td>\n<td>Structured logging with logr and log aggregation</td>\n</tr>\n<tr>\n<td>RBAC Validation</td>\n<td>kubectl auth can-i commands</td>\n<td>RBAC policy simulators and automated testing</td>\n</tr>\n<tr>\n<td>Certificate Management</td>\n<td>Manual openssl certificate validation</td>\n<td>cert-manager with automated certificate lifecycle</td>\n</tr>\n<tr>\n<td>Performance Monitoring</td>\n<td>Basic kubectl top and describe commands</td>\n<td>Prometheus metrics with Grafana dashboards</td>\n</tr>\n<tr>\n<td>Integration Testing</td>\n<td>Manual kubectl apply/delete cycles</td>\n<td>Automated envtest with comprehensive scenarios</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure for Debugging Tools:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>operator-project/\n  cmd/\n    debug-controller/\n      main.go                    ← debug utility for controller issues\n    validate-rbac/\n      main.go                    ← RBAC permission validation tool\n    webhook-tester/\n      main.go                    ← webhook admission request simulator\n  internal/\n    debug/\n      controller_diagnostics.go  ← controller health checking utilities\n      webhook_diagnostics.go     ← webhook validation and testing helpers\n      rbac_validator.go          ← automated RBAC permission verification\n  test/\n    debug/\n      controller_debug_test.go   ← debugging scenario test cases\n      webhook_debug_test.go      ← webhook failure simulation tests</code></pre></div>\n\n<p><strong>Complete Controller Diagnostics Helper:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/debug/controller_diagnostics.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> debug</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/client-go/tools/cache</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/client-go/util/workqueue</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/client</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    databasev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/example/database-operator/api/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ControllerDiagnostics</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Client </span><span style=\"color:#B392F0\">client</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Scheme </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Scheme</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#B392F0\">logr</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> InformerHealth</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CacheSynced     </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastSyncTime    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CacheSize       </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WatchConnected  </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResyncPeriod    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WorkqueueHealth</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    QueueLength     </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ProcessingRate  </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrorRate       </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RetryBacklog    </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsShuttingDown  </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ReconcilerHealth</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ActiveReconciliations </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AverageReconcileTime  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrorCount           </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SuccessCount         </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastReconcileTime    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DiagnoseInformerHealth checks the health of controller informers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cd </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ControllerDiagnostics</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DiagnoseInformerHealth</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">informer</span><span style=\"color:#B392F0\"> cache</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">SharedIndexInformer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InformerHealth</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if informer cache has synced with API server</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Measure cache size and last sync time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify watch connection is active</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Report resync period configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use informer.HasSynced() and informer.LastSyncResourceVersion()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> InformerHealth</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DiagnoseWorkqueueHealth analyzes workqueue performance and backlog</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cd </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ControllerDiagnostics</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DiagnoseWorkqueueHealth</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">queue</span><span style=\"color:#B392F0\"> workqueue</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RateLimitingInterface</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WorkqueueHealth</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Measure current queue length and processing rate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate error rate from retry attempts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Count items in retry backlog</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if queue is in shutdown state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use queue.Len() and implement metrics collection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> WorkqueueHealth</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DiagnoseReconcilerHealth evaluates reconciliation performance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cd </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ControllerDiagnostics</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DiagnoseReconcilerHealth</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">ReconcilerHealth</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Count active reconciliation goroutines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate average reconciliation duration from metrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Report success/error ratios</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Track last reconciliation timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use prometheus metrics or custom counters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> ReconcilerHealth</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateResourceState compares desired vs actual state for debugging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cd </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ControllerDiagnostics</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateResourceState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StateValidationResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Fetch current state of all owned resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Compare with desired state from Database spec</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Identify specific differences and inconsistencies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Report resources that should exist but don't</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Report resources that exist but shouldn't</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use owner references to find owned resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TraceReconciliationPath logs the complete reconciliation decision tree</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cd </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ControllerDiagnostics</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TraceReconciliationPath</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Enable debug logging for this specific resource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Log each step of reconciliation logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Record timing for each reconciliation phase</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Log state comparisons and decisions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Track condition updates and status changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use structured logging with consistent field names</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Webhook Diagnostics and Testing Helper:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/debug/webhook_diagnostics.go  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> debug</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/tls</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    admissionv1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/admission/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metav1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/apis/meta/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/runtime</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    databasev1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/example/database-operator/api/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WebhookDiagnostics</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WebhookURL  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CertPath    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    KeyPath     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HTTPClient  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CertificateHealth</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsValid         </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExpirationTime  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DaysUntilExpiry </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SubjectAltNames []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Issuer          </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ValidationError </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AdmissionTestResult</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RequestSent      </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResponseReceived </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResponseTime     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AdmissionDecision </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ValidationErrors []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MutationPatches  []</span><span style=\"color:#B392F0\">JSONPatch</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DiagnoseCertificateHealth validates webhook TLS certificates</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">wd </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WebhookDiagnostics</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DiagnoseCertificateHealth</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">CertificateHealth</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Load certificate from file or Kubernetes secret</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify certificate is not expired</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check Subject Alternative Names include service DNS names</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate certificate chain and CA trust</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test TLS handshake with API server requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use crypto/x509 for certificate parsing and validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> CertificateHealth</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TestAdmissionRequest sends a synthetic admission request to webhook</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">wd </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WebhookDiagnostics</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TestAdmissionRequest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">databasev1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">operation</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AdmissionTestResult</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Construct admission review request with test Database resource</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set appropriate operation (CREATE, UPDATE, DELETE)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Send HTTPS POST request to webhook endpoint</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Parse admission response and extract decision</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate response format and required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use admission/v1.AdmissionReview for request/response format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> AdmissionTestResult</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateWebhookConfiguration checks webhook registration with API server</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">wd </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WebhookDiagnostics</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateWebhookConfiguration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Fetch ValidatingAdmissionWebhook and MutatingAdmissionWebhook configurations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify webhook service and namespace references are correct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check that CA bundle matches webhook certificate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate admission rule selectors and resource matching</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test webhook failure policy configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use admissionregistration/v1 API to fetch webhook configs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SimulateWebhookFailures tests webhook behavior under various failure conditions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">wd </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WebhookDiagnostics</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SimulateWebhookFailures</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test webhook behavior when certificate is expired</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test webhook timeout scenarios with slow responses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test malformed admission request handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test webhook unavailability with failure policy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test concurrent admission request handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use test HTTP servers that simulate failure modes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>RBAC Validation Tool:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/debug/rbac_validator.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> debug</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    authv1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/authorization/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rbacv1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/api/rbac/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metav1 </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">k8s.io/apimachinery/pkg/apis/meta/v1</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/client-go/kubernetes</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RBACValidator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Client          </span><span style=\"color:#B392F0\">kubernetes</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Interface</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ServiceAccount  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Namespace       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PermissionTest</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Resource    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Verb        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    APIGroup    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Namespace   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Expected    </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Actual      </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Error       </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RBACValidationResult</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ServiceAccountExists </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RoleBindings        []</span><span style=\"color:#B392F0\">rbacv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RoleBinding</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ClusterRoleBindings []</span><span style=\"color:#B392F0\">rbacv1</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ClusterRoleBinding</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PermissionTests     []</span><span style=\"color:#B392F0\">PermissionTest</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MissingPermissions  []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExcessivePermissions []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateOperatorPermissions tests all required RBAC permissions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rv </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RBACValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateOperatorPermissions</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RBACValidationResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify service account exists in specified namespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Find all role bindings that reference the service account</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Find all cluster role bindings that reference the service account</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test each required permission using SubjectAccessReview</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Report missing permissions and excessive grants</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use authorization/v1.SubjectAccessReview for permission testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TestCustomResourcePermissions validates CRD-specific RBAC rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rv </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RBACValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TestCustomResourcePermissions</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test get, list, watch permissions on Database custom resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test create, update, patch permissions for Database resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test status subresource update permissions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test permissions across different namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify finalizer update permissions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Custom resources use different API groups than built-in resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TestOwnedResourcePermissions validates permissions for resources owned by operator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rv </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RBACValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TestOwnedResourcePermissions</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test Deployment create, update, delete permissions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test Service and ConfigMap management permissions  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test PersistentVolumeClaim permissions for storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test Secret permissions for database credentials</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify permissions work across target namespaces</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Test both namespace-scoped and cluster-scoped resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateMinimalRBACManifests creates RBAC with principle of least privilege</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rv </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RBACValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateMinimalRBACManifests</span><span style=\"color:#E1E4E8\">() ([]</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Object</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Analyze actual API calls made by operator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Generate Role and ClusterRole with minimal required permissions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create RoleBinding and ClusterRoleBinding for service account</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Separate permissions by functional area (controller, webhooks, leader election)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Include comments explaining why each permission is needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Group permissions logically and document rationale</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoint: Controller Debugging</strong>\nAfter implementing controller debugging tools, verify functionality by:</p>\n<ol>\n<li>Run <code>go run cmd/debug-controller/main.go</code> with a problematic Database resource</li>\n<li>Expected output: detailed informer cache status, workqueue metrics, and reconciliation trace</li>\n<li>Create a Database with intentional spec errors and confirm the debugging tool identifies the issue</li>\n<li>Verify that infinite reconciliation loops are detected and reported with specific root causes</li>\n</ol>\n<p><strong>Milestone Checkpoint: Webhook Debugging</strong><br>After implementing webhook diagnostics, validate by:</p>\n<ol>\n<li>Run webhook certificate validation against expired or misconfigured certificates</li>\n<li>Expected behavior: clear error messages identifying specific certificate problems  </li>\n<li>Test admission request simulation with various Database resource configurations</li>\n<li>Confirm that webhook timeout and failure scenarios are properly detected and reported</li>\n</ol>\n<p><strong>Milestone Checkpoint: RBAC Validation</strong>\nAfter implementing RBAC validation tools, confirm by:</p>\n<ol>\n<li>Run permission validation against service accounts with missing or excessive permissions</li>\n<li>Expected output: detailed report of required vs actual permissions with specific gaps identified</li>\n<li>Test custom resource permission validation across multiple namespaces</li>\n<li>Verify that minimal RBAC manifest generation produces working configurations</li>\n</ol>\n<h2 id=\"future-extensions-and-evolution\">Future Extensions and Evolution</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - this section guides how operators can evolve beyond their initial implementation while maintaining backward compatibility and operational stability</p>\n</blockquote>\n<p>The beauty of the Kubernetes operator pattern lies not just in solving immediate automation problems, but in creating a foundation that can evolve with changing requirements. Unlike traditional configuration management tools that often require complete rewrites for new features, well-designed operators can grow organically through extension points and architectural patterns that preserve existing functionality while adding new capabilities.</p>\n<h3 id=\"mental-model-the-living-system\">Mental Model: The Living System</h3>\n<p>Think of a mature operator like a city&#39;s infrastructure. When a city grows, you don&#39;t tear down all the roads and buildings to add new neighborhoods. Instead, you extend existing transit systems, add new utility lines that connect to existing grids, and build new districts that integrate with established ones. Similarly, a well-architected operator provides extension points that allow new functionality to plug into existing reconciliation loops, admission controls, and status reporting without disrupting operational workloads.</p>\n<p>The key insight is that operators encode operational knowledge as code, and this knowledge base should be extensible. Each new feature should build upon the foundation of custom resources, controllers, and webhooks established in the initial implementation, rather than requiring parallel systems that duplicate effort and create consistency challenges.</p>\n<h3 id=\"feature-extension-points\">Feature Extension Points</h3>\n<p>The operator pattern provides several natural extension points where new functionality can be added without breaking existing behavior. These extension points align with the separation of concerns established in the core architecture: custom resource schemas can be versioned and extended, controllers can watch additional resource types, and admission webhooks can be composed to handle multiple validation scenarios.</p>\n<h3 id=\"mental-model-the-plugin-architecture\">Mental Model: The Plugin Architecture</h3>\n<p>Consider how modern IDEs like Visual Studio Code handle extensions. The core editor provides fundamental capabilities (editing text, managing files), but extensions add language support, debugging tools, and specialized workflows. Each extension registers with well-defined interfaces, contributes to specific extension points, and can be installed or removed without affecting other extensions.</p>\n<p>Similarly, operator extensions should leverage Kubernetes&#39; native extension mechanisms. New custom resource definitions can be added alongside existing ones, additional controllers can be deployed to handle new resource types, and webhook configurations can be extended to cover new admission scenarios. The key is designing these extensions to be composable rather than monolithic.</p>\n<blockquote>\n<p><strong>Decision: Extension Architecture Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Operators need to evolve with new requirements while maintaining backward compatibility and operational stability for existing resources</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Monolithic operator with all features in one controller</li>\n<li>Microservice operators with one controller per resource type</li>\n<li>Plugin-based architecture with core operator and extension points</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Plugin-based architecture with extension points for new resource types, custom reconciliation logic, and admission policies</li>\n<li><strong>Rationale</strong>: This approach balances operational simplicity (single deployment) with extensibility (isolated feature development) while leveraging Kubernetes&#39; native composition mechanisms</li>\n<li><strong>Consequences</strong>: Extensions can be developed and tested independently, but require careful interface design to prevent tight coupling between core and extension code</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Extension Point</th>\n<th>Implementation Strategy</th>\n<th>Backward Compatibility</th>\n<th>Development Isolation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>New Custom Resources</td>\n<td>Additional CRDs with separate controllers</td>\n<td>Complete - existing resources unaffected</td>\n<td>High - independent schema and logic</td>\n</tr>\n<tr>\n<td>Resource Composition</td>\n<td>Cross-resource references and status aggregation</td>\n<td>Maintained through optional fields</td>\n<td>Medium - requires coordination protocols</td>\n</tr>\n<tr>\n<td>Admission Policy Extensions</td>\n<td>Webhook composition with policy plugins</td>\n<td>Preserved through additive validation</td>\n<td>High - independent policy modules</td>\n</tr>\n<tr>\n<td>Status Reporting Extensions</td>\n<td>Custom condition types and metrics</td>\n<td>Compatible through condition namespacing</td>\n<td>High - independent status providers</td>\n</tr>\n<tr>\n<td>Reconciliation Strategies</td>\n<td>Pluggable reconcilers with common interfaces</td>\n<td>Maintained through interface versioning</td>\n<td>Medium - shared interface contracts</td>\n</tr>\n</tbody></table>\n<h4 id=\"custom-resource-extensions\">Custom Resource Extensions</h4>\n<p>The most natural extension point involves adding new custom resource definitions that complement the existing <code>Database</code> resource. These extensions should follow the established patterns for schema design, status reporting, and controller integration while addressing new operational requirements.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: New custom resources should be designed as first-class citizens rather than sub-resources or configuration options within existing types. This approach provides cleaner separation of concerns, independent versioning capabilities, and clearer RBAC boundaries.</p>\n</blockquote>\n<p>Common custom resource extensions include:</p>\n<p><strong>Backup Resources</strong> that manage backup policies and execution schedules independently of database lifecycle management. A <code>DatabaseBackup</code> resource would reference <code>Database</code> instances through owner references or explicit references, allowing backup policies to be managed by different teams or systems while integrating with the database operator&#39;s status reporting.</p>\n<p><strong>Migration Resources</strong> that handle database schema changes and data migrations with their own reconciliation logic and status tracking. A <code>DatabaseMigration</code> resource would coordinate with <code>Database</code> controllers to ensure migrations execute during appropriate maintenance windows and update database status to reflect migration completion.</p>\n<p><strong>Monitoring Resources</strong> that configure observability and alerting for database instances based on operational requirements that may change independently of database configuration. A <code>DatabaseMonitor</code> resource would manage metrics collection, alert rules, and dashboard configuration while integrating with the database operator&#39;s health reporting.</p>\n<table>\n<thead>\n<tr>\n<th>Resource Extension</th>\n<th>Primary Responsibility</th>\n<th>Integration Points</th>\n<th>Status Reporting</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DatabaseBackup</code></td>\n<td>Backup policy and execution</td>\n<td>Owner references to <code>Database</code>, shared storage</td>\n<td>Backup completion, schedule adherence</td>\n</tr>\n<tr>\n<td><code>DatabaseMigration</code></td>\n<td>Schema version management</td>\n<td>Database readiness conditions, maintenance windows</td>\n<td>Migration progress, rollback capability</td>\n</tr>\n<tr>\n<td><code>DatabaseMonitor</code></td>\n<td>Observability configuration</td>\n<td>Database health status, performance metrics</td>\n<td>Monitor health, alert firing status</td>\n</tr>\n<tr>\n<td><code>DatabaseCluster</code></td>\n<td>Multi-instance coordination</td>\n<td>Database instance membership, leader election</td>\n<td>Cluster topology, split-brain detection</td>\n</tr>\n</tbody></table>\n<h4 id=\"controller-composition-strategies\">Controller Composition Strategies</h4>\n<p>As new custom resources are added, the controller architecture must accommodate multiple reconciliation loops that may need to coordinate their actions. The key architectural decision involves balancing controller isolation with cross-resource coordination requirements.</p>\n<blockquote>\n<p><strong>Decision: Multi-Controller Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Additional custom resources require their own reconciliation logic while maintaining coordination with existing database controllers</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Single controller handling all resource types with shared reconciliation logic</li>\n<li>Separate controllers per resource type with event-based coordination</li>\n<li>Controller hierarchy with primary controller coordinating secondary controllers</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Separate controllers per resource type with well-defined coordination protocols through status conditions and owner references</li>\n<li><strong>Rationale</strong>: This approach maximizes development isolation, enables independent testing and deployment of new controllers, and leverages Kubernetes&#39; native coordination mechanisms</li>\n<li><strong>Consequences</strong>: Each controller can be developed and maintained independently, but coordination protocols must be carefully designed to prevent race conditions and inconsistent state</li>\n</ul>\n</blockquote>\n<p>The controller composition strategy relies on several coordination mechanisms that build upon Kubernetes&#39; native patterns:</p>\n<p><strong>Owner Reference Coordination</strong> establishes parent-child relationships between resources, ensuring that backup resources are automatically garbage-collected when their associated database is deleted. This pattern also enables status aggregation, where parent resources can report the health of their children through aggregated conditions.</p>\n<p><strong>Status Condition Protocols</strong> define standard condition types and status values that controllers use to communicate their state to other controllers. For example, a database controller might set a <code>MaintenanceWindow</code> condition that migration controllers watch before executing schema changes.</p>\n<p><strong>Event-Based Coordination</strong> leverages Kubernetes events and controller watches to trigger cross-controller actions. When a database controller detects a configuration change that requires backup policy updates, it can emit an event that backup controllers watch and respond to appropriately.</p>\n<table>\n<thead>\n<tr>\n<th>Coordination Mechanism</th>\n<th>Implementation</th>\n<th>Consistency Guarantees</th>\n<th>Error Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Owner References</td>\n<td>Automatic garbage collection</td>\n<td>Eventually consistent cleanup</td>\n<td>Finalizers for cleanup ordering</td>\n</tr>\n<tr>\n<td>Status Conditions</td>\n<td>Cross-controller status sharing</td>\n<td>Optimistically consistent status</td>\n<td>Condition-based retry logic</td>\n</tr>\n<tr>\n<td>Event Watching</td>\n<td>Cross-resource change detection</td>\n<td>At-least-once event delivery</td>\n<td>Event deduplication in handlers</td>\n</tr>\n<tr>\n<td>Shared ConfigMaps</td>\n<td>Configuration coordination</td>\n<td>Read-your-writes consistency</td>\n<td>Conflict resolution strategies</td>\n</tr>\n</tbody></table>\n<h4 id=\"admission-webhook-composition\">Admission Webhook Composition</h4>\n<p>As operators evolve to handle additional resource types and more sophisticated validation requirements, admission webhook architecture must support composable validation and mutation policies. The key challenge involves maintaining performance and reliability while adding new admission logic.</p>\n<p>The webhook composition strategy builds upon the foundation established in Milestone 4 while providing extension points for new validation scenarios:</p>\n<p><strong>Policy Plugin Architecture</strong> allows new validation rules to be added without modifying core webhook code. Each policy plugin registers with the webhook server and receives admission requests for relevant resource types, enabling independent development and testing of specialized validation logic.</p>\n<p><strong>Validation Pipeline Composition</strong> enables multiple validation stages to be applied to the same resource, with each stage having the opportunity to add conditions, modify the admission response, or trigger additional validation steps based on resource content and cluster state.</p>\n<p><strong>Cross-Resource Validation</strong> supports validation rules that depend on the state of multiple resources, such as ensuring that backup schedules don&#39;t conflict with maintenance windows or verifying that migration resources reference valid database instances.</p>\n<table>\n<thead>\n<tr>\n<th>Webhook Extension</th>\n<th>Validation Scope</th>\n<th>Performance Impact</th>\n<th>Failure Isolation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Policy Plugins</td>\n<td>Resource-specific business rules</td>\n<td>Low - parallel validation</td>\n<td>High - plugin failures don&#39;t affect others</td>\n</tr>\n<tr>\n<td>Pipeline Composition</td>\n<td>Multi-stage validation workflows</td>\n<td>Medium - sequential processing</td>\n<td>Medium - early stage failures abort pipeline</td>\n</tr>\n<tr>\n<td>Cross-Resource Validation</td>\n<td>Cluster-wide consistency rules</td>\n<td>High - requires additional API calls</td>\n<td>Low - API failures affect all validation</td>\n</tr>\n<tr>\n<td>Dynamic Policy Loading</td>\n<td>Runtime policy updates</td>\n<td>Low - cached policy evaluation</td>\n<td>High - invalid policies isolated to specific requests</td>\n</tr>\n</tbody></table>\n<h3 id=\"scaling-and-performance\">Scaling and Performance</h3>\n<p>As operators mature and manage larger numbers of resources across more clusters, performance characteristics become critical operational concerns. The scaling strategy must address both horizontal scaling (handling more resources) and vertical scaling (handling more complex resources) while maintaining the reliability and consistency guarantees established in the initial implementation.</p>\n<h3 id=\"mental-model-the-air-traffic-control-system\">Mental Model: The Air Traffic Control System</h3>\n<p>Consider how air traffic control systems handle increasing flight volumes. Rather than building larger and larger central control towers, the system is partitioned geographically with regional controllers handling local airspace while coordinating with adjacent regions for aircraft transitions. Each controller has local authority within their domain but follows standardized protocols for inter-region coordination.</p>\n<p>Similarly, operator scaling strategies should partition the problem space rather than simply adding more computational resources to a monolithic controller. This partitioning can occur along resource boundaries (different controllers for different resource types), geographic boundaries (controllers scoped to specific regions or availability zones), or tenant boundaries (controllers scoped to specific namespaces or organizational units).</p>\n<h4 id=\"horizontal-scaling-strategies\">Horizontal Scaling Strategies</h4>\n<p>The foundation for horizontal scaling lies in the informer and workqueue architecture established in Milestone 2. However, as the number of managed resources grows, several bottlenecks emerge that require architectural evolution.</p>\n<blockquote>\n<p><strong>Decision: Controller Sharding Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Single controller instances become CPU and memory bottlenecks when managing thousands of resources, and Kubernetes API server rate limiting affects reconciliation latency</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Vertical scaling with larger controller instances and more aggressive caching</li>\n<li>Resource-based sharding with multiple controller instances handling disjoint resource sets</li>\n<li>Namespace-based sharding with controllers scoped to specific namespace sets</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Hybrid sharding approach supporting both resource-based and namespace-based partitioning depending on deployment requirements</li>\n<li><strong>Rationale</strong>: This approach provides flexibility for different scaling scenarios while maintaining compatibility with existing single-controller deployments</li>\n<li><strong>Consequences</strong>: Sharding logic adds complexity to deployment and coordination, but enables near-linear scaling with resource counts</li>\n</ul>\n</blockquote>\n<p><strong>Resource-Based Sharding</strong> partitions resources across multiple controller instances using consistent hashing or explicit assignment strategies. Each controller instance handles a subset of all resources, reducing per-instance memory usage and API server load while maintaining independent reconciliation loops.</p>\n<p>The sharding implementation extends the controller manager pattern with shard-aware resource filtering:</p>\n<table>\n<thead>\n<tr>\n<th>Sharding Strategy</th>\n<th>Resource Distribution</th>\n<th>Coordination Requirements</th>\n<th>Rebalancing Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Hash-Based Sharding</td>\n<td>Consistent hash of resource name/namespace</td>\n<td>None - independent shards</td>\n<td>Medium - requires hash function changes</td>\n</tr>\n<tr>\n<td>Range-Based Sharding</td>\n<td>Alphabetical or numerical resource ranges</td>\n<td>Shard boundary coordination</td>\n<td>High - requires resource migration</td>\n</tr>\n<tr>\n<td>Label-Based Sharding</td>\n<td>Resources tagged with shard identifiers</td>\n<td>Shard assignment coordination</td>\n<td>Low - label changes trigger rebalancing</td>\n</tr>\n<tr>\n<td>Namespace Sharding</td>\n<td>Controller scope limited to namespace sets</td>\n<td>Cross-namespace resource coordination</td>\n<td>Medium - namespace assignment changes</td>\n</tr>\n</tbody></table>\n<p><strong>Leader Election Evolution</strong> becomes more sophisticated in sharded deployments, where each shard requires independent leader election to ensure exactly one active controller per shard while supporting shard-level failover and rebalancing.</p>\n<p>The leader election strategy builds upon the foundation from Milestone 5 but adds shard awareness:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Shard Assignment:\n- Controller instances register with shard coordinator\n- Coordinator assigns responsibility for resource ranges\n- Each shard maintains independent leader election\n- Failed shards trigger automatic rebalancing\n\nFailover Behavior:\n- Shard leader failures trigger immediate re-election\n- Shard coordinator failures trigger shard assignment redistribution\n- Controller instance failures trigger shard responsibility transfer</code></pre></div>\n\n<h4 id=\"performance-optimization-strategies\">Performance Optimization Strategies</h4>\n<p>Beyond horizontal scaling, several performance optimization strategies address the computational and memory efficiency of individual controller instances. These optimizations build upon the informer and reconciliation patterns while reducing unnecessary work and improving resource utilization.</p>\n<p><strong>Informer Cache Optimization</strong> reduces memory usage and improves cache efficiency through selective caching strategies that store only the resource fields needed for reconciliation decisions rather than complete resource objects.</p>\n<p><strong>Reconciliation Batching</strong> groups related reconciliation operations to reduce API server round trips and improve throughput for scenarios where multiple resources can be processed together efficiently.</p>\n<p><strong>Incremental Reconciliation</strong> tracks resource changes at a finer granularity to avoid unnecessary reconciliation work when only status fields or irrelevant metadata changes occur.</p>\n<table>\n<thead>\n<tr>\n<th>Optimization Strategy</th>\n<th>Memory Impact</th>\n<th>Latency Impact</th>\n<th>Complexity Cost</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Selective Field Caching</td>\n<td>50-80% reduction</td>\n<td>Minimal increase</td>\n<td>Medium - requires field selection logic</td>\n</tr>\n<tr>\n<td>Reconciliation Batching</td>\n<td>Minimal change</td>\n<td>30-60% reduction</td>\n<td>High - requires dependency analysis</td>\n</tr>\n<tr>\n<td>Incremental Reconciliation</td>\n<td>20-40% reduction</td>\n<td>40-70% reduction</td>\n<td>Medium - requires change detection logic</td>\n</tr>\n<tr>\n<td>Status-Only Updates</td>\n<td>Minimal change</td>\n<td>20-30% reduction</td>\n<td>Low - separate status client usage</td>\n</tr>\n</tbody></table>\n<h4 id=\"multi-cluster-operations\">Multi-Cluster Operations</h4>\n<p>As organizations adopt multi-cluster Kubernetes deployments, operators must evolve to handle resources that span cluster boundaries while maintaining consistency and coordination across distributed infrastructure.</p>\n<p>The multi-cluster architecture builds upon single-cluster patterns while adding cluster-aware coordination:</p>\n<p><strong>Cluster-Scoped Controllers</strong> manage resources within individual clusters while reporting status to cluster-wide coordination systems. Each cluster maintains its own controller instances that handle local reconciliation while participating in cross-cluster coordination protocols.</p>\n<p><strong>Federation Controllers</strong> coordinate resources across multiple clusters, making placement decisions, managing resource distribution, and aggregating status information from cluster-scoped controllers.</p>\n<p><strong>Cross-Cluster Networking</strong> handles the connectivity and service discovery requirements for resources that span cluster boundaries, such as database clusters with instances in multiple availability zones or regions.</p>\n<table>\n<thead>\n<tr>\n<th>Multi-Cluster Pattern</th>\n<th>Coordination Mechanism</th>\n<th>Consistency Model</th>\n<th>Failure Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Hub-and-Spoke</td>\n<td>Central controller with cluster agents</td>\n<td>Eventually consistent</td>\n<td>Hub failure affects coordination only</td>\n</tr>\n<tr>\n<td>Peer-to-Peer</td>\n<td>Direct cluster-to-cluster communication</td>\n<td>Conflict-free replicated data types</td>\n<td>Network partitions require conflict resolution</td>\n</tr>\n<tr>\n<td>Event-Driven</td>\n<td>Message queue coordination</td>\n<td>At-least-once processing</td>\n<td>Message delivery guarantees vary by queue</td>\n</tr>\n<tr>\n<td>GitOps-Based</td>\n<td>Configuration repository coordination</td>\n<td>Strong consistency for desired state</td>\n<td>Repository availability affects updates</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Distributed State Consistency</strong></p>\n<p>A common mistake in multi-cluster operators involves assuming that status updates across clusters will be immediately consistent. This leads to race conditions where controllers make decisions based on stale information from other clusters, resulting in resource conflicts or inconsistent resource placement.</p>\n<p>The solution involves designing coordination protocols that explicitly handle eventual consistency through techniques like vector clocks for causality tracking, conflict-free replicated data types for status aggregation, and idempotent operations that produce correct results regardless of message ordering or duplication.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The extension and scaling strategies described above require careful implementation planning to ensure that new capabilities integrate cleanly with existing operator patterns while maintaining operational stability.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Scaling Challenge</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Controller Sharding</td>\n<td>Label-based shard assignment with manual configuration</td>\n<td>Consistent hashing with automatic rebalancing using controller-runtime&#39;s cluster caching</td>\n</tr>\n<tr>\n<td>Multi-Cluster Coordination</td>\n<td>Shared ConfigMaps in hub cluster</td>\n<td>Admiral service mesh integration with cross-cluster service discovery</td>\n</tr>\n<tr>\n<td>Performance Monitoring</td>\n<td>Prometheus metrics with basic controller dashboards</td>\n<td>Custom resource status aggregation with SLI/SLO tracking</td>\n</tr>\n<tr>\n<td>Extension Development</td>\n<td>In-tree plugins with interface definitions</td>\n<td>Out-of-tree controllers with standardized coordination protocols</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-project-structure\">Recommended Project Structure</h4>\n<p>Extensions should follow a modular structure that isolates new functionality while integrating with the core operator patterns:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  cmd/\n    database-operator/main.go          ← core operator entry point\n    backup-controller/main.go          ← backup extension controller\n    migration-controller/main.go       ← migration extension controller\n  apis/\n    database/v1/                       ← core database CRD\n    backup/v1/                         ← backup extension CRD\n    migration/v1/                      ← migration extension CRD\n  internal/\n    controller/\n      database/                        ← core reconciliation logic\n        database_controller.go\n        status_manager.go\n      backup/                          ← backup extension logic\n        backup_controller.go\n        schedule_manager.go\n      migration/                       ← migration extension logic\n        migration_controller.go\n        version_manager.go\n    webhook/\n      database/                        ← core admission logic\n      common/                          ← shared webhook utilities\n        policy_engine.go\n        validation_pipeline.go\n    coordination/                      ← cross-controller coordination\n      owner_reference.go\n      status_aggregation.go\n      event_coordination.go\n  config/\n    core/                             ← base operator manifests\n    extensions/                       ← extension-specific manifests\n    samples/                          ← example configurations</code></pre></div>\n\n<h4 id=\"extension-development-framework\">Extension Development Framework</h4>\n<p>The extension framework provides standardized interfaces and utilities that new controllers can implement to integrate seamlessly with the core operator:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ExtensionController defines the interface that all extension controllers must implement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// to participate in the operator's coordination protocols and lifecycle management.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ExtensionController</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SetupWithManager registers the extension controller with the controller manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // and configures watches for relevant resource types.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SetupWithManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">mgr</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // GetCoordinationSpecs returns the coordination requirements for this controller,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // including which resources it owns, which status conditions it reports, and</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // which cross-controller events it needs to receive.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetCoordinationSpecs</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">CoordinationSpecs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HandleCoordinationEvent processes events from other controllers that may</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // trigger reconciliation or status updates in this controller.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    HandleCoordinationEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">event</span><span style=\"color:#B392F0\"> CoordinationEvent</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // GetHealthStatus returns the current health and performance metrics for</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // this controller instance, used for monitoring and debugging.</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetHealthStatus</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">HealthStatus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CoordinationSpecs defines how an extension controller participates in</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// cross-controller coordination and status aggregation.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CoordinationSpecs</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // OwnedResources lists the resource types this controller creates and manages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OwnedResources []</span><span style=\"color:#B392F0\">schema</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">GroupVersionKind</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // StatusConditions lists the condition types this controller reports</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StatusConditions []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // WatchedConditions lists condition types from other controllers that</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // trigger reconciliation in this controller</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WatchedConditions []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // EmittedEvents lists event types this controller emits for coordination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EmittedEvents []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"sharding-implementation-framework\">Sharding Implementation Framework</h4>\n<p>The sharding framework extends the controller-runtime manager with shard-aware resource filtering and leader election:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ShardingManager extends the controller-runtime manager with shard-aware</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// resource filtering and coordination capabilities.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ShardingManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Manager is the underlying controller-runtime manager</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Manager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ShardID identifies this controller instance's shard assignment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ShardID </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ShardingStrategy determines how resources are assigned to shards</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ShardingStrategy </span><span style=\"color:#B392F0\">ShardingStrategy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CoordinationClient handles shard assignment and rebalancing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CoordinationClient </span><span style=\"color:#B392F0\">ShardCoordinator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ShardingStrategy defines how resources are partitioned across controller instances</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ShardingStrategy</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // AssignShard determines which shard should handle a given resource</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    AssignShard</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">resource</span><span style=\"color:#B392F0\"> client</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Object</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // IsAssignedToShard returns true if the resource should be handled by the given shard</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    IsAssignedToShard</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">resource</span><span style=\"color:#B392F0\"> client</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Object</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">shardID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // RebalanceShards redistributes resources across available shards</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    RebalanceShards</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">availableShards</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">ShardAssignments</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"performance-monitoring-integration\">Performance Monitoring Integration</h4>\n<p>The performance monitoring framework provides standardized metrics collection and alerting for operator scaling scenarios:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// PerformanceMetrics provides standardized metrics collection for operator scaling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PerformanceMetrics</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ReconciliationDuration tracks time spent in reconciliation loops</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ReconciliationDuration </span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">HistogramVec</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ResourceCacheSize tracks informer cache memory usage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResourceCacheSize </span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">GaugeVec</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // WorkqueueDepth tracks pending reconciliation requests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WorkqueueDepth </span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">GaugeVec</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // APIServerLatency tracks Kubernetes API call performance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    APIServerLatency </span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">HistogramVec</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ShardDistribution tracks resource distribution across shards</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ShardDistribution </span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">GaugeVec</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecordReconciliation records metrics for a completed reconciliation operation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PerformanceMetrics</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecordReconciliation</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    controllerName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    resourceType</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    duration</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    result</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Record reconciliation duration in histogram with controller/type/result labels</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update workqueue depth gauge to reflect current queue size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Record any API server calls made during reconciliation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use prometheus labels to enable per-controller and per-resource-type analysis</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Extension Development Checkpoint:</strong>\nAfter implementing a new extension controller, verify the integration by:</p>\n<ol>\n<li>Deploying the extension alongside the core operator: <code>kubectl apply -f config/extensions/backup-controller/</code></li>\n<li>Creating a test resource that should trigger coordination: <code>kubectl apply -f config/samples/backup_v1_databasebackup.yaml</code></li>\n<li>Verifying cross-controller coordination through status conditions: <code>kubectl get database test-db -o jsonpath=&#39;{.status.conditions[?(@.type==&quot;BackupReady&quot;)]}&#39;</code></li>\n<li>Checking coordination events in controller logs: <code>kubectl logs -l app=database-operator | grep &quot;coordination.event&quot;</code></li>\n</ol>\n<p><strong>Scaling Checkpoint:</strong>\nAfter implementing controller sharding, verify the scaling behavior by:</p>\n<ol>\n<li>Deploy multiple controller replicas with sharding enabled: <code>kubectl scale deployment database-operator --replicas=3</code></li>\n<li>Create multiple test resources across different namespaces: <code>kubectl apply -f config/samples/scaling-test/</code></li>\n<li>Verify shard assignment distribution: <code>kubectl logs -l app=database-operator | grep &quot;shard.assignment&quot;</code></li>\n<li>Monitor performance metrics during scale testing: <code>curl http://localhost:8080/metrics | grep reconciliation_duration</code></li>\n</ol>\n<p><strong>Performance Checkpoint:</strong>\nAfter implementing performance optimizations, validate the improvements by:</p>\n<ol>\n<li>Establish baseline metrics with unoptimized operator: Deploy operator, create 100 test resources, measure reconciliation latency</li>\n<li>Deploy optimized operator version with same test resources</li>\n<li>Compare reconciliation performance: Expected 30-50% reduction in reconciliation duration</li>\n<li>Verify memory usage improvements: Expected 40-60% reduction in controller memory usage</li>\n<li>Validate correctness: All resources should reach Ready condition within expected timeframes</li>\n</ol>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - provides definitions of Kubernetes, operator, and distributed systems terminology used throughout the entire operator implementation process</p>\n</blockquote>\n<p>This glossary defines the technical terminology used throughout this design document. Understanding these concepts is essential for successfully implementing a Kubernetes operator. The terms are organized into categories to help build conceptual understanding of how different pieces of the operator pattern connect together.</p>\n<h3 id=\"mental-model-the-specialized-dictionary\">Mental Model: The Specialized Dictionary</h3>\n<p>Think of this glossary like a specialized technical dictionary for a specific engineering discipline. Just as aerospace engineers have precise definitions for &quot;thrust,&quot; &quot;drag,&quot; and &quot;lift&quot; that might differ slightly from common usage, Kubernetes operators use terms like &quot;reconciliation,&quot; &quot;admission,&quot; and &quot;informer&quot; with very specific technical meanings. This glossary provides those precise definitions to prevent confusion when reading documentation or discussing implementation details with other engineers.</p>\n<p>The terminology forms layers of abstraction, from low-level Kubernetes primitives up to operator-specific patterns. Understanding these layers helps you navigate between different levels of detail when designing and troubleshooting your operator.</p>\n<h3 id=\"kubernetes-core-concepts\">Kubernetes Core Concepts</h3>\n<p>These fundamental Kubernetes terms form the foundation that operators build upon. Every operator developer must understand these concepts deeply.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Why It Matters</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>API Server</strong></td>\n<td>Central component of Kubernetes control plane that exposes REST API for all cluster operations and stores cluster state in etcd</td>\n<td>Operators interact with this component for all resource operations - understanding its role helps debug API errors and performance issues</td>\n</tr>\n<tr>\n<td><strong>Custom Resource Definition (CRD)</strong></td>\n<td>API extension defining new resource types with OpenAPI v3 schema validation that extends Kubernetes API without modifying core code</td>\n<td>CRDs are how operators introduce new APIs - poorly designed CRDs create maintenance headaches and user experience problems</td>\n</tr>\n<tr>\n<td><strong>Custom Resource (CR)</strong></td>\n<td>Instance of a custom resource type defined by a CRD, stored in etcd and accessible through standard Kubernetes API operations</td>\n<td>These are the resources your operator manages - understanding their lifecycle helps design better reconciliation logic</td>\n</tr>\n<tr>\n<td><strong>Resource Version</strong></td>\n<td>Monotonically increasing identifier for resource modifications used for optimistic locking and conflict detection</td>\n<td>Critical for handling concurrent updates - ignoring resource versions leads to lost updates and race conditions</td>\n</tr>\n<tr>\n<td><strong>Owner Reference</strong></td>\n<td>Metadata field establishing parent-child relationships between resources for automatic garbage collection</td>\n<td>Prevents resource leaks when parent resources are deleted - improper owner references cause cleanup failures</td>\n</tr>\n<tr>\n<td><strong>Finalizer</strong></td>\n<td>Metadata field preventing resource deletion until cleanup operations complete, allowing controllers to perform cleanup before removal</td>\n<td>Essential for managing external resources - forgetting to remove finalizers causes resources to stuck in deletion</td>\n</tr>\n<tr>\n<td><strong>Namespace</strong></td>\n<td>Virtual cluster that provides scope for resource names and RBAC policies, enabling multi-tenancy within a single cluster</td>\n<td>Affects controller permissions and resource isolation - namespace design impacts operator security model</td>\n</tr>\n<tr>\n<td><strong>Service Account</strong></td>\n<td>Identity for processes running in pods, used for authentication and authorization with the Kubernetes API</td>\n<td>Operators run under service accounts - understanding this helps design proper RBAC policies</td>\n</tr>\n<tr>\n<td><strong>RBAC (Role-Based Access Control)</strong></td>\n<td>Authorization mechanism controlling what operations service accounts can perform on specific resources</td>\n<td>Operators need carefully scoped permissions - overly broad RBAC creates security risks</td>\n</tr>\n</tbody></table>\n<h3 id=\"controller-pattern-concepts\">Controller Pattern Concepts</h3>\n<p>The controller pattern is the heart of Kubernetes operators. These terms describe the continuous reconciliation process that makes operators work.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Why It Matters</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Controller</strong></td>\n<td>Software component implementing a control loop that continuously observes cluster state and takes corrective actions to maintain desired state</td>\n<td>The core of every operator - understanding controller design patterns helps build robust, efficient operators</td>\n</tr>\n<tr>\n<td><strong>Reconciliation</strong></td>\n<td>Process of making actual state match desired state through continuous comparison and correction, implementing the controller&#39;s primary logic</td>\n<td>This is what makes operators &quot;smart&quot; - poor reconciliation logic causes performance problems and incorrect behavior</td>\n</tr>\n<tr>\n<td><strong>Control Loop</strong></td>\n<td>Continuous cycle of observing current state, comparing to desired state, and taking corrective action to eliminate differences</td>\n<td>Understanding control loops helps design operators that converge reliably without oscillation or instability</td>\n</tr>\n<tr>\n<td><strong>Desired State</strong></td>\n<td>Target configuration specified in resource spec fields that the controller works to achieve and maintain</td>\n<td>Controllers compare actual state against this - unclear desired state specifications lead to unpredictable behavior</td>\n</tr>\n<tr>\n<td><strong>Actual State</strong></td>\n<td>Current state of managed resources as observed through API server queries and external system inspection</td>\n<td>Controllers must accurately determine actual state - incorrect state detection leads to unnecessary reconciliation work</td>\n</tr>\n<tr>\n<td><strong>Event-Driven Architecture</strong></td>\n<td>Design pattern where controllers react to resource change events rather than continuously polling for changes</td>\n<td>Enables efficient operators that respond quickly to changes - polling-based designs waste resources and respond slowly</td>\n</tr>\n<tr>\n<td><strong>Declarative Management</strong></td>\n<td>Approach where users specify desired end state rather than imperative steps, letting the controller determine how to achieve that state</td>\n<td>Makes operators easier to use and more reliable - imperative approaches are harder to reason about and recover from failures</td>\n</tr>\n</tbody></table>\n<h3 id=\"informer-and-caching-architecture\">Informer and Caching Architecture</h3>\n<p>Informers provide the efficient event-driven foundation that controllers build on. Understanding these concepts is crucial for performance and correctness.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Why It Matters</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Informer</strong></td>\n<td>Client-side cache that watches API server events and maintains a local copy of resources, providing efficient reads without API server load</td>\n<td>Enables scalable controllers - direct API server queries for every operation create performance bottlenecks</td>\n</tr>\n<tr>\n<td><strong>Shared Index Informer</strong></td>\n<td>Informer implementation that allows multiple controllers to share the same cache and watch streams, reducing memory usage and API server load</td>\n<td>Multiple controllers can efficiently watch the same resource types - separate informers waste memory and network bandwidth</td>\n</tr>\n<tr>\n<td><strong>List-Watch Pattern</strong></td>\n<td>API pattern where clients first list all resources then watch for subsequent changes, providing consistent event streams</td>\n<td>Foundation of Kubernetes event system - understanding this helps debug informer sync issues and cache inconsistencies</td>\n</tr>\n<tr>\n<td><strong>Resync Period</strong></td>\n<td>Interval at which informers re-list all resources to ensure cache consistency and recover from missed events</td>\n<td>Balances cache freshness with API server load - too frequent causes load, too infrequent causes stale cache issues</td>\n</tr>\n<tr>\n<td><strong>Cache Sync</strong></td>\n<td>Process where informer cache becomes consistent with API server state before processing events, ensuring controllers don&#39;t act on incomplete data</td>\n<td>Controllers must wait for cache sync - processing events before sync completion can cause incorrect reconciliation decisions</td>\n</tr>\n<tr>\n<td><strong>Index Function</strong></td>\n<td>Custom function that creates secondary indexes on cached resources for efficient lookups by fields other than name/namespace</td>\n<td>Enables efficient queries like &quot;find all pods with label X&quot; - missing indexes force expensive linear searches</td>\n</tr>\n<tr>\n<td><strong>Event Handler</strong></td>\n<td>Function called when informer detects resource changes, typically enqueueing reconcile requests for later processing</td>\n<td>Bridges informer events to controller work queues - blocking in event handlers causes event processing delays</td>\n</tr>\n</tbody></table>\n<h3 id=\"work-queue-and-scheduling\">Work Queue and Scheduling</h3>\n<p>Work queues provide reliable, ordered processing of reconciliation requests with proper error handling and rate limiting.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Why It Matters</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Work Queue</strong></td>\n<td>Thread-safe queue that buffers reconcile requests and provides features like rate limiting, exponential backoff, and duplicate detection</td>\n<td>Prevents overwhelming controllers with requests - poor queue management causes performance problems and resource exhaustion</td>\n</tr>\n<tr>\n<td><strong>Rate Limiting</strong></td>\n<td>Mechanism that controls how frequently items can be processed from the work queue, preventing resource exhaustion during high load</td>\n<td>Protects controllers and API server from overload - missing rate limiting can cause cascade failures</td>\n</tr>\n<tr>\n<td><strong>Exponential Backoff</strong></td>\n<td>Retry strategy that increases delay between attempts exponentially, preventing overwhelming failing systems with repeated requests</td>\n<td>Essential for handling transient failures gracefully - linear backoff can worsen system overload conditions</td>\n</tr>\n<tr>\n<td><strong>Jitter</strong></td>\n<td>Random variation added to retry delays to prevent multiple controllers from retrying simultaneously and creating thundering herd effects</td>\n<td>Distributes retry load over time - without jitter, synchronized retries can overwhelm recovering systems</td>\n</tr>\n<tr>\n<td><strong>Requeue</strong></td>\n<td>Operation that adds a reconcile request back to the work queue for processing after a delay, used for retry logic and periodic reconciliation</td>\n<td>Enables robust error handling and state drift correction - improper requeue logic causes infinite loops or missed updates</td>\n</tr>\n<tr>\n<td><strong>Deduplication</strong></td>\n<td>Work queue feature that prevents duplicate reconcile requests for the same resource from being processed simultaneously</td>\n<td>Improves efficiency and prevents conflicting reconciliation attempts - missing deduplication wastes controller resources</td>\n</tr>\n</tbody></table>\n<h3 id=\"reconciliation-logic-patterns\">Reconciliation Logic Patterns</h3>\n<p>These patterns describe common approaches for implementing robust reconciliation logic that handles complex state management scenarios.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Why It Matters</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Idempotent Operation</strong></td>\n<td>Operation that produces the same result when called multiple times with the same input, essential for reliable reconciliation</td>\n<td>Controllers may reconcile the same resource multiple times - non-idempotent operations cause inconsistent state</td>\n</tr>\n<tr>\n<td><strong>Three-Way Merge</strong></td>\n<td>Reconciliation pattern that compares desired state, current state, and last-applied state to determine minimal changes needed</td>\n<td>Enables efficient updates that preserve user modifications while applying operator changes</td>\n</tr>\n<tr>\n<td><strong>Drift Detection</strong></td>\n<td>Process of identifying when actual state has diverged from desired state due to external changes or system issues</td>\n<td>Allows operators to correct configuration drift - without drift detection, external changes persist indefinitely</td>\n</tr>\n<tr>\n<td><strong>State Machine</strong></td>\n<td>Model where resources transition through well-defined states with specific triggers and actions for each transition</td>\n<td>Simplifies complex lifecycle management - ad-hoc state handling leads to bugs and unpredictable behavior</td>\n</tr>\n<tr>\n<td><strong>Condition Types</strong></td>\n<td>Standardized status fields that report specific aspects of resource state like <code>Ready</code>, <code>Progressing</code>, and <code>Degraded</code></td>\n<td>Provides consistent status reporting across different resource types - improper condition usage confuses users</td>\n</tr>\n<tr>\n<td><strong>Phase</strong></td>\n<td>High-level resource lifecycle state like <code>Pending</code>, <code>Running</code>, <code>Failed</code> that summarizes overall resource condition</td>\n<td>Gives users quick understanding of resource health - inconsistent phase reporting makes troubleshooting difficult</td>\n</tr>\n<tr>\n<td><strong>Generation</strong></td>\n<td>Counter that increments when resource spec changes, used to track which changes have been processed</td>\n<td>Helps controllers track which spec changes they&#39;ve reconciled - ignoring generation can cause missed updates</td>\n</tr>\n<tr>\n<td><strong>Observed Generation</strong></td>\n<td>Generation number that controller has successfully processed, reported in resource status</td>\n<td>Shows users that their spec changes have been applied - missing observed generation updates confuse users about operator responsiveness</td>\n</tr>\n</tbody></table>\n<h3 id=\"admission-control-and-webhooks\">Admission Control and Webhooks</h3>\n<p>Admission webhooks provide validation and mutation capabilities that run during resource creation and updates, implementing the &quot;gatekeeper pattern&quot; for resource operations.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Why It Matters</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Admission Controller</strong></td>\n<td>Component in Kubernetes API server request processing pipeline that can validate, mutate, or deny resource operations</td>\n<td>Understanding admission flow helps design webhooks that integrate properly with other admission controllers</td>\n</tr>\n<tr>\n<td><strong>Admission Webhook</strong></td>\n<td>HTTP endpoint that receives admission review requests from the API server to validate or mutate resources before they are stored</td>\n<td>Extends Kubernetes with custom validation and defaulting logic - webhook failures can block all resource operations</td>\n</tr>\n<tr>\n<td><strong>Validating Webhook</strong></td>\n<td>Admission webhook that can approve or deny resource operations but cannot modify the resources being processed</td>\n<td>Enforces business rules and constraints - failing validation provides immediate feedback to users</td>\n</tr>\n<tr>\n<td><strong>Mutating Webhook</strong></td>\n<td>Admission webhook that can modify resources before they are stored in etcd, typically used for injecting default values</td>\n<td>Provides consistent defaulting and transformation - mutation order matters when multiple webhooks modify the same resource</td>\n</tr>\n<tr>\n<td><strong>Admission Review</strong></td>\n<td>Kubernetes API object containing resource data and metadata that is sent to webhooks for processing</td>\n<td>Understanding this structure is essential for implementing webhook handlers correctly</td>\n</tr>\n<tr>\n<td><strong>Admission Response</strong></td>\n<td>Object returned by webhooks indicating whether to allow the operation and any mutations to apply</td>\n<td>Proper response formatting ensures API server processes webhook decisions correctly</td>\n</tr>\n<tr>\n<td><strong>JSON Patch</strong></td>\n<td>RFC 6902 standard for describing changes to JSON documents using operations like add, replace, and remove</td>\n<td>Mutating webhooks use JSON patches to specify resource modifications - incorrect patches cause admission failures</td>\n</tr>\n<tr>\n<td><strong>Strategic Merge Patch</strong></td>\n<td>Kubernetes-specific patch format that understands resource schema and can merge lists intelligently</td>\n<td>Used internally by kubectl and controllers for resource updates - understanding helps debug update conflicts</td>\n</tr>\n</tbody></table>\n<h3 id=\"tls-and-certificate-management\">TLS and Certificate Management</h3>\n<p>Webhooks require HTTPS communication, making certificate management a critical operational concern for operators.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Why It Matters</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>TLS Certificate</strong></td>\n<td>X.509 certificate used to establish encrypted HTTPS connections between API server and admission webhooks</td>\n<td>Required for webhook security - certificate issues prevent webhook operations and can block cluster operations</td>\n</tr>\n<tr>\n<td><strong>Certificate Authority (CA)</strong></td>\n<td>Entity that signs certificates, establishing trust relationships for TLS connections</td>\n<td>Webhook certificates must be trusted by the API server - CA configuration errors prevent webhook communication</td>\n</tr>\n<tr>\n<td><strong>Subject Alternative Name (SAN)</strong></td>\n<td>Certificate extension that specifies additional identities the certificate is valid for, including DNS names and IP addresses</td>\n<td>Webhook certificates must have correct SAN entries for service names - missing SANs cause TLS verification failures</td>\n</tr>\n<tr>\n<td><strong>Certificate Rotation</strong></td>\n<td>Process of automatically renewing and replacing TLS certificates before they expire to maintain service availability</td>\n<td>Prevents webhook outages from certificate expiration - manual certificate management is error-prone and operationally expensive</td>\n</tr>\n<tr>\n<td><strong>Cert-Manager</strong></td>\n<td>Kubernetes operator that automates certificate lifecycle management including provisioning, renewal, and distribution</td>\n<td>Simplifies webhook certificate management - manual certificate handling creates operational burden</td>\n</tr>\n<tr>\n<td><strong>Self-Signed Certificate</strong></td>\n<td>Certificate signed by its own private key rather than a certificate authority, useful for development and testing</td>\n<td>Acceptable for development but requires careful CA bundle management - production should use proper CA-signed certificates</td>\n</tr>\n</tbody></table>\n<h3 id=\"error-handling-and-reliability-patterns\">Error Handling and Reliability Patterns</h3>\n<p>Robust operators must handle various failure modes gracefully while maintaining system stability and providing clear diagnostics.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Why It Matters</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Transient Error</strong></td>\n<td>Temporary failure that is likely to succeed if retried after a delay, such as network timeouts or resource conflicts</td>\n<td>Should trigger exponential backoff retry - treating transient errors as permanent wastes reconciliation opportunities</td>\n</tr>\n<tr>\n<td><strong>Permanent Error</strong></td>\n<td>Failure that will not succeed if retried without external intervention, such as validation errors or missing permissions</td>\n<td>Should not trigger automatic retry - permanent error retry wastes resources and creates noise in logs</td>\n</tr>\n<tr>\n<td><strong>Circuit Breaker</strong></td>\n<td>Pattern that temporarily stops calling a failing service to prevent cascading failures and allow recovery time</td>\n<td>Protects external dependencies from overload - missing circuit breakers can cause widespread system failures</td>\n</tr>\n<tr>\n<td><strong>Graceful Degradation</strong></td>\n<td>Approach where systems continue operating with reduced functionality when components fail rather than failing completely</td>\n<td>Maintains service availability during partial failures - brittle systems cause unnecessary outages</td>\n</tr>\n<tr>\n<td><strong>Error Classification</strong></td>\n<td>Process of categorizing errors by type, severity, and appropriate response to enable proper handling strategies</td>\n<td>Enables appropriate retry and escalation behavior - poor error classification leads to incorrect recovery actions</td>\n</tr>\n<tr>\n<td><strong>Leader Election</strong></td>\n<td>Distributed coordination mechanism that ensures only one controller replica actively reconciles resources at any time</td>\n<td>Prevents split-brain scenarios in high availability deployments - missing leader election causes resource conflicts</td>\n</tr>\n<tr>\n<td><strong>Lease Object</strong></td>\n<td>Kubernetes resource used for leader election coordination, containing holder identity and renewal timestamp</td>\n<td>Provides distributed locking primitive - lease configuration affects failover time and split-brain risk</td>\n</tr>\n</tbody></table>\n<h3 id=\"testing-and-validation-concepts\">Testing and Validation Concepts</h3>\n<p>Comprehensive testing ensures operator reliability and helps catch regressions during development and maintenance.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Why It Matters</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Fake Client</strong></td>\n<td>Test implementation of Kubernetes client that simulates API server behavior without requiring a real cluster</td>\n<td>Enables fast unit tests that verify controller logic in isolation - real cluster tests are slow and harder to control</td>\n</tr>\n<tr>\n<td><strong>Envtest</strong></td>\n<td>Testing framework that runs a real Kubernetes API server in-process for integration testing without full cluster setup</td>\n<td>Provides realistic testing environment without operational complexity - catches integration issues that unit tests miss</td>\n</tr>\n<tr>\n<td><strong>Test Double</strong></td>\n<td>Generic term for fake objects used in testing, including mocks, stubs, and fakes</td>\n<td>Isolates code under test from dependencies - improper test doubles can hide real integration problems</td>\n</tr>\n<tr>\n<td><strong>Contract Test</strong></td>\n<td>Test that verifies component interfaces and behavior contracts without testing implementation details</td>\n<td>Ensures components integrate correctly - implementation-focused tests break when refactoring</td>\n</tr>\n<tr>\n<td><strong>Chaos Testing</strong></td>\n<td>Testing approach that introduces random failures to verify system resilience and recovery behavior</td>\n<td>Validates error handling and recovery logic - systems often fail in unexpected ways during real outages</td>\n</tr>\n<tr>\n<td><strong>Property-Based Testing</strong></td>\n<td>Testing technique that verifies system properties hold across a wide range of generated inputs</td>\n<td>Finds edge cases that example-based tests miss - especially valuable for testing reconciliation logic</td>\n</tr>\n</tbody></table>\n<h3 id=\"deployment-and-operations\">Deployment and Operations</h3>\n<p>Production operators require careful attention to security, observability, and operational concerns beyond basic functionality.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Why It Matters</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Principle of Least Privilege</strong></td>\n<td>Security practice of granting the minimum permissions necessary for operation, reducing blast radius of security breaches</td>\n<td>Minimizes security risk from compromised operator - overly broad permissions increase attack surface</td>\n</tr>\n<tr>\n<td><strong>ClusterRole vs Role</strong></td>\n<td>RBAC distinction between cluster-scoped permissions (ClusterRole) and namespace-scoped permissions (Role)</td>\n<td>Affects security isolation and operator deployment model - wrong scope causes permission errors or security violations</td>\n</tr>\n<tr>\n<td><strong>Service Account Token</strong></td>\n<td>JWT token that provides authentication credentials for processes running in pods</td>\n<td>Enables operator authentication with API server - token management affects security and reliability</td>\n</tr>\n<tr>\n<td><strong>Pod Security Standards</strong></td>\n<td>Kubernetes security policies that control pod security contexts and capabilities</td>\n<td>Affects how operator pods can run - restrictive policies may prevent operator functionality</td>\n</tr>\n<tr>\n<td><strong>Resource Quota</strong></td>\n<td>Kubernetes mechanism that limits resource consumption within namespaces</td>\n<td>Can prevent operator from creating resources - understanding quotas helps design operators that work within limits</td>\n</tr>\n<tr>\n<td><strong>Network Policy</strong></td>\n<td>Kubernetes resource that controls network traffic between pods using label selectors</td>\n<td>May affect operator communication with managed resources - network restrictions can cause unexpected failures</td>\n</tr>\n<tr>\n<td><strong>Observability</strong></td>\n<td>Practice of understanding system behavior through metrics, logging, and tracing</td>\n<td>Essential for operating production systems - poor observability makes troubleshooting difficult and time-consuming</td>\n</tr>\n</tbody></table>\n<h3 id=\"performance-and-scaling-concepts\">Performance and Scaling Concepts</h3>\n<p>As operators manage more resources, performance and scaling considerations become increasingly important for maintaining system stability.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Why It Matters</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Horizontal Scaling</strong></td>\n<td>Adding more controller instances to handle increased load by distributing work across multiple processes</td>\n<td>Increases processing capacity for large resource counts - requires careful coordination to prevent conflicts</td>\n</tr>\n<tr>\n<td><strong>Vertical Scaling</strong></td>\n<td>Increasing computational resources (CPU, memory) for individual controller instances to handle more work</td>\n<td>Simpler than horizontal scaling but has physical limits - helps handle resource-intensive reconciliation logic</td>\n</tr>\n<tr>\n<td><strong>Sharding</strong></td>\n<td>Technique for partitioning resources across multiple controller instances based on criteria like namespace or resource hash</td>\n<td>Enables horizontal scaling without resource conflicts - poor sharding strategies cause load imbalances</td>\n</tr>\n<tr>\n<td><strong>Back Pressure</strong></td>\n<td>Mechanism where overloaded components signal upstream components to slow down request rates</td>\n<td>Prevents cascading failures during high load - missing back pressure can cause system-wide overload</td>\n</tr>\n<tr>\n<td><strong>Resource Pooling</strong></td>\n<td>Pattern where expensive resources like database connections are shared across multiple operations</td>\n<td>Improves efficiency and reduces resource usage - poor pooling causes resource exhaustion</td>\n</tr>\n<tr>\n<td><strong>Batch Processing</strong></td>\n<td>Technique for grouping multiple operations together to reduce overhead and improve throughput</td>\n<td>Reduces API server load and improves performance - batching must balance latency with efficiency</td>\n</tr>\n</tbody></table>\n<h3 id=\"advanced-operator-patterns\">Advanced Operator Patterns</h3>\n<p>These patterns enable sophisticated operator behaviors for complex application management scenarios.</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Why It Matters</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Operator Composition</strong></td>\n<td>Pattern where multiple operators coordinate to manage related resources without conflicts</td>\n<td>Enables modular operator design - poor composition causes resource conflicts and inconsistent behavior</td>\n</tr>\n<tr>\n<td><strong>Cross-Controller Coordination</strong></td>\n<td>Communication and synchronization between different controllers managing related resources</td>\n<td>Prevents conflicts when multiple controllers affect the same resources - missing coordination causes race conditions</td>\n</tr>\n<tr>\n<td><strong>Multi-Tenant Operator</strong></td>\n<td>Operator design that safely manages resources for multiple users or teams within the same cluster</td>\n<td>Enables shared operator infrastructure - poor multi-tenancy creates security and isolation issues</td>\n</tr>\n<tr>\n<td><strong>Operator Lifecycle Management</strong></td>\n<td>Practices for managing operator installation, upgrades, and removal without disrupting managed applications</td>\n<td>Ensures smooth operator evolution - poor lifecycle management causes service disruptions during updates</td>\n</tr>\n<tr>\n<td><strong>Extension Points</strong></td>\n<td>Architectural patterns that allow new functionality to be added to operators without modifying core code</td>\n<td>Enables customization and ecosystem development - rigid operators are difficult to extend for specific use cases</td>\n</tr>\n<tr>\n<td><strong>Federation</strong></td>\n<td>Pattern for managing resources across multiple Kubernetes clusters from a single control point</td>\n<td>Enables multi-cluster operations - federation adds significant complexity and failure modes</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-anti-patterns-and-pitfalls\">Common Anti-Patterns and Pitfalls</h3>\n<p>Understanding what not to do is often as important as knowing correct approaches. These anti-patterns cause common operator reliability and performance issues.</p>\n<table>\n<thead>\n<tr>\n<th>Anti-Pattern</th>\n<th>Description</th>\n<th>Why It&#39;s Problematic</th>\n<th>How to Avoid</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Polling-Based Reconciliation</strong></td>\n<td>Continuously checking resource state on fixed intervals rather than using event-driven updates</td>\n<td>Wastes resources and responds slowly to changes</td>\n<td>Use informers and event-driven architecture</td>\n</tr>\n<tr>\n<td><strong>Blocking Reconciliation</strong></td>\n<td>Performing long-running operations synchronously in reconciliation logic without timeouts</td>\n<td>Causes controller hangs and prevents processing other resources</td>\n<td>Use asynchronous operations with proper timeouts</td>\n</tr>\n<tr>\n<td><strong>Status Thrashing</strong></td>\n<td>Repeatedly updating resource status with the same values or minor variations</td>\n<td>Creates unnecessary API server load and version conflicts</td>\n<td>Compare current and desired status before updating</td>\n</tr>\n<tr>\n<td><strong>Infinite Reconciliation</strong></td>\n<td>Reconciliation logic that always finds differences and requeues indefinitely</td>\n<td>Wastes resources and prevents controller from processing other work</td>\n<td>Ensure reconciliation can reach stable state</td>\n</tr>\n<tr>\n<td><strong>Missing Error Classification</strong></td>\n<td>Treating all errors the same way regardless of whether they&#39;re transient or permanent</td>\n<td>Causes inappropriate retry behavior and resource waste</td>\n<td>Classify errors and apply appropriate handling strategies</td>\n</tr>\n<tr>\n<td><strong>Overly Broad RBAC</strong></td>\n<td>Granting cluster-admin or excessive permissions to operators</td>\n<td>Creates security vulnerabilities and violates least privilege</td>\n<td>Analyze required permissions and grant minimum necessary</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Understanding operator terminology is essential, but applying these concepts correctly requires practical knowledge of how they map to actual code and configuration. This section provides concrete guidance for implementing the concepts defined above.</p>\n<h4 id=\"technology-recommendations-for-operator-development\">Technology Recommendations for Operator Development</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Framework</strong></td>\n<td>Raw client-go with manual informer setup</td>\n<td>Kubebuilder or Operator SDK with scaffolding</td>\n</tr>\n<tr>\n<td><strong>Testing</strong></td>\n<td>Standard go test with fake client</td>\n<td>Ginkgo + Gomega with envtest integration</td>\n</tr>\n<tr>\n<td><strong>Logging</strong></td>\n<td>Standard log package</td>\n<td>Structured logging with logr interface</td>\n</tr>\n<tr>\n<td><strong>Metrics</strong></td>\n<td>Basic HTTP /metrics endpoint</td>\n<td>Prometheus metrics with controller-runtime</td>\n</tr>\n<tr>\n<td><strong>Webhooks</strong></td>\n<td>Manual HTTP server with TLS</td>\n<td>Kubebuilder webhook generation</td>\n</tr>\n<tr>\n<td><strong>RBAC</strong></td>\n<td>Manual role definitions</td>\n<td>RBAC markers with automated generation</td>\n</tr>\n</tbody></table>\n<h4 id=\"essential-go-packages-for-kubernetes-operators\">Essential Go Packages for Kubernetes Operators</h4>\n<p>The Kubernetes ecosystem provides several packages that implement the concepts defined in this glossary. Understanding which packages provide which functionality helps you build operators efficiently.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Core Kubernetes client libraries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/client-go/kubernetes</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">           // Typed client for built-in resources</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/client-go/dynamic</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">              // Dynamic client for custom resources</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/client-go/tools/cache</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">          // Informer and caching infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/client-go/util/workqueue</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">       // Rate-limited work queue implementation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/client-go/tools/leaderelection</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\"> // Leader election coordination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Controller runtime - higher-level abstractions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/manager</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">    // Manager orchestrates controllers</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/controller</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\"> // Controller registration and setup</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/reconcile</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">  // Reconciler interface definition</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/webhook</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">    // Admission webhook framework</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/client</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">     // Unified client interface</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Testing infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/envtest</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">    // Integration testing with real API server</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">k8s.io/client-go/kubernetes/fake</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\">              // Fake client for unit testing</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sigs.k8s.io/controller-runtime/pkg/client/fake</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\"> // Fake client with controller-runtime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"project-structure-for-operator-development\">Project Structure for Operator Development</h4>\n<p>Organizing operator code properly from the start prevents confusion as the project grows. This structure follows Kubernetes conventions and separates concerns appropriately.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>database-operator/\n├── cmd/\n│   └── manager/\n│       └── main.go                    # Operator entry point and manager setup\n├── api/\n│   └── v1/\n│       ├── database_types.go          # Custom resource type definitions\n│       ├── database_webhook.go        # Admission webhook implementations\n│       ├── zz_generated.deepcopy.go   # Generated deep copy methods\n│       └── groupversion_info.go       # API group and version metadata\n├── controllers/\n│   ├── database_controller.go         # Main reconciliation logic\n│   ├── database_controller_test.go    # Controller unit tests\n│   └── suite_test.go                  # Test suite setup with envtest\n├── webhooks/\n│   ├── admission_handler.go           # HTTP server for admission webhooks\n│   ├── certificate_manager.go         # TLS certificate management\n│   └── webhook_test.go                # Webhook integration tests\n├── pkg/\n│   ├── resources/                     # Resource creation and management utilities\n│   ├── conditions/                    # Condition management helpers\n│   └── errors/                        # Error classification and handling\n├── config/\n│   ├── crd/                          # Custom Resource Definition manifests\n│   ├── rbac/                         # Role and ServiceAccount definitions\n│   ├── webhook/                      # Webhook configuration manifests\n│   ├── manager/                      # Deployment and service manifests\n│   └── samples/                      # Example custom resource instances\n├── hack/\n│   ├── boilerplate.go.txt           # License header template\n│   └── tools.go                     # Build tool dependency management\n└── Makefile                         # Build, test, and deployment automation</code></pre></div>\n\n<h4 id=\"core-type-definitions\">Core Type Definitions</h4>\n<p>Understanding how the terminology maps to actual Go types helps bridge the gap between concepts and implementation. These definitions show the essential structures every operator needs.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Reconciler implements the core reconciliation logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseReconciler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    client</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#6A737D\">                    // Kubernetes API client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Scheme </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">runtime</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Scheme</span><span style=\"color:#6A737D\">          // Resource type registry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Recorder </span><span style=\"color:#B392F0\">record</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">EventRecorder</span><span style=\"color:#6A737D\">   // Event recording for observability</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Reconcile implements the reconciliation loop for Database resources</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Reconcile</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">req</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement reconciliation logic following control loop pattern</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Fetch current Database resource and handle not found errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Determine desired state from Database spec</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Compare actual state with desired state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create, update, or delete resources to eliminate differences</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update Database status with current conditions and state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return appropriate Result for requeue or completion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"debugging-command-reference\">Debugging Command Reference</h4>\n<p>When implementing operators, these commands help diagnose common issues by examining the cluster state and operator behavior.</p>\n<table>\n<thead>\n<tr>\n<th>Issue Type</th>\n<th>Diagnostic Command</th>\n<th>What It Shows</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>CRD Issues</strong></td>\n<td><code>kubectl get crd databases.example.com -o yaml</code></td>\n<td>CRD definition, status, and validation schema</td>\n</tr>\n<tr>\n<td><strong>Resource Status</strong></td>\n<td><code>kubectl describe database my-database</code></td>\n<td>Resource events, conditions, and status details</td>\n</tr>\n<tr>\n<td><strong>Controller Logs</strong></td>\n<td><code>kubectl logs -n operator-system controller-manager-xxx</code></td>\n<td>Reconciliation events and error messages</td>\n</tr>\n<tr>\n<td><strong>Webhook Issues</strong></td>\n<td><code>kubectl get validatingwebhookconfigurations</code></td>\n<td>Webhook registration and configuration</td>\n</tr>\n<tr>\n<td><strong>RBAC Problems</strong></td>\n<td><code>kubectl auth can-i create databases --as=system:serviceaccount:operator-system:controller</code></td>\n<td>Permission verification</td>\n</tr>\n<tr>\n<td><strong>Informer Cache</strong></td>\n<td>Look for &quot;Failed to sync cache&quot; in controller logs</td>\n<td>Cache synchronization problems</td>\n</tr>\n<tr>\n<td><strong>Leader Election</strong></td>\n<td><code>kubectl get leases -n operator-system</code></td>\n<td>Current leader and lease status</td>\n</tr>\n</tbody></table>\n<h4 id=\"common-implementation-patterns\">Common Implementation Patterns</h4>\n<p>These code patterns implement the concepts defined in the glossary using idiomatic Go and Kubernetes conventions.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Error classification pattern for retry logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HandleReconcileError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Database</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> IsTransientError</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Transient errors should be retried with exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">{RequeueAfter: </span><span style=\"color:#B392F0\">CalculateBackoffDelay</span><span style=\"color:#E1E4E8\">(err)}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> IsPermanentError</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Permanent errors should update status but not requeue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        r.</span><span style=\"color:#B392F0\">updateCondition</span><span style=\"color:#E1E4E8\">(db, </span><span style=\"color:#9ECBFF\">\"Ready\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"False\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"ConfigurationError\"</span><span style=\"color:#E1E4E8\">, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">{}, r.</span><span style=\"color:#B392F0\">Status</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(ctx, db)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Unknown errors are treated as transient</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> ctrl</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Result</span><span style=\"color:#E1E4E8\">{RequeueAfter: DefaultRequeueDelay}, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Idempotent resource creation pattern</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DatabaseReconciler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">createOrUpdateResource</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">desired</span><span style=\"color:#B392F0\"> client</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Object</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    existing </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> desired.</span><span style=\"color:#B392F0\">DeepCopyObject</span><span style=\"color:#E1E4E8\">().(</span><span style=\"color:#B392F0\">client</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Object</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(ctx, client.</span><span style=\"color:#B392F0\">ObjectKeyFromObject</span><span style=\"color:#E1E4E8\">(desired), existing)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> apierrors.</span><span style=\"color:#B392F0\">IsNotFound</span><span style=\"color:#E1E4E8\">(err) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Resource doesn't exist - create it</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">Create</span><span style=\"color:#E1E4E8\">(ctx, desired)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Resource exists - update if different</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">reflect.</span><span style=\"color:#B392F0\">DeepEqual</span><span style=\"color:#E1E4E8\">(existing, desired) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        desired.</span><span style=\"color:#B392F0\">SetResourceVersion</span><span style=\"color:#E1E4E8\">(existing.</span><span style=\"color:#B392F0\">GetResourceVersion</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> r.</span><span style=\"color:#B392F0\">Update</span><span style=\"color:#E1E4E8\">(ctx, desired)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\"> // No changes needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-validation-checkpoints\">Milestone Validation Checkpoints</h4>\n<p>After implementing operator components, these checkpoints verify that the terminology concepts are working correctly in your implementation.</p>\n<p><strong>Controller Setup Validation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Verify informer cache synchronization</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> logs</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> operator-system</span><span style=\"color:#9ECBFF\"> controller-manager-xxx</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> \"Starting workers\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check work queue processing</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> logs</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> operator-system</span><span style=\"color:#9ECBFF\"> controller-manager-xxx</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> \"Successfully Reconciled\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Validate leader election</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> leases</span><span style=\"color:#79B8FF\"> -n</span><span style=\"color:#9ECBFF\"> operator-system</span></span></code></pre></div>\n\n<p><strong>Admission Webhook Validation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test validating webhook</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> -</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#9ECBFF\">EOF</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">apiVersion: example.com/v1</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">kind: Database</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">metadata:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  name: test-validation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">spec:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  replicas: -1  # Invalid value should be rejected</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">EOF</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test mutating webhook default injection</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> apply</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> -</span><span style=\"color:#F97583\"> &#x3C;&#x3C;</span><span style=\"color:#9ECBFF\">EOF</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">apiVersion: example.com/v1</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">kind: Database</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">metadata:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  name: test-defaulting</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">spec:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  replicas: 3</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  # version field omitted - should be defaulted</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">EOF</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> database</span><span style=\"color:#9ECBFF\"> test-defaulting</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> yaml</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> version</span></span></code></pre></div>\n\n<p><strong>Status and Condition Validation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Check condition updates</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> database</span><span style=\"color:#9ECBFF\"> my-database</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> jsonpath='{.status.conditions[*].type}'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify observed generation tracking</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">kubectl</span><span style=\"color:#9ECBFF\"> get</span><span style=\"color:#9ECBFF\"> database</span><span style=\"color:#9ECBFF\"> my-database</span><span style=\"color:#79B8FF\"> -o</span><span style=\"color:#9ECBFF\"> jsonpath='{.metadata.generation} {.status.observedGeneration}'</span></span></code></pre></div>\n\n<p>These validation steps ensure your operator correctly implements the patterns and concepts defined in this glossary, providing confidence that the terminology translates to working code.</p>\n","toc":[{"level":1,"text":"Kubernetes Operator: Design Document","id":"kubernetes-operator-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: The Tireless System Administrator","id":"mental-model-the-tireless-system-administrator"},{"level":3,"text":"Existing Approaches Comparison","id":"existing-approaches-comparison"},{"level":4,"text":"Manual kubectl Operations","id":"manual-kubectl-operations"},{"level":4,"text":"Helm Charts and Package Managers","id":"helm-charts-and-package-managers"},{"level":4,"text":"Custom Scripts and Automation","id":"custom-scripts-and-automation"},{"level":3,"text":"Why the Operator Pattern","id":"why-the-operator-pattern"},{"level":4,"text":"Encoding Operational Knowledge","id":"encoding-operational-knowledge"},{"level":4,"text":"Self-Healing Infrastructure","id":"self-healing-infrastructure"},{"level":4,"text":"Integration with Kubernetes Ecosystem","id":"integration-with-kubernetes-ecosystem"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Project Structure","id":"recommended-project-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton","id":"core-logic-skeleton"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Functional Goals","id":"functional-goals"},{"level":4,"text":"Primary Resource Management Capabilities","id":"primary-resource-management-capabilities"},{"level":4,"text":"Declarative Configuration Management","id":"declarative-configuration-management"},{"level":4,"text":"Status Reporting and Observability","id":"status-reporting-and-observability"},{"level":3,"text":"Non-Functional Goals","id":"non-functional-goals"},{"level":4,"text":"Reliability and Fault Tolerance","id":"reliability-and-fault-tolerance"},{"level":4,"text":"Performance and Scalability","id":"performance-and-scalability"},{"level":4,"text":"Operational Integration","id":"operational-integration"},{"level":3,"text":"Explicit Non-Goals","id":"explicit-non-goals"},{"level":4,"text":"Data Management and Backup Operations","id":"data-management-and-backup-operations"},{"level":4,"text":"Advanced Deployment Strategies","id":"advanced-deployment-strategies"},{"level":4,"text":"Security and Access Control","id":"security-and-access-control"},{"level":4,"text":"Performance Tuning and Optimization","id":"performance-tuning-and-optimization"},{"level":3,"text":"Implementation Scope Summary","id":"implementation-scope-summary"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Recommended Project Structure","id":"recommended-project-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Overview","id":"component-overview"},{"level":3,"text":"Kubernetes API Integration","id":"kubernetes-api-integration"},{"level":3,"text":"Recommended Project Structure","id":"recommended-project-structure"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"File Structure Setup","id":"file-structure-setup"},{"level":4,"text":"Core Type Definitions","id":"core-type-definitions"},{"level":4,"text":"Controller Foundation","id":"controller-foundation"},{"level":4,"text":"Webhook Skeleton","id":"webhook-skeleton"},{"level":4,"text":"Language-Specific Development Tips","id":"language-specific-development-tips"},{"level":2,"text":"Data Model and Custom Resources","id":"data-model-and-custom-resources"},{"level":3,"text":"Mental Model: The Application Blueprint","id":"mental-model-the-application-blueprint"},{"level":3,"text":"Custom Resource Definition Schema","id":"custom-resource-definition-schema"},{"level":3,"text":"Validation and Defaulting Strategy","id":"validation-and-defaulting-strategy"},{"level":3,"text":"API Versioning and Evolution","id":"api-versioning-and-evolution"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Controller and Reconciliation Engine","id":"controller-and-reconciliation-engine"},{"level":3,"text":"Mental Model: The Control System","id":"mental-model-the-control-system"},{"level":3,"text":"Informer and Caching Architecture","id":"informer-and-caching-architecture"},{"level":3,"text":"Reconciliation Algorithm","id":"reconciliation-algorithm"},{"level":3,"text":"Error Handling and Requeue Strategy","id":"error-handling-and-requeue-strategy"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Admission Control with Webhooks","id":"admission-control-with-webhooks"},{"level":3,"text":"Mental Model: The Gatekeeper","id":"mental-model-the-gatekeeper"},{"level":3,"text":"Validating Webhook Implementation","id":"validating-webhook-implementation"},{"level":3,"text":"Mutating Webhook Implementation","id":"mutating-webhook-implementation"},{"level":3,"text":"TLS Certificate Management","id":"tls-certificate-management"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Component Interactions and Data Flow","id":"component-interactions-and-data-flow"},{"level":3,"text":"Mental Model: The Orchestra Conductor","id":"mental-model-the-orchestra-conductor"},{"level":3,"text":"Resource Creation Flow","id":"resource-creation-flow"},{"level":4,"text":"Pre-Storage Validation Pipeline","id":"pre-storage-validation-pipeline"},{"level":4,"text":"Mutating Webhook Processing","id":"mutating-webhook-processing"},{"level":4,"text":"Validating Webhook Processing","id":"validating-webhook-processing"},{"level":4,"text":"Storage and Initial Status","id":"storage-and-initial-status"},{"level":3,"text":"Update and Reconciliation Flow","id":"update-and-reconciliation-flow"},{"level":4,"text":"Spec Change Detection","id":"spec-change-detection"},{"level":4,"text":"Incremental Reconciliation Strategy","id":"incremental-reconciliation-strategy"},{"level":4,"text":"Status Update Propagation","id":"status-update-propagation"},{"level":3,"text":"Deletion and Cleanup Flow","id":"deletion-and-cleanup-flow"},{"level":4,"text":"Finalizer-Protected Deletion","id":"finalizer-protected-deletion"},{"level":4,"text":"Ordered Resource Cleanup","id":"ordered-resource-cleanup"},{"level":4,"text":"Backup and Data Protection","id":"backup-and-data-protection"},{"level":4,"text":"Cleanup Failure Recovery","id":"cleanup-failure-recovery"},{"level":4,"text":"Graceful Shutdown Coordination","id":"graceful-shutdown-coordination"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Mental Model: The Resilient Orchestra Conductor","id":"mental-model-the-resilient-orchestra-conductor"},{"level":2,"text":"Common Failure Modes","id":"common-failure-modes"},{"level":3,"text":"API Server Connectivity Failures","id":"api-server-connectivity-failures"},{"level":3,"text":"Webhook Processing Failures","id":"webhook-processing-failures"},{"level":3,"text":"Controller Process Failures","id":"controller-process-failures"},{"level":3,"text":"Resource Conflict Scenarios","id":"resource-conflict-scenarios"},{"level":2,"text":"Recovery and Self-Healing","id":"recovery-and-self-healing"},{"level":3,"text":"Automatic Retry Logic","id":"automatic-retry-logic"},{"level":3,"text":"Leader Election Failover","id":"leader-election-failover"},{"level":3,"text":"State Reconstruction from Cluster State","id":"state-reconstruction-from-cluster-state"},{"level":2,"text":"Consistency and Conflict Resolution","id":"consistency-and-conflict-resolution"},{"level":3,"text":"Handling Concurrent Updates","id":"handling-concurrent-updates"},{"level":3,"text":"Optimistic Locking Patterns","id":"optimistic-locking-patterns"},{"level":3,"text":"Eventual Consistency Expectations","id":"eventual-consistency-expectations"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Error Classification Infrastructure","id":"error-classification-infrastructure"},{"level":4,"text":"Robust Reconciliation Loop Skeleton","id":"robust-reconciliation-loop-skeleton"},{"level":4,"text":"Webhook Error Handling Infrastructure","id":"webhook-error-handling-infrastructure"},{"level":4,"text":"TLS Certificate Management","id":"tls-certificate-management"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Testing Strategy and Validation","id":"testing-strategy-and-validation"},{"level":3,"text":"Mental Model: The Quality Assurance Laboratory","id":"mental-model-the-quality-assurance-laboratory"},{"level":2,"text":"Unit Testing with Fake Clients","id":"unit-testing-with-fake-clients"},{"level":3,"text":"Core Testing Components","id":"core-testing-components"},{"level":3,"text":"Testing Reconciliation Logic","id":"testing-reconciliation-logic"},{"level":3,"text":"Fake Client Configuration and Setup","id":"fake-client-configuration-and-setup"},{"level":3,"text":"Status Update Validation","id":"status-update-validation"},{"level":3,"text":"Error Handling and Requeue Testing","id":"error-handling-and-requeue-testing"},{"level":3,"text":"Testing Finalizer Logic","id":"testing-finalizer-logic"},{"level":3,"text":"Common Unit Testing Pitfalls","id":"common-unit-testing-pitfalls"},{"level":2,"text":"Integration Testing with Envtest","id":"integration-testing-with-envtest"},{"level":3,"text":"Envtest Environment Setup","id":"envtest-environment-setup"},{"level":3,"text":"Controller Manager Integration","id":"controller-manager-integration"},{"level":3,"text":"End-to-End Reconciliation Testing","id":"end-to-end-reconciliation-testing"},{"level":3,"text":"Testing Concurrent Reconciliation","id":"testing-concurrent-reconciliation"},{"level":3,"text":"Webhook Integration Testing","id":"webhook-integration-testing"},{"level":3,"text":"Performance and Load Testing","id":"performance-and-load-testing"},{"level":3,"text":"Common Integration Testing Pitfalls","id":"common-integration-testing-pitfalls"},{"level":2,"text":"Milestone Validation Checkpoints","id":"milestone-validation-checkpoints"},{"level":3,"text":"Milestone 1: Custom Resource Definition Validation","id":"milestone-1-custom-resource-definition-validation"},{"level":3,"text":"Milestone 2: Controller Setup Validation","id":"milestone-2-controller-setup-validation"},{"level":3,"text":"Milestone 3: Reconciliation Loop Validation","id":"milestone-3-reconciliation-loop-validation"},{"level":3,"text":"Milestone 4: Webhook Validation","id":"milestone-4-webhook-validation"},{"level":3,"text":"Milestone 5: Testing and Deployment Validation","id":"milestone-5-testing-and-deployment-validation"},{"level":3,"text":"Common Milestone Validation Pitfalls","id":"common-milestone-validation-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Complete Unit Testing Infrastructure","id":"complete-unit-testing-infrastructure"},{"level":4,"text":"Core Reconciliation Test Skeleton","id":"core-reconciliation-test-skeleton"},{"level":4,"text":"Integration Testing with Controller Manager","id":"integration-testing-with-controller-manager"},{"level":4,"text":"Webhook Testing Infrastructure","id":"webhook-testing-infrastructure"},{"level":4,"text":"Milestone Validation Checkpoints","id":"milestone-validation-checkpoints"},{"level":2,"text":"Deployment and Operations","id":"deployment-and-operations"},{"level":3,"text":"RBAC and Security Model","id":"rbac-and-security-model"},{"level":4,"text":"Core Permission Requirements","id":"core-permission-requirements"},{"level":4,"text":"Owner References and Garbage Collection","id":"owner-references-and-garbage-collection"},{"level":4,"text":"Webhook RBAC Requirements","id":"webhook-rbac-requirements"},{"level":3,"text":"Container Packaging and Deployment","id":"container-packaging-and-deployment"},{"level":4,"text":"Container Image Strategy","id":"container-image-strategy"},{"level":4,"text":"Helm Chart Organization","id":"helm-chart-organization"},{"level":4,"text":"Environment Configuration Management","id":"environment-configuration-management"},{"level":3,"text":"High Availability and Leader Election","id":"high-availability-and-leader-election"},{"level":4,"text":"Leader Election Mechanics","id":"leader-election-mechanics"},{"level":4,"text":"Leader Election Configuration","id":"leader-election-configuration"},{"level":4,"text":"Failover and Recovery Behavior","id":"failover-and-recovery-behavior"},{"level":4,"text":"Monitoring and Observability for HA Deployments","id":"monitoring-and-observability-for-ha-deployments"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Complete RBAC Configuration","id":"complete-rbac-configuration"},{"level":4,"text":"Complete Deployment Configuration","id":"complete-deployment-configuration"},{"level":4,"text":"Core Leader Election Implementation","id":"core-leader-election-implementation"},{"level":4,"text":"Container Build Configuration","id":"container-build-configuration"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Controller and Reconciliation Issues","id":"controller-and-reconciliation-issues"},{"level":4,"text":"Reconciliation Loop Problems","id":"reconciliation-loop-problems"},{"level":4,"text":"Informer and Cache Problems","id":"informer-and-cache-problems"},{"level":4,"text":"Workqueue and Rate Limiting Issues","id":"workqueue-and-rate-limiting-issues"},{"level":3,"text":"Webhook and Admission Problems","id":"webhook-and-admission-problems"},{"level":4,"text":"Certificate and TLS Issues","id":"certificate-and-tls-issues"},{"level":4,"text":"Admission Review Processing","id":"admission-review-processing"},{"level":4,"text":"Webhook Timeout and Performance Issues","id":"webhook-timeout-and-performance-issues"},{"level":3,"text":"RBAC and Permissions Debugging","id":"rbac-and-permissions-debugging"},{"level":4,"text":"Service Account and Role Configuration","id":"service-account-and-role-configuration"},{"level":4,"text":"Permission Scope and Binding Issues","id":"permission-scope-and-binding-issues"},{"level":4,"text":"Runtime Permission Verification","id":"runtime-permission-verification"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Future Extensions and Evolution","id":"future-extensions-and-evolution"},{"level":3,"text":"Mental Model: The Living System","id":"mental-model-the-living-system"},{"level":3,"text":"Feature Extension Points","id":"feature-extension-points"},{"level":3,"text":"Mental Model: The Plugin Architecture","id":"mental-model-the-plugin-architecture"},{"level":4,"text":"Custom Resource Extensions","id":"custom-resource-extensions"},{"level":4,"text":"Controller Composition Strategies","id":"controller-composition-strategies"},{"level":4,"text":"Admission Webhook Composition","id":"admission-webhook-composition"},{"level":3,"text":"Scaling and Performance","id":"scaling-and-performance"},{"level":3,"text":"Mental Model: The Air Traffic Control System","id":"mental-model-the-air-traffic-control-system"},{"level":4,"text":"Horizontal Scaling Strategies","id":"horizontal-scaling-strategies"},{"level":4,"text":"Performance Optimization Strategies","id":"performance-optimization-strategies"},{"level":4,"text":"Multi-Cluster Operations","id":"multi-cluster-operations"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Project Structure","id":"recommended-project-structure"},{"level":4,"text":"Extension Development Framework","id":"extension-development-framework"},{"level":4,"text":"Sharding Implementation Framework","id":"sharding-implementation-framework"},{"level":4,"text":"Performance Monitoring Integration","id":"performance-monitoring-integration"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Mental Model: The Specialized Dictionary","id":"mental-model-the-specialized-dictionary"},{"level":3,"text":"Kubernetes Core Concepts","id":"kubernetes-core-concepts"},{"level":3,"text":"Controller Pattern Concepts","id":"controller-pattern-concepts"},{"level":3,"text":"Informer and Caching Architecture","id":"informer-and-caching-architecture"},{"level":3,"text":"Work Queue and Scheduling","id":"work-queue-and-scheduling"},{"level":3,"text":"Reconciliation Logic Patterns","id":"reconciliation-logic-patterns"},{"level":3,"text":"Admission Control and Webhooks","id":"admission-control-and-webhooks"},{"level":3,"text":"TLS and Certificate Management","id":"tls-and-certificate-management"},{"level":3,"text":"Error Handling and Reliability Patterns","id":"error-handling-and-reliability-patterns"},{"level":3,"text":"Testing and Validation Concepts","id":"testing-and-validation-concepts"},{"level":3,"text":"Deployment and Operations","id":"deployment-and-operations"},{"level":3,"text":"Performance and Scaling Concepts","id":"performance-and-scaling-concepts"},{"level":3,"text":"Advanced Operator Patterns","id":"advanced-operator-patterns"},{"level":3,"text":"Common Anti-Patterns and Pitfalls","id":"common-anti-patterns-and-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations for Operator Development","id":"technology-recommendations-for-operator-development"},{"level":4,"text":"Essential Go Packages for Kubernetes Operators","id":"essential-go-packages-for-kubernetes-operators"},{"level":4,"text":"Project Structure for Operator Development","id":"project-structure-for-operator-development"},{"level":4,"text":"Core Type Definitions","id":"core-type-definitions"},{"level":4,"text":"Debugging Command Reference","id":"debugging-command-reference"},{"level":4,"text":"Common Implementation Patterns","id":"common-implementation-patterns"},{"level":4,"text":"Milestone Validation Checkpoints","id":"milestone-validation-checkpoints"}],"title":"Kubernetes Operator: Design Document","markdown":"# Kubernetes Operator: Design Document\n\n\n## Overview\n\nThis system implements a Kubernetes operator that extends the cluster API with custom resources and automated reconciliation logic. The key architectural challenge is building a robust controller that watches cluster state, maintains desired configuration, and handles the complexities of distributed system failures while integrating seamlessly with Kubernetes' declarative model.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** All milestones - provides foundational understanding for the entire operator pattern\n\nManaging applications in Kubernetes can quickly become overwhelming as systems grow in complexity. While Kubernetes provides excellent primitives for deploying and running containers, it lacks built-in knowledge about how specific applications should behave, how they should respond to failures, or how they should be configured for optimal performance. This gap between Kubernetes' generic container orchestration and application-specific operational knowledge creates significant challenges for platform teams and application developers.\n\nThe fundamental problem is that **operational knowledge** - the accumulated wisdom about how to run, monitor, upgrade, backup, and troubleshoot applications - typically exists only in documentation, runbooks, and the minds of experienced operators. When incidents occur at 3 AM, or when applications need to be scaled or upgraded, human operators must manually translate this knowledge into a series of kubectl commands, configuration changes, and monitoring checks. This approach doesn't scale as organizations grow their Kubernetes footprint or as applications become more sophisticated.\n\nConsider a typical scenario: deploying a stateful application like a database cluster requires not just creating Deployments and Services, but also configuring persistent volumes, setting up replication, managing leader election, coordinating rolling updates without data loss, implementing backup schedules, monitoring cluster health, and handling various failure scenarios. Each of these operations requires deep understanding of both Kubernetes APIs and the application's specific requirements. When done manually, this process is error-prone, time-consuming, and difficult to reproduce consistently across environments.\n\n### Mental Model: The Tireless System Administrator\n\nTo understand what Kubernetes operators provide, imagine the most experienced system administrator on your team - someone who has managed complex applications for years, knows every configuration nuance, never makes typos, never forgets steps in procedures, and never needs sleep. This administrator sits in front of a terminal 24/7, continuously monitoring the state of all applications under their care.\n\nWhen this tireless administrator notices that a database replica has failed, they immediately spring into action: checking the health of remaining replicas, determining if the failure affects the primary, deciding whether to promote a new replica or wait for the failed one to recover, updating load balancer configurations if needed, sending alerts to the appropriate teams, and documenting the incident. They perform these actions not by following a rigid script, but by understanding the current state of the system, comparing it to the desired state, and taking the minimal necessary actions to close the gap.\n\nThis administrator never gets overwhelmed by multiple simultaneous issues because they process each situation methodically, always working from first principles: \"What should the system look like?\" and \"What's the smallest change I can make to get closer to that goal?\" They don't panic during outages, they don't skip steps during routine maintenance, and they learn from each incident to improve their procedures.\n\nA **Kubernetes operator** is essentially this tireless system administrator encoded as software. It continuously watches the actual state of resources in your cluster, compares that state to your declared intentions, and takes corrective actions when gaps are detected. It never gets tired, never forgets to check on things, and can manage dozens or hundreds of application instances simultaneously with perfect consistency.\n\nThe operator doesn't just monitor and react - it also embodies years of operational wisdom about the applications it manages. It knows that when scaling up a database cluster, replicas should be added one at a time with health checks between each addition. It understands that certain configuration changes require rolling restarts while others can be applied dynamically. It recognizes the difference between temporary network hiccups and genuine failures that require intervention.\n\nMost importantly, this tireless administrator is **declarative** rather than **imperative**. Instead of being told \"scale the database to 5 replicas, then update the configuration, then restart the monitoring agent,\" the operator is simply told \"I want a database cluster with 5 replicas running version 2.4.1 with monitoring enabled.\" The operator figures out the sequence of operations needed to make that desire a reality, handles any errors or unexpected conditions that arise, and continues working until the actual state matches the declared intent.\n\n### Existing Approaches Comparison\n\nBefore diving into why operators represent a superior approach, it's important to understand the landscape of existing solutions and their limitations. Each approach addresses part of the operational complexity problem, but none provides the complete solution that operators enable.\n\n#### Manual kubectl Operations\n\nThe most basic approach to managing Kubernetes applications involves manually crafting YAML manifests and applying them with kubectl. This approach gives operators complete control and transparency - every action is explicit and visible.\n\n| Aspect | Strengths | Weaknesses |\n|--------|-----------|------------|\n| **Control** | Complete visibility into every operation; no hidden abstractions | Requires deep Kubernetes expertise; prone to human error |\n| **Debugging** | Easy to trace exactly what resources exist and how they were created | No history of changes; difficult to understand why resources are in current state |\n| **Scalability** | Works well for simple applications with few resources | Doesn't scale beyond small numbers of applications or environments |\n| **Consistency** | Can achieve perfect consistency if procedures are followed exactly | Relies entirely on human discipline; no enforcement of procedures |\n| **Error Handling** | Operator can immediately see and respond to errors | All error detection and recovery is manual; easy to miss problems |\n\nThe fundamental limitation of manual operations is that they require constant human attention and perfect execution. Consider managing a multi-environment deployment: ensuring that the same sequence of operations is performed correctly in development, staging, and production environments requires meticulous documentation and discipline. When problems arise - a pod fails to start, a service becomes unreachable, or a configuration change has unexpected side effects - human operators must diagnose the issue and determine appropriate remediation steps.\n\nAs the number of applications and environments grows, manual operations become increasingly unsustainable. Teams spend more time on routine operational tasks and less time on developing new features or improving system reliability.\n\n#### Helm Charts and Package Managers\n\nHelm represents a significant improvement over manual operations by introducing templating, dependency management, and release lifecycle management. Helm charts package application resources into reusable units that can be customized for different environments through values files.\n\n| Aspect | Strengths | Weaknesses |\n|--------|-----------|------------|\n| **Reusability** | Charts can be shared and reused across teams and organizations | Limited to deployment-time configuration; no runtime adaptation |\n| **Templating** | Values files enable environment-specific customization | Complex applications require complex templating logic |\n| **Versioning** | Release management with rollback capabilities | Rollbacks are coarse-grained; can't handle partial failures gracefully |\n| **Ecosystem** | Large ecosystem of pre-built charts for common applications | Charts often make assumptions that don't fit specific use cases |\n| **Day-2 Operations** | Good for initial deployment and major updates | No ongoing lifecycle management; no automatic problem resolution |\n\nHelm excels at solving the **deployment** problem - packaging applications in a way that makes them easy to install, configure, and upgrade. However, Helm charts are fundamentally **installation tools**, not **operational tools**. Once a Helm release is deployed, it doesn't continue monitoring the application, responding to failures, or adapting to changing conditions.\n\nFor example, a Helm chart can deploy a database cluster with appropriate initial configuration, but it can't automatically scale the cluster based on load, replace failed replicas, perform routine maintenance tasks, or coordinate complex upgrade procedures that require specific sequences of operations.\n\n#### Custom Scripts and Automation\n\nMany organizations bridge the gap between manual operations and full automation by developing custom scripts, often integrated with CI/CD pipelines or scheduled as cron jobs. These scripts encode operational procedures and can perform routine maintenance tasks automatically.\n\n| Aspect | Strengths | Weaknesses |\n|--------|-----------|------------|\n| **Customization** | Scripts can encode organization-specific procedures perfectly | High maintenance overhead; scripts break as systems evolve |\n| **Integration** | Can integrate with existing monitoring and alerting systems | Often fragile and difficult to debug when problems occur |\n| **Automation** | Reduces manual toil for routine operations | Usually imperative; difficult to ensure idempotency |\n| **Knowledge Capture** | Procedures are documented in code rather than runbooks | Knowledge is scattered across many scripts with no unified model |\n| **Error Recovery** | Can include error handling and retry logic | Error handling is ad-hoc; difficult to handle all edge cases |\n\nThe primary challenge with custom scripts is that they tend to be **imperative** rather than **declarative**. A script might contain logic like \"if the database has fewer than 3 replicas, create a new one,\" but scripts struggle with more complex scenarios like \"ensure the database cluster is healthy and properly configured according to this specification.\"\n\nScripts also suffer from the **coordination problem**: multiple scripts running simultaneously can interfere with each other, leading to race conditions and inconsistent state. Without a unified control plane, it's difficult to ensure that all automation is working toward the same goals.\n\n### Why the Operator Pattern\n\nThe operator pattern addresses the fundamental limitations of existing approaches by treating **operational knowledge as code** and integrating deeply with Kubernetes' declarative architecture. Rather than viewing automation as a collection of scripts or deployment tools, operators embody the principle that application management should be as declarative and self-healing as the underlying Kubernetes platform.\n\n> **Design Insight:** The operator pattern succeeds because it aligns with Kubernetes' core philosophy: desired state should be declared, and the system should continuously work to make reality match that declaration. Operators extend this philosophy from basic Kubernetes resources to application-specific concerns.\n\n#### Encoding Operational Knowledge\n\nThe most significant advantage of operators is their ability to **encode operational knowledge directly into the control plane**. Instead of documenting procedures in runbooks that humans must execute, operators embed this knowledge into software that can execute procedures consistently and reliably.\n\nConsider the operational knowledge required to manage a database cluster:\n\n| Operational Concern | Traditional Approach | Operator Approach |\n|-------------------|---------------------|------------------|\n| **Scaling** | Runbook: \"Add replicas one at a time, wait for sync, update load balancer\" | Code: Reconciliation loop that creates replicas, monitors readiness, updates services |\n| **Failure Recovery** | Alert → Human investigates → Manual recovery steps | Automated detection → Self-healing → Human notified of resolution |\n| **Upgrades** | Maintenance window → Manual coordination → Hope nothing breaks | Rolling upgrade with automated rollback on failure detection |\n| **Configuration Changes** | Change management → Careful manual application → Monitor for issues | Declarative configuration → Automatic application → Drift detection |\n| **Backup Management** | Scheduled scripts → Manual verification → Hope backups work | Integrated backup scheduling → Automatic validation → Recovery testing |\n\nThis knowledge encoding provides several critical benefits:\n\n**Consistency**: The same operational procedures are executed identically every time, regardless of which team member initiated the action or what time of day it occurs. There's no variation in procedure execution based on operator experience or stress levels.\n\n**Auditability**: All operational actions are taken through the Kubernetes API and can be logged, monitored, and audited. The decision-making process is transparent and reproducible.\n\n**Testability**: Operational procedures can be tested in development environments before being applied to production. Complex scenarios like failure recovery can be validated through chaos engineering approaches.\n\n**Evolution**: Operational knowledge improves over time as the operator code is refined. Lessons learned from incidents can be encoded into the operator, making the entire system more resilient.\n\n#### Self-Healing Infrastructure\n\nOperators enable **self-healing infrastructure** by continuously monitoring actual state and taking corrective actions when deviations from desired state are detected. This goes far beyond simple resource creation and deletion to include application-specific health checks, performance optimization, and failure recovery procedures.\n\n> **Decision: Continuous Reconciliation vs Event-Driven Reactions**\n> - **Context**: Systems can respond to changes either by continuously checking state or by reacting to specific events\n> - **Options Considered**: Event-driven (webhook-based), polling-based, hybrid approach with informers\n> - **Decision**: Kubernetes informer pattern with continuous reconciliation loops\n> - **Rationale**: Event-driven systems can miss events or become inconsistent during network partitions; continuous reconciliation provides eventual consistency guarantees and can detect/correct drift from any source\n> - **Consequences**: Higher resource usage but much stronger consistency guarantees and better failure recovery\n\nThe self-healing capabilities of operators manifest in several ways:\n\n**Automatic Problem Detection**: Operators continuously monitor not just whether resources exist, but whether they're functioning correctly according to application-specific criteria. A database operator might check not only that pods are running, but that replication is working, that performance metrics are within acceptable ranges, and that backup processes are completing successfully.\n\n**Intelligent Recovery**: When problems are detected, operators can take application-aware corrective actions. Rather than simply restarting failed components, an operator might determine whether a failure affects service availability, attempt graceful recovery procedures first, and coordinate complex recovery processes that involve multiple components.\n\n**Drift Prevention**: Operators detect and correct configuration drift, ensuring that the actual system configuration always matches the declared specification. This prevents the gradual degradation that often occurs in manually managed systems as small changes accumulate over time.\n\n**Adaptive Behavior**: Advanced operators can adapt their behavior based on observed conditions. For example, an operator might automatically adjust resource allocations based on load patterns, or modify backup frequencies based on data change rates.\n\n#### Integration with Kubernetes Ecosystem\n\nOperators integrate seamlessly with the broader Kubernetes ecosystem, leveraging existing tooling, monitoring, and operational practices rather than requiring entirely new approaches.\n\n| Integration Point | Benefit | Example |\n|------------------|---------|---------|\n| **kubectl and API** | Operators are managed using standard Kubernetes tools | `kubectl get databases` shows all database instances with custom columns |\n| **RBAC** | Standard Kubernetes security model applies | Database operator can be restricted to specific namespaces or resource types |\n| **Monitoring** | Prometheus metrics, events, and logging work naturally | Operator exposes application-specific metrics alongside infrastructure metrics |\n| **GitOps** | Custom resources can be managed through Git workflows | Database configurations versioned and deployed through standard GitOps practices |\n| **Networking** | Application networking integrates with Kubernetes services and ingress | Operator manages service discovery and load balancing using native mechanisms |\n\nThis integration means that adopting operators doesn't require teams to learn entirely new toolsets or abandon existing operational practices. Instead, operators enhance and extend existing Kubernetes workflows with application-specific intelligence.\n\nThe operator pattern represents a fundamental shift from **reactive operational practices** to **proactive declarative management**. Rather than waiting for problems to occur and then responding, operators continuously work to maintain desired state and prevent problems from arising in the first place. This shift enables organizations to manage complex applications at scale while reducing operational toil and improving system reliability.\n\n> **Key Insight:** Operators don't just automate existing manual procedures - they enable entirely new approaches to system management that aren't practical with manual operations. The continuous reconciliation model allows for levels of consistency and reliability that are impossible to achieve through human-driven processes.\n\n### Implementation Guidance\n\nUnderstanding the operator pattern conceptually is the first step; implementing operators successfully requires careful technology choices and project structure decisions. This section provides concrete guidance for teams building their first Kubernetes operator.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Operator Framework** | Operator SDK with Helm or Ansible | Kubebuilder with controller-runtime |\n| **Language Runtime** | Go 1.21+ with controller-runtime | Go with custom client-go usage |\n| **Custom Resource Generation** | Kubebuilder markers and code generation | Hand-written OpenAPI v3 schemas |\n| **Testing Framework** | Envtest with Ginkgo/Gomega | Custom test harness with kind clusters |\n| **Admission Webhooks** | controller-runtime webhook builder | Custom HTTP servers with admission review handling |\n| **Certificate Management** | cert-manager with self-signed issuer | External certificate authority integration |\n\nFor teams new to operator development, **Kubebuilder with controller-runtime** provides the optimal balance of power and ease of use. It generates substantial boilerplate code, provides excellent testing utilities, and follows Kubernetes community best practices.\n\n#### Recommended Project Structure\n\nOrganizing operator code properly from the beginning prevents architectural debt and makes the codebase maintainable as features are added:\n\n```\ndatabase-operator/\n├── cmd/\n│   └── main.go                    ← Entry point and flag parsing\n├── api/\n│   └── v1/\n│       ├── database_types.go      ← Custom resource type definitions\n│       ├── groupversion_info.go   ← API group and version metadata\n│       └── zz_generated.deepcopy.go ← Generated code (do not edit)\n├── controllers/\n│   ├── database_controller.go     ← Main reconciliation logic\n│   └── database_controller_test.go ← Controller unit tests\n├── internal/\n│   ├── resources/                 ← Resource creation and management\n│   │   ├── deployment.go          ← Database deployment logic\n│   │   ├── service.go             ← Service creation and updates\n│   │   └── configmap.go           ← Configuration management\n│   ├── status/                    ← Status calculation and updates\n│   │   └── conditions.go          ← Status condition management\n│   └── webhooks/                  ← Admission webhook implementations\n│       ├── validator.go           ← Validation webhook logic\n│       └── defaulter.go           ← Defaulting webhook logic\n├── config/\n│   ├── crd/                       ← Custom resource definitions\n│   ├── rbac/                      ← Role and binding manifests\n│   ├── webhook/                   ← Webhook configuration\n│   └── samples/                   ← Example custom resources\n└── hack/\n    └── boilerplate.go.txt         ← License header for generated files\n```\n\nThis structure separates concerns clearly: API definitions remain stable in the `api/` directory, business logic lives in `controllers/`, and implementation details are encapsulated in `internal/` packages.\n\n#### Infrastructure Starter Code\n\nThe following code provides a complete foundation for operator development. Copy this code and modify it according to your specific requirements rather than building everything from scratch.\n\n**Main Entry Point (cmd/main.go):**\n\n```go\npackage main\n\nimport (\n    \"flag\"\n    \"fmt\"\n    \"os\"\n    \n    \"k8s.io/apimachinery/pkg/runtime\"\n    utilruntime \"k8s.io/apimachinery/pkg/util/runtime\"\n    clientgoscheme \"k8s.io/client-go/kubernetes/scheme\"\n    ctrl \"sigs.k8s.io/controller-runtime\"\n    \"sigs.k8s.io/controller-runtime/pkg/healthz\"\n    \"sigs.k8s.io/controller-runtime/pkg/log/zap\"\n    \n    databasev1 \"github.com/yourorg/database-operator/api/v1\"\n    \"github.com/yourorg/database-operator/controllers\"\n)\n\nvar (\n    scheme   = runtime.NewScheme()\n    setupLog = ctrl.Log.WithName(\"setup\")\n)\n\nfunc init() {\n    utilruntime.Must(clientgoscheme.AddToScheme(scheme))\n    utilruntime.Must(databasev1.AddToScheme(scheme))\n}\n\nfunc main() {\n    var metricsAddr string\n    var enableLeaderElection bool\n    var probeAddr string\n    \n    flag.StringVar(&metricsAddr, \"metrics-bind-address\", \":8080\", \"The address the metric endpoint binds to.\")\n    flag.StringVar(&probeAddr, \"health-probe-bind-address\", \":8081\", \"The address the probe endpoint binds to.\")\n    flag.BoolVar(&enableLeaderElection, \"leader-elect\", false, \"Enable leader election for controller manager.\")\n    opts := zap.Options{Development: true}\n    opts.BindFlags(flag.CommandLine)\n    flag.Parse()\n    \n    ctrl.SetLogger(zap.New(zap.UseFlagOptions(&opts)))\n    \n    mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{\n        Scheme:                 scheme,\n        MetricsBindAddress:     metricsAddr,\n        Port:                   9443,\n        HealthProbeBindAddress: probeAddr,\n        LeaderElection:         enableLeaderElection,\n        LeaderElectionID:       \"database-operator-lock\",\n    })\n    if err != nil {\n        setupLog.Error(err, \"unable to start manager\")\n        os.Exit(1)\n    }\n    \n    if err = (&controllers.DatabaseReconciler{\n        Client: mgr.GetClient(),\n        Scheme: mgr.GetScheme(),\n    }).SetupWithManager(mgr); err != nil {\n        setupLog.Error(err, \"unable to create controller\", \"controller\", \"Database\")\n        os.Exit(1)\n    }\n    \n    if err := mgr.AddHealthzCheck(\"healthz\", healthz.Ping); err != nil {\n        setupLog.Error(err, \"unable to set up health check\")\n        os.Exit(1)\n    }\n    \n    if err := mgr.AddReadyzCheck(\"readyz\", healthz.Ping); err != nil {\n        setupLog.Error(err, \"unable to set up ready check\")\n        os.Exit(1)\n    }\n    \n    setupLog.Info(\"starting manager\")\n    if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil {\n        setupLog.Error(err, \"problem running manager\")\n        os.Exit(1)\n    }\n}\n```\n\n**Basic Custom Resource Type (api/v1/database_types.go):**\n\n```go\npackage v1\n\nimport (\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\n// DatabaseSpec defines the desired state of Database\ntype DatabaseSpec struct {\n    // TODO: Define your custom resource specification fields here\n    // Examples:\n    // Replicas     *int32  `json:\"replicas,omitempty\"`\n    // Version      string  `json:\"version\"`\n    // StorageSize  string  `json:\"storageSize,omitempty\"`\n}\n\n// DatabaseStatus defines the observed state of Database\ntype DatabaseStatus struct {\n    // TODO: Define your status fields here\n    // Examples:\n    // Conditions       []metav1.Condition `json:\"conditions,omitempty\"`\n    // ReadyReplicas    int32              `json:\"readyReplicas,omitempty\"`\n    // ObservedGeneration int64            `json:\"observedGeneration,omitempty\"`\n}\n\n//+kubebuilder:object:root=true\n//+kubebuilder:subresource:status\n\n// Database is the Schema for the databases API\ntype Database struct {\n    metav1.TypeMeta   `json:\",inline\"`\n    metav1.ObjectMeta `json:\"metadata,omitempty\"`\n    \n    Spec   DatabaseSpec   `json:\"spec,omitempty\"`\n    Status DatabaseStatus `json:\"status,omitempty\"`\n}\n\n//+kubebuilder:object:root=true\n\n// DatabaseList contains a list of Database\ntype DatabaseList struct {\n    metav1.TypeMeta `json:\",inline\"`\n    metav1.ListMeta `json:\"metadata,omitempty\"`\n    Items           []Database `json:\"items\"`\n}\n\nfunc init() {\n    SchemeBuilder.Register(&Database{}, &DatabaseList{})\n}\n```\n\n#### Core Logic Skeleton\n\nThe following skeleton provides the structure for implementing your reconciliation logic. Fill in the TODO sections based on your specific application requirements:\n\n```go\npackage controllers\n\nimport (\n    \"context\"\n    \"time\"\n    \n    \"k8s.io/apimachinery/pkg/runtime\"\n    ctrl \"sigs.k8s.io/controller-runtime\"\n    \"sigs.k8s.io/controller-runtime/pkg/client\"\n    \"sigs.k8s.io/controller-runtime/pkg/log\"\n    \n    databasev1 \"github.com/yourorg/database-operator/api/v1\"\n)\n\n// DatabaseReconciler reconciles a Database object\ntype DatabaseReconciler struct {\n    client.Client\n    Scheme *runtime.Scheme\n}\n\n//+kubebuilder:rbac:groups=database.example.com,resources=databases,verbs=get;list;watch;create;update;patch;delete\n//+kubebuilder:rbac:groups=database.example.com,resources=databases/status,verbs=get;update;patch\n//+kubebuilder:rbac:groups=database.example.com,resources=databases/finalizers,verbs=update\n\n// Reconcile implements the main reconciliation logic for Database resources\nfunc (r *DatabaseReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {\n    log := log.FromContext(ctx)\n    \n    // TODO 1: Fetch the Database instance from the API server\n    // Use r.Get() to retrieve the resource by namespaced name\n    // Handle not-found errors gracefully (resource may have been deleted)\n    \n    // TODO 2: Check if the resource is being deleted (DeletionTimestamp is set)\n    // If deleting and has finalizers, perform cleanup operations\n    // Remove finalizers when cleanup is complete to allow deletion\n    \n    // TODO 3: Add finalizer if not already present\n    // Finalizers ensure cleanup logic runs before resource deletion\n    // Use controllerutil.AddFinalizer() helper function\n    \n    // TODO 4: Reconcile owned resources (Deployments, Services, ConfigMaps, etc.)\n    // Compare desired state (from spec) with actual state (from cluster)\n    // Create, update, or delete resources as needed to match desired state\n    \n    // TODO 5: Update the Database status based on owned resource states\n    // Calculate readiness, error conditions, and other status information\n    // Use r.Status().Update() to write status back to API server\n    \n    // TODO 6: Determine requeue behavior\n    // Return ctrl.Result{} for no requeue\n    // Return ctrl.Result{RequeueAfter: 30*time.Second} for periodic reconciliation\n    // Return ctrl.Result{Requeue: true} for immediate requeue on recoverable errors\n    \n    log.Info(\"reconciliation completed successfully\")\n    return ctrl.Result{}, nil\n}\n\n// SetupWithManager sets up the controller with the Manager\nfunc (r *DatabaseReconciler) SetupWithManager(mgr ctrl.Manager) error {\n    return ctrl.NewControllerManagedBy(mgr).\n        For(&databasev1.Database{}).\n        // TODO: Add Owns() calls for resources created by this controller\n        // Example: Owns(&appsv1.Deployment{}).\n        Complete(r)\n}\n```\n\n#### Language-Specific Hints\n\n**Go-Specific Best Practices:**\n- Use `sigs.k8s.io/controller-runtime/pkg/client` instead of raw client-go for better ergonomics\n- Always check `errors.IsNotFound()` when fetching resources that might not exist\n- Use `controllerutil.SetControllerReference()` to establish owner relationships\n- Leverage `kubebuilder` markers for RBAC and webhook generation rather than hand-writing manifests\n- Use structured logging with `logr.Logger` instead of standard library logging\n\n**Error Handling Patterns:**\n- Distinguish between permanent errors (bad configuration) and transient errors (network timeouts)\n- Use `ctrl.Result{Requeue: true}` for transient errors that should retry immediately\n- Use `ctrl.Result{RequeueAfter: duration}` for rate-limited retries or periodic reconciliation\n- Log errors with sufficient context for debugging, but don't log expected conditions like \"resource not found\"\n\n**Performance Considerations:**\n- Cache frequently accessed data in the controller struct rather than fetching repeatedly\n- Use client.Reader for read-only operations to leverage informer caches\n- Batch related operations when possible to reduce API server load\n- Consider using predicates to filter events that don't require reconciliation\n\n#### Milestone Checkpoints\n\nAfter implementing each major component, verify functionality with these checkpoints:\n\n**Custom Resource Definition Checkpoint:**\n```bash\n# Apply your CRD to a cluster\nkubectl apply -f config/crd/bases/\n\n# Verify the CRD is registered\nkubectl get crd databases.database.example.com\n\n# Test custom resource creation\nkubectl apply -f config/samples/database_v1_database.yaml\n\n# Verify custom columns are displayed\nkubectl get databases\n```\n\n**Controller Checkpoint:**\n```bash\n# Run the controller locally\nmake install run\n\n# In another terminal, create a test resource\nkubectl apply -f config/samples/database_v1_database.yaml\n\n# Verify reconciliation occurs (check controller logs)\n# Should see \"reconciliation completed successfully\" messages\n\n# Verify status is updated\nkubectl get database sample-database -o yaml\n```\n\n**Webhook Checkpoint:**\n```bash\n# Install cert-manager for webhook certificates\nkubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml\n\n# Deploy webhooks\nmake deploy-webhooks\n\n# Test validation webhook with invalid resource\n# Should receive admission denied error\n\n# Test defaulting webhook by omitting optional fields\n# Resource should be created with default values populated\n```\n\nExpected signs that implementation is working correctly:\n- Controller logs show reconciliation events for resource changes\n- Custom resources display appropriate status conditions and custom columns\n- Owned resources (Deployments, Services) are created and updated appropriately\n- Webhook validation prevents invalid resources from being created\n- Resource deletion triggers proper cleanup and finalizer removal\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** All milestones - defines the scope and boundaries that guide implementation decisions across CRD design, controller logic, webhooks, testing, and deployment\n\nBuilding a Kubernetes operator requires clear boundaries around what problems it will solve and what complexities it will deliberately avoid. Think of this goals definition as **drawing the blueprint before breaking ground** - it prevents scope creep, guides architectural decisions, and sets realistic expectations for both implementers and users. Without clear goals, operators often evolve into sprawling systems that try to solve every operational problem, leading to complexity that undermines the very automation they were meant to provide.\n\nThe operator pattern excels at codifying repetitive operational procedures, but not every operational task belongs in an operator. Some problems are better solved with existing Kubernetes primitives, external tools, or manual intervention. By explicitly defining what this operator will and will not handle, we create focused software that does its intended job well rather than attempting to be a universal solution.\n\n### Functional Goals\n\nThe **functional goals** define the specific automation capabilities our operator will provide. These represent the core value proposition - the repetitive operational tasks that the operator will handle automatically, reducing manual intervention and human error.\n\n#### Primary Resource Management Capabilities\n\nOur operator will provide automated lifecycle management for database instances through custom resources. The primary functional goals center around the `Database` custom resource and its associated operational workflows.\n\n| Capability | Description | Automation Level | User Interaction |\n|------------|-------------|------------------|------------------|\n| Database Provisioning | Create new database instances with specified configuration | Fully Automated | User creates Database resource |\n| Replica Management | Scale database replicas up/down based on spec changes | Fully Automated | User updates replicas field |\n| Version Upgrades | Perform rolling upgrades to new database versions | Semi-Automated | User updates version field, operator handles rollout |\n| Storage Management | Provision and resize persistent volumes for database storage | Fully Automated | User specifies storageSize, operator manages PVCs |\n| Configuration Updates | Apply configuration changes without service interruption | Semi-Automated | User updates config, operator validates and applies |\n| Health Monitoring | Continuously monitor database health and update status | Fully Automated | Status conditions updated automatically |\n\n> **Decision: Database-Focused Domain Model**\n> - **Context**: Operators work best with a specific domain rather than generic resource management. We need concrete use cases to drive meaningful automation.\n> - **Options Considered**: Generic application operator, database-specific operator, multi-application operator\n> - **Decision**: Database-specific operator with concrete database management workflows\n> - **Rationale**: Database management has well-understood operational patterns (provisioning, scaling, backup, upgrade) that translate naturally to declarative automation. This provides concrete requirements for testing reconciliation logic without getting lost in abstract scenarios.\n> - **Consequences**: Focused scope enables deeper automation but limits reusability across application types\n\nThe operator will manage **owned resources** - Kubernetes resources created and controlled by the operator to implement the desired database configuration. These owned resources form the actual infrastructure that delivers the database service.\n\n| Owned Resource Type | Purpose | Lifecycle Management | Status Reflection |\n|---------------------|---------|---------------------|-------------------|\n| StatefulSet | Manages database pods with stable identity and storage | Created, updated, and scaled based on Database spec | Ready replicas count reflected in Database status |\n| Service | Provides stable network endpoint for database access | Created with appropriate ports and selectors | Service endpoints reflected in Database status |\n| ConfigMap | Holds database configuration files and initialization scripts | Updated when Database spec.config changes | Configuration hash tracked in status |\n| PersistentVolumeClaim | Provides durable storage for database data | Created and resized based on spec.storageSize | Storage capacity reflected in status |\n| Secret | Manages database credentials and TLS certificates | Created with generated passwords, rotated on demand | Credential generation timestamp in status |\n\n#### Declarative Configuration Management\n\nThe operator will support **declarative configuration** where users specify the desired end state through the `DatabaseSpec`, and the operator continuously works to achieve and maintain that state through reconciliation.\n\n| Configuration Aspect | Declarative Behavior | Validation Rules | Default Handling |\n|----------------------|----------------------|------------------|------------------|\n| Replica Count | Scale StatefulSet to match spec.replicas | Must be positive integer, maximum of 10 | Defaults to 1 if omitted |\n| Database Version | Perform rolling upgrade to spec.version | Must be supported version from allowed list | Defaults to latest stable version |\n| Storage Size | Resize PVC to match spec.storageSize | Cannot decrease, must use valid resource quantities | Defaults to \"10Gi\" |\n| Resource Requirements | Update container resources in StatefulSet | Must fit within namespace resource quotas | Defaults to moderate CPU/memory requests |\n| Configuration Parameters | Update ConfigMap with spec.config values | Validate against database-specific schema | Applies sensible production defaults |\n\n> **The Desired State Principle**\n> \n> The operator embodies Kubernetes' core principle that users declare what they want, not how to achieve it. When a user creates a `Database` resource requesting 3 replicas with 50Gi storage, they shouldn't need to know about StatefulSets, PVCs, or rolling update strategies. The operator translates high-level intent into low-level Kubernetes resource management.\n\n#### Status Reporting and Observability\n\nThe operator will provide comprehensive status reporting through the `DatabaseStatus` subresource, giving users visibility into the current state of their database instances without requiring knowledge of the underlying Kubernetes resources.\n\n| Status Information | Update Frequency | Status Conditions | Troubleshooting Value |\n|--------------------|------------------|-------------------|----------------------|\n| Ready Replica Count | Every reconciliation cycle | Ready, Progressing, Degraded | Indicates scaling progress and health |\n| Current Version | On version change completion | VersionUpgrading, VersionReady | Shows upgrade progress and rollback status |\n| Storage Utilization | Periodic polling (configurable) | StorageWarning, StorageCritical | Enables proactive capacity planning |\n| Connection Information | On service endpoint changes | ServiceReady, ServiceUnavailable | Provides connection details for applications |\n| Last Reconciliation | Every reconciliation attempt | ReconcileSuccess, ReconcileError | Shows operator activity and error states |\n\n### Non-Functional Goals\n\nThe **non-functional goals** define quality attributes that constrain how the operator implements its functional capabilities. These goals ensure the operator behaves reliably in production environments and integrates smoothly with Kubernetes operational practices.\n\n#### Reliability and Fault Tolerance\n\nThe operator must handle the distributed system challenges inherent in Kubernetes environments, where network partitions, node failures, and API server unavailability are routine operational realities.\n\n| Reliability Aspect | Target Behavior | Failure Handling | Recovery Mechanism |\n|--------------------|-----------------|------------------|-------------------|\n| Controller Availability | 99.9% uptime during cluster operation | Leader election prevents split-brain scenarios | Automatic failover to standby controller replica |\n| Reconciliation Consistency | All reconciliation operations are idempotent | Partial failures don't leave resources in inconsistent states | Full state reconstruction from cluster resources |\n| API Server Connectivity | Graceful handling of connection interruptions | Exponential backoff on API failures | Automatic reconnection with informer resync |\n| Resource Conflict Resolution | Handle concurrent updates from multiple sources | Optimistic locking prevents conflicting changes | Retry with latest resource version on conflicts |\n| Data Durability | Never lose user-specified configuration | All spec changes persisted before processing | Status updates use separate API calls to prevent overwrites |\n\n> **Decision: Eventual Consistency Model**\n> - **Context**: Kubernetes operates on eventual consistency - cluster state changes propagate asynchronously through informers and caches\n> - **Options Considered**: Strong consistency with distributed locking, eventual consistency with convergence, manual consistency checking\n> - **Decision**: Embrace eventual consistency with robust reconciliation convergence\n> - **Rationale**: Fighting Kubernetes' eventual consistency model leads to complex synchronization code that's prone to deadlocks. Designing for convergence through idempotent operations aligns with Kubernetes patterns and provides better fault tolerance.\n> - **Consequences**: Simpler controller logic and better failure recovery, but requires careful status reporting to avoid user confusion during convergence periods\n\n#### Performance and Scalability\n\nThe operator should handle reasonable numbers of database instances without consuming excessive cluster resources or causing performance degradation.\n\n| Performance Metric | Target Value | Measurement Method | Scaling Behavior |\n|--------------------|--------------|--------------------|------------------|\n| Reconciliation Latency | < 30 seconds for spec changes | Time from Database update to owned resource convergence | Linear scaling with number of owned resources per Database |\n| Resource Consumption | < 100MB memory, < 0.1 CPU cores per 100 Database resources | Metrics exported via Prometheus endpoints | Memory usage grows with informer cache size |\n| API Server Load | < 10 QPS per controller replica | Rate limiting on client requests | Batched status updates reduce API call frequency |\n| Webhook Response Time | < 5 seconds for validation/mutation | Admission review processing time | Independent of cluster size for validation rules |\n| Controller Startup Time | < 60 seconds to ready state | Time from pod start to processing first reconciliation | Informer cache sync time dominates startup |\n\n#### Operational Integration\n\nThe operator must integrate seamlessly with standard Kubernetes operational practices and tooling used by platform teams.\n\n| Integration Aspect | Standard Compliance | Tooling Compatibility | Operational Benefit |\n|--------------------|---------------------|----------------------|-------------------|\n| RBAC Authorization | Principle of least privilege for all permissions | Compatible with namespace-scoped and cluster-scoped deployments | Security audit compliance and permission isolation |\n| Resource Labeling | Consistent labels for owned resources with operator identification | Works with label selectors in monitoring and debugging tools | Clear ownership tracking and troubleshooting |\n| Event Recording | Kubernetes events for all significant operator actions | Visible in kubectl describe and event aggregation systems | Audit trail and debugging information |\n| Metrics Export | Prometheus metrics for controller performance and resource counts | Integrates with existing monitoring infrastructure | Operational visibility and alerting capability |\n| Logging Structure | Structured JSON logs with consistent fields | Compatible with log aggregation systems like ELK or Loki | Centralized logging and log-based alerting |\n\n> **Operational Transparency Principle**\n> \n> Platform teams need visibility into operator behavior to debug issues, plan capacity, and maintain security compliance. The operator should export its internal state and decision-making process through standard Kubernetes observability mechanisms rather than requiring specialized knowledge or tools.\n\n### Explicit Non-Goals\n\nThe **explicit non-goals** define complexities and capabilities that this operator implementation will deliberately exclude. These boundaries prevent scope creep and ensure the operator remains focused on its core value proposition while avoiding areas where other tools provide better solutions.\n\n#### Data Management and Backup Operations\n\nWhile the operator manages database infrastructure, it will not implement data-level backup, restore, or migration capabilities.\n\n| Excluded Capability | Rationale | Recommended Alternative | Interface Boundary |\n|---------------------|-----------|------------------------|-------------------|\n| Automated Backup Scheduling | Database backup strategies vary significantly by database type and organizational requirements | Use dedicated backup operators like Velero or database-specific backup tools | Operator provisions storage; external tools handle data backup |\n| Point-in-Time Recovery | Recovery procedures require database-specific knowledge and operational context | Database-native tools with organization-specific recovery procedures | Operator provides persistent storage; DBA tools handle recovery |\n| Cross-Cluster Data Migration | Migration involves network, security, and data governance concerns beyond infrastructure | Specialized migration tools with proper data governance workflow | Operator manages instances; migration tools handle data movement |\n| Data Encryption at Rest | Encryption requirements vary by compliance framework and key management infrastructure | Kubernetes storage encryption or database-native encryption features | Operator specifies storage requirements; platform provides encryption |\n\n> **Decision: Infrastructure vs Data Layer Separation**\n> - **Context**: Operators can manage infrastructure (pods, services, storage) or data-level operations (backup, migration, schema changes)\n> - **Options Considered**: Full data lifecycle management, infrastructure-only management, hybrid approach with pluggable data operations\n> - **Decision**: Infrastructure-only management with clear boundaries at the data layer\n> - **Rationale**: Data operations require database-specific expertise, compliance considerations, and organizational procedures that vary significantly across environments. Infrastructure management has consistent patterns across database types.\n> - **Consequences**: Simpler operator implementation and clearer separation of concerns, but users need additional tools for data operations\n\n#### Advanced Deployment Strategies\n\nThe operator will not implement complex deployment patterns that require sophisticated orchestration beyond basic rolling updates.\n\n| Excluded Pattern | Complexity Reason | Standard Alternative | Operator Boundary |\n|------------------|-------------------|---------------------|-------------------|\n| Blue-Green Deployments | Requires maintaining parallel full environments and traffic switching logic | Use service mesh or ingress controllers for traffic management | Operator manages single environment; traffic tools handle switching |\n| Canary Deployments | Requires traffic percentage routing and automated rollback based on metrics | Use progressive delivery tools like Flagger or Argo Rollouts | Operator performs rolling updates; specialized tools handle canary logic |\n| Multi-Region Replication | Cross-region networking, latency, and consistency concerns | Use database-native replication or service mesh multi-cluster features | Operator manages single-cluster instances; platform handles multi-region |\n| Disaster Recovery Automation | Requires integration with backup systems, DNS switching, and recovery procedures | Use comprehensive DR orchestration tools with organizational runbooks | Operator provisions instances; DR tools coordinate full recovery |\n\n#### Security and Access Control\n\nWhile the operator follows security best practices, it will not implement application-level security features that belong in specialized security tools.\n\n| Security Aspect | Exclusion Rationale | Recommended Approach | Responsibility Boundary |\n|------------------|---------------------|----------------------|------------------------|\n| User Authentication | Database user management involves organizational identity systems | Use external authentication providers or database-native user management | Operator creates database infrastructure; identity systems handle users |\n| Network Policies | Network security requirements vary by organizational policy and compliance framework | Use Kubernetes NetworkPolicy resources or service mesh security features | Operator labels resources for policy targeting; network tools enforce policies |\n| Secret Rotation | Credential rotation involves integration with organizational secret management systems | Use external secret operators like External Secrets Operator or Vault integration | Operator consumes secrets; secret management tools handle rotation |\n| Compliance Auditing | Audit requirements vary by regulatory framework and organizational procedures | Use specialized compliance tools like OPA Gatekeeper or audit logging systems | Operator generates audit events; compliance tools enforce policies |\n\n> ⚠️ **Pitfall: Scope Creep Through Security Requirements**\n> \n> Security requirements often drive scope expansion as stakeholders request \"just one more security feature.\" Establishing clear boundaries early prevents the operator from becoming a monolithic security solution. Instead, design clean interfaces for integration with specialized security tools.\n\n#### Performance Tuning and Optimization\n\nThe operator will not implement database-specific performance tuning or optimization features that require deep database expertise.\n\n| Performance Aspect | Exclusion Reason | Alternative Solution | Integration Point |\n|--------------------|------------------|----------------------|-------------------|\n| Query Performance Tuning | Requires database-specific knowledge and workload analysis | Use database monitoring tools and DBA expertise | Operator provisions resources; DBAs tune performance |\n| Automatic Index Management | Index strategies depend on application query patterns and data characteristics | Use database-native optimization features or specialized tuning tools | Operator manages database infrastructure; applications manage schema |\n| Workload-Based Resource Scaling | Requires metrics analysis and workload prediction beyond basic replica scaling | Use Horizontal Pod Autoscaler or Vertical Pod Autoscaler with custom metrics | Operator handles manual scaling; autoscaling tools handle automatic scaling |\n| Connection Pool Management | Connection pooling strategies vary by application architecture and traffic patterns | Use application-level connection pooling or proxy tools like PgBouncer | Operator provides database endpoints; applications handle connection management |\n\n### Implementation Scope Summary\n\nThese goals and non-goals create a **focused operator implementation** that provides real value while maintaining reasonable complexity. The operator will excel at infrastructure lifecycle management - the operational tasks that follow predictable patterns and can be reliably automated through Kubernetes primitives.\n\n| In Scope | Out of Scope | Interface/Integration Point |\n|----------|--------------|----------------------------|\n| Database infrastructure provisioning and scaling | Database schema management and migrations | Operator provides stable endpoints for schema tools |\n| Resource lifecycle management (pods, services, storage) | Application deployment and configuration | Applications connect to operator-managed database services |\n| Basic health monitoring and status reporting | Advanced performance monitoring and alerting | Operator exports metrics for monitoring systems |\n| Rolling updates for version changes | Complex deployment strategies and traffic management | Operator performs updates; traffic tools handle advanced routing |\n| Infrastructure-level configuration management | Database-specific tuning and optimization | Operator provides base configuration; DBAs handle tuning |\n\nThis scope definition guides every implementation decision from CRD schema design through controller logic to testing strategies. When faced with feature requests or implementation choices, refer back to these goals to maintain focus and deliver a robust, maintainable operator that solves its intended problems well.\n\n### Implementation Guidance\n\nThe goals and non-goals defined above directly influence the technical implementation approach and technology choices throughout the operator development process. This guidance translates the high-level goals into concrete implementation decisions and project structure recommendations.\n\n#### Technology Recommendations Table\n\n| Component | Simple Option | Advanced Option | Recommendation for Learning |\n|-----------|---------------|-----------------|---------------------------|\n| Operator Framework | Kubebuilder with basic scaffolding | Operator SDK with advanced features and scorecard | Kubebuilder - cleaner generated code, better documentation |\n| Custom Resource Schema | Basic OpenAPI v3 schema validation | CEL expressions with cross-field validation | Start with OpenAPI, add CEL for complex validation |\n| Controller Runtime | Controller-runtime with basic manager | Custom controller with shared informers | Controller-runtime - handles boilerplate and follows patterns |\n| Webhook Framework | Controller-runtime webhook builder | Custom webhook server with admission review handling | Controller-runtime webhook builder - integrated TLS and registration |\n| Testing Framework | Fake client for unit tests only | Envtest for integration testing with real API server | Both - fake client for fast unit tests, envtest for end-to-end validation |\n| Deployment Method | Static YAML manifests | Helm charts with configurable values | Start with static YAML, migrate to Helm for production deployment |\n\n#### Recommended Project Structure\n\nThe project structure should reflect the goals' emphasis on focused domain logic while maintaining clear separation between infrastructure concerns and business logic:\n\n```\ndatabase-operator/\n├── cmd/\n│   └── manager/\n│       └── main.go                    ← Entry point with manager setup\n├── apis/\n│   └── database/\n│       └── v1/\n│           ├── database_types.go      ← Database CRD definition with spec/status\n│           ├── database_webhook.go    ← Validation and mutation logic\n│           └── zz_generated.deepcopy.go ← Generated by controller-gen\n├── controllers/\n│   └── database/\n│       ├── database_controller.go     ← Core reconciliation logic\n│       ├── database_controller_test.go ← Unit tests with fake client\n│       └── suite_test.go              ← Envtest integration test setup\n├── internal/\n│   ├── resources/                     ← Owned resource management (non-goals boundary)\n│   │   ├── statefulset.go            ← StatefulSet creation and updates\n│   │   ├── service.go                ← Service endpoint management\n│   │   ├── configmap.go              ← Configuration management\n│   │   └── secret.go                 ← Credential handling\n│   └── database/                      ← Database-specific logic (extensibility point)\n│       ├── postgres.go               ← PostgreSQL-specific configuration\n│       └── mysql.go                  ← MySQL-specific configuration (future)\n├── config/\n│   ├── crd/                          ← CRD manifests and kustomization\n│   ├── rbac/                         ← RBAC role definitions following least privilege\n│   ├── webhook/                      ← Webhook configuration and TLS setup\n│   └── manager/                      ← Controller deployment manifests\n└── hack/\n    ├── boilerplate.go.txt           ← License header for generated files\n    └── tools.go                     ← Tool dependencies for go mod\n```\n\nThis structure supports the functional goals by separating domain-specific logic (`internal/database/`) from generic Kubernetes resource management (`internal/resources/`), making it easy to extend support for additional database types without violating the infrastructure vs data management boundary.\n\n#### Infrastructure Starter Code\n\n**Manager Setup (cmd/manager/main.go)** - Complete working foundation:\n\n```go\npackage main\n\nimport (\n    \"flag\"\n    \"os\"\n    \"time\"\n\n    \"k8s.io/apimachinery/pkg/runtime\"\n    clientgoscheme \"k8s.io/client-go/kubernetes/scheme\"\n    ctrl \"sigs.k8s.io/controller-runtime\"\n    \"sigs.k8s.io/controller-runtime/pkg/healthz\"\n    \"sigs.k8s.io/controller-runtime/pkg/log/zap\"\n\n    databasev1 \"github.com/example/database-operator/apis/database/v1\"\n    databasecontrollers \"github.com/example/database-operator/controllers/database\"\n)\n\nvar (\n    scheme   = runtime.NewScheme()\n    setupLog = ctrl.Log.WithName(\"setup\")\n)\n\nfunc init() {\n    _ = clientgoscheme.AddToScheme(scheme)\n    _ = databasev1.AddToScheme(scheme)\n}\n\nfunc main() {\n    var metricsAddr string\n    var probeAddr string\n    var enableLeaderElection bool\n    var syncPeriod time.Duration\n\n    flag.StringVar(&metricsAddr, \"metrics-bind-address\", \":8080\", \"The address the metric endpoint binds to.\")\n    flag.StringVar(&probeAddr, \"health-probe-bind-address\", \":8081\", \"The address the probe endpoint binds to.\")\n    flag.BoolVar(&enableLeaderElection, \"leader-elect\", false, \"Enable leader election for controller manager.\")\n    flag.DurationVar(&syncPeriod, \"sync-period\", 10*time.Minute, \"Minimum frequency at which watched resources are reconciled.\")\n    opts := zap.Options{Development: true}\n    opts.BindFlags(flag.CommandLine)\n    flag.Parse()\n\n    ctrl.SetLogger(zap.New(zap.UseFlagOptions(&opts)))\n\n    mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{\n        Scheme:                 scheme,\n        MetricsBindAddress:     metricsAddr,\n        Port:                   9443, // Webhook server port\n        HealthProbeBindAddress: probeAddr,\n        LeaderElection:         enableLeaderElection,\n        LeaderElectionID:       \"database-operator-leader-election\",\n        SyncPeriod:             &syncPeriod,\n    })\n    if err != nil {\n        setupLog.Error(err, \"unable to start manager\")\n        os.Exit(1)\n    }\n\n    // Register controller - learner implements the reconciliation logic\n    if err = (&databasecontrollers.DatabaseReconciler{\n        Client: mgr.GetClient(),\n        Scheme: mgr.GetScheme(),\n        Log:    ctrl.Log.WithName(\"controllers\").WithName(\"Database\"),\n    }).SetupWithManager(mgr); err != nil {\n        setupLog.Error(err, \"unable to create controller\", \"controller\", \"Database\")\n        os.Exit(1)\n    }\n\n    // Register webhooks - learner implements validation and mutation\n    if err = (&databasev1.Database{}).SetupWebhookWithManager(mgr); err != nil {\n        setupLog.Error(err, \"unable to create webhook\", \"webhook\", \"Database\")\n        os.Exit(1)\n    }\n\n    // Health and readiness endpoints\n    if err := mgr.AddHealthzCheck(\"healthz\", healthz.Ping); err != nil {\n        setupLog.Error(err, \"unable to set up health check\")\n        os.Exit(1)\n    }\n    if err := mgr.AddReadyzCheck(\"readyz\", healthz.Ping); err != nil {\n        setupLog.Error(err, \"unable to set up ready check\")\n        os.Exit(1)\n    }\n\n    setupLog.Info(\"starting manager\")\n    if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil {\n        setupLog.Error(err, \"problem running manager\")\n        os.Exit(1)\n    }\n}\n```\n\n**Resource Helper Utilities (internal/resources/common.go)** - Infrastructure code supporting non-functional goals:\n\n```go\npackage resources\n\nimport (\n    \"fmt\"\n    \n    corev1 \"k8s.io/api/core/v1\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/apimachinery/pkg/runtime\"\n    ctrl \"sigs.k8s.io/controller-runtime\"\n    \n    databasev1 \"github.com/example/database-operator/apis/database/v1\"\n)\n\nconst (\n    // Labels for owned resource identification (supports operational integration goals)\n    ManagedByLabelKey   = \"app.kubernetes.io/managed-by\"\n    ManagedByLabelValue = \"database-operator\"\n    NameLabelKey        = \"app.kubernetes.io/name\"\n    ComponentLabelKey   = \"app.kubernetes.io/component\"\n    InstanceLabelKey    = \"app.kubernetes.io/instance\"\n)\n\n// CommonLabels returns the standard labels for all owned resources\n// Supports operational integration goal for resource identification\nfunc CommonLabels(database *databasev1.Database, component string) map[string]string {\n    return map[string]string{\n        ManagedByLabelKey: ManagedByLabelValue,\n        NameLabelKey:      \"database\",\n        ComponentLabelKey: component,\n        InstanceLabelKey:  database.Name,\n    }\n}\n\n// SetOwnerReference establishes owner reference for garbage collection\n// Supports reliability goal for automatic cleanup\nfunc SetOwnerReference(owner *databasev1.Database, controlled metav1.Object, scheme *runtime.Scheme) error {\n    return ctrl.SetControllerReference(owner, controlled, scheme)\n}\n\n// ResourceName generates consistent naming for owned resources\nfunc ResourceName(database *databasev1.Database, suffix string) string {\n    if suffix == \"\" {\n        return database.Name\n    }\n    return fmt.Sprintf(\"%s-%s\", database.Name, suffix)\n}\n\n// CommonAnnotations returns standard annotations for owned resources\nfunc CommonAnnotations(database *databasev1.Database) map[string]string {\n    return map[string]string{\n        \"database.example.com/managed-by-operator\": \"true\",\n        \"database.example.com/owner-generation\":   fmt.Sprintf(\"%d\", database.Generation),\n    }\n}\n```\n\n#### Core Logic Skeleton Code\n\n**Database Reconciler (controllers/database/database_controller.go)** - Core logic that learners implement:\n\n```go\npackage database\n\nimport (\n    \"context\"\n    \"time\"\n\n    appsv1 \"k8s.io/api/apps/v1\"\n    corev1 \"k8s.io/api/core/v1\"\n    \"k8s.io/apimachinery/pkg/api/errors\"\n    \"k8s.io/apimachinery/pkg/runtime\"\n    \"k8s.io/apimachinery/pkg/types\"\n    ctrl \"sigs.k8s.io/controller-runtime\"\n    \"sigs.k8s.io/controller-runtime/pkg/client\"\n    \"sigs.k8s.io/controller-runtime/pkg/log\"\n\n    databasev1 \"github.com/example/database-operator/apis/database/v1\"\n    \"github.com/example/database-operator/internal/resources\"\n)\n\nconst (\n    REQUEUE_AFTER_DURATION = 30 * time.Second\n    FINALIZER_NAME         = \"database.example.com/finalizer\"\n)\n\n// DatabaseReconciler reconciles a Database object\ntype DatabaseReconciler struct {\n    client.Client\n    Scheme *runtime.Scheme\n    Log    logr.Logger\n}\n\n//+kubebuilder:rbac:groups=database.example.com,resources=databases,verbs=get;list;watch;create;update;patch;delete\n//+kubebuilder:rbac:groups=database.example.com,resources=databases/status,verbs=get;update;patch\n//+kubebuilder:rbac:groups=database.example.com,resources=databases/finalizers,verbs=update\n//+kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=get;list;watch;create;update;patch;delete\n//+kubebuilder:rbac:groups=\"\",resources=services;configmaps;secrets,verbs=get;list;watch;create;update;patch;delete\n//+kubebuilder:rbac:groups=\"\",resources=persistentvolumeclaims,verbs=get;list;watch;create;update;patch\n//+kubebuilder:rbac:groups=\"\",resources=events,verbs=create;patch\n\n// Reconcile implements the main reconciliation logic comparing desired vs actual state\nfunc (r *DatabaseReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {\n    log := r.Log.WithValues(\"database\", req.NamespacedName)\n\n    // TODO 1: Fetch the Database resource from the API server\n    // Hint: Use r.Client.Get() with the req.NamespacedName\n    // Handle the case where the resource might have been deleted (errors.IsNotFound)\n    \n    // TODO 2: Handle deletion case if DeletionTimestamp is set\n    // Check if database.DeletionTimestamp != nil\n    // If deletion is in progress, call r.handleDeletion() and return\n    \n    // TODO 3: Add finalizer if not present\n    // Check if FINALIZER_NAME is in database.Finalizers\n    // If missing, add it using controllerutil.AddFinalizer and update the resource\n    \n    // TODO 4: Reconcile owned resources to match desired state\n    // Call r.reconcileStatefulSet(), r.reconcileService(), r.reconcileConfigMap()\n    // Each function should return error if reconciliation fails\n    \n    // TODO 5: Update status based on current state of owned resources\n    // Fetch current StatefulSet status and update database.Status.ReadyReplicas\n    // Set appropriate conditions in database.Status.Conditions\n    // Use r.Status().Update() to persist status changes\n    \n    // TODO 6: Determine requeue behavior\n    // Return ctrl.Result{RequeueAfter: REQUEUE_AFTER_DURATION} for periodic reconciliation\n    // Return ctrl.Result{} with no requeue if everything is in desired state\n    // Return error if reconciliation failed and should be retried with backoff\n    \n    return ctrl.Result{}, nil\n}\n\n// handleDeletion processes Database resource deletion with cleanup\nfunc (r *DatabaseReconciler) handleDeletion(ctx context.Context, database *databasev1.Database) error {\n    log := r.Log.WithValues(\"database\", database.Name, \"namespace\", database.Namespace)\n    \n    // TODO 1: Perform cleanup operations before allowing deletion\n    // This might include draining connections, backing up data, etc.\n    // For this implementation, we rely on owner references for cascade deletion\n    \n    // TODO 2: Remove finalizer to allow deletion to proceed\n    // Use controllerutil.RemoveFinalizer() and update the resource\n    // Return any errors from the update operation\n    \n    return nil\n}\n\n// reconcileStatefulSet ensures the StatefulSet matches the Database spec\nfunc (r *DatabaseReconciler) reconcileStatefulSet(ctx context.Context, database *databasev1.Database) error {\n    // TODO 1: Define desired StatefulSet based on Database spec\n    // Use resources.NewStatefulSet() helper to create desired state\n    // Set replica count from database.Spec.Replicas\n    // Set container image from database.Spec.Version\n    // Configure storage from database.Spec.StorageSize\n    \n    // TODO 2: Check if StatefulSet already exists\n    // Use r.Client.Get() to fetch existing StatefulSet\n    // Handle both \"exists\" and \"not found\" cases\n    \n    // TODO 3: Create StatefulSet if it doesn't exist\n    // Set owner reference using resources.SetOwnerReference()\n    // Use r.Client.Create() to create the StatefulSet\n    \n    // TODO 4: Update StatefulSet if it exists but doesn't match desired state\n    // Compare existing spec with desired spec\n    // Use r.Client.Update() to apply changes\n    // Handle update conflicts by refetching and retrying\n    \n    return nil\n}\n\n// SetupWithManager registers the controller with the manager and configures watches\nfunc (r *DatabaseReconciler) SetupWithManager(mgr ctrl.Manager) error {\n    return ctrl.NewControllerManagedBy(mgr).\n        For(&databasev1.Database{}).                    // Primary resource to watch\n        Owns(&appsv1.StatefulSet{}).                    // Watch owned StatefulSets\n        Owns(&corev1.Service{}).                        // Watch owned Services\n        Owns(&corev1.ConfigMap{}).                      // Watch owned ConfigMaps\n        Owns(&corev1.Secret{}).                         // Watch owned Secrets\n        Complete(r)\n}\n```\n\n#### Language-Specific Hints\n\n**Go-Specific Implementation Guidance:**\n\n- Use `sigs.k8s.io/controller-runtime/pkg/controller/controllerutil` for finalizer management (`AddFinalizer`, `RemoveFinalizer`)\n- Import `k8s.io/apimachinery/pkg/api/errors` for handling API server errors like `IsNotFound`, `IsConflict`\n- Use `context.Context` throughout for cancellation and timeouts - never ignore the context parameter\n- Leverage `k8s.io/apimachinery/pkg/types.NamespacedName` for resource identification in client calls\n- Use `sigs.k8s.io/controller-runtime/pkg/log` for structured logging with key-value pairs\n- Import specific API group packages like `appsv1 \"k8s.io/api/apps/v1\"` to avoid conflicts\n\n**Client Usage Patterns:**\n\n- Use `r.Client.Get(ctx, namespacedName, &resource)` for fetching resources\n- Use `r.Client.Create(ctx, &resource)` for creating new resources\n- Use `r.Client.Update(ctx, &resource)` for updating existing resources\n- Use `r.Status().Update(ctx, &resource)` for status-only updates\n- Always check `errors.IsNotFound(err)` when fetching resources that might not exist\n\n#### Milestone Checkpoint\n\nAfter implementing the goals and non-goals framework:\n\n**Validation Command:**\n```bash\n# Verify project structure matches recommendations\nfind . -name \"*.go\" | head -10\n\n# Check that generated code compiles\ngo mod tidy && go build ./cmd/manager\n\n# Verify RBAC markers are present\ngrep -r \"kubebuilder:rbac\" controllers/\n```\n\n**Expected Behavior:**\n- Project compiles without errors\n- Manager binary starts (may exit due to missing CRDs, but should parse flags)\n- RBAC markers generate appropriate permissions\n- File structure follows recommended organization\n\n**Signs of Problems:**\n- Import cycle errors → Check for circular dependencies between packages\n- Missing scheme registration → Verify `AddToScheme` calls in main.go\n- RBAC permission errors → Check that controller has necessary resource access\n\nThis implementation guidance translates the high-level goals into actionable development steps while maintaining the boundaries defined in the non-goals section.\n\n\n## High-Level Architecture\n\n> **Milestone(s):** Milestone 1 (Custom Resource Definition), Milestone 2 (Controller Setup) - this section establishes the foundational architecture that guides CRD design and controller implementation\n\nBuilding a Kubernetes operator is like constructing a sophisticated automation system that integrates seamlessly with an existing orchestration platform. Think of it as adding a specialized department to a large corporation - the new department must understand the company's communication protocols, follow established procedures, and coordinate effectively with existing teams while bringing its own domain expertise to automate previously manual processes.\n\nThe operator architecture consists of four primary components that work together to extend Kubernetes with domain-specific automation capabilities. These components - custom resources, controllers, admission webhooks, and supporting infrastructure - form a cohesive system that integrates with the Kubernetes API machinery while maintaining separation of concerns and operational reliability.\n\n![Operator Architecture Overview](./diagrams/operator-architecture.svg)\n\n### Component Overview\n\nThe operator follows the standard Kubernetes extension pattern, leveraging the platform's built-in extensibility mechanisms to add new resource types and automated management logic. Understanding how these components interact helps establish the mental model for implementing each piece correctly.\n\n**Custom Resources serve as the API contract** between users and the operator. These are not just data structures - they represent the declarative interface through which users express their desired state for managed applications. The `Database` custom resource, for example, encapsulates all the configuration parameters needed to describe a database instance, from basic settings like replicas and storage size to advanced configuration like backup schedules and monitoring endpoints.\n\nThe custom resource design follows Kubernetes conventions with distinct `spec` and `status` subresources. The `spec` contains the user's desired configuration and remains immutable once set (except for explicit updates). The `status` reflects the current observed state of the managed resources and gets updated continuously by the controller as it reconciles the actual state with the desired state.\n\n| Custom Resource Component | Purpose | Ownership | Update Pattern |\n|---|---|---|---|\n| `DatabaseSpec` | User's desired state declaration | User via kubectl/API | Explicit updates only |\n| `DatabaseStatus` | Controller's observed state report | Controller exclusively | Continuous reconciliation updates |\n| Metadata annotations | Operational hints and user labels | Mixed (user + controller) | Additive updates |\n| Finalizers | Cleanup coordination mechanism | Controller exclusively | Added on creation, removed on cleanup completion |\n\n**Controllers implement the reconciliation logic** that continuously works to make the actual state match the desired state declared in custom resources. Think of a controller as a tireless system administrator who never sleeps, constantly checking that everything is configured correctly and taking corrective action when things drift from the desired configuration.\n\nThe `DatabaseReconciler` watches for changes to `Database` custom resources and responds by examining the current state of all related Kubernetes resources (StatefulSets, Services, ConfigMaps, Secrets) and taking whatever actions are necessary to align them with the specification. This might involve creating new resources, updating existing ones, or cleaning up resources that are no longer needed.\n\nControllers operate through an event-driven architecture built on Kubernetes' watch mechanism. Rather than polling for changes, controllers receive notifications when resources are created, updated, or deleted. This allows them to respond quickly to changes while minimizing unnecessary API server load.\n\n| Controller Component | Function | Input | Output |\n|---|---|---|---|\n| `Informer` | Maintains local cache of watched resources | API server events | Cached resource state |\n| `WorkQueue` | Buffers reconciliation requests with rate limiting | Resource change events | Serialized reconcile requests |\n| `Reconciler` | Compares desired vs actual state and takes action | Reconcile request | Resource mutations + status updates |\n| `EventRecorder` | Provides observability into controller actions | Controller decisions | Kubernetes events |\n\n**Admission Webhooks provide validation and mutation capabilities** that execute during the resource admission process, before resources are stored in etcd. These webhooks act as gatekeepers, ensuring that only valid resources enter the system and automatically applying default values or transformations to improve the user experience.\n\nValidation webhooks implement business rules that go beyond what can be expressed in OpenAPI schema validation. For example, while the schema can enforce that a storage size is a valid quantity, a validation webhook can enforce that storage size increases are allowed but decreases are prohibited (since they could cause data loss).\n\nMutating webhooks enhance the user experience by automatically filling in reasonable defaults and applying organizational policies. When a user creates a `Database` resource with minimal configuration, the mutating webhook can inject appropriate resource limits, security contexts, and monitoring configurations based on organizational standards.\n\n| Webhook Type | Execution Phase | Purpose | Common Use Cases |\n|---|---|---|---|\n| Mutating | Before validation and storage | Apply defaults and transformations | Inject resource limits, add labels, set security policies |\n| Validating | After mutation, before storage | Enforce business rules and constraints | Validate field combinations, check quotas, verify dependencies |\n\n**Supporting Infrastructure** provides the operational foundation that enables the core components to function reliably in production environments. This includes observability tools, security configurations, and deployment mechanisms that ensure the operator can be operated safely at scale.\n\nThe infrastructure layer handles cross-cutting concerns like leader election (ensuring only one controller replica actively reconciles resources), TLS certificate management for webhook endpoints, RBAC configuration for secure API access, and monitoring integrations that provide visibility into operator health and performance.\n\n### Kubernetes API Integration\n\nThe operator extends Kubernetes by leveraging the platform's built-in extensibility mechanisms rather than working around them. This integration approach ensures that the operator feels like a natural part of the Kubernetes ecosystem, with custom resources appearing in `kubectl get` output, audit logs, and administrative tools just like built-in resources.\n\n**API Server Extension through Custom Resource Definitions** allows the operator to register new resource types that become first-class citizens in the Kubernetes API. When a Custom Resource Definition (CRD) is applied to a cluster, the API server automatically provides REST endpoints for the new resource type, complete with validation, versioning, and all the standard Kubernetes API features.\n\nThe CRD registration process creates API endpoints following Kubernetes conventions: `/api/v1/namespaces/{namespace}/databases` for namespaced resources or `/api/v1/databases` for cluster-scoped resources. These endpoints support all standard HTTP verbs (GET, POST, PUT, PATCH, DELETE) and integrate with existing tooling like `kubectl`, client libraries, and administrative dashboards.\n\n> **Decision: Namespaced vs Cluster-scoped Resources**\n> - **Context**: Database resources could be deployed at namespace level (tenant isolation) or cluster level (shared infrastructure)\n> - **Options Considered**: Namespaced only, cluster-scoped only, hybrid with both types\n> - **Decision**: Namespaced resources with cluster-scoped operator\n> - **Rationale**: Namespaced resources provide tenant isolation and align with Kubernetes RBAC patterns, while cluster-scoped operator deployment simplifies operational management\n> - **Consequences**: Enables multi-tenancy and role-based access control, but requires cluster admin privileges for operator installation\n\n**Controller Integration with the Control Plane** follows the established controller pattern used by Kubernetes itself. The operator's controller uses the same client-go library that built-in controllers use, ensuring consistent behavior and reliability characteristics.\n\nThe controller registers with the API server to watch specific resource types and receives a stream of events (create, update, delete) through efficient long-polling connections. When the connection is interrupted, the client-go library automatically reconnects and reestablishes the watch, ensuring the controller doesn't miss events during network partitions or API server restarts.\n\nControllers maintain an eventually consistent local cache of relevant cluster state through informers. This cache serves two critical purposes: it reduces load on the API server by serving read requests locally, and it provides a consistent snapshot of related resources during reconciliation, preventing race conditions that could occur if the controller made individual API calls for each resource.\n\n| API Integration Component | Purpose | Kubernetes Integration Point | Reliability Features |\n|---|---|---|---|\n| Custom Resource Definition | Extends API with new resource types | API server schema registration | Version conversion, validation, storage |\n| Controller Watch Streams | Receives resource change notifications | API server watch mechanism | Automatic reconnection, bookmark events |\n| Informer Cache | Local eventually-consistent state replica | List/watch with resync | Cache invalidation, index optimization |\n| Admission Webhooks | Intercepts resource mutations | API server admission chain | Timeout handling, failure policies |\n\n**Admission Webhook Integration** occurs within the API server's request processing pipeline, specifically during the admission phase after authentication and authorization but before persistence to etcd. This timing allows webhooks to validate and transform requests while ensuring that security policies have already been enforced.\n\nThe API server sends admission review requests to webhook endpoints over HTTPS, providing the full context of the operation including the resource being created or updated, the user making the request, and relevant metadata. Webhooks respond with admission review responses that either allow the operation (possibly with modifications) or deny it with an explanatory message.\n\nWebhook integration requires careful attention to reliability and security. The API server enforces timeout limits on webhook calls to prevent cluster availability issues, and webhook failure policies determine whether failures result in request denial (fail-closed) or request acceptance (fail-open). TLS certificate management ensures secure communication and prevents man-in-the-middle attacks.\n\n> **Critical Design Insight**: The operator doesn't replace Kubernetes mechanisms - it extends them. Every interaction goes through standard Kubernetes APIs, ensuring compatibility with existing tools, security policies, and operational procedures.\n\n**Event Recording and Observability** integrate with Kubernetes' standard observability mechanisms to provide visibility into operator actions. When the controller takes actions like creating StatefulSets or handling errors, it records events that appear in `kubectl describe` output and cluster monitoring systems.\n\nThe controller uses the Kubernetes event recording mechanism to document its decision-making process, providing an audit trail of actions taken during reconciliation. These events help both users and operators understand why certain actions were taken and provide debugging information when things don't work as expected.\n\n### Recommended Project Structure\n\nOrganizing the operator codebase follows established Go and Kubernetes conventions that promote maintainability, testing, and collaboration. The structure separates concerns clearly while keeping related functionality together, making it easier for team members to understand and modify the system.\n\n**Top-Level Organization** follows the standard Go project layout with `cmd/` for executable entry points, `internal/` for private implementation code, and `api/` for public API definitions. This structure makes it immediately clear what parts of the codebase are intended for external consumption versus internal implementation details.\n\n```\ndatabase-operator/\n├── cmd/\n│   └── manager/\n│       └── main.go                 ← Operator entry point with flag parsing and setup\n├── api/\n│   └── v1/\n│       ├── database_types.go       ← Database custom resource definition\n│       ├── groupversion_info.go    ← API group and version metadata\n│       └── zz_generated.deepcopy.go ← Generated code (do not edit)\n├── internal/\n│   └── controller/\n│       ├── database_controller.go  ← DatabaseReconciler implementation\n│       └── database_controller_test.go ← Controller unit tests\n├── config/\n│   ├── crd/\n│   │   └── bases/                  ← Generated CRD manifests\n│   ├── rbac/                       ← RBAC role definitions\n│   ├── webhook/                    ← Webhook configuration manifests\n│   └── manager/                    ← Controller manager deployment\n└── webhooks/\n    ├── database_defaulting.go      ← Mutating webhook implementation\n    ├── database_validation.go      ← Validating webhook implementation\n    └── webhook_suite_test.go       ← Webhook integration tests\n```\n\n**API Package Organization** separates the public API definitions from the implementation logic, making it easier to generate client libraries and ensuring that API changes are deliberate and well-considered. The `api/v1/` package contains only type definitions and generated code, with no business logic.\n\nThe API package structure supports versioning from the beginning, even if only one version exists initially. This forward-thinking approach makes it much easier to add new API versions later without requiring major refactoring. The versioned packages also align with Kubernetes' own API organization patterns.\n\n| Directory | Contents | Ownership | Generation |\n|---|---|---|---|\n| `api/v1/` | Type definitions and API metadata | Manual implementation | Partial (deepcopy methods) |\n| `config/crd/bases/` | CRD YAML manifests | Generated from Go types | Fully generated |\n| `config/rbac/` | Role and RoleBinding manifests | Manual configuration | Manual |\n| `config/webhook/` | Webhook configuration YAML | Generated with manual TLS setup | Mixed |\n\n**Internal Package Structure** organizes implementation code by function rather than by layer, keeping related functionality together. The `internal/controller/` package contains all controller-related logic, while webhook implementations live in a separate `webhooks/` package at the top level (since they may be shared across multiple operators).\n\nController organization separates the reconciliation logic from the Kubernetes integration machinery. The controller file focuses on the business logic of comparing desired state with actual state and deciding what actions to take. Integration concerns like informer setup, work queue configuration, and manager registration are handled in setup functions that keep the core reconciliation logic clean and testable.\n\n> **Decision: Single Package vs Multi-Package Controller Organization**\n> - **Context**: Controller code can be organized in one package or split across multiple packages by concern\n> - **Options Considered**: Single controller package, separate packages for reconciler/setup/types, layered packages\n> - **Decision**: Single controller package with clear function separation\n> - **Rationale**: Reduces cognitive overhead for small-to-medium operators, keeps related code together, aligns with controller-runtime patterns\n> - **Consequences**: May need refactoring if controller grows very large, but provides simpler navigation and testing\n\n**Configuration and Deployment Structure** separates generated manifests from manually maintained configuration, making it clear what should be edited directly versus what gets regenerated from code. The `config/` directory contains all Kubernetes manifests needed to deploy the operator, organized by function.\n\nThe configuration structure supports both development and production deployments through Kustomize overlays. The base configuration in `config/` provides a working deployment that can be customized for specific environments without modifying the original files. This approach enables GitOps workflows where environment-specific configurations are maintained in separate repositories or directories.\n\n**Testing Organization** co-locates unit tests with the code they test while providing separate integration test suites that exercise the full system. Controller unit tests focus on the reconciliation logic using fake clients, while integration tests in the `webhooks/` package exercise the full admission webhook flow including TLS certificate handling.\n\nThe testing structure supports both fast unit testing during development and comprehensive integration testing in CI/CD pipelines. Unit tests can run without a Kubernetes cluster and complete in seconds, while integration tests use envtest to run against a real API server but still complete quickly enough for regular execution.\n\n| Test Type | Location | Dependencies | Execution Time |\n|---|---|---|---|\n| Unit Tests | `*_test.go` next to implementation | Fake clients only | < 1 second per test |\n| Controller Integration | `internal/controller/suite_test.go` | envtest with real API server | < 10 seconds per test |\n| Webhook Integration | `webhooks/webhook_suite_test.go` | envtest with webhook server | < 15 seconds per test |\n| End-to-End Tests | `test/e2e/` | Full cluster deployment | 1-5 minutes per test |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Mixing API definitions with implementation logic** - New operator developers often put business logic directly in the API package alongside type definitions. This creates circular dependencies and makes it difficult to generate clean client libraries. Keep the `api/` package focused solely on type definitions and generated code. Business logic belongs in `internal/controller/` or other implementation packages.\n\n⚠️ **Pitfall: Ignoring the controller-runtime project structure** - The controller-runtime framework expects a specific project organization, and deviating from it breaks code generation and scaffolding tools. Use `kubebuilder init` to create the initial project structure and follow the conventions it establishes. This ensures compatibility with the broader Kubernetes tooling ecosystem.\n\n⚠️ **Pitfall: Not planning for API versioning from the start** - Even if you only need one API version initially, organizing code as if multiple versions will exist makes future evolution much easier. Create the `api/v1/` package structure immediately rather than using an unversioned `api/` package that will require refactoring later.\n\n⚠️ **Pitfall: Coupling controllers too tightly to specific custom resources** - Controllers should be designed to work with interface types when possible, making them more testable and reusable. Avoid directly importing custom resource types in controller business logic; instead, define interfaces that capture the required behavior and use type assertions only at the boundaries.\n\n### Implementation Guidance\n\nThe architecture implementation follows cloud-native patterns and leverages the controller-runtime framework to minimize boilerplate code while maintaining flexibility for customization.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|---|---|---|\n| Project Scaffolding | Kubebuilder v3 with default settings | Operator SDK with custom templates |\n| API Code Generation | controller-gen with basic markers | controller-gen with comprehensive OpenAPI markers |\n| Testing Framework | Ginkgo/Gomega with envtest | Ginkgo/Gomega with real cluster integration |\n| Configuration Management | Kustomize with simple overlays | Helm with complex value templating |\n| Observability | Standard Go logging with controller-runtime | Structured logging with Prometheus metrics |\n\n#### File Structure Setup\n\nInitialize the project structure using kubebuilder to ensure alignment with Kubernetes conventions:\n\n```bash\n# Initialize project with domain and repository\nkubebuilder init --domain example.com --repo github.com/yourorg/database-operator\n\n# Create API and controller scaffolding\nkubebuilder create api --group database --version v1 --kind Database\n\n# Create webhook scaffolding\nkubebuilder create webhook --group database --version v1 --kind Database --defaulting --programmatic-validation\n```\n\n#### Core Type Definitions\n\n```go\n// api/v1/database_types.go\npackage v1\n\nimport (\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\n// DatabaseSpec defines the desired state of Database\ntype DatabaseSpec struct {\n    // Replicas is the number of database instances to run\n    // +kubebuilder:validation:Minimum=1\n    // +kubebuilder:validation:Maximum=10\n    // +kubebuilder:default=1\n    Replicas int32 `json:\"replicas,omitempty\"`\n    \n    // Version specifies the database version to deploy\n    // +kubebuilder:validation:Pattern=^[0-9]+\\.[0-9]+\\.[0-9]+$\n    Version string `json:\"version\"`\n    \n    // StorageSize defines the persistent storage size for each replica\n    // +kubebuilder:validation:Pattern=^[0-9]+[KMGT]i$\n    StorageSize string `json:\"storageSize\"`\n    \n    // TODO: Add configuration fields like backup schedule, monitoring settings\n    // TODO: Add networking configuration for service exposure\n    // TODO: Add security settings like TLS and authentication\n}\n\n// DatabaseStatus defines the observed state of Database\ntype DatabaseStatus struct {\n    // Conditions represent the latest available observations of the database state\n    Conditions []metav1.Condition `json:\"conditions,omitempty\"`\n    \n    // ReadyReplicas is the number of database instances that are ready to serve requests\n    ReadyReplicas int32 `json:\"readyReplicas,omitempty\"`\n    \n    // ObservedGeneration reflects the generation of the most recently observed Database spec\n    ObservedGeneration int64 `json:\"observedGeneration,omitempty\"`\n    \n    // TODO: Add status fields for backup status, connection endpoints\n    // TODO: Add metrics like storage usage, connection count\n}\n\n// +kubebuilder:object:root=true\n// +kubebuilder:subresource:status\n// +kubebuilder:printcolumn:name=\"Replicas\",type=\"integer\",JSONPath=\".spec.replicas\"\n// +kubebuilder:printcolumn:name=\"Ready\",type=\"integer\",JSONPath=\".status.readyReplicas\"\n// +kubebuilder:printcolumn:name=\"Version\",type=\"string\",JSONPath=\".spec.version\"\n// +kubebuilder:printcolumn:name=\"Age\",type=\"date\",JSONPath=\".metadata.creationTimestamp\"\n\n// Database is the Schema for the databases API\ntype Database struct {\n    metav1.TypeMeta   `json:\",inline\"`\n    metav1.ObjectMeta `json:\"metadata,omitempty\"`\n    \n    Spec   DatabaseSpec   `json:\"spec,omitempty\"`\n    Status DatabaseStatus `json:\"status,omitempty\"`\n}\n\n// +kubebuilder:object:root=true\n\n// DatabaseList contains a list of Database\ntype DatabaseList struct {\n    metav1.TypeMeta `json:\",inline\"`\n    metav1.ListMeta `json:\"metadata,omitempty\"`\n    Items           []Database `json:\"items\"`\n}\n\nfunc init() {\n    SchemeBuilder.Register(&Database{}, &DatabaseList{})\n}\n```\n\n#### Controller Foundation\n\n```go\n// internal/controller/database_controller.go\npackage controller\n\nimport (\n    \"context\"\n    \"time\"\n    \n    \"k8s.io/apimachinery/pkg/runtime\"\n    ctrl \"sigs.k8s.io/controller-runtime\"\n    \"sigs.k8s.io/controller-runtime/pkg/client\"\n    \"sigs.k8s.io/controller-runtime/pkg/log\"\n    \n    databasev1 \"github.com/yourorg/database-operator/api/v1\"\n)\n\nconst (\n    REQUEUE_AFTER_DURATION = 30 * time.Second\n    FINALIZER_NAME = \"database.example.com/finalizer\"\n)\n\n// DatabaseReconciler reconciles a Database object\ntype DatabaseReconciler struct {\n    client.Client\n    Scheme *runtime.Scheme\n}\n\n// +kubebuilder:rbac:groups=database.example.com,resources=databases,verbs=get;list;watch;create;update;patch;delete\n// +kubebuilder:rbac:groups=database.example.com,resources=databases/status,verbs=get;update;patch\n// +kubebuilder:rbac:groups=database.example.com,resources=databases/finalizers,verbs=update\n// +kubebuilder:rbac:groups=apps,resources=statefulsets,verbs=get;list;watch;create;update;patch;delete\n// +kubebuilder:rbac:groups=\"\",resources=services,verbs=get;list;watch;create;update;patch;delete\n// +kubebuilder:rbac:groups=\"\",resources=configmaps,verbs=get;list;watch;create;update;patch;delete\n\n// Reconcile compares the state specified by the Database object against the actual cluster state,\n// and performs operations to make the cluster state reflect the state specified by the user.\nfunc (r *DatabaseReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {\n    log := log.FromContext(ctx)\n    \n    // TODO 1: Fetch the Database instance from the cluster\n    // TODO 2: Handle deletion by checking if DeletionTimestamp is set\n    // TODO 3: Add finalizer if not present to ensure cleanup\n    // TODO 4: Reconcile StatefulSet to match spec.replicas and spec.version\n    // TODO 5: Reconcile Service for database connectivity\n    // TODO 6: Reconcile ConfigMap with database configuration\n    // TODO 7: Update Database status with current ready replicas and conditions\n    // TODO 8: Return appropriate requeue strategy based on current state\n    \n    log.Info(\"Reconciling Database\", \"database\", req.NamespacedName)\n    \n    return ctrl.Result{RequeueAfter: REQUEUE_AFTER_DURATION}, nil\n}\n\n// SetupWithManager sets up the controller with the Manager.\nfunc (r *DatabaseReconciler) SetupWithManager(mgr ctrl.Manager) error {\n    return ctrl.NewControllerManagedBy(mgr).\n        For(&databasev1.Database{}).\n        // TODO: Add watches for owned resources (StatefulSet, Service, ConfigMap)\n        // TODO: Configure predicates to filter unnecessary reconciliation triggers\n        // TODO: Set up event handler for better observability\n        Complete(r)\n}\n```\n\n#### Webhook Skeleton\n\n```go\n// webhooks/database_validation.go\npackage webhooks\n\nimport (\n    \"context\"\n    \"fmt\"\n    \n    \"k8s.io/apimachinery/pkg/runtime\"\n    ctrl \"sigs.k8s.io/controller-runtime\"\n    \"sigs.k8s.io/controller-runtime/pkg/webhook\"\n    \"sigs.k8s.io/controller-runtime/pkg/webhook/admission\"\n    \n    databasev1 \"github.com/yourorg/database-operator/api/v1\"\n)\n\n// +kubebuilder:webhook:path=/validate-database-example-com-v1-database,mutating=false,failurePolicy=fail,groups=database.example.com,resources=databases,verbs=create;update,versions=v1,name=vdatabase.kb.io,sideEffects=None,admissionReviewVersions=v1\n\n// DatabaseValidator validates Database resources using custom business rules\ntype DatabaseValidator struct{}\n\n// ValidateCreate implements webhook.Validator\nfunc (v *DatabaseValidator) ValidateCreate(ctx context.Context, obj runtime.Object) (admission.Warnings, error) {\n    database := obj.(*databasev1.Database)\n    \n    // TODO 1: Validate that storage size is not below minimum threshold\n    // TODO 2: Validate that version string matches supported database versions\n    // TODO 3: Validate that replica count doesn't exceed cluster capacity\n    // TODO 4: Check for naming conflicts with existing databases\n    \n    return nil, nil\n}\n\n// ValidateUpdate implements webhook.Validator\nfunc (v *DatabaseValidator) ValidateUpdate(ctx context.Context, oldObj, newObj runtime.Object) (admission.Warnings, error) {\n    newDatabase := newObj.(*databasev1.Database)\n    oldDatabase := oldObj.(*databasev1.Database)\n    \n    // TODO 1: Prevent storage size decreases that could cause data loss\n    // TODO 2: Validate version upgrade paths (no downgrades, supported migrations)\n    // TODO 3: Ensure replica count changes are within acceptable bounds\n    \n    return nil, nil\n}\n\n// ValidateDelete implements webhook.Validator  \nfunc (v *DatabaseValidator) ValidateDelete(ctx context.Context, obj runtime.Object) (admission.Warnings, error) {\n    // TODO 1: Check if database contains data that should be backed up\n    // TODO 2: Validate that dependent applications are prepared for deletion\n    \n    return nil, nil\n}\n\nfunc (v *DatabaseValidator) SetupWebhookWithManager(mgr ctrl.Manager) error {\n    return ctrl.NewWebhookManagedBy(mgr).\n        For(&databasev1.Database{}).\n        WithValidator(v).\n        Complete()\n}\n```\n\n#### Language-Specific Development Tips\n\n**Go-Specific Implementation Guidance:**\n- Use `sigs.k8s.io/controller-runtime/pkg/client` for all Kubernetes API interactions - it provides automatic retries and rate limiting\n- Leverage `k8s.io/apimachinery/pkg/api/errors` for proper error handling that distinguishes between different failure types\n- Use `controllerutil.SetControllerReference` to establish owner relationships that enable garbage collection\n- Implement the `Defaulter` and `Validator` interfaces on your custom resource types for webhook functionality\n- Use `k8s.io/utils/pointer` for safely creating pointers to primitive values in Kubernetes objects\n\n**RBAC Configuration Guidelines:**\nThe generated RBAC markers in the controller comments will create appropriate permissions, but verify that they include:\n- Read/write access to your custom resources and their status subresources\n- Read/write access to all Kubernetes resources your controller manages (StatefulSets, Services, etc.)\n- Read access to resources you need to watch but don't own (Nodes, StorageClasses for validation)\n\n**Debugging and Development Workflow:**\n1. Run `make generate` after modifying API types to regenerate deepcopy methods\n2. Run `make manifests` to regenerate CRDs and RBAC from code annotations  \n3. Use `make install` to apply CRDs to your development cluster\n4. Test controller logic with `make run` for local development with real cluster access\n5. Use `make docker-build` and `make deploy` for full integration testing in the cluster\n\n\n## Data Model and Custom Resources\n\n> **Milestone(s):** Milestone 1 (Custom Resource Definition), Milestone 3 (Reconciliation Loop) - defines the API schema and status structures that the controller reconciles, and Milestone 4 (Webhooks) - establishes validation rules enforced by admission control\n\n### Mental Model: The Application Blueprint\n\nThink of a **custom resource definition** as an architectural blueprint for buildings. Just as a blueprint defines the structure, dimensions, materials, and specifications that every building of that type must follow, a CRD defines the schema, validation rules, and structural requirements that every instance of your custom resource must conform to. The blueprint doesn't create buildings—it defines what valid buildings look like. Similarly, the CRD doesn't create application instances—it defines what valid application configurations look like.\n\nWhen an architect designs a blueprint, they specify required elements (foundation, load-bearing walls), optional elements (balconies, decorative features), and validation rules (minimum ceiling height, maximum occupancy). The CRD schema works the same way: it specifies required fields that every resource must have, optional fields that provide additional configuration, and validation rules that prevent invalid configurations from being accepted.\n\nThe **status subresource** acts like a building inspector's report. While the blueprint (spec) describes what the building should look like, the inspector's report (status) describes the current state of construction: which floors are complete, what problems have been encountered, and whether the building is ready for occupancy. Just as the architect doesn't write the inspector's report, users don't directly modify the status—only the controller (acting as the inspector) updates the status based on what it observes.\n\n![Custom Resource Data Model](./diagrams/crd-data-model.svg)\n\nThe data model forms the contract between users who describe their desired application state and controllers that make that state reality. This contract must be precise enough to prevent ambiguous configurations, flexible enough to accommodate diverse use cases, and evolvable enough to support future requirements without breaking existing deployments.\n\n### Custom Resource Definition Schema\n\nThe OpenAPI v3 schema structure defines the shape and validation rules for custom resources. Unlike simple configuration files, CRD schemas provide strong typing, comprehensive validation, and automatic documentation generation. The schema serves multiple purposes: it validates user input at the API level, generates client code for type-safe programming, provides auto-completion in kubectl and IDEs, and documents the API for users and operators.\n\n**Database Custom Resource Structure:**\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `apiVersion` | string | Yes | Always \"example.com/v1\" for this resource type |\n| `kind` | string | Yes | Always \"Database\" for this resource type |\n| `metadata` | ObjectMeta | Yes | Standard Kubernetes metadata including name, namespace, labels, annotations |\n| `spec` | DatabaseSpec | Yes | User-specified desired state configuration |\n| `status` | DatabaseStatus | No | Controller-managed current state information |\n\nThe separation between `spec` and `status` reflects Kubernetes' declarative model. Users declare their intent in the spec, while controllers report reality in the status. This separation enables optimistic concurrency control and clear ownership boundaries.\n\n**DatabaseSpec Field Definitions:**\n\n| Field | Type | Required | Validation | Description |\n|-------|------|----------|------------|-------------|\n| `replicas` | int32 | Yes | minimum: 1, maximum: 10 | Number of database instances to maintain |\n| `version` | string | Yes | pattern: \"^[0-9]+\\\\.[0-9]+\\\\.[0-9]+$\" | Semantic version of database software |\n| `storageSize` | string | Yes | pattern: \"^[0-9]+[KMGT]i?$\" | Storage capacity using Kubernetes quantity format |\n| `backupSchedule` | string | No | pattern: \"^(@(annually\\|yearly\\|monthly\\|weekly\\|daily\\|hourly\\|reboot))\\|(@every (\\\\d+(ns\\|us\\|µs\\|ms\\|s\\|m\\|h))+)\\|((\\\\d+\\|\\\\*)(/(\\\\d+))? (\\\\d+\\|\\\\*)(/(\\\\d+))? (\\\\d+\\|\\\\*)(/(\\\\d+))? (\\\\d+\\|\\\\*)(/(\\\\d+))? (\\\\d+\\|\\\\*)(/(\\\\d+))?)$\" | Optional cron expression for automated backups |\n| `resources` | ResourceRequirements | No | - | CPU and memory resource requests and limits |\n| `config` | map[string]string | No | maxProperties: 20 | Database-specific configuration parameters |\n\nThe validation patterns serve as compile-time checks that prevent invalid configurations from entering the system. The `version` field uses semantic versioning to ensure upgrade compatibility. The `storageSize` field accepts Kubernetes quantity formats like \"10Gi\" or \"500Mi\" for consistency with other Kubernetes resources.\n\n**DatabaseStatus Field Definitions:**\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `conditions` | []Condition | No | Array of condition objects describing the current state |\n| `readyReplicas` | int32 | No | Number of database instances currently serving traffic |\n| `observedGeneration` | int64 | No | Generation of spec that was last processed by controller |\n| `phase` | string | No | High-level status: Pending, Running, Failed, Terminating |\n| `lastBackupTime` | *metav1.Time | No | Timestamp of most recent successful backup |\n| `endpoints` | []string | No | Connection endpoints for client applications |\n| `message` | string | No | Human-readable message describing current status |\n\nThe `observedGeneration` field enables controllers to track whether they've processed the latest spec changes. When `metadata.generation` exceeds `status.observedGeneration`, the controller knows new changes are pending. The `conditions` array provides detailed status information that tools like kubectl can interpret and display.\n\n**Condition Structure for Status Reporting:**\n\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| `type` | string | Yes | Condition type: Ready, Available, Progressing, Degraded |\n| `status` | string | Yes | Condition status: True, False, Unknown |\n| `lastTransitionTime` | metav1.Time | Yes | Time when condition last changed status |\n| `reason` | string | Yes | Machine-readable reason code for the condition |\n| `message` | string | Yes | Human-readable message explaining the condition |\n| `observedGeneration` | int64 | No | Generation when this condition was last updated |\n\nConditions provide structured status information that both humans and machines can interpret. The `Ready` condition indicates whether the resource is fully operational. The `Available` condition indicates whether the resource is accepting traffic. The `Progressing` condition indicates whether changes are being applied. The `Degraded` condition indicates whether the resource is running but with reduced functionality.\n\n> **Decision: Status Subresource Separation**\n> - **Context**: Controllers need to update status independently from user spec changes to avoid conflicts\n> - **Options Considered**: \n>   1. Store status in spec alongside user fields\n>   2. Use separate status subresource with independent update path\n>   3. Store status in annotations or separate custom resources\n> - **Decision**: Use separate status subresource with independent update path\n> - **Rationale**: Prevents update conflicts between user changes and controller status updates, enables proper RBAC separation, follows Kubernetes conventions\n> - **Consequences**: Requires two API calls for create+status update, but eliminates race conditions and follows established patterns\n\n### Validation and Defaulting Strategy\n\nKubernetes provides multiple layers of validation and defaulting that work together to ensure resource integrity. These layers operate at different points in the request lifecycle, each serving specific purposes and handling different classes of validation problems.\n\n**Schema-Level Validation** occurs first, using OpenAPI v3 schema definitions embedded in the CRD. This validation runs inside the API server and provides basic type checking, format validation, and structural constraints. Schema validation is fast and deterministic but limited to single-field constraints and simple cross-field relationships.\n\n**Admission Webhook Validation** provides custom business logic validation that can examine the entire resource, query external systems, and enforce complex cross-field constraints. Validating admission webhooks receive the complete resource and can reject requests with detailed error messages. This validation is more flexible but requires additional infrastructure and introduces latency and availability dependencies.\n\n**Common Expression Language (CEL) Validation** bridges the gap between schema validation and webhook validation. CEL expressions run inside the API server but can access multiple fields and perform complex logic. CEL provides better performance than webhooks while supporting more sophisticated validation than basic schema constraints.\n\n**Validation Strategy Table:**\n\n| Validation Type | Performance | Complexity | Use Cases | Failure Impact |\n|-----------------|-------------|------------|-----------|----------------|\n| OpenAPI Schema | Fastest | Low | Type checking, format validation, required fields | Request rejected immediately |\n| CEL Expressions | Fast | Medium | Cross-field validation, business rules | Request rejected immediately |\n| Admission Webhooks | Slower | High | External validation, complex business logic | Request rejected or webhook timeout |\n\n> **Decision: Layered Validation Approach**\n> - **Context**: Need comprehensive validation without sacrificing performance or availability\n> - **Options Considered**:\n>   1. Schema validation only for maximum performance\n>   2. Webhook validation only for maximum flexibility  \n>   3. Layered approach combining schema, CEL, and selective webhook validation\n> - **Decision**: Layered approach combining all three validation mechanisms\n> - **Rationale**: Schema catches basic errors fast, CEL handles cross-field logic efficiently, webhooks reserved for complex cases requiring external data\n> - **Consequences**: More complex validation setup, but better user experience and system reliability\n\n**CEL Expression Examples for Database Resource:**\n\n| Field Combination | CEL Expression | Purpose |\n|-------------------|----------------|---------|\n| Replicas and Storage | `self.replicas <= 3 || size(self.storageSize) >= 4` | Require larger storage for high-replica deployments |\n| Version and Config | `self.version.startsWith('5.') ? !has(self.config.legacy_mode) : true` | Prevent legacy configuration on modern versions |\n| Backup Schedule | `has(self.backupSchedule) ? self.replicas >= 2 : true` | Require multiple replicas when backups are enabled |\n| Resource Limits | `has(self.resources.limits.memory) ? self.resources.limits.memory >= self.resources.requests.memory : true` | Ensure limits are not less than requests |\n\nCEL expressions have access to the entire resource through `self` and can use built-in functions for string manipulation, arithmetic, and collection operations. The expressions must return boolean values, where `true` means validation passes and `false` means the request should be rejected.\n\n**Defaulting Strategy Implementation:**\n\n| Field | Default Value | Condition | Rationale |\n|-------|---------------|-----------|-----------|\n| `replicas` | 1 | Always applied if not specified | Single instance is minimum viable configuration |\n| `version` | \"5.7.0\" | Only for new resources | Provides stable default for users who don't specify |\n| `storageSize` | \"10Gi\" | Always applied if not specified | Reasonable default that works for development and testing |\n| `resources.requests.cpu` | \"100m\" | When resources section exists but cpu not specified | Prevents resource starvation |\n| `resources.requests.memory` | \"256Mi\" | When resources section exists but memory not specified | Reasonable baseline for database workloads |\n\nDefaulting occurs through mutating admission webhooks that modify incoming requests before validation. The webhook examines each field and injects appropriate defaults based on the current resource state and user-provided configuration. Defaults are applied only when fields are completely missing, not when they are explicitly set to empty values.\n\n**Validation Webhook Request Processing:**\n\n1. **Request Reception**: Webhook receives AdmissionReview containing the resource and operation type (CREATE, UPDATE)\n2. **Context Extraction**: Extract the Database resource from the admission request payload\n3. **Business Rule Validation**: Apply complex validation rules that span multiple fields or require external data\n4. **Cross-Resource Validation**: Query API server for related resources if validation depends on cluster state\n5. **Response Generation**: Create AdmissionResponse with allowed/denied decision and detailed messages\n6. **Error Handling**: Return structured error responses that kubectl can display meaningfully to users\n\nThe webhook must complete validation within the configured timeout (typically 10-30 seconds) or the API server will fail the request. This timeout constraint requires careful design of validation logic to avoid external dependencies that could cause unpredictable delays.\n\n### API Versioning and Evolution\n\nKubernetes custom resources evolve over time as requirements change, new features are added, and operational experience reveals design improvements. The API versioning system provides backward compatibility while enabling forward progress. Unlike traditional API versioning that maintains separate endpoints, Kubernetes CRDs support multiple versions of the same resource type with automatic conversion between versions.\n\n**Version Evolution Mental Model**: Think of API versioning like building renovation. When you renovate a house, you don't build a completely separate house—you modify the existing structure while keeping it livable. You might add new rooms (fields), remove outdated fixtures (deprecated fields), or reorganize the layout (restructure data). During renovation, you need temporary bridges or conversion tools so people can move between the old layout and new layout. Similarly, API versioning adds new fields and restructures existing ones while providing conversion mechanisms so existing clients continue working.\n\n**Versioning Strategy Overview:**\n\n| Version | Status | Purpose | Conversion Required |\n|---------|--------|---------|-------------------|\n| v1alpha1 | Deprecated | Initial experimental API | Yes - to v1beta1 and v1 |\n| v1beta1 | Active | Stable API with minor additions | Yes - to v1 |\n| v1 | Storage Version | Production-ready API | No - other versions convert to this |\n\nThe **storage version** is the canonical representation used in etcd. All other versions are converted to and from the storage version when resources are created, updated, or retrieved. This hub-and-spoke conversion model simplifies the conversion matrix compared to requiring direct conversion between every version pair.\n\n> **Decision: Hub and Spoke Conversion Model**\n> - **Context**: Need to support multiple API versions without exponential conversion complexity\n> - **Options Considered**:\n>   1. Direct conversion between every version pair (N² complexity)\n>   2. Hub and spoke with storage version as hub (2N complexity)\n>   3. Version deprecation forcing users to migrate immediately\n> - **Decision**: Hub and spoke conversion model with v1 as storage version\n> - **Rationale**: Minimizes conversion code maintenance, provides single source of truth, enables gradual migration\n> - **Consequences**: All versions must be convertible to/from storage version, but total complexity remains manageable\n\n**Version Migration Example: v1alpha1 to v1beta1:**\n\n| v1alpha1 Field | v1beta1 Field | Conversion Logic |\n|----------------|---------------|------------------|\n| `size` (string) | `replicas` (int32) | Parse string number, convert to int32 |\n| `dbVersion` (string) | `version` (string) | Direct field rename, no transformation |\n| `storage` (string) | `storageSize` (string) | Direct field rename, no transformation |\n| `backup` (bool) | `backupSchedule` (string) | If true, default to \"@daily\"; if false, omit field |\n| N/A | `resources` (ResourceRequirements) | New field, populate with empty object |\n\n**Conversion Webhook Architecture:**\n\nThe conversion webhook acts as a translator between API versions. When a user requests a resource in version A but it's stored in version B, the API server sends the stored version to the conversion webhook, which transforms it to the requested version. This process is transparent to clients—they see the version they requested without knowing about storage version differences.\n\n**Conversion Webhook Processing Steps:**\n\n1. **Request Analysis**: Webhook receives ConversionReview with desired version and current resource data\n2. **Version Detection**: Determine source version from resource apiVersion field and target version from request\n3. **Conversion Path Selection**: Choose appropriate conversion function based on source and target versions\n4. **Field Mapping**: Transform fields according to version-specific mapping rules\n5. **Validation**: Ensure converted resource passes target version's schema validation\n6. **Response Generation**: Return ConversionResponse with converted resource or error details\n\n**Backward Compatibility Guarantees:**\n\n| Compatibility Type | Guarantee Level | Description |\n|--------------------|------------------|-------------|\n| Field Addition | Full | New optional fields can be added without breaking existing clients |\n| Field Deprecation | Gradual | Deprecated fields continue working with warning messages for at least one version |\n| Field Removal | Breaking | Removed fields cause validation errors and require client updates |\n| Field Type Change | Breaking | Changing field types requires new version and conversion logic |\n| Default Value Change | Potentially Breaking | May affect resources that rely on previous defaults |\n\n**Storage Version Migration Process:**\n\nWhen changing the storage version from v1beta1 to v1, existing resources in etcd must be migrated to the new format. This migration happens lazily—resources are converted when they're next read or updated—or can be triggered explicitly using the storage version migrator tool.\n\n**Migration State Tracking:**\n\n| Resource State | Description | Action Required |\n|----------------|-------------|------------------|\n| Native Storage | Resource stored in current storage version | No action needed |\n| Conversion Pending | Resource stored in old version, needs conversion on access | Automatic conversion on read/write |\n| Conversion Failed | Resource cannot be converted due to data incompatibility | Manual intervention required |\n| Schema Violation | Converted resource fails new version validation | Manual correction needed |\n\n⚠️ **Pitfall: Breaking Conversion Assumptions**\n\nA common mistake is assuming that conversion is always reversible. When converting from a newer version to an older version, information loss may occur if the newer version contains fields that don't exist in the older version. This information loss means that converting v1→v1alpha1→v1 might not produce the same result as the original v1 resource.\n\n**Solution**: Design conversion functions to preserve as much information as possible, use annotations to store unconvertible data, and test round-trip conversions to verify data integrity.\n\n⚠️ **Pitfall: Storage Version Migration Timing**\n\nChanging the storage version in a CRD immediately affects how new resources are stored, but existing resources remain in their original format until converted. This can create inconsistency where identical resources have different storage representations.\n\n**Solution**: Plan storage version migration carefully, use gradual rollout with monitoring, and consider running explicit migration jobs to convert existing resources proactively rather than waiting for lazy conversion.\n\n**Version Deprecation Process:**\n\n1. **Deprecation Announcement**: Mark version as deprecated in CRD status and release notes\n2. **Warning Generation**: API server returns warning headers when deprecated versions are used\n3. **Grace Period**: Maintain deprecated version for at least two minor releases\n4. **Usage Monitoring**: Track deprecated version usage through metrics and audit logs\n5. **Removal Planning**: Coordinate with users to migrate before version removal\n6. **Final Removal**: Remove deprecated version from CRD and update conversion webhooks\n\nThis structured deprecation process ensures users have adequate time to migrate while providing clear signals about upcoming changes. The warning system allows automated detection of deprecated version usage in continuous integration pipelines and monitoring systems.\n\n### Implementation Guidance\n\n**A. Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Schema Validation | OpenAPI v3 in CRD manifest | CEL expressions + admission webhooks |\n| Defaulting | Static defaults in CRD schema | Dynamic defaults via mutating webhook |\n| Versioning | Single stable version | Multiple versions with conversion webhooks |\n| Testing | kubectl dry-run validation | CRD validation test suite with controller-runtime |\n\n**B. Recommended File Structure:**\n\n```\noperator-project/\n├── config/\n│   ├── crd/\n│   │   ├── bases/\n│   │   │   └── example.com_databases.yaml     ← Generated CRD manifest\n│   │   └── kustomization.yaml\n│   └── samples/\n│       └── example_v1_database.yaml           ← Example custom resource\n├── api/\n│   └── v1/\n│       ├── database_types.go                   ← Database struct definitions\n│       ├── database_webhook.go                 ← Admission webhook logic\n│       ├── groupversion_info.go               ← API group registration\n│       └── zz_generated.deepcopy.go           ← Generated deep copy methods\n└── internal/\n    └── controller/\n        └── database_controller.go             ← Controller reconciliation logic\n```\n\n**C. Infrastructure Starter Code:**\n\nComplete CRD manifest generation configuration:\n\n```go\n// api/v1/database_types.go\npackage v1\n\nimport (\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/apimachinery/pkg/api/resource\"\n    corev1 \"k8s.io/api/core/v1\"\n)\n\n// DatabaseSpec defines the desired state of Database\ntype DatabaseSpec struct {\n    // +kubebuilder:validation:Minimum=1\n    // +kubebuilder:validation:Maximum=10\n    // +kubebuilder:default=1\n    Replicas int32 `json:\"replicas\"`\n\n    // +kubebuilder:validation:Pattern=\"^[0-9]+\\.[0-9]+\\.[0-9]+$\"\n    // +kubebuilder:default=\"5.7.0\"\n    Version string `json:\"version\"`\n\n    // +kubebuilder:validation:Pattern=\"^[0-9]+[KMGT]i?$\"\n    // +kubebuilder:default=\"10Gi\"\n    StorageSize string `json:\"storageSize\"`\n\n    // +kubebuilder:validation:Pattern=\"^(@(annually|yearly|monthly|weekly|daily|hourly|reboot))|(@every (\\\\d+(ns|us|µs|ms|s|m|h))+)|((\\\\d+|\\\\*)(/(\\\\d+))? (\\\\d+|\\\\*)(/(\\\\d+))? (\\\\d+|\\\\*)(/(\\\\d+))? (\\\\d+|\\\\*)(/(\\\\d+))? (\\\\d+|\\\\*)(/(\\\\d+))?)$\"\n    // +optional\n    BackupSchedule *string `json:\"backupSchedule,omitempty\"`\n\n    // +optional\n    Resources *corev1.ResourceRequirements `json:\"resources,omitempty\"`\n\n    // +kubebuilder:validation:MaxProperties=20\n    // +optional\n    Config map[string]string `json:\"config,omitempty\"`\n}\n\n// DatabaseStatus defines the observed state of Database\ntype DatabaseStatus struct {\n    // +optional\n    Conditions []metav1.Condition `json:\"conditions,omitempty\"`\n\n    // +optional\n    ReadyReplicas int32 `json:\"readyReplicas,omitempty\"`\n\n    // +optional\n    ObservedGeneration int64 `json:\"observedGeneration,omitempty\"`\n\n    // +kubebuilder:validation:Enum=Pending;Running;Failed;Terminating\n    // +optional\n    Phase string `json:\"phase,omitempty\"`\n\n    // +optional\n    LastBackupTime *metav1.Time `json:\"lastBackupTime,omitempty\"`\n\n    // +optional\n    Endpoints []string `json:\"endpoints,omitempty\"`\n\n    // +optional\n    Message string `json:\"message,omitempty\"`\n}\n\n//+kubebuilder:object:root=true\n//+kubebuilder:subresource:status\n//+kubebuilder:resource:shortName=db\n//+kubebuilder:printcolumn:name=\"Replicas\",type=integer,JSONPath=`.spec.replicas`\n//+kubebuilder:printcolumn:name=\"Ready\",type=integer,JSONPath=`.status.readyReplicas`\n//+kubebuilder:printcolumn:name=\"Version\",type=string,JSONPath=`.spec.version`\n//+kubebuilder:printcolumn:name=\"Phase\",type=string,JSONPath=`.status.phase`\n//+kubebuilder:printcolumn:name=\"Age\",type=date,JSONPath=`.metadata.creationTimestamp`\n\n// Database is the Schema for the databases API\ntype Database struct {\n    metav1.TypeMeta   `json:\",inline\"`\n    metav1.ObjectMeta `json:\"metadata,omitempty\"`\n\n    Spec   DatabaseSpec   `json:\"spec,omitempty\"`\n    Status DatabaseStatus `json:\"status,omitempty\"`\n}\n\n//+kubebuilder:object:root=true\n\n// DatabaseList contains a list of Database\ntype DatabaseList struct {\n    metav1.TypeMeta `json:\",inline\"`\n    metav1.ListMeta `json:\"metadata,omitempty\"`\n    Items           []Database `json:\"items\"`\n}\n\nfunc init() {\n    SchemeBuilder.Register(&Database{}, &DatabaseList{})\n}\n```\n\n**D. Core Logic Skeleton Code:**\n\nAdmission webhook implementation template:\n\n```go\n// api/v1/database_webhook.go\npackage v1\n\nimport (\n    \"context\"\n    \"fmt\"\n    apierrors \"k8s.io/apimachinery/pkg/api/errors\"\n    \"k8s.io/apimachinery/pkg/runtime\"\n    \"k8s.io/apimachinery/pkg/runtime/schema\"\n    \"k8s.io/apimachinery/pkg/util/validation/field\"\n    ctrl \"sigs.k8s.io/controller-runtime\"\n    \"sigs.k8s.io/controller-runtime/pkg/webhook\"\n)\n\n// SetupWebhookWithManager registers the webhook with the manager\nfunc (r *Database) SetupWebhookWithManager(mgr ctrl.Manager) error {\n    return ctrl.NewWebhookManagedBy(mgr).\n        For(r).\n        Complete()\n}\n\n//+kubebuilder:webhook:path=/mutate-example-com-v1-database,mutating=true,failurePolicy=fail,sideEffects=None,groups=example.com,resources=databases,verbs=create;update,versions=v1,name=mdatabase.kb.io,admissionReviewVersions=v1\n\nvar _ webhook.Defaulter = &Database{}\n\n// Default implements webhook.Defaulter so a webhook will be registered for the type\nfunc (r *Database) Default() {\n    // TODO 1: Set default replica count if not specified\n    // TODO 2: Set default version if not specified\n    // TODO 3: Set default storage size if not specified\n    // TODO 4: Set default resource requests if resources specified but requests missing\n    // Hint: Use pointer fields to detect when values are not set vs set to zero\n}\n\n//+kubebuilder:webhook:path=/validate-example-com-v1-database,mutating=false,failurePolicy=fail,sideEffects=None,groups=example.com,resources=databases,verbs=create;update,versions=v1,name=vdatabase.kb.io,admissionReviewVersions=v1\n\nvar _ webhook.Validator = &Database{}\n\n// ValidateCreate implements webhook.Validator so a webhook will be registered for the type\nfunc (r *Database) ValidateCreate() error {\n    // TODO 1: Validate replica count is reasonable for storage size\n    // TODO 2: Validate version format and ensure it's a supported version\n    // TODO 3: Validate backup schedule cron expression if provided\n    // TODO 4: Validate resource requests are less than or equal to limits\n    // TODO 5: Validate configuration parameters are valid for the specified version\n    return r.validateDatabase()\n}\n\n// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type\nfunc (r *Database) ValidateUpdate(old runtime.Object) error {\n    oldDB := old.(*Database)\n    \n    // TODO 1: Prevent downgrading to older versions\n    // TODO 2: Prevent reducing storage size (data loss risk)\n    // TODO 3: Validate replica count changes are within safe limits\n    // TODO 4: Ensure configuration changes are compatible with current version\n    return r.validateDatabase()\n}\n\n// ValidateDelete implements webhook.Validator so a webhook will be registered for the type\nfunc (r *Database) ValidateDelete() error {\n    // TODO 1: Check if database has active connections (would require external check)\n    // TODO 2: Verify backup is recent if backup schedule is configured\n    // TODO 3: Implement additional deletion safety checks as needed\n    return nil\n}\n\nfunc (r *Database) validateDatabase() error {\n    var allErrs field.ErrorList\n    \n    // TODO: Add field-specific validation logic here\n    // Use field.ErrorList to collect multiple validation errors\n    // Return apierrors.NewInvalid() with collected errors\n    \n    if len(allErrs) == 0 {\n        return nil\n    }\n    \n    return apierrors.NewInvalid(\n        schema.GroupKind{Group: \"example.com\", Kind: \"Database\"},\n        r.Name,\n        allErrs,\n    )\n}\n```\n\n**E. Language-Specific Hints:**\n\n- Use `kubebuilder` markers (`//+kubebuilder:validation:`) for generating OpenAPI schema validation\n- Use `controller-gen` to generate CRD manifests from Go struct definitions\n- Use `k8s.io/apimachinery/pkg/util/validation/field` for structured validation error reporting\n- Use pointer fields (`*string`, `*int32`) to distinguish between unset and zero values\n- Use `omitempty` JSON tags for optional fields to keep manifests clean\n- Use `sigs.k8s.io/controller-runtime/pkg/webhook` for admission webhook infrastructure\n\n**F. Milestone Checkpoint:**\n\nAfter implementing the CRD and webhooks, verify the following behavior:\n\n```bash\n# Generate and apply CRD\nmake manifests\nkubectl apply -f config/crd/bases/\n\n# Test schema validation\nkubectl apply -f - <<EOF\napiVersion: example.com/v1\nkind: Database\nmetadata:\n  name: test-invalid\nspec:\n  replicas: 0  # Should fail validation (minimum 1)\n  version: \"invalid\"  # Should fail pattern validation\n  storageSize: \"bad-format\"  # Should fail pattern validation\nEOF\n\n# Test successful creation\nkubectl apply -f - <<EOF\napiVersion: example.com/v1\nkind: Database\nmetadata:\n  name: test-valid\nspec:\n  replicas: 3\n  version: \"5.7.0\"\n  storageSize: \"20Gi\"\nEOF\n\n# Verify printer columns work\nkubectl get databases\n```\n\nExpected output should show validation errors for invalid resource and successful creation with custom columns for valid resource.\n\n**G. Debugging Tips:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| CRD not found error | CRD manifest not applied or malformed | `kubectl get crd databases.example.com -o yaml` | Apply CRD manifest with `kubectl apply -f` |\n| Schema validation not working | Kubebuilder markers incorrect or CRD not regenerated | Check CRD openAPIV3Schema section | Run `make manifests` and reapply CRD |\n| Webhook not called | Webhook configuration missing or service unreachable | `kubectl get validatingwebhookconfiguration,mutatingwebhookconfiguration` | Verify webhook configuration and service |\n| Certificate errors | TLS certificates expired or malformed | Check webhook pod logs for certificate errors | Regenerate certificates or check cert-manager |\n| Status updates fail | Status subresource not enabled in CRD | Check CRD for `subresources: status:` | Add status subresource to CRD spec |\n\n\n## Controller and Reconciliation Engine\n\n> **Milestone(s):** Milestone 2 (Controller Setup), Milestone 3 (Reconciliation Loop) - implements the core controller logic that watches custom resources and maintains desired state through continuous reconciliation\n\nThe controller is the beating heart of any Kubernetes operator. While custom resources define the API and webhooks validate incoming requests, the controller provides the intelligence that continuously monitors the cluster and takes action to maintain the desired state. This section details how to build a robust controller that can handle the complexities of distributed systems while integrating seamlessly with Kubernetes' declarative model.\n\n### Mental Model: The Control System\n\nThink of the Kubernetes controller as an **automatic thermostat for your infrastructure**. Just as a thermostat continuously measures the current temperature, compares it to the desired temperature setting, and adjusts the heating or cooling system to eliminate the difference, a Kubernetes controller continuously observes the actual state of resources, compares it to the desired state declared in custom resources, and takes corrective actions to eliminate any drift.\n\nThis analogy reveals several key insights about controller design. First, the controller operates on a **feedback loop** - it measures, compares, acts, and then measures again. The system is inherently reactive rather than predictive. Second, the controller must be **level-triggered rather than edge-triggered** - it doesn't just respond to change events, but continuously ensures the system remains in the correct state even after transient failures or external modifications. Third, like a good thermostat, the controller should be **patient and persistent** - it doesn't panic when the temperature is wrong, but steadily works to correct it over time.\n\nThe control theory perspective also highlights the importance of **convergence and stability**. A poorly designed thermostat might oscillate wildly, turning the heat on and off rapidly without ever settling at the target temperature. Similarly, a poorly designed controller might create resources, delete them, recreate them, and never reach a stable state. The reconciliation algorithm must be designed to converge toward the desired state and remain stable once reached.\n\nUnlike a simple thermostat, however, a Kubernetes controller operates in a **distributed system with partial failures**. The \"temperature sensor\" (informer cache) might be stale, the \"heating system\" (Kubernetes API) might be temporarily unavailable, or multiple \"thermostats\" (controller replicas) might be running simultaneously. The controller must be designed to handle these complexities gracefully while still maintaining the core feedback loop behavior.\n\n### Informer and Caching Architecture\n\nThe informer architecture is the foundation that makes efficient Kubernetes controllers possible. Without informers, controllers would need to constantly poll the API server to check for changes, creating excessive load and introducing latency. The informer pattern solves this by maintaining a **local, eventually consistent cache** of resources that the controller cares about.\n\nThink of the informer as a **dedicated research assistant** who maintains a constantly updated filing system of all relevant documents. Instead of the controller running to the library (API server) every time it needs to check something, the research assistant watches for new publications, updates the local files, and notifies the controller when something important changes. This allows the controller to work efficiently from local information while still staying current with the authoritative source.\n\nThe informer architecture consists of several key components working together. The **SharedIndexInformer** is the core component that watches a specific resource type and maintains a local cache. It uses the Kubernetes **list-and-watch** protocol to efficiently stay synchronized with the API server. The informer first performs a list operation to get the current state of all resources, then establishes a watch stream to receive incremental updates.\n\n| Informer Component | Purpose | Key Responsibilities |\n|-------------------|---------|----------------------|\n| SharedIndexInformer | Core caching and watching | Maintains local cache, watches for changes, triggers event handlers |\n| Reflector | API server communication | Implements list-and-watch protocol, handles connection failures |\n| DeltaFIFO | Event queuing | Queues resource changes, deduplicates events, provides ordering |\n| Store | Local cache storage | Indexes resources for efficient lookup, thread-safe access |\n| ResourceEventHandler | Change notification | Receives add/update/delete events, enqueues work items |\n\nThe **SharedIndexInformer** uses several sophisticated mechanisms to provide reliable caching. The informer maintains multiple indexes on the cached data, allowing efficient lookups by different criteria. For example, it can quickly find all resources in a specific namespace or all resources owned by a particular parent object. The informer also handles **resync periods** - even without changes, it periodically re-examines all cached resources to ensure the controller processes any items that might have been missed due to transient failures.\n\n> **Critical Insight**: The informer cache is eventually consistent, not strongly consistent. There's always a window where the local cache might not reflect the latest API server state. Controllers must be designed to handle this gracefully by making their operations idempotent and tolerating stale information.\n\nEvent handling in the informer architecture follows a specific pattern designed for reliability and performance. When the informer detects a change, it doesn't immediately call the controller's reconciliation logic. Instead, it calls a **ResourceEventHandler** that typically just enqueues a work item into a rate-limited work queue. This decoupling is essential for several reasons: it prevents slow reconciliation logic from blocking the informer's watch stream, it allows for batching and deduplication of rapid changes to the same resource, and it enables sophisticated retry and backoff strategies.\n\n| Event Handler Method | When Called | Typical Action |\n|---------------------|-------------|----------------|\n| OnAdd | Resource created or informer started | Enqueue resource key for reconciliation |\n| OnUpdate | Resource spec or status changed | Compare old vs new, enqueue if meaningful change |\n| OnDelete | Resource deleted | Enqueue resource key for cleanup reconciliation |\n\nThe work queue used with informers provides several critical capabilities for robust controller operation. The **RateLimitingInterface** prevents controllers from overwhelming the API server with rapid requests when resources are changing frequently. The queue implements **exponential backoff** - if reconciling a resource fails, the queue will wait increasingly longer periods before retrying the same resource. The queue also provides **deduplication** - if the same resource changes multiple times before the controller processes it, only one reconciliation is triggered.\n\n> **Decision: SharedIndexInformer vs Direct API Calls**  \n> - **Context**: Controllers need to read resource state frequently during reconciliation. Direct API calls would create excessive load and latency.  \n> - **Options Considered**: Direct API calls for each read, local caching without watches, SharedIndexInformer pattern  \n> - **Decision**: Use SharedIndexInformer for all resource reads  \n> - **Rationale**: Provides efficient local caching, automatic synchronization, built-in indexing, and integrates with controller-runtime patterns. Reduces API server load by orders of magnitude while providing sub-second change notification.  \n> - **Consequences**: Controller logic must handle eventually consistent data and implement idempotent operations. Memory usage increases with number of cached resources.\n\nThe informer lifecycle requires careful management to ensure proper startup and shutdown behavior. During controller startup, the informer must complete its initial **cache synchronization** before the controller begins processing work items. This ensures that the local cache contains a complete view of existing resources before reconciliation begins. The `cache.WaitForCacheSync` function provides this capability, blocking until the informer has completed its initial list operation and is ready to serve requests.\n\n| Informer Lifecycle Phase | Actions Required | Common Pitfalls |\n|-------------------------|------------------|-----------------|\n| Startup | Start informer, wait for cache sync | Processing events before sync complete |\n| Running | Process events, handle watch errors | Blocking event handlers with slow operations |\n| Shutdown | Stop informer, drain work queue | Goroutine leaks from improper cleanup |\n\n### Reconciliation Algorithm\n\nThe reconciliation algorithm is where the controller's intelligence lives. This algorithm implements the core feedback loop that compares desired state (from the custom resource spec) with actual state (from the cluster) and takes corrective actions to eliminate any differences. The algorithm must be **idempotent**, **convergent**, and **robust** in the face of partial failures and concurrent modifications.\n\nThe reconciliation process follows a well-defined sequence of steps that ensures consistent and reliable behavior. Each step builds upon the previous one, creating a logical progression from observation through decision-making to action. Understanding this sequence is crucial for implementing correct controller behavior.\n\n**Step 1: Resource Retrieval and Validation**\n\nThe reconciliation begins by retrieving the current state of the custom resource that triggered the reconciliation. This involves fetching the resource from the local informer cache (not directly from the API server) and performing basic validation to ensure the resource is in a state that can be reconciled.\n\nDuring this phase, the controller must handle several edge cases. The resource might have been deleted between the time it was enqueued and when reconciliation begins. The resource might be in the middle of being deleted (having a non-zero deletion timestamp) but still have finalizers that prevent actual removal. The resource might have been modified by another client, changing its generation number since it was last processed.\n\n**Step 2: Current State Discovery**\n\nOnce the target resource is validated, the controller must discover the current state of all resources that should exist to satisfy the desired configuration. This typically involves querying for Deployments, Services, ConfigMaps, and other Kubernetes resources that the operator manages on behalf of the custom resource.\n\nThis discovery phase uses **owner references** to identify managed resources. Each resource created by the controller should have an owner reference pointing back to the custom resource that caused its creation. This enables both discovery (finding all owned resources) and automatic garbage collection (when the owner is deleted, Kubernetes automatically removes owned resources).\n\n| Resource Discovery Pattern | Query Method | Purpose |\n|---------------------------|-------------|---------|\n| List with label selectors | `client.List(ctx, &list, client.MatchingLabels{...})` | Find resources with specific labels |\n| List with owner references | `client.List(ctx, &list, client.MatchingFields{\".metadata.ownerReferences.uid\": owner.UID})` | Find all resources owned by custom resource |\n| Direct name lookup | `client.Get(ctx, namespacedName, &resource)` | Check existence of expected resource |\n\n**Step 3: Desired State Computation**\n\nWith the current state known, the controller must compute what the desired state should look like based on the custom resource's spec. This computation transforms the high-level desired configuration into specific Kubernetes resources with complete specifications.\n\nThis step often involves complex logic specific to the application being managed. For a database operator, it might involve determining the appropriate container images, computing resource requirements, generating configuration files, and deciding on networking configuration. The key principle is that this computation should be **deterministic** - given the same input spec, it should always produce the same desired resource configurations.\n\n**Step 4: Difference Analysis**\n\nThe heart of the reconciliation algorithm is comparing the current state with the desired state to identify what changes need to be made. This comparison must be sophisticated enough to distinguish between meaningful differences that require action and insignificant differences that should be ignored.\n\nSome fields in Kubernetes resources are modified by the system after creation and should not be considered during difference analysis. For example, the `resourceVersion` field changes with every update, and many fields have default values set by admission controllers. The controller must know which fields are significant for its purposes and focus only on those during comparison.\n\n| Difference Type | Action Required | Example |\n|----------------|----------------|---------|\n| Missing resource | Create with desired spec | Deployment doesn't exist but should |\n| Extra resource | Delete unwanted resource | Service exists but shouldn't based on current spec |\n| Configuration drift | Update to match desired spec | Container image version differs from spec |\n| Status-only changes | No action (status-only update) | Ready replicas count changed |\n\n**Step 5: Corrective Actions**\n\nBased on the difference analysis, the controller takes corrective actions to move the actual state toward the desired state. These actions typically involve creating, updating, or deleting Kubernetes resources through the client library.\n\nThe order of operations matters significantly during this phase. Resources with dependencies should be created in the correct order (ConfigMaps before Deployments that reference them), and deletions should happen in reverse dependency order. The controller should also be prepared for operations to fail partially and leave the system in an intermediate state.\n\n**Step 6: Status Update**\n\nAfter attempting corrective actions, the controller updates the custom resource's status to reflect the current state of reconciliation. This provides visibility to users about what the controller has accomplished and whether any problems were encountered.\n\nThe status update should include several types of information: overall conditions indicating the health and progress of reconciliation, specific metrics like the number of ready replicas, and detailed messages about any errors encountered. This information is crucial for debugging and monitoring operator behavior.\n\n| Status Field | Purpose | Example Values |\n|-------------|---------|----------------|\n| Conditions | Overall health and progress | Ready=True, Progressing=False |\n| ReadyReplicas | Current operational capacity | 3 (out of 3 desired replicas) |\n| ObservedGeneration | Last spec version processed | matches metadata.generation when up-to-date |\n| Phase | High-level lifecycle state | Pending, Ready, Failed |\n| Message | Human-readable status description | \"All replicas are ready and serving traffic\" |\n\nThe complete reconciliation algorithm can be expressed as the following decision flow:\n\n1. **Retrieve target custom resource from cache**\n   - If not found, log and return (resource was deleted)\n   - If deletion timestamp set, proceed with cleanup logic\n   - If generation unchanged and conditions current, return early (optimization)\n\n2. **Discovery current owned resources**\n   - Query for all resources with owner references to this custom resource\n   - Query for resources matching expected names and labels\n   - Build map of current resource state keyed by resource type and name\n\n3. **Compute desired resource specifications**\n   - Transform custom resource spec into concrete Kubernetes resource specs\n   - Apply naming conventions, labels, owner references\n   - Generate configurations, secrets, and other derived resources\n\n4. **Perform three-way diff analysis**\n   - Compare desired vs current for each resource type\n   - Identify resources to create, update, or delete\n   - Filter out insignificant differences (system-managed fields)\n\n5. **Execute corrective actions in dependency order**\n   - Create missing dependencies first (ConfigMaps, Secrets)\n   - Create or update primary resources (Deployments, Services)\n   - Delete obsolete resources last\n   - Handle partial failures gracefully\n\n6. **Update custom resource status**\n   - Set conditions based on reconciliation success/failure\n   - Update metrics (ready replicas, observed generation)\n   - Record detailed error messages for debugging\n   - Use status subresource to avoid update conflicts\n\n> **Decision: Reconciliation Frequency Strategy**  \n> - **Context**: Controllers need to balance responsiveness with efficiency, ensuring timely updates without overwhelming the API server  \n> - **Options Considered**: Continuous polling, event-driven only, hybrid approach with periodic resync  \n> - **Decision**: Event-driven reconciliation with configurable resync period (default 10 hours)  \n> - **Rationale**: Event-driven provides immediate response to changes while periodic resync catches missed events and handles external modifications. Long resync period minimizes unnecessary work while providing eventual consistency guarantees.  \n> - **Consequences**: Enables efficient resource usage while maintaining strong consistency. Requires careful event handler implementation to avoid missing important changes.\n\n### Error Handling and Requeue Strategy\n\nRobust error handling is what separates production-ready controllers from toy implementations. In distributed systems, failures are not exceptional - they are expected and must be handled gracefully. A well-designed controller can distinguish between different types of failures and respond appropriately to each category.\n\nThe fundamental insight for controller error handling is that **most failures are transient** and will resolve themselves if the controller simply waits and retries. Network connectivity issues, temporary API server overload, and resource conflicts during concurrent updates all fall into this category. However, some failures are **permanent** and will never succeed no matter how many times they are retried. Attempting to create a resource with an invalid name or referencing a non-existent secret will fail consistently until the underlying problem is fixed.\n\n**Transient vs Permanent Error Classification**\n\nThe controller's error handling strategy begins with correctly classifying errors as transient or permanent. This classification determines whether the controller should retry the operation automatically or surface the error to users for manual intervention.\n\n| Error Category | Examples | Handling Strategy |\n|---------------|----------|-------------------|\n| Transient Network | Connection timeout, DNS resolution failure | Exponential backoff retry |\n| Transient API Server | Rate limiting, temporary overload | Exponential backoff with jitter |\n| Transient Resource | Update conflicts, temporary resource constraints | Linear backoff retry |\n| Permanent Configuration | Invalid resource names, malformed specs | Surface error, no retry |\n| Permanent Permission | RBAC denials, forbidden operations | Surface error, log for admin |\n| Permanent Dependency | Non-existent secrets, missing CRDs | Surface error, watch for dependency |\n\nTransient errors should trigger **automatic retry with backoff**. The controller enqueues the resource for reprocessing after a delay, with the delay increasing on subsequent failures. This prevents the controller from overwhelming struggling components while still providing timely retry when conditions improve.\n\nPermanent errors should **not trigger automatic retry**. Instead, the controller should update the resource status with a detailed error message, emit a warning event, and wait for external action to resolve the underlying problem. Continuing to retry permanent failures wastes resources and creates excessive log noise.\n\n**Exponential Backoff Implementation**\n\nThe work queue provides sophisticated retry mechanisms that implement exponential backoff automatically. When the controller returns an error from the `Reconcile` function, the controller-runtime framework interprets this as a request to retry the operation after a delay.\n\nThe backoff algorithm starts with a base delay (typically 1 second) and doubles the delay after each failure, up to a maximum delay (typically 16 minutes). This exponential growth ensures that transient issues get resolved quickly while preventing permanent failures from consuming excessive resources.\n\n| Failure Count | Retry Delay | Cumulative Time | Rationale |\n|--------------|-------------|-----------------|-----------|\n| 1 | 1 second | 1 second | Quick recovery for brief glitches |\n| 2 | 2 seconds | 3 seconds | Still responsive for short outages |\n| 3 | 4 seconds | 7 seconds | Moderate backing off |\n| 4 | 8 seconds | 15 seconds | Reduced load during longer issues |\n| 5 | 16 seconds | 31 seconds | Significant backoff |\n| 10 | 16 minutes | ~17 minutes | Maximum delay prevents resource waste |\n\n**Jitter** is added to the backoff delays to prevent **thundering herd** problems when many controllers are retrying simultaneously. Without jitter, if the API server becomes unavailable and then recovers, all controllers would retry at exactly the same time, potentially overwhelming the server again. Jitter adds randomness to spread out the retry attempts.\n\n**Requeue Strategies**\n\nThe controller-runtime framework provides several mechanisms for requesting that a resource be reprocessed:\n\n| Requeue Method | When to Use | Behavior |\n|---------------|-------------|----------|\n| `return ctrl.Result{}, err` | Transient error occurred | Exponential backoff based on error count |\n| `return ctrl.Result{RequeueAfter: duration}, nil` | Need to check again after specific time | Fixed delay, resets error count |\n| `return ctrl.Result{Requeue: true}, nil` | Need immediate reprocessing | Immediate enqueue, resets error count |\n| `return ctrl.Result{}, nil` | Reconciliation successful | No requeue, wait for next event |\n\nThe choice between these requeue strategies depends on the specific situation encountered during reconciliation. Transient errors should use the error return to trigger exponential backoff. Situations where the controller needs to wait for an external condition (like waiting for a deployment to become ready) should use `RequeueAfter` with an appropriate delay. Immediate requeue should be used sparingly and only when the controller knows that conditions have changed and reconciliation should succeed.\n\n**Reconciliation Result Patterns**\n\nDifferent reconciliation outcomes require different result patterns to ensure optimal controller behavior:\n\n```\n// Successful reconciliation, no further action needed\nreturn ctrl.Result{}, nil\n\n// Transient error, use exponential backoff\nif isTransientError(err) {\n    return ctrl.Result{}, err\n}\n\n// Permanent error, update status and don't retry\nr.updateErrorStatus(ctx, database, err)\nreturn ctrl.Result{}, nil\n\n// Waiting for external condition, check again in 30 seconds\nif !allResourcesReady {\n    return ctrl.Result{RequeueAfter: REQUEUE_AFTER_DURATION}, nil\n}\n\n// Configuration changed during reconciliation, reprocess immediately\nif resourceModified {\n    return ctrl.Result{Requeue: true}, nil\n}\n```\n\n**Status Condition Management**\n\nError handling integrates closely with status condition management. The controller should maintain conditions that reflect the current state of reconciliation, including any errors encountered. Well-designed conditions provide both programmatic and human-readable information about controller state.\n\n| Condition Type | Status | Reason | Meaning |\n|---------------|--------|---------|---------|\n| Ready | True | AllResourcesReady | Reconciliation successful, all resources operational |\n| Ready | False | ReconciliationInProgress | Reconciliation in progress, resources not yet ready |\n| Ready | False | ReconciliationFailed | Permanent error prevents successful reconciliation |\n| Progressing | True | CreatingResources | Controller actively working to reach desired state |\n| Progressing | False | ReconciledSuccessfully | Desired state achieved, no work in progress |\n\n> **Decision: Error Classification Strategy**  \n> - **Context**: Controllers must distinguish between errors that should trigger retry vs errors that require human intervention  \n> - **Options Considered**: Retry all errors, never retry errors, classify by error type and HTTP status  \n> - **Decision**: Classify errors by HTTP status code and error type, with configurable retry limits  \n> - **Rationale**: HTTP 4xx errors (except 408, 429) are typically permanent while 5xx errors are transient. Specific error types (validation failures) can be classified regardless of HTTP status. Retry limits prevent infinite loops on misclassified errors.  \n> - **Consequences**: Enables efficient resource usage and faster recovery from transient issues. Requires careful error classification logic and monitoring of retry patterns.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Processing Events Before Cache Sync**\n\nA common mistake is starting the reconciliation loop before the informer cache has completed its initial synchronization. This can lead to creating duplicate resources because the controller doesn't see existing resources in its empty cache. Always wait for `cache.WaitForCacheSync` to return true before starting worker goroutines.\n\n⚠️ **Pitfall: Blocking Event Handlers**\n\nEvent handlers (`OnAdd`, `OnUpdate`, `OnDelete`) run in the informer's goroutine and must not block. Performing expensive operations or API calls directly in event handlers will block the informer's watch stream, preventing it from processing new events. Event handlers should only enqueue work items and return quickly.\n\n⚠️ **Pitfall: Not Implementing Idempotent Operations**\n\nControllers may reconcile the same resource multiple times due to retries, cache inconsistencies, or multiple events. All reconciliation operations must be idempotent - applying the same reconciliation multiple times should produce the same result. This requires checking existing resource state before creating new resources.\n\n⚠️ **Pitfall: Ignoring Owner References**\n\nWithout proper owner references, the controller cannot reliably discover resources it created, and garbage collection will not work correctly. Every resource created by the controller must have an owner reference pointing to the custom resource that caused its creation. Use `controllerutil.SetControllerReference` to set these correctly.\n\n⚠️ **Pitfall: Status Update Conflicts**\n\nUpdating both spec and status fields in the same operation can cause update conflicts with other clients. Use the status subresource (`client.Status().Update()`) to update status independently from spec changes. This allows the controller to update status without conflicting with user spec modifications.\n\n⚠️ **Pitfall: Infinite Reconciliation Loops**\n\nIf the controller modifies resources in a way that triggers its own event handlers, it can create infinite reconciliation loops. Be careful when updating resources that the controller watches. Use proper condition checking to avoid unnecessary updates, and ensure that status updates don't trigger spec changes.\n\n⚠️ **Pitfall: Not Handling Finalizers Properly**\n\nWhen using finalizers for cleanup, controllers must remove the finalizer after successful cleanup, or the resource will be stuck in deletion state forever. Always implement finalizer removal logic and test deletion scenarios thoroughly.\n\n![Operator Architecture Overview](./diagrams/operator-architecture.svg)\n\n![Resource Reconciliation State Machine](./diagrams/reconciliation-state-machine.svg)\n\n![Reconciliation Algorithm Flowchart](./diagrams/reconciliation-algorithm-flow.svg)\n\n![Error Handling and Recovery Flow](./diagrams/error-recovery-flow.svg)\n\n### Implementation Guidance\n\nThis section provides concrete code patterns and infrastructure to implement the controller architecture described above. The focus is on providing complete, working infrastructure code while leaving the core business logic for you to implement.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Controller Framework | controller-runtime (kubebuilder style) | Custom controller with client-go directly |\n| Client Library | controller-runtime client (unified interface) | Separate typed and dynamic clients |\n| Work Queue | controller-runtime managed queues | Manual workqueue.RateLimitingInterface |\n| Informer Setup | controller-runtime managed informers | Manual shared informer factory |\n| Testing Framework | controller-runtime envtest | Custom test cluster setup |\n\n#### Recommended File Structure\n\n```\ninternal/controller/\n  database_controller.go           ← main controller implementation\n  database_controller_test.go      ← unit tests with fake client\n  suite_test.go                    ← integration test suite setup\ninternal/resources/\n  deployment.go                    ← deployment resource builder\n  service.go                       ← service resource builder  \n  configmap.go                     ← configmap resource builder\nconfig/\n  samples/                         ← example custom resources\n    database_v1_database.yaml\n  manager/\n    manager.yaml                   ← controller deployment\n```\n\n#### Infrastructure Starter Code\n\n**Complete Controller Structure (internal/controller/database_controller.go):**\n\n```go\npackage controller\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n\n    appsv1 \"k8s.io/api/apps/v1\"\n    corev1 \"k8s.io/api/core/v1\"\n    \"k8s.io/apimachinery/pkg/api/errors\"\n    \"k8s.io/apimachinery/pkg/runtime\"\n    \"k8s.io/apimachinery/pkg/types\"\n    ctrl \"sigs.k8s.io/controller-runtime\"\n    \"sigs.k8s.io/controller-runtime/pkg/client\"\n    \"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil\"\n    \"sigs.k8s.io/controller-runtime/pkg/log\"\n\n    databasev1 \"github.com/example/database-operator/api/v1\"\n)\n\nconst (\n    REQUEUE_AFTER_DURATION = 30 * time.Second\n    FINALIZER_NAME         = \"database.example.com/finalizer\"\n)\n\n// DatabaseReconciler reconciles a Database object\ntype DatabaseReconciler struct {\n    client.Client\n    Scheme *runtime.Scheme\n}\n\n//+kubebuilder:rbac:groups=database.example.com,resources=databases,verbs=get;list;watch;create;update;patch;delete\n//+kubebuilder:rbac:groups=database.example.com,resources=databases/status,verbs=get;update;patch\n//+kubebuilder:rbac:groups=database.example.com,resources=databases/finalizers,verbs=update\n//+kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete\n//+kubebuilder:rbac:groups=\"\",resources=services,verbs=get;list;watch;create;update;patch;delete\n//+kubebuilder:rbac:groups=\"\",resources=configmaps,verbs=get;list;watch;create;update;patch;delete\n//+kubebuilder:rbac:groups=\"\",resources=events,verbs=create;patch\n\n// SetupWithManager sets up the controller with the Manager.\nfunc (r *DatabaseReconciler) SetupWithManager(mgr ctrl.Manager) error {\n    return ctrl.NewControllerManagedBy(mgr).\n        For(&databasev1.Database{}).\n        Owns(&appsv1.Deployment{}).\n        Owns(&corev1.Service{}).\n        Owns(&corev1.ConfigMap{}).\n        Complete(r)\n}\n```\n\n**Work Queue and Event Handling Infrastructure:**\n\n```go\n// ConditionType represents the type of condition\ntype ConditionType string\n\nconst (\n    ConditionTypeReady      ConditionType = \"Ready\"\n    ConditionTypeProgressing ConditionType = \"Progressing\"\n)\n\n// ConditionStatus represents the status of a condition\ntype ConditionStatus string\n\nconst (\n    ConditionStatusTrue    ConditionStatus = \"True\"\n    ConditionStatusFalse   ConditionStatus = \"False\" \n    ConditionStatusUnknown ConditionStatus = \"Unknown\"\n)\n\n// updateCondition updates or adds a condition to the Database status\nfunc (r *DatabaseReconciler) updateCondition(database *databasev1.Database, conditionType ConditionType, status ConditionStatus, reason, message string) {\n    condition := databasev1.Condition{\n        Type:               string(conditionType),\n        Status:             string(status),\n        LastTransitionTime: metav1.Now(),\n        Reason:             reason,\n        Message:            message,\n        ObservedGeneration: database.Generation,\n    }\n\n    // Find existing condition of same type\n    for i, existing := range database.Status.Conditions {\n        if existing.Type == condition.Type {\n            // Only update if status changed\n            if existing.Status != condition.Status {\n                database.Status.Conditions[i] = condition\n            } else {\n                // Update message but keep transition time\n                database.Status.Conditions[i].Message = message\n                database.Status.Conditions[i].Reason = reason\n                database.Status.Conditions[i].ObservedGeneration = database.Generation\n            }\n            return\n        }\n    }\n\n    // Add new condition\n    database.Status.Conditions = append(database.Status.Conditions, condition)\n}\n\n// isErrorRetryable determines if an error should trigger exponential backoff retry\nfunc isErrorRetryable(err error) bool {\n    if errors.IsTimeout(err) || errors.IsServerTimeout(err) {\n        return true\n    }\n    if errors.IsServiceUnavailable(err) || errors.IsInternalError(err) {\n        return true\n    }\n    if errors.IsTooManyRequests(err) {\n        return true\n    }\n    if errors.IsConflict(err) {\n        return true // Resource conflicts are typically transient\n    }\n    // 4xx errors (except above) are typically permanent\n    if errors.IsNotFound(err) || errors.IsAlreadyExists(err) {\n        return false\n    }\n    if errors.IsBadRequest(err) || errors.IsInvalid(err) {\n        return false\n    }\n    if errors.IsForbidden(err) || errors.IsUnauthorized(err) {\n        return false\n    }\n    // Default to retryable for unknown errors\n    return true\n}\n```\n\n#### Core Logic Skeleton Code\n\n**Main Reconciliation Logic (implement this yourself):**\n\n```go\n// Reconcile is part of the main kubernetes reconciliation loop which aims to\n// move the current state of the cluster closer to the desired state.\nfunc (r *DatabaseReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {\n    log := log.FromContext(ctx)\n    log.Info(\"Starting reconciliation\", \"database\", req.NamespacedName)\n\n    // TODO 1: Fetch the Database instance from the cache\n    // Use r.Get(ctx, req.NamespacedName, &database) to retrieve the resource\n    // If not found, return success (resource was deleted)\n    // Hint: Use errors.IsNotFound(err) to check for not found errors\n\n    // TODO 2: Handle deletion logic if deletion timestamp is set\n    // Check if database.DeletionTimestamp != nil\n    // If deleting and has finalizer, perform cleanup and remove finalizer\n    // Return after handling deletion\n    // Hint: Use controllerutil.ContainsFinalizer() and controllerutil.RemoveFinalizer()\n\n    // TODO 3: Add finalizer if not present\n    // Check if finalizer is present using controllerutil.ContainsFinalizer()\n    // If missing, add it using controllerutil.AddFinalizer() and update resource\n    // Hint: This ensures cleanup logic runs before deletion\n\n    // TODO 4: Discover current state of all owned resources\n    // Find existing Deployment, Service, ConfigMap using owner references\n    // Build a map of current resources keyed by type and name\n    // Hint: Use client.List with owner reference field selector or label selectors\n\n    // TODO 5: Compute desired state based on Database spec\n    // Call helper functions to generate desired Deployment, Service, ConfigMap specs\n    // Apply naming conventions, labels, and owner references\n    // Hint: Use controllerutil.SetControllerReference to set owner references\n\n    // TODO 6: Perform three-way diff and apply changes\n    // Compare current vs desired for each resource type\n    // Create missing resources, update modified resources, delete obsolete resources\n    // Handle partial failures gracefully - update what you can\n    // Hint: Use r.createOrUpdateResource() helper for each resource\n\n    // TODO 7: Update Database status based on reconciliation results\n    // Set conditions (Ready, Progressing) based on success/failure\n    // Update ReadyReplicas from Deployment status\n    // Set ObservedGeneration to database.Generation when fully reconciled\n    // Use r.Status().Update() to persist status changes\n\n    // TODO 8: Determine appropriate return value\n    // Return error for transient failures (triggers exponential backoff)\n    // Return RequeueAfter for waiting on external conditions\n    // Return success (empty Result) when reconciliation complete\n    // Hint: Use isErrorRetryable() to classify errors\n\n    return ctrl.Result{}, nil\n}\n```\n\n**Resource Management Helper (implement this yourself):**\n\n```go\n// createOrUpdateResource creates or updates a Kubernetes resource to match desired state\nfunc (r *DatabaseReconciler) createOrUpdateResource(ctx context.Context, desired client.Object, database *databasev1.Database) error {\n    log := log.FromContext(ctx)\n    \n    // TODO 1: Check if resource already exists\n    // Create a new instance of the same type as desired\n    // Use r.Get() to fetch existing resource\n    // Handle both found and not found cases\n    // Hint: Use errors.IsNotFound() to distinguish cases\n\n    // TODO 2: If resource doesn't exist, create it\n    // Set owner reference to the Database resource\n    // Use r.Create() to create the resource\n    // Log creation and return any errors\n    // Hint: Use controllerutil.SetControllerReference()\n\n    // TODO 3: If resource exists, check if update is needed\n    // Compare significant fields between existing and desired\n    // Skip fields that are modified by the system (resourceVersion, etc.)\n    // Decide whether an update is necessary\n    // Hint: Focus on spec fields, ignore status and metadata\n\n    // TODO 4: Update resource if changes detected\n    // Copy desired spec into existing resource\n    // Preserve system-managed fields (resourceVersion, etc.)\n    // Use r.Update() to persist changes\n    // Log update and return any errors\n\n    return nil\n}\n```\n\n**Status Management Helper (implement this yourself):**\n\n```go\n// updateDatabaseStatus updates the Database status subresource with current state\nfunc (r *DatabaseReconciler) updateDatabaseStatus(ctx context.Context, database *databasev1.Database) error {\n    log := log.FromContext(ctx)\n\n    // TODO 1: Fetch current Deployment status\n    // Look up the Deployment owned by this Database\n    // Extract ready replicas, total replicas, and conditions\n    // Handle case where Deployment doesn't exist yet\n    // Hint: Use same naming convention as resource creation\n\n    // TODO 2: Update Database status fields\n    // Set ReadyReplicas from Deployment status\n    // Set ObservedGeneration to database.Generation when fully processed  \n    // Determine overall Phase (Pending, Ready, Failed)\n    // Update Endpoints if Service exists\n\n    // TODO 3: Update status conditions\n    // Set Ready condition based on whether all resources are operational\n    // Set Progressing condition based on whether work is in progress\n    // Include detailed messages for debugging\n    // Hint: Use r.updateCondition() helper\n\n    // TODO 4: Persist status changes\n    // Use r.Status().Update() to update only status subresource\n    // This avoids conflicts with spec changes\n    // Return any update errors\n    // Hint: Status updates use different RBAC permissions\n\n    return r.Status().Update(ctx, database)\n}\n```\n\n#### Language-Specific Hints\n\n- Use `sigs.k8s.io/controller-runtime/pkg/client` for all API operations - it provides caching and works with both typed and untyped resources\n- Use `controllerutil.SetControllerReference()` to establish owner relationships - this enables automatic garbage collection\n- Use `errors.IsNotFound()`, `errors.IsConflict()`, etc. for proper error classification rather than string matching\n- Use `ctrl.Request.NamespacedName` type for resource keys - it's the standard way to identify resources\n- Use `metav1.Now()` for condition timestamps to ensure consistent time format\n- Use `runtime.Object` interface for generic resource handling in helper functions\n\n#### Milestone Checkpoint\n\nAfter implementing the controller logic:\n\n**Test Command**: `go test ./internal/controller/... -v`\n\n**Expected Behavior**:\n- Controller starts and waits for cache sync before processing\n- Creating a Database resource triggers reconciliation\n- Owned Deployment, Service, and ConfigMap are created with proper owner references  \n- Database status is updated with Ready condition and replica counts\n- Deleting Database triggers finalizer cleanup before actual deletion\n- Status subresource updates don't conflict with spec changes\n\n**Manual Verification**:\n```bash\n# Create test Database resource\nkubectl apply -f config/samples/database_v1_database.yaml\n\n# Verify owned resources were created\nkubectl get deployments,services,configmaps -l app.kubernetes.io/name=database-sample\n\n# Check Database status\nkubectl get database database-sample -o yaml | grep -A 20 status:\n\n# Verify owner references are set\nkubectl get deployment database-sample-deployment -o yaml | grep -A 10 ownerReferences:\n```\n\n**Signs Something is Wrong**:\n- \"cache not started\" errors → informer not properly initialized\n- Resources created without owner references → garbage collection won't work\n- Status updates causing \"conflict\" errors → not using status subresource\n- Reconciliation not triggered by resource changes → event handlers not configured\n- Controller processing before cache sync → missing WaitForCacheSync\n\n\n## Admission Control with Webhooks\n\n> **Milestone(s):** Milestone 4 (Webhooks) - implements admission webhooks for validation and mutation that intercept resource operations before they reach storage\n\nAdmission webhooks represent one of the most powerful extensibility mechanisms in Kubernetes, allowing operators to implement custom business logic that executes during the resource lifecycle. These webhooks act as gatekeepers that can inspect, validate, and modify resources before they are persisted to etcd, providing a critical control point for enforcing organizational policies and ensuring data consistency.\n\n### Mental Model: The Gatekeeper\n\nThink of admission webhooks as security guards at the entrance to a high-security building. Just as every person entering the building must pass through a checkpoint where guards verify credentials, check for prohibited items, and potentially provide visitor badges, every resource entering the Kubernetes API must pass through admission control where webhooks can validate the request, reject invalid operations, and inject required metadata.\n\nThe analogy extends further: just as there might be multiple checkpoints with different responsibilities (one guard checks identification, another performs security screening, a third issues access badges), Kubernetes runs multiple webhook types in a specific order. **Mutating webhooks** act like the badge-issuing station - they can add required information to requests (like default values or labels). **Validating webhooks** act like the final security checkpoint - they perform comprehensive validation and can deny entry entirely if something is wrong.\n\nThe critical insight is that these gatekeepers operate synchronously in the request path. When a user runs `kubectl apply`, their request doesn't go directly to storage - it first passes through this entire admission chain. If any webhook rejects the request, the operation fails immediately and nothing gets stored. This provides strong consistency guarantees that manual validation processes cannot match.\n\n> **Decision: Synchronous vs Asynchronous Webhook Processing**\n> - **Context**: Admission webhooks could potentially operate asynchronously to avoid blocking the API request path, but this would require complex coordination mechanisms\n> - **Options Considered**: Synchronous processing during admission, asynchronous processing with eventual validation, hybrid approach with fast-path synchronous and slow-path asynchronous\n> - **Decision**: Synchronous processing during admission control\n> - **Rationale**: Provides immediate feedback to users, ensures invalid resources never reach storage, and maintains strong consistency without complex reconciliation logic for validation failures\n> - **Consequences**: Webhook latency directly impacts API response time, requires careful timeout configuration, but provides superior user experience and data integrity guarantees\n\n### Validating Webhook Implementation\n\nValidating admission webhooks implement business rule validation that goes beyond what OpenAPI schema validation can express in the Custom Resource Definition. While CRD schemas excel at structural validation (ensuring fields have correct types, required fields are present), validating webhooks handle cross-field validation, external dependency checks, and complex business logic that requires computational evaluation.\n\nThe webhook receives an `AdmissionReview` request containing the proposed resource and must return an `AdmissionResponse` indicating whether to allow or deny the operation. The webhook has access to both the new resource (for create operations) and the old resource (for update operations), enabling sophisticated change validation that can prevent invalid state transitions.\n\n**AdmissionReview Request Structure:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `kind` | string | Always \"AdmissionReview\" |\n| `apiVersion` | string | API version of the admission review (admission.k8s.io/v1) |\n| `request.uid` | string | Unique identifier for this admission request - must be included in response |\n| `request.kind` | GroupVersionKind | The resource type being validated (e.g., Database) |\n| `request.namespace` | string | Namespace of the resource being created/updated |\n| `request.operation` | string | CREATE, UPDATE, or DELETE |\n| `request.object` | runtime.RawExtension | The new resource being created or updated (JSON-encoded) |\n| `request.oldObject` | runtime.RawExtension | The existing resource (only present for UPDATE operations) |\n| `request.userInfo` | UserInfo | Information about the user making the request |\n| `request.dryRun` | bool | True if this is a dry-run operation (kubectl apply --dry-run) |\n\n**AdmissionResponse Structure:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `uid` | string | Must match the request UID |\n| `allowed` | bool | Whether the operation should be permitted |\n| `result.status` | string | \"Success\" for allowed operations, \"Failure\" for denied |\n| `result.message` | string | Human-readable explanation for denial |\n| `result.reason` | string | Machine-readable reason code |\n| `result.code` | int32 | HTTP status code (400 for validation errors, 403 for policy violations) |\n\nThe validation logic should be **idempotent** and **stateless** - the same resource should always produce the same validation result regardless of when the webhook is called. This is critical because Kubernetes may call the webhook multiple times for the same resource during retries or internal processing.\n\n**Database Validation Rules Implementation:**\n\nConsider implementing these validation rules for the `Database` custom resource:\n\n1. **Version Compatibility Validation**: Ensure the requested database version is supported and that version downgrades follow safe migration paths\n2. **Resource Constraint Validation**: Verify that CPU and memory requests are within organizational limits and that storage size is appropriate for the database version\n3. **Backup Schedule Validation**: Validate cron expressions in `BackupSchedule` and ensure backup frequency meets compliance requirements\n4. **Configuration Validation**: Check that database configuration parameters in the `Config` map are valid for the specified version\n5. **Update Path Validation**: For UPDATE operations, ensure changes don't violate constraints (e.g., storage size cannot be decreased, replica count changes follow safe scaling patterns)\n\n> **Decision: Client-Side vs Server-Side Validation Balance**\n> - **Context**: Validation can occur in multiple places - CRD schema, admission webhooks, and reconciliation logic\n> - **Options Considered**: All validation in webhooks, all validation in reconciliation, layered validation with different concerns at each level\n> - **Decision**: Layered validation with schema for structure, webhooks for business rules, reconciliation for runtime constraints\n> - **Rationale**: Schema validation provides immediate feedback with minimal latency, webhooks handle complex business logic synchronously, reconciliation handles constraints that depend on cluster state\n> - **Consequences**: Multiple validation layers require careful coordination, but provides optimal user experience and strong consistency guarantees\n\n**Common Validation Patterns:**\n\n| Validation Type | Implementation Approach | Example |\n|----------------|------------------------|---------|\n| Cross-field validation | Compare multiple fields in same resource | Validate that memory limits are greater than memory requests |\n| Enumeration validation | Check field values against allowed lists | Ensure database version is in supported versions list |\n| External dependency validation | Query external systems or APIs | Verify that specified storage class exists and is available |\n| Policy compliance validation | Apply organizational rules and constraints | Check that resource requests don't exceed namespace quotas |\n| Change safety validation | Compare old and new resources for updates | Prevent scaling down below minimum replica count |\n\n⚠️ **Pitfall: Webhook Validation Loops**\n\nA common mistake is implementing validation logic that can change its decision based on external factors like current time or cluster state. For example, validating that \"backups can only be scheduled during maintenance windows\" might reject the same resource at different times of day. This creates confusing user experiences where `kubectl apply` succeeds at one time but fails at another for the same YAML.\n\nInstead, validate the structural correctness of the schedule but let the controller's reconciliation logic handle timing-based decisions. The webhook should ensure the cron expression is valid, but the controller should skip backups that fall outside maintenance windows.\n\n**Error Response Best Practices:**\n\nWhen rejecting a resource, provide actionable error messages that help users fix the problem:\n\n```\n❌ Bad: \"Invalid configuration\"\n✅ Good: \"spec.config.max_connections: value 10000 exceeds maximum allowed value of 1000 for database version 14.x\"\n\n❌ Bad: \"Update not allowed\"  \n✅ Good: \"spec.replicas: cannot decrease replica count from 5 to 2 in a single operation. Scale down gradually by reducing count by at most 1 replica per operation.\"\n```\n\n### Mutating Webhook Implementation\n\nMutating admission webhooks modify incoming resources by injecting default values, adding required metadata, and transforming fields to ensure consistency across the cluster. These webhooks run before validating webhooks in the admission chain, allowing them to normalize resources before validation occurs.\n\nThe mutation process uses **JSON Patch** operations to describe changes to the incoming resource. Rather than returning a modified copy of the entire resource, the webhook returns a list of patch operations that the API server applies to the original request. This approach is more efficient and provides better conflict resolution when multiple mutating webhooks modify the same resource.\n\n**JSON Patch Operations:**\n\n| Operation | Purpose | Example |\n|-----------|---------|---------|\n| `add` | Insert new field or array element | Add default storage size |\n| `replace` | Change value of existing field | Normalize version string format |\n| `remove` | Delete field or array element | Remove deprecated fields |\n| `move` | Relocate field within document | Reorganize configuration structure |\n| `copy` | Duplicate field value to another location | Copy name to display name |\n| `test` | Verify field has expected value | Ensure field hasn't changed since mutation started |\n\n**Default Value Injection Strategy:**\n\nThe `Default` method should implement smart defaulting that considers the environment and context:\n\n1. **Environment-Aware Defaults**: Set different default resource requests for development vs production namespaces\n2. **Version-Appropriate Defaults**: Apply defaults that are appropriate for the specified database version\n3. **Organizational Policy Defaults**: Inject standard labels, annotations, and configuration that align with organizational policies\n4. **Resource-Dependent Defaults**: Set memory requests based on storage size, adjust replica counts based on resource tier\n\n**Database Default Values Implementation:**\n\n| Field | Default Logic | Rationale |\n|-------|---------------|-----------|\n| `spec.replicas` | 1 for development namespaces, 3 for production | Ensures high availability in production while keeping development lightweight |\n| `spec.version` | Latest stable version from supported versions list | Provides security updates while avoiding bleeding-edge releases |\n| `spec.storageSize` | \"20Gi\" for single replica, \"100Gi\" for multi-replica | Scales storage allocation with expected load |\n| `spec.backupSchedule` | \"0 2 * * *\" (daily at 2 AM) if not specified | Ensures data protection without manual configuration |\n| `spec.resources.requests.memory` | Calculated as storageSize / 10 | Provides reasonable memory allocation based on database size |\n| `spec.resources.requests.cpu` | \"500m\" for development, \"2\" for production | Balances performance with resource efficiency |\n\nThe mutation logic should be **deterministic** - given the same input resource and cluster state, it should always produce the same mutations. This ensures that repeated applications of the same YAML file don't cause unnecessary updates.\n\n> **Decision: Default Value Source Hierarchy**\n> - **Context**: Default values can come from multiple sources: CRD schema defaults, mutating webhooks, controller logic, or external configuration\n> - **Options Considered**: CRD schema defaults only, webhook-based defaulting, external configuration service, hybrid approach\n> - **Decision**: Hybrid approach with CRD schema for simple defaults, webhook for context-aware defaults\n> - **Rationale**: CRD schema defaults work well for static values but cannot consider namespace, user context, or organizational policies. Webhooks can implement sophisticated defaulting logic.\n> - **Consequences**: More complex implementation but enables smart defaults that improve user experience and enforce organizational standards\n\n**Mutation Ordering Considerations:**\n\nWhen multiple mutating webhooks are registered for the same resource type, Kubernetes calls them in alphabetical order by webhook name. This ordering is critical because later webhooks see the mutations applied by earlier webhooks. Design your webhook names carefully to ensure proper ordering:\n\n- `000-baseline-defaults`: Sets fundamental default values\n- `500-policy-injection`: Adds organizational policy requirements  \n- `900-finalization`: Performs final transformations and cleanup\n\n**Field Transformation Patterns:**\n\n| Transformation Type | Use Case | Implementation |\n|-------------------|----------|----------------|\n| Normalization | Convert user input to canonical format | Transform \"postgres:14\" to \"postgresql-14.6\" |\n| Policy Injection | Add required organizational metadata | Inject cost center labels, security scanning annotations |\n| Resource Calculation | Derive resource requirements from high-level specs | Calculate memory requests from connection pool size |\n| Configuration Generation | Generate complex config from simple parameters | Build database configuration map from performance tier |\n| Cross-Resource References | Establish relationships between resources | Set owner references, add finalizers |\n\n⚠️ **Pitfall: Mutation Conflicts and Overwrites**\n\nWhen implementing mutating webhooks, be careful not to overwrite values that users explicitly set. A common mistake is unconditionally setting default values without checking if the field is already populated:\n\n```\n❌ Bad: Always set spec.replicas = 3 for production\n✅ Good: Set spec.replicas = 3 only if spec.replicas is nil and namespace has production label\n```\n\nThis ensures that users can override defaults when needed while still getting sensible default behavior for most cases.\n\n### TLS Certificate Management\n\nAdmission webhooks require HTTPS communication between the Kubernetes API server and the webhook endpoint. This requirement exists because webhooks handle sensitive resource data and admission decisions that affect cluster security. The API server validates webhook certificates against a trusted CA certificate, making certificate management a critical operational concern.\n\nThe webhook server must present a valid TLS certificate that matches its service name and is signed by a Certificate Authority that the API server trusts. Kubernetes provides several approaches for managing these certificates, each with different complexity and automation characteristics.\n\n**Certificate Management Approaches:**\n\n| Approach | Pros | Cons | Best For |\n|----------|------|------|----------|\n| cert-manager | Automatic renewal, industry standard, handles CA distribution | Additional dependency, requires cert-manager installation | Production deployments |\n| Self-signed certificates | No external dependencies, simple for development | Manual renewal, complex CA distribution, security concerns | Development and testing |\n| External CA integration | Integrates with organizational PKI, auditable | Complex setup, requires external CA access | Enterprise environments |\n| Kubernetes CSR API | Built into Kubernetes, no external dependencies | Manual approval workflow, limited automation | Controlled environments |\n\n> **Decision: Certificate Management Strategy**\n> - **Context**: Webhook TLS certificates need provisioning, renewal, and distribution to API server configuration\n> - **Options Considered**: Manual certificate management, cert-manager automation, Kubernetes CSR API, external CA integration\n> - **Decision**: cert-manager for production, self-signed for development\n> - **Rationale**: cert-manager provides robust automation with industry-standard ACME protocol support, while self-signed certificates reduce dependencies during development\n> - **Consequences**: Production deployments require cert-manager installation, but operational overhead is minimal once configured\n\n**cert-manager Integration:**\n\ncert-manager automates the certificate lifecycle by creating `Certificate` resources that define the desired certificate properties. The cert-manager controller provisions certificates from various issuers (Let's Encrypt, HashiCorp Vault, self-signed CA) and automatically renews them before expiration.\n\n**Certificate Resource Configuration:**\n\n| Field | Value | Purpose |\n|-------|--------|---------|\n| `spec.secretName` | `database-webhook-certs` | Secret where certificate and key are stored |\n| `spec.issuerRef.name` | `selfsigned-issuer` | Certificate issuer (CA) to use for signing |\n| `spec.issuerRef.kind` | `ClusterIssuer` | Cluster-wide or namespace-scoped issuer |\n| `spec.dnsNames` | `[database-webhook.system.svc, database-webhook.system.svc.cluster.local]` | DNS names that certificate should be valid for |\n| `spec.duration` | `8760h` (1 year) | Certificate validity period |\n| `spec.renewBefore` | `720h` (30 days) | How long before expiry to renew |\n\n**Webhook Configuration TLS Setup:**\n\nThe `ValidatingAdmissionWebhook` and `MutatingAdmissionWebhook` configurations must reference the CA certificate that signed the webhook's TLS certificate. cert-manager can automatically inject this CA bundle using the `cert-manager.io/inject-ca-from` annotation:\n\n```yaml\nmetadata:\n  annotations:\n    cert-manager.io/inject-ca-from: system/selfsigned-issuer\n```\n\nThis annotation instructs cert-manager to populate the `caBundle` field in the webhook configuration with the appropriate CA certificate, ensuring the API server can validate the webhook's TLS certificate.\n\n**Certificate Rotation and High Availability:**\n\nCertificate rotation happens automatically when cert-manager renews certificates. The controller updates the secret containing the certificate and private key, and the webhook server must reload these certificates without downtime. Implement certificate reloading by:\n\n1. **Watching the certificate secret** for changes using a Kubernetes informer\n2. **Gracefully reloading** the TLS configuration without dropping existing connections  \n3. **Health checking** the new certificate before switching to ensure validity\n4. **Logging certificate events** for operational visibility and debugging\n\nFor high availability deployments with multiple webhook replicas, ensure that certificate updates propagate to all instances consistently. Use a shared secret for certificate storage and implement proper leader election if coordination is needed during certificate transitions.\n\n**Development Certificate Setup:**\n\nFor development environments, self-signed certificates provide a simpler alternative that avoids external dependencies:\n\n1. **Generate a CA key and certificate** for signing webhook certificates\n2. **Create a webhook certificate** signed by the development CA with appropriate DNS names\n3. **Store certificates in Kubernetes secrets** using the same naming conventions as production\n4. **Configure webhook registration** with the CA bundle for validation\n\n⚠️ **Pitfall: Certificate DNS Name Mismatches**\n\nA common certificate error occurs when the webhook certificate doesn't include all the DNS names that the API server might use to connect to the webhook service. The certificate must include:\n\n- `service-name.namespace.svc` (standard service DNS name)\n- `service-name.namespace.svc.cluster.local` (fully qualified service DNS name)  \n- Any additional DNS names if using custom networking or ingress\n\nMissing DNS names in the certificate cause connection failures with TLS verification errors that can be difficult to diagnose.\n\n**Certificate Monitoring and Observability:**\n\nImplement monitoring for certificate health to prevent webhook failures due to certificate expiration:\n\n| Metric | Purpose | Alert Threshold |\n|--------|---------|----------------|\n| Certificate expiry time | Track time until certificate expiration | Alert 7 days before expiry |\n| Certificate renewal success | Monitor automatic renewal operations | Alert on renewal failures |\n| Webhook TLS handshake errors | Track TLS connection failures | Alert on increased error rate |\n| cert-manager controller health | Ensure cert-manager is running properly | Alert on controller downtime |\n\nCertificate-related webhook failures often manifest as cryptic TLS errors in API server logs. Establish clear runbooks for certificate troubleshooting that cover common scenarios like expired certificates, CA bundle mismatches, and renewal failures.\n\n![Resource Creation and Validation Sequence](./diagrams/resource-creation-sequence.svg)\n\n![Admission Webhook Request Flow](./diagrams/webhook-request-flow.svg)\n\n### Implementation Guidance\n\nBuilding admission webhooks requires careful attention to HTTP server implementation, JSON processing, and certificate management. This section provides complete infrastructure code and implementation skeletons that handle the operational complexities while leaving the core validation and mutation logic for you to implement.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| HTTP Server | net/http with standard library | controller-runtime webhook server |\n| JSON Processing | encoding/json for AdmissionReview | controller-runtime admission package |\n| Certificate Management | Self-signed certificates with openssl | cert-manager with Certificate resources |\n| TLS Configuration | tls.LoadX509KeyPair for static certificates | Dynamic certificate reloading with fsnotify |\n| Testing Framework | httptest for webhook endpoint testing | envtest with real admission controller |\n\n**Recommended File Structure:**\n\n```\ninternal/webhooks/\n  admission.go              ← AdmissionReview request/response handling\n  database_defaulter.go     ← Mutating webhook implementation\n  database_validator.go     ← Validating webhook implementation\n  webhook_server.go         ← HTTP server and certificate management\n  admission_test.go         ← Unit tests for webhook logic\nconfig/webhook/\n  manifests.yaml           ← Webhook registration YAML\n  certificate.yaml         ← cert-manager Certificate resource\ndeploy/certificates/\n  ca.crt                   ← Development CA certificate\n  tls.crt                  ← Development webhook certificate  \n  tls.key                  ← Development webhook private key\n```\n\n**Complete Admission Infrastructure (admission.go):**\n\n```go\npackage webhooks\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n    \n    admissionv1 \"k8s.io/api/admission/v1\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/apimachinery/pkg/runtime\"\n    \"k8s.io/apimachinery/pkg/runtime/serializer\"\n    utilruntime \"k8s.io/apimachinery/pkg/util/runtime\"\n    ctrl \"sigs.k8s.io/controller-runtime\"\n    \"sigs.k8s.io/controller-runtime/pkg/log\"\n    \"sigs.k8s.io/controller-runtime/pkg/webhook/admission\"\n)\n\nvar (\n    scheme = runtime.NewScheme()\n    codecs = serializer.NewCodecFactory(scheme)\n)\n\nfunc init() {\n    utilruntime.Must(admissionv1.AddToScheme(scheme))\n}\n\n// AdmissionHandler wraps validation and mutation logic in HTTP handler\ntype AdmissionHandler struct {\n    decoder *admission.Decoder\n}\n\n// NewAdmissionHandler creates an admission handler with proper decoding setup\nfunc NewAdmissionHandler() *AdmissionHandler {\n    return &AdmissionHandler{\n        decoder: admission.NewDecoder(scheme),\n    }\n}\n\n// ServeHTTP handles incoming admission review requests\nfunc (h *AdmissionHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    logger := log.FromContext(r.Context())\n    \n    // Parse AdmissionReview from request body\n    body := make([]byte, r.ContentLength)\n    if _, err := r.Body.Read(body); err != nil {\n        logger.Error(err, \"Failed to read request body\")\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    \n    var admissionReview admissionv1.AdmissionReview\n    if err := json.Unmarshal(body, &admissionReview); err != nil {\n        logger.Error(err, \"Failed to unmarshal AdmissionReview\")\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    \n    // Process the admission request\n    response := h.processAdmissionReview(r.Context(), &admissionReview)\n    \n    // Send AdmissionReview response\n    responseBytes, err := json.Marshal(response)\n    if err != nil {\n        logger.Error(err, \"Failed to marshal AdmissionResponse\")\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    \n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.Write(responseBytes)\n}\n\nfunc (h *AdmissionHandler) processAdmissionReview(ctx context.Context, \n    review *admissionv1.AdmissionReview) *admissionv1.AdmissionReview {\n    \n    req := review.Request\n    response := &admissionv1.AdmissionResponse{\n        UID: req.UID,\n        Allowed: true,\n    }\n    \n    // Route to appropriate handler based on operation and resource\n    switch {\n    case req.Kind.Kind == \"Database\" && req.Operation == admissionv1.Create:\n        response = h.handleDatabaseCreate(ctx, req)\n    case req.Kind.Kind == \"Database\" && req.Operation == admissionv1.Update:\n        response = h.handleDatabaseUpdate(ctx, req)\n    case req.Kind.Kind == \"Database\" && req.Operation == admissionv1.Delete:\n        response = h.handleDatabaseDelete(ctx, req)\n    default:\n        // Allow operations on unknown resources\n        response.Allowed = true\n    }\n    \n    return &admissionv1.AdmissionReview{\n        TypeMeta: metav1.TypeMeta{\n            APIVersion: \"admission.k8s.io/v1\",\n            Kind:       \"AdmissionReview\",\n        },\n        Response: response,\n    }\n}\n```\n\n**Core Validation Logic Skeleton (database_validator.go):**\n\n```go\npackage webhooks\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"strconv\"\n    \"strings\"\n    \n    admissionv1 \"k8s.io/api/admission/v1\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \n    databasev1 \"github.com/example/database-operator/api/v1\"\n)\n\n// handleDatabaseCreate validates new Database resources\nfunc (h *AdmissionHandler) handleDatabaseCreate(ctx context.Context, \n    req *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse {\n    \n    var database databasev1.Database\n    if err := json.Unmarshal(req.Object.Raw, &database); err != nil {\n        return &admissionv1.AdmissionResponse{\n            UID: req.UID,\n            Allowed: false,\n            Result: &metav1.Status{\n                Message: fmt.Sprintf(\"Failed to decode Database: %v\", err),\n            },\n        }\n    }\n    \n    // TODO 1: Validate spec.version is in supported versions list\n    // Hint: Define supportedVersions = []string{\"14.6\", \"15.1\", \"15.2\"}\n    \n    // TODO 2: Validate spec.storageSize format and minimum size\n    // Hint: Use resource.ParseQuantity() and compare against minimum (1Gi)\n    \n    // TODO 3: Validate spec.replicas is within allowed range (1-10)\n    // Hint: Check database.Spec.Replicas >= 1 && database.Spec.Replicas <= 10\n    \n    // TODO 4: Validate spec.backupSchedule cron expression if provided\n    // Hint: Use \"github.com/robfig/cron/v3\" parser.Parse()\n    \n    // TODO 5: Validate spec.config map contains only allowed keys\n    // Hint: Define allowedConfigKeys and check all keys in database.Spec.Config\n    \n    return &admissionv1.AdmissionResponse{\n        UID: req.UID,\n        Allowed: true,\n    }\n}\n\n// handleDatabaseUpdate validates changes to existing Database resources\nfunc (h *AdmissionHandler) handleDatabaseUpdate(ctx context.Context,\n    req *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse {\n    \n    var oldDatabase, newDatabase databasev1.Database\n    if err := json.Unmarshal(req.OldObject.Raw, &oldDatabase); err != nil {\n        return &admissionv1.AdmissionResponse{\n            UID: req.UID,\n            Allowed: false,\n            Result: &metav1.Status{\n                Message: fmt.Sprintf(\"Failed to decode old Database: %v\", err),\n            },\n        }\n    }\n    \n    if err := json.Unmarshal(req.Object.Raw, &newDatabase); err != nil {\n        return &admissionv1.AdmissionResponse{\n            UID: req.UID,\n            Allowed: false,\n            Result: &metav1.Status{\n                Message: fmt.Sprintf(\"Failed to decode new Database: %v\", err),\n            },\n        }\n    }\n    \n    // TODO 1: Validate storage size is not decreased\n    // Hint: Parse both sizes and compare: newSize >= oldSize\n    \n    // TODO 2: Validate version changes are upgrade-only (no downgrades)\n    // Hint: Compare version numbers, reject if newVersion < oldVersion\n    \n    // TODO 3: Validate replica scaling follows safe patterns\n    // Hint: Allow scaling up freely, but limit scaling down to max 1 replica per operation\n    \n    // TODO 4: Validate immutable fields haven't changed\n    // Hint: Check that critical fields like database name/type remain unchanged\n    \n    return &admissionv1.AdmissionResponse{\n        UID: req.UID,\n        Allowed: true,\n    }\n}\n\n// handleDatabaseDelete validates Database deletion requests\nfunc (h *AdmissionHandler) handleDatabaseDelete(ctx context.Context,\n    req *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse {\n    \n    // TODO 1: Check if database has dependent resources that need cleanup\n    // Hint: Look for finalizers that indicate cleanup is required\n    \n    // TODO 2: Validate deletion is allowed based on database state\n    // Hint: Prevent deletion if database is in \"backup-in-progress\" state\n    \n    // TODO 3: Check for protection annotations that prevent deletion\n    // Hint: Look for \"database.example.com/protect: true\" annotation\n    \n    return &admissionv1.AdmissionResponse{\n        UID: req.UID,\n        Allowed: true,\n    }\n}\n```\n\n**Core Mutation Logic Skeleton (database_defaulter.go):**\n\n```go\npackage webhooks\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \n    admissionv1 \"k8s.io/api/admission/v1\"\n    corev1 \"k8s.io/api/core/v1\"\n    \"k8s.io/apimachinery/pkg/api/resource\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \n    databasev1 \"github.com/example/database-operator/api/v1\"\n)\n\n// handleDatabaseDefaulting applies default values to new Database resources\nfunc (h *AdmissionHandler) handleDatabaseDefaulting(ctx context.Context,\n    req *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse {\n    \n    var database databasev1.Database\n    if err := json.Unmarshal(req.Object.Raw, &database); err != nil {\n        return &admissionv1.AdmissionResponse{\n            UID: req.UID,\n            Allowed: false,\n            Result: &metav1.Status{\n                Message: fmt.Sprintf(\"Failed to decode Database: %v\", err),\n            },\n        }\n    }\n    \n    var patches []JSONPatch\n    \n    // TODO 1: Set default replicas based on namespace environment\n    // Hint: Check namespace labels for \"environment=production\" → 3 replicas, else 1\n    \n    // TODO 2: Set default version to latest stable if not specified\n    // Hint: if database.Spec.Version == \"\" { patches = append(...) }\n    \n    // TODO 3: Set default storage size based on replica count\n    // Hint: Single replica → 20Gi, Multiple replicas → 100Gi\n    \n    // TODO 4: Generate default backup schedule if not provided\n    // Hint: Use \"0 2 * * *\" for daily backups at 2 AM\n    \n    // TODO 5: Calculate default resource requests based on storage size\n    // Hint: Memory = StorageSize / 10, CPU = \"500m\" for dev, \"2\" for prod\n    \n    // TODO 6: Inject organizational labels and annotations\n    // Hint: Add cost-center, team, and monitoring labels\n    \n    if len(patches) == 0 {\n        return &admissionv1.AdmissionResponse{\n            UID: req.UID,\n            Allowed: true,\n        }\n    }\n    \n    patchBytes, err := json.Marshal(patches)\n    if err != nil {\n        return &admissionv1.AdmissionResponse{\n            UID: req.UID,\n            Allowed: false,\n            Result: &metav1.Status{\n                Message: fmt.Sprintf(\"Failed to marshal patches: %v\", err),\n            },\n        }\n    }\n    \n    patchType := admissionv1.PatchTypeJSONPatch\n    return &admissionv1.AdmissionResponse{\n        UID: req.UID,\n        Allowed: true,\n        Patch: patchBytes,\n        PatchType: &patchType,\n    }\n}\n\n// JSONPatch represents a JSON patch operation\ntype JSONPatch struct {\n    Op    string      `json:\"op\"`\n    Path  string      `json:\"path\"`\n    Value interface{} `json:\"value,omitempty\"`\n}\n\n// Helper function to create an \"add\" patch operation\nfunc createAddPatch(path string, value interface{}) JSONPatch {\n    return JSONPatch{\n        Op:    \"add\",\n        Path:  path,\n        Value: value,\n    }\n}\n\n// Helper function to create a \"replace\" patch operation  \nfunc createReplacePatch(path string, value interface{}) JSONPatch {\n    return JSONPatch{\n        Op:    \"replace\", \n        Path:  path,\n        Value: value,\n    }\n}\n```\n\n**Complete Webhook Server Setup (webhook_server.go):**\n\n```go\npackage webhooks\n\nimport (\n    \"context\"\n    \"crypto/tls\"\n    \"fmt\"\n    \"net/http\"\n    \"path/filepath\"\n    \"time\"\n    \n    \"k8s.io/apimachinery/pkg/util/wait\"\n    ctrl \"sigs.k8s.io/controller-runtime\"\n    \"sigs.k8s.io/controller-runtime/pkg/healthz\"\n    \"sigs.k8s.io/controller-runtime/pkg/log\"\n    \"sigs.k8s.io/controller-runtime/pkg/manager\"\n    \"sigs.k8s.io/controller-runtime/pkg/webhook\"\n)\n\nconst (\n    WebhookPort = 9443\n    CertDir     = \"/tmp/k8s-webhook-server/serving-certs\"\n    CertName    = \"tls.crt\"\n    KeyName     = \"tls.key\"\n)\n\n// SetupWebhookServer configures the webhook server with TLS and health checks\nfunc SetupWebhookServer(mgr ctrl.Manager) error {\n    hookServer := mgr.GetWebhookServer()\n    \n    // Configure TLS certificate paths\n    hookServer.Port = WebhookPort\n    hookServer.CertDir = CertDir\n    hookServer.CertName = CertName\n    hookServer.KeyName = KeyName\n    \n    // Register admission handlers\n    admissionHandler := NewAdmissionHandler()\n    hookServer.Register(\"/mutate\", &webhook.Admission{Handler: admissionHandler})\n    hookServer.Register(\"/validate\", &webhook.Admission{Handler: admissionHandler})\n    \n    // Add health check endpoints\n    if err := mgr.AddHealthzCheck(\"webhook\", healthz.Ping); err != nil {\n        return fmt.Errorf(\"failed to add health check: %w\", err)\n    }\n    \n    if err := mgr.AddReadyzCheck(\"webhook\", healthz.Ping); err != nil {\n        return fmt.Errorf(\"failed to add ready check: %w\", err)\n    }\n    \n    return nil\n}\n\n// CertificateReloader handles dynamic certificate reloading\ntype CertificateReloader struct {\n    certPath string\n    keyPath  string\n    cert     *tls.Certificate\n}\n\n// NewCertificateReloader creates a certificate reloader for the given paths\nfunc NewCertificateReloader(certPath, keyPath string) (*CertificateReloader, error) {\n    reloader := &CertificateReloader{\n        certPath: certPath,\n        keyPath:  keyPath,\n    }\n    \n    if err := reloader.loadCertificate(); err != nil {\n        return nil, fmt.Errorf(\"failed to load initial certificate: %w\", err)\n    }\n    \n    return reloader, nil\n}\n\nfunc (r *CertificateReloader) loadCertificate() error {\n    cert, err := tls.LoadX509KeyPair(r.certPath, r.keyPath)\n    if err != nil {\n        return err\n    }\n    r.cert = &cert\n    return nil\n}\n\n// GetCertificate returns the current certificate (implements tls.Config.GetCertificate)\nfunc (r *CertificateReloader) GetCertificate(*tls.ClientHelloInfo) (*tls.Certificate, error) {\n    return r.cert, nil\n}\n\n// Start begins watching for certificate changes and reloading automatically\nfunc (r *CertificateReloader) Start(ctx context.Context) error {\n    logger := log.FromContext(ctx)\n    \n    return wait.PollImmediateUntil(30*time.Second, func() (bool, error) {\n        if err := r.loadCertificate(); err != nil {\n            logger.Error(err, \"Failed to reload certificate\")\n            return false, nil // Continue polling\n        }\n        logger.Info(\"Certificate reloaded successfully\")\n        return false, nil // Continue polling\n    }, ctx.Done())\n}\n```\n\n**Language-Specific Implementation Hints:**\n\n- **JSON Patch Operations**: Use the `JSONPatch` struct to build mutation operations. The `path` field uses JSON Pointer syntax (e.g., `/spec/replicas`, `/metadata/labels/environment`)\n- **AdmissionReview Handling**: Always copy the request UID to the response UID - this is required for proper request tracking\n- **Error Response Formatting**: Use `metav1.Status` for structured error responses with appropriate HTTP status codes (400 for validation errors, 500 for internal errors)\n- **TLS Certificate Loading**: Use `tls.LoadX509KeyPair()` for loading certificates and implement `GetCertificate` callback for dynamic reloading\n- **Resource Quantity Parsing**: Use `resource.ParseQuantity()` for validating storage sizes and resource limits\n\n**Milestone Checkpoint:**\n\nAfter implementing the webhook logic, verify the following behavior:\n\n1. **Webhook Registration**: `kubectl get validatingadmissionwebhooks` and `kubectl get mutatingadmissionwebhooks` show your webhooks\n2. **Certificate Validation**: Check that webhook pod logs show successful TLS certificate loading\n3. **Mutation Behavior**: Create a `Database` resource with minimal spec and verify defaults are applied\n4. **Validation Behavior**: Try creating invalid `Database` resources and verify they are rejected with clear error messages\n5. **Update Validation**: Try invalid updates (like decreasing storage size) and verify they are properly blocked\n\n**Common Debugging Scenarios:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| \"connection refused\" errors | Webhook server not running or wrong port | Check pod logs and service endpoints | Verify webhook server is listening on correct port |\n| \"certificate verification failed\" | CA bundle mismatch or expired certificate | Check webhook configuration caBundle vs actual cert | Update caBundle or renew certificate |\n| \"webhook timeout\" errors | Webhook processing too slow or hanging | Check webhook response time and goroutine leaks | Optimize validation logic, add timeouts |\n| \"admission webhook denied\" without clear reason | Poor error message formatting | Check AdmissionResponse.Result.Message field | Improve error message content and structure |\n| Mutations not being applied | Webhook called but patches malformed | Check JSON patch syntax and field paths | Validate patch operations against JSON Pointer spec |\n\n\n## Component Interactions and Data Flow\n\n> **Milestone(s):** Milestone 3 (Reconciliation Loop), Milestone 4 (Webhooks), Milestone 5 (Testing & Deployment) - demonstrates the orchestrated behavior between controller, webhooks, and API server during complete resource lifecycle operations\n\nThe interaction between the operator's components creates a sophisticated orchestration that maintains system consistency while handling the complexities of distributed operations. Understanding these interaction patterns is crucial for building operators that behave predictably under both normal conditions and failure scenarios.\n\n### Mental Model: The Orchestra Conductor\n\nThink of the Kubernetes API server as an orchestra conductor coordinating multiple musicians (the controller and webhooks). When someone in the audience (a user) requests a song (creates a resource), the conductor first asks the first violin section (mutating webhooks) to tune their instruments (apply defaults), then asks the brass section (validating webhooks) to confirm they can play the piece (validate the request). Only after everyone agrees does the conductor store the sheet music (persist the resource) and signal the orchestra to begin playing (trigger controller reconciliation). Throughout the performance, musicians continuously watch the conductor for tempo changes (status updates) and adjust their playing accordingly.\n\nThis mental model helps explain why webhook failures can block resource creation (the brass section refusing to play stops the entire orchestra) and why controller reconciliation happens asynchronously (the orchestra continues playing even if some audience members leave).\n\n![Resource Reconciliation State Machine](./diagrams/reconciliation-state-machine.svg)\n\n![Resource Creation and Validation Sequence](./diagrams/resource-creation-sequence.svg)\n\n### Resource Creation Flow\n\nThe resource creation flow represents the most complex interaction pattern in the operator ecosystem, involving multiple validation and processing stages that must complete successfully before the controller begins reconciliation. This flow demonstrates how Kubernetes' admission control system provides strong consistency guarantees while allowing operators to extend the platform's behavior.\n\n#### Pre-Storage Validation Pipeline\n\nWhen a user submits a `Database` resource through `kubectl apply`, the API server initiates a multi-stage validation pipeline before the resource reaches persistent storage. This pipeline ensures that only valid, properly configured resources enter the cluster state, preventing downstream controller errors and maintaining system integrity.\n\nThe API server first performs schema validation against the CRD's OpenAPI v3 specification, rejecting resources that violate basic type constraints or required field rules. This validation catches structural errors like missing required fields, incorrect field types, or values that exceed defined string length limits. Schema validation provides the first line of defense against malformed resources, ensuring that subsequent processing stages can assume basic structural correctness.\n\n| Validation Stage | Purpose | Failure Impact | Recovery Action |\n|-----------------|---------|----------------|-----------------|\n| Schema Validation | Type safety and required fields | Immediate rejection with schema error | Fix resource definition and reapply |\n| Mutating Webhook | Default value injection | Webhook timeout or denial | Check webhook pod logs and certificate |\n| Validating Webhook | Business rule enforcement | Resource creation blocked | Address validation error and resubmit |\n| Storage Layer | Optimistic concurrency control | Conflict on resource version | Retry with fresh resource version |\n\nAfter schema validation succeeds, the API server invokes any configured mutating webhooks in the order specified by their admission registration. The mutating webhook receives an `AdmissionReview` containing the proposed resource and can modify field values before storage occurs. Common mutations include injecting default values for optional fields, adding labels or annotations for operational tracking, or transforming user-friendly field values into internal representations.\n\n> **Design Insight: Mutation Order Matters**\n>\n> Multiple mutating webhooks execute in a defined sequence, with each webhook receiving the potentially modified resource from previous webhooks. This creates a pipeline where early webhooks can set defaults that later webhooks can validate or further modify. Operators must consider this ordering when designing webhook logic to avoid conflicts or unexpected interactions between different mutation policies.\n\n#### Mutating Webhook Processing\n\nThe mutating webhook implementation receives admission review requests containing the raw resource JSON along with metadata about the operation context. The webhook deserializes this JSON into the `Database` struct, applies default values for any unspecified optional fields, and returns a JSON patch describing the required modifications.\n\n```\nMutating Webhook Request Processing:\n1. API server serializes Database resource to JSON\n2. API server constructs AdmissionReview with resource JSON and operation metadata  \n3. API server sends HTTPS POST to webhook endpoint with AdmissionReview\n4. Webhook deserializes AdmissionReview and extracts Database resource\n5. Webhook applies defaulting logic to populate missing optional fields\n6. Webhook generates JSON patch operations for modified fields\n7. Webhook returns AdmissionResponse with patch and admission decision\n8. API server applies patch to original resource JSON\n9. Modified resource proceeds to validating webhook stage\n```\n\nThe JSON patch format provides precise control over field modifications, supporting operations like adding missing fields, replacing existing values, or removing unwanted elements. This precision ensures that webhooks only modify their intended fields without accidentally affecting other resource properties.\n\n| Default Field | Condition | Applied Value | Justification |\n|--------------|-----------|---------------|---------------|\n| `StorageSize` | If empty or unspecified | \"10Gi\" | Reasonable default for development databases |\n| `Replicas` | If zero or negative | 1 | Single replica provides basic functionality |\n| `Version` | If empty string | \"14.5\" | Current stable PostgreSQL release |\n| `Resources.Limits` | If nil | CPU: \"500m\", Memory: \"512Mi\" | Prevent resource exhaustion |\n| `Config` | If nil | `map[string]string{\"shared_buffers\": \"256MB\"}` | Basic performance tuning |\n\n#### Validating Webhook Processing\n\nAfter successful mutation, the API server invokes validating webhooks to enforce business rules and cross-field validation constraints that cannot be expressed in the OpenAPI schema. Unlike mutating webhooks, validating webhooks cannot modify the resource but can reject the entire operation by returning a denial response.\n\nThe validating webhook performs comprehensive business logic validation, checking constraints like database version compatibility, resource requirement feasibility, and configuration parameter validity. These validations often require external knowledge or complex logic that exceeds the capabilities of declarative schema validation.\n\nCommon validation scenarios include verifying that the requested `StorageSize` is larger than any existing persistent volume claims, ensuring that the specified `Version` is compatible with upgrade paths from currently running versions, and validating that custom configuration parameters in the `Config` map use valid PostgreSQL settings with appropriate values.\n\n> **Decision: Webhook vs Schema Validation Split**\n> - **Context**: Complex validation logic can be implemented in webhooks or expressed in CRD schemas using CEL expressions\n> - **Options Considered**: \n>   1. Implement all validation in admission webhooks with full programming flexibility\n>   2. Use CEL expressions in CRD schema for all validation logic\n>   3. Hybrid approach with schema validation for simple rules and webhooks for complex logic\n> - **Decision**: Hybrid approach with simple validations in schema and complex business rules in webhooks\n> - **Rationale**: Schema validation provides faster feedback and better error messages for simple constraints, while webhooks handle complex logic requiring external state or computations\n> - **Consequences**: Reduces webhook load for simple validation failures while maintaining flexibility for sophisticated business rules\n\n#### Storage and Initial Status\n\nOnce all webhook validations pass, the API server commits the resource to etcd storage and initializes the status subresource with default condition values. The newly stored resource receives a unique `resourceVersion` that enables optimistic concurrency control for subsequent updates.\n\nThe initial status includes a `Progressing` condition set to `True` with a reason of \"ResourceCreated\", indicating that the controller should begin reconciliation processing. The `ObservedGeneration` field initializes to zero, signaling that no controller reconciliation has occurred yet.\n\n| Initial Status Field | Value | Purpose |\n|---------------------|-------|---------|\n| `Conditions` | `[{Type: \"Progressing\", Status: \"True\", Reason: \"ResourceCreated\"}]` | Indicates pending reconciliation |\n| `ReadyReplicas` | 0 | No workloads created yet |\n| `ObservedGeneration` | 0 | No reconciliation completed |\n| `Phase` | \"Pending\" | Resource awaiting controller processing |\n| `Message` | \"Resource created, awaiting reconciliation\" | Human-readable status |\n\n### Update and Reconciliation Flow\n\nThe update and reconciliation flow demonstrates how the operator maintains system consistency when users modify existing resources or when external conditions change the actual cluster state. This flow showcases the declarative nature of Kubernetes operators, where controllers continuously work to align actual state with desired state regardless of what triggered the divergence.\n\n#### Spec Change Detection\n\nWhen users modify a `Database` resource specification, the API server increments the resource's `generation` field and processes the update through the same webhook pipeline used during creation. However, validating webhooks receive both the old and new resource versions, enabling validation logic that considers the implications of specific changes.\n\nThe controller's informer cache detects the specification change through its watch connection to the API server. The shared informer compares the new resource version against its cached copy and triggers an update event that enqueues the resource key for reconciliation processing.\n\n```\nUpdate Detection and Queuing:\n1. User submits resource update via kubectl apply or API call\n2. API server processes update through mutating and validating webhooks  \n3. API server increments generation field and stores modified resource\n4. Controller informer receives watch event with updated resource\n5. Event handler compares new generation against cached generation\n6. If generation changed, handler enqueues resource key in work queue\n7. Controller worker goroutine dequeues key and begins reconciliation\n8. Reconciler fetches fresh resource version from cache\n9. Reconciler compares generation vs observedGeneration to detect changes\n```\n\nThe controller uses generation comparison to distinguish between user-initiated spec changes and controller-initiated status updates. Only when `metadata.generation` exceeds `status.observedGeneration` does the controller recognize that new reconciliation work is required.\n\n#### Incremental Reconciliation Strategy\n\nRather than recreating all owned resources during every reconciliation, the controller implements incremental updates that modify only the specific resources affected by the spec change. This approach minimizes disruption to running workloads and reduces the risk of cascading failures during updates.\n\nThe reconciler fetches the current state of all owned resources and compares their configuration against the desired state derived from the updated spec. For each owned resource, the controller determines whether creation, update, or deletion is required to align with the new desired state.\n\n| Change Type | Affected Resources | Reconciliation Action | Disruption Level |\n|-------------|-------------------|----------------------|------------------|\n| Replica count increase | StatefulSet, Service | Update StatefulSet replicas field | Rolling scale-up |\n| Replica count decrease | StatefulSet, Service | Update StatefulSet replicas field | Rolling scale-down |\n| Storage size increase | PersistentVolumeClaim | Create new PVC, migrate data | High disruption |\n| Version upgrade | StatefulSet, ConfigMap | Update image and configuration | Rolling restart |\n| Configuration change | ConfigMap, StatefulSet | Update ConfigMap, restart pods | Controlled restart |\n| Resource limits change | StatefulSet | Update pod template resources | Rolling restart |\n\n> **Critical Insight: Storage Size Immutability**\n>\n> Kubernetes PersistentVolumeClaims cannot be resized in all storage classes, and decreasing storage size is never supported. The controller must detect storage size changes and implement appropriate strategies like creating new volumes and orchestrating data migration rather than attempting in-place PVC modifications that will fail.\n\n#### Status Update Propagation\n\nAfter completing reconciliation actions, the controller updates the `Database` status subresource to reflect the current state of owned resources and the progress of the reconciliation operation. Status updates use a separate API call to the status subresource, preventing race conditions between controller status updates and user spec modifications.\n\nThe controller aggregates status information from all owned resources, computing values like `ReadyReplicas` from the StatefulSet status and updating condition states based on the overall health of the database deployment. The `ObservedGeneration` field advances to match the current `metadata.generation`, indicating that reconciliation has processed the latest spec changes.\n\n```\nStatus Update Process:\n1. Controller completes reconciliation actions for owned resources\n2. Controller queries current status of all owned resources  \n3. Controller aggregates health information from StatefulSet, Services, PVCs\n4. Controller computes overall readiness state and condition values\n5. Controller constructs updated DatabaseStatus with current state\n6. Controller calls status subresource API to persist status changes\n7. Controller sets ObservedGeneration to current metadata.generation\n8. Controller updates LastTransitionTime for any changed conditions\n9. Updated status becomes visible to users via kubectl get database\n```\n\nThe status update includes human-readable messages that help users understand the current state and any issues that might prevent successful reconciliation. These messages appear in `kubectl describe` output and provide valuable debugging information when troubleshooting deployment problems.\n\n### Deletion and Cleanup Flow\n\nThe deletion and cleanup flow represents the most complex interaction pattern because it must coordinate resource cleanup across multiple Kubernetes objects while respecting dependency relationships and handling potential failures during the cleanup process. This flow demonstrates how finalizers provide deletion safety in distributed systems where cleanup operations may take significant time or encounter transient failures.\n\n#### Finalizer-Protected Deletion\n\nWhen users delete a `Database` resource, Kubernetes does not immediately remove the resource from storage if finalizers are present in the `metadata.finalizers` array. Instead, the API server sets the `metadata.deletionTimestamp` field and waits for controllers to remove their finalizers after completing cleanup operations.\n\nThe `DatabaseReconciler` adds the `FINALIZER_NAME` to newly created resources during their first reconciliation, ensuring that deletion cannot proceed without controller involvement. This finalizer acts as a safety mechanism that prevents orphaned resources when users delete the parent `Database` object.\n\n| Finalizer | Purpose | Cleanup Responsibility | Removal Condition |\n|-----------|---------|----------------------|-------------------|\n| `database.example.com/finalizer` | Owned resource cleanup | Delete StatefulSet, Services, ConfigMaps, PVCs | All owned resources successfully deleted |\n| `database.example.com/backup-finalizer` | Backup completion | Ensure backup job completes or fails | Backup job reaches terminal state |\n| `external-secrets.io/finalizer` | Secret cleanup | Remove database credentials from external systems | External secret deletion confirmed |\n\nThe controller detects deletion requests by checking for the presence of `metadata.deletionTimestamp` during reconciliation. When this timestamp is set, the controller switches from normal reconciliation logic to deletion processing, focusing exclusively on cleanup operations rather than maintaining desired state.\n\n#### Ordered Resource Cleanup\n\nThe cleanup process follows a specific order designed to minimize data loss risk and prevent dependency violations. The controller begins by stopping new connections to the database, then drains existing connections, performs final backups, and finally removes storage resources.\n\n```\nDeletion Processing Order:\n1. Controller detects deletionTimestamp is set on Database resource\n2. Controller updates status phase to \"Terminating\" \n3. Controller initiates graceful shutdown of database pods via StatefulSet\n4. Controller waits for active connections to drain (with timeout)\n5. Controller triggers final backup job if backup schedule configured\n6. Controller waits for backup completion or timeout\n7. Controller deletes Service resources to prevent new connections  \n8. Controller deletes StatefulSet and waits for pod termination\n9. Controller deletes ConfigMaps and Secrets\n10. Controller deletes PersistentVolumeClaims (if policy allows)\n11. Controller removes finalizer from Database resource\n12. Kubernetes completes resource deletion automatically\n```\n\nEach cleanup step includes timeout handling to prevent indefinite blocking on failing operations. The controller maintains detailed status messages throughout the deletion process, helping users understand cleanup progress and identify any issues that require manual intervention.\n\n> **Decision: PVC Deletion Policy**\n> - **Context**: Database PersistentVolumeClaims contain critical data that users might want to preserve after operator deletion\n> - **Options Considered**:\n>   1. Always delete PVCs automatically during cleanup\n>   2. Never delete PVCs, leaving cleanup to administrators\n>   3. Configurable deletion policy per Database instance\n> - **Decision**: Configurable deletion policy with annotation-based control\n> - **Rationale**: Provides flexibility for both development environments (auto-cleanup) and production environments (manual cleanup)\n> - **Consequences**: Requires clear documentation about PVC lifecycle and potential storage costs from orphaned volumes\n\n#### Backup and Data Protection\n\nBefore deleting storage resources, the controller creates a final backup job to preserve database contents. This backup operation runs asynchronously while the controller monitors job status to determine when cleanup can proceed safely.\n\nThe backup job creation follows the same owner reference pattern used for other owned resources, ensuring that backup jobs are cleaned up automatically if the Database deletion process fails and requires restart. The controller includes backup metadata in the Database status, providing users with information about backup location and completion status.\n\n| Backup Stage | Duration Estimate | Failure Handling | User Visibility |\n|--------------|------------------|------------------|----------------|\n| Job Creation | < 1 second | Retry with exponential backoff | Status: \"Creating backup job\" |\n| Backup Execution | Varies by data size | Monitor job status, timeout after 1 hour | Status: \"Backing up data\" |\n| Backup Verification | < 30 seconds | Check backup file existence and size | Status: \"Verifying backup\" |\n| Cleanup Continuation | < 10 seconds | Proceed with resource deletion | Status: \"Backup complete, cleaning up\" |\n\n#### Cleanup Failure Recovery\n\nThe deletion flow includes comprehensive error handling for scenarios where cleanup operations fail due to temporary issues like network connectivity problems, insufficient permissions, or resource conflicts. The controller uses exponential backoff retry logic to handle transient failures while providing escape mechanisms for permanent failure conditions.\n\nWhen cleanup operations encounter errors, the controller updates the Database status with detailed error information and requeues the reconciliation request for retry. The exponential backoff algorithm prevents overwhelming failing systems while ensuring that temporary issues resolve automatically once underlying conditions improve.\n\nCommon cleanup failures include PersistentVolumeClaims that cannot be deleted due to active pod mounts, backup jobs that fail due to storage connectivity issues, and StatefulSets that hang during termination due to pod disruption budgets or resource constraints.\n\n⚠️ **Pitfall: Incomplete Finalizer Removal**\n\nControllers must remove their finalizers only after ALL cleanup operations complete successfully. Removing finalizers prematurely allows Kubernetes to complete resource deletion, potentially orphaning external resources or causing data loss. Always implement comprehensive error checking before finalizer removal, and prefer leaving finalizers in place during uncertain failure conditions rather than risking incomplete cleanup.\n\n#### Graceful Shutdown Coordination\n\nThe StatefulSet deletion process includes graceful shutdown coordination to ensure that database processes have sufficient time to flush pending writes, close connections cleanly, and perform other shutdown procedures. The controller configures appropriate `terminationGracePeriodSeconds` values based on the database type and expected shutdown duration.\n\nDuring StatefulSet deletion, the controller monitors pod termination status and can extend grace periods if shutdown operations require additional time. This monitoring prevents forceful pod termination that could corrupt database files or lose pending transactions.\n\n```\nGraceful Shutdown Monitoring:\n1. Controller initiates StatefulSet deletion with configured grace period\n2. Controller watches for pod termination events from informer\n3. Controller checks database process status via readiness probes  \n4. If shutdown exceeds grace period, controller logs warning\n5. Controller waits for all pods to reach Terminated phase\n6. Controller verifies no orphaned persistent connections remain\n7. Controller proceeds with next cleanup phase\n```\n\nThe graceful shutdown process includes health checks that verify database processes have stopped completely before proceeding to delete storage resources. These checks prevent data corruption scenarios where storage cleanup occurs while database processes are still writing data files.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Webhook Timeout During Resource Creation**\n\nAdmission webhooks have strict timeout limits (typically 10-30 seconds) enforced by the API server. Complex validation logic or external API calls in webhooks can exceed these timeouts, causing resource creation to fail with cryptic timeout errors. Implement webhook logic with fast execution paths and avoid synchronous external dependencies. Use caching for expensive validations and prefer eventual consistency models where immediate validation is not critical.\n\n⚠️ **Pitfall: Status Update Race Conditions**\n\nControllers that update status frequently can encounter race conditions where multiple status updates attempt to modify the same resource version simultaneously. This causes \"conflict\" errors that appear as reconciliation failures. Always fetch fresh resource versions before status updates, implement retry logic for conflict errors, and consider batching multiple status changes into single update operations.\n\n⚠️ **Pitfall: Finalizer Deadlock Scenarios**\n\nMultiple controllers adding finalizers to the same resource can create deadlock situations where each controller waits for others to complete cleanup before removing their own finalizers. Design finalizer cleanup logic to be independent of other finalizers and implement timeout mechanisms that allow emergency finalizer removal during administrative intervention.\n\n⚠️ **Pitfall: Informer Cache Staleness**\n\nControllers making decisions based on informer cache data may operate on stale information that doesn't reflect recent cluster changes. Critical decisions like resource creation or deletion should fetch fresh data from the API server rather than relying solely on cache contents. Use `client.Get()` calls for authoritative state checks before irreversible operations.\n\n⚠️ **Pitfall: Webhook Certificate Expiration**\n\nAdmission webhooks require valid TLS certificates for HTTPS communication with the API server. Certificate expiration causes immediate webhook failures that block all resource operations. Implement automated certificate rotation using cert-manager or similar tools, monitor certificate expiration dates, and establish emergency procedures for manual certificate renewal during outages.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| HTTP Client | `net/http` with retry logic | `controller-runtime/pkg/client` with built-in retries |\n| JSON Processing | `encoding/json` with struct tags | `sigs.k8s.io/controller-runtime/pkg/webhook/admission` decoder |\n| Status Updates | Direct client calls to status subresource | `controller-runtime/pkg/client` with `SubResource()` |\n| Event Recording | `client-go/tools/record` EventRecorder | Controller-runtime manager event recorder |\n| Certificate Management | Manual certificate creation | `cert-manager.io` automatic certificate lifecycle |\n\n#### Recommended File Structure\n\n```\ninternal/controller/\n  database_controller.go          ← Main reconciliation logic\n  database_controller_test.go     ← Reconciliation unit tests\n  status_updater.go               ← Status management utilities\n  finalizer_manager.go            ← Finalizer addition/removal logic\n\ninternal/webhook/\n  database_webhook.go             ← Admission webhook handlers\n  database_webhook_test.go        ← Webhook validation tests\n  certificate_manager.go          ← TLS certificate management\n  admission_handler.go            ← Webhook HTTP server setup\n\ninternal/resources/\n  statefulset.go                  ← StatefulSet creation and updates\n  service.go                      ← Service resource management\n  configmap.go                    ← ConfigMap generation logic\n  pvc.go                          ← PersistentVolumeClaim handling\n\nconfig/webhook/\n  manifests.yaml                  ← ValidatingAdmissionWebhook configuration\n  kustomization.yaml              ← Webhook resource overlay\n  certificate.yaml                ← Certificate resource for cert-manager\n```\n\n#### Infrastructure Starter Code\n\n**Complete HTTP Server for Admission Webhooks:**\n\n```go\npackage webhook\n\nimport (\n    \"context\"\n    \"crypto/tls\"\n    \"fmt\"\n    \"net/http\"\n    \"time\"\n    \n    admissionv1 \"k8s.io/api/admission/v1\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/apimachinery/pkg/runtime\"\n    \"sigs.k8s.io/controller-runtime/pkg/log\"\n    \"sigs.k8s.io/controller-runtime/pkg/webhook/admission\"\n)\n\n// AdmissionHandler processes admission review requests for Database resources\ntype AdmissionHandler struct {\n    decoder *admission.Decoder\n    scheme  *runtime.Scheme\n}\n\nfunc NewAdmissionHandler(decoder *admission.Decoder, scheme *runtime.Scheme) *AdmissionHandler {\n    return &AdmissionHandler{\n        decoder: decoder,\n        scheme:  scheme,\n    }\n}\n\nfunc (h *AdmissionHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    logger := log.FromContext(r.Context())\n    \n    var review admissionv1.AdmissionReview\n    if err := json.NewDecoder(r.Body).Decode(&review); err != nil {\n        logger.Error(err, \"Failed to decode admission review request\")\n        http.Error(w, \"Invalid admission review\", http.StatusBadRequest)\n        return\n    }\n    \n    response := h.processAdmissionReview(r.Context(), &review)\n    review.Response = response\n    review.Response.UID = review.Request.UID\n    \n    w.Header().Set(\"Content-Type\", \"application/json\")\n    if err := json.NewEncoder(w).Encode(review); err != nil {\n        logger.Error(err, \"Failed to encode admission review response\")\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n    }\n}\n\nfunc (h *AdmissionHandler) processAdmissionReview(ctx context.Context, review *admissionv1.AdmissionReview) *admissionv1.AdmissionResponse {\n    req := review.Request\n    \n    switch req.Kind.Kind {\n    case \"Database\":\n        switch req.Operation {\n        case admissionv1.Create:\n            return h.handleDatabaseCreate(ctx, req)\n        case admissionv1.Update:\n            return h.handleDatabaseUpdate(ctx, req)\n        case admissionv1.Delete:\n            return h.handleDatabaseDelete(ctx, req)\n        }\n    }\n    \n    return &admissionv1.AdmissionResponse{\n        Allowed: true,\n        Result: &metav1.Status{\n            Code: http.StatusOK,\n        },\n    }\n}\n```\n\n**Complete TLS Certificate Manager:**\n\n```go\npackage webhook\n\nimport (\n    \"context\"\n    \"crypto/tls\"\n    \"fmt\"\n    \"os\"\n    \"sync\"\n    \"time\"\n)\n\n// CertificateReloader manages TLS certificate lifecycle for webhook servers\ntype CertificateReloader struct {\n    certPath string\n    keyPath  string\n    cert     *tls.Certificate\n    mutex    sync.RWMutex\n}\n\nfunc NewCertificateReloader(certPath, keyPath string) *CertificateReloader {\n    return &CertificateReloader{\n        certPath: certPath,\n        keyPath:  keyPath,\n    }\n}\n\nfunc (cr *CertificateReloader) GetCertificate(*tls.ClientHelloInfo) (*tls.Certificate, error) {\n    cr.mutex.RLock()\n    defer cr.mutex.RUnlock()\n    \n    if cr.cert == nil {\n        return nil, fmt.Errorf(\"certificate not loaded\")\n    }\n    \n    return cr.cert, nil\n}\n\nfunc (cr *CertificateReloader) loadCertificate() error {\n    cert, err := tls.LoadX509KeyPair(cr.certPath, cr.keyPath)\n    if err != nil {\n        return fmt.Errorf(\"failed to load certificate: %w\", err)\n    }\n    \n    cr.mutex.Lock()\n    cr.cert = &cert\n    cr.mutex.Unlock()\n    \n    return nil\n}\n\nfunc (cr *CertificateReloader) Start(ctx context.Context) error {\n    // Initial certificate load\n    if err := cr.loadCertificate(); err != nil {\n        return err\n    }\n    \n    // Watch for certificate file changes\n    ticker := time.NewTicker(30 * time.Second)\n    defer ticker.Stop()\n    \n    for {\n        select {\n        case <-ctx.Done():\n            return ctx.Err()\n        case <-ticker.C:\n            if err := cr.loadCertificate(); err != nil {\n                // Log error but continue watching\n                continue\n            }\n        }\n    }\n}\n```\n\n#### Core Logic Skeleton Code\n\n**Main Reconciliation Flow:**\n\n```go\nfunc (r *DatabaseReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {\n    logger := log.FromContext(ctx)\n    \n    // TODO 1: Fetch the Database resource from the API server\n    // Use r.Get() to retrieve the current resource state\n    // Handle NotFound errors by returning successful result (resource deleted)\n    \n    // TODO 2: Check if resource is being deleted (deletionTimestamp set)\n    // If deletion detected, call handleDeletion() and return\n    // Deletion flow bypasses normal reconciliation logic\n    \n    // TODO 3: Add finalizer if not present\n    // Check if FINALIZER_NAME exists in metadata.finalizers\n    // Add finalizer and update resource if missing\n    \n    // TODO 4: Check if reconciliation is needed\n    // Compare metadata.generation with status.observedGeneration  \n    // Skip reconciliation if generations match (no spec changes)\n    \n    // TODO 5: Fetch current state of owned resources\n    // Get StatefulSet, Service, ConfigMap, PVC owned by this Database\n    // Use owner reference labels for efficient resource discovery\n    \n    // TODO 6: Compute desired state from spec\n    // Generate desired StatefulSet, Service, ConfigMap based on Database spec\n    // Apply configuration templates with values from spec fields\n    \n    // TODO 7: Reconcile each owned resource type\n    // Call createOrUpdateResource() for StatefulSet, Service, ConfigMap\n    // Handle creation, updates, and error scenarios\n    \n    // TODO 8: Wait for StatefulSet readiness\n    // Check StatefulSet status.readyReplicas vs spec.replicas\n    // Return requeue if StatefulSet not ready yet\n    \n    // TODO 9: Update Database status\n    // Set conditions, readyReplicas, phase based on owned resource status\n    // Update observedGeneration to current metadata.generation\n    \n    // TODO 10: Return appropriate result\n    // Return ctrl.Result{} for success, ctrl.Result{RequeueAfter: duration} for retry\n    // Return error for permanent failures that need exponential backoff\n}\n```\n\n**Database Validation Logic:**\n\n```go\nfunc (h *AdmissionHandler) handleDatabaseCreate(ctx context.Context, req *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse {\n    var db Database\n    \n    // TODO 1: Decode the Database resource from admission request\n    // Use h.decoder.DecodeRaw() to convert req.Object into Database struct\n    // Handle JSON decode errors with appropriate error response\n    \n    // TODO 2: Validate replica count constraints\n    // Check if db.Spec.Replicas is between 1 and maximum allowed (e.g., 5)\n    // Return denial response for invalid replica counts\n    \n    // TODO 3: Validate storage size format and minimum\n    // Parse db.Spec.StorageSize using resource.ParseQuantity()\n    // Ensure storage size meets minimum requirements (e.g., 1Gi)\n    \n    // TODO 4: Validate PostgreSQL version format\n    // Check db.Spec.Version matches expected version pattern (major.minor)\n    // Verify version is in supported versions list\n    \n    // TODO 5: Validate resource requirements\n    // Check db.Spec.Resources.Limits and Requests for reasonable values\n    // Ensure memory limits are sufficient for database operation\n    \n    // TODO 6: Validate configuration parameters\n    // Iterate through db.Spec.Config map entries\n    // Check parameter names against allowed PostgreSQL settings\n    // Validate parameter values are within acceptable ranges\n    \n    // TODO 7: Return admission response\n    // Return &admissionv1.AdmissionResponse{Allowed: true} for valid resources\n    // Return denial response with detailed error message for validation failures\n}\n```\n\n**Status Update Logic:**\n\n```go\nfunc (r *DatabaseReconciler) updateDatabaseStatus(ctx context.Context, db *Database, sts *appsv1.StatefulSet) error {\n    // TODO 1: Create updated status object\n    // Initialize new DatabaseStatus struct with current field values\n    // Preserve existing status fields that should not change\n    \n    // TODO 2: Update ready replica count\n    // Set status.ReadyReplicas from sts.Status.ReadyReplicas\n    // Handle case where StatefulSet is nil (not created yet)\n    \n    // TODO 3: Determine current phase\n    // Set status.Phase based on StatefulSet status and readiness\n    // Use phases: \"Pending\", \"Progressing\", \"Ready\", \"Failed\"\n    \n    // TODO 4: Update Ready condition\n    // Set Ready condition to True if readyReplicas == spec.replicas\n    // Set Ready condition to False if StatefulSet has errors\n    // Set Ready condition to Unknown during initial deployment\n    \n    // TODO 5: Update Progressing condition  \n    // Set Progressing to True during rollouts or scaling operations\n    // Set Progressing to False when deployment reaches stable state\n    // Include reason and message describing current operation\n    \n    // TODO 6: Set observed generation\n    // Update status.ObservedGeneration to current metadata.generation\n    // This signals that reconciliation has processed latest spec changes\n    \n    // TODO 7: Update last reconciliation timestamp\n    // Set status.LastReconcileTime to current time\n    // Provides visibility into reconciliation activity\n    \n    // TODO 8: Persist status update\n    // Use r.Status().Update() to save status changes\n    // Handle conflict errors with retry logic\n}\n```\n\n#### Milestone Checkpoint\n\n**After Milestone 3 Implementation:**\n\nRun the following commands to verify complete resource lifecycle:\n\n```bash\n# Test resource creation flow\nkubectl apply -f config/samples/database_v1_database.yaml\nkubectl get database sample-database -o yaml\n\n# Verify webhook processing\nkubectl describe database sample-database\n# Should show defaulted values and validation success\n\n# Test update and reconciliation flow  \nkubectl patch database sample-database --type='merge' -p='{\"spec\":{\"replicas\":3}}'\nkubectl get database sample-database -o jsonpath='{.status.readyReplicas}'\n\n# Test deletion and cleanup flow\nkubectl delete database sample-database\nkubectl get statefulset,service,pvc\n# Should show progressive cleanup of owned resources\n```\n\n**Expected Behavior:**\n- Resource creation triggers mutating webhook defaulting followed by validating webhook checks\n- Controller reconciliation creates StatefulSet, Service, and ConfigMap with owner references\n- Status updates show progression from Pending → Progressing → Ready phases\n- Replica count changes trigger StatefulSet updates and status reflects new ready count\n- Resource deletion initiates finalizer-controlled cleanup sequence\n- All owned resources are removed before Database deletion completes\n\n**Signs of Issues:**\n- Webhook timeouts indicate certificate or networking problems\n- Reconciliation stuck in Progressing phase suggests StatefulSet creation failures\n- Status never updates indicates RBAC permission issues\n- Finalizer not removed indicates cleanup operation failures\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Resource creation hangs | Webhook timeout | Check webhook pod logs and certificate validity | Restart webhook pods, renew certificates |\n| Validation rejected with unclear message | Webhook validation logic error | Examine admission response details in kubectl output | Review webhook validation code, add detailed error messages |\n| Controller reconciliation never triggers | Informer cache sync failure | Check controller manager logs for watch errors | Verify RBAC permissions, restart controller |\n| Status updates fail with conflict errors | Concurrent status modifications | Enable verbose logging to see resource version conflicts | Implement retry logic with fresh resource fetches |\n| Finalizer cleanup stuck | External resource deletion failure | Check Database status message and owned resource states | Manually clean up stuck resources, remove finalizer |\n| Owned resources not deleted | Missing owner references | Verify owner reference metadata on StatefulSet, Service | Add proper owner references during resource creation |\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** Milestone 3 (Reconciliation Loop), Milestone 4 (Webhooks), Milestone 5 (Testing & Deployment) - addresses robust error handling across controller reconciliation, webhook processing, and production deployment scenarios\n\n### Mental Model: The Resilient Orchestra Conductor\n\nThink of a Kubernetes operator as an orchestra conductor who must keep the music playing even when instruments malfunction, sheet music gets lost, or the concert hall loses power. A resilient conductor doesn't panic when the violin section misses an entrance—they calmly adjust the tempo, signal the missed cue again, and ensure the overall performance continues. Similarly, our operator must gracefully handle API server outages, webhook timeouts, and resource conflicts while maintaining the declarative promises made to users.\n\nThe key insight is that distributed systems failures are not exceptional—they are normal operating conditions. Just as a professional conductor expects and prepares for missed cues, a well-designed operator anticipates network partitions, transient errors, and partial failures as part of its standard repertoire.\n\n![Error Handling and Recovery Flow](./diagrams/error-recovery-flow.svg)\n\n## Common Failure Modes\n\nUnderstanding failure modes is crucial for building resilient operators. Each failure mode requires different detection, classification, and recovery strategies. The operator must distinguish between transient errors that will resolve themselves with retry and permanent errors that require human intervention or alternative approaches.\n\n### API Server Connectivity Failures\n\nAPI server connectivity issues are among the most common failures in Kubernetes environments. These can range from brief network hiccups to extended outages during cluster maintenance or infrastructure failures.\n\n**Connection Loss During Informer Operations**\n\nWhen the informer loses its connection to the API server, it stops receiving resource events and its local cache becomes stale. The controller might continue processing items from its work queue, but it cannot fetch current resource state or update resource status. This creates a dangerous situation where the controller operates on outdated information.\n\n| Failure Scenario | Symptoms | Detection Method | Recovery Strategy |\n|------------------|----------|------------------|------------------|\n| Network partition | Informer stops receiving events | Connection error logs, cache staleness | Exponential backoff reconnection with jitter |\n| API server restart | HTTP 503 responses | Failed API calls with server unavailable | Wait for server readiness, rebuild cache |\n| Certificate expiration | TLS handshake failures | Certificate validation errors | Automatic certificate reload or rotation |\n| Resource quota exhaustion | API calls rejected | HTTP 429 or quota exceeded errors | Back off and alert, may require manual intervention |\n\nThe informer's shared index cache provides some protection during brief outages, allowing read operations to continue using cached data. However, the controller must be aware that cached data may be stale and avoid making destructive decisions based on potentially outdated information.\n\n> **Decision: Informer Cache Staleness Handling**\n> - **Context**: When API server connectivity is lost, the informer cache becomes stale but remains readable\n> - **Options Considered**: \n>   1. Stop all reconciliation during connectivity loss\n>   2. Continue reconciliation with stale cache data\n>   3. Limit reconciliation to read-only operations during outages\n> - **Decision**: Continue reconciliation with stale cache but avoid destructive operations\n> - **Rationale**: Stopping completely would prevent recovery when connectivity returns, but destructive operations on stale data could cause cascading failures\n> - **Consequences**: Requires careful classification of operations as safe/unsafe with stale data\n\n**API Call Failures During Reconciliation**\n\nIndividual API calls within the reconciliation loop can fail for various reasons, from temporary network issues to resource conflicts with concurrent operations. The controller must handle these failures gracefully without corrupting the overall reconciliation state.\n\n```\nReconciliation Error Classification:\n1. Check if error indicates stale cache (NotFound for recently created resource)\n2. Classify as transient (network timeout) or permanent (validation failure)\n3. For transient errors: requeue with exponential backoff\n4. For permanent errors: update status with error condition, stop retrying\n5. For cache staleness: force cache refresh and retry once\n```\n\n### Webhook Processing Failures\n\nAdmission webhooks introduce additional failure points in the resource creation and update pipeline. Webhook failures can block all resource operations, making them particularly critical to handle correctly.\n\n**Webhook Timeout and Unavailability**\n\nThe Kubernetes API server has a default 10-second timeout for webhook calls. If the webhook service is unavailable or overloaded, these timeouts can block all operations on the affected resource types.\n\n| Timeout Scenario | Impact | Detection | Mitigation |\n|------------------|---------|----------|------------|\n| Webhook pod not ready | All resource operations fail | Pod status, readiness probes | Failure policy configuration, multiple replicas |\n| Network latency spikes | Intermittent timeouts | Response time monitoring | Reduce webhook processing time, increase timeout |\n| Webhook overloaded | Cascading timeout failures | Queue depth metrics, CPU/memory usage | Horizontal scaling, request rate limiting |\n| Certificate issues | TLS handshake failures | Certificate validation logs | Automated certificate management with cert-manager |\n\nThe webhook configuration's `failurePolicy` setting determines whether operations should be allowed or denied when the webhook is unreachable. This represents a fundamental trade-off between availability and security enforcement.\n\n> **Decision: Webhook Failure Policy Configuration**\n> - **Context**: Webhook unavailability can block all resource operations\n> - **Options Considered**:\n>   1. `failurePolicy: Fail` - deny operations when webhook unavailable (secure but less available)\n>   2. `failurePolicy: Ignore` - allow operations when webhook unavailable (available but less secure)\n>   3. Hybrid approach with different policies for validation vs mutation\n> - **Decision**: Use `Fail` for critical validations, `Ignore` for optional mutations\n> - **Rationale**: Critical business rules must be enforced even at the cost of availability, but optional enhancements shouldn't block operations\n> - **Consequences**: Requires careful classification of webhook logic as critical vs optional\n\n**Webhook Processing Errors**\n\nEven when the webhook service is reachable, processing errors within the webhook logic can cause admission failures. These errors must be handled gracefully with appropriate error messages for users.\n\nThe webhook's error handling affects user experience significantly. A webhook that returns a generic \"internal error\" message leaves users unable to diagnose or fix their resource definitions, while clear, actionable error messages enable self-service problem resolution.\n\n### Controller Process Failures\n\nController crashes and restarts are inevitable in distributed environments. The controller must be designed to recover gracefully from failures without losing track of resources or corrupting reconciliation state.\n\n**Controller Crash Recovery**\n\nWhen a controller process crashes and restarts, it loses all in-memory state including work queue contents and ongoing reconciliation progress. The controller must reconstruct its understanding of the world from the persistent state stored in the Kubernetes API server.\n\n| Recovery Aspect | Challenge | Solution |\n|-----------------|-----------|----------|\n| Work queue state | In-memory queue contents lost on crash | Rebuild from informer full sync on startup |\n| Ongoing reconciliations | Partial operations may be incomplete | Implement idempotent reconciliation logic |\n| Finalizer cleanup | Resources may be stuck in deletion | Check for stale finalizers on startup scan |\n| Status updates | Status may not reflect current state | Recompute and update status during reconciliation |\n\nThe informer's resync mechanism provides a safety net by periodically re-enqueueing all resources, ensuring that any missed events or incomplete reconciliations are eventually processed.\n\n**Leader Election Failures**\n\nIn high-availability deployments with multiple controller replicas, leader election ensures only one replica actively reconciles resources. Leader election failures can result in split-brain scenarios or periods with no active leader.\n\nLeader election uses Kubernetes lease resources with time-based renewal. The leader must continuously renew its lease, and followers must monitor for lease expiration to detect when they should attempt to acquire leadership.\n\n### Resource Conflict Scenarios\n\nMultiple controllers or external actors can modify the same Kubernetes resources concurrently, leading to conflicts that must be resolved without data loss or inconsistent state.\n\n**Optimistic Locking Conflicts**\n\nKubernetes uses optimistic locking through resource versions to detect concurrent modifications. When a controller attempts to update a resource that has been modified since it was last read, the API server returns a conflict error.\n\n```\nOptimistic Locking Conflict Resolution:\n1. Attempt resource update with current resource version\n2. If conflict error occurs, re-read resource from API server\n3. Merge local changes with current state (if possible)\n4. Retry update with new resource version\n5. If conflicts persist, implement exponential backoff\n6. Alert if conflicts indicate systematic issues\n```\n\nThe controller's reconciliation logic must be designed to handle resource version conflicts gracefully by re-reading current state and recomputing desired changes.\n\n**Concurrent Controller Modifications**\n\nWhen multiple controllers manage different aspects of the same resource, coordination becomes essential to prevent conflicts and ensure coherent behavior.\n\n| Conflict Type | Example | Resolution Strategy |\n|---------------|---------|-------------------|\n| Field ownership | Two controllers updating same field | Use Server-Side Apply with field management |\n| Resource creation | Multiple controllers creating same resource | Use owner references and naming conventions |\n| Status updates | Concurrent status field modifications | Use status subresource with separate resource versions |\n| Finalizer management | Multiple controllers adding/removing finalizers | Coordinate finalizer names and removal order |\n\n## Recovery and Self-Healing\n\nThe operator's recovery mechanisms must be automatic, reliable, and comprehensive enough to handle the full spectrum of failure scenarios without human intervention for common cases.\n\n### Automatic Retry Logic\n\nThe retry strategy forms the foundation of the operator's resilience. Different types of errors require different retry approaches, and the strategy must prevent overwhelming failing systems while ensuring rapid recovery when conditions improve.\n\n**Exponential Backoff Implementation**\n\nExponential backoff prevents the controller from overwhelming a struggling API server or webhook service with repeated failed requests. The backoff algorithm increases delay between retries exponentially, with jitter to prevent thundering herd problems.\n\n| Retry Attempt | Base Delay | Jitter Range | Total Delay Range |\n|---------------|------------|--------------|------------------|\n| 1 | 1s | ±0.5s | 0.5s - 1.5s |\n| 2 | 2s | ±1s | 1s - 3s |\n| 3 | 4s | ±2s | 2s - 6s |\n| 4 | 8s | ±4s | 4s - 12s |\n| 5 | 16s | ±8s | 8s - 24s |\n| Max | 300s | ±150s | 150s - 450s |\n\nThe controller-runtime's rate-limiting work queue provides built-in exponential backoff with configurable parameters. The `isErrorRetryable` function classifies errors to determine whether retry is appropriate.\n\n**Error Classification for Retry Decisions**\n\nNot all errors should trigger automatic retries. Permanent errors like validation failures will not resolve through retry and should be reported to users immediately rather than consuming retry capacity.\n\n```\nError Classification Algorithm:\n1. Check error type and HTTP status code\n2. Transient errors (network timeouts, 5xx responses): retry with backoff\n3. Retryable client errors (409 conflicts, 429 rate limits): retry with backoff\n4. Permanent client errors (400 validation, 403 permission): report immediately\n5. Resource not found errors: check if resource was recently deleted, may retry once\n6. Unknown errors: default to transient classification for safety\n```\n\nThe classification function must be conservative, erring on the side of retrying potentially recoverable errors rather than giving up prematurely.\n\n### Leader Election Failover\n\nHigh-availability deployments require seamless failover when the current leader becomes unavailable. The leader election mechanism must detect failures quickly while preventing split-brain scenarios.\n\n**Leader Health Monitoring**\n\nThe active leader must continuously prove its health by renewing its lease before expiration. The lease renewal interval must be shorter than the lease duration to provide a safety margin for network delays and processing time.\n\n| Configuration Parameter | Value | Rationale |\n|------------------------|--------|-----------|\n| Lease Duration | 15s | Long enough to survive brief network hiccups |\n| Renew Deadline | 10s | Provides 5s safety margin before lease expiration |\n| Retry Period | 2s | Allows multiple renewal attempts within deadline |\n\nFollowers monitor the leader's lease and attempt to acquire leadership when the lease expires without renewal. The acquisition process uses atomic compare-and-swap operations to prevent multiple followers from becoming leader simultaneously.\n\n**Graceful Leadership Transition**\n\nWhen leadership changes, the new leader must reconstruct the controller state and resume reconciliation without missing resources or duplicating operations. This requires careful coordination between the outgoing and incoming leaders.\n\nThe incoming leader performs a full informer resync to rebuild its local cache and work queue, ensuring it processes all resources regardless of what the previous leader may have missed. This approach trades some performance for reliability and simplicity.\n\n### State Reconstruction from Cluster State\n\nAfter failures or leadership changes, the controller must reconstruct its understanding of the world from the authoritative state stored in the Kubernetes API server. This reconstruction must be complete and accurate to prevent inconsistencies.\n\n**Full Reconciliation Sweep**\n\nThe informer's initial cache sync triggers reconciliation for all existing custom resources, allowing the controller to verify that actual state matches desired state and correct any drift that may have occurred during downtime.\n\n```\nState Reconstruction Process:\n1. Start informer and wait for initial cache sync completion\n2. Controller receives reconcile requests for all existing resources\n3. Each reconciliation compares actual state with desired state\n4. Controller corrects any drift by creating, updating, or deleting owned resources\n5. Status is updated to reflect current reconciliation state\n6. Normal event-driven reconciliation resumes\n```\n\nThis approach ensures that the controller can recover from extended downtime, configuration changes, or external modifications to owned resources.\n\n**Finalizer Cleanup Verification**\n\nDuring startup, the controller must verify that all finalizers under its management are still needed and remove any stale finalizers that may prevent resource deletion. This prevents resources from becoming stuck in deletion state due to controller failures or configuration changes.\n\nThe controller scans all resources with its finalizer and verifies that cleanup operations are complete. If cleanup has already been performed (perhaps by a previous controller instance), the finalizer is removed to allow deletion to proceed.\n\n## Consistency and Conflict Resolution\n\nDistributed systems like Kubernetes provide eventual consistency rather than strong consistency, requiring operators to handle concurrent modifications and conflicting updates gracefully.\n\n### Handling Concurrent Updates\n\nMultiple actors may attempt to modify the same Kubernetes resource simultaneously, including the operator itself, other controllers, and human administrators using `kubectl`. The operator must coordinate these updates without losing data or creating inconsistent state.\n\n**Resource Version Conflicts**\n\nEvery Kubernetes resource includes a `resourceVersion` field that changes with each modification. When updating a resource, the client must provide the current resource version, and the API server rejects updates that specify an outdated version.\n\n| Conflict Resolution Step | Action | Purpose |\n|-------------------------|---------|----------|\n| 1. Read current resource | `GET /api/v1/namespaces/{ns}/databases/{name}` | Obtain latest resourceVersion |\n| 2. Compute desired changes | Compare spec with actual state | Determine required modifications |\n| 3. Apply changes | `PUT` or `PATCH` with resourceVersion | Attempt atomic update |\n| 4. Handle conflict | If 409 Conflict, retry from step 1 | Resolve concurrent modifications |\n| 5. Update work queue | Requeue with exponential backoff if needed | Prevent overwhelming API server |\n\nThe controller's reconciliation logic must be prepared to restart the reconciliation process when conflicts occur, ensuring that it operates on current resource state rather than stale cached data.\n\n**Server-Side Apply for Field Management**\n\nServer-Side Apply provides a more sophisticated approach to handling concurrent updates by tracking field ownership and allowing controllers to declare which fields they manage. This prevents accidental overwrites of fields managed by other controllers or users.\n\nEach controller declares its identity as a field manager and specifies exactly which fields it wants to control. The API server automatically resolves conflicts by preserving fields owned by other managers while applying only the requesting controller's managed fields.\n\n> **Decision: Update Strategy Selection**\n> - **Context**: Controllers must handle concurrent updates to shared resources\n> - **Options Considered**:\n>   1. Traditional Update (PUT) with conflict retry - simple but can overwrite other controllers' changes\n>   2. Strategic Merge Patch - better than PUT but still can conflict\n>   3. JSON Patch - precise but fragile to concurrent changes\n>   4. Server-Side Apply - most sophisticated but requires field management design\n> - **Decision**: Use Server-Side Apply for spec updates, traditional Update for status\n> - **Rationale**: Spec updates often conflict with user or other controller changes, while status is typically owned by single controller\n> - **Consequences**: Requires defining field management policies and handling field ownership conflicts\n\n### Optimistic Locking Patterns\n\nOptimistic locking assumes that conflicts are rare and allows multiple readers to access data concurrently, detecting conflicts only when writes occur. This provides better performance than pessimistic locking but requires careful conflict resolution logic.\n\n**Read-Modify-Write Cycles**\n\nThe controller's typical update pattern follows a read-modify-write cycle where it reads the current resource state, computes required changes, and attempts to write the updated resource back to the API server.\n\n```\nOptimistic Locking Pattern:\n1. Read resource and note resourceVersion (e.g., \"12345\")\n2. Compute desired changes based on current state\n3. Modify resource object with intended changes\n4. Attempt update with resourceVersion: \"12345\"\n5. If successful: operation complete\n6. If conflict (409): another actor modified resource, restart from step 1\n7. If other error: classify and handle according to retry policy\n```\n\nThe key insight is that the controller must be prepared to discard its computed changes and restart the reconciliation process with fresh data when conflicts occur.\n\n**Idempotent Reconciliation Design**\n\nIdempotent reconciliation ensures that applying the same desired state multiple times produces the same result, making conflict resolution and retry logic safe and predictable.\n\n| Idempotency Principle | Example | Implementation |\n|-----------------------|---------|----------------|\n| Create operations are idempotent | Creating a Deployment | Check if resource exists before creating, or use `kubectl apply` semantics |\n| Update operations are idempotent | Scaling replicas from 2 to 3 | Set absolute values rather than relative changes |\n| Delete operations are idempotent | Removing a Service | Check if resource exists before deletion, handle NotFound gracefully |\n| Status updates are idempotent | Setting Ready condition | Compare current status, update only if different |\n\nIdempotent design allows the controller to safely retry operations after conflicts without worrying about double-application of changes or accumulating errors.\n\n### Eventual Consistency Expectations\n\nKubernetes provides eventual consistency, meaning that changes propagate through the system over time but may not be immediately visible to all observers. The operator must account for this consistency model in its design and expectations.\n\n**Informer Cache Lag**\n\nThe informer's local cache may lag behind the authoritative state in the API server, particularly during periods of high change volume or network issues. The controller must handle cases where its cache doesn't yet reflect recent changes made by other actors.\n\nA common scenario occurs when the controller creates a resource (like a Deployment) and immediately queries its informer cache to check the resource's status. The cache may not yet contain the newly created resource, leading to incorrect decisions if the controller assumes the resource doesn't exist.\n\n> The critical insight here is that informer caches provide **eventually consistent** views of cluster state, not **immediately consistent** views. Controllers must design their logic to handle cache lag gracefully rather than assuming instant consistency.\n\n**Cross-Resource Dependency Timing**\n\nWhen the operator manages multiple related resources (like a Deployment, Service, and ConfigMap), the timing of their creation and readiness can vary. The controller must handle scenarios where dependencies aren't yet available or haven't reached their desired state.\n\n```\nDependency Handling Strategy:\n1. Create all owned resources in dependency order (ConfigMap → Deployment → Service)\n2. Check readiness of dependencies before proceeding with dependent resources\n3. Use owner references to ensure garbage collection if parent resource is deleted\n4. Implement timeout and retry logic for dependency readiness checks\n5. Update status with detailed progress information for troubleshooting\n```\n\nThe `updateCondition` function maintains detailed status information about dependency progress, allowing users and debugging tools to understand why reconciliation may be incomplete.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Assuming Immediate Consistency After Creates**\nMany developers assume that after successfully creating a resource via the API server, it will immediately be visible in the informer cache. This leads to race conditions where the controller makes incorrect decisions based on stale cache data. The fix is to either use direct API server queries for recently created resources or implement retry logic that handles temporary cache inconsistency.\n\n⚠️ **Pitfall: Not Implementing Proper Resource Version Handling**\nSome controllers ignore resource version conflicts and keep retrying with the original resource version, leading to permanent update failures. The correct approach is to re-read the resource after each conflict and recompute changes based on the current state rather than the original state.\n\n⚠️ **Pitfall: Blocking Reconciliation on Transient Errors**\nControllers that fail fast on any error, including transient network issues, provide poor user experience. The operator should distinguish between permanent errors (validation failures) that require user intervention and transient errors (network timeouts) that should be retried automatically with exponential backoff.\n\n⚠️ **Pitfall: Missing Finalizer Cleanup in Error Scenarios**\nIf the controller adds a finalizer but crashes before completing cleanup, the resource becomes stuck in deletion state. The controller must implement startup logic that scans for stale finalizers and completes any pending cleanup operations to prevent resources from being permanently stuck.\n\n⚠️ **Pitfall: Not Handling Webhook Unavailability Gracefully**\nWebhook services that crash or become unavailable can block all operations on their resource types if configured with `failurePolicy: Fail`. While this prevents bypassing validation, it can make the entire system unusable. The solution is to implement webhook high availability with multiple replicas, health checks, and careful consideration of failure policy settings.\n\n### Implementation Guidance\n\nUnderstanding error handling concepts is only half the battle—implementing robust error handling requires careful attention to Go's error handling patterns, controller-runtime's retry mechanisms, and Kubernetes API conventions.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Error Classification | Basic type assertions and string matching | Custom error types with structured classification |\n| Retry Logic | controller-runtime's default rate limiter | Custom rate limiter with circuit breaker patterns |\n| Monitoring | Standard Go logging with structured fields | Prometheus metrics with custom error counters |\n| Leader Election | controller-runtime's built-in leader election | Custom leader election with health checks |\n\n#### Recommended File Structure\n\n```\ninternal/controller/\n  database_controller.go           ← main reconciliation logic with error handling\n  database_controller_test.go      ← tests including error scenarios\n  error_handling.go               ← error classification and retry logic\n  finalizer_cleanup.go            ← startup cleanup and recovery logic\n  status_manager.go               ← status update logic with conflict handling\ninternal/webhook/\n  admission_handler.go            ← webhook error handling and timeout management\n  tls_manager.go                  ← certificate management and rotation\ninternal/metrics/\n  error_metrics.go               ← error tracking and alerting\n```\n\n#### Error Classification Infrastructure\n\nThis complete error classification system provides the foundation for intelligent retry decisions throughout the operator:\n\n```go\npackage controller\n\nimport (\n    \"errors\"\n    \"net\"\n    \"time\"\n    \n    apierrors \"k8s.io/apimachinery/pkg/api/errors\"\n    \"sigs.k8s.io/controller-runtime/pkg/reconcile\"\n)\n\n// ErrorClassification represents different types of errors and their handling\ntype ErrorClassification int\n\nconst (\n    ErrorTransient ErrorClassification = iota  // Retry with exponential backoff\n    ErrorRetryable                            // Retry immediately or with short delay\n    ErrorPermanent                            // Don't retry, update status with error\n    ErrorConflict                             // Special handling for optimistic locking\n)\n\n// ClassifyError determines how an error should be handled during reconciliation\nfunc (r *DatabaseReconciler) ClassifyError(err error) ErrorClassification {\n    if err == nil {\n        return ErrorTransient // Should not happen, but safe default\n    }\n    \n    // Kubernetes API errors\n    if apierrors.IsConflict(err) {\n        return ErrorConflict\n    }\n    if apierrors.IsNotFound(err) {\n        return ErrorRetryable // May be cache lag\n    }\n    if apierrors.IsServerTimeout(err) || apierrors.IsTimeout(err) {\n        return ErrorTransient\n    }\n    if apierrors.IsTooManyRequests(err) {\n        return ErrorTransient\n    }\n    if apierrors.IsInternalError(err) || apierrors.IsServiceUnavailable(err) {\n        return ErrorTransient\n    }\n    if apierrors.IsBadRequest(err) || apierrors.IsInvalid(err) {\n        return ErrorPermanent\n    }\n    if apierrors.IsForbidden(err) || apierrors.IsUnauthorized(err) {\n        return ErrorPermanent\n    }\n    \n    // Network errors\n    var netErr net.Error\n    if errors.As(err, &netErr) {\n        if netErr.Timeout() {\n            return ErrorTransient\n        }\n        return ErrorTransient // Most network errors are transient\n    }\n    \n    // Default to transient for safety\n    return ErrorTransient\n}\n\n// HandleReconcileError processes errors according to their classification\nfunc (r *DatabaseReconciler) HandleReconcileError(ctx context.Context, \n    db *Database, err error) (reconcile.Result, error) {\n    \n    classification := r.ClassifyError(err)\n    \n    switch classification {\n    case ErrorTransient:\n        // Let controller-runtime handle exponential backoff\n        r.updateCondition(db, ConditionTypeReady, \"False\", \"TransientError\", err.Error())\n        return reconcile.Result{}, err\n        \n    case ErrorRetryable:\n        // Quick retry, might be cache staleness\n        r.updateCondition(db, ConditionTypeReady, \"False\", \"RetryableError\", err.Error())\n        return reconcile.Result{RequeueAfter: 5 * time.Second}, nil\n        \n    case ErrorConflict:\n        // Resource version conflict - retry immediately\n        return reconcile.Result{Requeue: true}, nil\n        \n    case ErrorPermanent:\n        // Don't retry, update status with error\n        r.updateCondition(db, ConditionTypeReady, \"False\", \"PermanentError\", err.Error())\n        return reconcile.Result{}, nil // Don't return error to avoid retry\n        \n    default:\n        return reconcile.Result{}, err\n    }\n}\n```\n\n#### Robust Reconciliation Loop Skeleton\n\nThis skeleton implements the complete error handling patterns discussed in the design section:\n\n```go\nfunc (r *DatabaseReconciler) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) {\n    logger := r.Log.WithValues(\"database\", req.NamespacedName)\n    \n    // TODO 1: Fetch the Database resource with error handling\n    // Hint: Handle NotFound errors gracefully - resource may have been deleted\n    var db Database\n    if err := r.Get(ctx, req.NamespacedName, &db); err != nil {\n        if apierrors.IsNotFound(err) {\n            // Resource deleted, stop reconciliation\n            return reconcile.Result{}, nil\n        }\n        return r.HandleReconcileError(ctx, &db, err)\n    }\n    \n    // TODO 2: Handle finalizer logic for deletion\n    // Hint: Check if deletion timestamp is set, add/remove finalizers accordingly\n    if !db.DeletionTimestamp.IsZero() {\n        return r.handleDeletion(ctx, &db)\n    }\n    if !controllerutil.ContainsFinalizer(&db, FINALIZER_NAME) {\n        controllerutil.AddFinalizer(&db, FINALIZER_NAME)\n        return reconcile.Result{Requeue: true}, r.Update(ctx, &db)\n    }\n    \n    // TODO 3: Get current state of owned resources with conflict handling\n    // Hint: Use Get() calls with proper error classification\n    currentState, err := r.getCurrentState(ctx, &db)\n    if err != nil {\n        return r.HandleReconcileError(ctx, &db, err)\n    }\n    \n    // TODO 4: Compare desired state from spec with current state\n    // Hint: Implement comparison logic that's resilient to cache staleness\n    desiredState := r.computeDesiredState(&db)\n    changes := r.computeChanges(currentState, desiredState)\n    \n    // TODO 5: Apply changes with proper error handling and conflict resolution\n    // Hint: Use Server-Side Apply for spec updates, handle conflicts gracefully\n    for _, change := range changes {\n        if err := r.applyChange(ctx, change); err != nil {\n            if r.ClassifyError(err) == ErrorConflict {\n                // Immediate retry for conflicts\n                return reconcile.Result{Requeue: true}, nil\n            }\n            return r.HandleReconcileError(ctx, &db, err)\n        }\n    }\n    \n    // TODO 6: Update status with current conditions and state\n    // Hint: Use status subresource, handle conflicts by re-reading and retrying\n    return r.updateDatabaseStatus(ctx, &db, currentState)\n}\n```\n\n#### Webhook Error Handling Infrastructure\n\nComplete webhook error handling that addresses timeout and certificate issues:\n\n```go\npackage webhook\n\nimport (\n    \"context\"\n    \"crypto/tls\"\n    \"fmt\"\n    \"net/http\"\n    \"time\"\n    \n    admissionv1 \"k8s.io/api/admission/v1\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/apimachinery/pkg/runtime\"\n)\n\ntype AdmissionHandler struct {\n    decoder *admission.Decoder\n    certReloader *CertificateReloader\n}\n\n// ServeHTTP handles admission review requests with comprehensive error handling\nfunc (h *AdmissionHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    // TODO 1: Set reasonable timeout for webhook processing\n    // Hint: Kubernetes has 10s default timeout, leave buffer for response\n    ctx, cancel := context.WithTimeout(r.Context(), 8*time.Second)\n    defer cancel()\n    \n    // TODO 2: Parse admission review request with error handling\n    // Hint: Handle malformed requests gracefully with proper HTTP status codes\n    review, err := h.parseAdmissionReview(r)\n    if err != nil {\n        h.sendErrorResponse(w, http.StatusBadRequest, \n            fmt.Sprintf(\"Failed to parse admission review: %v\", err))\n        return\n    }\n    \n    // TODO 3: Process admission review with timeout handling\n    // Hint: Check context deadline and return partial response if needed\n    response := h.processAdmissionReview(ctx, review)\n    \n    // TODO 4: Send response with proper error handling\n    // Hint: Set appropriate HTTP status codes and content types\n    h.sendAdmissionResponse(w, response)\n}\n\n// processAdmissionReview routes requests to appropriate handlers with error recovery\nfunc (h *AdmissionHandler) processAdmissionReview(ctx context.Context, \n    review *admissionv1.AdmissionReview) *admissionv1.AdmissionReview {\n    \n    // TODO 1: Check context deadline before processing\n    // Hint: Return admission denial if insufficient time remains\n    if deadline, ok := ctx.Deadline(); ok && time.Until(deadline) < 1*time.Second {\n        return h.timeoutResponse(review, \"Webhook processing timeout\")\n    }\n    \n    // TODO 2: Route to appropriate handler based on operation and kind\n    // Hint: Use type switches and handle unknown operations gracefully\n    req := review.Request\n    var response *admissionv1.AdmissionResponse\n    \n    switch {\n    case req.Kind.Kind == \"Database\" && req.Operation == admissionv1.Create:\n        response = h.handleDatabaseCreate(ctx, req)\n    case req.Kind.Kind == \"Database\" && req.Operation == admissionv1.Update:\n        response = h.handleDatabaseUpdate(ctx, req)\n    case req.Kind.Kind == \"Database\" && req.Operation == admissionv1.Delete:\n        response = h.handleDatabaseDelete(ctx, req)\n    default:\n        response = h.allowResponse(req.UID, \"Operation not handled by this webhook\")\n    }\n    \n    // TODO 3: Create admission review response with proper metadata\n    // Hint: Preserve request UID and API version information\n    return &admissionv1.AdmissionReview{\n        TypeMeta: metav1.TypeMeta{\n            APIVersion: \"admission.k8s.io/v1\",\n            Kind:       \"AdmissionReview\",\n        },\n        Response: response,\n    }\n}\n```\n\n#### TLS Certificate Management\n\nRobust certificate handling that prevents webhook outages due to certificate issues:\n\n```go\ntype CertificateReloader struct {\n    certPath string\n    keyPath  string\n    cert     *tls.Certificate\n    certTime time.Time\n    keyTime  time.Time\n}\n\nfunc NewCertificateReloader(certPath, keyPath string) *CertificateReloader {\n    return &CertificateReloader{\n        certPath: certPath,\n        keyPath:  keyPath,\n    }\n}\n\n// GetCertificate returns current certificate, reloading if files have changed\nfunc (cr *CertificateReloader) GetCertificate(*tls.ClientHelloInfo) (*tls.Certificate, error) {\n    // TODO 1: Check if certificate files have been modified\n    // Hint: Use os.Stat to check modification times, reload if changed\n    \n    // TODO 2: Load certificate with proper error handling\n    // Hint: Don't update stored cert if loading fails, return previous cert\n    \n    // TODO 3: Validate certificate expiration\n    // Hint: Log warnings if certificate expires soon, return error if expired\n    \n    return cr.cert, nil\n}\n```\n\n#### Milestone Checkpoints\n\n**Checkpoint 1: Error Classification Testing**\nRun this test to verify error classification works correctly:\n```bash\ngo test ./internal/controller -run TestErrorClassification\n```\nExpected behavior: All Kubernetes API error types are correctly classified as transient, retryable, or permanent. Network errors are classified as transient. Unknown errors default to transient.\n\n**Checkpoint 2: Reconciliation Error Handling**\nCreate a Database resource with invalid configuration and verify the controller updates status with appropriate error condition instead of retrying indefinitely.\n\n**Checkpoint 3: Webhook Timeout Simulation**\nAdd artificial delays to webhook processing and verify that requests near the timeout deadline are handled gracefully with appropriate admission responses.\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Resources stuck in pending state | Controller crashing on reconciliation errors | Check controller logs for panic stacktraces | Add error handling and classification to reconciliation loop |\n| Webhook blocking all operations | Certificate expired or webhook pod not ready | Check webhook service endpoints and certificate validity | Implement certificate reloading and webhook health checks |\n| Status never updates after errors | Status update conflicts not handled | Look for 409 Conflict errors in logs during status updates | Implement conflict retry in status update logic |\n| Controller consuming excessive CPU | Infinite reconciliation loop from missing error handling | Monitor reconciliation frequency for specific resources | Add proper requeue delays and error classification |\n| Resources stuck in deletion | Finalizer not removed due to cleanup errors | Check for resources with finalizers but no owning controller | Implement finalizer cleanup verification on controller startup |\n\nThe error handling and recovery mechanisms form the foundation of operator reliability. By implementing comprehensive error classification, intelligent retry logic, and robust conflict resolution, the operator can provide consistent behavior even in the face of network partitions, API server outages, and concurrent modifications that are inherent in distributed Kubernetes environments.\n\n\n## Testing Strategy and Validation\n\n> **Milestone(s):** Milestone 5 (Testing & Deployment) - provides comprehensive testing approaches for unit testing, integration testing, and milestone validation checkpoints that ensure the operator functions correctly at each development stage\n\nTesting a Kubernetes operator presents unique challenges that differ significantly from testing traditional applications. The operator must interact correctly with the Kubernetes API server, handle distributed system failures gracefully, and maintain consistent behavior across different cluster states. A robust testing strategy requires multiple layers of validation, from isolated unit tests that verify individual functions to full integration tests that exercise the complete controller lifecycle against a real API server.\n\n### Mental Model: The Quality Assurance Laboratory\n\nThink of operator testing like a medical laboratory that validates treatments at multiple levels. Unit tests are like testing individual chemical reactions in isolation - they verify that specific functions produce expected outputs when given controlled inputs. Integration tests resemble clinical trials that test the complete treatment protocol on live subjects - they validate that the entire operator behaves correctly when interacting with a real Kubernetes environment. Finally, milestone validation checkpoints are like regulatory approval processes that ensure each development phase meets safety and efficacy standards before proceeding to the next phase.\n\nJust as medical testing requires both controlled laboratory conditions and real-world clinical validation, operator testing demands both isolated unit tests with predictable fake clients and comprehensive integration tests against actual Kubernetes API servers. Each testing layer catches different categories of defects and provides different types of confidence in the system's correctness.\n\n## Unit Testing with Fake Clients\n\nUnit testing forms the foundation of operator validation by testing individual controller functions in complete isolation from external dependencies. The controller-runtime library provides sophisticated fake client implementations that simulate Kubernetes API behavior without requiring an actual cluster. These fake clients maintain in-memory representations of cluster state and respond to client operations with realistic behavior, including resource versioning, conflict detection, and validation.\n\n**Fake clients excel at testing reconciliation logic** because they provide deterministic, controllable environments where specific error conditions can be simulated reliably. Unlike integration tests that may exhibit timing-dependent behavior, unit tests with fake clients produce identical results on every execution, making them ideal for testing edge cases and error scenarios that would be difficult to reproduce consistently in real clusters.\n\nThe fake client architecture maintains separate storage for each resource type, implementing the same optimistic locking semantics as the real Kubernetes API server. When a test creates a `Database` resource with the fake client, subsequent `Get` operations return the exact object with proper resource versions and generation fields. Updates that specify outdated resource versions fail with conflict errors, allowing tests to verify that the controller handles concurrent modifications correctly.\n\n### Core Testing Components\n\nThe unit testing infrastructure relies on several key components that work together to provide comprehensive test coverage:\n\n| Component | Type | Purpose |\n|-----------|------|---------|\n| `fake.NewClientBuilder()` | Client Builder | Creates configurable fake Kubernetes client instances |\n| `scheme.Scheme` | Runtime Scheme | Defines known resource types for client serialization |\n| `envtest.Environment` | Test Environment | Provides real API server for integration tests |\n| `reconcile.Request` | Reconciliation Request | Represents controller work queue items |\n| `ctrl.Result` | Reconciliation Result | Indicates requeue behavior and timing |\n\n### Testing Reconciliation Logic\n\nThe core of unit testing focuses on validating the `Reconcile` method behavior under various scenarios. Each test case should establish a known cluster state using the fake client, trigger reconciliation for a specific resource, and verify both the returned result and the resulting cluster state changes.\n\n**Testing successful reconciliation** requires creating a `Database` resource with a valid specification, calling the reconciler, and verifying that owned resources are created with correct configurations. The test must check that the `Database` status is updated with appropriate conditions and that the reconciliation result indicates successful completion without requeue requirements.\n\n**Testing error conditions** involves simulating various failure modes and verifying that the controller responds appropriately. This includes testing scenarios where owned resources cannot be created due to API server errors, where resource specifications contain invalid configurations, and where external dependencies are unavailable.\n\n**Testing idempotent behavior** ensures that repeated reconciliation of the same resource produces identical results. This critical property guarantees that controller restarts or duplicate events do not cause unintended side effects or resource duplication.\n\n### Fake Client Configuration and Setup\n\nProper fake client configuration requires careful attention to scheme registration and resource type definitions. The fake client must understand all custom resource types that the controller manages, requiring explicit registration of CRDs in the runtime scheme.\n\n```go\n// Example scheme registration (Implementation Guidance will show complete code)\nscheme.AddToScheme(DatabaseCRD)\nscheme.AddToScheme(SecretCRD)\nfakeClient := fake.NewClientBuilder().WithScheme(scheme).Build()\n```\n\nThe fake client supports advanced features like resource generation tracking, owner reference validation, and finalizer processing. Tests can configure the fake client to simulate specific API server behaviors, such as temporary unavailability or resource quota enforcement.\n\n**Initial state setup** involves creating prerequisite resources that the controller expects to exist. This might include `ConfigMap` resources containing default configurations, `Secret` resources with authentication credentials, or `Namespace` resources that own the custom resources being tested.\n\n### Status Update Validation\n\nTesting status updates requires careful verification that the controller correctly writes status information without affecting the resource specification. The fake client maintains separate tracking for spec and status subresources, allowing tests to verify that status updates do not inadvertently modify the desired state.\n\n| Status Field | Test Verification | Purpose |\n|--------------|------------------|---------|\n| `Conditions` | Contains expected condition types with correct status values | Communicates current reconciliation state |\n| `ReadyReplicas` | Matches number of ready owned resources | Indicates operational capacity |\n| `ObservedGeneration` | Equals metadata generation of reconciled resource | Shows which spec version was processed |\n| `Phase` | Reflects current lifecycle stage | Provides high-level status summary |\n| `LastBackupTime` | Updated when backup operations complete | Tracks operational activities |\n| `Endpoints` | Lists accessible service endpoints | Provides connectivity information |\n\n**Condition testing** focuses on verifying that the controller creates appropriate condition entries for different scenarios. Ready conditions should indicate when all owned resources are operational, while progressing conditions should appear during active reconciliation activities. Error conditions must provide clear, actionable messages that help users understand and resolve issues.\n\n### Error Handling and Requeue Testing\n\nUnit tests must thoroughly validate the controller's error handling behavior, ensuring that different error types trigger appropriate responses. Transient errors should result in exponential backoff requeue behavior, while permanent errors should update the resource status without scheduling automatic retries.\n\nThe fake client can be configured to return specific error types for different operations, allowing tests to verify controller behavior in response to various failure modes:\n\n| Error Scenario | Expected Behavior | Test Validation |\n|----------------|-------------------|-----------------|\n| API server unavailable | Return error with immediate requeue | Verify `Result.Requeue` is true |\n| Resource already exists | Continue reconciliation normally | Verify no error returned |\n| Invalid resource configuration | Update status with error condition | Verify condition type and message |\n| Insufficient permissions | Return error without requeue | Verify `Result.RequeueAfter` is zero |\n| Resource conflict | Return error with short requeue delay | Verify `Result.RequeueAfter` < 1 minute |\n\n**Requeue timing validation** ensures that the controller requests appropriate delays between reconciliation attempts. Immediate requeues should be reserved for situations where external state changes are expected quickly, while longer delays should be used for scenarios requiring user intervention or external system recovery.\n\n### Testing Finalizer Logic\n\nFinalizer processing represents one of the most critical and error-prone aspects of operator behavior. Unit tests must verify that finalizers are added during resource creation, that cleanup operations execute correctly during deletion, and that finalizers are removed only after successful cleanup completion.\n\n**Testing finalizer addition** involves creating a new `Database` resource and verifying that the controller adds the appropriate finalizer during initial reconciliation. The test should confirm that the finalizer appears in the resource metadata and that subsequent reconciliation recognizes the finalizer's presence.\n\n**Testing deletion and cleanup** requires setting a deletion timestamp on a resource with finalizers and verifying that cleanup operations execute in the correct order. The controller should delete all owned resources, wait for deletion completion, and only then remove the finalizer to allow garbage collection.\n\n**Testing cleanup failures** ensures that incomplete cleanup operations do not remove finalizers prematurely. If owned resource deletion fails, the controller should leave finalizers in place and report error conditions in the resource status.\n\n### Common Unit Testing Pitfalls\n\n⚠️ **Pitfall: Not Configuring Fake Client Scheme Properly**\n\nTests frequently fail because the fake client doesn't understand custom resource types that the controller attempts to manipulate. This manifests as serialization errors or \"no kind is registered\" panics during test execution. The fix requires explicitly adding all relevant CRDs and built-in Kubernetes types to the fake client's scheme during test setup.\n\n⚠️ **Pitfall: Testing Only Happy Path Scenarios**\n\nMany unit test suites focus exclusively on successful reconciliation scenarios while ignoring error conditions and edge cases. This creates false confidence in controller reliability because real-world environments frequently encounter API server unavailability, resource conflicts, and configuration errors. Comprehensive test suites should include more error scenarios than success scenarios.\n\n⚠️ **Pitfall: Not Verifying Status Updates Separately**\n\nTests often check that reconciliation completes successfully but fail to verify that status updates contain correct information. Since status subresources update independently from spec changes, tests must explicitly fetch and validate status fields after reconciliation completion. Missing status validation can hide bugs where controllers perform correct actions but provide incorrect feedback to users.\n\n⚠️ **Pitfall: Ignoring Resource Version and Generation Fields**\n\nFake clients properly implement optimistic locking through resource versions, but tests that don't account for these fields may pass artificially. Real controllers must handle resource version conflicts and generation tracking correctly, so unit tests should verify that these mechanisms work properly by attempting concurrent modifications and checking generation-based condition logic.\n\n## Integration Testing with Envtest\n\nIntegration testing validates operator behavior against real Kubernetes API servers, providing confidence that the controller works correctly within actual cluster environments. The `envtest` framework creates lightweight Kubernetes control planes that include `etcd` and `kube-apiserver` components without the overhead of full cluster deployments. These test environments support all standard Kubernetes API operations while running quickly enough for automated testing pipelines.\n\n**Envtest bridges the gap between unit tests and full cluster testing** by providing real API server behavior while maintaining test isolation and repeatability. Unlike fake clients that simulate API responses, envtest environments process requests through actual Kubernetes controllers, including garbage collection, owner reference processing, and admission controller execution.\n\nThe envtest environment supports advanced Kubernetes features that fake clients cannot replicate, such as server-side apply, strategic merge patches, and admission webhook processing. This comprehensive API compatibility ensures that operators tested with envtest behave identically in production clusters, reducing the likelihood of integration issues during deployment.\n\n### Envtest Environment Setup\n\nEnvtest environments require careful configuration to match production cluster characteristics while maintaining test performance. The environment setup process involves downloading Kubernetes binaries, configuring API server options, and establishing client connections with appropriate authentication credentials.\n\n| Configuration Option | Purpose | Typical Value |\n|----------------------|---------|---------------|\n| `KubernetesVersion` | Specifies API server version | \"1.28.0\" |\n| `CRDInstallOptions.Paths` | Locations of CRD YAML files | [\"./config/crd/bases\"] |\n| `UseExistingCluster` | Connect to running cluster instead of creating new one | false for CI, true for debugging |\n| `AttachControlPlaneOutput` | Show API server logs during tests | true for debugging |\n| `ControlPlaneStartTimeout` | Maximum time to wait for startup | 60 * time.Second |\n| `ControlPlaneStopTimeout` | Maximum time to wait for shutdown | 60 * time.Second |\n\n**CRD installation** happens automatically during environment startup when CRD paths are configured correctly. The envtest framework reads YAML files from specified directories and creates custom resource definitions before starting the test API server. This process ensures that custom resources are available immediately when tests begin execution.\n\n**Client configuration** uses the same controller-runtime managers and clients that production operators employ. This consistency ensures that integration tests exercise identical code paths to production environments, including client-side caching, informer behavior, and work queue processing.\n\n### Controller Manager Integration\n\nIntegration tests run complete controller managers that include informers, work queues, and reconciliation loops. This comprehensive testing approach validates not only individual reconciliation logic but also the interactions between different controller components and their behavior under concurrent load.\n\nThe controller manager setup process involves registering custom resource schemes, configuring controller options, and starting background processing goroutines. Integration tests must carefully coordinate controller startup with test execution to ensure that informer caches are populated and event processing is active before triggering test scenarios.\n\n```go\n// Example controller manager setup (complete implementation in Implementation Guidance)\nmgr := ctrl.NewManager(cfg, ctrl.Options{Scheme: scheme})\nreconciler := &DatabaseReconciler{Client: mgr.GetClient(), Scheme: scheme}\nreconciler.SetupWithManager(mgr)\nctx, cancel := context.WithCancel(context.Background())\ngo mgr.Start(ctx)\n```\n\n**Manager lifecycle coordination** requires proper startup sequencing and graceful shutdown handling. Tests must wait for manager readiness before executing test scenarios and must trigger clean shutdown to prevent goroutine leaks between test cases.\n\n**Informer cache synchronization** introduces timing considerations that don't exist in unit tests. Integration tests must wait for informer caches to populate with initial resource state before verifying controller behavior, as controllers operating with empty caches may exhibit different behavior than those with fully synchronized state.\n\n### End-to-End Reconciliation Testing\n\nIntegration tests validate complete reconciliation cycles by creating custom resources, waiting for controller processing, and verifying that both owned resources and status updates reflect the expected final state. These tests provide confidence that all components work together correctly under realistic conditions.\n\n**Resource creation testing** involves applying `Database` resources to the envtest cluster and monitoring both the reconciliation process and its outcomes. Tests must account for asynchronous processing by polling resource status until reconciliation completes or timeout periods expire.\n\n**Owned resource verification** ensures that controllers create, configure, and manage owned resources correctly. Integration tests should verify not only that owned resources exist but also that they contain correct specifications, labels, annotations, and owner references that enable proper garbage collection.\n\n**Status progression tracking** monitors how resource status evolves during reconciliation cycles. Tests should verify that progressing conditions appear during active reconciliation, that ready conditions indicate successful completion, and that error conditions provide actionable diagnostic information.\n\n### Testing Concurrent Reconciliation\n\nIntegration tests can validate controller behavior under concurrent load by creating multiple custom resources simultaneously and verifying that reconciliation proceeds correctly for all resources. This testing approach reveals race conditions, resource contention issues, and queue processing problems that single-resource tests cannot detect.\n\n**Multiple resource testing** creates several `Database` resources with different configurations and verifies that each resource reconciles independently without interference. These tests should confirm that controller scaling works correctly and that individual resource failures do not affect processing of other resources.\n\n**Resource update testing** modifies existing resources while reconciliation is active, simulating real-world scenarios where users update specifications while controllers are processing previous changes. Tests should verify that controllers handle spec changes gracefully and that status updates reflect the most recent reconciliation results.\n\n**Concurrent modification testing** attempts to modify resources from multiple clients simultaneously, verifying that controllers handle resource version conflicts and retry operations appropriately. These tests ensure that operators behave correctly in multi-user environments where administrative operations may overlap with controller activities.\n\n### Webhook Integration Testing\n\nIntegration tests with envtest can validate admission webhook behavior by configuring webhook endpoints and processing admission review requests through the test API server. This comprehensive testing approach ensures that webhooks integrate correctly with the Kubernetes admission control system.\n\n**Webhook server setup** involves starting HTTPS servers with appropriate TLS certificates and registering admission webhook configurations with the test API server. The envtest framework supports webhook testing through proper certificate management and admission controller configuration.\n\n**Validation webhook testing** creates resources with invalid specifications and verifies that admission webhooks reject requests with appropriate error messages. Tests should confirm that validation logic correctly identifies invalid field combinations and provides clear diagnostic information to users.\n\n**Mutation webhook testing** creates resources with minimal specifications and verifies that mutating webhooks inject appropriate default values. Tests should confirm that mutation logic produces consistent results and that mutated resources pass subsequent validation checks.\n\n### Performance and Load Testing\n\nIntegration tests can evaluate operator performance characteristics by creating large numbers of resources and measuring reconciliation throughput, memory usage, and response times. These measurements provide baseline performance expectations and help identify scalability limitations.\n\n**Throughput testing** creates batches of resources and measures how quickly the controller processes them to completion. These tests help establish capacity planning guidelines and identify performance bottlenecks in reconciliation logic.\n\n**Memory usage testing** monitors controller memory consumption while processing various workloads to identify memory leaks or excessive resource usage. Long-running tests can reveal gradual memory growth that would not be apparent in short-duration scenarios.\n\n**Response time testing** measures the delay between resource creation and reconciliation completion, providing insights into user experience and system responsiveness. These measurements help establish appropriate timeout values and requeue intervals.\n\n### Common Integration Testing Pitfalls\n\n⚠️ **Pitfall: Not Waiting for Controller Readiness**\n\nIntegration tests frequently fail because they attempt to validate controller behavior before informer caches are fully synchronized or before controllers have registered their watches. This manifests as tests that pass when run individually but fail when executed as part of larger test suites. The fix requires implementing proper readiness checks that wait for manager startup completion and informer cache synchronization.\n\n⚠️ **Pitfall: Ignoring Asynchronous Processing**\n\nMany integration tests assume that reconciliation completes immediately after resource creation, leading to race conditions where tests check results before processing finishes. Real controllers process events asynchronously through work queues, requiring tests to poll for expected conditions with appropriate timeout values rather than checking results immediately.\n\n⚠️ **Pitfall: Not Cleaning Up Resources Between Tests**\n\nIntegration tests that don't properly clean up created resources can exhibit order-dependent failures where previous test state affects subsequent test execution. Since envtest environments persist resources across individual test cases within a suite, tests must explicitly delete created resources or use unique namespaces to ensure isolation.\n\n⚠️ **Pitfall: Insufficient Timeout Values**\n\nIntegration tests often use timeout values that work during local development but fail in resource-constrained CI environments. Envtest startup, controller initialization, and reconciliation processing all require sufficient time to complete, particularly when running on shared infrastructure with limited CPU resources.\n\n## Milestone Validation Checkpoints\n\nEach development milestone requires specific validation checkpoints that verify correct implementation before proceeding to subsequent phases. These checkpoints combine automated testing with manual verification to ensure that foundational components work correctly before adding additional complexity.\n\n**Milestone validation provides confidence gates** that prevent cascading failures where issues in early milestones cause confusing symptoms in later development phases. By establishing clear success criteria for each milestone, developers can focus on one set of challenges at a time while building incrementally toward a complete operator implementation.\n\nThe validation checkpoints include both positive testing that verifies expected behavior and negative testing that confirms appropriate error handling. Each checkpoint also includes performance expectations and operational characteristics that should be observable during testing.\n\n### Milestone 1: Custom Resource Definition Validation\n\nThe first milestone focuses on validating that custom resource definitions are properly configured with appropriate schema validation, status subresources, and versioning support. These foundational elements must work correctly before controller implementation begins.\n\n| Validation Check | Expected Behavior | Verification Method |\n|------------------|-------------------|---------------------|\n| CRD Installation | CRD appears in cluster and accepts valid resources | `kubectl get crd databases.example.com` |\n| Schema Validation | Invalid resources are rejected with clear error messages | `kubectl apply` with invalid YAML |\n| Status Subresource | Status updates don't affect spec fields | Separate `kubectl patch` operations |\n| Printer Columns | Custom columns appear in `kubectl get` output | `kubectl get databases` shows custom fields |\n| OpenAPI Integration | API discovery includes CRD schema information | `kubectl explain database.spec` |\n| Multiple Versions | Both v1alpha1 and v1beta1 versions are accepted | Create resources with different apiVersions |\n\n**Schema validation testing** involves creating `Database` resources with various invalid configurations and verifying that the API server rejects them with helpful error messages. Tests should cover missing required fields, invalid enum values, and constraint violations like negative replica counts.\n\n**Status subresource testing** confirms that status updates operate independently from spec modifications. This involves patching status fields directly and verifying that the resource generation field doesn't increment, indicating that spec changes and status updates are properly isolated.\n\n**Version conversion testing** creates resources using older API versions and verifies that they can be retrieved using newer versions, with appropriate field mapping and default value injection occurring during conversion.\n\n### Milestone 2: Controller Setup Validation\n\nThe second milestone validates that the controller infrastructure is properly configured with working client connections, informer caches, and work queue processing. These components must function correctly before implementing reconciliation logic.\n\n| Validation Check | Expected Behavior | Verification Method |\n|------------------|-------------------|---------------------|\n| Client Connection | Controller can list and watch custom resources | Log messages show successful connection |\n| Informer Startup | Informer cache synchronizes with API server state | Ready condition in manager status |\n| Event Processing | Resource changes trigger work queue entries | Debug logs show enqueued reconciliation requests |\n| Worker Goroutines | Multiple reconciliation requests process concurrently | Concurrent processing visible in logs |\n| Leader Election | Only one controller replica processes events | Multiple replicas with one active leader |\n| RBAC Permissions | Controller can read, create, update, and delete required resources | No permission denied errors |\n\n**Client functionality testing** creates, updates, and deletes resources using the controller's Kubernetes client to verify that authentication and authorization work correctly. This includes testing both cached reads through informers and direct API calls for write operations.\n\n**Informer behavior testing** creates resources outside the controller and verifies that informer caches reflect changes within reasonable time periods. Tests should also verify that informer resync operations occur at configured intervals.\n\n**Work queue testing** triggers rapid resource changes and verifies that work queue processing handles the load without dropping events or creating excessive goroutines. Rate limiting behavior should be observable during high-frequency updates.\n\n### Milestone 3: Reconciliation Loop Validation\n\nThe third milestone validates that reconciliation logic correctly compares desired versus actual state and takes appropriate corrective actions. This represents the core operator functionality and requires comprehensive testing across various scenarios.\n\n| Validation Check | Expected Behavior | Verification Method |\n|------------------|-------------------|---------------------|\n| Resource Creation | New Database resources trigger owned resource creation | Deployment and Service objects appear |\n| Resource Updates | Spec changes propagate to owned resources | Modified owned resources match new spec |\n| Resource Deletion | Finalizer processing cleans up owned resources | Owned resources deleted before Database removal |\n| Status Updates | Status reflects current reconciliation state | Conditions indicate progress and completion |\n| Error Handling | Reconciliation failures update status appropriately | Error conditions with diagnostic messages |\n| Idempotent Operations | Repeated reconciliation produces identical results | Multiple reconcile calls show no changes |\n\n**State comparison testing** modifies owned resources directly and verifies that the controller detects differences and restores desired state. This includes testing configuration drift scenarios where external processes modify controller-managed resources.\n\n**Reconciliation timing testing** measures how quickly controllers detect changes and complete reconciliation cycles. Response times should be consistent and appropriate for the complexity of managed resources.\n\n**Error recovery testing** introduces various failure conditions and verifies that controllers handle them gracefully with appropriate status reporting and retry behavior. This includes testing API server unavailability, resource conflicts, and invalid configurations.\n\n### Milestone 4: Webhook Validation\n\nThe fourth milestone validates that admission webhooks correctly validate and mutate resources according to business rules and policy requirements. Webhook behavior must be thoroughly tested because admission failures can prevent resource creation entirely.\n\n| Validation Check | Expected Behavior | Verification Method |\n|------------------|-------------------|---------------------|\n| Webhook Registration | Admission webhook configurations appear in cluster | `kubectl get validatingwebhookconfiguration` |\n| TLS Certificate Setup | Webhook server accepts HTTPS connections | Certificate validation in server logs |\n| Validation Logic | Invalid resources are rejected with clear messages | `kubectl apply` with policy violations |\n| Mutation Logic | Default values are injected into new resources | Compare applied vs original resource content |\n| Webhook Availability | Admission processing continues during webhook updates | No service disruption during deployment |\n| Error Responses | Admission failures include actionable error messages | Clear feedback about validation failures |\n\n**Validation testing** attempts to create resources that violate business rules and verifies that webhooks reject them with informative error messages. Tests should cover both simple field validation and complex cross-field business logic.\n\n**Mutation testing** creates resources with minimal specifications and verifies that webhooks inject appropriate default values and computed fields. The resulting resources should be valid and functionally complete.\n\n**Certificate management testing** verifies that webhook certificates are properly provisioned, renewed before expiration, and updated without service disruption. This includes testing both cert-manager integration and manual certificate management approaches.\n\n### Milestone 5: Testing and Deployment Validation\n\nThe final milestone validates that the complete operator functions correctly in production-like environments with proper security configuration, monitoring integration, and operational procedures. This comprehensive validation ensures that the operator is ready for production deployment.\n\n| Validation Check | Expected Behavior | Verification Method |\n|------------------|-------------------|---------------------|\n| Unit Test Coverage | All reconciliation paths have comprehensive test coverage | Code coverage reports show >80% coverage |\n| Integration Tests | End-to-end scenarios pass consistently | Automated test suite passes in CI |\n| Container Image Build | Operator image builds successfully with proper labeling | `docker build` produces tagged image |\n| RBAC Configuration | Deployed operator has minimal required permissions | Security audit of ClusterRole permissions |\n| High Availability | Multiple operator replicas with leader election work correctly | Pod failures don't interrupt reconciliation |\n| Monitoring Integration | Metrics and logs provide operational visibility | Prometheus metrics and structured logs |\n\n**End-to-end testing** deploys the operator to test clusters and validates that complete user workflows function correctly from resource creation through deletion. These tests should simulate real user interactions and verify that all features work together seamlessly.\n\n**Production readiness testing** evaluates the operator under production-like conditions including resource constraints, network partitions, and concurrent user activity. These tests identify potential issues that might not appear under ideal testing conditions.\n\n**Operational testing** verifies that administrative procedures like operator upgrades, certificate rotation, and backup/restore operations work correctly without disrupting managed applications.\n\n### Common Milestone Validation Pitfalls\n\n⚠️ **Pitfall: Skipping Negative Testing**\n\nMany validation checkpoints focus only on verifying that expected behaviors work correctly while ignoring error conditions and edge cases. Production environments frequently encounter unexpected inputs, network failures, and resource constraints that can expose untested code paths. Comprehensive validation requires testing both success and failure scenarios at each milestone.\n\n⚠️ **Pitfall: Not Testing Real-World Conditions**\n\nValidation that works in clean, isolated test environments may fail when deployed to production clusters with existing workloads, resource quotas, and security policies. Effective milestone validation should include testing under conditions that approximate production environments, including limited resources and competing workloads.\n\n⚠️ **Pitfall: Insufficient Soak Testing**\n\nMany operators that pass short-duration tests exhibit issues like memory leaks, performance degradation, or state corruption over longer periods. Milestone validation should include extended testing periods that allow time-dependent issues to manifest, particularly for controllers that process high event volumes.\n\n⚠️ **Pitfall: Not Validating User Experience**\n\nTechnical validation often focuses on internal correctness while ignoring the user experience aspects like error message clarity, documentation accuracy, and operational complexity. Production operators must provide excellent user experiences, requiring validation that includes usability testing from the perspective of actual users.\n\n### Implementation Guidance\n\nThis subsection provides practical implementation details for building comprehensive testing infrastructure that supports effective operator development and validation.\n\n#### Technology Recommendations\n\n| Testing Component | Simple Option | Advanced Option |\n|-------------------|---------------|-----------------|\n| Unit Testing Framework | Go's built-in `testing` package | Ginkgo + Gomega for BDD-style testing |\n| Integration Testing | controller-runtime's `envtest` package | Kind clusters for full Kubernetes features |\n| Mock Generation | Manual fake implementations | `go generate` with `counterfeiter` or `gomock` |\n| Test Data Management | Hard-coded YAML strings | External YAML files with template processing |\n| Assertion Library | Basic Go comparisons | `testify/assert` for rich assertion methods |\n| Coverage Analysis | `go test -cover` built-in coverage | `gocov` + `gocov-html` for detailed reports |\n\n#### Recommended File Structure\n\n```\nproject-root/\n  controllers/\n    database_controller.go           ← main controller implementation\n    database_controller_test.go      ← unit tests with fake client\n    suite_test.go                    ← integration test suite setup\n  webhooks/\n    database_webhook.go              ← admission webhook implementation\n    database_webhook_test.go         ← unit tests for webhook logic\n    webhook_suite_test.go            ← integration tests with envtest\n  testdata/\n    valid-database.yaml              ← test resource manifests\n    invalid-database.yaml            ← resources for validation testing\n    webhook-certificates/            ← test TLS certificates\n      tls.crt\n      tls.key\n  hack/\n    setup-envtest.sh                 ← script to install envtest binaries\n    run-integration-tests.sh         ← script for CI integration testing\n```\n\n#### Complete Unit Testing Infrastructure\n\nThis infrastructure provides a complete foundation for unit testing with fake clients:\n\n```go\n// controllers/suite_test.go - Complete unit test setup\npackage controllers\n\nimport (\n    \"context\"\n    \"path/filepath\"\n    \"testing\"\n    \"time\"\n\n    . \"github.com/onsi/ginkgo/v2\"\n    . \"github.com/onsi/gomega\"\n    \n    corev1 \"k8s.io/api/core/v1\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/apimachinery/pkg/runtime\"\n    \"k8s.io/client-go/kubernetes/scheme\"\n    \"sigs.k8s.io/controller-runtime/pkg/client\"\n    \"sigs.k8s.io/controller-runtime/pkg/client/fake\"\n    \"sigs.k8s.io/controller-runtime/pkg/envtest\"\n    \"sigs.k8s.io/controller-runtime/pkg/log/zap\"\n    ctrl \"sigs.k8s.io/controller-runtime\"\n    \n    examplev1 \"github.com/example/database-operator/api/v1\"\n)\n\nvar (\n    k8sClient client.Client\n    testEnv   *envtest.Environment\n    ctx       context.Context\n    cancel    context.CancelFunc\n)\n\nfunc TestControllers(t *testing.T) {\n    RegisterFailHandler(Fail)\n    RunSpecs(t, \"Controller Suite\")\n}\n\nvar _ = BeforeSuite(func() {\n    ctrl.SetLogger(zap.New(zap.WriteTo(GinkgoWriter), zap.UseDevMode(true)))\n\n    ctx, cancel = context.WithCancel(context.Background())\n\n    By(\"bootstrapping test environment\")\n    testEnv = &envtest.Environment{\n        CRDDirectoryPaths:     []string{filepath.Join(\"..\", \"config\", \"crd\", \"bases\")},\n        ErrorIfCRDPathMissing: true,\n    }\n\n    cfg, err := testEnv.Start()\n    Expect(err).NotTo(HaveOccurred())\n    Expect(cfg).NotTo(BeNil())\n\n    err = examplev1.AddToScheme(scheme.Scheme)\n    Expect(err).NotTo(HaveOccurred())\n\n    k8sClient, err = client.New(cfg, client.Options{Scheme: scheme.Scheme})\n    Expect(err).NotTo(HaveOccurred())\n    Expect(k8sClient).NotTo(BeNil())\n})\n\nvar _ = AfterSuite(func() {\n    cancel()\n    By(\"tearing down the test environment\")\n    err := testEnv.Stop()\n    Expect(err).NotTo(HaveOccurred())\n})\n\n// Test helper functions\nfunc CreateTestNamespace() *corev1.Namespace {\n    ns := &corev1.Namespace{\n        ObjectMeta: metav1.ObjectMeta{\n            GenerateName: \"test-\",\n        },\n    }\n    Expect(k8sClient.Create(ctx, ns)).To(Succeed())\n    return ns\n}\n\nfunc CreateTestDatabase(namespace, name string) *examplev1.Database {\n    db := &examplev1.Database{\n        ObjectMeta: metav1.ObjectMeta{\n            Name:      name,\n            Namespace: namespace,\n        },\n        Spec: examplev1.DatabaseSpec{\n            Replicas:    3,\n            Version:     \"13.0\",\n            StorageSize: \"10Gi\",\n        },\n    }\n    Expect(k8sClient.Create(ctx, db)).To(Succeed())\n    return db\n}\n```\n\n#### Core Reconciliation Test Skeleton\n\nThis skeleton provides the structure for comprehensive reconciliation testing:\n\n```go\n// controllers/database_controller_test.go - Reconciliation test template\npackage controllers\n\nimport (\n    . \"github.com/onsi/ginkgo/v2\"\n    . \"github.com/onsi/gomega\"\n    \n    corev1 \"k8s.io/api/core/v1\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/apimachinery/pkg/types\"\n    ctrl \"sigs.k8s.io/controller-runtime\"\n    \"sigs.k8s.io/controller-runtime/pkg/client/fake\"\n    \n    examplev1 \"github.com/example/database-operator/api/v1\"\n)\n\nvar _ = Describe(\"Database Controller\", func() {\n    var (\n        reconciler *DatabaseReconciler\n        namespace  *corev1.Namespace\n        database   *examplev1.Database\n    )\n\n    BeforeEach(func() {\n        namespace = CreateTestNamespace()\n        reconciler = &DatabaseReconciler{\n            Client: k8sClient,\n            Scheme: scheme.Scheme,\n        }\n    })\n\n    Context(\"When creating a new Database\", func() {\n        BeforeEach(func() {\n            database = CreateTestDatabase(namespace.Name, \"test-db\")\n        })\n\n        It(\"Should create owned resources successfully\", func() {\n            // TODO: Call reconciler.Reconcile() with appropriate request\n            // TODO: Verify that Deployment and Service resources are created\n            // TODO: Check that owner references are set correctly\n            // TODO: Validate that finalizers are added to the Database resource\n            // TODO: Confirm that status conditions indicate successful creation\n        })\n\n        It(\"Should handle missing namespace gracefully\", func() {\n            // TODO: Delete the namespace before reconciliation\n            // TODO: Call reconciler.Reconcile() and expect appropriate error handling\n            // TODO: Verify that status conditions indicate the error state\n            // TODO: Confirm that no owned resources are created in invalid state\n        })\n    })\n\n    Context(\"When updating an existing Database\", func() {\n        BeforeEach(func() {\n            database = CreateTestDatabase(namespace.Name, \"test-db\")\n            // TODO: Wait for initial reconciliation to complete\n            // TODO: Verify that owned resources exist and are ready\n        })\n\n        It(\"Should propagate spec changes to owned resources\", func() {\n            // TODO: Update database spec (e.g., change replica count)\n            // TODO: Call reconciler.Reconcile() with update event\n            // TODO: Verify that owned Deployment reflects new replica count\n            // TODO: Check that status indicates progressing state during update\n            // TODO: Confirm that ready condition updates after completion\n        })\n\n        It(\"Should detect and correct configuration drift\", func() {\n            // TODO: Manually modify an owned resource (e.g., change Deployment image)\n            // TODO: Call reconciler.Reconcile() to trigger drift detection\n            // TODO: Verify that controller restores correct configuration\n            // TODO: Check that no unnecessary updates occur for correct resources\n        })\n    })\n\n    Context(\"When deleting a Database\", func() {\n        BeforeEach(func() {\n            database = CreateTestDatabase(namespace.Name, \"test-db\")\n            // TODO: Wait for reconciliation to create owned resources\n            // TODO: Set deletion timestamp on database resource\n        })\n\n        It(\"Should clean up owned resources before finalizer removal\", func() {\n            // TODO: Call reconciler.Reconcile() with deletion event\n            // TODO: Verify that owned resources are deleted\n            // TODO: Check that finalizers remain until cleanup completes\n            // TODO: Confirm finalizer removal after successful cleanup\n        })\n\n        It(\"Should handle cleanup failures gracefully\", func() {\n            // TODO: Configure fake client to return errors for delete operations\n            // TODO: Call reconciler.Reconcile() and expect error result\n            // TODO: Verify that finalizers are not removed on cleanup failure\n            // TODO: Check that status conditions indicate cleanup error\n        })\n    })\n})\n```\n\n#### Integration Testing with Controller Manager\n\nThis template demonstrates full integration testing with running controllers:\n\n```go\n// controllers/integration_test.go - Full integration test template\npackage controllers\n\nimport (\n    \"time\"\n\n    . \"github.com/onsi/ginkgo/v2\"\n    . \"github.com/onsi/gomega\"\n    \n    appsv1 \"k8s.io/api/apps/v1\"\n    corev1 \"k8s.io/api/core/v1\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/apimachinery/pkg/types\"\n    ctrl \"sigs.k8s.io/controller-runtime\"\n    \n    examplev1 \"github.com/example/database-operator/api/v1\"\n)\n\nvar _ = Describe(\"Database Integration\", func() {\n    var (\n        mgr       ctrl.Manager\n        namespace *corev1.Namespace\n        database  *examplev1.Database\n    )\n\n    BeforeEach(func() {\n        var err error\n        mgr, err = ctrl.NewManager(cfg, ctrl.Options{\n            Scheme: scheme.Scheme,\n            Port:   9443, // webhook port\n        })\n        Expect(err).ToNot(HaveOccurred())\n\n        reconciler := &DatabaseReconciler{\n            Client: mgr.GetClient(),\n            Scheme: mgr.GetScheme(),\n        }\n        \n        err = reconciler.SetupWithManager(mgr)\n        Expect(err).ToNot(HaveOccurred())\n\n        go func() {\n            defer GinkgoRecover()\n            err = mgr.Start(ctx)\n            Expect(err).ToNot(HaveOccurred(), \"failed to run manager\")\n        }()\n\n        namespace = CreateTestNamespace()\n    })\n\n    It(\"Should reconcile Database resources end-to-end\", func() {\n        By(\"Creating a Database resource\")\n        database = &examplev1.Database{\n            ObjectMeta: metav1.ObjectMeta{\n                Name:      \"integration-test-db\",\n                Namespace: namespace.Name,\n            },\n            Spec: examplev1.DatabaseSpec{\n                Replicas:    2,\n                Version:     \"13.0\",\n                StorageSize: \"5Gi\",\n            },\n        }\n        Expect(k8sClient.Create(ctx, database)).To(Succeed())\n\n        By(\"Waiting for owned resources to be created\")\n        deployment := &appsv1.Deployment{}\n        Eventually(func() error {\n            return k8sClient.Get(ctx, types.NamespacedName{\n                Name:      database.Name,\n                Namespace: database.Namespace,\n            }, deployment)\n        }, time.Minute, time.Second).Should(Succeed())\n\n        By(\"Verifying Deployment configuration\")\n        Expect(deployment.Spec.Replicas).To(Equal(int32Ptr(2)))\n        Expect(deployment.OwnerReferences).To(HaveLen(1))\n        Expect(deployment.OwnerReferences[0].Name).To(Equal(database.Name))\n\n        By(\"Waiting for Database status to indicate readiness\")\n        Eventually(func() bool {\n            err := k8sClient.Get(ctx, types.NamespacedName{\n                Name:      database.Name,\n                Namespace: database.Namespace,\n            }, database)\n            if err != nil {\n                return false\n            }\n            return database.Status.Phase == \"Ready\"\n        }, time.Minute, time.Second).Should(BeTrue())\n    })\n})\n\nfunc int32Ptr(i int32) *int32 {\n    return &i\n}\n```\n\n#### Webhook Testing Infrastructure\n\nThis infrastructure enables comprehensive webhook testing:\n\n```go\n// webhooks/webhook_suite_test.go - Webhook testing setup\npackage webhooks\n\nimport (\n    \"context\"\n    \"crypto/tls\"\n    \"fmt\"\n    \"net\"\n    \"path/filepath\"\n    \"testing\"\n    \"time\"\n\n    . \"github.com/onsi/ginkgo/v2\"\n    . \"github.com/onsi/gomega\"\n\n    admissionv1 \"k8s.io/api/admission/v1\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/apimachinery/pkg/runtime\"\n    \"k8s.io/client-go/kubernetes/scheme\"\n    ctrl \"sigs.k8s.io/controller-runtime\"\n    \"sigs.k8s.io/controller-runtime/pkg/client\"\n    \"sigs.k8s.io/controller-runtime/pkg/envtest\"\n    \"sigs.k8s.io/controller-runtime/pkg/webhook\"\n    \"sigs.k8s.io/controller-runtime/pkg/webhook/admission\"\n\n    examplev1 \"github.com/example/database-operator/api/v1\"\n)\n\nvar (\n    k8sClient client.Client\n    testEnv   *envtest.Environment\n    ctx       context.Context\n    cancel    context.CancelFunc\n)\n\nfunc TestWebhooks(t *testing.T) {\n    RegisterFailHandler(Fail)\n    RunSpecs(t, \"Webhook Suite\")\n}\n\nvar _ = BeforeSuite(func() {\n    ctx, cancel = context.WithCancel(context.Background())\n\n    By(\"bootstrapping test environment\")\n    testEnv = &envtest.Environment{\n        CRDDirectoryPaths:     []string{filepath.Join(\"..\", \"config\", \"crd\", \"bases\")},\n        ErrorIfCRDPathMissing: true,\n        WebhookInstallOptions: envtest.WebhookInstallOptions{\n            Paths: []string{filepath.Join(\"..\", \"config\", \"webhook\")},\n        },\n    }\n\n    cfg, err := testEnv.Start()\n    Expect(err).NotTo(HaveOccurred())\n    Expect(cfg).NotTo(BeNil())\n\n    err = examplev1.AddToScheme(scheme.Scheme)\n    Expect(err).NotTo(HaveOccurred())\n\n    k8sClient, err = client.New(cfg, client.Options{Scheme: scheme.Scheme})\n    Expect(err).NotTo(HaveOccurred())\n\n    // Start webhook server\n    webhookInstallOptions := &testEnv.WebhookInstallOptions\n    mgr, err := ctrl.NewManager(cfg, ctrl.Options{\n        Scheme:             scheme.Scheme,\n        Host:               webhookInstallOptions.LocalServingHost,\n        Port:               webhookInstallOptions.LocalServingPort,\n        CertDir:            webhookInstallOptions.LocalServingCertDir,\n        LeaderElection:     false,\n        MetricsBindAddress: \"0\",\n    })\n    Expect(err).NotTo(HaveOccurred())\n\n    // TODO: Setup webhook handlers with manager\n    // TODO: Start manager in goroutine\n})\n\nvar _ = AfterSuite(func() {\n    cancel()\n    By(\"tearing down the test environment\")\n    err := testEnv.Stop()\n    Expect(err).NotTo(HaveOccurred())\n})\n```\n\n#### Milestone Validation Checkpoints\n\nEach milestone includes specific commands and expected outputs for validation:\n\n**Milestone 1 Checkpoint Commands:**\n```bash\n# Verify CRD installation\nkubectl get crd databases.example.com -o yaml\n\n# Test schema validation\nkubectl apply -f testdata/invalid-database.yaml\n# Expected: validation error with specific field requirements\n\n# Test status subresource\nkubectl patch database test-db --subresource=status --type=merge -p='{\"status\":{\"phase\":\"Testing\"}}'\n# Expected: status updated without spec generation increment\n```\n\n**Milestone 2 Checkpoint Commands:**\n```bash\n# Start controller with debug logging\ngo run ./cmd/main.go --zap-log-level=debug\n\n# Create test resource and watch logs\nkubectl apply -f testdata/valid-database.yaml\n# Expected: reconciliation request logged within 5 seconds\n\n# Test concurrent processing\nfor i in {1..10}; do kubectl apply -f testdata/database-$i.yaml; done\n# Expected: multiple concurrent reconciliation logs\n```\n\n**Language-Specific Testing Hints:**\n\n- Use `testify/suite` for complex test setup with BeforeTest/AfterTest hooks\n- Leverage `t.Parallel()` for unit tests that don't share state\n- Use `go test -race` to detect race conditions in controller code\n- Configure `KUBEBUILDER_ASSETS` environment variable for envtest binary location\n- Use `Eventually()` and `Consistently()` from Gomega for asynchronous assertions\n- Mock external dependencies using `testify/mock` or `counterfeiter`\n- Use `t.Helper()` in test utility functions to improve error reporting\n- Configure test timeouts appropriately: unit tests 10s, integration tests 60s\n\n**Common Debugging Scenarios:**\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---------|--------------|-----------|-----|\n| Unit tests panic with \"no kind is registered\" | Missing scheme registration | Check fake client scheme setup | Add all CRDs to scheme.Scheme |\n| Integration tests timeout waiting for resources | Controller not running or not watching | Check manager startup and controller registration | Verify SetupWithManager() call |\n| Webhook tests fail with certificate errors | TLS configuration incorrect | Check certificate paths and validity | Regenerate test certificates |\n| Tests pass individually but fail in suite | Resource cleanup between tests | Check for resource leakage | Add proper cleanup in AfterEach |\n| Flaky test failures in CI | Race conditions or insufficient timeouts | Increase timeout values and add synchronization | Use Eventually() with longer durations |\n\n\n## Deployment and Operations\n\n> **Milestone(s):** Milestone 5 (Testing & Deployment) - covers packaging the operator as container images, RBAC configuration, and production deployment strategies\n\nMoving a Kubernetes operator from development to production requires careful attention to security, packaging, and operational concerns. Think of deploying an operator like installing a new resident admin in your apartment building - they need the right keys (RBAC permissions), their own secure apartment (container packaging), and a backup admin available if they get sick (high availability). Unlike regular applications that just process requests, operators have elevated privileges to manage cluster resources, making security and reliability critical considerations.\n\nThe deployment phase transforms your operator from a development artifact into a production-ready service that can safely manage workloads at scale. This involves three key challenges: ensuring the operator has exactly the permissions it needs and no more (RBAC), packaging it as a container with proper configuration management (container packaging), and ensuring it remains available even during node failures or rolling updates (high availability).\n\n![Production Deployment Architecture](./diagrams/deployment-architecture.svg)\n\n### RBAC and Security Model\n\n**Mental Model: The Building Superintendent's Keys**\n\nThink of Kubernetes RBAC like a building superintendent's key ring. A good superintendent has keys to common areas (cluster-scoped resources) and individual apartments they manage (namespace-scoped resources), but they don't have keys to the bank vault next door (unrelated cluster resources) or other buildings entirely (other clusters). Each key serves a specific purpose, and losing or misusing any key has clear consequences. Your operator needs exactly the right keys to do its job effectively without creating security risks.\n\nThe **principle of least privilege** governs operator RBAC design. Rather than granting broad permissions like `cluster-admin`, operators should receive only the specific permissions required for their reconciliation logic. This approach limits the blast radius if the operator is compromised and makes security auditing more straightforward.\n\n> **Decision: Namespace-Scoped vs Cluster-Scoped Permissions**\n> - **Context**: Operators can be deployed with cluster-wide permissions or restricted to specific namespaces\n> - **Options Considered**: \n>   1. Cluster-scoped with ClusterRole and ClusterRoleBinding\n>   2. Namespace-scoped with Role and RoleBinding\n>   3. Hybrid approach with multiple permission levels\n> - **Decision**: Start with namespace-scoped permissions and escalate to cluster-scoped only when required\n> - **Rationale**: Namespace-scoped permissions provide better security isolation, easier multi-tenancy, and clearer audit trails. Many operators only need to manage resources within specific namespaces.\n> - **Consequences**: Requires more complex permission modeling for cross-namespace operations but provides stronger security boundaries\n\n| Permission Scope | Resource Types | Use Cases | Security Trade-offs |\n|-----------------|----------------|-----------|-------------------|\n| Cluster-scoped | ClusterRole, ClusterRoleBinding, CRDs | Managing cluster-wide resources, cross-namespace operations | Broad permissions, single point of failure, harder to audit |\n| Namespace-scoped | Role, RoleBinding within target namespaces | Application-specific operators, multi-tenant environments | Limited blast radius, easier isolation, more complex setup |\n| Hybrid | Multiple roles with different scopes | Operators managing both namespace and cluster resources | Balanced approach, requires careful permission design |\n\nThe `DatabaseReconciler` requires specific permissions to manage its custom resources and owned Kubernetes resources. These permissions are defined through a combination of RBAC resources that work together to grant the operator's ServiceAccount the necessary access.\n\n| RBAC Component | Purpose | Scope | Example Resource |\n|---------------|---------|-------|------------------|\n| ServiceAccount | Identity for operator pods | Namespace | `database-operator-service-account` |\n| Role/ClusterRole | Permission definitions | Namespace/Cluster | Rules for Database CRD, Secrets, Services |\n| RoleBinding/ClusterRoleBinding | Links ServiceAccount to permissions | Namespace/Cluster | Grants operator ServiceAccount the defined roles |\n\n#### Core Permission Requirements\n\nThe `DatabaseReconciler` needs specific permissions to perform its reconciliation duties. These permissions should be carefully scoped to prevent privilege escalation while enabling full operator functionality.\n\n| Resource Type | Operations Needed | Justification | Example Usage |\n|---------------|------------------|---------------|---------------|\n| `databases.example.com` | get, list, watch, update, patch | Monitor custom resources and update status | Watch Database resource changes, update status subresource |\n| `secrets` | get, list, watch, create, update, patch, delete | Manage database credentials and TLS certificates | Create admin passwords, manage backup encryption keys |\n| `services` | get, list, watch, create, update, patch, delete | Expose database instances | Create ClusterIP services for database connectivity |\n| `deployments` | get, list, watch, create, update, patch, delete | Manage database workloads | Deploy database pods with specified replica counts |\n| `persistentvolumeclaims` | get, list, watch, create, update, patch, delete | Manage database storage | Provision storage volumes for database data |\n| `configmaps` | get, list, watch, create, update, patch, delete | Manage database configuration | Store database config files, backup scripts |\n| `events` | create, patch | Record operator activities | Log reconciliation events for debugging |\n\n> The critical insight here is that every permission must map to a specific reconciliation action. If you cannot explain why the operator needs a particular permission by pointing to specific reconciliation logic, that permission should be removed.\n\n#### Owner References and Garbage Collection\n\nOwner references establish parent-child relationships between custom resources and their managed Kubernetes resources. This mechanism enables automatic garbage collection when custom resources are deleted, reducing the operator's cleanup burden and preventing resource leaks.\n\n| Owner Reference Field | Purpose | Example Value | Behavior on Deletion |\n|-----------------------|---------|---------------|---------------------|\n| `apiVersion` | API version of parent resource | `example.com/v1` | Links to specific API version |\n| `kind` | Resource type of parent | `Database` | Identifies parent resource type |\n| `name` | Name of parent resource | `production-postgres` | Links to specific resource instance |\n| `uid` | Unique identifier of parent | `abc123-def456-...` | Ensures precise parent identification |\n| `controller` | Indicates controlling owner | `true` | Triggers cascading deletion |\n| `blockOwnerDeletion` | Blocks parent deletion until child is removed | `false` | Allows graceful cleanup ordering |\n\n⚠️ **Pitfall: Missing Owner References Leading to Resource Leaks**\n\nForgetting to set owner references on managed resources causes them to persist after the custom resource is deleted. This creates orphaned resources that consume cluster capacity and complicate cleanup. Always set owner references when creating managed resources, and verify garbage collection behavior in your tests.\n\n```go\n// WRONG: Creating resource without owner reference\nservice := &corev1.Service{...}\nerr := r.Client.Create(ctx, service)\n\n// CORRECT: Setting owner reference for garbage collection\nservice := &corev1.Service{...}\nerr := ctrl.SetControllerReference(database, service, r.Scheme)\nif err != nil {\n    return ctrl.Result{}, err\n}\nerr = r.Client.Create(ctx, service)\n```\n\n#### Webhook RBAC Requirements\n\nAdmission webhooks require additional RBAC permissions beyond the controller's reconciliation needs. These permissions enable webhook registration, certificate management, and admission review processing.\n\n| Webhook Component | Required Permissions | Resource Types | Justification |\n|-------------------|---------------------|----------------|---------------|\n| ValidatingAdmissionWebhook registration | create, update, patch | `validatingadmissionwebhooks.admissionregistration.k8s.io` | Register webhook with API server |\n| MutatingAdmissionWebhook registration | create, update, patch | `mutatingadmissionwebhooks.admissionregistration.k8s.io` | Register webhook with API server |\n| Certificate management | get, list, watch, create, update | `secrets` (for TLS certificates) | Manage webhook TLS certificates |\n| Service management | get, list, watch, create, update | `services` (for webhook endpoints) | Expose webhook HTTPS endpoints |\n\n> **Decision: Webhook Certificate Management Strategy**\n> - **Context**: Webhooks require TLS certificates for HTTPS communication with the API server\n> - **Options Considered**:\n>   1. Self-signed certificates generated at startup\n>   2. cert-manager for automatic certificate lifecycle management\n>   3. External certificate authority with manual certificate provision\n> - **Decision**: Use cert-manager for production deployments with self-signed fallback for development\n> - **Rationale**: cert-manager provides automatic renewal, proper CA trust chains, and integrates well with Kubernetes RBAC. Self-signed certificates work for development but require manual rotation in production.\n> - **Consequences**: Adds cert-manager dependency but eliminates certificate management toil and reduces security risks from expired certificates\n\n### Container Packaging and Deployment\n\n**Mental Model: The Shipping Container**\n\nThink of packaging your operator like preparing a shipping container for international transport. The container must be self-contained with all dependencies included, properly labeled with version and contents, and standardized so it runs the same way whether deployed in development, staging, or production. Like shipping containers, operator images should be immutable, versioned, and contain everything needed to run in any compliant Kubernetes cluster.\n\nContainer packaging transforms your operator from source code into a deployable artifact that can be distributed, versioned, and deployed consistently across environments. This process involves building container images, organizing deployment manifests, and creating configuration management systems that handle environment-specific variations.\n\n#### Container Image Strategy\n\nThe operator container image serves as the fundamental deployment unit, containing the compiled binary, runtime dependencies, and configuration templates. Image design affects security, deployment speed, and operational complexity.\n\n| Image Characteristic | Development Approach | Production Approach | Trade-offs |\n|---------------------|----------------------|-------------------|------------|\n| Base image | Full OS (ubuntu, centos) | Minimal (alpine, distroless) | Debug tools vs. attack surface |\n| Binary packaging | Debug builds with symbols | Optimized builds stripped | Debugging capability vs. image size |\n| Dependency management | Package manager installs | Multi-stage builds | Build simplicity vs. reproducibility |\n| User permissions | Root user | Non-root user | Convenience vs. security |\n| Layer optimization | Single layer builds | Multi-stage with layer caching | Build speed vs. image efficiency |\n\n> **Decision: Multi-Stage Build with Distroless Base Image**\n> - **Context**: Operator images need to be secure, small, and fast to deploy while containing all required dependencies\n> - **Options Considered**:\n>   1. Single-stage build with full OS base image\n>   2. Multi-stage build with minimal base image\n>   3. Scratch base image with static binary\n> - **Decision**: Multi-stage build with Google's distroless base image\n> - **Rationale**: Distroless images contain only the application and runtime dependencies, reducing attack surface while maintaining compatibility. Multi-stage builds separate build dependencies from runtime dependencies.\n> - **Consequences**: Smaller image size, improved security posture, but more complex Dockerfile and potential debugging challenges\n\nThe operator container requires careful dependency management to ensure consistent behavior across environments. All required certificates, configuration schemas, and runtime dependencies must be included in the image or mounted at runtime.\n\n| Container Component | Purpose | Location | Management Strategy |\n|--------------------|---------|----------|-------------------|\n| Operator binary | Main application executable | `/usr/local/bin/operator` | Compiled during image build |\n| CA certificates | TLS certificate validation | `/etc/ssl/certs/` | Included in base image or mounted |\n| CRD schemas | OpenAPI validation schemas | `/etc/operator/crds/` | Embedded in image or mounted as ConfigMap |\n| Default configurations | Fallback operator settings | `/etc/operator/config/` | Embedded with environment variable overrides |\n| Health check scripts | Liveness and readiness probes | `/usr/local/bin/health` | Embedded shell scripts or HTTP endpoints |\n\n#### Helm Chart Organization\n\nHelm charts provide templating and configuration management for operator deployments, enabling environment-specific customization while maintaining consistency across clusters. Chart organization affects maintainability, user experience, and upgrade reliability.\n\n| Chart Component | Purpose | Template Location | Configuration Source |\n|----------------|---------|-------------------|-------------------|\n| Deployment | Operator pod specification | `templates/deployment.yaml` | `values.yaml` replicas, image, resources |\n| RBAC resources | ServiceAccount, Role, RoleBinding | `templates/rbac.yaml` | `values.yaml` rbac.create, serviceAccount.name |\n| CRD definitions | Custom resource schemas | `templates/crds/` | Static files or `values.yaml` schema overrides |\n| Webhook configuration | AdmissionWebhook registration | `templates/webhooks.yaml` | `values.yaml` webhook.enabled, certificate settings |\n| Service definitions | Webhook and metrics endpoints | `templates/services.yaml` | `values.yaml` service ports and types |\n| ConfigMap resources | Operator configuration | `templates/configmap.yaml` | `values.yaml` config section |\n\nThe Helm chart must handle upgrade scenarios gracefully, particularly when CRD schemas change or when webhook configurations are modified. CRD upgrades require special attention because Helm cannot handle CRD lifecycle management automatically.\n\n| Upgrade Scenario | Challenge | Helm Solution | Considerations |\n|------------------|-----------|---------------|---------------|\n| CRD schema changes | Helm doesn't update CRDs automatically | `crds/` directory for install-only, hooks for updates | May require manual `kubectl apply` for CRD updates |\n| Webhook endpoint changes | API server caches webhook configuration | Rolling update with readiness probes | Temporary admission failures during rollout |\n| RBAC permission changes | Existing pods use old ServiceAccount tokens | Restart operator pods after RBAC update | Plan for brief reconciliation pause |\n| Image updates | Container registry authentication | imagePullSecrets configuration | Ensure registry access before update |\n\n> **Decision: Separate CRD Management from Operator Lifecycle**\n> - **Context**: CRDs have different lifecycle requirements than the operator deployment, particularly around upgrades and versioning\n> - **Options Considered**:\n>   1. Include CRDs in Helm chart templates/ directory\n>   2. Use Helm CRDs/ directory for install-only management\n>   3. Separate CRD management with dedicated tooling\n> - **Decision**: Use Helm crds/ directory for installation with separate CRD upgrade procedures\n> - **Rationale**: Helm's CRD handling has limitations around updates, but storing CRDs in the chart ensures they're installed with the operator. Separate upgrade procedures provide better control.\n> - **Consequences**: Requires documented CRD upgrade procedures and coordination between chart updates and CRD changes\n\n#### Environment Configuration Management\n\nOperators must adapt to different environments (development, staging, production) without requiring image rebuilds. Configuration management strategies affect operational complexity, security, and deployment reliability.\n\n| Configuration Source | Use Cases | Examples | Security Considerations |\n|---------------------|-----------|----------|------------------------|\n| Environment variables | Simple runtime settings | Log levels, feature flags, timeouts | Visible in pod specifications and process lists |\n| ConfigMaps | Structured configuration files | JSON/YAML configs, template files | Visible to users with ConfigMap read permissions |\n| Secrets | Sensitive configuration | Database passwords, API keys, certificates | Encrypted at rest, base64 encoded in transit |\n| Command-line flags | Override settings | Debug modes, alternative config paths | Visible in process arguments and pod specs |\n| File mounts | Large configuration files | Custom CRD schemas, policy definitions | Requires volume management and file watching |\n\nConfiguration precedence establishes clear override behavior when multiple sources provide the same setting. A well-defined precedence order prevents configuration conflicts and enables predictable behavior across environments.\n\n| Precedence Level | Configuration Source | Override Scope | Example Usage |\n|-----------------|---------------------|----------------|---------------|\n| 1 (Highest) | Command-line flags | Specific settings for debugging or testing | `--log-level=debug` for development environments |\n| 2 | Environment variables | Runtime overrides for deployment-specific settings | `RECONCILE_TIMEOUT=30s` for slower clusters |\n| 3 | ConfigMap mounted files | Environment-specific structured configuration | Different resource limits per environment |\n| 4 (Lowest) | Built-in defaults | Fallback values when no override is provided | Default replica counts, timeout values |\n\n⚠️ **Pitfall: Sensitive Information in Environment Variables**\n\nAvoid passing sensitive information like passwords or API keys through environment variables, as they're visible in pod specifications, process lists, and kubectl describe output. Use Kubernetes Secrets with volume mounts or the Secrets API instead.\n\n### High Availability and Leader Election\n\n**Mental Model: The Night Shift Manager System**\n\nThink of leader election like managing night shift supervisors at a 24/7 factory. You need multiple qualified supervisors available (multiple operator replicas), but only one should be actively making decisions at any time (leader election). If the active supervisor has an emergency and can't continue (pod failure), another supervisor should immediately take over (leadership transfer) without missing any critical tasks (reconciliation continuity). The transition should be seamless to workers on the factory floor (managed resources).\n\nHigh availability ensures your operator continues managing workloads even during node failures, rolling updates, or unexpected crashes. Unlike stateless applications where you can simply run multiple replicas behind a load balancer, operators require coordination to prevent multiple controllers from conflicting with each other while reconciling the same resources.\n\n#### Leader Election Mechanics\n\nLeader election coordinates multiple operator replicas to ensure only one actively reconciles resources at any time. This coordination prevents race conditions, conflicting updates, and split-brain scenarios where multiple controllers attempt to manage the same resources simultaneously.\n\n| Election Component | Purpose | Storage Location | Update Behavior |\n|-------------------|---------|------------------|-----------------|\n| Lock resource | Stores current leader identity and lease information | ConfigMap or Lease resource | Atomic updates with resource version checking |\n| Leader identity | Identifies which replica currently holds the lock | Lock resource annotations | Pod name and namespace for leader identification |\n| Lease duration | How long a leader can hold the lock without renewal | Lock resource spec | Configurable, typically 15-30 seconds |\n| Renew deadline | How often the leader must update the lock | Controller configuration | Typically lease duration / 3 |\n| Retry period | How often non-leaders check for lock availability | Controller configuration | Typically renew deadline / 2 |\n\nThe leader election algorithm follows a simple but robust protocol that handles network partitions, process crashes, and clock skew gracefully. Understanding this protocol helps debug leadership issues and tune performance for different cluster characteristics.\n\n| Election State | Replica Behavior | Lock Resource Action | Transition Conditions |\n|---------------|------------------|---------------------|----------------------|\n| Startup | Attempt to acquire lock | Read current lock, try to claim if expired | Becomes leader if successful, follower if failed |\n| Leader | Continuously renew lock, perform reconciliation | Update lock resource within renew deadline | Becomes follower if renewal fails |\n| Follower | Watch lock status, attempt takeover if leader fails | Periodically check lock expiration | Becomes leader if lock expires and successfully claimed |\n| Takeover | Attempting to claim expired lock | Atomic update with resource version check | Becomes leader if successful, remains follower if conflict |\n\n> The critical insight here is that leader election provides coordination, not load balancing. Only one replica does the work while others remain on standby, unlike horizontally scaled stateless applications.\n\n#### Leader Election Configuration\n\nProper leader election configuration balances failover speed against cluster load and stability. Aggressive timers provide faster failover but increase API server load and susceptibility to network glitches.\n\n| Configuration Parameter | Conservative Setting | Aggressive Setting | Trade-offs |\n|------------------------|---------------------|-------------------|------------|\n| Lease duration | 60 seconds | 15 seconds | Failover speed vs. stability during network issues |\n| Renew deadline | 20 seconds | 5 seconds | Leader renewal frequency vs. API server load |\n| Retry period | 10 seconds | 2 seconds | Lock acquisition speed vs. election overhead |\n| Lock resource type | ConfigMap | Lease | API server compatibility vs. semantic clarity |\n\n> **Decision: Lease Resources with 15-Second Lease Duration**\n> - **Context**: Leader election requires storage for coordination data and appropriate timing for failover scenarios\n> - **Options Considered**:\n>   1. ConfigMap with 60-second lease duration for conservative failover\n>   2. Lease resource with 15-second lease duration for faster failover\n>   3. Custom resource for lock storage with application-specific timing\n> - **Decision**: Use Kubernetes Lease resources with 15-second lease duration\n> - **Rationale**: Lease resources are designed specifically for leader election, reducing semantic confusion. 15-second duration provides reasonable failover speed without excessive API server load.\n> - **Consequences**: Requires Kubernetes 1.14+ for Lease API availability, but provides optimal balance of failover speed and stability\n\n#### Failover and Recovery Behavior\n\nWhen leadership changes occur, the operator must handle the transition gracefully to maintain reconciliation continuity. Both outgoing and incoming leaders have responsibilities during the transition period.\n\n| Failover Scenario | Detection Mechanism | Recovery Actions | Expected Downtime |\n|------------------|-------------------|------------------|------------------|\n| Graceful shutdown | Leader releases lock before termination | Immediate lock release, follower takeover | 0-2 retry periods |\n| Process crash | Lock renewal timeout | Automatic lock expiration, follower takeover | 1 lease duration + retry period |\n| Network partition | Leader cannot reach API server for renewal | Lock expires, follower on connected side takes over | 1 lease duration + retry period |\n| Node failure | Lock renewal timeout + pod rescheduling | Lock expiration, new pod startup, leadership claim | Pod scheduling time + lease duration |\n\nThe operator must handle leadership transitions without losing reconciliation state or creating resource conflicts. This requires careful design of the reconciliation loop and state management.\n\n| Transition Phase | Leader Responsibilities | Follower Responsibilities | State Considerations |\n|------------------|------------------------|--------------------------|---------------------|\n| Leadership loss | Stop reconciliation immediately, release in-flight operations | Monitor lock status, prepare for takeover | Avoid partial updates that could conflict |\n| Leadership acquisition | Start reconciliation loop, scan for pending work | Continue monitoring for future leadership opportunities | Resume from cluster state, not in-memory state |\n| Steady state | Maintain lock renewal, perform normal reconciliation | Stay ready for immediate takeover | Keep reconciliation idempotent and stateless |\n\n⚠️ **Pitfall: Continuing Reconciliation After Losing Leadership**\n\nA common mistake is failing to stop reconciliation immediately when leadership is lost. This can cause multiple controllers to simultaneously modify the same resources, leading to conflicts, inconsistent state, and resource thrashing. Always check leadership status before performing any write operations.\n\n#### Monitoring and Observability for HA Deployments\n\nHigh availability deployments require additional monitoring to track leadership status, failover events, and replica health. This observability helps diagnose performance issues and verify that failover mechanisms work correctly.\n\n| Metric Category | Key Metrics | Purpose | Alert Conditions |\n|----------------|-------------|---------|------------------|\n| Leadership status | Current leader identity, lease age, renewal success rate | Track which replica is active and leadership stability | No active leader for >lease duration |\n| Failover events | Leadership transitions, takeover frequency, transition duration | Monitor failover reliability and performance | Frequent leadership changes (>1/hour) |\n| Reconciliation health | Reconciliation rate, error rate, queue depth per replica | Verify only leader is working, followers are idle | Non-leader performing reconciliation |\n| Resource utilization | CPU, memory, API server requests per replica | Optimize resource allocation and detect resource leaks | High resource usage on follower replicas |\n\nThe operator should expose Prometheus metrics for leadership status and reconciliation health. These metrics enable alerting on split-brain conditions, failed failovers, and performance degradation.\n\n| Metric Name | Type | Labels | Description |\n|-------------|------|--------|-------------|\n| `operator_leader_election_status` | Gauge | `instance`, `leader` | 1 if this replica is leader, 0 if follower |\n| `operator_leadership_changes_total` | Counter | `instance` | Total number of leadership transitions for this replica |\n| `operator_lease_renewal_duration_seconds` | Histogram | `instance` | Time taken to renew leadership lease |\n| `operator_reconciliation_rate` | Gauge | `instance`, `resource_type` | Number of reconciliations per second (should be 0 for followers) |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Overly Broad RBAC Permissions**\n\nGranting `cluster-admin` or wildcard permissions (`*`) makes security auditing impossible and creates significant security risks. If an operator with broad permissions is compromised, attackers gain access to the entire cluster. Instead, enumerate specific permissions required for each reconciliation action and grant only those permissions.\n\n⚠️ **Pitfall: Missing Resource Version Conflicts in Leader Election**\n\nFailing to handle resource version conflicts during leader election can cause split-brain scenarios where multiple replicas believe they are the leader. Always use conditional updates with resource version checking when claiming or renewing leadership locks.\n\n⚠️ **Pitfall: Hardcoded Configuration in Container Images**\n\nEmbedding environment-specific configuration (URLs, credentials, timeouts) in container images prevents image reuse across environments and requires image rebuilds for configuration changes. Use environment variables, ConfigMaps, and Secrets for all environment-specific settings.\n\n⚠️ **Pitfall: Ignoring Webhook Certificate Expiration**\n\nSelf-signed certificates or manually provisioned certificates will eventually expire, causing webhook failures that prevent resource creation and updates. Implement certificate monitoring and automatic renewal, preferably using cert-manager or similar automated certificate management systems.\n\n⚠️ **Pitfall: Leader Election with Inappropriate Timing**\n\nSetting lease durations too short causes leadership thrashing during network hiccups, while setting them too long delays failover during actual failures. Test leader election behavior under various network conditions and adjust timing parameters based on your cluster characteristics and recovery time objectives.\n\n### Implementation Guidance\n\nThis section provides concrete implementation details for deploying the Database Operator with proper RBAC configuration, container packaging, and high availability setup.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Container Build | `docker build` with multi-stage Dockerfile | Buildpacks with Cloud Native Buildpacks |\n| Image Registry | Docker Hub public registry | Private registry with Harbor or ECR |\n| RBAC Management | Static YAML manifests with `kubectl apply` | Helm charts with templated RBAC |\n| Certificate Management | Self-signed certificates with OpenSSL | cert-manager with Let's Encrypt or private CA |\n| Configuration Management | Environment variables with ConfigMaps | Helm values with environment-specific overrides |\n| Deployment Strategy | kubectl apply with manual manifests | GitOps with ArgoCD or Flux |\n\n#### Recommended File Structure\n\n```\noperator-deployment/\n├── docker/\n│   ├── Dockerfile              ← Multi-stage build definition\n│   └── .dockerignore           ← Exclude unnecessary files from build context\n├── helm/\n│   ├── Chart.yaml              ← Helm chart metadata\n│   ├── values.yaml             ← Default configuration values\n│   ├── values-dev.yaml         ← Development environment overrides\n│   ├── values-prod.yaml        ← Production environment overrides\n│   ├── templates/\n│   │   ├── deployment.yaml     ← Operator pod specification\n│   │   ├── rbac.yaml           ← ServiceAccount, Role, RoleBinding\n│   │   ├── webhooks.yaml       ← Admission webhook configuration\n│   │   ├── service.yaml        ← Webhook and metrics services\n│   │   └── configmap.yaml      ← Operator configuration\n│   └── crds/\n│       └── databases.yaml      ← CRD definitions (install-only)\n├── manifests/\n│   ├── namespace.yaml          ← Operator namespace\n│   ├── crd.yaml               ← Raw CRD for kubectl apply\n│   └── rbac.yaml              ← Minimal RBAC for development\n└── scripts/\n    ├── build.sh               ← Container build script\n    ├── deploy.sh              ← Helm deployment script\n    └── undeploy.sh            ← Cleanup script\n```\n\n#### Complete RBAC Configuration\n\n```yaml\n# ServiceAccount for operator pods\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: database-operator-controller-manager\n  namespace: database-operator-system\n---\n# ClusterRole with minimal required permissions\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: database-operator-manager-role\nrules:\n- apiGroups:\n  - \"\"\n  resources:\n  - configmaps\n  - events\n  - persistentvolumeclaims\n  - secrets\n  - services\n  verbs:\n  - create\n  - delete\n  - get\n  - list\n  - patch\n  - update\n  - watch\n- apiGroups:\n  - apps\n  resources:\n  - deployments\n  verbs:\n  - create\n  - delete\n  - get\n  - list\n  - patch\n  - update\n  - watch\n- apiGroups:\n  - example.com\n  resources:\n  - databases\n  verbs:\n  - create\n  - delete\n  - get\n  - list\n  - patch\n  - update\n  - watch\n- apiGroups:\n  - example.com\n  resources:\n  - databases/status\n  verbs:\n  - get\n  - patch\n  - update\n- apiGroups:\n  - coordination.k8s.io\n  resources:\n  - leases\n  verbs:\n  - create\n  - get\n  - list\n  - update\n---\n# ClusterRoleBinding linking ServiceAccount to permissions\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: database-operator-manager-rolebinding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: database-operator-manager-role\nsubjects:\n- kind: ServiceAccount\n  name: database-operator-controller-manager\n  namespace: database-operator-system\n```\n\n#### Complete Deployment Configuration\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: database-operator-controller-manager\n  namespace: database-operator-system\n  labels:\n    app.kubernetes.io/name: database-operator\n    app.kubernetes.io/component: manager\nspec:\n  replicas: 2  # High availability with leader election\n  selector:\n    matchLabels:\n      app.kubernetes.io/name: database-operator\n      app.kubernetes.io/component: manager\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/name: database-operator\n        app.kubernetes.io/component: manager\n    spec:\n      serviceAccountName: database-operator-controller-manager\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 65532  # Distroless nonroot user\n      containers:\n      - name: manager\n        image: database-operator:latest\n        command:\n        - /manager\n        args:\n        - --leader-elect\n        - --leader-elect-lease-duration=15s\n        - --leader-elect-renew-deadline=5s\n        - --leader-elect-retry-period=2s\n        ports:\n        - containerPort: 9443\n          name: webhook-server\n          protocol: TCP\n        - containerPort: 8080\n          name: metrics\n          protocol: TCP\n        - containerPort: 8081\n          name: health-probe\n          protocol: TCP\n        env:\n        - name: POD_NAMESPACE\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.namespace\n        - name: POD_NAME\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.name\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 8081\n          initialDelaySeconds: 15\n          periodSeconds: 20\n        readinessProbe:\n          httpGet:\n            path: /readyz\n            port: 8081\n          initialDelaySeconds: 5\n          periodSeconds: 10\n        resources:\n          limits:\n            cpu: 500m\n            memory: 128Mi\n          requests:\n            cpu: 10m\n            memory: 64Mi\n        securityContext:\n          allowPrivilegeEscalation: false\n          capabilities:\n            drop:\n            - ALL\n          readOnlyRootFilesystem: true\n        volumeMounts:\n        - mountPath: /tmp/k8s-webhook-server/serving-certs\n          name: cert\n          readOnly: true\n      volumes:\n      - name: cert\n        secret:\n          defaultMode: 420\n          secretName: webhook-server-certs\n      terminationGracePeriodSeconds: 10\n```\n\n#### Core Leader Election Implementation\n\n```go\n// Manager setup with leader election enabled\nfunc main() {\n    var enableLeaderElection bool\n    var leaseDuration time.Duration\n    var renewDeadline time.Duration\n    var retryPeriod time.Duration\n    \n    flag.BoolVar(&enableLeaderElection, \"leader-elect\", false,\n        \"Enable leader election for controller manager\")\n    flag.DurationVar(&leaseDuration, \"leader-elect-lease-duration\", 15*time.Second,\n        \"The duration that non-leader candidates will wait after observing a leadership renewal\")\n    flag.DurationVar(&renewDeadline, \"leader-elect-renew-deadline\", 5*time.Second,\n        \"The interval between attempts by the acting master to renew a leadership slot\")\n    flag.DurationVar(&retryPeriod, \"leader-elect-retry-period\", 2*time.Second,\n        \"The duration the clients should wait between attempting acquisition and renewal\")\n    flag.Parse()\n\n    mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{\n        Scheme:                 scheme,\n        MetricsBindAddress:     \":8080\",\n        Port:                   9443,\n        HealthProbeBindAddress: \":8081\",\n        LeaderElection:         enableLeaderElection,\n        LeaderElectionID:       \"database.example.com\",\n        LeaseDuration:          &leaseDuration,\n        RenewDeadline:          &renewDeadline,\n        RetryPeriod:            &retryPeriod,\n        LeaderElectionResourceLock: \"leases\",\n        LeaderElectionNamespace: os.Getenv(\"POD_NAMESPACE\"),\n    })\n    if err != nil {\n        setupLog.Error(err, \"unable to start manager\")\n        os.Exit(1)\n    }\n\n    // TODO: Register controllers and webhooks with manager\n    // TODO: Add health and readiness checks  \n    // TODO: Start manager with graceful shutdown on SIGTERM\n}\n```\n\n#### Container Build Configuration\n\n```dockerfile\n# Multi-stage build for minimal production image\nFROM golang:1.21 AS builder\n\nWORKDIR /workspace\n# Copy go mod files for dependency caching\nCOPY go.mod go.sum ./\nRUN go mod download\n\n# Copy source code\nCOPY cmd/ cmd/\nCOPY internal/ internal/\nCOPY api/ api/\n\n# Build the operator binary\nRUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -a -o manager cmd/main.go\n\n# Production image with minimal attack surface\nFROM gcr.io/distroless/static:nonroot\nWORKDIR /\nCOPY --from=builder /workspace/manager .\nUSER 65532:65532\n\nENTRYPOINT [\"/manager\"]\n```\n\n#### Milestone Checkpoint\n\nAfter implementing the deployment configuration:\n\n1. **RBAC Verification**: Deploy the operator and verify it can perform required operations:\n   ```bash\n   kubectl auth can-i create databases --as=system:serviceaccount:database-operator-system:database-operator-controller-manager\n   kubectl auth can-i update secrets --as=system:serviceaccount:database-operator-system:database-operator-controller-manager\n   ```\n\n2. **Leader Election Testing**: Deploy multiple replicas and verify only one performs reconciliation:\n   ```bash\n   kubectl scale deployment database-operator-controller-manager --replicas=3\n   kubectl logs -l app.kubernetes.io/name=database-operator -f | grep \"leader election\"\n   ```\n\n3. **Failover Validation**: Delete the leader pod and verify another replica takes over within the lease duration.\n\n4. **Expected Behavior**: \n   - Only one replica should show \"Starting EventSource\" and \"Starting Controller\" in logs\n   - Other replicas should show \"Waiting for leader election\" or similar\n   - After leader pod deletion, a new leader should be elected within 15-20 seconds\n   - Reconciliation should continue without interruption during leadership transitions\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| \"Forbidden\" errors during reconciliation | Missing RBAC permissions | Check `kubectl auth can-i` for required operations | Add missing permissions to ClusterRole |\n| Multiple replicas reconciling simultaneously | Leader election not working | Check logs for \"acquired lease\" messages from multiple pods | Verify leader election configuration and lease resource creation |\n| Webhook admission failures | Certificate issues or service misconfiguration | Check webhook service endpoints and certificate validity | Verify cert-manager setup or regenerate self-signed certificates |\n| Operator not starting after deployment | Image pull failures or resource constraints | Check pod events and resource utilization | Verify image registry access and resource requests |\n| Slow failover during leader crashes | Lease duration too long | Monitor leadership transition timing | Reduce lease duration while avoiding election thrashing |\n\n\n## Debugging Guide\n\n> **Milestone(s):** Milestone 2 (Controller Setup), Milestone 3 (Reconciliation Loop), Milestone 4 (Webhooks), Milestone 5 (Testing & Deployment) - provides troubleshooting guidance for common issues across controller implementation, webhook configuration, and RBAC setup\n\nBuilding a Kubernetes operator involves complex interactions between custom controllers, admission webhooks, informers, workqueues, and the Kubernetes API server. When these components don't work as expected, the symptoms can be confusing and the root causes non-obvious. This section provides a systematic debugging guide organized around the three most common problem areas developers encounter when building operators.\n\n**Mental Model: The Detective's Toolkit** - Think of debugging an operator like being a detective investigating a complex case. You have multiple witnesses (logs), physical evidence (resource states), and timelines (event sequences). Just as a detective follows leads and eliminates suspects, debugging operators requires gathering evidence from multiple sources, forming hypotheses about root causes, and systematically testing those theories. The key is knowing what evidence to look for and how to interpret the clues.\n\nThe debugging process typically follows this pattern: observe the symptoms (what's not working), gather evidence from logs and cluster state, form hypotheses about potential causes, test each hypothesis with targeted debugging techniques, and implement fixes. This guide provides the diagnostic toolkit and investigative procedures for each category of problems.\n\nOperator debugging is particularly challenging because problems often manifest as cascading failures. A simple RBAC misconfiguration can cause controller crashes, which leads to failed reconciliation, which results in outdated status conditions, which confuses end users about the actual problem. The key is learning to trace problems back to their root causes rather than treating symptoms.\n\n### Controller and Reconciliation Issues\n\nController and reconciliation problems are among the most common issues operators face. These manifest as resources stuck in pending states, infinite reconciliation loops, or controllers that appear to be \"doing nothing\" despite resource changes. Understanding the controller's internal state machine and information flow is crucial for effective debugging.\n\n**Mental Model: The Broken Assembly Line** - Think of the controller as an assembly line with several stations: the informer (receives raw materials), the workqueue (buffers work items), and the reconcile function (processes each item). When the assembly line breaks down, products either pile up at one station, get stuck in processing, or come out defective. By examining each station's health and throughput, you can identify where the bottleneck or failure occurs.\n\n#### Reconciliation Loop Problems\n\nReconciliation loops can fail in several distinct patterns, each with characteristic symptoms and root causes. The most common failure modes involve infinite loops, stalled reconciliation, and partial reconciliation failures that leave resources in inconsistent states.\n\n**Infinite Reconciliation Loops**\n\nInfinite reconciliation loops occur when the `Reconcile` function continuously requeues the same resource without making progress toward the desired state. This typically happens when the reconciler incorrectly determines that the current state doesn't match the desired state, even though they are actually equivalent.\n\n| Symptom | Evidence | Root Cause | Diagnostic Method | Solution |\n|---------|----------|------------|------------------|----------|\n| High CPU usage on controller pods | Metrics show constant reconciliation rate | Spec comparison logic treats equivalent states as different | Add debug logging to state comparison logic | Fix comparison logic to handle semantic equivalence |\n| Resource status never reaches \"Ready\" | Status shows rapid condition updates | Reconciler updates owned resources on every loop | Log owned resource hashes before/after comparison | Implement proper resource comparison with strategic merge |\n| Exponentially growing log volume | Same resource appears repeatedly in logs | Missing break condition in reconciliation logic | Trace reconciliation decision tree for specific resource | Add idempotency checks and proper exit conditions |\n| API server rate limiting errors | Controller logs show 429 responses | Excessive API calls from repeated reconciliation | Monitor API call patterns with request counting | Implement client-side rate limiting and backoff |\n\n⚠️ **Pitfall: Resource Comparison Without Strategic Merge**\nMany infinite loops result from comparing resources without accounting for Kubernetes' strategic merge patch behavior. When you create a `Deployment` with `replicas: 3`, Kubernetes may add default fields like `progressDeadlineSeconds: 600`. If your reconciler compares the original spec (without defaults) to the current state (with defaults), it will always detect differences and attempt updates.\n\n**Stalled Reconciliation**\n\nStalled reconciliation occurs when the controller stops processing resources entirely, even though new events are occurring. This typically indicates problems with the informer cache, workqueue processing, or controller startup sequence.\n\n| Symptom | Evidence | Root Cause | Diagnostic Method | Solution |\n|---------|----------|------------|------------------|----------|\n| Resources stuck in \"Pending\" state | No reconciliation logs for affected resources | Informer cache not synced before processing started | Check informer sync status in controller startup | Add proper cache sync wait before starting workers |\n| Controller appears healthy but ignores changes | Resource updates don't trigger reconciliation | Event handlers not properly registered | Verify SetupWithManager includes all watch configurations | Add missing watch statements for owned resources |\n| Some resources reconcile, others don't | Selective resource processing failures | Workqueue filtering or malformed resource keys | Examine workqueue contents and key generation logic | Fix resource key generation and queue filtering |\n| Fresh resources process, old ones don't | Controller restart resolves some stuck resources | Informer resync period too long or disabled | Check resync configuration and cache staleness | Configure appropriate resync period or force cache refresh |\n\n**Partial Reconciliation Failures**\n\nPartial reconciliation failures occur when the reconciler successfully processes some owned resources but fails on others, leaving the system in an inconsistent state. This is particularly dangerous because the overall status may appear healthy while critical components are actually broken.\n\n```\nExample Failure Sequence:\n1. Database resource specifies: replicas=3, version=14.5\n2. Reconciler successfully creates StatefulSet with 3 replicas  \n3. Reconciler fails to create ConfigMap with version 14.5 config\n4. Status shows \"Ready: True\" based on StatefulSet status\n5. Pods start but fail to launch due to missing ConfigMap\n6. User sees \"Ready\" status but database is actually down\n```\n\nThe challenge with partial failures is that the reconciler must decide whether to report success (some resources are healthy) or failure (the overall system is broken). The solution is implementing transactional reconciliation with proper rollback and status reporting.\n\n#### Informer and Cache Problems\n\nThe informer and cache system provides the controller with a local, eventually consistent view of cluster state. When this system malfunctions, controllers may operate on stale data, miss important events, or crash due to unexpected cache states.\n\n**Cache Synchronization Issues**\n\nCache synchronization problems occur when the local informer cache diverges from the actual API server state, leading to reconciliation decisions based on outdated information.\n\n| Problem Type | Symptoms | Detection Method | Resolution |\n|--------------|----------|------------------|------------|\n| Stale cache data | Reconciler operates on deleted resources | Compare cache contents with direct API calls | Increase resync period or force cache refresh |\n| Missing recent updates | Controller ignores recent resource changes | Check event sequence timestamps vs cache timestamps | Verify watch connection health and restart if needed |\n| Cache memory pressure | High memory usage, frequent GC pauses | Monitor informer cache size and growth patterns | Implement cache size limits or namespace filtering |\n| Watch connection drops | Periodic reconciliation gaps in logs | Monitor watch connection errors and reconnections | Add connection monitoring and exponential backoff |\n\n⚠️ **Pitfall: Starting Workers Before Cache Sync**\nA common mistake is starting workqueue processing goroutines before the informer cache has fully synchronized with the API server. This causes the controller to process events based on incomplete cache data, leading to incorrect reconciliation decisions and potential data corruption.\n\n**Event Handler Registration Problems**\n\nEvent handlers translate informer cache events (add, update, delete) into workqueue items for reconciliation. Misconfigured event handlers can cause the controller to miss important events or process irrelevant changes.\n\n| Handler Issue | Behavior | Investigation | Fix |\n|---------------|----------|---------------|-----|\n| Missing update handlers | Resource changes ignored | Verify all SetupWithManager watch configurations | Add missing Controller.Watches() calls |\n| Incorrect filtering | Wrong resources trigger reconciliation | Log event handler invocations with resource details | Fix OwnerReference or label selectors in watches |\n| Handler panics | Controller crashes on specific events | Check event handler code for nil pointer dereferences | Add nil checks and error handling in handlers |\n| Duplicate event processing | Same resource reconciled multiple times per change | Monitor workqueue items and deduplication | Ensure proper resource key generation and dedup logic |\n\n#### Workqueue and Rate Limiting Issues\n\nThe workqueue buffers reconciliation requests and implements rate limiting to prevent overwhelming the controller or API server. Workqueue problems typically manifest as delayed processing, resource starvation, or memory growth from unbounded queues.\n\n**Rate Limiting and Backoff Problems**\n\nRate limiting protects the system from overload but can cause delays when misconfigured. Understanding the backoff algorithms and tuning parameters is essential for optimal controller performance.\n\nThe default controller-runtime rate limiter uses exponential backoff with jitter: initial delay of 5ms, doubling on each retry, up to a maximum of 16 minutes. For transient errors, this provides good protection. However, permanent errors (like RBAC denials) will continue consuming rate limiter capacity without making progress.\n\n| Rate Limiting Issue | Observable Effects | Tuning Approach | Implementation |\n|---------------------|-------------------|-----------------|----------------|\n| Aggressive backoff delays critical updates | Important resources take minutes to reconcile | Reduce base delay and maximum interval | Configure custom ItemBasedRateLimiter with lower bounds |\n| Rate limiter overwhelmed by error resources | Healthy resources delayed behind failing ones | Separate rate limiting for different error types | Implement multi-tier rate limiting based on error classification |\n| Memory growth from queued items | Controller memory usage grows without bound | Add queue depth monitoring and circuit breakers | Set maximum queue length and reject new items when full |\n| Hot resource monopolizes queue capacity | Single misbehaving resource blocks others | Implement per-resource rate limiting | Use BucketRateLimiter with separate buckets per resource |\n\n**Workqueue Shutdown and Goroutine Leaks**\n\nProper workqueue shutdown is critical for clean controller termination and preventing goroutine leaks in testing scenarios. Shutdown problems often manifest as hanging tests or controllers that can't be cleanly restarted.\n\nThe workqueue shutdown sequence must be carefully orchestrated: stop accepting new items, drain existing items, signal worker goroutines to exit, and wait for all workers to complete. Skipping any step can cause deadlocks or resource leaks.\n\n```\nProper Shutdown Sequence:\n1. Call workqueue.ShutDown() to stop accepting new items\n2. Worker goroutines check Done() channel and exit gracefully  \n3. Call workqueue.ShutDownWithDrain() to process remaining items\n4. Use sync.WaitGroup to wait for all workers to finish\n5. Close any additional channels or cleanup resources\n```\n\n### Webhook and Admission Problems\n\nAdmission webhooks introduce additional complexity because they operate synchronously in the request path between the client and API server. When webhooks malfunction, they can block all resource operations, cause timeouts, or silently fail validation. Webhook debugging requires understanding HTTPS certificate management, admission review processing, and failure policy configuration.\n\n**Mental Model: The Security Checkpoint** - Think of admission webhooks like airport security checkpoints. Every passenger (resource) must pass through security (webhook validation) before boarding the plane (being stored in etcd). If security is down, flights get delayed or canceled. If security is too slow, passengers miss connections. If security has wrong information, innocent passengers get detained while threats slip through. The key is ensuring the checkpoint is fast, reliable, and has current information.\n\n#### Certificate and TLS Issues\n\nAdmission webhooks must serve HTTPS traffic with valid TLS certificates that the API server can verify. Certificate problems are among the most common webhook issues and can be particularly frustrating because they often work in development but fail in production due to different certificate authorities or hostname verification.\n\n**Certificate Provisioning and Validation**\n\nThe API server must trust the webhook's TLS certificate and verify that the certificate's subject matches the service hostname. This requires proper certificate generation, distribution, and rotation mechanisms.\n\n| Certificate Problem | Symptoms | Verification Steps | Solution Approach |\n|---------------------|-----------|-------------------|------------------|\n| Self-signed certificate not trusted | Webhook admission review requests fail with TLS errors | Check API server logs for certificate validation errors | Use cert-manager or add CA bundle to webhook configuration |\n| Hostname mismatch in certificate | TLS handshake failures despite valid certificates | Verify certificate SAN includes service DNS names | Regenerate certificate with correct Subject Alternative Names |\n| Expired certificates | Intermittent webhook failures, particularly after time jumps | Check certificate expiration dates with openssl | Implement automatic certificate rotation with cert-manager |\n| Certificate not readable by webhook pod | Webhook server fails to start with TLS initialization errors | Verify certificate file permissions and volume mounts | Fix service account permissions and secret volume configuration |\n\nThe certificate Subject Alternative Name (SAN) field must include all DNS names that the API server might use to reach the webhook service. For a webhook service named `database-webhook` in namespace `operator-system`, the SAN should include: `database-webhook.operator-system.svc`, `database-webhook.operator-system.svc.cluster.local`, and potentially the service IP address.\n\n⚠️ **Pitfall: Certificate Rotation During Webhook Processing**\nCertificate rotation can cause admission request failures if certificates change while the API server still has cached connections. The webhook server must implement graceful certificate reloading without dropping active connections, and the API server may need time to refresh its certificate cache.\n\n**TLS Configuration and Cipher Suites**\n\nThe webhook server must support TLS versions and cipher suites that the API server accepts. Mismatched TLS configurations can cause connection failures that are difficult to diagnose because they occur during the initial handshake.\n\nModern Kubernetes API servers typically require TLS 1.2 or higher and prefer Forward Secrecy cipher suites. The webhook server should support a compatible set of protocols and ciphers while maintaining reasonable security standards.\n\n#### Admission Review Processing\n\nAdmission review processing involves unmarshaling the admission request, validating or mutating the resource, and returning a properly formatted admission response. Problems in this pipeline can cause webhook timeouts, malformed responses, or incorrect admission decisions.\n\n**Request Deserialization and Validation**\n\nThe admission review request contains the resource data in JSON format, along with metadata about the operation type, user information, and admission context. Proper deserialization requires handling different API versions, unknown fields, and malformed input.\n\n| Processing Issue | Error Manifestation | Debugging Approach | Implementation Fix |\n|------------------|-------------------|-------------------|-------------------|\n| Unsupported admission review version | Webhook returns 400 Bad Request | Log admission review version in request handler | Add support for multiple admissionregistration API versions |\n| Resource deserialization failures | Webhook denies all requests with decode errors | Log raw admission request JSON for analysis | Add proper error handling and version-aware deserialization |\n| Missing required fields in admission request | Webhook crashes or returns malformed responses | Validate admission request structure before processing | Add comprehensive input validation with clear error messages |\n| Memory exhaustion from large resources | Webhook becomes unresponsive or crashes | Monitor memory usage during large resource processing | Implement request size limits and streaming deserialization |\n\n**Mutation Response Formatting**\n\nMutating webhooks must return JSON Patch operations that describe the changes to apply to the resource. Malformed patches can cause admission failures or unintended modifications.\n\nJSON Patch operations must specify the exact path to modify, the operation type (add, replace, remove), and the new value with correct typing. Path specifications use JSON Pointer syntax, which has specific escaping rules for field names containing special characters.\n\n```\nExample Mutation Scenarios:\n- Adding a default value to an empty field: {\"op\": \"add\", \"path\": \"/spec/replicas\", \"value\": 1}\n- Replacing an existing array element: {\"op\": \"replace\", \"path\": \"/spec/containers/0/image\", \"value\": \"new-image:v2\"}  \n- Removing a field: {\"op\": \"remove\", \"path\": \"/metadata/annotations/old-annotation\"}\n- Adding to an array: {\"op\": \"add\", \"path\": \"/spec/containers/-\", \"value\": {...}}\n```\n\n⚠️ **Pitfall: JSON Patch Path Escaping**\nJSON Pointer paths require escaping special characters in field names. A field named `example.com/annotation` must be referenced as `/metadata/annotations/example.com~1annotation` (where `~1` represents the `/` character). Incorrect escaping causes patch application failures.\n\n#### Webhook Timeout and Performance Issues\n\nAdmission webhooks operate in the synchronous request path, so performance problems directly impact user operations. The default admission timeout is 10 seconds, after which the API server either admits or denies the request based on the configured failure policy.\n\n**Response Time Optimization**\n\nWebhook response time affects the user experience for all resource operations. Slow webhooks make `kubectl apply` commands feel sluggish and can cause client timeouts on large batch operations.\n\nCommon performance bottlenecks include: external API calls during validation (such as checking license servers or external databases), complex validation logic with nested loops, large resource deserialization, and cold start delays in serverless environments.\n\n| Performance Issue | User Impact | Measurement Method | Optimization Strategy |\n|-------------------|-------------|-------------------|---------------------|\n| Slow validation logic | kubectl commands take several seconds | Add timing metrics to webhook handlers | Cache validation results and optimize algorithms |\n| External API dependencies | Webhooks fail when external services are unavailable | Monitor external service response times | Implement circuit breakers and local caching |\n| Large resource processing | Memory pressure and slow response for big resources | Profile memory allocation during large resource handling | Stream processing and implement size limits |\n| Cold start delays | First requests after deployment are very slow | Measure time-to-first-response after pod startup | Add readiness probes and pre-warm caches |\n\n**Failure Policy and Degraded Mode Operation**\n\nWebhook failure policies determine what happens when the webhook is unavailable, times out, or returns errors. The two options are `Fail` (deny admission on webhook failure) and `Ignore` (allow admission on webhook failure). Both have significant operational implications.\n\nA `Fail` policy provides security guarantees by ensuring no unvalidated resources enter the cluster, but it creates availability risks if the webhook becomes unavailable. An `Ignore` policy maintains cluster availability during webhook outages but allows potentially invalid resources to be created.\n\n> **Decision: Webhook Failure Policy Selection**  \n> - **Context**: Webhook failures can either block all resource operations (Fail policy) or allow unvalidated resources (Ignore policy)  \n> - **Options Considered**: Always Fail, Always Ignore, Dynamic policy based on validation criticality  \n> - **Decision**: Use Fail policy for validating webhooks, Ignore policy for mutating webhooks with non-critical defaults  \n> - **Rationale**: Validation failures indicate policy violations that should block admission. Mutation failures for defaults are less critical than availability  \n> - **Consequences**: Validation webhook outages block resource creation, requiring high availability deployment. Mutation webhook outages allow resources without defaults but maintain system operation\n\n### RBAC and Permissions Debugging\n\nRole-Based Access Control (RBAC) governs what operations the operator's service account can perform against the Kubernetes API. RBAC problems typically manifest as \"permission denied\" errors, but diagnosing the specific missing permissions and configuring minimal privilege access requires understanding Kubernetes' multi-layered permission model.\n\n**Mental Model: The Credential Hierarchy** - Think of Kubernetes RBAC like a corporate security system with keycards and access levels. Each service account has a keycard (identity), roles define what areas each keycard can access (permissions), and role bindings connect keycards to access levels (authorization). When access is denied, you need to trace through the entire chain: does the keycard exist, does the role have the right permissions, is the binding connecting them correctly, and is the request happening in the right location (namespace).\n\n#### Service Account and Role Configuration\n\nService accounts provide identity for pods, while roles and role bindings define and grant permissions. The interaction between these components creates a complex permission matrix that can be difficult to debug when misconfigured.\n\n**Service Account Identity Issues**\n\nService accounts must exist and be properly mounted into pods before they can be used for API authentication. Missing or misconfigured service accounts cause immediate authentication failures.\n\n| Service Account Problem | Error Pattern | Investigation Steps | Resolution Path |\n|-------------------------|---------------|-------------------|-----------------|\n| Service account doesn't exist | HTTP 401 Unauthorized errors on all API calls | Check if service account exists in the correct namespace | Create service account with proper metadata |\n| Service account token not mounted | Authentication works in pod but fails for specific operations | Verify automountServiceAccountToken is not disabled | Enable service account token mounting or use manual token |\n| Wrong service account specified in deployment | Pod uses default service account instead of operator account | Compare Deployment serviceAccountName with actual pod spec | Update Deployment to reference correct service account |\n| Service account in wrong namespace | Permission denied errors despite correct role bindings | Verify service account and role binding namespaces match | Move service account or update role binding namespace |\n\n**Role Definition and Scope Problems**\n\nRoles define the specific permissions (verbs and resources) that can be granted to service accounts. Incorrect role definitions are a common source of permission errors, particularly when operators need to manage multiple resource types or perform administrative operations.\n\nThe principle of least privilege suggests granting only the minimum permissions necessary for operation. However, operators often require broad permissions across multiple resources, creating tension between security and functionality.\n\n| Permission Issue | Manifestation | Diagnosis Technique | Correction Method |\n|------------------|---------------|-------------------|------------------|\n| Missing resource permissions | Permission denied on specific resource types | Check role definition against error messages | Add required resources to role rules |\n| Insufficient verbs for operations | Create works but update/delete fails | Map operation types to required verbs (get, list, watch, create, update, patch, delete) | Expand verb list in role rules |\n| API group mismatches | Permission denied for custom resources | Verify apiGroups in role match CRD group | Update role apiGroups to include custom resource groups |\n| Namespace scope limitations | Cluster-wide operations fail with namespace-scoped roles | Determine if operator needs cluster-wide or namespace-scoped access | Convert Role to ClusterRole or add namespace-specific roles |\n\n⚠️ **Pitfall: Custom Resource API Groups in RBAC**\nCustom resources use different API groups than built-in Kubernetes resources. A `Database` custom resource in the `database.example.com` API group requires RBAC rules with `apiGroups: [\"database.example.com\"]`, not the empty string used for core resources. Forgetting to include the custom API group causes permission denied errors for all custom resource operations.\n\n#### Permission Scope and Binding Issues\n\nRole bindings connect service accounts to roles, creating the actual permission grants. Binding problems can be subtle because they often involve namespace boundaries, subject references, or binding scope mismatches.\n\n**Namespace Boundary and Scope Mismatches**\n\nKubernetes uses both namespace-scoped (Role, RoleBinding) and cluster-scoped (ClusterRole, ClusterRoleBinding) RBAC objects. Mismatching scopes between roles and bindings, or between operator needs and binding scope, causes permission failures that can be difficult to diagnose.\n\n```\nRBAC Scope Combinations:\n- Role + RoleBinding: namespace-scoped permissions within a specific namespace  \n- ClusterRole + RoleBinding: cluster-wide permissions applied to a specific namespace\n- ClusterRole + ClusterRoleBinding: cluster-wide permissions applied cluster-wide\n- Role + ClusterRoleBinding: Invalid - ClusterRoleBindings cannot reference Roles\n```\n\nThe most common scope mismatch occurs when operators need to watch resources across all namespaces but are configured with namespace-scoped role bindings. This causes the operator to successfully process resources in its own namespace while failing silently on resources in other namespaces.\n\n**Subject Reference and Binding Validation**\n\nRole bindings must correctly reference the service account using the proper subject format. Incorrect subject references cause the binding to be ineffective, even though it appears correctly configured.\n\n| Binding Problem | Symptoms | Validation Method | Fix Implementation |\n|-----------------|----------|------------------|-------------------|\n| Incorrect subject name | Permission denied despite apparently correct bindings | Compare binding subjects with actual service account names | Update binding subject name to match service account |\n| Wrong subject namespace | Binding exists but doesn't grant permissions | Verify binding subject namespace matches service account namespace | Update subject namespace in role binding |\n| Invalid subject kind | Binding appears correct but permissions not granted | Ensure subject kind is \"ServiceAccount\" not \"User\" or \"Group\" | Correct subject kind in binding specification |\n| Multiple conflicting bindings | Inconsistent permission behavior across operations | List all role bindings affecting the service account | Consolidate bindings and remove conflicting rules |\n\n#### Runtime Permission Verification\n\nRuntime permission verification involves testing actual API operations to confirm that RBAC configuration grants the expected access. This is particularly important during operator development and deployment because RBAC misconfigurations often only surface when specific operations are attempted.\n\n**Permission Testing and Validation**\n\nThe `kubectl auth can-i` command provides a way to test permissions without attempting actual operations. This is useful for validating RBAC configuration before deploying operators or troubleshooting permission issues in production.\n\n```\nPermission Testing Examples:\nkubectl auth can-i create databases.database.example.com --as=system:serviceaccount:operator-system:database-controller\nkubectl auth can-i update deployments --as=system:serviceaccount:operator-system:database-controller -n production  \nkubectl auth can-i list secrets --as=system:serviceaccount:operator-system:database-controller --all-namespaces\nkubectl auth can-i delete persistentvolumeclaims --as=system:serviceaccount:operator-system:database-controller\n```\n\nThese tests should be performed for all operations the operator needs to perform, across all relevant namespaces and resource types.\n\n**Minimal Privilege Validation**\n\nOperators should follow the principle of least privilege, granting only the minimum permissions necessary for correct operation. However, determining the exact minimum set of permissions requires careful analysis of all operator operations and their corresponding RBAC requirements.\n\nThe process involves: cataloging all API operations the operator performs (from controller reconciliation and webhook processing), mapping each operation to required RBAC verbs and resources, grouping permissions by functional area to create focused roles, and testing that the minimal permission set supports all operator functionality.\n\n| Operation Type | Required Permissions | Rationale | Validation Method |\n|----------------|---------------------|-----------|------------------|\n| Custom resource reconciliation | get, list, watch, update, patch on custom resources | Controller needs to read current state and update status | Test reconciliation loop with minimal permissions |\n| Owned resource management | get, list, watch, create, update, patch, delete on owned types | Controller creates and manages Deployments, Services, etc. | Test resource creation, updates, and cleanup |\n| Event recording | create on events | Controller reports status and errors through events | Test event creation during normal and error scenarios |\n| Leader election | get, create, update on leases or configmaps | High availability requires leader election coordination | Test controller startup with multiple replicas |\n\n> **The critical insight here is that RBAC debugging requires understanding the complete request context - not just the service account and permissions, but also the namespace scope, API group, and specific operation being performed. Each element must align correctly for authorization to succeed.**\n\n### Implementation Guidance\n\nThis debugging toolkit provides practical techniques for diagnosing and resolving the most common operator development issues. The goal is enabling developers to quickly identify root causes and apply targeted fixes rather than spending hours on trial-and-error debugging.\n\n**Technology Recommendations:**\n\n| Debugging Component | Simple Option | Advanced Option |\n|---------------------|---------------|-----------------|\n| Log Analysis | Basic kubectl logs with grep | Structured logging with logr and log aggregation |\n| RBAC Validation | kubectl auth can-i commands | RBAC policy simulators and automated testing |\n| Certificate Management | Manual openssl certificate validation | cert-manager with automated certificate lifecycle |\n| Performance Monitoring | Basic kubectl top and describe commands | Prometheus metrics with Grafana dashboards |\n| Integration Testing | Manual kubectl apply/delete cycles | Automated envtest with comprehensive scenarios |\n\n**Recommended File Structure for Debugging Tools:**\n\n```\noperator-project/\n  cmd/\n    debug-controller/\n      main.go                    ← debug utility for controller issues\n    validate-rbac/\n      main.go                    ← RBAC permission validation tool\n    webhook-tester/\n      main.go                    ← webhook admission request simulator\n  internal/\n    debug/\n      controller_diagnostics.go  ← controller health checking utilities\n      webhook_diagnostics.go     ← webhook validation and testing helpers\n      rbac_validator.go          ← automated RBAC permission verification\n  test/\n    debug/\n      controller_debug_test.go   ← debugging scenario test cases\n      webhook_debug_test.go      ← webhook failure simulation tests\n```\n\n**Complete Controller Diagnostics Helper:**\n\n```go\n// internal/debug/controller_diagnostics.go\npackage debug\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n    \n    \"k8s.io/apimachinery/pkg/runtime\"\n    \"k8s.io/client-go/tools/cache\"\n    \"k8s.io/client-go/util/workqueue\"\n    \"sigs.k8s.io/controller-runtime/pkg/client\"\n    \"sigs.k8s.io/controller-runtime/pkg/log\"\n    \n    databasev1 \"github.com/example/database-operator/api/v1\"\n)\n\ntype ControllerDiagnostics struct {\n    Client client.Client\n    Scheme *runtime.Scheme\n    logger logr.Logger\n}\n\ntype InformerHealth struct {\n    CacheSynced     bool\n    LastSyncTime    time.Time\n    CacheSize       int\n    WatchConnected  bool\n    ResyncPeriod    time.Duration\n}\n\ntype WorkqueueHealth struct {\n    QueueLength     int\n    ProcessingRate  float64\n    ErrorRate       float64\n    RetryBacklog    int\n    IsShuttingDown  bool\n}\n\ntype ReconcilerHealth struct {\n    ActiveReconciliations int\n    AverageReconcileTime  time.Duration\n    ErrorCount           int64\n    SuccessCount         int64\n    LastReconcileTime    time.Time\n}\n\n// DiagnoseInformerHealth checks the health of controller informers\nfunc (cd *ControllerDiagnostics) DiagnoseInformerHealth(informer cache.SharedIndexInformer) InformerHealth {\n    // TODO: Check if informer cache has synced with API server\n    // TODO: Measure cache size and last sync time\n    // TODO: Verify watch connection is active\n    // TODO: Report resync period configuration\n    // Hint: Use informer.HasSynced() and informer.LastSyncResourceVersion()\n    return InformerHealth{}\n}\n\n// DiagnoseWorkqueueHealth analyzes workqueue performance and backlog\nfunc (cd *ControllerDiagnostics) DiagnoseWorkqueueHealth(queue workqueue.RateLimitingInterface) WorkqueueHealth {\n    // TODO: Measure current queue length and processing rate\n    // TODO: Calculate error rate from retry attempts\n    // TODO: Count items in retry backlog\n    // TODO: Check if queue is in shutdown state\n    // Hint: Use queue.Len() and implement metrics collection\n    return WorkqueueHealth{}\n}\n\n// DiagnoseReconcilerHealth evaluates reconciliation performance\nfunc (cd *ControllerDiagnostics) DiagnoseReconcilerHealth() ReconcilerHealth {\n    // TODO: Count active reconciliation goroutines\n    // TODO: Calculate average reconciliation duration from metrics\n    // TODO: Report success/error ratios\n    // TODO: Track last reconciliation timestamp\n    // Hint: Use prometheus metrics or custom counters\n    return ReconcilerHealth{}\n}\n\n// ValidateResourceState compares desired vs actual state for debugging\nfunc (cd *ControllerDiagnostics) ValidateResourceState(ctx context.Context, db *databasev1.Database) (*StateValidationResult, error) {\n    // TODO: Fetch current state of all owned resources\n    // TODO: Compare with desired state from Database spec\n    // TODO: Identify specific differences and inconsistencies\n    // TODO: Report resources that should exist but don't\n    // TODO: Report resources that exist but shouldn't\n    // Hint: Use owner references to find owned resources\n    return nil, nil\n}\n\n// TraceReconciliationPath logs the complete reconciliation decision tree\nfunc (cd *ControllerDiagnostics) TraceReconciliationPath(ctx context.Context, db *databasev1.Database) error {\n    // TODO: Enable debug logging for this specific resource\n    // TODO: Log each step of reconciliation logic\n    // TODO: Record timing for each reconciliation phase\n    // TODO: Log state comparisons and decisions\n    // TODO: Track condition updates and status changes\n    // Hint: Use structured logging with consistent field names\n    return nil\n}\n```\n\n**Webhook Diagnostics and Testing Helper:**\n\n```go\n// internal/debug/webhook_diagnostics.go  \npackage debug\n\nimport (\n    \"context\"\n    \"crypto/tls\"\n    \"fmt\"\n    \"net/http\"\n    \"time\"\n    \n    admissionv1 \"k8s.io/api/admission/v1\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/apimachinery/pkg/runtime\"\n    \n    databasev1 \"github.com/example/database-operator/api/v1\"\n)\n\ntype WebhookDiagnostics struct {\n    WebhookURL  string\n    CertPath    string\n    KeyPath     string\n    HTTPClient  *http.Client\n}\n\ntype CertificateHealth struct {\n    IsValid         bool\n    ExpirationTime  time.Time\n    DaysUntilExpiry int\n    SubjectAltNames []string\n    Issuer          string\n    ValidationError error\n}\n\ntype AdmissionTestResult struct {\n    RequestSent      bool\n    ResponseReceived bool\n    ResponseTime     time.Duration\n    AdmissionDecision string\n    ValidationErrors []string\n    MutationPatches  []JSONPatch\n}\n\n// DiagnoseCertificateHealth validates webhook TLS certificates\nfunc (wd *WebhookDiagnostics) DiagnoseCertificateHealth() CertificateHealth {\n    // TODO: Load certificate from file or Kubernetes secret\n    // TODO: Verify certificate is not expired\n    // TODO: Check Subject Alternative Names include service DNS names\n    // TODO: Validate certificate chain and CA trust\n    // TODO: Test TLS handshake with API server requirements\n    // Hint: Use crypto/x509 for certificate parsing and validation\n    return CertificateHealth{}\n}\n\n// TestAdmissionRequest sends a synthetic admission request to webhook\nfunc (wd *WebhookDiagnostics) TestAdmissionRequest(ctx context.Context, db *databasev1.Database, operation string) AdmissionTestResult {\n    // TODO: Construct admission review request with test Database resource\n    // TODO: Set appropriate operation (CREATE, UPDATE, DELETE)\n    // TODO: Send HTTPS POST request to webhook endpoint\n    // TODO: Parse admission response and extract decision\n    // TODO: Validate response format and required fields\n    // Hint: Use admission/v1.AdmissionReview for request/response format\n    return AdmissionTestResult{}\n}\n\n// ValidateWebhookConfiguration checks webhook registration with API server\nfunc (wd *WebhookDiagnostics) ValidateWebhookConfiguration(ctx context.Context) error {\n    // TODO: Fetch ValidatingAdmissionWebhook and MutatingAdmissionWebhook configurations\n    // TODO: Verify webhook service and namespace references are correct\n    // TODO: Check that CA bundle matches webhook certificate\n    // TODO: Validate admission rule selectors and resource matching\n    // TODO: Test webhook failure policy configuration\n    // Hint: Use admissionregistration/v1 API to fetch webhook configs\n    return nil\n}\n\n// SimulateWebhookFailures tests webhook behavior under various failure conditions\nfunc (wd *WebhookDiagnostics) SimulateWebhookFailures(ctx context.Context) error {\n    // TODO: Test webhook behavior when certificate is expired\n    // TODO: Test webhook timeout scenarios with slow responses\n    // TODO: Test malformed admission request handling\n    // TODO: Test webhook unavailability with failure policy\n    // TODO: Test concurrent admission request handling\n    // Hint: Use test HTTP servers that simulate failure modes\n    return nil\n}\n```\n\n**RBAC Validation Tool:**\n\n```go\n// internal/debug/rbac_validator.go\npackage debug\n\nimport (\n    \"context\"\n    \"fmt\"\n    \n    authv1 \"k8s.io/api/authorization/v1\"\n    rbacv1 \"k8s.io/api/rbac/v1\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/client-go/kubernetes\"\n)\n\ntype RBACValidator struct {\n    Client          kubernetes.Interface\n    ServiceAccount  string\n    Namespace       string\n}\n\ntype PermissionTest struct {\n    Resource    string\n    Verb        string\n    APIGroup    string\n    Namespace   string\n    Expected    bool\n    Actual      bool\n    Error       error\n}\n\ntype RBACValidationResult struct {\n    ServiceAccountExists bool\n    RoleBindings        []rbacv1.RoleBinding\n    ClusterRoleBindings []rbacv1.ClusterRoleBinding  \n    PermissionTests     []PermissionTest\n    MissingPermissions  []string\n    ExcessivePermissions []string\n}\n\n// ValidateOperatorPermissions tests all required RBAC permissions\nfunc (rv *RBACValidator) ValidateOperatorPermissions(ctx context.Context) (*RBACValidationResult, error) {\n    // TODO: Verify service account exists in specified namespace\n    // TODO: Find all role bindings that reference the service account\n    // TODO: Find all cluster role bindings that reference the service account\n    // TODO: Test each required permission using SubjectAccessReview\n    // TODO: Report missing permissions and excessive grants\n    // Hint: Use authorization/v1.SubjectAccessReview for permission testing\n    return nil, nil\n}\n\n// TestCustomResourcePermissions validates CRD-specific RBAC rules\nfunc (rv *RBACValidator) TestCustomResourcePermissions(ctx context.Context) error {\n    // TODO: Test get, list, watch permissions on Database custom resources\n    // TODO: Test create, update, patch permissions for Database resources\n    // TODO: Test status subresource update permissions\n    // TODO: Test permissions across different namespaces\n    // TODO: Verify finalizer update permissions\n    // Hint: Custom resources use different API groups than built-in resources\n    return nil\n}\n\n// TestOwnedResourcePermissions validates permissions for resources owned by operator\nfunc (rv *RBACValidator) TestOwnedResourcePermissions(ctx context.Context) error {\n    // TODO: Test Deployment create, update, delete permissions\n    // TODO: Test Service and ConfigMap management permissions  \n    // TODO: Test PersistentVolumeClaim permissions for storage\n    // TODO: Test Secret permissions for database credentials\n    // TODO: Verify permissions work across target namespaces\n    // Hint: Test both namespace-scoped and cluster-scoped resources\n    return nil\n}\n\n// GenerateMinimalRBACManifests creates RBAC with principle of least privilege\nfunc (rv *RBACValidator) GenerateMinimalRBACManifests() ([]runtime.Object, error) {\n    // TODO: Analyze actual API calls made by operator\n    // TODO: Generate Role and ClusterRole with minimal required permissions\n    // TODO: Create RoleBinding and ClusterRoleBinding for service account\n    // TODO: Separate permissions by functional area (controller, webhooks, leader election)\n    // TODO: Include comments explaining why each permission is needed\n    // Hint: Group permissions logically and document rationale\n    return nil, nil\n}\n```\n\n**Milestone Checkpoint: Controller Debugging**\nAfter implementing controller debugging tools, verify functionality by:\n1. Run `go run cmd/debug-controller/main.go` with a problematic Database resource\n2. Expected output: detailed informer cache status, workqueue metrics, and reconciliation trace\n3. Create a Database with intentional spec errors and confirm the debugging tool identifies the issue\n4. Verify that infinite reconciliation loops are detected and reported with specific root causes\n\n**Milestone Checkpoint: Webhook Debugging**  \nAfter implementing webhook diagnostics, validate by:\n1. Run webhook certificate validation against expired or misconfigured certificates\n2. Expected behavior: clear error messages identifying specific certificate problems  \n3. Test admission request simulation with various Database resource configurations\n4. Confirm that webhook timeout and failure scenarios are properly detected and reported\n\n**Milestone Checkpoint: RBAC Validation**\nAfter implementing RBAC validation tools, confirm by:\n1. Run permission validation against service accounts with missing or excessive permissions\n2. Expected output: detailed report of required vs actual permissions with specific gaps identified\n3. Test custom resource permission validation across multiple namespaces\n4. Verify that minimal RBAC manifest generation produces working configurations\n\n\n## Future Extensions and Evolution\n\n> **Milestone(s):** All milestones - this section guides how operators can evolve beyond their initial implementation while maintaining backward compatibility and operational stability\n\nThe beauty of the Kubernetes operator pattern lies not just in solving immediate automation problems, but in creating a foundation that can evolve with changing requirements. Unlike traditional configuration management tools that often require complete rewrites for new features, well-designed operators can grow organically through extension points and architectural patterns that preserve existing functionality while adding new capabilities.\n\n### Mental Model: The Living System\n\nThink of a mature operator like a city's infrastructure. When a city grows, you don't tear down all the roads and buildings to add new neighborhoods. Instead, you extend existing transit systems, add new utility lines that connect to existing grids, and build new districts that integrate with established ones. Similarly, a well-architected operator provides extension points that allow new functionality to plug into existing reconciliation loops, admission controls, and status reporting without disrupting operational workloads.\n\nThe key insight is that operators encode operational knowledge as code, and this knowledge base should be extensible. Each new feature should build upon the foundation of custom resources, controllers, and webhooks established in the initial implementation, rather than requiring parallel systems that duplicate effort and create consistency challenges.\n\n### Feature Extension Points\n\nThe operator pattern provides several natural extension points where new functionality can be added without breaking existing behavior. These extension points align with the separation of concerns established in the core architecture: custom resource schemas can be versioned and extended, controllers can watch additional resource types, and admission webhooks can be composed to handle multiple validation scenarios.\n\n### Mental Model: The Plugin Architecture\n\nConsider how modern IDEs like Visual Studio Code handle extensions. The core editor provides fundamental capabilities (editing text, managing files), but extensions add language support, debugging tools, and specialized workflows. Each extension registers with well-defined interfaces, contributes to specific extension points, and can be installed or removed without affecting other extensions.\n\nSimilarly, operator extensions should leverage Kubernetes' native extension mechanisms. New custom resource definitions can be added alongside existing ones, additional controllers can be deployed to handle new resource types, and webhook configurations can be extended to cover new admission scenarios. The key is designing these extensions to be composable rather than monolithic.\n\n> **Decision: Extension Architecture Strategy**\n> - **Context**: Operators need to evolve with new requirements while maintaining backward compatibility and operational stability for existing resources\n> - **Options Considered**: \n>   1. Monolithic operator with all features in one controller\n>   2. Microservice operators with one controller per resource type\n>   3. Plugin-based architecture with core operator and extension points\n> - **Decision**: Plugin-based architecture with extension points for new resource types, custom reconciliation logic, and admission policies\n> - **Rationale**: This approach balances operational simplicity (single deployment) with extensibility (isolated feature development) while leveraging Kubernetes' native composition mechanisms\n> - **Consequences**: Extensions can be developed and tested independently, but require careful interface design to prevent tight coupling between core and extension code\n\n| Extension Point | Implementation Strategy | Backward Compatibility | Development Isolation |\n|---|---|---|---|\n| New Custom Resources | Additional CRDs with separate controllers | Complete - existing resources unaffected | High - independent schema and logic |\n| Resource Composition | Cross-resource references and status aggregation | Maintained through optional fields | Medium - requires coordination protocols |\n| Admission Policy Extensions | Webhook composition with policy plugins | Preserved through additive validation | High - independent policy modules |\n| Status Reporting Extensions | Custom condition types and metrics | Compatible through condition namespacing | High - independent status providers |\n| Reconciliation Strategies | Pluggable reconcilers with common interfaces | Maintained through interface versioning | Medium - shared interface contracts |\n\n#### Custom Resource Extensions\n\nThe most natural extension point involves adding new custom resource definitions that complement the existing `Database` resource. These extensions should follow the established patterns for schema design, status reporting, and controller integration while addressing new operational requirements.\n\n> **Design Insight**: New custom resources should be designed as first-class citizens rather than sub-resources or configuration options within existing types. This approach provides cleaner separation of concerns, independent versioning capabilities, and clearer RBAC boundaries.\n\nCommon custom resource extensions include:\n\n**Backup Resources** that manage backup policies and execution schedules independently of database lifecycle management. A `DatabaseBackup` resource would reference `Database` instances through owner references or explicit references, allowing backup policies to be managed by different teams or systems while integrating with the database operator's status reporting.\n\n**Migration Resources** that handle database schema changes and data migrations with their own reconciliation logic and status tracking. A `DatabaseMigration` resource would coordinate with `Database` controllers to ensure migrations execute during appropriate maintenance windows and update database status to reflect migration completion.\n\n**Monitoring Resources** that configure observability and alerting for database instances based on operational requirements that may change independently of database configuration. A `DatabaseMonitor` resource would manage metrics collection, alert rules, and dashboard configuration while integrating with the database operator's health reporting.\n\n| Resource Extension | Primary Responsibility | Integration Points | Status Reporting |\n|---|---|---|---|\n| `DatabaseBackup` | Backup policy and execution | Owner references to `Database`, shared storage | Backup completion, schedule adherence |\n| `DatabaseMigration` | Schema version management | Database readiness conditions, maintenance windows | Migration progress, rollback capability |\n| `DatabaseMonitor` | Observability configuration | Database health status, performance metrics | Monitor health, alert firing status |\n| `DatabaseCluster` | Multi-instance coordination | Database instance membership, leader election | Cluster topology, split-brain detection |\n\n#### Controller Composition Strategies\n\nAs new custom resources are added, the controller architecture must accommodate multiple reconciliation loops that may need to coordinate their actions. The key architectural decision involves balancing controller isolation with cross-resource coordination requirements.\n\n> **Decision: Multi-Controller Architecture**\n> - **Context**: Additional custom resources require their own reconciliation logic while maintaining coordination with existing database controllers\n> - **Options Considered**:\n>   1. Single controller handling all resource types with shared reconciliation logic\n>   2. Separate controllers per resource type with event-based coordination\n>   3. Controller hierarchy with primary controller coordinating secondary controllers\n> - **Decision**: Separate controllers per resource type with well-defined coordination protocols through status conditions and owner references\n> - **Rationale**: This approach maximizes development isolation, enables independent testing and deployment of new controllers, and leverages Kubernetes' native coordination mechanisms\n> - **Consequences**: Each controller can be developed and maintained independently, but coordination protocols must be carefully designed to prevent race conditions and inconsistent state\n\nThe controller composition strategy relies on several coordination mechanisms that build upon Kubernetes' native patterns:\n\n**Owner Reference Coordination** establishes parent-child relationships between resources, ensuring that backup resources are automatically garbage-collected when their associated database is deleted. This pattern also enables status aggregation, where parent resources can report the health of their children through aggregated conditions.\n\n**Status Condition Protocols** define standard condition types and status values that controllers use to communicate their state to other controllers. For example, a database controller might set a `MaintenanceWindow` condition that migration controllers watch before executing schema changes.\n\n**Event-Based Coordination** leverages Kubernetes events and controller watches to trigger cross-controller actions. When a database controller detects a configuration change that requires backup policy updates, it can emit an event that backup controllers watch and respond to appropriately.\n\n| Coordination Mechanism | Implementation | Consistency Guarantees | Error Handling |\n|---|---|---|---|\n| Owner References | Automatic garbage collection | Eventually consistent cleanup | Finalizers for cleanup ordering |\n| Status Conditions | Cross-controller status sharing | Optimistically consistent status | Condition-based retry logic |\n| Event Watching | Cross-resource change detection | At-least-once event delivery | Event deduplication in handlers |\n| Shared ConfigMaps | Configuration coordination | Read-your-writes consistency | Conflict resolution strategies |\n\n#### Admission Webhook Composition\n\nAs operators evolve to handle additional resource types and more sophisticated validation requirements, admission webhook architecture must support composable validation and mutation policies. The key challenge involves maintaining performance and reliability while adding new admission logic.\n\nThe webhook composition strategy builds upon the foundation established in Milestone 4 while providing extension points for new validation scenarios:\n\n**Policy Plugin Architecture** allows new validation rules to be added without modifying core webhook code. Each policy plugin registers with the webhook server and receives admission requests for relevant resource types, enabling independent development and testing of specialized validation logic.\n\n**Validation Pipeline Composition** enables multiple validation stages to be applied to the same resource, with each stage having the opportunity to add conditions, modify the admission response, or trigger additional validation steps based on resource content and cluster state.\n\n**Cross-Resource Validation** supports validation rules that depend on the state of multiple resources, such as ensuring that backup schedules don't conflict with maintenance windows or verifying that migration resources reference valid database instances.\n\n| Webhook Extension | Validation Scope | Performance Impact | Failure Isolation |\n|---|---|---|---|\n| Policy Plugins | Resource-specific business rules | Low - parallel validation | High - plugin failures don't affect others |\n| Pipeline Composition | Multi-stage validation workflows | Medium - sequential processing | Medium - early stage failures abort pipeline |\n| Cross-Resource Validation | Cluster-wide consistency rules | High - requires additional API calls | Low - API failures affect all validation |\n| Dynamic Policy Loading | Runtime policy updates | Low - cached policy evaluation | High - invalid policies isolated to specific requests |\n\n### Scaling and Performance\n\nAs operators mature and manage larger numbers of resources across more clusters, performance characteristics become critical operational concerns. The scaling strategy must address both horizontal scaling (handling more resources) and vertical scaling (handling more complex resources) while maintaining the reliability and consistency guarantees established in the initial implementation.\n\n### Mental Model: The Air Traffic Control System\n\nConsider how air traffic control systems handle increasing flight volumes. Rather than building larger and larger central control towers, the system is partitioned geographically with regional controllers handling local airspace while coordinating with adjacent regions for aircraft transitions. Each controller has local authority within their domain but follows standardized protocols for inter-region coordination.\n\nSimilarly, operator scaling strategies should partition the problem space rather than simply adding more computational resources to a monolithic controller. This partitioning can occur along resource boundaries (different controllers for different resource types), geographic boundaries (controllers scoped to specific regions or availability zones), or tenant boundaries (controllers scoped to specific namespaces or organizational units).\n\n#### Horizontal Scaling Strategies\n\nThe foundation for horizontal scaling lies in the informer and workqueue architecture established in Milestone 2. However, as the number of managed resources grows, several bottlenecks emerge that require architectural evolution.\n\n> **Decision: Controller Sharding Strategy**\n> - **Context**: Single controller instances become CPU and memory bottlenecks when managing thousands of resources, and Kubernetes API server rate limiting affects reconciliation latency\n> - **Options Considered**:\n>   1. Vertical scaling with larger controller instances and more aggressive caching\n>   2. Resource-based sharding with multiple controller instances handling disjoint resource sets\n>   3. Namespace-based sharding with controllers scoped to specific namespace sets\n> - **Decision**: Hybrid sharding approach supporting both resource-based and namespace-based partitioning depending on deployment requirements\n> - **Rationale**: This approach provides flexibility for different scaling scenarios while maintaining compatibility with existing single-controller deployments\n> - **Consequences**: Sharding logic adds complexity to deployment and coordination, but enables near-linear scaling with resource counts\n\n**Resource-Based Sharding** partitions resources across multiple controller instances using consistent hashing or explicit assignment strategies. Each controller instance handles a subset of all resources, reducing per-instance memory usage and API server load while maintaining independent reconciliation loops.\n\nThe sharding implementation extends the controller manager pattern with shard-aware resource filtering:\n\n| Sharding Strategy | Resource Distribution | Coordination Requirements | Rebalancing Complexity |\n|---|---|---|---|\n| Hash-Based Sharding | Consistent hash of resource name/namespace | None - independent shards | Medium - requires hash function changes |\n| Range-Based Sharding | Alphabetical or numerical resource ranges | Shard boundary coordination | High - requires resource migration |\n| Label-Based Sharding | Resources tagged with shard identifiers | Shard assignment coordination | Low - label changes trigger rebalancing |\n| Namespace Sharding | Controller scope limited to namespace sets | Cross-namespace resource coordination | Medium - namespace assignment changes |\n\n**Leader Election Evolution** becomes more sophisticated in sharded deployments, where each shard requires independent leader election to ensure exactly one active controller per shard while supporting shard-level failover and rebalancing.\n\nThe leader election strategy builds upon the foundation from Milestone 5 but adds shard awareness:\n\n```\nShard Assignment:\n- Controller instances register with shard coordinator\n- Coordinator assigns responsibility for resource ranges\n- Each shard maintains independent leader election\n- Failed shards trigger automatic rebalancing\n\nFailover Behavior:\n- Shard leader failures trigger immediate re-election\n- Shard coordinator failures trigger shard assignment redistribution\n- Controller instance failures trigger shard responsibility transfer\n```\n\n#### Performance Optimization Strategies\n\nBeyond horizontal scaling, several performance optimization strategies address the computational and memory efficiency of individual controller instances. These optimizations build upon the informer and reconciliation patterns while reducing unnecessary work and improving resource utilization.\n\n**Informer Cache Optimization** reduces memory usage and improves cache efficiency through selective caching strategies that store only the resource fields needed for reconciliation decisions rather than complete resource objects.\n\n**Reconciliation Batching** groups related reconciliation operations to reduce API server round trips and improve throughput for scenarios where multiple resources can be processed together efficiently.\n\n**Incremental Reconciliation** tracks resource changes at a finer granularity to avoid unnecessary reconciliation work when only status fields or irrelevant metadata changes occur.\n\n| Optimization Strategy | Memory Impact | Latency Impact | Complexity Cost |\n|---|---|---|---|\n| Selective Field Caching | 50-80% reduction | Minimal increase | Medium - requires field selection logic |\n| Reconciliation Batching | Minimal change | 30-60% reduction | High - requires dependency analysis |\n| Incremental Reconciliation | 20-40% reduction | 40-70% reduction | Medium - requires change detection logic |\n| Status-Only Updates | Minimal change | 20-30% reduction | Low - separate status client usage |\n\n#### Multi-Cluster Operations\n\nAs organizations adopt multi-cluster Kubernetes deployments, operators must evolve to handle resources that span cluster boundaries while maintaining consistency and coordination across distributed infrastructure.\n\nThe multi-cluster architecture builds upon single-cluster patterns while adding cluster-aware coordination:\n\n**Cluster-Scoped Controllers** manage resources within individual clusters while reporting status to cluster-wide coordination systems. Each cluster maintains its own controller instances that handle local reconciliation while participating in cross-cluster coordination protocols.\n\n**Federation Controllers** coordinate resources across multiple clusters, making placement decisions, managing resource distribution, and aggregating status information from cluster-scoped controllers.\n\n**Cross-Cluster Networking** handles the connectivity and service discovery requirements for resources that span cluster boundaries, such as database clusters with instances in multiple availability zones or regions.\n\n| Multi-Cluster Pattern | Coordination Mechanism | Consistency Model | Failure Handling |\n|---|---|---|---|\n| Hub-and-Spoke | Central controller with cluster agents | Eventually consistent | Hub failure affects coordination only |\n| Peer-to-Peer | Direct cluster-to-cluster communication | Conflict-free replicated data types | Network partitions require conflict resolution |\n| Event-Driven | Message queue coordination | At-least-once processing | Message delivery guarantees vary by queue |\n| GitOps-Based | Configuration repository coordination | Strong consistency for desired state | Repository availability affects updates |\n\n⚠️ **Pitfall: Distributed State Consistency**\n\nA common mistake in multi-cluster operators involves assuming that status updates across clusters will be immediately consistent. This leads to race conditions where controllers make decisions based on stale information from other clusters, resulting in resource conflicts or inconsistent resource placement.\n\nThe solution involves designing coordination protocols that explicitly handle eventual consistency through techniques like vector clocks for causality tracking, conflict-free replicated data types for status aggregation, and idempotent operations that produce correct results regardless of message ordering or duplication.\n\n### Implementation Guidance\n\nThe extension and scaling strategies described above require careful implementation planning to ensure that new capabilities integrate cleanly with existing operator patterns while maintaining operational stability.\n\n#### Technology Recommendations\n\n| Scaling Challenge | Simple Option | Advanced Option |\n|---|---|---|\n| Controller Sharding | Label-based shard assignment with manual configuration | Consistent hashing with automatic rebalancing using controller-runtime's cluster caching |\n| Multi-Cluster Coordination | Shared ConfigMaps in hub cluster | Admiral service mesh integration with cross-cluster service discovery |\n| Performance Monitoring | Prometheus metrics with basic controller dashboards | Custom resource status aggregation with SLI/SLO tracking |\n| Extension Development | In-tree plugins with interface definitions | Out-of-tree controllers with standardized coordination protocols |\n\n#### Recommended Project Structure\n\nExtensions should follow a modular structure that isolates new functionality while integrating with the core operator patterns:\n\n```\nproject-root/\n  cmd/\n    database-operator/main.go          ← core operator entry point\n    backup-controller/main.go          ← backup extension controller\n    migration-controller/main.go       ← migration extension controller\n  apis/\n    database/v1/                       ← core database CRD\n    backup/v1/                         ← backup extension CRD\n    migration/v1/                      ← migration extension CRD\n  internal/\n    controller/\n      database/                        ← core reconciliation logic\n        database_controller.go\n        status_manager.go\n      backup/                          ← backup extension logic\n        backup_controller.go\n        schedule_manager.go\n      migration/                       ← migration extension logic\n        migration_controller.go\n        version_manager.go\n    webhook/\n      database/                        ← core admission logic\n      common/                          ← shared webhook utilities\n        policy_engine.go\n        validation_pipeline.go\n    coordination/                      ← cross-controller coordination\n      owner_reference.go\n      status_aggregation.go\n      event_coordination.go\n  config/\n    core/                             ← base operator manifests\n    extensions/                       ← extension-specific manifests\n    samples/                          ← example configurations\n```\n\n#### Extension Development Framework\n\nThe extension framework provides standardized interfaces and utilities that new controllers can implement to integrate seamlessly with the core operator:\n\n```go\n// ExtensionController defines the interface that all extension controllers must implement\n// to participate in the operator's coordination protocols and lifecycle management.\ntype ExtensionController interface {\n    // SetupWithManager registers the extension controller with the controller manager\n    // and configures watches for relevant resource types.\n    SetupWithManager(mgr ctrl.Manager) error\n    \n    // GetCoordinationSpecs returns the coordination requirements for this controller,\n    // including which resources it owns, which status conditions it reports, and\n    // which cross-controller events it needs to receive.\n    GetCoordinationSpecs() CoordinationSpecs\n    \n    // HandleCoordinationEvent processes events from other controllers that may\n    // trigger reconciliation or status updates in this controller.\n    HandleCoordinationEvent(ctx context.Context, event CoordinationEvent) error\n    \n    // GetHealthStatus returns the current health and performance metrics for\n    // this controller instance, used for monitoring and debugging.\n    GetHealthStatus() HealthStatus\n}\n\n// CoordinationSpecs defines how an extension controller participates in\n// cross-controller coordination and status aggregation.\ntype CoordinationSpecs struct {\n    // OwnedResources lists the resource types this controller creates and manages\n    OwnedResources []schema.GroupVersionKind\n    \n    // StatusConditions lists the condition types this controller reports\n    StatusConditions []string\n    \n    // WatchedConditions lists condition types from other controllers that\n    // trigger reconciliation in this controller\n    WatchedConditions []string\n    \n    // EmittedEvents lists event types this controller emits for coordination\n    EmittedEvents []string\n}\n```\n\n#### Sharding Implementation Framework\n\nThe sharding framework extends the controller-runtime manager with shard-aware resource filtering and leader election:\n\n```go\n// ShardingManager extends the controller-runtime manager with shard-aware\n// resource filtering and coordination capabilities.\ntype ShardingManager struct {\n    // Manager is the underlying controller-runtime manager\n    ctrl.Manager\n    \n    // ShardID identifies this controller instance's shard assignment\n    ShardID string\n    \n    // ShardingStrategy determines how resources are assigned to shards\n    ShardingStrategy ShardingStrategy\n    \n    // CoordinationClient handles shard assignment and rebalancing\n    CoordinationClient ShardCoordinator\n}\n\n// ShardingStrategy defines how resources are partitioned across controller instances\ntype ShardingStrategy interface {\n    // AssignShard determines which shard should handle a given resource\n    AssignShard(resource client.Object) string\n    \n    // IsAssignedToShard returns true if the resource should be handled by the given shard\n    IsAssignedToShard(resource client.Object, shardID string) bool\n    \n    // RebalanceShards redistributes resources across available shards\n    RebalanceShards(availableShards []string) (ShardAssignments, error)\n}\n```\n\n#### Performance Monitoring Integration\n\nThe performance monitoring framework provides standardized metrics collection and alerting for operator scaling scenarios:\n\n```go\n// PerformanceMetrics provides standardized metrics collection for operator scaling\ntype PerformanceMetrics struct {\n    // ReconciliationDuration tracks time spent in reconciliation loops\n    ReconciliationDuration prometheus.HistogramVec\n    \n    // ResourceCacheSize tracks informer cache memory usage\n    ResourceCacheSize prometheus.GaugeVec\n    \n    // WorkqueueDepth tracks pending reconciliation requests\n    WorkqueueDepth prometheus.GaugeVec\n    \n    // APIServerLatency tracks Kubernetes API call performance\n    APIServerLatency prometheus.HistogramVec\n    \n    // ShardDistribution tracks resource distribution across shards\n    ShardDistribution prometheus.GaugeVec\n}\n\n// RecordReconciliation records metrics for a completed reconciliation operation\nfunc (m *PerformanceMetrics) RecordReconciliation(\n    controllerName string,\n    resourceType string,\n    duration time.Duration,\n    result string,\n) {\n    // TODO 1: Record reconciliation duration in histogram with controller/type/result labels\n    // TODO 2: Update workqueue depth gauge to reflect current queue size\n    // TODO 3: Record any API server calls made during reconciliation\n    // Hint: Use prometheus labels to enable per-controller and per-resource-type analysis\n}\n```\n\n#### Milestone Checkpoints\n\n**Extension Development Checkpoint:**\nAfter implementing a new extension controller, verify the integration by:\n1. Deploying the extension alongside the core operator: `kubectl apply -f config/extensions/backup-controller/`\n2. Creating a test resource that should trigger coordination: `kubectl apply -f config/samples/backup_v1_databasebackup.yaml`\n3. Verifying cross-controller coordination through status conditions: `kubectl get database test-db -o jsonpath='{.status.conditions[?(@.type==\"BackupReady\")]}'`\n4. Checking coordination events in controller logs: `kubectl logs -l app=database-operator | grep \"coordination.event\"`\n\n**Scaling Checkpoint:**\nAfter implementing controller sharding, verify the scaling behavior by:\n1. Deploy multiple controller replicas with sharding enabled: `kubectl scale deployment database-operator --replicas=3`\n2. Create multiple test resources across different namespaces: `kubectl apply -f config/samples/scaling-test/`\n3. Verify shard assignment distribution: `kubectl logs -l app=database-operator | grep \"shard.assignment\"`\n4. Monitor performance metrics during scale testing: `curl http://localhost:8080/metrics | grep reconciliation_duration`\n\n**Performance Checkpoint:**\nAfter implementing performance optimizations, validate the improvements by:\n1. Establish baseline metrics with unoptimized operator: Deploy operator, create 100 test resources, measure reconciliation latency\n2. Deploy optimized operator version with same test resources\n3. Compare reconciliation performance: Expected 30-50% reduction in reconciliation duration\n4. Verify memory usage improvements: Expected 40-60% reduction in controller memory usage\n5. Validate correctness: All resources should reach Ready condition within expected timeframes\n\n\n## Glossary\n\n> **Milestone(s):** All milestones - provides definitions of Kubernetes, operator, and distributed systems terminology used throughout the entire operator implementation process\n\nThis glossary defines the technical terminology used throughout this design document. Understanding these concepts is essential for successfully implementing a Kubernetes operator. The terms are organized into categories to help build conceptual understanding of how different pieces of the operator pattern connect together.\n\n### Mental Model: The Specialized Dictionary\n\nThink of this glossary like a specialized technical dictionary for a specific engineering discipline. Just as aerospace engineers have precise definitions for \"thrust,\" \"drag,\" and \"lift\" that might differ slightly from common usage, Kubernetes operators use terms like \"reconciliation,\" \"admission,\" and \"informer\" with very specific technical meanings. This glossary provides those precise definitions to prevent confusion when reading documentation or discussing implementation details with other engineers.\n\nThe terminology forms layers of abstraction, from low-level Kubernetes primitives up to operator-specific patterns. Understanding these layers helps you navigate between different levels of detail when designing and troubleshooting your operator.\n\n### Kubernetes Core Concepts\n\nThese fundamental Kubernetes terms form the foundation that operators build upon. Every operator developer must understand these concepts deeply.\n\n| Term | Definition | Why It Matters |\n|------|------------|----------------|\n| **API Server** | Central component of Kubernetes control plane that exposes REST API for all cluster operations and stores cluster state in etcd | Operators interact with this component for all resource operations - understanding its role helps debug API errors and performance issues |\n| **Custom Resource Definition (CRD)** | API extension defining new resource types with OpenAPI v3 schema validation that extends Kubernetes API without modifying core code | CRDs are how operators introduce new APIs - poorly designed CRDs create maintenance headaches and user experience problems |\n| **Custom Resource (CR)** | Instance of a custom resource type defined by a CRD, stored in etcd and accessible through standard Kubernetes API operations | These are the resources your operator manages - understanding their lifecycle helps design better reconciliation logic |\n| **Resource Version** | Monotonically increasing identifier for resource modifications used for optimistic locking and conflict detection | Critical for handling concurrent updates - ignoring resource versions leads to lost updates and race conditions |\n| **Owner Reference** | Metadata field establishing parent-child relationships between resources for automatic garbage collection | Prevents resource leaks when parent resources are deleted - improper owner references cause cleanup failures |\n| **Finalizer** | Metadata field preventing resource deletion until cleanup operations complete, allowing controllers to perform cleanup before removal | Essential for managing external resources - forgetting to remove finalizers causes resources to stuck in deletion |\n| **Namespace** | Virtual cluster that provides scope for resource names and RBAC policies, enabling multi-tenancy within a single cluster | Affects controller permissions and resource isolation - namespace design impacts operator security model |\n| **Service Account** | Identity for processes running in pods, used for authentication and authorization with the Kubernetes API | Operators run under service accounts - understanding this helps design proper RBAC policies |\n| **RBAC (Role-Based Access Control)** | Authorization mechanism controlling what operations service accounts can perform on specific resources | Operators need carefully scoped permissions - overly broad RBAC creates security risks |\n\n### Controller Pattern Concepts\n\nThe controller pattern is the heart of Kubernetes operators. These terms describe the continuous reconciliation process that makes operators work.\n\n| Term | Definition | Why It Matters |\n|------|------------|----------------|\n| **Controller** | Software component implementing a control loop that continuously observes cluster state and takes corrective actions to maintain desired state | The core of every operator - understanding controller design patterns helps build robust, efficient operators |\n| **Reconciliation** | Process of making actual state match desired state through continuous comparison and correction, implementing the controller's primary logic | This is what makes operators \"smart\" - poor reconciliation logic causes performance problems and incorrect behavior |\n| **Control Loop** | Continuous cycle of observing current state, comparing to desired state, and taking corrective action to eliminate differences | Understanding control loops helps design operators that converge reliably without oscillation or instability |\n| **Desired State** | Target configuration specified in resource spec fields that the controller works to achieve and maintain | Controllers compare actual state against this - unclear desired state specifications lead to unpredictable behavior |\n| **Actual State** | Current state of managed resources as observed through API server queries and external system inspection | Controllers must accurately determine actual state - incorrect state detection leads to unnecessary reconciliation work |\n| **Event-Driven Architecture** | Design pattern where controllers react to resource change events rather than continuously polling for changes | Enables efficient operators that respond quickly to changes - polling-based designs waste resources and respond slowly |\n| **Declarative Management** | Approach where users specify desired end state rather than imperative steps, letting the controller determine how to achieve that state | Makes operators easier to use and more reliable - imperative approaches are harder to reason about and recover from failures |\n\n### Informer and Caching Architecture\n\nInformers provide the efficient event-driven foundation that controllers build on. Understanding these concepts is crucial for performance and correctness.\n\n| Term | Definition | Why It Matters |\n|------|------------|----------------|\n| **Informer** | Client-side cache that watches API server events and maintains a local copy of resources, providing efficient reads without API server load | Enables scalable controllers - direct API server queries for every operation create performance bottlenecks |\n| **Shared Index Informer** | Informer implementation that allows multiple controllers to share the same cache and watch streams, reducing memory usage and API server load | Multiple controllers can efficiently watch the same resource types - separate informers waste memory and network bandwidth |\n| **List-Watch Pattern** | API pattern where clients first list all resources then watch for subsequent changes, providing consistent event streams | Foundation of Kubernetes event system - understanding this helps debug informer sync issues and cache inconsistencies |\n| **Resync Period** | Interval at which informers re-list all resources to ensure cache consistency and recover from missed events | Balances cache freshness with API server load - too frequent causes load, too infrequent causes stale cache issues |\n| **Cache Sync** | Process where informer cache becomes consistent with API server state before processing events, ensuring controllers don't act on incomplete data | Controllers must wait for cache sync - processing events before sync completion can cause incorrect reconciliation decisions |\n| **Index Function** | Custom function that creates secondary indexes on cached resources for efficient lookups by fields other than name/namespace | Enables efficient queries like \"find all pods with label X\" - missing indexes force expensive linear searches |\n| **Event Handler** | Function called when informer detects resource changes, typically enqueueing reconcile requests for later processing | Bridges informer events to controller work queues - blocking in event handlers causes event processing delays |\n\n### Work Queue and Scheduling\n\nWork queues provide reliable, ordered processing of reconciliation requests with proper error handling and rate limiting.\n\n| Term | Definition | Why It Matters |\n|------|------------|----------------|\n| **Work Queue** | Thread-safe queue that buffers reconcile requests and provides features like rate limiting, exponential backoff, and duplicate detection | Prevents overwhelming controllers with requests - poor queue management causes performance problems and resource exhaustion |\n| **Rate Limiting** | Mechanism that controls how frequently items can be processed from the work queue, preventing resource exhaustion during high load | Protects controllers and API server from overload - missing rate limiting can cause cascade failures |\n| **Exponential Backoff** | Retry strategy that increases delay between attempts exponentially, preventing overwhelming failing systems with repeated requests | Essential for handling transient failures gracefully - linear backoff can worsen system overload conditions |\n| **Jitter** | Random variation added to retry delays to prevent multiple controllers from retrying simultaneously and creating thundering herd effects | Distributes retry load over time - without jitter, synchronized retries can overwhelm recovering systems |\n| **Requeue** | Operation that adds a reconcile request back to the work queue for processing after a delay, used for retry logic and periodic reconciliation | Enables robust error handling and state drift correction - improper requeue logic causes infinite loops or missed updates |\n| **Deduplication** | Work queue feature that prevents duplicate reconcile requests for the same resource from being processed simultaneously | Improves efficiency and prevents conflicting reconciliation attempts - missing deduplication wastes controller resources |\n\n### Reconciliation Logic Patterns\n\nThese patterns describe common approaches for implementing robust reconciliation logic that handles complex state management scenarios.\n\n| Term | Definition | Why It Matters |\n|------|------------|----------------|\n| **Idempotent Operation** | Operation that produces the same result when called multiple times with the same input, essential for reliable reconciliation | Controllers may reconcile the same resource multiple times - non-idempotent operations cause inconsistent state |\n| **Three-Way Merge** | Reconciliation pattern that compares desired state, current state, and last-applied state to determine minimal changes needed | Enables efficient updates that preserve user modifications while applying operator changes |\n| **Drift Detection** | Process of identifying when actual state has diverged from desired state due to external changes or system issues | Allows operators to correct configuration drift - without drift detection, external changes persist indefinitely |\n| **State Machine** | Model where resources transition through well-defined states with specific triggers and actions for each transition | Simplifies complex lifecycle management - ad-hoc state handling leads to bugs and unpredictable behavior |\n| **Condition Types** | Standardized status fields that report specific aspects of resource state like `Ready`, `Progressing`, and `Degraded` | Provides consistent status reporting across different resource types - improper condition usage confuses users |\n| **Phase** | High-level resource lifecycle state like `Pending`, `Running`, `Failed` that summarizes overall resource condition | Gives users quick understanding of resource health - inconsistent phase reporting makes troubleshooting difficult |\n| **Generation** | Counter that increments when resource spec changes, used to track which changes have been processed | Helps controllers track which spec changes they've reconciled - ignoring generation can cause missed updates |\n| **Observed Generation** | Generation number that controller has successfully processed, reported in resource status | Shows users that their spec changes have been applied - missing observed generation updates confuse users about operator responsiveness |\n\n### Admission Control and Webhooks\n\nAdmission webhooks provide validation and mutation capabilities that run during resource creation and updates, implementing the \"gatekeeper pattern\" for resource operations.\n\n| Term | Definition | Why It Matters |\n|------|------------|----------------|\n| **Admission Controller** | Component in Kubernetes API server request processing pipeline that can validate, mutate, or deny resource operations | Understanding admission flow helps design webhooks that integrate properly with other admission controllers |\n| **Admission Webhook** | HTTP endpoint that receives admission review requests from the API server to validate or mutate resources before they are stored | Extends Kubernetes with custom validation and defaulting logic - webhook failures can block all resource operations |\n| **Validating Webhook** | Admission webhook that can approve or deny resource operations but cannot modify the resources being processed | Enforces business rules and constraints - failing validation provides immediate feedback to users |\n| **Mutating Webhook** | Admission webhook that can modify resources before they are stored in etcd, typically used for injecting default values | Provides consistent defaulting and transformation - mutation order matters when multiple webhooks modify the same resource |\n| **Admission Review** | Kubernetes API object containing resource data and metadata that is sent to webhooks for processing | Understanding this structure is essential for implementing webhook handlers correctly |\n| **Admission Response** | Object returned by webhooks indicating whether to allow the operation and any mutations to apply | Proper response formatting ensures API server processes webhook decisions correctly |\n| **JSON Patch** | RFC 6902 standard for describing changes to JSON documents using operations like add, replace, and remove | Mutating webhooks use JSON patches to specify resource modifications - incorrect patches cause admission failures |\n| **Strategic Merge Patch** | Kubernetes-specific patch format that understands resource schema and can merge lists intelligently | Used internally by kubectl and controllers for resource updates - understanding helps debug update conflicts |\n\n### TLS and Certificate Management\n\nWebhooks require HTTPS communication, making certificate management a critical operational concern for operators.\n\n| Term | Definition | Why It Matters |\n|------|------------|----------------|\n| **TLS Certificate** | X.509 certificate used to establish encrypted HTTPS connections between API server and admission webhooks | Required for webhook security - certificate issues prevent webhook operations and can block cluster operations |\n| **Certificate Authority (CA)** | Entity that signs certificates, establishing trust relationships for TLS connections | Webhook certificates must be trusted by the API server - CA configuration errors prevent webhook communication |\n| **Subject Alternative Name (SAN)** | Certificate extension that specifies additional identities the certificate is valid for, including DNS names and IP addresses | Webhook certificates must have correct SAN entries for service names - missing SANs cause TLS verification failures |\n| **Certificate Rotation** | Process of automatically renewing and replacing TLS certificates before they expire to maintain service availability | Prevents webhook outages from certificate expiration - manual certificate management is error-prone and operationally expensive |\n| **Cert-Manager** | Kubernetes operator that automates certificate lifecycle management including provisioning, renewal, and distribution | Simplifies webhook certificate management - manual certificate handling creates operational burden |\n| **Self-Signed Certificate** | Certificate signed by its own private key rather than a certificate authority, useful for development and testing | Acceptable for development but requires careful CA bundle management - production should use proper CA-signed certificates |\n\n### Error Handling and Reliability Patterns\n\nRobust operators must handle various failure modes gracefully while maintaining system stability and providing clear diagnostics.\n\n| Term | Definition | Why It Matters |\n|------|------------|----------------|\n| **Transient Error** | Temporary failure that is likely to succeed if retried after a delay, such as network timeouts or resource conflicts | Should trigger exponential backoff retry - treating transient errors as permanent wastes reconciliation opportunities |\n| **Permanent Error** | Failure that will not succeed if retried without external intervention, such as validation errors or missing permissions | Should not trigger automatic retry - permanent error retry wastes resources and creates noise in logs |\n| **Circuit Breaker** | Pattern that temporarily stops calling a failing service to prevent cascading failures and allow recovery time | Protects external dependencies from overload - missing circuit breakers can cause widespread system failures |\n| **Graceful Degradation** | Approach where systems continue operating with reduced functionality when components fail rather than failing completely | Maintains service availability during partial failures - brittle systems cause unnecessary outages |\n| **Error Classification** | Process of categorizing errors by type, severity, and appropriate response to enable proper handling strategies | Enables appropriate retry and escalation behavior - poor error classification leads to incorrect recovery actions |\n| **Leader Election** | Distributed coordination mechanism that ensures only one controller replica actively reconciles resources at any time | Prevents split-brain scenarios in high availability deployments - missing leader election causes resource conflicts |\n| **Lease Object** | Kubernetes resource used for leader election coordination, containing holder identity and renewal timestamp | Provides distributed locking primitive - lease configuration affects failover time and split-brain risk |\n\n### Testing and Validation Concepts\n\nComprehensive testing ensures operator reliability and helps catch regressions during development and maintenance.\n\n| Term | Definition | Why It Matters |\n|------|------------|----------------|\n| **Fake Client** | Test implementation of Kubernetes client that simulates API server behavior without requiring a real cluster | Enables fast unit tests that verify controller logic in isolation - real cluster tests are slow and harder to control |\n| **Envtest** | Testing framework that runs a real Kubernetes API server in-process for integration testing without full cluster setup | Provides realistic testing environment without operational complexity - catches integration issues that unit tests miss |\n| **Test Double** | Generic term for fake objects used in testing, including mocks, stubs, and fakes | Isolates code under test from dependencies - improper test doubles can hide real integration problems |\n| **Contract Test** | Test that verifies component interfaces and behavior contracts without testing implementation details | Ensures components integrate correctly - implementation-focused tests break when refactoring |\n| **Chaos Testing** | Testing approach that introduces random failures to verify system resilience and recovery behavior | Validates error handling and recovery logic - systems often fail in unexpected ways during real outages |\n| **Property-Based Testing** | Testing technique that verifies system properties hold across a wide range of generated inputs | Finds edge cases that example-based tests miss - especially valuable for testing reconciliation logic |\n\n### Deployment and Operations\n\nProduction operators require careful attention to security, observability, and operational concerns beyond basic functionality.\n\n| Term | Definition | Why It Matters |\n|------|------------|----------------|\n| **Principle of Least Privilege** | Security practice of granting the minimum permissions necessary for operation, reducing blast radius of security breaches | Minimizes security risk from compromised operator - overly broad permissions increase attack surface |\n| **ClusterRole vs Role** | RBAC distinction between cluster-scoped permissions (ClusterRole) and namespace-scoped permissions (Role) | Affects security isolation and operator deployment model - wrong scope causes permission errors or security violations |\n| **Service Account Token** | JWT token that provides authentication credentials for processes running in pods | Enables operator authentication with API server - token management affects security and reliability |\n| **Pod Security Standards** | Kubernetes security policies that control pod security contexts and capabilities | Affects how operator pods can run - restrictive policies may prevent operator functionality |\n| **Resource Quota** | Kubernetes mechanism that limits resource consumption within namespaces | Can prevent operator from creating resources - understanding quotas helps design operators that work within limits |\n| **Network Policy** | Kubernetes resource that controls network traffic between pods using label selectors | May affect operator communication with managed resources - network restrictions can cause unexpected failures |\n| **Observability** | Practice of understanding system behavior through metrics, logging, and tracing | Essential for operating production systems - poor observability makes troubleshooting difficult and time-consuming |\n\n### Performance and Scaling Concepts\n\nAs operators manage more resources, performance and scaling considerations become increasingly important for maintaining system stability.\n\n| Term | Definition | Why It Matters |\n|------|------------|----------------|\n| **Horizontal Scaling** | Adding more controller instances to handle increased load by distributing work across multiple processes | Increases processing capacity for large resource counts - requires careful coordination to prevent conflicts |\n| **Vertical Scaling** | Increasing computational resources (CPU, memory) for individual controller instances to handle more work | Simpler than horizontal scaling but has physical limits - helps handle resource-intensive reconciliation logic |\n| **Sharding** | Technique for partitioning resources across multiple controller instances based on criteria like namespace or resource hash | Enables horizontal scaling without resource conflicts - poor sharding strategies cause load imbalances |\n| **Back Pressure** | Mechanism where overloaded components signal upstream components to slow down request rates | Prevents cascading failures during high load - missing back pressure can cause system-wide overload |\n| **Resource Pooling** | Pattern where expensive resources like database connections are shared across multiple operations | Improves efficiency and reduces resource usage - poor pooling causes resource exhaustion |\n| **Batch Processing** | Technique for grouping multiple operations together to reduce overhead and improve throughput | Reduces API server load and improves performance - batching must balance latency with efficiency |\n\n### Advanced Operator Patterns\n\nThese patterns enable sophisticated operator behaviors for complex application management scenarios.\n\n| Term | Definition | Why It Matters |\n|------|------------|----------------|\n| **Operator Composition** | Pattern where multiple operators coordinate to manage related resources without conflicts | Enables modular operator design - poor composition causes resource conflicts and inconsistent behavior |\n| **Cross-Controller Coordination** | Communication and synchronization between different controllers managing related resources | Prevents conflicts when multiple controllers affect the same resources - missing coordination causes race conditions |\n| **Multi-Tenant Operator** | Operator design that safely manages resources for multiple users or teams within the same cluster | Enables shared operator infrastructure - poor multi-tenancy creates security and isolation issues |\n| **Operator Lifecycle Management** | Practices for managing operator installation, upgrades, and removal without disrupting managed applications | Ensures smooth operator evolution - poor lifecycle management causes service disruptions during updates |\n| **Extension Points** | Architectural patterns that allow new functionality to be added to operators without modifying core code | Enables customization and ecosystem development - rigid operators are difficult to extend for specific use cases |\n| **Federation** | Pattern for managing resources across multiple Kubernetes clusters from a single control point | Enables multi-cluster operations - federation adds significant complexity and failure modes |\n\n### Common Anti-Patterns and Pitfalls\n\nUnderstanding what not to do is often as important as knowing correct approaches. These anti-patterns cause common operator reliability and performance issues.\n\n| Anti-Pattern | Description | Why It's Problematic | How to Avoid |\n|-------------|-------------|---------------------|--------------|\n| **Polling-Based Reconciliation** | Continuously checking resource state on fixed intervals rather than using event-driven updates | Wastes resources and responds slowly to changes | Use informers and event-driven architecture |\n| **Blocking Reconciliation** | Performing long-running operations synchronously in reconciliation logic without timeouts | Causes controller hangs and prevents processing other resources | Use asynchronous operations with proper timeouts |\n| **Status Thrashing** | Repeatedly updating resource status with the same values or minor variations | Creates unnecessary API server load and version conflicts | Compare current and desired status before updating |\n| **Infinite Reconciliation** | Reconciliation logic that always finds differences and requeues indefinitely | Wastes resources and prevents controller from processing other work | Ensure reconciliation can reach stable state |\n| **Missing Error Classification** | Treating all errors the same way regardless of whether they're transient or permanent | Causes inappropriate retry behavior and resource waste | Classify errors and apply appropriate handling strategies |\n| **Overly Broad RBAC** | Granting cluster-admin or excessive permissions to operators | Creates security vulnerabilities and violates least privilege | Analyze required permissions and grant minimum necessary |\n\n### Implementation Guidance\n\nUnderstanding operator terminology is essential, but applying these concepts correctly requires practical knowledge of how they map to actual code and configuration. This section provides concrete guidance for implementing the concepts defined above.\n\n#### Technology Recommendations for Operator Development\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Framework** | Raw client-go with manual informer setup | Kubebuilder or Operator SDK with scaffolding |\n| **Testing** | Standard go test with fake client | Ginkgo + Gomega with envtest integration |\n| **Logging** | Standard log package | Structured logging with logr interface |\n| **Metrics** | Basic HTTP /metrics endpoint | Prometheus metrics with controller-runtime |\n| **Webhooks** | Manual HTTP server with TLS | Kubebuilder webhook generation |\n| **RBAC** | Manual role definitions | RBAC markers with automated generation |\n\n#### Essential Go Packages for Kubernetes Operators\n\nThe Kubernetes ecosystem provides several packages that implement the concepts defined in this glossary. Understanding which packages provide which functionality helps you build operators efficiently.\n\n```go\n// Core Kubernetes client libraries\nimport (\n    \"k8s.io/client-go/kubernetes\"           // Typed client for built-in resources\n    \"k8s.io/client-go/dynamic\"              // Dynamic client for custom resources\n    \"k8s.io/client-go/tools/cache\"          // Informer and caching infrastructure\n    \"k8s.io/client-go/util/workqueue\"       // Rate-limited work queue implementation\n    \"k8s.io/client-go/tools/leaderelection\" // Leader election coordination\n)\n\n// Controller runtime - higher-level abstractions\nimport (\n    \"sigs.k8s.io/controller-runtime/pkg/manager\"    // Manager orchestrates controllers\n    \"sigs.k8s.io/controller-runtime/pkg/controller\" // Controller registration and setup\n    \"sigs.k8s.io/controller-runtime/pkg/reconcile\"  // Reconciler interface definition\n    \"sigs.k8s.io/controller-runtime/pkg/webhook\"    // Admission webhook framework\n    \"sigs.k8s.io/controller-runtime/pkg/client\"     // Unified client interface\n)\n\n// Testing infrastructure\nimport (\n    \"sigs.k8s.io/controller-runtime/pkg/envtest\"    // Integration testing with real API server\n    \"k8s.io/client-go/kubernetes/fake\"              // Fake client for unit testing\n    \"sigs.k8s.io/controller-runtime/pkg/client/fake\" // Fake client with controller-runtime\n)\n```\n\n#### Project Structure for Operator Development\n\nOrganizing operator code properly from the start prevents confusion as the project grows. This structure follows Kubernetes conventions and separates concerns appropriately.\n\n```\ndatabase-operator/\n├── cmd/\n│   └── manager/\n│       └── main.go                    # Operator entry point and manager setup\n├── api/\n│   └── v1/\n│       ├── database_types.go          # Custom resource type definitions\n│       ├── database_webhook.go        # Admission webhook implementations\n│       ├── zz_generated.deepcopy.go   # Generated deep copy methods\n│       └── groupversion_info.go       # API group and version metadata\n├── controllers/\n│   ├── database_controller.go         # Main reconciliation logic\n│   ├── database_controller_test.go    # Controller unit tests\n│   └── suite_test.go                  # Test suite setup with envtest\n├── webhooks/\n│   ├── admission_handler.go           # HTTP server for admission webhooks\n│   ├── certificate_manager.go         # TLS certificate management\n│   └── webhook_test.go                # Webhook integration tests\n├── pkg/\n│   ├── resources/                     # Resource creation and management utilities\n│   ├── conditions/                    # Condition management helpers\n│   └── errors/                        # Error classification and handling\n├── config/\n│   ├── crd/                          # Custom Resource Definition manifests\n│   ├── rbac/                         # Role and ServiceAccount definitions\n│   ├── webhook/                      # Webhook configuration manifests\n│   ├── manager/                      # Deployment and service manifests\n│   └── samples/                      # Example custom resource instances\n├── hack/\n│   ├── boilerplate.go.txt           # License header template\n│   └── tools.go                     # Build tool dependency management\n└── Makefile                         # Build, test, and deployment automation\n```\n\n#### Core Type Definitions\n\nUnderstanding how the terminology maps to actual Go types helps bridge the gap between concepts and implementation. These definitions show the essential structures every operator needs.\n\n```go\n// Reconciler implements the core reconciliation logic\ntype DatabaseReconciler struct {\n    client.Client                    // Kubernetes API client\n    Scheme *runtime.Scheme          // Resource type registry\n    Recorder record.EventRecorder   // Event recording for observability\n}\n\n// Reconcile implements the reconciliation loop for Database resources\nfunc (r *DatabaseReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {\n    // TODO: Implement reconciliation logic following control loop pattern\n    // TODO: Fetch current Database resource and handle not found errors\n    // TODO: Determine desired state from Database spec\n    // TODO: Compare actual state with desired state\n    // TODO: Create, update, or delete resources to eliminate differences\n    // TODO: Update Database status with current conditions and state\n    // TODO: Return appropriate Result for requeue or completion\n}\n```\n\n#### Debugging Command Reference\n\nWhen implementing operators, these commands help diagnose common issues by examining the cluster state and operator behavior.\n\n| Issue Type | Diagnostic Command | What It Shows |\n|------------|-------------------|---------------|\n| **CRD Issues** | `kubectl get crd databases.example.com -o yaml` | CRD definition, status, and validation schema |\n| **Resource Status** | `kubectl describe database my-database` | Resource events, conditions, and status details |\n| **Controller Logs** | `kubectl logs -n operator-system controller-manager-xxx` | Reconciliation events and error messages |\n| **Webhook Issues** | `kubectl get validatingwebhookconfigurations` | Webhook registration and configuration |\n| **RBAC Problems** | `kubectl auth can-i create databases --as=system:serviceaccount:operator-system:controller` | Permission verification |\n| **Informer Cache** | Look for \"Failed to sync cache\" in controller logs | Cache synchronization problems |\n| **Leader Election** | `kubectl get leases -n operator-system` | Current leader and lease status |\n\n#### Common Implementation Patterns\n\nThese code patterns implement the concepts defined in the glossary using idiomatic Go and Kubernetes conventions.\n\n```go\n// Error classification pattern for retry logic\nfunc (r *DatabaseReconciler) HandleReconcileError(ctx context.Context, db *Database, err error) (ctrl.Result, error) {\n    if IsTransientError(err) {\n        // Transient errors should be retried with exponential backoff\n        return ctrl.Result{RequeueAfter: CalculateBackoffDelay(err)}, nil\n    }\n    \n    if IsPermanentError(err) {\n        // Permanent errors should update status but not requeue\n        r.updateCondition(db, \"Ready\", \"False\", \"ConfigurationError\", err.Error())\n        return ctrl.Result{}, r.Status().Update(ctx, db)\n    }\n    \n    // Unknown errors are treated as transient\n    return ctrl.Result{RequeueAfter: DefaultRequeueDelay}, err\n}\n\n// Idempotent resource creation pattern\nfunc (r *DatabaseReconciler) createOrUpdateResource(ctx context.Context, desired client.Object) error {\n    existing := desired.DeepCopyObject().(client.Object)\n    err := r.Get(ctx, client.ObjectKeyFromObject(desired), existing)\n    \n    if apierrors.IsNotFound(err) {\n        // Resource doesn't exist - create it\n        return r.Create(ctx, desired)\n    } else if err != nil {\n        return err\n    }\n    \n    // Resource exists - update if different\n    if !reflect.DeepEqual(existing, desired) {\n        desired.SetResourceVersion(existing.GetResourceVersion())\n        return r.Update(ctx, desired)\n    }\n    \n    return nil // No changes needed\n}\n```\n\n#### Milestone Validation Checkpoints\n\nAfter implementing operator components, these checkpoints verify that the terminology concepts are working correctly in your implementation.\n\n**Controller Setup Validation:**\n```bash\n# Verify informer cache synchronization\nkubectl logs -n operator-system controller-manager-xxx | grep \"Starting workers\"\n\n# Check work queue processing\nkubectl logs -n operator-system controller-manager-xxx | grep \"Successfully Reconciled\"\n\n# Validate leader election\nkubectl get leases -n operator-system\n```\n\n**Admission Webhook Validation:**\n```bash\n# Test validating webhook\nkubectl apply -f - <<EOF\napiVersion: example.com/v1\nkind: Database\nmetadata:\n  name: test-validation\nspec:\n  replicas: -1  # Invalid value should be rejected\nEOF\n\n# Test mutating webhook default injection\nkubectl apply -f - <<EOF\napiVersion: example.com/v1\nkind: Database\nmetadata:\n  name: test-defaulting\nspec:\n  replicas: 3\n  # version field omitted - should be defaulted\nEOF\n\nkubectl get database test-defaulting -o yaml | grep version\n```\n\n**Status and Condition Validation:**\n```bash\n# Check condition updates\nkubectl get database my-database -o jsonpath='{.status.conditions[*].type}'\n\n# Verify observed generation tracking\nkubectl get database my-database -o jsonpath='{.metadata.generation} {.status.observedGeneration}'\n```\n\nThese validation steps ensure your operator correctly implements the patterns and concepts defined in this glossary, providing confidence that the terminology translates to working code.\n"}