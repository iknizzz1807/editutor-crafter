{"html":"<h1 id=\"leader-election-design-document\">Leader Election: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This system implements distributed leader election algorithms to coordinate cluster operations and handle node failures. The key architectural challenge is ensuring exactly one leader emerges even during network partitions, concurrent elections, and cascading failures.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all milestones - understanding the fundamental challenges that leader election solves</p>\n</blockquote>\n<h3 id=\"mental-model-parliamentary-speaker-election\">Mental Model: Parliamentary Speaker Election</h3>\n<p>Think of distributed leader election like electing a <strong>Speaker of the House</strong> in a parliament. In a parliament, hundreds of members need to coordinate their activities - scheduling debates, managing speaking time, maintaining order during votes. Without a clear authority figure, chaos would ensue with everyone talking at once, conflicting schedules, and no way to reach decisive outcomes.</p>\n<p>The <strong>Speaker</strong> serves as the single point of coordination. They have the authority to recognize speakers, call votes, and make procedural decisions. Crucially, there can only be <strong>one Speaker at a time</strong> - having multiple people claiming to be Speaker would create competing orders and parliamentary deadlock.</p>\n<p>Now imagine this parliament is spread across multiple buildings connected by an unreliable phone system. Members occasionally lose phone service, buildings get isolated due to network outages, and sometimes members simply crash (literally fall asleep at their desks). Despite these failures, the parliament must continue functioning, which means they need a <strong>robust process for electing a new Speaker</strong> whenever the current one becomes unavailable.</p>\n<p>The <strong>election process</strong> itself faces challenges: What if multiple members simultaneously notice the Speaker is unavailable and each tries to claim the role? What if the phone system partitions the parliament into two groups, each electing their own Speaker? What if a member claims to be Speaker but then immediately becomes unreachable?</p>\n<p>Just like parliamentary procedure has evolved formal rules for Speaker election (quorum requirements, nomination processes, voting protocols), distributed systems need <strong>election algorithms</strong> with precisely defined steps to ensure exactly one leader emerges even during failures and network problems.</p>\n<p>This analogy captures the essential tension: we need strong coordination (single leader) in an environment prone to communication failures and member unavailability. The algorithms we&#39;ll implement - <strong>Bully</strong> and <strong>Ring</strong> election - are like different parliamentary procedures, each with distinct approaches to achieving the same fundamental goal: establishing legitimate authority that all members recognize.</p>\n<h3 id=\"the-distributed-coordination-problem\">The Distributed Coordination Problem</h3>\n<p><strong>Leader election</strong> is a fundamental building block in distributed systems where multiple nodes must coordinate their actions through a single designated coordinator. The leader serves as the authoritative decision-maker for tasks like resource allocation, transaction coordination, task scheduling, and maintaining cluster-wide invariants.</p>\n<p>The core challenge emerges from the <strong>impossibility of instantaneous communication</strong> in distributed environments. Unlike single-machine programs where components can share memory and communicate through direct function calls, distributed nodes communicate through unreliable networks with variable latency, message loss, and potential partitions.</p>\n<h4 id=\"formal-requirements\">Formal Requirements</h4>\n<p>A correct leader election algorithm must satisfy several <strong>safety and liveness properties</strong>:</p>\n<p><strong>Safety Properties</strong> (nothing bad happens):</p>\n<ul>\n<li><strong>Uniqueness</strong>: At most one node can be the leader at any given time</li>\n<li><strong>Agreement</strong>: All non-partitioned nodes agree on the identity of the current leader  </li>\n<li><strong>Validity</strong>: Only live, reachable nodes can become leaders</li>\n</ul>\n<p><strong>Liveness Properties</strong> (something good eventually happens):</p>\n<ul>\n<li><strong>Termination</strong>: Every election eventually completes with a leader chosen</li>\n<li><strong>Progress</strong>: The system continues operating despite bounded failures</li>\n<li><strong>Availability</strong>: A new leader is elected within bounded time after the current leader fails</li>\n</ul>\n<h4 id=\"the-failure-model\">The Failure Model</h4>\n<p>Leader election algorithms must handle multiple categories of failures simultaneously:</p>\n<table>\n<thead>\n<tr>\n<th>Failure Type</th>\n<th>Description</th>\n<th>Impact on Election</th>\n<th>Detection Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Node Crash</strong></td>\n<td>Process terminates or machine shuts down</td>\n<td>Current leader becomes unavailable</td>\n<td>Heartbeat timeout</td>\n</tr>\n<tr>\n<td><strong>Network Partition</strong></td>\n<td>Subset of nodes becomes unreachable</td>\n<td>Split-brain risk with multiple leaders</td>\n<td>Connectivity matrix changes</td>\n</tr>\n<tr>\n<td><strong>Message Loss</strong></td>\n<td>Individual messages dropped during transmission</td>\n<td>Election messages don&#39;t arrive</td>\n<td>Acknowledgment timeout</td>\n</tr>\n<tr>\n<td><strong>Message Delay</strong></td>\n<td>Messages arrive after expected timeouts</td>\n<td>False failure detection</td>\n<td>Adaptive timeout tuning</td>\n</tr>\n<tr>\n<td><strong>Byzantine Faults</strong></td>\n<td>Nodes send incorrect or malicious messages</td>\n<td>Leaders may give conflicting orders</td>\n<td>Message validation (out of scope)</td>\n</tr>\n</tbody></table>\n<p>The <strong>split-brain scenario</strong> represents the most dangerous failure mode. When a network partition divides the cluster, each partition may independently elect its own leader. If both leaders continue operating, they can make conflicting decisions that violate system invariants. For example, two leaders might both grant exclusive access to the same resource, leading to data corruption.</p>\n<blockquote>\n<p><strong>Critical Insight</strong>: The fundamental tension in leader election is between <strong>availability</strong> and <strong>consistency</strong>. Aggressive failure detection ensures quick leader transitions (availability) but increases the risk of false positives that trigger unnecessary elections. Conservative failure detection reduces false positives but means longer periods without leadership during actual failures.</p>\n</blockquote>\n<h4 id=\"state-consistency-during-elections\">State Consistency During Elections</h4>\n<p>During the <strong>election period</strong>, the cluster exists in a temporary state without established leadership. This creates several coordination challenges:</p>\n<ol>\n<li><p><strong>Client Request Handling</strong>: Should nodes accept new client requests when no leader exists? Accepting requests risks inconsistency, while rejecting requests impacts availability.</p>\n</li>\n<li><p><strong>Partial Election State</strong>: Nodes may have different views of the election&#39;s progress due to message delays or losses. Some nodes might believe candidate A is winning while others support candidate B.</p>\n</li>\n<li><p><strong>Multiple Concurrent Elections</strong>: Network delays might cause multiple nodes to simultaneously detect leader failure and initiate competing elections.</p>\n</li>\n<li><p><strong>Election Termination</strong>: Nodes must reliably detect when an election completes and identify the winner, even if they missed some election messages.</p>\n</li>\n</ol>\n<p>The algorithms we implement address these challenges through different approaches to <strong>election coordination</strong> and <strong>failure handling</strong>.</p>\n<h3 id=\"comparison-of-election-algorithms\">Comparison of Election Algorithms</h3>\n<p>Different leader election algorithms make distinct trade-offs between <strong>message complexity</strong>, <strong>election latency</strong>, <strong>fault tolerance</strong>, and <strong>implementation complexity</strong>. Understanding these trade-offs is crucial for selecting the appropriate algorithm for specific system requirements.</p>\n<h4 id=\"algorithm-characteristics-matrix\">Algorithm Characteristics Matrix</h4>\n<table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Message Complexity</th>\n<th>Election Latency</th>\n<th>Fault Tolerance</th>\n<th>Network Topology</th>\n<th>Best Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Bully</strong></td>\n<td>O(n²) worst case</td>\n<td>2-3 message rounds</td>\n<td>Handles crash failures</td>\n<td>Fully connected</td>\n<td>Small clusters, stable networks</td>\n</tr>\n<tr>\n<td><strong>Ring</strong></td>\n<td>O(n) messages</td>\n<td>Full ring traversal</td>\n<td>Handles crash + partitions</td>\n<td>Logical ring</td>\n<td>Moderate clusters, predictable topology</td>\n</tr>\n<tr>\n<td><strong>Raft</strong> (future)</td>\n<td>O(n) messages</td>\n<td>Majority consensus</td>\n<td>Handles complex failures</td>\n<td>Fully connected</td>\n<td>Production systems, strong consistency</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Primary Algorithms for Implementation</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to demonstrate different approaches to distributed election with varying complexity and failure handling</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Focus only on Bully (simpler implementation, fewer concepts)</li>\n<li>Implement Bully + Ring (contrasting approaches, broader learning)</li>\n<li>Include Raft leader election (production-grade but much more complex)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement both Bully and Ring algorithms</li>\n<li><strong>Rationale</strong>: Bully teaches basic election concepts with straightforward message patterns, while Ring demonstrates token-passing approaches and topology management. Together they illustrate the fundamental design space without overwhelming complexity.</li>\n<li><strong>Consequences</strong>: Increases implementation scope but provides deeper understanding of election trade-offs. Ring algorithm requires additional topology management complexity.</li>\n</ul>\n</blockquote>\n<h4 id=\"bully-algorithm-deep-analysis\">Bully Algorithm Deep Analysis</h4>\n<p>The <strong>Bully algorithm</strong> follows a hierarchical approach where higher-priority nodes (typically those with larger numeric IDs) can &quot;bully&quot; lower-priority nodes out of leadership claims. This creates a deterministic outcome based on node priorities.</p>\n<p><strong>Algorithm Mechanics:</strong></p>\n<ol>\n<li>When a node detects leader failure, it initiates an election by sending <code>ELECTION</code> messages to all nodes with higher IDs</li>\n<li>Any higher-ID node that receives an <code>ELECTION</code> message responds with <code>OK</code> and starts its own election</li>\n<li>If a node receives any <code>OK</code> response, it abandons its election attempt</li>\n<li>If no <code>OK</code> responses arrive within a timeout, the node declares itself leader and broadcasts <code>COORDINATOR</code></li>\n<li>All nodes accept the first valid <code>COORDINATOR</code> announcement</li>\n</ol>\n<p><strong>Strengths of Bully Algorithm:</strong></p>\n<ul>\n<li><strong>Deterministic outcomes</strong>: The highest-ID live node always becomes leader</li>\n<li><strong>Simple message patterns</strong>: Only three message types (ELECTION, OK, COORDINATOR)  </li>\n<li><strong>Fast convergence</strong>: Typically completes in 2-3 message rounds</li>\n<li><strong>Clear termination</strong>: Explicit COORDINATOR broadcast signals completion</li>\n</ul>\n<p><strong>Weaknesses of Bully Algorithm:</strong></p>\n<ul>\n<li><strong>Message overhead</strong>: In worst case, generates O(n²) messages during election</li>\n<li><strong>Network dependency</strong>: Requires reliable communication between all node pairs</li>\n<li><strong>Cascading elections</strong>: High-priority node returning after failure immediately triggers new election</li>\n<li><strong>Split-brain vulnerability</strong>: Network partitions can result in multiple leaders</li>\n</ul>\n<h4 id=\"ring-election-deep-analysis\">Ring Election Deep Analysis</h4>\n<p>The <strong>Ring election algorithm</strong> organizes nodes into a logical ring topology where election tokens circulate to collect information about all live nodes before selecting a leader.</p>\n<p><strong>Algorithm Mechanics:</strong></p>\n<ol>\n<li>Nodes are arranged in a logical ring ordered by their IDs</li>\n<li>When election starts, initiating node creates a token containing its own ID</li>\n<li>Token travels around the ring, with each node adding its ID to the token</li>\n<li>When token returns to the initiator, it contains IDs of all live nodes</li>\n<li>The node with the highest ID in the token becomes the new leader</li>\n<li>A <code>COORDINATOR</code> message announces the winner to all nodes</li>\n</ol>\n<p><strong>Strengths of Ring Algorithm:</strong></p>\n<ul>\n<li><strong>Linear message complexity</strong>: Exactly O(n) messages per election</li>\n<li><strong>Comprehensive failure detection</strong>: Token collection identifies all live nodes</li>\n<li><strong>Partition tolerance</strong>: Partial rings can still elect leaders within partitions</li>\n<li><strong>Predictable message flow</strong>: Token follows well-defined path around ring</li>\n</ul>\n<p><strong>Weaknesses of Ring Algorithm:</strong></p>\n<ul>\n<li><strong>Higher latency</strong>: Requires full ring traversal before decision</li>\n<li><strong>Topology maintenance</strong>: Ring structure must be maintained as nodes join/leave</li>\n<li><strong>Single point of failure</strong>: Token loss requires election restart</li>\n<li><strong>Ring repair complexity</strong>: Failed nodes must be bypassed to maintain token flow</li>\n</ul>\n<h4 id=\"election-algorithm-selection-criteria\">Election Algorithm Selection Criteria</h4>\n<table>\n<thead>\n<tr>\n<th>System Requirement</th>\n<th>Favors Bully</th>\n<th>Favors Ring</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Small cluster size (&lt; 10 nodes)</strong></td>\n<td>✓</td>\n<td></td>\n<td>Bully&#39;s O(n²) overhead is acceptable</td>\n</tr>\n<tr>\n<td><strong>Large cluster size (&gt; 20 nodes)</strong></td>\n<td></td>\n<td>✓</td>\n<td>Ring&#39;s O(n) complexity scales better</td>\n</tr>\n<tr>\n<td><strong>Frequent leader changes</strong></td>\n<td>✓</td>\n<td></td>\n<td>Bully&#39;s faster convergence reduces disruption</td>\n</tr>\n<tr>\n<td><strong>Network partitions common</strong></td>\n<td></td>\n<td>✓</td>\n<td>Ring handles partitions more gracefully</td>\n</tr>\n<tr>\n<td><strong>Simple implementation priority</strong></td>\n<td>✓</td>\n<td></td>\n<td>Bully has fewer moving parts</td>\n</tr>\n<tr>\n<td><strong>Predictable message patterns</strong></td>\n<td></td>\n<td>✓</td>\n<td>Ring&#39;s structured flow aids debugging</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Design Insight</strong>: The choice between election algorithms often comes down to whether you prioritize <strong>speed of election</strong> (Bully) or <strong>predictable resource usage</strong> (Ring). Bully optimizes for the common case of stable leadership with occasional elections, while Ring optimizes for consistent behavior even during frequent elections or network instability.</p>\n</blockquote>\n<h4 id=\"election-trigger-conditions\">Election Trigger Conditions</h4>\n<p>Both algorithms must handle multiple scenarios that can trigger new leadership elections:</p>\n<p><strong>Primary Triggers:</strong></p>\n<ul>\n<li><strong>Leader failure detection</strong>: Current leader stops responding to heartbeats</li>\n<li><strong>Leader abdication</strong>: Current leader voluntarily steps down (planned maintenance, resource constraints)</li>\n<li><strong>Network partition resolution</strong>: Previously partitioned nodes reconnect and discover conflicting leaders</li>\n<li><strong>Higher-priority node recovery</strong>: In Bully, a previously failed high-ID node returning online immediately triggers re-election</li>\n</ul>\n<p><strong>Secondary Triggers:</strong></p>\n<ul>\n<li><strong>Election timeout</strong>: Previous election failed to complete, requiring restart</li>\n<li><strong>Inconsistent leader state</strong>: Nodes discover they have different views of current leader</li>\n<li><strong>Manual election</strong>: Administrative command forces new leader selection</li>\n</ul>\n<p>The <strong>election trigger logic</strong> must be carefully designed to avoid both false positives (unnecessary elections that waste resources) and false negatives (failing to detect actual leader failures). This requires tunable timeout parameters and potentially adaptive failure detection based on network conditions.</p>\n<p>Each algorithm handles these triggers differently. Bully&#39;s aggressive approach means any trigger results in immediate election attempts by multiple nodes. Ring&#39;s structured approach typically designates specific nodes (like the failed leader&#39;s successor) to initiate elections, reducing the chaos of multiple simultaneous attempts.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Inter-node Transport</strong></td>\n<td>HTTP REST + JSON (net/http)</td>\n<td>gRPC with Protocol Buffers</td>\n</tr>\n<tr>\n<td><strong>Node Discovery</strong></td>\n<td>Static configuration file</td>\n<td>Consul service discovery</td>\n</tr>\n<tr>\n<td><strong>Message Serialization</strong></td>\n<td>JSON with encoding/json</td>\n<td>Protocol Buffers or MessagePack</td>\n</tr>\n<tr>\n<td><strong>Failure Detection</strong></td>\n<td>Simple TCP heartbeats</td>\n<td>SWIM gossip protocol</td>\n</tr>\n<tr>\n<td><strong>Logging</strong></td>\n<td>Standard log package</td>\n<td>Structured logging with logrus/zap</td>\n</tr>\n<tr>\n<td><strong>Configuration</strong></td>\n<td>Environment variables</td>\n<td>YAML/TOML with viper</td>\n</tr>\n</tbody></table>\n<p>For learning purposes, start with the simple options and upgrade to advanced options only after core functionality works correctly.</p>\n<h4 id=\"recommended-project-structure\">Recommended Project Structure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">leader</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">election</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  cmd</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      main.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">                    ← Node entry point and CLI setup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  internal</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      node.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">                    ← Core node identity and state management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      node_test.</span><span style=\"color:#F97583\">go</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transport</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      transport.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">               ← Message passing </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\"> definition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      http_transport.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">          ← HTTP</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">based transport implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      transport_test.</span><span style=\"color:#F97583\">go</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    discovery</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      discovery.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">               ← Node discovery </span><span style=\"color:#F97583\">interface</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      static_discovery.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">        ← Configuration</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">based discovery</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      discovery_test.</span><span style=\"color:#F97583\">go</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    election</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      types.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">                   ← Common election message types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      bully.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">                   ← Bully algorithm implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      ring.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">                    ← Ring algorithm implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      election_test.</span><span style=\"color:#F97583\">go</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    detector</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      failure_detector.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">        ← Heartbeat and failure detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      detector_test.</span><span style=\"color:#F97583\">go</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  pkg</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    messages</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      messages.</span><span style=\"color:#F97583\">go</span><span style=\"color:#E1E4E8\">                ← Public message </span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\"> definitions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  config</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node1.yaml                   ← Example node configurations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node2.yaml</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  scripts</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start_cluster.sh             ← Helper script </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> testing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  README.md</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  go</span><span style=\"color:#E1E4E8\">.mod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  go</span><span style=\"color:#E1E4E8\">.sum</span></span></code></pre></div>\n\n<h4 id=\"core-type-definitions\">Core Type Definitions</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// NodeID represents a unique identifier for cluster nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#F97583\"> uint64</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NodeState represents the current state of a node in the election process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NodeState</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateFollower</span><span style=\"color:#B392F0\">  NodeState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span><span style=\"color:#6A737D\">  // Node follows current leader</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateCandidate</span><span style=\"color:#6A737D\">                   // Node is participating in election</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateLeader</span><span style=\"color:#6A737D\">                      // Node is current cluster leader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Node represents a cluster member with election capabilities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Node</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID       </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Address  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    State    </span><span style=\"color:#B392F0\">NodeState</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add fields for current leader tracking, election state, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MessageType distinguishes different election message categories</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MessageType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgElection</span><span style=\"color:#B392F0\">    MessageType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span><span style=\"color:#6A737D\">  // Bully algorithm election message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgOK</span><span style=\"color:#6A737D\">                              // Bully algorithm acknowledgment</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgCoordinator</span><span style=\"color:#6A737D\">                     // Leader announcement message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgHeartbeat</span><span style=\"color:#6A737D\">                       // Failure detection heartbeat</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgRingToken</span><span style=\"color:#6A737D\">                       // Ring algorithm election token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"transport-layer-interface\">Transport Layer Interface</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Transport defines the interface for inter-node communication</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Transport</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SendMessage sends a message to a specific node</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SendMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // BroadcastMessage sends a message to all known nodes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    BroadcastMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ReceiveMessages returns a channel for incoming messages</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ReceiveMessages</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;-chan</span><span style=\"color:#B392F0\"> Message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // RegisterNode adds a node to the known peers list</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    RegisterNode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">address</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start begins listening for incoming messages</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Start</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Stop cleanly shuts down the transport</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Stop</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Message represents any inter-node communication</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Message</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type     </span><span style=\"color:#B392F0\">MessageType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    From     </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    To       </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#6A737D\">        // NodeID(0) for broadcast messages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Payload  []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#6A737D\">        // JSON-serialized message content</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"election-coordinator-interface\">Election Coordinator Interface</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ElectionCoordinator manages the leader election process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ElectionCoordinator</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // StartElection initiates a new leader election</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    StartElection</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HandleMessage processes incoming election-related messages</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    HandleMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // GetCurrentLeader returns the current leader's ID (or 0 if none)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetCurrentLeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // IsLeader returns true if this node is currently the leader</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    IsLeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // GetState returns the current election state of this node</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetState</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">NodeState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"starter-code-basic-http-transport\">Starter Code: Basic HTTP Transport</h4>\n<p>This complete implementation handles the networking complexity so learners can focus on election algorithms:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> transport</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">bytes</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HTTPTransport implements Transport using HTTP REST API</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> HTTPTransport</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID   </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    port     </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peers    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // NodeID -> \"host:port\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    messages </span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> Message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu       </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewHTTPTransport creates a new HTTP-based transport</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewHTTPTransport</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">port</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nodeID:   nodeID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        port:     port,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        peers:    </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        messages: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> Message</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Start begins listening for HTTP requests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> http.</span><span style=\"color:#B392F0\">NewServeMux</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/message\"</span><span style=\"color:#E1E4E8\">, t.handleMessage)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.server </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Addr:    fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\":</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, t.port),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Handler: mux,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.server.</span><span style=\"color:#B392F0\">ListenAndServe</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> http.ErrServerClosed {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Log error in production code</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SendMessage sends an HTTP POST to the target node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SendMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    address, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.peers[target]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unknown target node </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, target)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Marshal</span><span style=\"color:#E1E4E8\">(msg)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    url </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"http://</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/message\"</span><span style=\"color:#E1E4E8\">, address)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resp, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> http.</span><span style=\"color:#B392F0\">Post</span><span style=\"color:#E1E4E8\">(url, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">, bytes.</span><span style=\"color:#B392F0\">NewReader</span><span style=\"color:#E1E4E8\">(payload))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resp.Body.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReceiveMessages returns the channel for incoming messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReceiveMessages</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;-chan</span><span style=\"color:#B392F0\"> Message</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> t.messages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleMessage processes incoming HTTP requests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> msg </span><span style=\"color:#B392F0\">Message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">NewDecoder</span><span style=\"color:#E1E4E8\">(r.Body).</span><span style=\"color:#B392F0\">Decode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">msg); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        http.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(w, </span><span style=\"color:#9ECBFF\">\"Invalid JSON\"</span><span style=\"color:#E1E4E8\">, http.StatusBadRequest)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> t.messages </span><span style=\"color:#F97583\">&#x3C;-</span><span style=\"color:#E1E4E8\"> msg:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.</span><span style=\"color:#B392F0\">WriteHeader</span><span style=\"color:#E1E4E8\">(http.StatusOK)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        http.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(w, </span><span style=\"color:#9ECBFF\">\"Message queue full\"</span><span style=\"color:#E1E4E8\">, http.StatusServiceUnavailable)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Additional methods: BroadcastMessage, RegisterNode, Stop...</span></span></code></pre></div>\n\n<h4 id=\"core-algorithm-skeletons\">Core Algorithm Skeletons</h4>\n<p>The learner implements these election algorithms by filling in the TODO comments:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// BullyElection implements the bully algorithm for leader election</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BullyElection</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID      </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transport   </span><span style=\"color:#B392F0\">Transport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peers       []</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#6A737D\">  // All known node IDs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentTerm </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#6A737D\">    // Election term for ordering</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state       </span><span style=\"color:#B392F0\">NodeState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leader      </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    electionTimeout </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add fields for tracking ongoing elections, timers, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartElection initiates a bully algorithm election</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartElection</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Set state to StateCandidate and increment election term</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Find all peer nodes with higher IDs than this node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send ELECTION messages to all higher-ID nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Start election timeout timer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If no higher-ID nodes exist, immediately declare victory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use b.findHigherIDNodes() to get candidates to message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandleElectionMessage processes incoming ELECTION messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleElectionMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">from</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">term</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if sender has lower ID than this node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If so, send OK response to reject their election attempt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Start our own election since we have higher priority</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update our term if sender's term is higher</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Higher ID nodes should always challenge lower ID election attempts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandleOKMessage processes OK responses from higher-priority nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleOKMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">from</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Cancel our current election attempt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set state back to StateFollower  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Clear any election timers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Wait for COORDINATOR message from the winning node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Receiving OK means a higher-priority node will handle leadership</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandleCoordinatorMessage processes leader announcements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleCoordinatorMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">from</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">term</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate that sender has authority to be leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update our leader field and current term</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set state to StateFollower</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Cancel any ongoing election activities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Accept coordinator messages from higher-ID nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// declareVictory announces this node as the new leader</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">declareVictory</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Set state to StateLeader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set leader field to our own node ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Broadcast COORDINATOR message to all peers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Start leader heartbeat process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Only call this after election timeout with no OK responses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"ring-election-implementation-skeleton\">Ring Election Implementation Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// RingElection implements ring-based leader election</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RingElection</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID    </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transport </span><span style=\"color:#B392F0\">Transport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ring      []</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#6A737D\">  // Nodes arranged in ring order</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    position  </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">       // Our position in the ring</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state     </span><span style=\"color:#B392F0\">NodeState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leader    </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add fields for token tracking, ring maintenance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartElection begins ring election by creating initial token</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartElection</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create election token containing our node ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set state to StateCandidate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send token to next live node in ring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Start token timeout in case token gets lost</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use r.findNextLiveNode() to locate token destination</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandleRingToken processes election tokens circulating around ring</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleRingToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">token</span><span style=\"color:#B392F0\"> RingToken</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if this token originated from us (election complete)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If complete, find highest ID in token and declare winner</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Otherwise, add our ID to token and forward to next node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle case where next node is unreachable (ring repair)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Token completion means we've collected all live node IDs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// findNextLiveNode locates the next reachable node in ring order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">findNextLiveNode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">startPos</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Start from position after startPos in ring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Test connectivity to each node in ring order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return first reachable node ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle case where no nodes are reachable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use ping messages or transport.SendMessage to test connectivity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-validation-checkpoints\">Milestone Validation Checkpoints</h4>\n<p><strong>Milestone 1 Checkpoint - Node Communication:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Terminal 1: Start first node</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/node/main.go</span><span style=\"color:#79B8FF\"> --id=1</span><span style=\"color:#79B8FF\"> --port=8001</span><span style=\"color:#79B8FF\"> --config=config/node1.yaml</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Terminal 2: Start second node  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/node/main.go</span><span style=\"color:#79B8FF\"> --id=2</span><span style=\"color:#79B8FF\"> --port=8002</span><span style=\"color:#79B8FF\"> --config=config/node2.yaml</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected behavior:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Nodes discover each other through configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Heartbeat messages appear in logs every 5 seconds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Kill one node, other detects failure within 15 seconds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Restart killed node, it rejoins cluster automatically</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Checkpoint - Bully Algorithm:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start 3 nodes with IDs 1, 2, 3</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Kill node 3 (highest ID, should be initial leader)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify node 2 becomes new leader via election messages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Restart node 3, verify it reclaims leadership immediately</span></span></code></pre></div>\n\n<p><strong>Milestone 3 Checkpoint - Ring Algorithm:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Configure nodes in ring order: 1 → 3 → 5 → 7 → 1  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Kill current leader, verify ring token circulates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check logs show token visiting each live node exactly once</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify highest-ID node from token becomes new leader</span></span></code></pre></div>\n\n<h4 id=\"common-implementation-pitfalls\">Common Implementation Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Race Conditions in State Updates</strong>\nMultiple goroutines may simultaneously update node state during elections. Always protect shared state with mutexes:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">setState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">newState</span><span style=\"color:#B392F0\"> NodeState</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> b.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> newState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Infinite Election Loops</strong>\nIf election timeouts are too short, nodes may repeatedly trigger elections before previous ones complete. Use exponential backoff for election retry delays.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Message Ordering</strong>\nNetwork messages can arrive out of order. Always include term/sequence numbers in messages to handle delayed messages correctly.</p>\n<p>⚠️ <strong>Pitfall: Split-Brain During Partitions</strong>\nBoth partitions may elect leaders simultaneously. Implement quorum requirements (majority of nodes must participate) to prevent split-brain scenarios.</p>\n<p>⚠️ <strong>Pitfall: Resource Leaks in Transport Layer</strong>\nHTTP connections and goroutines can leak if not properly cleaned up. Always implement graceful shutdown with context cancellation and connection pooling.</p>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for Milestones 1, 2, and 3 - defining the exact scope and boundaries of what this leader election system will achieve</p>\n</blockquote>\n<p>Before diving into implementation details, we need to clearly define what this leader election system will and will not accomplish. Think of this as drawing the boundaries of a construction project - we need to know exactly what we&#39;re building, what quality standards it must meet, and what features we&#39;re explicitly choosing not to include. This clarity prevents scope creep and ensures we build a focused, working system rather than an overly ambitious prototype that never quite works properly.</p>\n<p>The leader election system sits at the heart of distributed coordination. Without clear goals, it&#39;s easy to either under-engineer (creating a system that works in happy-path scenarios but fails under real-world stress) or over-engineer (building enterprise-grade features when learning the fundamentals is the primary objective). This section establishes those boundaries explicitly.</p>\n<h3 id=\"functional-requirements\">Functional Requirements</h3>\n<p>The functional requirements define the core behaviors that our leader election system must exhibit to be considered correct and complete. These are not performance goals or quality attributes - they are the fundamental &quot;what must this system do&quot; requirements that determine whether the implementation succeeds or fails.</p>\n<h4 id=\"core-election-behaviors\">Core Election Behaviors</h4>\n<p>The system must guarantee that exactly one leader exists in the cluster at any given time, except during brief transition periods when an election is actively in progress. This is the fundamental safety property of leader election. During normal operation, every node in the cluster must agree on who the current leader is. When the leader fails or becomes unreachable, the system must detect this condition and initiate a new election automatically.</p>\n<p>For the bully algorithm implementation, the system must ensure that the node with the highest <code>NodeID</code> among all currently responding nodes always wins the election. This is deterministic - given the same set of live nodes, the bully algorithm must always produce the same leader. The election process follows a specific protocol: when a node detects leader failure, it sends <code>MsgElection</code> messages only to nodes with higher IDs. If any higher-ID node responds with <code>MsgOK</code>, the initiating node must abandon its election attempt. Only when no higher-ID nodes respond within the timeout period should a node declare itself the winner and broadcast <code>MsgCoordinator</code> to announce its leadership.</p>\n<p>For the ring election implementation, the system must arrange nodes in a logical ring topology ordered by <code>NodeID</code>. When an election begins, a <code>RingToken</code> circulates around the ring, collecting the IDs of all live nodes it encounters. The token must visit every reachable node exactly once per election cycle. When the token returns to its originator, the node with the highest collected ID becomes the new leader, and this decision must be communicated to all participating nodes.</p>\n<table>\n<thead>\n<tr>\n<th>Requirement</th>\n<th>Bully Algorithm</th>\n<th>Ring Algorithm</th>\n<th>Detection Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single leader guarantee</td>\n<td>Highest live ID wins</td>\n<td>Highest collected ID wins</td>\n<td>Compare <code>GetCurrentLeader()</code> across all nodes</td>\n</tr>\n<tr>\n<td>Election convergence</td>\n<td>Within 2 × timeout period</td>\n<td>Within ring traversal time</td>\n<td>All nodes report same leader</td>\n</tr>\n<tr>\n<td>Failure detection response</td>\n<td>Immediate election start</td>\n<td>Token-based detection</td>\n<td>Election triggered within heartbeat timeout</td>\n</tr>\n<tr>\n<td>Split election handling</td>\n<td>Higher ID preempts lower</td>\n<td>Token prevents concurrent elections</td>\n<td>No multiple <code>StateLeader</code> nodes</td>\n</tr>\n</tbody></table>\n<h4 id=\"node-communication-requirements\">Node Communication Requirements</h4>\n<p>The system must implement reliable point-to-point messaging where <code>SendMessage(target NodeID, msg Message)</code> delivers messages to specific nodes with confirmation of delivery or explicit failure notification. Messages should not be silently dropped - the sender must know whether the message reached its destination or failed to arrive.</p>\n<p>Broadcast messaging via <code>BroadcastMessage(msg Message)</code> must deliver messages to all currently known live nodes in the cluster. This doesn&#39;t require atomic broadcast - it&#39;s acceptable for some nodes to receive the message slightly before others. However, the broadcast must not systematically exclude certain nodes due to implementation bugs or race conditions.</p>\n<p>The node discovery mechanism must allow nodes to find and connect to their peers either through static configuration files or dynamic discovery methods like multicast announcements. Once discovered, nodes must maintain awareness of which peers are currently reachable and which have failed or become partitioned.</p>\n<table>\n<thead>\n<tr>\n<th>Communication Type</th>\n<th>Delivery Guarantee</th>\n<th>Failure Handling</th>\n<th>Implementation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Point-to-point</td>\n<td>At-least-once or confirmed failure</td>\n<td>Return error from <code>SendMessage()</code></td>\n<td>TCP connections with retries</td>\n</tr>\n<tr>\n<td>Broadcast</td>\n<td>Best-effort to all live nodes</td>\n<td>Log failures but continue</td>\n<td>Iterate through known nodes</td>\n</tr>\n<tr>\n<td>Node discovery</td>\n<td>Eventually consistent membership</td>\n<td>Periodic rediscovery attempts</td>\n<td>Config file + heartbeat validation</td>\n</tr>\n<tr>\n<td>Failure detection</td>\n<td>Detect within configurable timeout</td>\n<td>Trigger re-election automatically</td>\n<td>Heartbeat + suspicion counters</td>\n</tr>\n</tbody></table>\n<h4 id=\"state-management-and-consistency\">State Management and Consistency</h4>\n<p>Each node must maintain consistent state about its role in the cluster using the <code>NodeState</code> enumeration. A node begins in <code>StateFollower</code>, transitions to <code>StateCandidate</code> during election participation, and may become <code>StateLeader</code> if it wins. State transitions must be atomic and logged for debugging purposes.</p>\n<p>The system must track cluster membership accurately. This includes maintaining a current view of which nodes are alive, which have failed, and which are suspected of having failed but haven&#39;t been definitively confirmed as down. This membership information drives both election algorithms and failure detection logic.</p>\n<p>Leadership must be persistent once established. A newly elected leader should remain in that role until it actually fails, becomes partitioned, or voluntarily steps down. The system should not trigger unnecessary re-elections due to transient network hiccups or temporary message delays.</p>\n<blockquote>\n<p><strong>Design Principle:</strong> The functional requirements focus on correctness over performance. A slower election that always produces the right result is vastly preferable to a fast election that occasionally produces split-brain scenarios or fails to converge on a single leader.</p>\n</blockquote>\n<h3 id=\"performance-and-reliability-requirements\">Performance and Reliability Requirements</h3>\n<p>While correctness is paramount, the leader election system must also meet minimum performance and reliability standards to be useful in practice. These requirements establish the quantitative benchmarks that determine whether the system is fast enough, reliable enough, and scalable enough for its intended use cases.</p>\n<h4 id=\"election-timing-requirements\">Election Timing Requirements</h4>\n<p>Leader elections must complete within reasonable time bounds to minimize the period during which the cluster lacks coordination. For the bully algorithm, an election should converge within twice the message timeout period in the common case where network conditions are stable. This accounts for one timeout period to determine that higher-ID nodes aren&#39;t responding, plus additional time for the winner to broadcast its coordinator message.</p>\n<p>Ring elections should complete within the time required for a token to traverse the entire logical ring once, plus a small buffer for processing delays at each node. In a healthy network with N nodes, this should be proportional to N × average_message_latency rather than scaling exponentially.</p>\n<p>The system must detect node failures within a configurable timeout period, typically on the order of seconds rather than minutes. However, the failure detection should not be so aggressive that transient network delays trigger false positives and unnecessary elections.</p>\n<table>\n<thead>\n<tr>\n<th>Timing Requirement</th>\n<th>Target Value</th>\n<th>Measurement Method</th>\n<th>Failure Condition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Bully election completion</td>\n<td>&lt; 2 × message timeout</td>\n<td>Time from election start to coordinator broadcast</td>\n<td>&gt; 5 × message timeout</td>\n</tr>\n<tr>\n<td>Ring election completion</td>\n<td>&lt; N × message timeout + processing buffer</td>\n<td>Token full-circle time</td>\n<td>Token stuck or lost</td>\n</tr>\n<tr>\n<td>Failure detection latency</td>\n<td>Configurable (default 10s)</td>\n<td>Time from actual failure to election trigger</td>\n<td>&gt; 2 × configured timeout</td>\n</tr>\n<tr>\n<td>Leader announcement propagation</td>\n<td>&lt; message timeout</td>\n<td>Time for all nodes to learn new leader</td>\n<td>Nodes disagree on leader after election</td>\n</tr>\n</tbody></table>\n<h4 id=\"scalability-and-resource-requirements\">Scalability and Resource Requirements</h4>\n<p>The system must function correctly with cluster sizes from 3 nodes (minimum for meaningful elections) up to at least 10 nodes. While enterprise systems might require hundreds of nodes, this implementation focuses on the algorithmic correctness rather than extreme scalability.</p>\n<p>Memory usage should remain bounded and proportional to cluster size. Each node should maintain O(N) state for tracking N peer nodes, but should not accumulate unbounded state over time through memory leaks or unbounded log growth.</p>\n<p>Network overhead should be reasonable relative to the coordination value provided. Elections are infrequent events (triggered only by actual failures), so moderate message overhead during elections is acceptable. However, steady-state heartbeat and failure detection traffic should be lightweight.</p>\n<p>CPU usage for election algorithms should be minimal. The computational complexity of both bully and ring algorithms is low, involving simple message passing and ID comparisons rather than cryptographic operations or complex computations.</p>\n<table>\n<thead>\n<tr>\n<th>Resource</th>\n<th>Scaling Requirement</th>\n<th>Measurement</th>\n<th>Acceptable Range</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory per node</td>\n<td>O(N) for N cluster members</td>\n<td>Process RSS during operation</td>\n<td>&lt; 50MB for 10-node cluster</td>\n</tr>\n<tr>\n<td>Network messages per election</td>\n<td>O(N) for bully, O(N) for ring</td>\n<td>Count messages during election</td>\n<td>Bully: &lt; 2N², Ring: &lt; 2N</td>\n</tr>\n<tr>\n<td>Steady-state network overhead</td>\n<td>Heartbeat traffic only</td>\n<td>Messages per second outside elections</td>\n<td>&lt; 1 message/second/node</td>\n</tr>\n<tr>\n<td>CPU utilization</td>\n<td>Minimal during steady state</td>\n<td>Process CPU during normal operation</td>\n<td>&lt; 1% except during elections</td>\n</tr>\n</tbody></table>\n<h4 id=\"reliability-and-fault-tolerance\">Reliability and Fault Tolerance</h4>\n<p>The system must handle common failure scenarios gracefully without requiring manual intervention. Single node failures should trigger automatic re-election and leadership transfer without affecting the overall cluster&#39;s ability to coordinate.</p>\n<p>Network partitions present a more complex challenge. The system should avoid split-brain scenarios where multiple nodes simultaneously believe they are the leader. While perfect partition tolerance requires sophisticated quorum mechanisms, this implementation should at least detect partition scenarios and take conservative action (such as stepping down when isolated).</p>\n<p>Message loss and reordering should not break the election algorithms&#39; correctness. The protocols should be designed to handle these network realities through timeouts, retries, and idempotent message handling.</p>\n<p>The system should recover automatically when failed nodes rejoin the cluster or when network partitions heal. Rejoining nodes should be able to learn the current leader and integrate back into the cluster membership without triggering unnecessary elections.</p>\n<blockquote>\n<p><strong>Reliability Design Insight:</strong> The goal is not to achieve perfect fault tolerance (which would require much more sophisticated protocols), but to ensure that common failures are handled gracefully and that the system fails safely when it encounters scenarios beyond its design limits.</p>\n</blockquote>\n<h3 id=\"out-of-scope\">Out of Scope</h3>\n<p>Clearly defining what this leader election system will NOT include is just as important as defining what it will include. This prevents feature creep and keeps the implementation focused on learning the core algorithms rather than building a production-ready distributed systems framework.</p>\n<h4 id=\"advanced-distributed-systems-features\">Advanced Distributed Systems Features</h4>\n<p>This implementation explicitly excludes sophisticated consensus algorithms like Raft or Paxos. While these protocols solve leader election as part of broader consensus problems, they introduce significant complexity around log replication, term numbers, and linearizability guarantees that would overshadow the basic election algorithm learning objectives.</p>\n<p>Byzantine fault tolerance is completely out of scope. The system assumes that nodes may crash or become unreachable, but it does not protect against malicious nodes that lie about their identity, forge messages, or intentionally disrupt elections. All nodes are assumed to follow the protocol honestly when they are operational.</p>\n<p>Multi-datacenter deployments and wide-area network considerations are not addressed. The system assumes all nodes can communicate directly with reasonable latency and that network partitions are binary (nodes are either reachable or completely unreachable).</p>\n<p>Dynamic membership changes during elections are not supported. While nodes can join or leave the cluster, the system does not handle scenarios like nodes joining in the middle of an active election or graceful leadership handoff when a leader voluntarily steps down.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Feature</th>\n<th>Reason for Exclusion</th>\n<th>Alternative Learning Path</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Raft/Paxos consensus</td>\n<td>Too complex for basic election learning</td>\n<td>Separate project after mastering basic algorithms</td>\n</tr>\n<tr>\n<td>Byzantine fault tolerance</td>\n<td>Requires cryptographic verification</td>\n<td>Advanced distributed systems course</td>\n</tr>\n<tr>\n<td>Multi-datacenter support</td>\n<td>Network topology complications</td>\n<td>Study CAP theorem and partition tolerance</td>\n</tr>\n<tr>\n<td>Dynamic membership during elections</td>\n<td>Race conditions add algorithmic complexity</td>\n<td>Focus on static membership first</td>\n</tr>\n</tbody></table>\n<h4 id=\"production-ready-operations-features\">Production-Ready Operations Features</h4>\n<p>The system does not include comprehensive logging, metrics, or observability features beyond basic debugging information. While production systems require detailed telemetry, this implementation focuses on algorithmic correctness rather than operational visibility.</p>\n<p>Configuration management is minimal. The system may use simple configuration files or hard-coded parameters rather than sophisticated configuration systems with validation, hot reloading, or environment-specific overrides.</p>\n<p>Security features like authentication, authorization, or encrypted communication are completely excluded. Messages are sent in plaintext, and any node that can reach the cluster can participate in elections. This is obviously unsuitable for production but acceptable for learning algorithm fundamentals.</p>\n<p>Performance optimization beyond basic algorithmic efficiency is not included. The implementation prioritizes code clarity and correctness over micro-optimizations, advanced data structures, or high-performance networking libraries.</p>\n<p>Integration with external systems (service discovery, load balancers, monitoring systems) is out of scope. The leader election system operates as a standalone learning environment rather than a component in a broader infrastructure ecosystem.</p>\n<blockquote>\n<p><strong>Scope Decision:</strong> By explicitly excluding production-ready features, we can focus entirely on understanding how leader election algorithms work, what can go wrong, and how to implement them correctly. These operational concerns can be layered on top after the core algorithms are solid.</p>\n</blockquote>\n<h4 id=\"advanced-election-features\">Advanced Election Features</h4>\n<p>Weighted voting where some nodes have more influence in elections is not supported. All nodes with valid <code>NodeID</code> values have equal say in determining the leader, regardless of their hardware capabilities, network position, or assigned roles.</p>\n<p>Leader leases or term limits are not implemented. Once elected, a leader remains in power until it actually fails or becomes unreachable. There are no mechanisms for periodic re-election or automatic leadership rotation.</p>\n<p>Hierarchical elections or multi-level leadership structures are excluded. The system elects a single flat leader rather than supporting regional leaders, backup leaders, or leadership hierarchies.</p>\n<p>Custom election criteria beyond highest <code>NodeID</code> are not supported. Some production systems might elect leaders based on load, capability, geographic location, or other factors, but this implementation uses only numeric ID comparison for simplicity and determinism.</p>\n<table>\n<thead>\n<tr>\n<th>Advanced Feature</th>\n<th>Complexity Added</th>\n<th>Learning Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Weighted voting</td>\n<td>Vote counting algorithms, configuration management</td>\n<td>Low - obscures basic algorithm</td>\n</tr>\n<tr>\n<td>Leader leases/terms</td>\n<td>Time synchronization, lease renewal protocols</td>\n<td>Medium - useful but complicates learning</td>\n</tr>\n<tr>\n<td>Hierarchical leadership</td>\n<td>Multi-level coordination, cascading failures</td>\n<td>High - but better as separate project</td>\n</tr>\n<tr>\n<td>Custom election criteria</td>\n<td>Pluggable decision logic, complex comparison</td>\n<td>Low - ID-based is sufficient for learning</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete technical recommendations for implementing the goals and requirements defined above. The focus is on practical choices that support the learning objectives while keeping implementation complexity manageable.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Inter-node transport</td>\n<td>HTTP REST with JSON (net/http)</td>\n<td>gRPC with Protocol Buffers</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>JSON config file (encoding/json)</td>\n<td>YAML with validation (gopkg.in/yaml.v3)</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard library (log)</td>\n<td>Structured logging (logrus, zap)</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td>Built-in testing (testing)</td>\n<td>Testify framework (github.com/stretchr/testify)</td>\n</tr>\n<tr>\n<td>Networking</td>\n<td>TCP sockets (net)</td>\n<td>UDP with reliability layer</td>\n</tr>\n<tr>\n<td>State storage</td>\n<td>In-memory maps</td>\n<td>Persistent storage (BoltDB)</td>\n</tr>\n</tbody></table>\n<p>For learning purposes, start with the simple options. They require less setup and have fewer dependencies, letting you focus on the election algorithms rather than infrastructure concerns.</p>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>leader-election/\n├── cmd/\n│   └── node/\n│       └── main.go                    # Node startup and CLI\n├── internal/\n│   ├── node/\n│   │   ├── node.go                    # Node struct and basic lifecycle\n│   │   ├── state.go                   # NodeState management\n│   │   └── node_test.go               # Node behavior tests\n│   ├── transport/\n│   │   ├── transport.go               # Transport interface\n│   │   ├── http_transport.go          # HTTPTransport implementation\n│   │   └── transport_test.go          # Transport layer tests\n│   ├── election/\n│   │   ├── coordinator.go             # ElectionCoordinator interface\n│   │   ├── bully.go                   # BullyElection implementation\n│   │   ├── ring.go                    # RingElection implementation\n│   │   └── election_test.go           # Election algorithm tests\n│   └── discovery/\n│       ├── discovery.go               # Node discovery and membership\n│       └── discovery_test.go          # Discovery mechanism tests\n├── configs/\n│   └── cluster.json                   # Node configuration\n└── README.md                          # Setup and running instructions</code></pre></div>\n\n<h4 id=\"core-data-structures\">Core Data Structures</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// NodeID represents a unique node identifier for election comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#F97583\"> uint64</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NodeState represents the current role of a node in the election process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NodeState</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateFollower</span><span style=\"color:#B392F0\">  NodeState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span><span style=\"color:#6A737D\">  // Following current leader</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateCandidate</span><span style=\"color:#6A737D\">                   // Participating in election</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateLeader</span><span style=\"color:#6A737D\">                      // Serving as cluster leader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Node represents a cluster member with identity and network information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Node</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID      </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\"> `json:\"id\"`</span><span style=\"color:#6A737D\">       // Unique identifier for elections</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Address </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"address\"`</span><span style=\"color:#6A737D\">  // Network address (host:port)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    State   </span><span style=\"color:#B392F0\">NodeState</span><span style=\"color:#9ECBFF\"> `json:\"state\"`</span><span style=\"color:#6A737D\"> // Current election state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MessageType identifies the purpose of election messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MessageType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgElection</span><span style=\"color:#B392F0\">     MessageType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span><span style=\"color:#6A737D\">  // Bully algorithm election start</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgOK</span><span style=\"color:#6A737D\">                              // Bully algorithm acknowledgment</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgCoordinator</span><span style=\"color:#6A737D\">                     // Leader announcement</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgHeartbeat</span><span style=\"color:#6A737D\">                       // Failure detection ping</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgRingToken</span><span style=\"color:#6A737D\">                       // Ring election token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Message represents inter-node communication for election protocols</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Message</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type    </span><span style=\"color:#B392F0\">MessageType</span><span style=\"color:#9ECBFF\"> `json:\"type\"`</span><span style=\"color:#6A737D\">    // Message purpose</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    From    </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\">      `json:\"from\"`</span><span style=\"color:#6A737D\">    // Sender node ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    To      </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\">      `json:\"to\"`</span><span style=\"color:#6A737D\">      // Target node ID (0 for broadcast)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Payload []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#9ECBFF\">      `json:\"payload\"`</span><span style=\"color:#6A737D\"> // Algorithm-specific data</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"transport-layer-foundation\">Transport Layer Foundation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Transport defines the interface for inter-node communication</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Transport</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SendMessage delivers a message to a specific node</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SendMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // BroadcastMessage sends a message to all known live nodes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    BroadcastMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ReceiveMessages returns a channel of incoming messages</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ReceiveMessages</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;-chan</span><span style=\"color:#B392F0\"> Message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start begins listening for incoming messages</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Start</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">address</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Stop shuts down the transport layer</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Stop</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HTTPTransport implements Transport using HTTP REST calls</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> HTTPTransport</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID    </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peers     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">  // NodeID -> address mapping</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    messages  </span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> Message</span><span style=\"color:#6A737D\">       // Incoming message buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add mutex for thread safety</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add HTTP client for outgoing messages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add graceful shutdown handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Implement SendMessage for HTTP transport</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SendMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up target address in peers map</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Serialize message to JSON</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: POST to http://target-address/messages endpoint</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return error if HTTP request fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Consider adding retry logic for transient failures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"election-coordinator-interface\">Election Coordinator Interface</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ElectionCoordinator manages the leader election process for a node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ElectionCoordinator</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // StartElection initiates a new leader election</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    StartElection</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HandleMessage processes incoming election-related messages</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    HandleMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // GetCurrentLeader returns the ID of the current leader (0 if none)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetCurrentLeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // IsLeader returns true if this node is currently the leader</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    IsLeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SetTransport configures the communication layer</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SetTransport</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">transport</span><span style=\"color:#B392F0\"> Transport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BullyElection implements leader election using the bully algorithm</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BullyElection</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID      </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transport   </span><span style=\"color:#B392F0\">Transport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentLeader </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state       </span><span style=\"color:#B392F0\">NodeState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peers       []</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#6A737D\">           // Known peer node IDs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    electionTimeout </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#6A737D\">  // How long to wait for responses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add election timer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add mutex for concurrent access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add heartbeat tracking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartElection initiates bully algorithm election</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartElection</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Set state to StateCandidate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Find all peer nodes with higher IDs than this node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send MsgElection to all higher-ID nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Start election timeout timer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If timeout expires with no MsgOK responses, declare victory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: If victory, set state to StateLeader and broadcast MsgCoordinator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-validation-checkpoints\">Milestone Validation Checkpoints</h4>\n<p><strong>Milestone 1 Validation (Node Communication):</strong></p>\n<ol>\n<li>Start 3 nodes with different IDs in separate terminals</li>\n<li>Check that each node discovers the other two via membership mechanism</li>\n<li>Send test messages between nodes - verify they arrive correctly</li>\n<li>Kill one node - verify others detect failure within timeout period</li>\n<li>Expected output: Logs showing &quot;Node X discovered&quot;, &quot;Message from Y received&quot;, &quot;Node Z failed&quot;</li>\n</ol>\n<p><strong>Milestone 2 Validation (Bully Algorithm):</strong></p>\n<ol>\n<li>Start cluster of 5 nodes with IDs 1, 2, 3, 4, 5</li>\n<li>Verify node 5 becomes initial leader</li>\n<li>Kill node 5 - verify node 4 takes over leadership</li>\n<li>Kill node 4 - verify node 3 becomes leader</li>\n<li>Restart node 5 - verify it reclaims leadership</li>\n<li>Expected behavior: Always the highest-ID live node is leader</li>\n</ol>\n<p><strong>Milestone 3 Validation (Ring Election):</strong></p>\n<ol>\n<li>Configure nodes in ring topology: 1→3→5→7→1</li>\n<li>Trigger election from node 3</li>\n<li>Trace token passing: 3→5→7→1→3</li>\n<li>Verify node 7 (highest collected ID) becomes leader</li>\n<li>Test with failed node in ring - verify ring repair</li>\n<li>Expected output: Token trace logs showing ID collection at each hop</li>\n</ol>\n<h4 id=\"common-implementation-pitfalls\">Common Implementation Pitfalls</h4>\n<p>⚠️ <strong>Pitfall: Forgetting Message Serialization</strong>\nDon&#39;t assume you can send Go structs directly over the network. HTTP transport requires JSON serialization of the <code>Message</code> struct and its payload. Always test with <code>json.Marshal()</code> and <code>json.Unmarshal()</code> to catch serialization issues early.</p>\n<p>⚠️ <strong>Pitfall: Race Conditions in State Updates</strong>\nMultiple goroutines will access <code>NodeState</code> and leader information concurrently (message handlers, timers, API calls). Always protect shared state with mutexes or channels. A common bug is checking state in one line and using it in the next, with state changing between the two operations.</p>\n<p>⚠️ <strong>Pitfall: Election Timeout Too Short</strong>\nDon&#39;t set election timeouts to milliseconds in initial testing. Network latency, especially on localhost, can be variable. Start with 5-10 second timeouts, then optimize downward once the algorithm works correctly.</p>\n<p>⚠️ <strong>Pitfall: Infinite Election Loops</strong>\nIf two nodes simultaneously detect leader failure and start elections, they can end up in infinite loops of starting new elections. The bully algorithm handles this by having lower-ID nodes defer to higher-ID nodes, but you must implement the <code>MsgOK</code> response handling correctly.</p>\n<p>⚠️ <strong>Pitfall: Forgetting Edge Cases in Ring</strong>\nRing election token can get stuck if the next node in the ring fails while the token is in transit. Always implement a token timeout - if the originating node doesn&#39;t get its token back within a reasonable time, assume it was lost and start a new election.</p>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all milestones - provides the structural blueprint for implementing node communication (Milestone 1), bully election (Milestone 2), and ring election (Milestone 3)</p>\n</blockquote>\n<p>Before diving into the specifics of election algorithms, we need to establish the foundational architecture that will support both bully and ring election protocols. This section outlines the major components, their relationships, and how they work together to provide reliable distributed leader election.</p>\n<h3 id=\"mental-model-orchestra-conductor-selection\">Mental Model: Orchestra Conductor Selection</h3>\n<p>Think of leader election like selecting a conductor for an orchestra. Each musician (node) has a unique chair number (NodeID), and they all need to agree on who leads. The orchestra needs several key capabilities:</p>\n<ul>\n<li><strong>Communication system</strong>: Musicians can pass notes to specific colleagues or make announcements to everyone</li>\n<li><strong>Failure detection</strong>: Musicians notice when the conductor stops conducting or when fellow musicians miss their cues  </li>\n<li><strong>Election protocols</strong>: Structured procedures for selecting a new conductor when the current one fails</li>\n<li><strong>Coordination</strong>: Once elected, the conductor coordinates the entire performance</li>\n</ul>\n<p>Just as an orchestra needs these systems working together seamlessly, our leader election system requires coordinated components that handle communication, failure detection, and election logic as an integrated whole.</p>\n<p><img src=\"/api/project/leader-election/architecture-doc/asset?path=diagrams%2Fsystem-overview.svg\" alt=\"Leader Election System Overview\"></p>\n<h3 id=\"system-components\">System Components</h3>\n<p>The leader election system is built around four core components that work together to provide reliable distributed coordination. Each component has clearly defined responsibilities and interfaces with the others through well-structured APIs.</p>\n<h4 id=\"node-manager\">Node Manager</h4>\n<p>The <strong>Node Manager</strong> serves as the central control component for each node in the cluster. It maintains the node&#39;s identity, current state, and coordinates all election-related activities. Think of it as the node&#39;s &quot;brain&quot; that makes high-level decisions about when to start elections, how to respond to messages, and what role the node should play.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Key Data Managed</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Node Identity Management</td>\n<td>Maintains unique NodeID and network address</td>\n<td>NodeID, IP address, port</td>\n</tr>\n<tr>\n<td>State Management</td>\n<td>Tracks current node state (Follower/Candidate/Leader)</td>\n<td>NodeState, election term</td>\n</tr>\n<tr>\n<td>Election Coordination</td>\n<td>Decides when to start elections and handles outcomes</td>\n<td>Current leader ID, election status</td>\n</tr>\n<tr>\n<td>Component Integration</td>\n<td>Orchestrates message layer, failure detector, and election algorithms</td>\n<td>Component references and configurations</td>\n</tr>\n</tbody></table>\n<p>The Node Manager implements a state machine that transitions between <code>StateFollower</code>, <code>StateCandidate</code>, and <code>StateLeader</code> based on election events and failure detection. It serves as the single source of truth for the node&#39;s current role in the cluster.</p>\n<h4 id=\"message-layer-transport\">Message Layer (Transport)</h4>\n<p>The <strong>Message Layer</strong> provides reliable communication between nodes in the cluster. It abstracts the underlying network protocol (HTTP, TCP, UDP) and provides both point-to-point and broadcast messaging capabilities. This layer handles message serialization, delivery confirmation, and network error recovery.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SendMessage</code></td>\n<td><code>target NodeID, msg Message</code></td>\n<td><code>error</code></td>\n<td>Sends message to specific node with delivery confirmation</td>\n</tr>\n<tr>\n<td><code>BroadcastMessage</code></td>\n<td><code>msg Message</code></td>\n<td><code>error</code></td>\n<td>Sends message to all known live nodes in cluster</td>\n</tr>\n<tr>\n<td><code>ReceiveMessages</code></td>\n<td>None</td>\n<td><code>&lt;-chan Message</code></td>\n<td>Returns channel for incoming messages from other nodes</td>\n</tr>\n<tr>\n<td><code>UpdateMembership</code></td>\n<td><code>nodes []Node</code></td>\n<td><code>error</code></td>\n<td>Updates the set of known cluster nodes for routing</td>\n</tr>\n</tbody></table>\n<p>The transport layer maintains a routing table of all known nodes and their network addresses. It implements retry logic for failed message deliveries and provides feedback to upper layers about communication failures that may indicate node crashes.</p>\n<h4 id=\"election-coordinator\">Election Coordinator</h4>\n<p>The <strong>Election Coordinator</strong> implements the specific election algorithms (bully and ring). It&#39;s designed as a pluggable interface so different election strategies can be used interchangeably. The coordinator handles the detailed protocol logic for each algorithm while relying on the message layer for communication.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>StartElection</code></td>\n<td>None</td>\n<td><code>error</code></td>\n<td>Initiates new election using this algorithm</td>\n</tr>\n<tr>\n<td><code>HandleMessage</code></td>\n<td><code>msg Message</code></td>\n<td><code>error</code></td>\n<td>Processes incoming election-specific messages</td>\n</tr>\n<tr>\n<td><code>GetCurrentLeader</code></td>\n<td>None</td>\n<td><code>NodeID</code></td>\n<td>Returns the currently elected leader&#39;s ID</td>\n</tr>\n<tr>\n<td><code>IsLeader</code></td>\n<td>None</td>\n<td><code>bool</code></td>\n<td>Checks if this node is currently the leader</td>\n</tr>\n</tbody></table>\n<p>Two concrete implementations provide the core election algorithms:</p>\n<ul>\n<li><strong>BullyElection</strong>: Implements the bully algorithm where the highest-ID responding node becomes leader</li>\n<li><strong>RingElection</strong>: Implements ring-based election using token passing to collect live node IDs</li>\n</ul>\n<h4 id=\"failure-detector\">Failure Detector</h4>\n<p>The <strong>Failure Detector</strong> monitors cluster health and identifies node failures or network partitions. It uses heartbeat messages and timeout-based detection to determine when nodes become unreachable. This component triggers leader re-election when the current leader fails.</p>\n<table>\n<thead>\n<tr>\n<th>Detection Method</th>\n<th>Mechanism</th>\n<th>Timeout Configuration</th>\n<th>Action Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Heartbeat Monitoring</td>\n<td>Periodic <code>MsgHeartbeat</code> messages</td>\n<td>Configurable interval (default 1s)</td>\n<td>Mark nodes as suspected, then failed</td>\n</tr>\n<tr>\n<td>Leader Liveness</td>\n<td>Monitor heartbeats from current leader</td>\n<td>Leader timeout (default 5s)</td>\n<td>Trigger new election</td>\n</tr>\n<tr>\n<td>Network Partition</td>\n<td>Track communication failures across nodes</td>\n<td>Partition timeout (default 10s)</td>\n<td>Enter partition recovery mode</td>\n</tr>\n<tr>\n<td>Node Recovery</td>\n<td>Detect previously failed nodes rejoining</td>\n<td>Recovery grace period (default 3s)</td>\n<td>Update membership and potentially re-elect</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision: Component Separation</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to support multiple election algorithms while maintaining clean interfaces</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Monolithic design with all logic in one component</li>\n<li>Pluggable election algorithms with shared infrastructure </li>\n<li>Completely separate implementations for each algorithm</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Pluggable election coordinators with shared message layer and failure detection</li>\n<li><strong>Rationale</strong>: Enables algorithm comparison, testing flexibility, and code reuse while maintaining clear separation of concerns</li>\n<li><strong>Consequences</strong>: Slightly more complex interfaces but much better maintainability and extensibility</li>\n</ul>\n</blockquote>\n<h3 id=\"inter-node-communication\">Inter-Node Communication</h3>\n<p>Nodes discover each other and communicate through a layered approach that handles both cluster membership management and reliable message delivery. The communication system must work correctly even during network partitions and node failures.</p>\n<h4 id=\"node-discovery-and-membership\">Node Discovery and Membership</h4>\n<p>Cluster membership is managed through a combination of static configuration and dynamic discovery. Each node maintains a membership list that tracks all known cluster participants and their current status.</p>\n<p><strong>Static Configuration Approach</strong>: For initial development and testing, nodes are configured with a static list of cluster members including their NodeIDs and network addresses. This approach ensures deterministic behavior and simplifies debugging during development.</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Field</th>\n<th>Type</th>\n<th>Example Value</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>cluster_nodes</code></td>\n<td><code>[]NodeConfig</code></td>\n<td><code>[{id: 1, addr: &quot;10.0.1.1:8080&quot;}, ...]</code></td>\n<td>List of all cluster participants</td>\n</tr>\n<tr>\n<td><code>local_node_id</code></td>\n<td><code>NodeID</code></td>\n<td><code>3</code></td>\n<td>This node&#39;s unique identifier</td>\n</tr>\n<tr>\n<td><code>local_bind_addr</code></td>\n<td><code>string</code></td>\n<td><code>&quot;0.0.0.0:8080&quot;</code></td>\n<td>Address to bind for incoming connections</td>\n</tr>\n<tr>\n<td><code>heartbeat_interval</code></td>\n<td><code>time.Duration</code></td>\n<td><code>1s</code></td>\n<td>Frequency of heartbeat messages</td>\n</tr>\n</tbody></table>\n<p><strong>Dynamic Discovery Extension</strong>: For production deployments, the system can be extended with multicast announcement or service discovery integration. Nodes periodically announce their presence and discover new cluster members automatically.</p>\n<h4 id=\"message-routing-and-delivery\">Message Routing and Delivery</h4>\n<p>The message layer implements reliable delivery semantics for election coordination. Different message types have different delivery requirements based on their role in the election protocols.</p>\n<table>\n<thead>\n<tr>\n<th>Message Category</th>\n<th>Delivery Guarantee</th>\n<th>Retry Policy</th>\n<th>Timeout Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Election Messages (<code>MsgElection</code>, <code>MsgOK</code>)</td>\n<td>At-least-once with deduplication</td>\n<td>3 retries with exponential backoff</td>\n<td>Treat as node failure after timeout</td>\n</tr>\n<tr>\n<td>Coordinator Announcements (<code>MsgCoordinator</code>)</td>\n<td>Best-effort broadcast</td>\n<td>Single attempt to all nodes</td>\n<td>Continue with partial delivery</td>\n</tr>\n<tr>\n<td>Heartbeats (<code>MsgHeartbeat</code>)</td>\n<td>Best-effort</td>\n<td>No retries</td>\n<td>Missing heartbeats indicate failure</td>\n</tr>\n<tr>\n<td>Ring Tokens (<code>MsgRingToken</code>)</td>\n<td>Exactly-once with ordering</td>\n<td>Forward to next live node</td>\n<td>Skip failed nodes and continue ring</td>\n</tr>\n</tbody></table>\n<p>The transport layer maintains connection state for each cluster member and implements adaptive timeout policies. Connections that consistently fail are marked as suspected, and repeated failures trigger failure detection callbacks.</p>\n<h4 id=\"network-partition-handling\">Network Partition Handling</h4>\n<p>Network partitions pose a fundamental challenge for distributed leader election because different network segments may simultaneously elect different leaders (split-brain scenario). Our architecture includes several mechanisms to detect and handle partitions safely.</p>\n<p><strong>Partition Detection</strong>: The failure detector monitors communication patterns across the cluster to identify potential network partitions. When a node can communicate with some cluster members but not others, it may be experiencing a partition.</p>\n<p>| Partition Indicator | Detection Logic | Response Strategy |\n|---|---|---|---|\n| Asymmetric Failures | Node A can reach B but not C, while B can reach both A and C | Wait for partition recovery before participating in elections |\n| Majority Loss | Node can only communicate with less than half of configured cluster | Enter read-only mode, do not start new elections |\n| Leader Isolation | Current leader becomes unreachable but other nodes remain connected | Remaining nodes elect new leader after timeout |\n| Complete Isolation | Node cannot reach any other cluster members | Assume network failure, do not claim leadership |</p>\n<blockquote>\n<p><strong>Design Insight: Conservative Partition Handling</strong>\nOur approach prioritizes safety over availability during network partitions. It&#39;s better to have no leader temporarily than to have multiple conflicting leaders. This aligns with the CAP theorem trade-off where we choose consistency over availability during partition events.</p>\n</blockquote>\n<p><strong>Quorum Requirements</strong>: To prevent split-brain scenarios, certain operations require a quorum (majority) of nodes to be reachable. Leader election succeeds only when the electing partition contains more than half of the configured cluster nodes.</p>\n<h4 id=\"message-serialization-and-protocol\">Message Serialization and Protocol</h4>\n<p>All inter-node communication uses a structured message format that supports multiple election algorithms while maintaining backwards compatibility for future extensions.</p>\n<p>The base <code>Message</code> structure provides routing and metadata:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n<th>Example Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Type</code></td>\n<td><code>MessageType</code></td>\n<td>Identifies the message category and expected payload format</td>\n<td><code>MsgElection</code></td>\n</tr>\n<tr>\n<td><code>From</code></td>\n<td><code>NodeID</code></td>\n<td>Source node identifier for routing and authentication</td>\n<td><code>3</code></td>\n</tr>\n<tr>\n<td><code>To</code></td>\n<td><code>NodeID</code></td>\n<td>Target node identifier (0 for broadcast messages)</td>\n<td><code>5</code></td>\n</tr>\n<tr>\n<td><code>Term</code></td>\n<td><code>uint64</code></td>\n<td>Election term number for ordering and duplicate detection</td>\n<td><code>42</code></td>\n</tr>\n<tr>\n<td><code>Payload</code></td>\n<td><code>[]byte</code></td>\n<td>Algorithm-specific message content (JSON-encoded)</td>\n<td><code>{&quot;candidates&quot;: [3,4,5]}</code></td>\n</tr>\n<tr>\n<td><code>Timestamp</code></td>\n<td><code>int64</code></td>\n<td>Message creation time for timeout and ordering</td>\n<td>Unix timestamp</td>\n</tr>\n</tbody></table>\n<p>Each election algorithm defines its own payload structures that get serialized into the <code>Payload</code> field. This allows the transport layer to route messages without understanding algorithm-specific details.</p>\n<blockquote>\n<p><strong>Architecture Decision: JSON Message Serialization</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to serialize complex message payloads for network transmission</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>JSON for human readability and debugging ease</li>\n<li>Protocol Buffers for performance and schema evolution</li>\n<li>Custom binary format for minimal overhead</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: JSON for initial implementation</li>\n<li><strong>Rationale</strong>: Prioritizes development speed and debugging over performance. Network traffic volume is low for election protocols</li>\n<li><strong>Consequences</strong>: Slightly higher bandwidth usage but much easier debugging and development</li>\n</ul>\n</blockquote>\n<h3 id=\"recommended-project-organization\">Recommended Project Organization</h3>\n<p>The project structure reflects the component architecture while maintaining clear separation between core election logic, infrastructure concerns, and algorithm implementations. This organization supports both development workflow and testing isolation.</p>\n<h4 id=\"directory-structure\">Directory Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>leader-election/\n├── cmd/\n│   └── election-node/          # Main executable for running election nodes\n│       └── main.go             # Entry point, configuration, and startup logic\n├── internal/                   # Private application code (not importable by other projects)\n│   ├── node/                   # Node Manager - central coordination\n│   │   ├── manager.go          # Node state management and lifecycle\n│   │   ├── state_machine.go    # State transitions (Follower/Candidate/Leader)\n│   │   └── manager_test.go     # Unit tests for node management logic\n│   ├── transport/              # Message Layer - inter-node communication\n│   │   ├── transport.go        # Transport interface definition\n│   │   ├── http_transport.go   # HTTP-based transport implementation\n│   │   ├── message.go          # Message types and serialization\n│   │   └── transport_test.go   # Transport layer unit tests\n│   ├── election/               # Election Coordinators - algorithm implementations\n│   │   ├── coordinator.go      # ElectionCoordinator interface\n│   │   ├── bully.go           # Bully algorithm implementation\n│   │   ├── ring.go            # Ring election implementation\n│   │   └── election_test.go    # Algorithm-specific unit tests\n│   ├── detector/               # Failure Detector - health monitoring\n│   │   ├── failure_detector.go # Failure detection logic and heartbeats\n│   │   ├── membership.go       # Cluster membership tracking\n│   │   └── detector_test.go    # Failure detection unit tests\n│   └── config/                 # Configuration management\n│       ├── config.go           # Configuration structure and validation\n│       └── defaults.go         # Default values and constants\n├── pkg/                        # Public library code (importable by other projects)\n│   └── types/                  # Shared type definitions\n│       ├── node.go             # NodeID, NodeState, Node structs\n│       ├── message.go          # MessageType constants and Message struct\n│       └── errors.go           # Election-specific error types\n├── test/                       # Integration and end-to-end tests\n│   ├── integration/            # Multi-node test scenarios\n│   │   ├── bully_test.go       # Full bully election integration tests\n│   │   ├── ring_test.go        # Full ring election integration tests\n│   │   └── partition_test.go   # Network partition simulation tests\n│   └── testutil/               # Testing utilities and helpers\n│       ├── cluster.go          # Test cluster setup and management\n│       └── network.go          # Network failure simulation tools\n├── scripts/                    # Build and deployment scripts\n│   ├── run-cluster.sh          # Start test cluster with multiple nodes\n│   └── simulate-failure.sh     # Network failure simulation script\n├── docs/                       # Documentation\n│   └── diagrams/               # Architecture and sequence diagrams\n└── go.mod                      # Go module definition</code></pre></div>\n\n<h4 id=\"module-responsibilities-and-dependencies\">Module Responsibilities and Dependencies</h4>\n<p>Each module has clearly defined responsibilities and dependency relationships that enforce proper layering and prevent circular dependencies.</p>\n<table>\n<thead>\n<tr>\n<th>Module</th>\n<th>Primary Responsibility</th>\n<th>Dependencies</th>\n<th>Exports</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pkg/types</code></td>\n<td>Shared type definitions and constants</td>\n<td>None (foundational)</td>\n<td>NodeID, NodeState, MessageType, Message, Node</td>\n</tr>\n<tr>\n<td><code>internal/config</code></td>\n<td>Configuration parsing and validation</td>\n<td><code>pkg/types</code></td>\n<td>Config struct, default values</td>\n</tr>\n<tr>\n<td><code>internal/transport</code></td>\n<td>Network communication and message routing</td>\n<td><code>pkg/types</code></td>\n<td>Transport interface, HTTPTransport implementation</td>\n</tr>\n<tr>\n<td><code>internal/detector</code></td>\n<td>Failure detection and membership management</td>\n<td><code>pkg/types</code>, <code>internal/transport</code></td>\n<td>FailureDetector, membership tracking</td>\n</tr>\n<tr>\n<td><code>internal/election</code></td>\n<td>Election algorithm implementations</td>\n<td><code>pkg/types</code>, <code>internal/transport</code></td>\n<td>ElectionCoordinator, BullyElection, RingElection</td>\n</tr>\n<tr>\n<td><code>internal/node</code></td>\n<td>Node lifecycle and state management</td>\n<td>All internal modules</td>\n<td>NodeManager, orchestration logic</td>\n</tr>\n<tr>\n<td><code>cmd/election-node</code></td>\n<td>Application entry point and CLI</td>\n<td>All modules</td>\n<td>Executable binary</td>\n</tr>\n</tbody></table>\n<p>This dependency structure ensures that:</p>\n<ul>\n<li>Core types are defined once and shared across all modules</li>\n<li>Transport layer can be tested independently of election algorithms  </li>\n<li>Election algorithms can be developed and tested in isolation</li>\n<li>The node manager orchestrates all components without tight coupling</li>\n</ul>\n<h4 id=\"interface-boundaries-and-testing-strategy\">Interface Boundaries and Testing Strategy</h4>\n<p>The modular architecture enables comprehensive testing at multiple levels by providing clear interface boundaries for mocking and test doubles.</p>\n<p><strong>Unit Testing Strategy</strong>: Each module includes comprehensive unit tests that mock dependencies through interfaces. For example, election algorithm tests use a mock transport layer to simulate network conditions without requiring actual network communication.</p>\n<p><strong>Integration Testing Strategy</strong>: The <code>test/integration</code> package runs full multi-node scenarios using the actual implementations. These tests validate that components work correctly together and handle real network timing and failure conditions.</p>\n<p><strong>Testing Utilities</strong>: The <code>test/testutil</code> package provides reusable components for setting up test clusters, simulating network failures, and validating election outcomes. This reduces test complexity and improves consistency across different test scenarios.</p>\n<blockquote>\n<p><strong>Architecture Decision: Internal vs Pkg Module Organization</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to balance code reusability with API stability and encapsulation</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Everything in internal/ (no external API)</li>\n<li>Everything in pkg/ (fully public API)</li>\n<li>Mixed approach with stable types in pkg/, implementation in internal/</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Mixed approach with minimal pkg/ surface area</li>\n<li><strong>Rationale</strong>: Allows type sharing for testing while keeping implementation details private. Prevents external dependencies on unstable internals</li>\n<li><strong>Consequences</strong>: Clear API boundary but requires discipline to keep pkg/ minimal and stable</li>\n</ul>\n</blockquote>\n<h4 id=\"development-workflow-and-build-process\">Development Workflow and Build Process</h4>\n<p>The project structure supports efficient development workflows for both individual components and full system testing.</p>\n<p><strong>Local Development</strong>: Developers can work on individual algorithms or components using focused unit tests. The <code>go test ./internal/election/...</code> command runs only election algorithm tests, providing fast feedback during development.</p>\n<p><strong>Integration Testing</strong>: The <code>scripts/run-cluster.sh</code> script starts multiple node processes locally with different configurations, enabling manual testing of election scenarios. Network failures can be simulated using <code>scripts/simulate-failure.sh</code> to test partition handling.</p>\n<p><strong>Debugging Support</strong>: The modular structure enables selective logging and debugging. Each component can be configured with different log levels, and the HTTP transport provides REST endpoints for inspecting node state during development.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Circular Dependencies Between Components</strong></p>\n<p>A common mistake is creating circular import dependencies between the node manager, election coordinator, and transport layer. This happens when components try to directly call methods on each other instead of using proper interfaces and dependency injection.</p>\n<p><strong>Why it&#39;s wrong</strong>: Circular dependencies prevent compilation and make testing extremely difficult. They also indicate poor separation of concerns where components are too tightly coupled.</p>\n<p><strong>How to fix</strong>: Always make dependencies flow in one direction. Higher-level components (like NodeManager) depend on interfaces defined by lower-level components. Use dependency injection to provide concrete implementations at startup rather than having components create their own dependencies.</p>\n<p>⚠️ <strong>Pitfall: Blocking Message Handlers</strong></p>\n<p>Election message handlers often need to perform operations that might block (like sending messages to other nodes or updating persistent state). A common mistake is making these operations synchronous in the message handling path, which can cause deadlocks or missed messages.</p>\n<p><strong>Why it&#39;s wrong</strong>: If a message handler blocks while processing one message, it cannot process subsequent messages. This can cause election timeouts or missed critical messages that affect correctness.</p>\n<p><strong>How to fix</strong>: Use asynchronous message processing with worker goroutines and message queues. The main message receive loop should never block - it should queue messages for processing and return immediately.</p>\n<p>⚠️ <strong>Pitfall: Inconsistent Node ID Assignment</strong></p>\n<p>Node IDs must be unique and consistent across cluster restarts, but beginners often assign them randomly or use unstable values like memory addresses or timestamps.</p>\n<p><strong>Why it&#39;s wrong</strong>: Election algorithms depend on stable ID ordering. If node IDs change across restarts, the cluster cannot maintain consistent leadership or may experience continuous re-elections.</p>\n<p><strong>How to fix</strong>: Use configuration-based ID assignment where each node explicitly knows its own ID and the IDs of all cluster members. Never generate IDs dynamically or derive them from runtime values.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The implementation approach balances learning objectives with practical development concerns. We provide complete infrastructure code for components that aren&#39;t the core learning focus, while giving you skeleton code with detailed guidance for the key election logic you should implement yourself.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Transport Layer</td>\n<td>HTTP REST with JSON (net/http)</td>\n<td>gRPC with Protocol Buffers</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>JSON files with encoding/json</td>\n<td>YAML with validation library</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard log package with levels</td>\n<td>Structured logging (logrus/zap)</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td>Built-in testing package</td>\n<td>Testify for assertions and mocks</td>\n</tr>\n<tr>\n<td>Serialization</td>\n<td>JSON for all message payloads</td>\n<td>MessagePack or Protocol Buffers</td>\n</tr>\n<tr>\n<td>HTTP Client</td>\n<td>net/http with custom transport</td>\n<td>Dedicated HTTP client library</td>\n</tr>\n</tbody></table>\n<p>For learning purposes, start with the simple options to focus on distributed systems concepts rather than library complexity. The advanced options can be adopted later for production deployments.</p>\n<h4 id=\"recommended-file-structure-and-starter-code\">Recommended File Structure and Starter Code</h4>\n<p><strong>Core Type Definitions</strong> (<code>pkg/types/node.go</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> types</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#F97583\"> uint64</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NodeState</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateFollower</span><span style=\"color:#B392F0\"> NodeState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateCandidate</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateLeader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#B392F0\">NodeState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> s {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> StateFollower:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"Follower\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> StateCandidate:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"Candidate\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> StateLeader:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"Leader\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Unknown(</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">)\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">(s))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Node</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID      </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\"> `json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Address </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"address\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    State   </span><span style=\"color:#B392F0\">NodeState</span><span style=\"color:#9ECBFF\"> `json:\"state\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Message Type Definitions</strong> (<code>pkg/types/message.go</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> types</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MessageType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgHeartbeat</span><span style=\"color:#B392F0\"> MessageType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgElection</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgOK</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgCoordinator</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgRingToken</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#B392F0\">MessageType</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> t {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MsgHeartbeat:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"Heartbeat\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MsgElection:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"Election\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MsgOK:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"OK\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MsgCoordinator:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"Coordinator\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MsgRingToken:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"RingToken\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"Unknown\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Message</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type      </span><span style=\"color:#B392F0\">MessageType</span><span style=\"color:#9ECBFF\"> `json:\"type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    From      </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\">      `json:\"from\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    To        </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\">      `json:\"to\"`</span><span style=\"color:#6A737D\">        // 0 for broadcast</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Term      </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\">      `json:\"term\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Payload   []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#9ECBFF\">      `json:\"payload\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">       `json:\"timestamp\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Transport Interface Definition</strong> (<code>internal/transport/transport.go</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> transport</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#B392F0\">github.com/yourproject/pkg/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Transport</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SendMessage delivers a message to a specific target node</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SendMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // BroadcastMessage sends a message to all known live nodes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    BroadcastMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ReceiveMessages returns a channel for incoming messages</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ReceiveMessages</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;-chan</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // UpdateMembership updates the set of known cluster nodes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    UpdateMembership</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodes</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start begins accepting incoming connections and messages</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Start</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Stop cleanly shuts down the transport layer</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Stop</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>HTTP Transport Implementation</strong> (<code>internal/transport/http_transport.go</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> transport</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">bytes</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/yourproject/pkg/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> HTTPTransport</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    localNodeID </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bindAddr    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodes       </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodesMutex  </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    incomingMsg </span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx         </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cancel      </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CancelFunc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewHTTPTransport</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">bindAddr</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx, cancel </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">WithCancel</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        localNodeID: nodeID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        bindAddr:    bindAddr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nodes:       </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        incomingMsg: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        client: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Timeout: </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ctx:    ctx,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cancel: cancel,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> http.</span><span style=\"color:#B392F0\">NewServeMux</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/message\"</span><span style=\"color:#E1E4E8\">, t.handleMessage)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/health\"</span><span style=\"color:#E1E4E8\">, t.handleHealth)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.server </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Addr:    t.bindAddr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Handler: mux,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.server.</span><span style=\"color:#B392F0\">ListenAndServe</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> http.ErrServerClosed {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Log error in production</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.</span><span style=\"color:#B392F0\">cancel</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> t.server </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> t.server.</span><span style=\"color:#B392F0\">Shutdown</span><span style=\"color:#E1E4E8\">(context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SendMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.nodesMutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.nodes[target]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.nodesMutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unknown target node: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, target)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">sendHTTPMessage</span><span style=\"color:#E1E4E8\">(node.Address, msg)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">BroadcastMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.nodesMutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(t.nodes))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, node </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> t.nodes {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> node.ID </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> t.localNodeID {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            nodes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(nodes, node)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.nodesMutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> lastErr </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, node </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> nodes {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.</span><span style=\"color:#B392F0\">sendHTTPMessage</span><span style=\"color:#E1E4E8\">(node.Address, msg); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            lastErr </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Continue trying to send to other nodes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> lastErr</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReceiveMessages</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;-chan</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> t.incomingMsg</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdateMembership</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodes</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.nodesMutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> t.nodesMutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.nodes </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, node </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> nodes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.nodes[node.ID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">sendHTTPMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">address</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Marshal</span><span style=\"color:#E1E4E8\">(msg)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"marshal message: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    req, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> http.</span><span style=\"color:#B392F0\">NewRequestWithContext</span><span style=\"color:#E1E4E8\">(t.ctx, </span><span style=\"color:#9ECBFF\">\"POST\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"http://</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">/message\"</span><span style=\"color:#E1E4E8\">, address), bytes.</span><span style=\"color:#B392F0\">NewReader</span><span style=\"color:#E1E4E8\">(data))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"create request: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    req.Header.</span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Content-Type\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"application/json\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    resp, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.client.</span><span style=\"color:#B392F0\">Do</span><span style=\"color:#E1E4E8\">(req)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"send request: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> resp.Body.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> resp.StatusCode </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> http.StatusOK {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unexpected status: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, resp.StatusCode)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> r.Method </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> http.MethodPost {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        http.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(w, </span><span style=\"color:#9ECBFF\">\"Method not allowed\"</span><span style=\"color:#E1E4E8\">, http.StatusMethodNotAllowed)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> msg </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">NewDecoder</span><span style=\"color:#E1E4E8\">(r.Body).</span><span style=\"color:#B392F0\">Decode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">msg); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        http.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(w, </span><span style=\"color:#9ECBFF\">\"Invalid JSON\"</span><span style=\"color:#E1E4E8\">, http.StatusBadRequest)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> t.incomingMsg </span><span style=\"color:#F97583\">&#x3C;-</span><span style=\"color:#E1E4E8\"> msg:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        w.</span><span style=\"color:#B392F0\">WriteHeader</span><span style=\"color:#E1E4E8\">(http.StatusOK)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">t.ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        http.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(w, </span><span style=\"color:#9ECBFF\">\"Shutting down\"</span><span style=\"color:#E1E4E8\">, http.StatusServiceUnavailable)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        http.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(w, </span><span style=\"color:#9ECBFF\">\"Message queue full\"</span><span style=\"color:#E1E4E8\">, http.StatusTooManyRequests)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleHealth</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">WriteHeader</span><span style=\"color:#E1E4E8\">(http.StatusOK)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    json.</span><span style=\"color:#B392F0\">NewEncoder</span><span style=\"color:#E1E4E8\">(w).</span><span style=\"color:#B392F0\">Encode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"node_id\"</span><span style=\"color:#E1E4E8\">: t.localNodeID,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"status\"</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#9ECBFF\">\"healthy\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Election Coordinator Interface</strong> (<code>internal/election/coordinator.go</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> election</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#B392F0\">github.com/yourproject/pkg/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ElectionCoordinator</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // StartElection initiates a new leader election using this algorithm</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    StartElection</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HandleMessage processes incoming election-specific messages</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    HandleMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // GetCurrentLeader returns the currently elected leader's ID</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetCurrentLeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // IsLeader checks if this node is currently the leader</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    IsLeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // GetElectionTerm returns the current election term number</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetElectionTerm</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeletons for Student Implementation</strong></p>\n<p><strong>Bully Election Skeleton</strong> (<code>internal/election/bully.go</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> election</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/yourproject/pkg/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/yourproject/internal/transport</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BullyElection</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID       </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transport    </span><span style=\"color:#B392F0\">transport</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Transport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentLeader </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    electionTerm  </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state         </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex         </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    electionTimer </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Timer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    electionTimeout </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodes          []</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#6A737D\"> // All known node IDs in cluster</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewBullyElection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">transport</span><span style=\"color:#B392F0\"> transport</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Transport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">nodes</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nodeID:          nodeID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        transport:       transport,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nodes:          nodes,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        state:          types.StateFollower,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        electionTimeout: </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartElection initiates a new bully election from this node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartElection</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> b.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Increment election term and become candidate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Find all nodes with higher IDs than this node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send MsgElection to all higher-ID nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Start election timeout timer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If no higher-ID nodes exist, immediately declare victory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use b.findHigherIDNodes() to get nodes to contact</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Create Message with Type=MsgElection, From=b.nodeID, Term=b.electionTerm</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandleMessage processes incoming bully election messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HandleMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> msg.Type {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> types.MsgElection:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> b.</span><span style=\"color:#B392F0\">handleElectionMessage</span><span style=\"color:#E1E4E8\">(msg)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> types.MsgOK:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> b.</span><span style=\"color:#B392F0\">handleOKMessage</span><span style=\"color:#E1E4E8\">(msg)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> types.MsgCoordinator:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> b.</span><span style=\"color:#B392F0\">handleCoordinatorMessage</span><span style=\"color:#E1E4E8\">(msg)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\"> // Ignore unknown message types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleElectionMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> b.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if sender has lower ID than this node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If sender ID &#x3C; this node ID, send MsgOK response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Start own election (call StartElection) to assert higher priority</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Compare msg.From with b.nodeID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Create response message with Type=MsgOK, From=b.nodeID, To=msg.From</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleOKMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> b.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Cancel election timer since higher-ID node responded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Return to follower state </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Clear any pending election state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use b.electionTimer.Stop() if timer exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Set b.state = types.StateFollower</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleCoordinatorMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> b.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Accept the announced leader if election term is current/newer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update current leader to sender</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Transition to follower state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Cancel any ongoing election</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check msg.Term >= b.electionTerm before accepting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">onElectionTimeout</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> b.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if still in candidate state (election wasn't cancelled)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: No higher-ID nodes responded, so this node wins</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Transition to leader state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Broadcast MsgCoordinator to announce victory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Create coordinator message with Type=MsgCoordinator, From=b.nodeID, To=0 (broadcast)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetCurrentLeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.mutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> b.mutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> b.currentLeader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsLeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.mutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> b.mutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> b.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> types.StateLeader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetElectionTerm</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    b.mutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> b.mutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> b.electionTerm</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Helper method to find nodes with higher IDs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">findHigherIDNodes</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return slice of node IDs that are greater than b.nodeID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Iterate through b.nodes and collect IDs where node > b.nodeID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Configuration Structure</strong> (<code>internal/config/config.go</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> config</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/yourproject/pkg/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Config</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LocalNodeID       </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\">        `json:\"local_node_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BindAddress       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">              `json:\"bind_address\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ClusterNodes      []</span><span style=\"color:#B392F0\">NodeConfig</span><span style=\"color:#9ECBFF\">        `json:\"cluster_nodes\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ElectionAlgorithm </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">              `json:\"election_algorithm\"`</span><span style=\"color:#6A737D\"> // \"bully\" or \"ring\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HeartbeatInterval </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\">       `json:\"heartbeat_interval\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ElectionTimeout   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\">       `json:\"election_timeout\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LeaderTimeout     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\">       `json:\"leader_timeout\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NodeConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID      </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\"> `json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Address </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"address\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> LoadConfig</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">filename</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(filename)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"read config file: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> config </span><span style=\"color:#B392F0\">Config</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">config); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"parse config JSON: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Apply defaults</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.HeartbeatInterval </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config.HeartbeatInterval </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.ElectionTimeout </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config.ElectionTimeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> config.LeaderTimeout </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config.LeaderTimeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">config, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Milestone 1 Checkpoint - Node Communication</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start first node</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/election-node/main.go</span><span style=\"color:#79B8FF\"> -config=test/node1.json</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Start second node  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/election-node/main.go</span><span style=\"color:#79B8FF\"> -config=test/node2.json</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test message passing with curl</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8081/message</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -d</span><span style=\"color:#9ECBFF\"> '{\"type\": 0, \"from\": 999, \"to\": 1, \"payload\": null}'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Both nodes should log receiving heartbeat messages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Health endpoints should return node status</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> http://localhost:8081/health</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Checkpoint - Bully Election</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start 3-node cluster</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./scripts/run-cluster.sh</span><span style=\"color:#9ECBFF\"> bully</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Kill current leader node</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">pkill</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> \"node-id=3\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Remaining nodes should elect new leader within 10 seconds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All nodes should agree on same leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check logs for \"Election started\", \"Received OK\", \"New leader elected\" messages</span></span></code></pre></div>\n\n<p><strong>Milestone 3 Checkpoint - Ring Election</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start 5-node ring cluster</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./scripts/run-cluster.sh</span><span style=\"color:#9ECBFF\"> ring</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Simulate network partition</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./scripts/simulate-failure.sh</span><span style=\"color:#9ECBFF\"> partition</span><span style=\"color:#9ECBFF\"> 2,3</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Ring should adapt and continue election around partition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Token should skip failed nodes and complete ring traversal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check logs for \"Token forwarded\", \"Ring repaired\", \"Leader selected\" messages</span></span></code></pre></div>\n\n\n<h2 id=\"data-model-and-message-types\">Data Model and Message Types</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Foundation for all milestones - defines the core data structures and message formats used in node communication (Milestone 1), bully election (Milestone 2), and ring election (Milestone 3)</p>\n</blockquote>\n<p>Before implementing any distributed leader election algorithm, we must establish the fundamental data structures that represent nodes, their states, and the messages they exchange. Think of this as defining the &quot;vocabulary&quot; and &quot;grammar&quot; of our distributed system - without a clear understanding of how nodes identify themselves and communicate, we cannot build reliable coordination protocols.</p>\n<h3 id=\"mental-model-diplomatic-protocol\">Mental Model: Diplomatic Protocol</h3>\n<p>Imagine a group of ambassadors from different countries trying to select a conference chairperson. Each ambassador has official credentials (node identity), follows specific diplomatic protocols for communication (message formats), and maintains an up-to-date list of which other ambassadors are present and participating (cluster membership). Just as diplomatic protocols prevent confusion and ensure orderly communication, our data model provides the structured foundation for distributed coordination.</p>\n<p>The ambassadors need standardized message formats - formal proposals, acknowledgments, and announcements - that everyone understands. They also need to track who is present, who has left the conference, and who might be temporarily unreachable due to communication issues. This diplomatic analogy captures the essence of our data model: formal identity, structured communication, and membership tracking.</p>\n<h3 id=\"node-identity-and-state\">Node Identity and State</h3>\n<p>Every participant in our leader election system requires a unique, stable identity that persists across restarts and network interruptions. The node identity serves multiple critical purposes: it provides a deterministic way to order nodes (essential for the bully algorithm), enables point-to-point message routing, and allows other nodes to track membership changes over time.</p>\n<p><strong>Node Identity Design</strong></p>\n<p>The foundation of node identity is the <code>NodeID</code> type, which uses a 64-bit unsigned integer. This choice provides several important benefits over alternatives like string-based UUIDs or network addresses. Numeric identifiers enable efficient comparison operations required by election algorithms - the bully algorithm specifically depends on determining which node has the &quot;highest&quot; ID. Additionally, 64-bit integers provide an enormous namespace (18 quintillion possible values) while maintaining compact representation and fast comparison performance.</p>\n<blockquote>\n<p><strong>Decision: Numeric Node Identifiers</strong></p>\n<ul>\n<li><strong>Context</strong>: Need unique, comparable identifiers for nodes participating in leader election</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>String-based UUIDs (universally unique but not naturally ordered)</li>\n<li>Network addresses like IP:Port (not stable across restarts or network changes)</li>\n<li>64-bit unsigned integers (compact, fast comparison, naturally ordered)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use 64-bit unsigned integers as <code>NodeID</code></li>\n<li><strong>Rationale</strong>: Election algorithms require efficient comparison and ordering of node identities. Numeric IDs provide O(1) comparison, deterministic ordering for tie-breaking, and compact representation for network messages</li>\n<li><strong>Consequences</strong>: Requires configuration or generation strategy to ensure uniqueness. Enables efficient election algorithms but means node IDs must be assigned rather than automatically generated</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>NodeID</code></td>\n<td><code>uint64</code></td>\n<td>Unique numeric identifier for the node, used for comparison in election algorithms</td>\n</tr>\n</tbody></table>\n<p><strong>Node State Representation</strong></p>\n<p>Each node maintains its current state in the leader election process through a simple but crucial state machine. The <code>NodeState</code> enumeration captures the three fundamental roles a node can occupy: following an established leader, actively participating in an election, or serving as the current cluster leader.</p>\n<table>\n<thead>\n<tr>\n<th>State</th>\n<th>Value</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>StateFollower</code></td>\n<td><code>0</code></td>\n<td>Node is following the current leader and not participating in elections</td>\n</tr>\n<tr>\n<td><code>StateCandidate</code></td>\n<td><code>1</code></td>\n<td>Node is actively participating in a leader election process</td>\n</tr>\n<tr>\n<td><code>StateLeader</code></td>\n<td><code>2</code></td>\n<td>Node is the current elected leader of the cluster</td>\n</tr>\n</tbody></table>\n<p>The state transitions follow a predictable pattern that prevents confusion and ensures system stability. A <code>Follower</code> transitions to <code>Candidate</code> when it detects leader failure or receives election messages. A <code>Candidate</code> either transitions to <code>Leader</code> upon winning an election or back to <code>Follower</code> when another node wins. A <code>Leader</code> transitions back to <code>Follower</code> when it detects it has lost leadership due to network partition or higher-priority elections.</p>\n<p><strong>Complete Node Representation</strong></p>\n<p>The <code>Node</code> structure combines identity, addressing, and state information to provide a complete representation of a cluster participant:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ID</code></td>\n<td><code>NodeID</code></td>\n<td>Unique numeric identifier for this node</td>\n</tr>\n<tr>\n<td><code>Address</code></td>\n<td><code>string</code></td>\n<td>Network address for communication (IP:Port format)</td>\n</tr>\n<tr>\n<td><code>State</code></td>\n<td><code>NodeState</code></td>\n<td>Current election state of this node</td>\n</tr>\n</tbody></table>\n<p>This design separates concerns effectively: the <code>ID</code> provides stable identity for election logic, the <code>Address</code> enables network communication, and the <code>State</code> tracks the node&#39;s current role in the coordination protocol. The address field uses string representation to accommodate both IPv4 and IPv6 addresses, as well as different port configurations.</p>\n<blockquote>\n<p>The key insight here is that node identity must remain stable across network changes, restarts, and even IP address modifications. The <code>NodeID</code> serves as the permanent identity, while the <code>Address</code> provides the current communication endpoint.</p>\n</blockquote>\n<p><strong>State Management Considerations</strong></p>\n<p>Node state changes must be atomic and carefully synchronized to prevent race conditions during concurrent elections. When a node changes state, it must ensure that its message handling logic immediately reflects the new role. For example, a node transitioning from <code>Candidate</code> to <code>Leader</code> must start accepting coordination requests and stop participating in election protocols.</p>\n<p>The state machine also provides important debugging and monitoring capabilities. By examining the current state distribution across the cluster, operators can quickly identify problems: too many nodes in <code>Candidate</code> state suggests election instability, while no nodes in <code>Leader</code> state indicates a coordination failure that requires intervention.</p>\n<h3 id=\"election-message-formats\">Election Message Formats</h3>\n<p>Inter-node communication during leader election requires precisely defined message formats that both algorithms can understand and process reliably. The message format design must accommodate different election protocols while maintaining type safety and extensibility for future enhancements.</p>\n<p><strong>Base Message Structure</strong></p>\n<p>All election messages share a common envelope structure that provides routing information and message classification:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Type</code></td>\n<td><code>MessageType</code></td>\n<td>Identifies the specific message category and protocol</td>\n</tr>\n<tr>\n<td><code>From</code></td>\n<td><code>NodeID</code></td>\n<td>Identifier of the node that sent this message</td>\n</tr>\n<tr>\n<td><code>To</code></td>\n<td><code>NodeID</code></td>\n<td>Intended recipient node (0 for broadcast messages)</td>\n</tr>\n<tr>\n<td><code>Payload</code></td>\n<td><code>[]byte</code></td>\n<td>Serialized message content specific to the message type</td>\n</tr>\n</tbody></table>\n<p>The <code>From</code> field enables message authentication and helps detect network issues or malicious behavior. The <code>To</code> field supports both point-to-point messaging (specific <code>NodeID</code>) and broadcast semantics (using <code>NodeID</code> value 0 to indicate all nodes). The binary payload approach provides flexibility for different message types while maintaining a consistent envelope format.</p>\n<p><strong>Message Type Classification</strong></p>\n<p>The <code>MessageType</code> enumeration defines all communication patterns used across both election algorithms:</p>\n<table>\n<thead>\n<tr>\n<th>Message Type</th>\n<th>Value</th>\n<th>Algorithm</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>MsgElection</code></td>\n<td><code>1</code></td>\n<td>Bully</td>\n<td>Election initiation message sent to higher-ID nodes</td>\n</tr>\n<tr>\n<td><code>MsgOK</code></td>\n<td><code>2</code></td>\n<td>Bully</td>\n<td>Acknowledgment that a higher-ID node will handle the election</td>\n</tr>\n<tr>\n<td><code>MsgCoordinator</code></td>\n<td><code>3</code></td>\n<td>Both</td>\n<td>Announcement of the newly elected leader</td>\n</tr>\n<tr>\n<td><code>MsgHeartbeat</code></td>\n<td><code>4</code></td>\n<td>Both</td>\n<td>Periodic liveness check from current leader</td>\n</tr>\n<tr>\n<td><code>MsgRingToken</code></td>\n<td><code>5</code></td>\n<td>Ring</td>\n<td>Election token passed around the logical ring</td>\n</tr>\n</tbody></table>\n<p>This enumeration provides clear separation between algorithm-specific messages and shared infrastructure messages. The heartbeat message serves both algorithms by providing failure detection, while the coordinator message announces election results regardless of the algorithm used.</p>\n<p><strong>Bully Algorithm Message Formats</strong></p>\n<p>The bully algorithm uses three distinct message types to coordinate elections. Each message type carries specific information required for the protocol&#39;s operation:</p>\n<p><strong>Election Message (<code>MsgElection</code>)</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ElectionID</code></td>\n<td><code>uint64</code></td>\n<td>Unique identifier for this election instance</td>\n</tr>\n<tr>\n<td><code>CandidateID</code></td>\n<td><code>NodeID</code></td>\n<td>ID of the node initiating this election</td>\n</tr>\n<tr>\n<td><code>Term</code></td>\n<td><code>uint64</code></td>\n<td>Election term number to prevent confusion from delayed messages</td>\n</tr>\n</tbody></table>\n<p>The <code>ElectionID</code> prevents confusion when multiple elections run concurrently or when delayed messages from previous elections arrive out of order. The <code>Term</code> field provides additional protection against stale messages and enables proper election sequencing.</p>\n<p><strong>OK Message (<code>MsgOK</code>)</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ElectionID</code></td>\n<td><code>uint64</code></td>\n<td>References the election being acknowledged</td>\n</tr>\n<tr>\n<td><code>ResponderID</code></td>\n<td><code>NodeID</code></td>\n<td>ID of the node sending this acknowledgment</td>\n</tr>\n</tbody></table>\n<p>The OK message serves as both acknowledgment and promise: the responding node acknowledges the election request and promises to conduct its own election attempt with higher-priority nodes.</p>\n<p><strong>Coordinator Message (<code>MsgCoordinator</code>)</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>LeaderID</code></td>\n<td><code>NodeID</code></td>\n<td>ID of the newly elected leader</td>\n</tr>\n<tr>\n<td><code>Term</code></td>\n<td><code>uint64</code></td>\n<td>Election term in which this leader was chosen</td>\n</tr>\n<tr>\n<td><code>ElectionID</code></td>\n<td><code>uint64</code></td>\n<td>The election that produced this leader</td>\n</tr>\n</tbody></table>\n<p>The coordinator message broadcasts the election results to all cluster members. The term and election ID fields help nodes validate the announcement and detect potential split-brain scenarios.</p>\n<p><strong>Ring Election Message Format</strong></p>\n<p>The ring election algorithm uses a single, more complex message type that accumulates information as it travels around the cluster:</p>\n<p><strong>Ring Token Message (<code>MsgRingToken</code>)</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ElectionID</code></td>\n<td><code>uint64</code></td>\n<td>Unique identifier for this ring election instance</td>\n</tr>\n<tr>\n<td><code>InitiatorID</code></td>\n<td><code>NodeID</code></td>\n<td>Node that started this election</td>\n</tr>\n<tr>\n<td><code>Participants</code></td>\n<td><code>[]NodeID</code></td>\n<td>List of live node IDs collected during ring traversal</td>\n</tr>\n<tr>\n<td><code>Complete</code></td>\n<td><code>bool</code></td>\n<td>True when the token has completed a full ring traversal</td>\n</tr>\n</tbody></table>\n<p>The <code>Participants</code> slice grows as the token travels around the ring, with each live node adding its own ID to the list. When the token returns to the <code>InitiatorID</code> node, the <code>Complete</code> flag is set to true, and the node with the highest ID in the <code>Participants</code> list becomes the new leader.</p>\n<p>This design elegantly handles ring election requirements: it collects membership information dynamically, handles failed nodes by skipping them, and provides all necessary data for leader selection in a single message that makes one complete traversal of the cluster.</p>\n<p><strong>Heartbeat Message Format</strong></p>\n<p>Both election algorithms rely on heartbeat messages for failure detection:</p>\n<p><strong>Heartbeat Message (<code>MsgHeartbeat</code>)</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>LeaderID</code></td>\n<td><code>NodeID</code></td>\n<td>ID of the current leader sending this heartbeat</td>\n</tr>\n<tr>\n<td><code>Term</code></td>\n<td><code>uint64</code></td>\n<td>Current leadership term</td>\n</tr>\n<tr>\n<td><code>Timestamp</code></td>\n<td><code>int64</code></td>\n<td>Unix timestamp when this heartbeat was sent</td>\n</tr>\n</tbody></table>\n<p>Heartbeat messages serve multiple purposes: they confirm leader liveness, establish the current term for election ordering, and provide timing information for failure detection calculations.</p>\n<blockquote>\n<p><strong>Decision: Binary Payload with Type-Specific Deserialization</strong></p>\n<ul>\n<li><strong>Context</strong>: Need flexible message format that supports multiple election algorithms and future extensions</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Fixed struct with optional fields (wastes bandwidth, limits extensibility)</li>\n<li>JSON payloads (human-readable but larger and slower to parse)</li>\n<li>Binary payload with type-specific deserialization (compact, fast, extensible)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use binary payload with message type determining deserialization logic</li>\n<li><strong>Rationale</strong>: Provides optimal network efficiency for high-frequency messages like heartbeats, while maintaining flexibility for different message formats per algorithm</li>\n<li><strong>Consequences</strong>: Requires careful serialization/deserialization logic and version compatibility management, but enables efficient network usage and protocol evolution</li>\n</ul>\n</blockquote>\n<h3 id=\"cluster-membership-model\">Cluster Membership Model</h3>\n<p>Effective leader election requires every node to maintain an accurate, up-to-date view of cluster membership. The membership model must handle dynamic scenarios where nodes join, leave gracefully, crash unexpectedly, or become temporarily unreachable due to network partitions. This information directly impacts election decisions and determines message routing patterns.</p>\n<p><strong>Membership State Representation</strong></p>\n<p>The cluster membership model centers on maintaining a consistent view of which nodes are currently alive and participating in the election process. Each node maintains its own membership table, which gets updated through various mechanisms including heartbeat monitoring, explicit join/leave messages, and failure detection timeouts.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Members</code></td>\n<td><code>map[NodeID]Node</code></td>\n<td>Current view of live cluster members indexed by node ID</td>\n</tr>\n<tr>\n<td><code>LastSeen</code></td>\n<td><code>map[NodeID]int64</code></td>\n<td>Unix timestamp of last communication from each node</td>\n</tr>\n<tr>\n<td><code>SuspicionLevel</code></td>\n<td><code>map[NodeID]int</code></td>\n<td>Graduated suspicion levels for potentially failed nodes</td>\n</tr>\n<tr>\n<td><code>Term</code></td>\n<td><code>uint64</code></td>\n<td>Current cluster membership term for consistency checking</td>\n</tr>\n</tbody></table>\n<p>The <code>Members</code> map provides O(1) lookup of node information during message routing and election decisions. The <code>LastSeen</code> timestamps enable failure detection by tracking communication recency. The <code>SuspicionLevel</code> field implements graduated failure detection - rather than immediately declaring a node dead after one missed heartbeat, the system increases suspicion levels and requires multiple consecutive failures before removing a node from the active membership.</p>\n<p><strong>Membership State Transitions</strong></p>\n<p>Nodes transition through several states in the membership model, reflecting their current availability and participation status:</p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Event</th>\n<th>Next State</th>\n<th>Actions Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unknown</td>\n<td>Join Request</td>\n<td>Suspected</td>\n<td>Add to members map, start monitoring</td>\n</tr>\n<tr>\n<td>Suspected</td>\n<td>Heartbeat Received</td>\n<td>Active</td>\n<td>Reset suspicion level, update last seen</td>\n</tr>\n<tr>\n<td>Active</td>\n<td>Heartbeat Timeout</td>\n<td>Suspected</td>\n<td>Increment suspicion level</td>\n</tr>\n<tr>\n<td>Suspected</td>\n<td>Multiple Timeouts</td>\n<td>Failed</td>\n<td>Remove from active members, trigger election if was leader</td>\n</tr>\n<tr>\n<td>Failed</td>\n<td>Heartbeat Received</td>\n<td>Suspected</td>\n<td>Re-add to members, reset monitoring</td>\n</tr>\n<tr>\n<td>Active</td>\n<td>Explicit Leave</td>\n<td>Departed</td>\n<td>Remove from members, no election trigger</td>\n</tr>\n</tbody></table>\n<p>This graduated approach prevents membership churn due to temporary network hiccups while ensuring that truly failed nodes are eventually removed from the active membership. The distinction between &quot;Failed&quot; and &quot;Departed&quot; states helps with debugging - departed nodes left gracefully, while failed nodes stopped responding unexpectedly.</p>\n<p><strong>Membership Update Mechanisms</strong></p>\n<p>Several mechanisms work together to maintain accurate membership information across the cluster:</p>\n<ol>\n<li><p><strong>Heartbeat-Based Discovery</strong>: Active leaders periodically broadcast heartbeat messages that include their current membership view. Followers compare this information with their local view and request updates for any discrepancies.</p>\n</li>\n<li><p><strong>Join Protocol</strong>: New nodes announce themselves to the cluster using a standardized join message that includes their ID, address, and capabilities. Existing members validate the join request and update their membership tables accordingly.</p>\n</li>\n<li><p><strong>Failure Detection Integration</strong>: The failure detection subsystem automatically updates membership when nodes become unresponsive. This integration ensures that election algorithms always work with current membership information.</p>\n</li>\n<li><p><strong>Explicit Leave Notifications</strong>: Nodes shutting down gracefully send leave messages to inform other members of their intentional departure. This prevents unnecessary failure detection and election triggering.</p>\n</li>\n</ol>\n<p><strong>Membership Consistency Challenges</strong></p>\n<p>Maintaining consistent membership views across all nodes presents several technical challenges that directly impact election correctness:</p>\n<p>⚠️ <strong>Pitfall: Split-Brain Membership Views</strong>\nDifferent nodes may have inconsistent views of cluster membership, especially during network partitions. Node A might believe Node C has failed, while Node B still considers Node C active. This can lead to multiple simultaneous elections or incorrect leader selection. The solution is to include membership version information in election messages and require nodes to reconcile their views before participating in elections.</p>\n<p>⚠️ <strong>Pitfall: Premature Failure Detection</strong>\nAggressive failure detection timeouts can cause nodes to be incorrectly marked as failed during temporary network congestion or garbage collection pauses. This creates membership churn and unnecessary elections. The graduated suspicion levels and configurable timeout values help balance responsiveness with stability.</p>\n<p>The membership model also must handle the fundamental challenge of determining cluster quorum - how many nodes must be reachable to conduct a valid election. During network partitions, different groups of nodes may each believe they constitute a valid majority, leading to split-brain scenarios.</p>\n<blockquote>\n<p><strong>Decision: Graduated Failure Detection with Configurable Timeouts</strong></p>\n<ul>\n<li><strong>Context</strong>: Need balance between quick failure detection and stability during network hiccups</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Binary alive/dead based on single heartbeat timeout (fast but unstable)</li>\n<li>Graduated suspicion levels with multiple timeouts (slower but more stable)</li>\n<li>External failure detector service (adds complexity and single point of failure)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement graduated suspicion levels with configurable timeout parameters</li>\n<li><strong>Rationale</strong>: Provides tunable balance between detection speed and false positive rate. Allows different timeout values for different network conditions without code changes</li>\n<li><strong>Consequences</strong>: More complex state management and requires careful timeout parameter tuning, but significantly reduces membership churn in unstable network conditions</li>\n</ul>\n</blockquote>\n<p><strong>Quorum and Split-Brain Prevention</strong></p>\n<p>The membership model must integrate with quorum mechanisms to prevent split-brain scenarios during network partitions. A quorum represents the minimum number of nodes that must be reachable to conduct valid cluster operations, including leader elections.</p>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Total Nodes</th>\n<th>Quorum Size</th>\n<th>Partition A</th>\n<th>Partition B</th>\n<th>Valid Elections</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Simple Majority</td>\n<td>5</td>\n<td>3</td>\n<td>3 nodes</td>\n<td>2 nodes</td>\n<td>Partition A only</td>\n</tr>\n<tr>\n<td>Simple Majority</td>\n<td>6</td>\n<td>4</td>\n<td>3 nodes</td>\n<td>3 nodes</td>\n<td>Neither partition</td>\n</tr>\n<tr>\n<td>Dynamic Quorum</td>\n<td>5</td>\n<td>3</td>\n<td>3 nodes</td>\n<td>2 nodes</td>\n<td>Partition A only</td>\n</tr>\n</tbody></table>\n<p>The quorum calculation directly uses the membership information to determine election validity. Nodes must verify they can communicate with a quorum of cluster members before initiating or participating in leader elections. This prevents minority partitions from electing leaders that the majority partition would not recognize.</p>\n<p><strong>Membership Message Integration</strong></p>\n<p>The membership model integrates closely with the election message formats by including membership metadata in election communications:</p>\n<p><strong>Enhanced Election Messages with Membership Context</strong></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>MembershipTerm</code></td>\n<td><code>uint64</code></td>\n<td>Version of membership view used for this election</td>\n</tr>\n<tr>\n<td><code>KnownMembers</code></td>\n<td><code>[]NodeID</code></td>\n<td>List of nodes the sender believes are currently active</td>\n</tr>\n<tr>\n<td><code>QuorumSize</code></td>\n<td><code>int</code></td>\n<td>Minimum nodes required for valid election</td>\n</tr>\n</tbody></table>\n<p>This integration ensures that election decisions are based on consistent membership information and helps nodes detect when their membership views are out of sync. When a node receives an election message with a different membership term or member list, it can request a membership update before participating in the election.</p>\n<p>The membership model serves as the foundation for all higher-level coordination protocols. By providing accurate, eventually consistent information about cluster participation, it enables the election algorithms to make correct decisions about leadership while maintaining system stability during various failure scenarios.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides concrete implementation details for the data structures and message formats described above, with complete Go code that junior developers can use as a foundation for building their leader election system.</p>\n<p><strong>A. Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Serialization</td>\n<td>JSON with encoding/json</td>\n<td>Protocol Buffers with protobuf</td>\n</tr>\n<tr>\n<td>Message Transport</td>\n<td>HTTP POST with JSON bodies</td>\n<td>gRPC with streaming</td>\n</tr>\n<tr>\n<td>State Persistence</td>\n<td>In-memory maps</td>\n<td>Embedded database (BadgerDB)</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>JSON config files</td>\n<td>YAML with validation</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard log package</td>\n<td>Structured logging (logrus/zap)</td>\n</tr>\n</tbody></table>\n<p>For learning purposes, start with the simple options and migrate to advanced options once the core algorithms are working correctly.</p>\n<p><strong>B. Recommended File Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>leader-election/\n  cmd/\n    node/\n      main.go                 ← node entry point\n  internal/\n    types/\n      node.go                 ← core data structures\n      messages.go             ← message formats\n      membership.go           ← cluster membership\n    transport/\n      transport.go            ← transport interface\n      http_transport.go       ← HTTP implementation\n    election/\n      coordinator.go          ← election coordinator interface\n      bully.go               ← bully algorithm\n      ring.go                ← ring algorithm\n  pkg/\n    config/\n      config.go              ← configuration structures</code></pre></div>\n\n<p><strong>C. Core Data Structures (Complete Implementation)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/types/node.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> types</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NodeID represents a unique node identifier</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#F97583\"> uint64</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NodeState represents the current election state of a node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NodeState</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Node state constants</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateFollower</span><span style=\"color:#B392F0\"> NodeState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateCandidate</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateLeader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// String returns human-readable state names</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#B392F0\">NodeState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> s {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> StateFollower:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"Follower\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> StateCandidate:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"Candidate\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> StateLeader:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"Leader\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"Unknown\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Node represents a cluster member</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Node</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID      </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\">    `json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Address </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"address\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    State   </span><span style=\"color:#B392F0\">NodeState</span><span style=\"color:#9ECBFF\"> `json:\"state\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// String returns a formatted node description</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">n </span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Node{ID: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">, Address: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">, State: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">}\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        n.ID, n.Address, n.State)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ClusterMembership manages the view of cluster members</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ClusterMembership</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex         </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    members       </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastSeen      </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    suspicionLevel </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    term          </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    localNodeID   </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewClusterMembership creates a new membership manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewClusterMembership</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">localID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ClusterMembership</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        members:       </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lastSeen:      </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        suspicionLevel: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        term:          </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        localNodeID:   localID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UpdateMembership updates the known cluster nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdateMembership</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodes</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cm.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> cm.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement membership update logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate node information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update internal maps</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Increment membership term</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Trigger callbacks for membership changes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetActiveMembers returns currently active cluster members</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetActiveMembers</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cm.mutex.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> cm.mutex.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> active []</span><span style=\"color:#B392F0\">Node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, node </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> cm.members {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        active </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(active, node)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> active</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MarkNodeSeen updates the last seen timestamp for a node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MarkNodeSeen</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cm.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> cm.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cm.lastSeen[nodeID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cm.suspicionLevel[nodeID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#6A737D\"> // Reset suspicion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IncreaseSuspicion increments suspicion level for a node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IncreaseSuspicion</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cm.mutex.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> cm.mutex.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cm.suspicionLevel[nodeID]</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> cm.suspicionLevel[nodeID]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Message Format Implementation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/types/messages.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> types</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MessageType identifies different message categories</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MessageType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Message type constants</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgElection</span><span style=\"color:#B392F0\"> MessageType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgOK</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgCoordinator</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgHeartbeat</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgRingToken</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// String returns human-readable message type names</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mt </span><span style=\"color:#B392F0\">MessageType</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> mt {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MsgElection:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"Election\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MsgOK:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"OK\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MsgCoordinator:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"Coordinator\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MsgHeartbeat:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"Heartbeat\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MsgRingToken:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"RingToken\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"Unknown\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Message represents the base message structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Message</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type    </span><span style=\"color:#B392F0\">MessageType</span><span style=\"color:#9ECBFF\"> `json:\"type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    From    </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\">      `json:\"from\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    To      </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\">      `json:\"to\"`</span><span style=\"color:#6A737D\"> // 0 for broadcast</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Payload []</span><span style=\"color:#F97583\">byte</span><span style=\"color:#9ECBFF\">      `json:\"payload\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ElectionMessage represents bully algorithm election initiation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ElectionMessage</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ElectionID  </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"election_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CandidateID </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\"> `json:\"candidate_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Term        </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"term\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// OKMessage represents bully algorithm acknowledgment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> OKMessage</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ElectionID  </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"election_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResponderID </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\"> `json:\"responder_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CoordinatorMessage announces the new leader</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CoordinatorMessage</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LeaderID   </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\"> `json:\"leader_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Term       </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"term\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ElectionID </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"election_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HeartbeatMessage provides leader liveness indication</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> HeartbeatMessage</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LeaderID  </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\"> `json:\"leader_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Term      </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\"> `json:\"term\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">  `json:\"timestamp\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RingToken represents ring election token</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RingToken</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ElectionID   </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\">   `json:\"election_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InitiatorID  </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\">   `json:\"initiator_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Participants []</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\"> `json:\"participants\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Complete     </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">     `json:\"complete\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MessageBuilder helps construct typed messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MessageBuilder</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fromNodeID </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewMessageBuilder creates a message builder for a node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewMessageBuilder</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageBuilder</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">MessageBuilder</span><span style=\"color:#E1E4E8\">{fromNodeID: nodeID}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BuildElectionMessage creates an election message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mb </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageBuilder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">BuildElectionMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">to</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">electionID</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">term</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> ElectionMessage</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ElectionID:  electionID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CandidateID: mb.fromNodeID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Term:        term,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Marshal</span><span style=\"color:#E1E4E8\">(payload)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Type:    MsgElection,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        From:    mb.fromNodeID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        To:      to,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Payload: data,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BuildCoordinatorMessage creates a coordinator announcement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mb </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageBuilder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">BuildCoordinatorMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">leaderID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">term</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">electionID</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> CoordinatorMessage</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LeaderID:   leaderID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Term:       term,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ElectionID: electionID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Marshal</span><span style=\"color:#E1E4E8\">(payload)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Type:    MsgCoordinator,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        From:    mb.fromNodeID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        To:      </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// Broadcast</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Payload: data,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BuildHeartbeatMessage creates a heartbeat message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mb </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageBuilder</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">BuildHeartbeatMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">term</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    payload </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> HeartbeatMessage</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        LeaderID:  mb.fromNodeID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Term:      term,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Timestamp: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Unix</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Marshal</span><span style=\"color:#E1E4E8\">(payload)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Type:    MsgHeartbeat,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        From:    mb.fromNodeID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        To:      </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// Broadcast</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Payload: data,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Transport Interface Definition</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/transport/transport.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> transport</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">leader-election/internal/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Transport defines the interface for inter-node communication</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Transport</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SendMessage sends a message to a specific node</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SendMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // BroadcastMessage sends a message to all known nodes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    BroadcastMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ReceiveMessages returns a channel of incoming messages</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ReceiveMessages</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;-chan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // UpdateMembership updates the transport's view of cluster members</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    UpdateMembership</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodes</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Start begins listening for messages</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Start</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Stop gracefully shuts down the transport</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Stop</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>F. Election Coordinator Interface</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/election/coordinator.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> election</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">leader-election/internal/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ElectionCoordinator manages leader election algorithms</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ElectionCoordinator</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // StartElection initiates a new leader election</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    StartElection</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // HandleMessage processes incoming election messages</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    HandleMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // GetCurrentLeader returns the current leader ID</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetCurrentLeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // IsLeader checks if this node is the current leader</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    IsLeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // SetMembership updates the known cluster membership</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SetMembership</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">members</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>G. Configuration Structure</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// pkg/config/config.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> config</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">leader-election/internal/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Config holds all configuration for a leader election node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Config</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Node configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NodeID      </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\"> `json:\"node_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ListenAddr  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"listen_addr\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Cluster configuration  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InitialPeers []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"initial_peers\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Election algorithm selection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Algorithm </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"algorithm\"`</span><span style=\"color:#6A737D\"> // \"bully\" or \"ring\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Timing configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HeartbeatInterval </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"heartbeat_interval\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ElectionTimeout   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"election_timeout\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FailureTimeout    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"failure_timeout\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Advanced settings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxSuspicionLevel </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\"> `json:\"max_suspicion_level\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LoadConfig reads configuration from a JSON file</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> LoadConfig</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">filename</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Config</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> os.</span><span style=\"color:#B392F0\">ReadFile</span><span style=\"color:#E1E4E8\">(filename)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> config </span><span style=\"color:#B392F0\">Config</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Unmarshal</span><span style=\"color:#E1E4E8\">(data, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">config)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">config, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DefaultConfig returns sensible default configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> DefaultConfig</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Config</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Config</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Algorithm:         </span><span style=\"color:#9ECBFF\">\"bully\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        HeartbeatInterval: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ElectionTimeout:   </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        FailureTimeout:    </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        MaxSuspicionLevel: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>H. Milestone Checkpoint: Data Structures Validation</strong></p>\n<p>After implementing these data structures, validate them with this simple test:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run the data structure tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/types/...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create a simple main function to test message creation:</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/test-messages/main.go</span></span></code></pre></div>\n\n<p>Expected behavior:</p>\n<ol>\n<li>All message types should serialize/deserialize correctly to/from JSON</li>\n<li>Node state transitions should be validated</li>\n<li>Membership updates should trigger appropriate callbacks</li>\n<li>Message builder should create well-formed messages</li>\n</ol>\n<p><strong>I. Common Implementation Mistakes</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JSON marshal errors</td>\n<td>Missing struct tags</td>\n<td>Check error messages for field names</td>\n<td>Add <code>json:&quot;field_name&quot;</code> tags to all exported fields</td>\n</tr>\n<tr>\n<td>Race conditions</td>\n<td>Missing mutex protection</td>\n<td>Use <code>go run -race</code> to detect races</td>\n<td>Add proper mutex protection around shared maps</td>\n</tr>\n<tr>\n<td>Memory leaks</td>\n<td>Maps never cleaned up</td>\n<td>Monitor memory usage over time</td>\n<td>Implement cleanup for old membership entries</td>\n</tr>\n<tr>\n<td>Message routing failures</td>\n<td>Incorrect NodeID comparison</td>\n<td>Log message routing decisions</td>\n<td>Ensure NodeID 0 is reserved for broadcasts</td>\n</tr>\n</tbody></table>\n<p><strong>J. Language-Specific Tips for Go</strong></p>\n<ul>\n<li>Use <code>sync.RWMutex</code> for membership maps - many readers, few writers</li>\n<li>Implement <code>String()</code> methods for all custom types for better debugging</li>\n<li>Use <code>encoding/json</code> struct tags to control serialization field names</li>\n<li>Consider using <code>context.Context</code> for cancellable operations</li>\n<li>Use typed constants with <code>iota</code> for enumerations</li>\n<li>Implement proper error handling with wrapped errors using <code>fmt.Errorf</code></li>\n</ul>\n<p>This implementation foundation provides all the basic data structures needed for the next milestones while following Go idioms and best practices. The code is production-ready for the infrastructure components (serialization, configuration, interfaces) while providing clear TODO markers for the core election logic that learners should implement themselves.</p>\n<h2 id=\"node-communication-layer\">Node Communication Layer</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (Node Communication) - establishing the foundational messaging infrastructure that enables all leader election algorithms</p>\n</blockquote>\n<h3 id=\"mental-model-postal-service-with-tracking\">Mental Model: Postal Service with Tracking</h3>\n<p>Think of the node communication layer as a sophisticated postal service that connects all offices (nodes) in a large corporation. Just like the postal service, our system needs to solve several fundamental challenges:</p>\n<p><strong>Address Discovery</strong>: Before you can send mail, you need to know which offices exist and where they&#39;re located. Our nodes face the same challenge - they must discover their peers and maintain an up-to-date directory of active participants. This is like maintaining a corporate phone book that automatically updates when new branches open or existing ones close.</p>\n<p><strong>Reliable Delivery</strong>: When you send an important document via certified mail, you expect confirmation that it arrived. Our messaging system provides similar guarantees - when Node A sends an election message to Node B, it needs to know whether the message was delivered or if Node B is unreachable. Unlike simple email, our system can&#39;t afford to lose critical election messages.</p>\n<p><strong>Failure Detection</strong>: The postal service tracks which addresses are invalid or unreachable. Similarly, our system must detect when nodes become unavailable due to crashes, network issues, or maintenance. This detection triggers the leader election process - just as a company would need to elect a new department head if the current one becomes unavailable.</p>\n<p><strong>Broadcast Announcements</strong>: Sometimes you need to send the same memo to every office simultaneously. In leader election, the winning candidate must announce their victory to all participants. Our broadcast mechanism ensures every active node receives coordinator announcements, preventing confusion about who&#39;s currently in charge.</p>\n<p>The key insight is that reliable communication forms the foundation for all election algorithms. Without trustworthy message delivery and accurate failure detection, election algorithms would make incorrect decisions based on incomplete information.</p>\n<h3 id=\"node-discovery-and-membership\">Node Discovery and Membership</h3>\n<p>Node discovery and membership management solve the fundamental question: &quot;Who else is in this cluster, and how do I reach them?&quot; This component maintains the cluster&#39;s membership view and handles the dynamic nature of distributed systems where nodes join, leave, and fail unpredictably.</p>\n<p><strong>Cluster Membership Representation</strong></p>\n<p>The cluster membership component tracks all known nodes and their current status. Each node maintains a local view of cluster membership that gets updated through discovery mechanisms and runtime observations.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>nodes</code></td>\n<td><code>map[NodeID]Node</code></td>\n<td>Complete registry of all known cluster members indexed by unique node ID</td>\n</tr>\n<tr>\n<td><code>activeMembers</code></td>\n<td><code>[]NodeID</code></td>\n<td>List of currently responsive nodes that can participate in elections</td>\n</tr>\n<tr>\n<td><code>lastSeen</code></td>\n<td><code>map[NodeID]int64</code></td>\n<td>Timestamp of last successful communication with each node (Unix milliseconds)</td>\n</tr>\n<tr>\n<td><code>suspicionLevels</code></td>\n<td><code>map[NodeID]int</code></td>\n<td>Failure detection suspicion counter - higher values indicate likely node failure</td>\n</tr>\n<tr>\n<td><code>joinTimestamps</code></td>\n<td><code>map[NodeID]int64</code></td>\n<td>When each node first joined the cluster (for tie-breaking and priority)</td>\n</tr>\n</tbody></table>\n<p>The membership manager provides essential operations for maintaining cluster awareness:</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>UpdateMembership</code></td>\n<td><code>nodes []Node</code></td>\n<td><code>error</code></td>\n<td>Bulk update of known cluster members from configuration or discovery</td>\n</tr>\n<tr>\n<td><code>GetActiveMembers</code></td>\n<td>none</td>\n<td><code>[]Node</code></td>\n<td>Returns list of nodes currently considered alive and reachable</td>\n</tr>\n<tr>\n<td><code>AddNode</code></td>\n<td><code>node Node</code></td>\n<td><code>error</code></td>\n<td>Registers a new node that joined the cluster dynamically</td>\n</tr>\n<tr>\n<td><code>RemoveNode</code></td>\n<td><code>nodeID NodeID</code></td>\n<td><code>error</code></td>\n<td>Permanently removes a node from cluster membership</td>\n</tr>\n<tr>\n<td><code>MarkNodeSeen</code></td>\n<td><code>nodeID NodeID</code></td>\n<td>none</td>\n<td>Updates last-seen timestamp when receiving any message from the node</td>\n</tr>\n<tr>\n<td><code>IncreaseSuspicion</code></td>\n<td><code>nodeID NodeID</code></td>\n<td><code>int</code></td>\n<td>Increments suspicion level when communication fails, returns new level</td>\n</tr>\n<tr>\n<td><code>ResetSuspicion</code></td>\n<td><code>nodeID NodeID</code></td>\n<td>none</td>\n<td>Clears suspicion level when node responds successfully</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Static vs Dynamic Discovery</strong></p>\n<ul>\n<li><strong>Context</strong>: Clusters can use static configuration files listing all members, or dynamic discovery through multicast/broadcast announcements</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Static configuration only (simple, deterministic)</li>\n<li>Dynamic multicast discovery (flexible, auto-joining)</li>\n<li>Hybrid approach supporting both methods</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Hybrid approach with static configuration as primary and optional multicast discovery</li>\n<li><strong>Rationale</strong>: Static configuration provides deterministic membership for production environments while multicast enables easier development and testing. This covers both use cases without forcing a single approach.</li>\n<li><strong>Consequences</strong>: Requires implementing both discovery mechanisms but provides maximum deployment flexibility</li>\n</ul>\n</blockquote>\n<p><strong>Static Configuration Discovery</strong></p>\n<p>Static discovery reads cluster membership from configuration files or environment variables. This approach provides deterministic membership that doesn&#39;t change during runtime, making it suitable for production deployments with known infrastructure.</p>\n<p>The static configuration specifies each node&#39;s ID, network address, and optional metadata:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Node ID: 1001, Address: 192.168.1.10:8080\nNode ID: 1002, Address: 192.168.1.11:8080  \nNode ID: 1003, Address: 192.168.1.12:8080</code></pre></div>\n\n<p>Static discovery follows this initialization sequence:</p>\n<ol>\n<li>The node reads its configuration file containing all cluster members</li>\n<li>It validates that its own node ID appears in the member list</li>\n<li>It attempts to establish connections with all configured peers</li>\n<li>It marks peers as active or suspected based on initial connectivity tests</li>\n<li>It begins heartbeat monitoring for ongoing failure detection</li>\n</ol>\n<p><strong>Dynamic Multicast Discovery</strong></p>\n<p>Dynamic discovery uses UDP multicast to announce node presence and discover peers automatically. This approach enables nodes to join clusters without prior configuration, making it ideal for development environments and auto-scaling deployments.</p>\n<p>The multicast discovery protocol works as follows:</p>\n<ol>\n<li>New nodes broadcast JOIN_ANNOUNCEMENT messages to a well-known multicast group</li>\n<li>Existing cluster members respond with MEMBERSHIP_UPDATE messages containing current member lists  </li>\n<li>The new node validates responses and builds its initial membership view</li>\n<li>All nodes periodically broadcast HEARTBEAT_ANNOUNCE messages to maintain discovery</li>\n<li>Nodes that stop receiving announcements from a peer mark it as suspected</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Message Type</th>\n<th>Multicast Group</th>\n<th>Port</th>\n<th>Content</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>JOIN_ANNOUNCEMENT</code></td>\n<td>224.0.1.200</td>\n<td>7946</td>\n<td>Node ID, listening address, cluster name</td>\n</tr>\n<tr>\n<td><code>MEMBERSHIP_UPDATE</code></td>\n<td>224.0.1.200</td>\n<td>7946</td>\n<td>Full member list with addresses and last-seen times</td>\n</tr>\n<tr>\n<td><code>HEARTBEAT_ANNOUNCE</code></td>\n<td>224.0.1.200</td>\n<td>7946</td>\n<td>Node ID, current term, leader ID (if known)</td>\n</tr>\n</tbody></table>\n<p><strong>Membership Consistency and Split Views</strong></p>\n<p>Different nodes may temporarily hold inconsistent views of cluster membership due to network delays, partitions, or node failures. The system handles membership inconsistencies through several mechanisms:</p>\n<p><em>Membership Reconciliation</em>: When nodes exchange messages during elections, they include their current membership views. Receiving nodes merge this information with their local state, adding newly discovered members and updating last-seen timestamps for known members.</p>\n<p><em>Partition Detection</em>: Nodes detect potential network partitions by comparing their active member count with the expected cluster size. If a node can only reach a small subset of configured members, it assumes it&#39;s in the minority partition and avoids starting elections that could create split-brain scenarios.</p>\n<p><em>Member Prioritization</em>: When membership views conflict, nodes prioritize information from recently active members over stale entries. Members that have communicated within the failure detection timeout carry higher authority for membership updates.</p>\n<h3 id=\"reliable-message-passing\">Reliable Message Passing</h3>\n<p>Message passing provides the communication foundation that election algorithms depend on. The system must deliver messages reliably between specific nodes (point-to-point) and to all active cluster members (broadcast) while handling network failures gracefully.</p>\n<p><strong>Transport Abstraction Layer</strong></p>\n<p>The transport layer abstracts network communication details behind a common interface, allowing different implementations (HTTP, UDP, TCP) while providing consistent semantics to election algorithms.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SendMessage</code></td>\n<td><code>target NodeID, msg *Message</code></td>\n<td><code>error</code></td>\n<td>Delivers message to specific node with delivery confirmation</td>\n</tr>\n<tr>\n<td><code>BroadcastMessage</code></td>\n<td><code>msg *Message</code></td>\n<td><code>error</code></td>\n<td>Sends message to all currently active cluster members</td>\n</tr>\n<tr>\n<td><code>ReceiveMessages</code></td>\n<td>none</td>\n<td><code>&lt;-chan *Message</code></td>\n<td>Returns channel for incoming messages from all sources</td>\n</tr>\n<tr>\n<td><code>RegisterHandler</code></td>\n<td><code>msgType MessageType, handler func(*Message)</code></td>\n<td>none</td>\n<td>Registers callback function for specific message types</td>\n</tr>\n<tr>\n<td><code>GetReachableNodes</code></td>\n<td>none</td>\n<td><code>[]NodeID</code></td>\n<td>Returns list of nodes currently reachable via transport</td>\n</tr>\n<tr>\n<td><code>Close</code></td>\n<td>none</td>\n<td><code>error</code></td>\n<td>Cleanly shuts down transport and releases network resources</td>\n</tr>\n</tbody></table>\n<p><strong>Message Structure and Serialization</strong></p>\n<p>All inter-node communication uses a standardized message format that includes routing information, message type classification, and payload data. The message structure supports both election-specific protocols and general cluster coordination.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Type</code></td>\n<td><code>MessageType</code></td>\n<td>Enum identifying message category (election, heartbeat, coordinator, etc.)</td>\n</tr>\n<tr>\n<td><code>From</code></td>\n<td><code>NodeID</code></td>\n<td>Source node ID for routing responses and tracking message origin</td>\n</tr>\n<tr>\n<td><code>To</code></td>\n<td><code>NodeID</code></td>\n<td>Destination node ID for point-to-point messages (0 for broadcasts)</td>\n</tr>\n<tr>\n<td><code>Term</code></td>\n<td><code>uint64</code></td>\n<td>Election term number for ordering and detecting stale messages</td>\n</tr>\n<tr>\n<td><code>Timestamp</code></td>\n<td><code>int64</code></td>\n<td>Unix milliseconds when message was created (for timeout detection)</td>\n</tr>\n<tr>\n<td><code>Payload</code></td>\n<td><code>[]byte</code></td>\n<td>Serialized message-type-specific data (election details, heartbeat info, etc.)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Message Serialization Format</strong></p>\n<ul>\n<li><strong>Context</strong>: Messages need serialization for network transmission with requirements for performance, debuggability, and cross-language compatibility</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>JSON (human readable, widely supported, verbose)</li>\n<li>Protocol Buffers (compact, fast, requires schema)</li>\n<li>MessagePack (compact, schema-free, less tooling)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: JSON for simplicity with option to upgrade to Protocol Buffers later</li>\n<li><strong>Rationale</strong>: JSON provides excellent debugging capability and eliminates schema management complexity. Performance overhead is acceptable for election message volumes.</li>\n<li><strong>Consequences</strong>: Larger message sizes and slower serialization, but significantly easier development and debugging experience</li>\n</ul>\n</blockquote>\n<p><strong>Point-to-Point Message Delivery</strong></p>\n<p>Point-to-point messaging delivers messages from one specific node to another with delivery confirmation. This is essential for bully algorithm ELECTION and OK messages where the sender needs to know whether the target node responded.</p>\n<p>The point-to-point delivery process follows these steps:</p>\n<ol>\n<li>The sender serializes the message and establishes a connection to the target node</li>\n<li>It transmits the message with a unique sequence number for tracking</li>\n<li>The receiver deserializes the message and sends an acknowledgment response</li>\n<li>The sender waits for acknowledgment within a configurable timeout period</li>\n<li>If no acknowledgment arrives, the sender retries up to a maximum retry count</li>\n<li>After exhausting retries, the sender reports the target node as unreachable</li>\n</ol>\n<p><strong>Broadcast Message Delivery</strong></p>\n<p>Broadcast messaging delivers the same message to all currently active cluster members simultaneously. This is crucial for coordinator announcements where the newly elected leader must notify all participants of the election outcome.</p>\n<p>The broadcast implementation provides different delivery semantics based on requirements:</p>\n<p><em>Best-Effort Broadcast</em>: Sends messages to all known active members but doesn&#39;t wait for confirmations. Failed deliveries are logged but don&#39;t block the broadcast operation. This is suitable for periodic heartbeats and non-critical announcements.</p>\n<p><em>Reliable Broadcast</em>: Attempts delivery to all active members and tracks individual acknowledgments. The broadcast succeeds only when a configurable percentage of members acknowledge receipt. This ensures critical messages like coordinator announcements reach most of the cluster.</p>\n<table>\n<thead>\n<tr>\n<th>Broadcast Type</th>\n<th>Acknowledgment Required</th>\n<th>Failure Behavior</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Best-Effort</td>\n<td>No</td>\n<td>Log and continue</td>\n<td>Heartbeats, periodic updates</td>\n</tr>\n<tr>\n<td>Reliable</td>\n<td>Yes (configurable %)</td>\n<td>Retry failed deliveries</td>\n<td>Election results, leadership changes</td>\n</tr>\n<tr>\n<td>Atomic</td>\n<td>Yes (all members)</td>\n<td>Abort on any failure</td>\n<td>Critical coordination messages</td>\n</tr>\n</tbody></table>\n<p><strong>Message Ordering and Duplicate Detection</strong></p>\n<p>Distributed systems can deliver messages out of order or deliver the same message multiple times due to network retransmissions. The communication layer handles these challenges through sequence numbering and deduplication.</p>\n<p>Each node maintains sequence counters for outgoing messages and tracks received message IDs to detect duplicates. Messages include both sender-specific sequence numbers and globally unique identifiers for comprehensive duplicate detection.</p>\n<p><strong>Network Failure Handling</strong></p>\n<p>The transport layer detects and handles various network failure scenarios that commonly occur in distributed systems:</p>\n<p><em>Connection Timeouts</em>: When establishing connections to remote nodes takes longer than expected, the transport layer retries with exponential backoff and eventually marks the target as unreachable.</p>\n<p><em>Transmission Failures</em>: If message transmission fails due to closed connections or network errors, the system attempts to re-establish the connection and retransmit the message.</p>\n<p><em>Partial Network Partitions</em>: When a node can reach some cluster members but not others, it updates its reachable node list and informs the membership manager about suspected failures.</p>\n<h3 id=\"failure-detection-and-heartbeats\">Failure Detection and Heartbeats</h3>\n<p>Failure detection determines which cluster nodes are currently alive and participating versus those that have crashed, become unreachable, or are experiencing network connectivity issues. Accurate failure detection is crucial because false positives trigger unnecessary elections while false negatives delay necessary leadership transitions.</p>\n<p><strong>Heartbeat-Based Monitoring</strong></p>\n<p>The failure detection system uses periodic heartbeat messages to monitor node availability. Each node sends heartbeat messages at regular intervals and expects to receive heartbeats from all other cluster members. Missing heartbeats indicate potential node failures.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>LeaderID</code></td>\n<td><code>NodeID</code></td>\n<td>ID of the node currently believed to be the cluster leader</td>\n</tr>\n<tr>\n<td><code>Term</code></td>\n<td><code>uint64</code></td>\n<td>Current election term number known by the heartbeat sender</td>\n</tr>\n<tr>\n<td><code>Timestamp</code></td>\n<td><code>int64</code></td>\n<td>Unix milliseconds when heartbeat was generated</td>\n</tr>\n<tr>\n<td><code>ActiveMembers</code></td>\n<td><code>[]NodeID</code></td>\n<td>List of nodes the sender considers currently alive</td>\n</tr>\n<tr>\n<td><code>SenderLoad</code></td>\n<td><code>float64</code></td>\n<td>CPU/memory utilization for load-based leader selection (optional)</td>\n</tr>\n</tbody></table>\n<p>The heartbeat monitoring process works as follows:</p>\n<ol>\n<li>Each node broadcasts heartbeat messages every N seconds (configurable interval)</li>\n<li>Receiving nodes update their last-seen timestamps for the heartbeat sender</li>\n<li>Nodes monitor for missing heartbeats from each known cluster member</li>\n<li>If no heartbeat arrives within the failure detection timeout, suspicion levels increase</li>\n<li>Nodes with high suspicion levels are considered failed and removed from active membership</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Push vs Pull Heartbeat Model</strong></p>\n<ul>\n<li><strong>Context</strong>: Failure detection can use push (nodes broadcast &quot;I&#39;m alive&quot;) or pull (nodes query &quot;are you alive?&quot;) approaches</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Push-only (periodic broadcasts, low overhead)</li>\n<li>Pull-only (explicit health checks, accurate but chatty)</li>\n<li>Hybrid push-pull (broadcasts plus targeted queries)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Push-only with configurable intervals</li>\n<li><strong>Rationale</strong>: Push model provides good failure detection accuracy with minimal network overhead. Pull mechanisms add complexity and increase message volume significantly.</li>\n<li><strong>Consequences</strong>: May have slightly slower failure detection than pull models, but much better network efficiency and simpler implementation</li>\n</ul>\n</blockquote>\n<p><strong>Suspicion-Based Failure Detection</strong></p>\n<p>Rather than immediately declaring nodes failed after missing a single heartbeat, the system uses graduated suspicion levels that account for temporary network glitches and varying network latency.</p>\n<p>The suspicion mechanism works through several stages:</p>\n<table>\n<thead>\n<tr>\n<th>Suspicion Level</th>\n<th>Missed Heartbeats</th>\n<th>Node Status</th>\n<th>Actions Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0 (Healthy)</td>\n<td>0</td>\n<td>Active</td>\n<td>Include in elections, accept messages normally</td>\n</tr>\n<tr>\n<td>1 (Monitoring)</td>\n<td>1-2</td>\n<td>Active</td>\n<td>Continue normal operations, increase monitoring</td>\n</tr>\n<tr>\n<td>2 (Suspected)</td>\n<td>3-4</td>\n<td>Questionable</td>\n<td>Exclude from new elections, accept existing messages</td>\n</tr>\n<tr>\n<td>3 (Failed)</td>\n<td>5+</td>\n<td>Inactive</td>\n<td>Remove from active membership, ignore messages</td>\n</tr>\n</tbody></table>\n<p><em>Suspicion Escalation</em>: Each missed heartbeat increments the suspicion level for that node. The system only declares nodes failed after multiple consecutive missed heartbeats, reducing false positives from temporary network issues.</p>\n<p><em>Suspicion Recovery</em>: When a suspected node sends any valid message (heartbeat, election message, etc.), its suspicion level resets to zero immediately. This allows nodes to quickly recover from temporary network partitions or performance issues.</p>\n<p><strong>Adaptive Timeout Configuration</strong></p>\n<p>Network conditions vary significantly between deployment environments (local datacenter vs wide-area network vs cloud environments). The failure detection system adapts its timeout parameters based on observed network characteristics.</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Parameter</th>\n<th>Local Network</th>\n<th>Wide Area Network</th>\n<th>Cloud Environment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Heartbeat Interval</td>\n<td>1 second</td>\n<td>3 seconds</td>\n<td>2 seconds</td>\n</tr>\n<tr>\n<td>Failure Detection Timeout</td>\n<td>5 seconds</td>\n<td>15 seconds</td>\n<td>10 seconds</td>\n</tr>\n<tr>\n<td>Maximum Suspicion Level</td>\n<td>3</td>\n<td>5</td>\n<td>4</td>\n</tr>\n<tr>\n<td>Network Partition Threshold</td>\n<td>30 seconds</td>\n<td>60 seconds</td>\n<td>45 seconds</td>\n</tr>\n</tbody></table>\n<p>The system monitors round-trip message times and adjusts timeout parameters automatically:</p>\n<ol>\n<li>It tracks the 95th percentile of heartbeat round-trip times over rolling windows</li>\n<li>It sets failure detection timeouts to 3-5x the observed round-trip times</li>\n<li>It increases timeouts during periods of high network variability</li>\n<li>It gradually decreases timeouts when network conditions stabilize</li>\n</ol>\n<p><strong>Network Partition Detection</strong></p>\n<p>Network partitions split the cluster into isolated groups where nodes within each partition can communicate with each other but not with nodes in other partitions. Partition detection prevents split-brain scenarios where multiple partitions elect separate leaders simultaneously.</p>\n<p>The partition detection algorithm considers several factors:</p>\n<p><em>Reachability Analysis</em>: Nodes track which cluster members they can successfully communicate with. If a node can only reach a small fraction of the configured cluster size, it suspects it&#39;s in a minority partition.</p>\n<p><em>Quorum Requirements</em>: Elections require a minimum number of participating nodes (quorum) to produce valid results. Nodes that cannot reach a quorum of cluster members refuse to start or participate in elections.</p>\n<p><em>Partition Recovery</em>: When network connectivity returns, nodes from different partitions must reconcile their state. The system uses election term numbers to determine which partition had legitimate leadership and updates all nodes accordingly.</p>\n<p><strong>Leader-Specific Failure Detection</strong></p>\n<p>The current cluster leader requires special monitoring because leader failures trigger immediate re-election. The system uses enhanced failure detection for leaders with shorter timeout periods and more frequent health checks.</p>\n<p>Leader monitoring includes several specialized mechanisms:</p>\n<ol>\n<li><strong>Accelerated Heartbeats</strong>: Leaders send heartbeats twice as frequently as regular nodes</li>\n<li><strong>Explicit Health Queries</strong>: Followers can send direct health check messages to leaders</li>\n<li><strong>Reduced Failure Threshold</strong>: Leaders are considered failed after fewer missed heartbeats</li>\n<li><strong>Split-Brain Prevention</strong>: Multiple nodes claiming leadership are detected and resolved</li>\n</ol>\n<p>When leader failure is detected, any cluster member can initiate a new election. The failure detection system includes backoff mechanisms to prevent multiple nodes from starting concurrent elections simultaneously.</p>\n<p><strong>Common Pitfalls</strong></p>\n<p>⚠️ <strong>Pitfall: Heartbeat Storms During Network Issues</strong>\nWhen network connectivity is degraded, nodes may flood the network with heartbeat retries and failure detection messages. This can worsen network congestion and create cascading failures. The system prevents this by implementing exponential backoff for heartbeat intervals and rate-limiting failure detection messages during suspected network issues.</p>\n<p>⚠️ <strong>Pitfall: False Positives from GC Pauses</strong>\nLanguage runtime garbage collection can pause nodes for several seconds, causing them to miss heartbeat deadlines and be falsely declared failed. The system accounts for this by using longer timeout periods than typical GC pause times and allowing suspected nodes to quickly recover when they resume sending heartbeats.</p>\n<p>⚠️ <strong>Pitfall: Symmetric Network Failures</strong>\nTwo nodes may lose connectivity to each other while remaining connected to the rest of the cluster. Each node may suspect the other is failed, leading to inconsistent membership views. The system handles this by prioritizing membership information from nodes that can communicate with the majority of cluster members.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The node communication layer forms the foundation for all leader election algorithms. This section provides complete implementation guidance for building reliable messaging, membership management, and failure detection systems.</p>\n<p><strong>Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Transport Protocol</td>\n<td>HTTP/1.1 with JSON over TCP</td>\n<td>gRPC with Protocol Buffers</td>\n</tr>\n<tr>\n<td>Service Discovery</td>\n<td>Static configuration files</td>\n<td>etcd or Consul integration</td>\n</tr>\n<tr>\n<td>Serialization</td>\n<td>Standard library JSON</td>\n<td>MessagePack or Protocol Buffers</td>\n</tr>\n<tr>\n<td>Network Library</td>\n<td>Built-in net/http package</td>\n<td>Custom UDP with reliability layer</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard log package</td>\n<td>Structured logging (logrus, zap)</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>JSON/YAML files</td>\n<td>Environment variables + config management</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/communication/\n  transport.go              ← Transport interface and HTTP implementation\n  transport_test.go         ← Transport layer tests\n  membership.go             ← Cluster membership management\n  membership_test.go        ← Membership tests\n  discovery.go              ← Static and multicast node discovery\n  discovery_test.go         ← Discovery mechanism tests\n  failure_detector.go       ← Heartbeat and failure detection\n  failure_detector_test.go  ← Failure detection tests\n  message_builder.go        ← Message construction utilities\n  types.go                  ← All message types and constants</code></pre></div>\n\n<p><strong>Core Transport Infrastructure (Complete Implementation)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> communication</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">bytes</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">net/http</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HTTPTransport implements the Transport interface using HTTP/1.1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> HTTPTransport</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID       </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    listenAddr   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    server       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    client       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    membership   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    msgChan      </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    handlers     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">MessageType</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    handlerMu    </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    shutdown     </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewHTTPTransport</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">listenAddr</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">membership</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ClusterMembership</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nodeID:     nodeID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        listenAddr: listenAddr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        client: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Client</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Timeout: </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        membership: membership,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        msgChan:    </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        handlers:   </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">MessageType</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        shutdown:   </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Start</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> http.</span><span style=\"color:#B392F0\">NewServeMux</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mux.</span><span style=\"color:#B392F0\">HandleFunc</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/message\"</span><span style=\"color:#E1E4E8\">, t.handleIncomingMessage)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.server </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Server</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Addr:    t.listenAddr,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Handler: mux,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.server.</span><span style=\"color:#B392F0\">ListenAndServe</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> http.ErrServerClosed {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Log error - server failed to start</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleIncomingMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">w</span><span style=\"color:#B392F0\"> http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ResponseWriter</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">r</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">http</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Request</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> r.Method </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"POST\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        http.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(w, </span><span style=\"color:#9ECBFF\">\"Method not allowed\"</span><span style=\"color:#E1E4E8\">, http.StatusMethodNotAllowed)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> msg </span><span style=\"color:#B392F0\">Message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">NewDecoder</span><span style=\"color:#E1E4E8\">(r.Body).</span><span style=\"color:#B392F0\">Decode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">msg); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        http.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">(w, </span><span style=\"color:#9ECBFF\">\"Invalid message format\"</span><span style=\"color:#E1E4E8\">, http.StatusBadRequest)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update membership - mark sender as seen</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.membership.</span><span style=\"color:#B392F0\">MarkNodeSeen</span><span style=\"color:#E1E4E8\">(msg.From)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Route to handler if registered, otherwise send to channel</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.handlerMu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> handler, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> t.handlers[msg.Type]; exists {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.handlerMu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        go</span><span style=\"color:#B392F0\"> handler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">msg)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.handlerMu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#E1E4E8\"> t.msgChan </span><span style=\"color:#F97583\">&#x3C;-</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">msg:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">t.shutdown:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Channel full - drop message or handle overflow</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    w.</span><span style=\"color:#B392F0\">WriteHeader</span><span style=\"color:#E1E4E8\">(http.StatusOK)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Cluster Membership Management (Complete Implementation)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ClusterMembership</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu              </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodes           </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    activeMembers   []</span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastSeen        </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    suspicionLevels </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    joinTimestamps  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failureTimeout  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxSuspicion    </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewClusterMembership</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">failureTimeout</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">maxSuspicion</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ClusterMembership</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nodes:           </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        activeMembers:   </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lastSeen:        </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        suspicionLevels: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        joinTimestamps:  </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        failureTimeout:  failureTimeout,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        maxSuspicion:    maxSuspicion,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdateMembership</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodes</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">Node</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cm.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> cm.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    now </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UnixMilli</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, node </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> nodes {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> _, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cm.nodes[node.ID]; </span><span style=\"color:#F97583\">!</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // New node discovered</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cm.nodes[node.ID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cm.lastSeen[node.ID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> now</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cm.suspicionLevels[node.ID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cm.joinTimestamps[node.ID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> now</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Update existing node info</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cm.nodes[node.ID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cm.</span><span style=\"color:#B392F0\">updateActiveMembers</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">updateActiveMembers</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Must be called with lock held</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    now </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UnixMilli</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timeoutMs </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cm.failureTimeout.</span><span style=\"color:#B392F0\">Milliseconds</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cm.activeMembers </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cm.activeMembers[:</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#6A737D\">// Clear slice but keep capacity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> nodeID, lastSeenTime </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> cm.lastSeen {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timeSinceLastSeen </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> lastSeenTime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        suspicion </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cm.suspicionLevels[nodeID]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Node is active if recently seen and suspicion is low</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> timeSinceLastSeen </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> timeoutMs </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> suspicion </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> cm.maxSuspicion {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cm.activeMembers </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(cm.activeMembers, nodeID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeletons for Implementation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// SendMessage delivers a message to a specific target node with retry logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SendMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Look up target node address from membership</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set message routing fields (From, To, Timestamp)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Serialize message to JSON</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create HTTP POST request to target's /message endpoint</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Send request with timeout and retry on failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Handle response - update membership on success/failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return delivery confirmation or error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BroadcastMessage sends a message to all currently active cluster members</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">HTTPTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">BroadcastMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get current active member list from membership manager</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set broadcast routing fields (From=self, To=0 for broadcast)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send message to each active member in parallel</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Collect results and count successful deliveries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update membership status based on delivery results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return success if minimum delivery threshold met</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MarkNodeSeen updates the last-seen timestamp for a node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MarkNodeSeen</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire write lock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update lastSeen timestamp to current time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Reset suspicion level to 0 (node responded)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Refresh active members list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Release lock</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IncreaseSuspicion increments suspicion level when communication fails</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IncreaseSuspicion</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Acquire write lock</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Increment suspicion level (max at configured threshold)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Update active members list (may remove node)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return new suspicion level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Release lock</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Failure Detector Implementation Skeleton</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FailureDetector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transport    </span><span style=\"color:#B392F0\">Transport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    membership   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heartbeatInterval </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID       </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentTerm  </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leaderID     </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stopChan     </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartHeartbeats begins sending periodic heartbeat messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fd </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FailureDetector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartHeartbeats</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create ticker for heartbeat interval</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: In loop, create heartbeat message with current term and leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Broadcast heartbeat to all active members</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update membership suspicion levels for failed deliveries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Handle stop signal to exit cleanly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CheckForFailures examines membership for failed nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fd </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FailureDetector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CheckForFailures</span><span style=\"color:#E1E4E8\">() []</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get current active members from membership</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Compare with expected cluster size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Identify nodes that exceeded failure timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check if current leader has failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return list of newly failed node IDs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Implementation Hints</strong></p>\n<ul>\n<li>Use <code>sync.RWMutex</code> for membership data structures that have frequent reads but infrequent writes</li>\n<li>Use <code>time.NewTicker()</code> for periodic heartbeat sending with proper cleanup via <code>ticker.Stop()</code></li>\n<li>Use <code>context.WithTimeout()</code> for HTTP requests to implement configurable timeouts</li>\n<li>Use <code>sync.WaitGroup</code> for coordinating parallel broadcast message sending</li>\n<li>Use buffered channels for message passing to prevent blocking senders</li>\n<li>Use <code>atomic.LoadUint64()</code> and <code>atomic.StoreUint64()</code> for term numbers accessed from multiple goroutines</li>\n</ul>\n<p><strong>Milestone Checkpoint</strong></p>\n<p>After implementing the node communication layer, verify the following behavior:</p>\n<ol>\n<li><p><strong>Static Discovery Test</strong>: Start 3 nodes with static configuration pointing to each other. All nodes should discover each other within 5 seconds and report correct active membership counts.</p>\n</li>\n<li><p><strong>Message Delivery Test</strong>: Send point-to-point messages between nodes. Verify messages arrive with correct routing information and senders receive delivery confirmations.</p>\n</li>\n<li><p><strong>Broadcast Test</strong>: Have one node broadcast a message to all members. Verify all active nodes receive the broadcast message within reasonable time bounds.</p>\n</li>\n<li><p><strong>Failure Detection Test</strong>: Stop one node abruptly. Verify other nodes detect the failure within the configured timeout period and update their active member lists.</p>\n</li>\n<li><p><strong>Network Partition Simulation</strong>: Use firewall rules or network namespaces to isolate nodes. Verify partition detection works and nodes update membership appropriately.</p>\n</li>\n</ol>\n<p>Expected test output:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>=== RUN   TestStaticDiscovery\nNode 1001: Discovered 3 total members, 3 active\nNode 1002: Discovered 3 total members, 3 active  \nNode 1003: Discovered 3 total members, 3 active\n--- PASS: TestStaticDiscovery (5.23s)\n\n=== RUN   TestMessageDelivery  \nSent message from 1001 to 1002: SUCCESS\nSent message from 1002 to 1003: SUCCESS\n--- PASS: TestMessageDelivery (0.15s)</code></pre></div>\n\n<p><strong>Debugging Tips</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Nodes don&#39;t discover each other</td>\n<td>Configuration mismatch</td>\n<td>Check node IDs and addresses in config files</td>\n<td>Ensure all nodes have consistent member lists</td>\n</tr>\n<tr>\n<td>Messages timeout frequently</td>\n<td>Network latency higher than timeout</td>\n<td>Measure round-trip times between nodes</td>\n<td>Increase timeout values in configuration</td>\n</tr>\n<tr>\n<td>False failure detection</td>\n<td>Heartbeat interval too aggressive</td>\n<td>Monitor heartbeat delivery success rates</td>\n<td>Increase heartbeat intervals and failure thresholds</td>\n</tr>\n<tr>\n<td>Split-brain during partitions</td>\n<td>Quorum logic not implemented</td>\n<td>Check election behavior during network splits</td>\n<td>Implement majority quorum requirements</td>\n</tr>\n<tr>\n<td>High CPU usage</td>\n<td>Polling loops without delays</td>\n<td>Profile CPU usage during normal operation</td>\n<td>Add sleep intervals in monitoring loops</td>\n</tr>\n</tbody></table>\n<h2 id=\"bully-election-algorithm\">Bully Election Algorithm</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 (Bully Algorithm) - implements the bully election algorithm where the highest-ID node becomes leader through competitive messaging</p>\n</blockquote>\n<h3 id=\"mental-model-corporate-hierarchy-challenge\">Mental Model: Corporate Hierarchy Challenge</h3>\n<p>Think of the bully algorithm like a workplace scenario where the CEO suddenly leaves and the company needs to select a new leader. In a traditional corporate hierarchy, the person with the highest seniority (analogous to the highest node ID) should become the new CEO. However, there&#39;s no HR department to coordinate this - the employees must figure it out themselves through direct communication.</p>\n<p>Here&#39;s how it would unfold: when someone notices the CEO is gone, they might think &quot;I should be the new leader!&quot; But before declaring themselves CEO, they&#39;re required by company protocol to first ask everyone more senior than them: &quot;Hey, are you going to step up and lead?&quot; If any senior person responds &quot;Yes, I&#39;ve got this,&quot; then the junior person backs down and waits. But if no senior person responds after a reasonable time, the junior person can declare themselves the new CEO and announce it to everyone.</p>\n<p>This captures the essence of the bully algorithm: higher-ranked participants have the right to &quot;bully&quot; lower-ranked ones out of leadership contention, but they must actively claim that right. The algorithm isn&#39;t called &quot;bully&quot; because it&#39;s mean-spirited - it&#39;s because higher-ID nodes can override lower-ID nodes&#39; leadership attempts, similar to how a senior employee might override a junior employee&#39;s decision in a corporate hierarchy.</p>\n<p>The key insight is that this approach ensures the most qualified candidate (highest ID) becomes leader, but only if they&#39;re actually available and responsive. If the most senior person is unavailable (crashed or network-partitioned), the next most senior person can step up, and so on down the hierarchy.</p>\n<p><img src=\"/api/project/leader-election/architecture-doc/asset?path=diagrams%2Fnode-state-machine.svg\" alt=\"Node Election State Machine\"></p>\n<h3 id=\"bully-algorithm-steps\">Bully Algorithm Steps</h3>\n<p>The bully algorithm operates through a three-phase protocol that ensures the highest-ID responding node becomes leader. Each phase has specific message types and timing requirements that prevent conflicts and guarantee convergence.</p>\n<p><img src=\"/api/project/leader-election/architecture-doc/asset?path=diagrams%2Fbully-sequence.svg\" alt=\"Bully Algorithm Message Flow\"></p>\n<p>The algorithm consists of three distinct phases, each with clear responsibilities and message flows:</p>\n<p><strong>Phase 1: Election Initiation and Higher-ID Query</strong></p>\n<ol>\n<li><p><strong>Failure Detection Trigger</strong>: A node detects that the current leader has failed through the failure detection mechanism (heartbeat timeouts or message delivery failures). The detecting node transitions from <code>StateFollower</code> to <code>StateCandidate</code> and initiates an election.</p>\n</li>\n<li><p><strong>Election ID Generation</strong>: The initiating node generates a unique election ID (typically a combination of its node ID and current timestamp) to distinguish this election from any concurrent elections. This prevents confusion when multiple nodes simultaneously detect the leader failure.</p>\n</li>\n<li><p><strong>Higher-ID Node Query</strong>: The initiating node identifies all nodes with IDs higher than its own from the current cluster membership. It sends <code>MsgElection</code> messages to each of these higher-ID nodes, essentially asking &quot;Are you available to be leader?&quot;</p>\n</li>\n<li><p><strong>Election Timeout Setup</strong>: The initiator starts a timeout timer (typically 2-5 seconds) to wait for responses from higher-ID nodes. If no responses arrive within this timeout, the initiator assumes all higher-ID nodes are unavailable.</p>\n</li>\n</ol>\n<p><strong>Phase 2: Higher-ID Response and Candidate Withdrawal</strong></p>\n<ol start=\"5\">\n<li><p><strong>Higher-ID Node Response</strong>: Any higher-ID node that receives an <code>MsgElection</code> message immediately responds with an <code>MsgOK</code> message to indicate it&#39;s alive and will handle the election. The responding node then transitions to <code>StateCandidate</code> and starts its own election process.</p>\n</li>\n<li><p><strong>Initiator Withdrawal</strong>: When the original initiator receives any <code>MsgOK</code> response, it immediately withdraws from the election by transitioning back to <code>StateFollower</code>. It stops its timeout timer and waits for the eventual coordinator announcement.</p>\n</li>\n<li><p><strong>Cascading Elections</strong>: Higher-ID nodes that sent <code>MsgOK</code> responses now become election initiators themselves. They repeat the process by sending <code>MsgElection</code> messages to nodes with IDs higher than their own. This creates a cascade effect that eventually reaches the highest available node.</p>\n</li>\n</ol>\n<p><strong>Phase 3: Coordinator Selection and Announcement</strong></p>\n<ol start=\"8\">\n<li><p><strong>Victory Declaration</strong>: The highest-ID node that receives no <code>MsgOK</code> responses within the timeout period declares itself the winner. This node transitions to <code>StateLeader</code> and prepares to announce its leadership.</p>\n</li>\n<li><p><strong>Coordinator Broadcast</strong>: The winning node broadcasts a <code>MsgCoordinator</code> message to all nodes in the cluster membership, announcing itself as the new leader. This message includes the election ID to help nodes correlate the announcement with the election they witnessed.</p>\n</li>\n<li><p><strong>Leadership Acceptance</strong>: All nodes receiving the <code>MsgCoordinator</code> message transition to <code>StateFollower</code> and update their internal leader tracking to point to the announced leader. The new leader begins its leadership duties (heartbeat broadcasting, handling client requests, etc.).</p>\n</li>\n</ol>\n<p>The algorithm&#39;s correctness relies on several key properties: messages are delivered reliably between live nodes, timeouts are sufficient for message round-trips, and the cluster membership view is reasonably consistent. The timeout values must balance responsiveness (detecting failures quickly) with reliability (allowing slower nodes time to respond).</p>\n<blockquote>\n<p><strong>Critical Design Insight</strong>: The bully algorithm&#39;s safety comes from its sequential nature - only one node can be in the final &quot;declaring victory&quot; state at any time, because all lower-ID nodes will have received OK messages from higher-ID nodes and withdrawn. This prevents split-brain scenarios where multiple nodes simultaneously believe they&#39;re the leader.</p>\n</blockquote>\n<p>The message flow creates a natural ordering where election attempts &quot;bubble up&quot; to the highest available node, ensuring that exactly one leader emerges even when multiple nodes simultaneously detect the failure and initiate elections.</p>\n<h3 id=\"bully-election-state-management\">Bully Election State Management</h3>\n<p>The bully algorithm requires careful state management to handle concurrent elections, message ordering, and node state transitions. Each node maintains both persistent state (survives restarts) and transient election state (reset between elections).</p>\n<p><strong>Node State Transitions</strong></p>\n<table>\n<thead>\n<tr>\n<th>Current State</th>\n<th>Triggering Event</th>\n<th>Next State</th>\n<th>Actions Taken</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>StateFollower</code></td>\n<td>Leader failure detected</td>\n<td><code>StateCandidate</code></td>\n<td>Generate election ID, send <code>MsgElection</code> to higher-ID nodes, start timeout</td>\n</tr>\n<tr>\n<td><code>StateFollower</code></td>\n<td>Receive <code>MsgElection</code> from lower-ID node</td>\n<td><code>StateCandidate</code></td>\n<td>Send <code>MsgOK</code> response, start own election process</td>\n</tr>\n<tr>\n<td><code>StateFollower</code></td>\n<td>Receive <code>MsgCoordinator</code></td>\n<td><code>StateFollower</code></td>\n<td>Update leader tracking, reset election state</td>\n</tr>\n<tr>\n<td><code>StateCandidate</code></td>\n<td>Receive <code>MsgOK</code> from higher-ID node</td>\n<td><code>StateFollower</code></td>\n<td>Cancel timeout, stop election, wait for coordinator announcement</td>\n</tr>\n<tr>\n<td><code>StateCandidate</code></td>\n<td>Election timeout expires (no OK received)</td>\n<td><code>StateLeader</code></td>\n<td>Broadcast <code>MsgCoordinator</code>, start leadership duties</td>\n</tr>\n<tr>\n<td><code>StateCandidate</code></td>\n<td>Receive <code>MsgCoordinator</code> from winner</td>\n<td><code>StateFollower</code></td>\n<td>Update leader tracking, reset election state</td>\n</tr>\n<tr>\n<td><code>StateLeader</code></td>\n<td>Receive <code>MsgCoordinator</code> with higher term</td>\n<td><code>StateFollower</code></td>\n<td>Step down, update leader tracking</td>\n</tr>\n<tr>\n<td><code>StateLeader</code></td>\n<td>Own failure detection timeout</td>\n<td><code>StateCandidate</code></td>\n<td>Restart election (network partition recovery)</td>\n</tr>\n</tbody></table>\n<p><strong>Election State Data Structures</strong></p>\n<p>Each node maintains several state components during elections:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>currentState</code></td>\n<td><code>NodeState</code></td>\n<td>Current role in the election process</td>\n</tr>\n<tr>\n<td><code>currentLeader</code></td>\n<td><code>NodeID</code></td>\n<td>ID of the node currently believed to be leader</td>\n</tr>\n<tr>\n<td><code>currentTerm</code></td>\n<td><code>uint64</code></td>\n<td>Monotonically increasing election epoch counter</td>\n</tr>\n<tr>\n<td><code>activeElectionID</code></td>\n<td><code>uint64</code></td>\n<td>ID of the election this node is currently participating in</td>\n</tr>\n<tr>\n<td><code>electionTimeout</code></td>\n<td><code>time.Timer</code></td>\n<td>Timeout for waiting on higher-ID node responses</td>\n</tr>\n<tr>\n<td><code>candidateNodes</code></td>\n<td><code>map[NodeID]bool</code></td>\n<td>Set of higher-ID nodes queried in current election</td>\n</tr>\n<tr>\n<td><code>receivedOKs</code></td>\n<td><code>map[NodeID]bool</code></td>\n<td>Track which higher-ID nodes have responded with OK</td>\n</tr>\n<tr>\n<td><code>lastLeaderHeartbeat</code></td>\n<td><code>time.Time</code></td>\n<td>Timestamp of last heartbeat from current leader</td>\n</tr>\n</tbody></table>\n<p><strong>Concurrent Election Handling</strong></p>\n<p>The bully algorithm naturally handles concurrent elections through its message semantics and state transitions, but several edge cases require careful management:</p>\n<blockquote>\n<p><strong>Decision: Election ID Uniqueness Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Multiple nodes might simultaneously detect leader failure and initiate elections, creating potential confusion about which election messages belong to which attempt</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Single global election counter (requires consensus)</li>\n<li>Node ID + timestamp combination</li>\n<li>Random UUIDs for each election</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Node ID + timestamp combination (<code>(nodeID &lt;&lt; 32) | timestamp</code>)</li>\n<li><strong>Rationale</strong>: Provides uniqueness without coordination overhead, includes initiator identity for debugging, and maintains ordering properties for conflict resolution</li>\n<li><strong>Consequences</strong>: Requires reasonably synchronized clocks, but degrades gracefully with clock skew</li>\n</ul>\n</blockquote>\n<p><strong>Concurrent Election Resolution Rules</strong>:</p>\n<ol>\n<li><p><strong>Multiple Election Initiators</strong>: When a node receives <code>MsgElection</code> messages from multiple lower-ID nodes with different election IDs, it responds with <code>MsgOK</code> to all of them and starts its own single election attempt.</p>\n</li>\n<li><p><strong>Election ID Precedence</strong>: If a node is already participating in an election and receives messages for a different election, it compares election IDs. The election with the higher ID (more recent timestamp or higher initiator ID) takes precedence.</p>\n</li>\n<li><p><strong>Late Election Messages</strong>: If a node receives <code>MsgElection</code> after it has already transitioned to <code>StateLeader</code>, it responds with the current <code>MsgCoordinator</code> message instead of <code>MsgOK</code>, immediately informing the late node of the current leader.</p>\n</li>\n<li><p><strong>Duplicate Prevention</strong>: Nodes track the election ID they&#39;re currently participating in and ignore <code>MsgElection</code> messages for elections they&#39;ve already responded to, preventing infinite election loops.</p>\n</li>\n</ol>\n<p><strong>State Persistence and Recovery</strong></p>\n<p>The bully election state includes both volatile and persistent components:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Persistence</th>\n<th>Recovery Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>currentState</code></td>\n<td>Volatile</td>\n<td>Always start as <code>StateFollower</code> after restart</td>\n</tr>\n<tr>\n<td><code>currentLeader</code></td>\n<td>Persistent</td>\n<td>Attempt to contact last known leader on startup</td>\n</tr>\n<tr>\n<td><code>currentTerm</code></td>\n<td>Persistent</td>\n<td>Increment on first election participation after restart</td>\n</tr>\n<tr>\n<td><code>activeElectionID</code></td>\n<td>Volatile</td>\n<td>Reset to 0, participate in any ongoing elections</td>\n</tr>\n<tr>\n<td>Election timers</td>\n<td>Volatile</td>\n<td>Restart failure detection from scratch</td>\n</tr>\n</tbody></table>\n<p><strong>Memory and Resource Management</strong></p>\n<p>Election state management includes resource cleanup to prevent memory leaks during long-running operations:</p>\n<ul>\n<li><strong>Timeout Cleanup</strong>: All election timeouts are canceled when transitioning out of <code>StateCandidate</code>, preventing spurious timeout events</li>\n<li><strong>State Reset</strong>: Election-specific state (<code>candidateNodes</code>, <code>receivedOKs</code>) is cleared when elections complete or are superseded</li>\n<li><strong>Term Advancement</strong>: The <code>currentTerm</code> is incremented each time a node initiates an election, providing a monotonic ordering for election attempts</li>\n</ul>\n<h3 id=\"bully-algorithm-edge-cases\">Bully Algorithm Edge Cases</h3>\n<p>The bully algorithm&#39;s distributed nature creates numerous edge cases that must be handled to ensure correctness and prevent split-brain scenarios. These edge cases often occur due to message loss, network partitions, timing variations, and cascading failures.</p>\n<p><strong>Message Loss and Delivery Failures</strong></p>\n<p><img src=\"/api/project/leader-election/architecture-doc/asset?path=diagrams%2Fmessage-types.svg\" alt=\"Election Message Type Relationships\"></p>\n<p>Message loss can occur at any phase of the bully algorithm, each creating different failure modes:</p>\n<table>\n<thead>\n<tr>\n<th>Lost Message Type</th>\n<th>Impact</th>\n<th>Detection Method</th>\n<th>Recovery Mechanism</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>MsgElection</code> to higher-ID node</td>\n<td>Higher node doesn&#39;t participate, lower node may incorrectly become leader</td>\n<td>Timeout waiting for coordinator announcement</td>\n<td>Re-election triggered by heartbeat failure</td>\n</tr>\n<tr>\n<td><code>MsgOK</code> from higher-ID node</td>\n<td>Lower node incorrectly declares victory</td>\n<td>Multiple coordinator announcements detected</td>\n<td>Higher-term coordinator message overrides</td>\n</tr>\n<tr>\n<td><code>MsgCoordinator</code> to some nodes</td>\n<td>Inconsistent leader view across cluster</td>\n<td>Heartbeat failures from unnotified nodes</td>\n<td>Missing nodes detect leader and request status</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Message Delivery Guarantees</strong></p>\n<ul>\n<li><strong>Context</strong>: The bully algorithm correctness depends on reliable message delivery, but network failures are inevitable in distributed systems</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Best-effort delivery with retries and timeouts</li>\n<li>Exactly-once delivery with acknowledgment tracking</li>\n<li>At-least-once delivery with idempotent message processing</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: At-least-once delivery with idempotent message processing</li>\n<li><strong>Rationale</strong>: Balances reliability with complexity - duplicate messages are safer than lost messages in leader election, and idempotent processing prevents state corruption</li>\n<li><strong>Consequences</strong>: Requires message deduplication logic but ensures election progress even with network instability</li>\n</ul>\n</blockquote>\n<p><strong>Network Partition Scenarios</strong></p>\n<p>Network partitions create the most complex edge cases because different parts of the cluster may independently elect leaders:</p>\n<ol>\n<li><p><strong>Majority Partition Scenario</strong>: The partition containing more than half the nodes can safely elect a leader because it represents the cluster majority. The minority partition should detect it lacks quorum and avoid electing a leader.</p>\n</li>\n<li><p><strong>Equal Partition Scenario</strong>: When the cluster splits into equal-sized partitions, both sides might attempt leader election. The partition containing the node with the highest ID should eventually win when partitions heal.</p>\n</li>\n<li><p><strong>Cascading Partition Scenario</strong>: A leader might become isolated while the rest of the cluster remains connected. The main cluster should elect a new leader while the isolated leader eventually detects its isolation and steps down.</p>\n</li>\n</ol>\n<p><strong>Split-Brain Prevention Mechanisms</strong>:</p>\n<ul>\n<li><strong>Quorum Requirements</strong>: A node can only become leader if it can communicate with more than half the nodes in its last known cluster membership</li>\n<li><strong>Partition Detection</strong>: Nodes monitor their connectivity to other cluster members and refuse leadership if they detect they&#39;re in a minority partition  </li>\n<li><strong>Term Comparison</strong>: When partitions heal, the leader with the higher election term remains leader, while lower-term leaders step down</li>\n</ul>\n<p><strong>Timing and Timeout Edge Cases</strong></p>\n<p>The bully algorithm relies heavily on timeouts, which create timing-dependent edge cases:</p>\n<p>⚠️ <strong>Pitfall: Timeout Values Too Aggressive</strong>\nSetting election timeouts too low causes premature leader declarations when higher-ID nodes are slow to respond. This leads to multiple coordinator announcements and leader thrashing. The timeout should be at least 3x the maximum expected network round-trip time plus processing delays.</p>\n<p>⚠️ <strong>Pitfall: Timeout Values Too Conservative</strong> \nSetting election timeouts too high delays leader election when higher-ID nodes have genuinely failed, increasing cluster unavailability. This is especially problematic in cascading failure scenarios where multiple nodes fail in sequence.</p>\n<p><strong>Adaptive Timeout Strategy</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Network Condition</th>\n<th>Timeout Multiplier</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Normal operation</td>\n<td>1.0x base timeout</td>\n<td>Fast elections for quick recovery</td>\n</tr>\n<tr>\n<td>Recent message loss detected</td>\n<td>1.5x base timeout</td>\n<td>Allow extra time for retransmission</td>\n</tr>\n<tr>\n<td>Network partition recovery</td>\n<td>2.0x base timeout</td>\n<td>Avoid premature elections during cluster healing</td>\n</tr>\n<tr>\n<td>Multiple recent elections</td>\n<td>1.3x base timeout</td>\n<td>Reduce election thrashing</td>\n</tr>\n</tbody></table>\n<p><strong>Cascading Failure Scenarios</strong></p>\n<p>When multiple nodes fail in rapid succession, the bully algorithm can experience cascading election attempts:</p>\n<ol>\n<li><strong>Leader Failure</strong>: Original leader fails, node N-1 detects and starts election</li>\n<li><strong>Cascade Trigger</strong>: Node N-1 fails during its election attempt, node N-2 must restart the process</li>\n<li><strong>Rapid Succession</strong>: Pattern continues until a stable node successfully completes the election</li>\n</ol>\n<p><strong>Cascading Failure Handling</strong>:</p>\n<ul>\n<li><strong>Election Attempt Tracking</strong>: Nodes track recent election attempts and implement exponential backoff to reduce thundering herd effects</li>\n<li><strong>Stability Detection</strong>: New leaders wait a brief period before accepting client requests to ensure they remain stable</li>\n<li><strong>Failure Correlation</strong>: Nodes consider whether recent failures might indicate broader infrastructure issues (power, network) that affect election viability</li>\n</ul>\n<p><strong>State Inconsistency Resolution</strong></p>\n<p>Despite careful design, distributed systems can develop state inconsistencies that the bully algorithm must detect and resolve:</p>\n<table>\n<thead>\n<tr>\n<th>Inconsistency Type</th>\n<th>Symptoms</th>\n<th>Detection Method</th>\n<th>Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Multiple leaders with same term</td>\n<td>Conflicting coordinator messages</td>\n<td>Cross-leader heartbeat monitoring</td>\n<td>Re-election with term increment</td>\n</tr>\n<tr>\n<td>Follower has higher term than leader</td>\n<td>Stale leader sending old-term heartbeats</td>\n<td>Term comparison in heartbeat processing</td>\n<td>Leader steps down, follower triggers election</td>\n</tr>\n<tr>\n<td>Node believes it&#39;s leader but others don&#39;t</td>\n<td>Node sends heartbeats but receives election messages</td>\n<td>Election messages received while in leader state</td>\n<td>Step down and participate in new election</td>\n</tr>\n</tbody></table>\n<p><strong>Recovery from Edge Cases</strong></p>\n<p>The bully algorithm includes several recovery mechanisms that activate when edge cases are detected:</p>\n<ul>\n<li><strong>Periodic Leader Validation</strong>: Followers periodically verify they can reach the current leader and trigger re-election if not</li>\n<li><strong>Term Monotonicity Enforcement</strong>: Any message with a higher term than the current node&#39;s term triggers immediate term update and potential state transition</li>\n<li><strong>Election Liveness Guarantee</strong>: If no coordinator announcement is received within 2x the election timeout, any node can restart the election process</li>\n<li><strong>Cluster Membership Reconciliation</strong>: Nodes periodically exchange membership views to detect and resolve inconsistencies</li>\n</ul>\n<blockquote>\n<p><strong>Critical Design Insight</strong>: The bully algorithm&#39;s edge case handling relies on eventual consistency rather than preventing all edge cases. The system allows temporary inconsistencies (brief periods with no leader or multiple leaders) but guarantees eventual convergence to a single, highest-ID leader through its recovery mechanisms.</p>\n</blockquote>\n<p>These edge cases and their handling mechanisms ensure that the bully algorithm remains robust in the face of the various failure modes encountered in distributed systems, while maintaining the core guarantee that the highest-ID available node eventually becomes the leader.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides concrete implementation guidance for building the bully election algorithm on top of the node communication layer established in Milestone 1.</p>\n<p><strong>Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>State Management</td>\n<td>In-memory maps with mutex protection</td>\n<td>Persistent state with embedded database (BoltDB)</td>\n</tr>\n<tr>\n<td>Election Timeouts</td>\n<td><code>time.Timer</code> with context cancellation</td>\n<td>Priority queue with heap-based timeout management</td>\n</tr>\n<tr>\n<td>Message Serialization</td>\n<td>JSON with <code>encoding/json</code></td>\n<td>Protocol Buffers with generated Go bindings</td>\n</tr>\n<tr>\n<td>Concurrent Safety</td>\n<td><code>sync.RWMutex</code> for state protection</td>\n<td>Lock-free atomic operations with memory ordering</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td>Table-driven tests with mock transport</td>\n<td>Property-based testing with rapid failure injection</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/election/\n  bully.go              ← BullyElection implementation\n  bully_test.go         ← Comprehensive bully algorithm tests\n  state.go              ← Election state management\n  messages.go           ← Bully-specific message builders\n  timeouts.go           ← Election timeout management\n  edge_cases.go         ← Edge case detection and recovery\nexamples/bully_demo/\n  main.go               ← Multi-node bully demo\n  cluster_config.json   ← Node configuration for testing</code></pre></div>\n\n<p><strong>Core Infrastructure (Complete Implementation)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Package election provides leader election algorithm implementations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> election</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ElectionState manages the persistent and transient state for bully elections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ElectionState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu                   </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentState        </span><span style=\"color:#B392F0\">NodeState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentLeader       </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentTerm         </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    activeElectionID    </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    candidateNodes      </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    receivedOKs         </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastLeaderHeartbeat </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    electionStartTime   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewElectionState creates a new election state manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewElectionState</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionState</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ElectionState</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currentState:     StateFollower,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currentLeader:    </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currentTerm:      </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        candidateNodes:   </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        receivedOKs:      </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetCurrentState returns the node's current election state thread-safely</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">es </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetCurrentState</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">NodeState</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    es.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> es.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> es.currentState, es.currentLeader, es.currentTerm</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TransitionTo safely transitions the node to a new election state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">es </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionState</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TransitionTo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">newState</span><span style=\"color:#B392F0\"> NodeState</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">leaderID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">term</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    es.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> es.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    es.currentState </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> newState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    es.currentLeader </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> leaderID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> term </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> es.currentTerm {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        es.currentTerm </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> term</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    es.lastStateTransition </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ElectionTimeoutManager handles election timeout logic with context cancellation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ElectionTimeoutManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timeout    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timer      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Timer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cancelFunc </span><span style=\"color:#B392F0\">context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CancelFunc</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu         </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Mutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewElectionTimeoutManager creates a timeout manager with the specified duration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewElectionTimeoutManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionTimeoutManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ElectionTimeoutManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timeout: timeout,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartTimeout begins an election timeout with the provided callback</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">etm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionTimeoutManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartTimeout</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">callback</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">()) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    etm.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> etm.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> etm.timer </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        etm.timer.</span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    etm.timer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">AfterFunc</span><span style=\"color:#E1E4E8\">(etm.timeout, callback)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CancelTimeout stops the current election timeout</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">etm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionTimeoutManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CancelTimeout</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    etm.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> etm.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> etm.timer </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        etm.timer.</span><span style=\"color:#B392F0\">Stop</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        etm.timer </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Bully Algorithm Skeleton (TODO Implementation)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// BullyElection implements the bully leader election algorithm</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BullyElection</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID      </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transport   </span><span style=\"color:#B392F0\">Transport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    membership  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state       </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timeout     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionTimeoutManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    msgBuilder  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageBuilder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewBullyElection creates a new bully election coordinator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewBullyElection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">transport</span><span style=\"color:#B392F0\"> Transport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">membership</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ClusterMembership</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nodeID:     nodeID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        transport:  transport,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        membership: membership,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        state:      </span><span style=\"color:#B392F0\">NewElectionState</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timeout:    </span><span style=\"color:#B392F0\">NewElectionTimeoutManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        msgBuilder: </span><span style=\"color:#B392F0\">NewMessageBuilder</span><span style=\"color:#E1E4E8\">(nodeID),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartElection initiates a new bully election process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is called when the current leader is detected as failed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">be </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartElection</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Generate unique election ID using nodeID and current timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: electionID := uint64(be.nodeID)&#x3C;&#x3C;32 | uint64(time.Now().UnixNano())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Transition to StateCandidate and increment current term</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use be.state.TransitionTo() with new term = current term + 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Find all higher-ID nodes from cluster membership</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use be.membership.GetActiveMembers() and filter by ID > be.nodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Send MsgElection to each higher-ID node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use be.msgBuilder.BuildElectionMessage() and be.transport.SendMessage()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Start election timeout - if no OK responses, declare victory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use be.timeout.StartTimeout() with callback to be.declareVictory()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Track candidate nodes for response correlation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Store higher-ID node list in be.state.candidateNodes map</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandleMessage processes incoming election-related messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">be </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HandleMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> msg.Type {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MsgElection:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> be.</span><span style=\"color:#B392F0\">handleElectionMessage</span><span style=\"color:#E1E4E8\">(msg)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MsgOK:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> be.</span><span style=\"color:#B392F0\">handleOKMessage</span><span style=\"color:#E1E4E8\">(msg)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MsgCoordinator:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> be.</span><span style=\"color:#B392F0\">handleCoordinatorMessage</span><span style=\"color:#E1E4E8\">(msg)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unknown message type: </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, msg.Type)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleElectionMessage processes incoming election messages from lower-ID nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">be </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleElectionMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse election message from msg.Payload</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: json.Unmarshal into ElectionMessage struct</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if sender has lower ID than this node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: If msg.From >= be.nodeID, this shouldn't happen - log warning</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send OK response to sender</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Build MsgOK message and use be.transport.SendMessage()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If not already in election, start own election process</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check current state - if StateFollower, call be.StartElection()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleOKMessage processes OK responses from higher-ID nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">be </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleOKMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Verify this node is currently in StateCandidate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: If not candidate, ignore message (may be from old election)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Parse OK message from msg.Payload</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: json.Unmarshal into OKMessage struct</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Cancel election timeout since higher-ID node is handling election</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use be.timeout.CancelTimeout()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Transition back to StateFollower and wait for coordinator announcement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use be.state.TransitionTo(StateFollower, 0, currentTerm)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Clear election-specific state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Reset be.state.candidateNodes and be.state.receivedOKs maps</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleCoordinatorMessage processes leader announcements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">be </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleCoordinatorMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Parse coordinator message from msg.Payload</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: json.Unmarshal into CoordinatorMessage struct</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify sender ID matches announced leader ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: msg.From should equal coordinatorMsg.LeaderID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check if announced term is higher than current term</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: If lower term, this may be delayed message - ignore or log warning</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update state to follow new leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: TransitionTo StateFollower with new leader and term</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Cancel any ongoing election activities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Cancel timeout and clear election state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update last leader heartbeat timestamp for failure detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Set be.state.lastLeaderHeartbeat = time.Now()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// declareVictory is called when election timeout expires with no OK responses</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">be </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">declareVictory</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Verify still in StateCandidate (may have received late OK)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check be.state.GetCurrentState() - if not candidate, return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Transition to StateLeader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use be.state.TransitionTo(StateLeader, be.nodeID, currentTerm)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Build coordinator announcement message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use be.msgBuilder.BuildCoordinatorMessage()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Broadcast coordinator message to all cluster members</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use be.transport.BroadcastMessage()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Start leader responsibilities (heartbeat sending)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Call be.startLeaderDuties() or similar</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetCurrentLeader returns the ID of the current leader</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">be </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetCurrentLeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, leader, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> be.state.</span><span style=\"color:#B392F0\">GetCurrentState</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> leader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsLeader returns true if this node is the current leader</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">be </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsLeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state, leader, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> be.state.</span><span style=\"color:#B392F0\">GetCurrentState</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> StateLeader </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> leader </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> be.nodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Implementation Hints</strong></p>\n<ul>\n<li><strong>Goroutine Safety</strong>: All election state must be protected by mutexes since multiple goroutines handle messages, timeouts, and failure detection simultaneously</li>\n<li><strong>Context Cancellation</strong>: Use <code>context.WithTimeout()</code> for election timeouts to enable clean cancellation and resource cleanup</li>\n<li><strong>JSON Serialization</strong>: Use struct tags like <code>json:&quot;election_id&quot;</code> for consistent message formatting across nodes</li>\n<li><strong>Error Handling</strong>: Wrap transport errors with context: <code>fmt.Errorf(&quot;failed to send election message to node %d: %w&quot;, targetID, err)</code></li>\n<li><strong>Logging</strong>: Use structured logging with fields like <code>nodeID</code>, <code>electionID</code>, <code>term</code> for debugging distributed elections</li>\n<li><strong>Testing</strong>: Create mock <code>Transport</code> interface implementations that can simulate message loss, delays, and network partitions</li>\n</ul>\n<p><strong>Milestone 2 Checkpoint</strong></p>\n<p>After implementing the bully algorithm, verify correctness with these tests:</p>\n<p><strong>Basic Election Test</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> examples/bully_demo/main.go</span><span style=\"color:#79B8FF\"> --nodes=3</span><span style=\"color:#79B8FF\"> --ids=1,3,5</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Node 5 becomes leader after simulated failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check logs for: \"Node 5 declared victory\" and \"All nodes acknowledge leader 5\"</span></span></code></pre></div>\n\n<p><strong>Cascade Election Test</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start with 5 nodes, kill highest ID nodes in sequence</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> internal/election</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestBullyCascadeFailure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Leadership passes down: 5→4→3→2→1 as higher nodes fail</span></span></code></pre></div>\n\n<p><strong>Concurrent Election Test</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#9ECBFF\"> internal/election</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestBullyConcurrentElections</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Only one leader emerges despite multiple simultaneous election initiators</span></span></code></pre></div>\n\n<p><strong>Signs of Correct Implementation</strong>:</p>\n<ul>\n<li>Election completes within 2x timeout period (typically 10 seconds)</li>\n<li>Exactly one coordinator announcement per successful election</li>\n<li>Lower-ID nodes always defer to higher-ID nodes&#39; OK responses</li>\n<li>Network partitions prevent minority sides from electing leaders</li>\n<li>Logs show clear state transitions: Follower → Candidate → Leader/Follower</li>\n</ul>\n<p><strong>Common Implementation Issues</strong>:</p>\n<ul>\n<li><strong>Multiple Leaders</strong>: Check that nodes receiving OK messages immediately cancel timeouts and return to follower state</li>\n<li><strong>Election Hangs</strong>: Verify timeout callbacks are properly registered and election state is cleared after completion</li>\n<li><strong>Message Ordering</strong>: Ensure election ID generation creates unique, monotonic identifiers to handle concurrent elections</li>\n<li><strong>State Race Conditions</strong>: Protect all election state access with appropriate mutex locking</li>\n</ul>\n<h2 id=\"ring-election-algorithm\">Ring Election Algorithm</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3 (Ring Election) - implements ring-based election where tokens circulate to collect live nodes</p>\n</blockquote>\n<h3 id=\"mental-model-passing-the-torch\">Mental Model: Passing the Torch</h3>\n<p>Think of the ring election algorithm like an Olympic torch relay, but with a special twist: instead of just passing the torch to the finish line, each runner writes their name on the torch as it passes through their hands. The torch travels around a predetermined circular route, visiting each active relay station in order. When the torch completes the full circle and returns to where it started, everyone can see all the names written on it, and the person with the highest &quot;ranking&quot; (node ID) among those who successfully added their name becomes the champion.</p>\n<p>In our distributed system, the &quot;torch&quot; is an election token containing a list of participating node IDs. The &quot;relay stations&quot; are the nodes arranged in a logical ring ordered by their unique identifiers. Each node that successfully receives the token adds its ID to the participant list and passes it to the next node in the ring. Failed or unreachable nodes are automatically skipped, just like closed relay stations in our analogy. When the token returns to the initiating node, it contains a complete roster of all live nodes, and the highest-ID node from this list becomes the new leader.</p>\n<p>This approach differs fundamentally from the bully algorithm&#39;s competitive messaging. Instead of nodes fighting for leadership through direct challenges, ring election uses cooperative information gathering. The token methodically visits each node, collecting a census of who&#39;s alive and participating. This eliminates the cascade election problem that can occur in bully algorithms when multiple higher-ID nodes fail simultaneously.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: Ring election separates the concerns of <em>discovering who&#39;s alive</em> (token circulation) from <em>selecting the leader</em> (deterministic choice from the collected set). This makes the algorithm more predictable and easier to reason about than competitive approaches.</p>\n</blockquote>\n<h3 id=\"logical-ring-construction\">Logical Ring Construction</h3>\n<p>The foundation of ring election is establishing a <strong>logical ring topology</strong> where nodes are arranged in a predetermined order based on their unique identifiers. This ring exists as a conceptual overlay on top of the actual network topology - nodes don&#39;t need to be physically connected in a ring, they just need to know their logical position and successor.</p>\n<p><img src=\"/api/project/leader-election/architecture-doc/asset?path=diagrams%2Fring-topology.svg\" alt=\"Ring Election Topology\"></p>\n<h4 id=\"ring-ordering-and-successor-calculation\">Ring Ordering and Successor Calculation</h4>\n<p>The logical ring orders nodes by their <code>NodeID</code> values in ascending order, with the highest-ID node wrapping around to point to the lowest-ID node. This creates a circular structure where every node has exactly one successor and one predecessor.</p>\n<table>\n<thead>\n<tr>\n<th>Ring Property</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Node Ordering</strong></td>\n<td>Nodes sorted by ascending <code>NodeID</code></td>\n<td>IDs [1, 3, 5, 7] → Ring order: 1→3→5→7→1</td>\n</tr>\n<tr>\n<td><strong>Successor Mapping</strong></td>\n<td>Each node points to next higher ID</td>\n<td>Node 3&#39;s successor is Node 5</td>\n</tr>\n<tr>\n<td><strong>Ring Completion</strong></td>\n<td>Highest ID wraps to lowest ID</td>\n<td>Node 7&#39;s successor is Node 1</td>\n</tr>\n<tr>\n<td><strong>Bidirectional Knowledge</strong></td>\n<td>Optional: nodes know predecessors too</td>\n<td>Node 5&#39;s predecessor is Node 3</td>\n</tr>\n</tbody></table>\n<p>The <code>RingElection</code> component maintains this topology through a successor map and provides methods to navigate the ring structure:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>findNextLiveNode(startID NodeID)</code></td>\n<td>startID NodeID</td>\n<td>NodeID, error</td>\n<td>Finds next reachable node starting from given position</td>\n</tr>\n<tr>\n<td><code>calculateSuccessor(nodeID NodeID)</code></td>\n<td>nodeID NodeID</td>\n<td>NodeID</td>\n<td>Determines logical successor based on ID ordering</td>\n</tr>\n<tr>\n<td><code>rebuildRing()</code></td>\n<td>none</td>\n<td>error</td>\n<td>Reconstructs ring after membership changes</td>\n</tr>\n<tr>\n<td><code>validateRingIntegrity()</code></td>\n<td>none</td>\n<td>bool</td>\n<td>Checks if ring structure is consistent</td>\n</tr>\n</tbody></table>\n<h4 id=\"ring-construction-algorithm\">Ring Construction Algorithm</h4>\n<p>Building the logical ring involves several steps that must be coordinated across all participating nodes:</p>\n<ol>\n<li><p><strong>Membership Discovery</strong>: Each node obtains the current cluster membership from the <code>ClusterMembership</code> component, getting a list of all nodes believed to be alive and participating.</p>\n</li>\n<li><p><strong>ID Collection and Sorting</strong>: The node extracts all <code>NodeID</code> values from the membership list and sorts them in ascending order to establish the canonical ring sequence.</p>\n</li>\n<li><p><strong>Successor Assignment</strong>: For each node ID in the sorted list, calculate its successor as the next higher ID in the sequence, with the highest ID wrapping to the lowest.</p>\n</li>\n<li><p><strong>Ring State Persistence</strong>: Store the ring topology locally so the node knows its position and can determine where to forward election tokens.</p>\n</li>\n<li><p><strong>Connectivity Verification</strong>: Test that the node can actually communicate with its calculated successor to ensure the ring is functional, not just theoretical.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Static vs Dynamic Ring Ordering</strong></p>\n<ul>\n<li><strong>Context</strong>: Ring topology can be recalculated each election or maintained continuously</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Static: Calculate ring once at startup, rebuild only on explicit membership changes</li>\n<li>Dynamic: Recalculate ring topology for every election initiation</li>\n<li>Hybrid: Maintain ring but verify/repair before each election</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Hybrid approach with continuous maintenance and pre-election verification</li>\n<li><strong>Rationale</strong>: Static rings can become stale with undetected failures; fully dynamic rings add unnecessary overhead; hybrid provides reliability with efficiency</li>\n<li><strong>Consequences</strong>: Requires ring repair mechanisms but provides fast election startup with current topology</li>\n</ul>\n</blockquote>\n<h4 id=\"handling-ring-membership-changes\">Handling Ring Membership Changes</h4>\n<p>When nodes join or leave the cluster, the ring topology must be updated to maintain consistency. This presents several challenges:</p>\n<p><strong>Node Join Scenarios</strong>: When a new node joins, it must insert itself into the correct position in the ring based on its ID. This requires updating the predecessor&#39;s successor pointer and establishing connections to both neighbors.</p>\n<p><strong>Node Departure Scenarios</strong>: When a node leaves (gracefully or through failure), its predecessor must update its successor pointer to skip the departed node and connect directly to the next live node in sequence.</p>\n<p><strong>Split Ring Recovery</strong>: Network partitions can break the ring into multiple segments. When partitions heal, the segments must be reconnected and duplicate leaders resolved.</p>\n<table>\n<thead>\n<tr>\n<th>Ring Event</th>\n<th>Impact</th>\n<th>Recovery Action</th>\n<th>Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Node Join</strong></td>\n<td>Ring grows, IDs reordered</td>\n<td>Insert node, update predecessor successor</td>\n<td>Low</td>\n</tr>\n<tr>\n<td><strong>Graceful Leave</strong></td>\n<td>Ring shrinks, clean removal</td>\n<td>Update predecessor&#39;s successor pointer</td>\n<td>Low</td>\n</tr>\n<tr>\n<td><strong>Node Failure</strong></td>\n<td>Ring breaks, successor unreachable</td>\n<td>Skip failed node, find next live successor</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td><strong>Partition Healing</strong></td>\n<td>Multiple ring segments merge</td>\n<td>Rebuild unified ring, resolve leader conflicts</td>\n<td>High</td>\n</tr>\n</tbody></table>\n<h4 id=\"ring-state-representation\">Ring State Representation</h4>\n<p>The <code>RingElection</code> component maintains several data structures to track the ring topology and its current state:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>nodeID</code></td>\n<td>NodeID</td>\n<td>This node&#39;s unique identifier</td>\n</tr>\n<tr>\n<td><code>successorMap</code></td>\n<td>map[NodeID]NodeID</td>\n<td>Maps each node to its ring successor</td>\n</tr>\n<tr>\n<td><code>ringSequence</code></td>\n<td>[]NodeID</td>\n<td>Ordered list of node IDs in ring sequence</td>\n</tr>\n<tr>\n<td><code>membership</code></td>\n<td>*ClusterMembership</td>\n<td>Reference to cluster membership manager</td>\n</tr>\n<tr>\n<td><code>ringVersion</code></td>\n<td>uint64</td>\n<td>Monotonic counter tracking ring topology changes</td>\n</tr>\n<tr>\n<td><code>lastRingUpdate</code></td>\n<td>int64</td>\n<td>Timestamp of most recent ring reconstruction</td>\n</tr>\n</tbody></table>\n<h3 id=\"ring-election-protocol\">Ring Election Protocol</h3>\n<p>The ring election protocol implements a token-passing mechanism where an election token circulates around the logical ring, collecting participant information and ultimately selecting the highest-ID node as leader. This process involves several distinct phases and message types.</p>\n<p><img src=\"/api/project/leader-election/architecture-doc/asset?path=diagrams%2Fring-sequence.svg\" alt=\"Ring Election Token Passing\"></p>\n<h4 id=\"election-token-structure\">Election Token Structure</h4>\n<p>The core of ring election is the <code>RingToken</code> message that circulates around the ring:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ElectionID</code></td>\n<td>uint64</td>\n<td>Unique identifier for this election instance</td>\n</tr>\n<tr>\n<td><code>InitiatorID</code></td>\n<td>NodeID</td>\n<td>ID of node that started this election</td>\n</tr>\n<tr>\n<td><code>Participants</code></td>\n<td>[]NodeID</td>\n<td>Ordered list of live nodes encountered</td>\n</tr>\n<tr>\n<td><code>Complete</code></td>\n<td>bool</td>\n<td>Whether token has completed full ring traversal</td>\n</tr>\n<tr>\n<td><code>Term</code></td>\n<td>uint64</td>\n<td>Election term for ordering and duplicate detection</td>\n</tr>\n<tr>\n<td><code>Timestamp</code></td>\n<td>int64</td>\n<td>Creation timestamp for timeout calculation</td>\n</tr>\n</tbody></table>\n<p>The token serves as both a census-taking mechanism and a coordination device. As it travels around the ring, it accumulates evidence of which nodes are alive and participating. When it returns to the initiator, the <code>Participants</code> slice contains a definitive list of live nodes from which the leader can be deterministically selected.</p>\n<h4 id=\"token-passing-state-machine\">Token Passing State Machine</h4>\n<p>Each node in the ring maintains state about ongoing elections and transitions through different roles as tokens pass through:</p>\n<table>\n<thead>\n<tr>\n<th>Node State</th>\n<th>Description</th>\n<th>Trigger Events</th>\n<th>Actions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Idle</strong></td>\n<td>No active election, following current leader</td>\n<td>Leader failure detected</td>\n<td>Initiate new election</td>\n</tr>\n<tr>\n<td><strong>Token Creator</strong></td>\n<td>This node initiated current election</td>\n<td>Election timeout or failure</td>\n<td>Create and send initial token</td>\n</tr>\n<tr>\n<td><strong>Token Forwarder</strong></td>\n<td>Processing received token from predecessor</td>\n<td>Token received</td>\n<td>Add self to participants, forward to successor</td>\n</tr>\n<tr>\n<td><strong>Token Receiver</strong></td>\n<td>Received completed token back from ring</td>\n<td>Complete token received</td>\n<td>Select leader from participants list</td>\n</tr>\n<tr>\n<td><strong>Leader Elected</strong></td>\n<td>Election completed, leader determined</td>\n<td>Token processing complete</td>\n<td>Announce coordinator or become follower</td>\n</tr>\n</tbody></table>\n<h4 id=\"ring-election-steps\">Ring Election Steps</h4>\n<p>The complete ring election protocol follows these detailed steps:</p>\n<ol>\n<li><p><strong>Election Initiation</strong>: A node detects leader failure through the failure detection mechanism or election timeout. It transitions to candidate state and decides to initiate a ring election.</p>\n</li>\n<li><p><strong>Token Creation</strong>: The initiating node creates a new <code>RingToken</code> with a unique <code>ElectionID</code>, sets itself as the <code>InitiatorID</code>, adds its own <code>NodeID</code> to the <code>Participants</code> list, and marks <code>Complete</code> as false.</p>\n</li>\n<li><p><strong>Initial Token Transmission</strong>: The initiator finds its successor in the ring using <code>findNextLiveNode()</code> and sends the token via <code>SendMessage()</code> to begin the circulation process.</p>\n</li>\n<li><p><strong>Token Reception and Processing</strong>: Each node that receives the token performs several validation and processing steps:</p>\n<ul>\n<li>Verify the token is for a current election (not outdated or duplicate)</li>\n<li>Add its own <code>NodeID</code> to the <code>Participants</code> list if not already present</li>\n<li>Check if this token has completed a full ring traversal by comparing current position to initiator</li>\n</ul>\n</li>\n<li><p><strong>Token Forwarding</strong>: After processing, each node determines its successor in the ring and forwards the modified token. If the immediate successor is unreachable, the node uses ring repair logic to skip failed nodes.</p>\n</li>\n<li><p><strong>Ring Completion Detection</strong>: When the token returns to the original initiator, the initiator recognizes completion by seeing its own ID as the next recipient. It marks the token as <code>Complete = true</code>.</p>\n</li>\n<li><p><strong>Leader Selection</strong>: The initiator examines the complete <code>Participants</code> list and selects the node with the highest <code>NodeID</code> value as the new leader. This selection is deterministic and will be the same regardless of which node performs it.</p>\n</li>\n<li><p><strong>Coordinator Announcement</strong>: The initiator broadcasts a <code>CoordinatorMessage</code> to all nodes in the cluster, announcing the elected leader and the election term. All nodes update their leader state accordingly.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Key Design Insight</strong>: The ring election separates the <em>information gathering phase</em> (token circulation) from the <em>decision phase</em> (leader selection). This separation makes the algorithm more predictable and easier to debug than protocols that interleave discovery and decision-making.</p>\n</blockquote>\n<h4 id=\"token-circulation-example\">Token Circulation Example</h4>\n<p>Consider a cluster with nodes [1, 3, 5, 7] where node 3 detects leader failure and initiates an election:</p>\n<p><strong>Step 1</strong>: Node 3 creates token: <code>{ElectionID: 12, InitiatorID: 3, Participants: [3], Complete: false}</code></p>\n<p><strong>Step 2</strong>: Node 3 sends token to successor Node 5</p>\n<p><strong>Step 3</strong>: Node 5 receives token, adds itself: <code>{ElectionID: 12, InitiatorID: 3, Participants: [3, 5], Complete: false}</code></p>\n<p><strong>Step 4</strong>: Node 5 sends token to successor Node 7</p>\n<p><strong>Step 5</strong>: Node 7 receives token, adds itself: <code>{ElectionID: 12, InitiatorID: 3, Participants: [3, 5, 7], Complete: false}</code></p>\n<p><strong>Step 6</strong>: Node 7 sends token to successor Node 1</p>\n<p><strong>Step 7</strong>: Node 1 receives token, adds itself: <code>{ElectionID: 12, InitiatorID: 3, Participants: [3, 5, 7, 1], Complete: false}</code></p>\n<p><strong>Step 8</strong>: Node 1 sends token back to Node 3 (completing the ring)</p>\n<p><strong>Step 9</strong>: Node 3 receives token, marks complete, selects Node 7 (highest ID) as leader, broadcasts coordinator announcement</p>\n<h4 id=\"concurrent-election-handling\">Concurrent Election Handling</h4>\n<p>Unlike bully elections where concurrent elections can create complex cascades, ring elections handle concurrency through token precedence and election ID comparison:</p>\n<table>\n<thead>\n<tr>\n<th>Scenario</th>\n<th>Detection Method</th>\n<th>Resolution Strategy</th>\n<th>Outcome</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Multiple Initiators</strong></td>\n<td>Different ElectionID values</td>\n<td>Higher ElectionID takes precedence</td>\n<td>Lower ID election abandoned</td>\n</tr>\n<tr>\n<td><strong>Token Collision</strong></td>\n<td>Same node receives multiple tokens</td>\n<td>Compare timestamps and initiator IDs</td>\n<td>Earlier or higher-priority token wins</td>\n</tr>\n<tr>\n<td><strong>Stale Token</strong></td>\n<td>Token from previous election</td>\n<td>Check against current election term</td>\n<td>Stale token discarded</td>\n</tr>\n<tr>\n<td><strong>Partition Merge</strong></td>\n<td>Tokens from different partitions</td>\n<td>Compare election metadata</td>\n<td>Most recent/complete election wins</td>\n</tr>\n</tbody></table>\n<h3 id=\"ring-maintenance-and-repair\">Ring Maintenance and Repair</h3>\n<p>The logical ring topology requires continuous maintenance to handle node failures, network partitions, and membership changes. Ring repair mechanisms ensure that election tokens can always find a path around the ring, even when some nodes are unreachable.</p>\n<h4 id=\"failure-detection-in-ring-context\">Failure Detection in Ring Context</h4>\n<p>Ring elections rely on two levels of failure detection: <strong>immediate successor failure</strong> during token forwarding, and <strong>background membership monitoring</strong> for proactive ring updates.</p>\n<p><strong>Successor Failure Detection</strong>: When a node attempts to forward a token to its successor and encounters a timeout or connection failure, it immediately triggers ring repair to find the next live node in sequence.</p>\n<p><strong>Background Health Monitoring</strong>: The failure detection component continuously monitors all known nodes via heartbeats and updates the <code>ClusterMembership</code>. When failures are detected, the ring topology is asynchronously updated to reflect the new membership.</p>\n<table>\n<thead>\n<tr>\n<th>Detection Method</th>\n<th>Trigger</th>\n<th>Response Time</th>\n<th>Accuracy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Token Forward Timeout</strong></td>\n<td>SendMessage() fails to successor</td>\n<td>Immediate (during election)</td>\n<td>High - tested during use</td>\n</tr>\n<tr>\n<td><strong>Heartbeat Timeout</strong></td>\n<td>No heartbeat within interval</td>\n<td>Background (eventual)</td>\n<td>Medium - may have false positives</td>\n</tr>\n<tr>\n<td><strong>Connection Refused</strong></td>\n<td>TCP/HTTP connection rejected</td>\n<td>Immediate</td>\n<td>High - definitive failure</td>\n</tr>\n<tr>\n<td><strong>Membership Update</strong></td>\n<td>External membership change</td>\n<td>Event-driven</td>\n<td>High - authoritative source</td>\n</tr>\n</tbody></table>\n<h4 id=\"ring-repair-algorithm\">Ring Repair Algorithm</h4>\n<p>When a node discovers that its immediate successor is unreachable, it must dynamically repair the ring by finding the next live node in the sequence. This repair happens transparently during token forwarding:</p>\n<ol>\n<li><p><strong>Failure Detection</strong>: Node A attempts to send token to successor Node B but receives a timeout or connection error.</p>\n</li>\n<li><p><strong>Successor Search</strong>: Node A queries its local <code>ClusterMembership</code> to get the current list of believed-live nodes and rebuilds the ring sequence.</p>\n</li>\n<li><p><strong>Next Live Node Calculation</strong>: Node A finds the next node in ring order after the failed Node B. This might require skipping multiple failed nodes.</p>\n</li>\n<li><p><strong>Connection Validation</strong>: Node A tests connectivity to the calculated next live node before forwarding the token to ensure the repair is effective.</p>\n</li>\n<li><p><strong>Token Forward with Repair</strong>: Node A sends the token to the validated next live node, effectively bypassing the failed portion of the ring.</p>\n</li>\n<li><p><strong>Membership Update</strong>: Node A marks the failed nodes as suspicious or unreachable in its local failure detector to prevent repeated repair attempts.</p>\n</li>\n</ol>\n<p>The <code>findNextLiveNode()</code> method implements this repair logic:</p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Action</th>\n<th>Failure Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>1. Get Ring Sequence</strong></td>\n<td>Retrieve ordered node list from membership</td>\n<td>Use cached sequence if membership unavailable</td>\n</tr>\n<tr>\n<td><strong>2. Find Current Position</strong></td>\n<td>Locate starting node in sequence</td>\n<td>Return error if starting node not in ring</td>\n</tr>\n<tr>\n<td><strong>3. Iterate to Next</strong></td>\n<td>Move to next position in ring order</td>\n<td>Wrap around from highest to lowest ID</td>\n</tr>\n<tr>\n<td><strong>4. Test Connectivity</strong></td>\n<td>Attempt connection to candidate node</td>\n<td>Skip unreachable nodes, continue search</td>\n</tr>\n<tr>\n<td><strong>5. Return Live Node</strong></td>\n<td>Return first reachable successor</td>\n<td>Return error if no live nodes found</td>\n</tr>\n</tbody></table>\n<h4 id=\"partition-healing-and-ring-reconstruction\">Partition Healing and Ring Reconstruction</h4>\n<p>Network partitions can split the logical ring into multiple disconnected segments, each potentially running independent elections. When partitions heal and network connectivity is restored, the system must merge the segments back into a unified ring and resolve any conflicting leadership states.</p>\n<p><strong>Partition Detection</strong>: Nodes detect they&#39;re in a partition when they can only reach a subset of the expected cluster members. Ring elections may proceed within each partition segment, potentially electing different leaders.</p>\n<p><strong>Healing Detection</strong>: When network connectivity is restored, nodes begin receiving heartbeats and messages from previously unreachable nodes. The <code>ClusterMembership</code> component detects the membership expansion.</p>\n<p><strong>Ring Reconstruction Process</strong>:</p>\n<ol>\n<li><strong>Membership Reconciliation</strong>: All nodes update their membership view to include newly reachable nodes</li>\n<li><strong>Ring Topology Rebuild</strong>: Recalculate the complete ring sequence with all available nodes</li>\n<li><strong>Leader Conflict Resolution</strong>: If multiple leaders exist from partition elections, apply deterministic rules (highest ID, most recent term) to select one</li>\n<li><strong>State Synchronization</strong>: The unified leader broadcasts its authority to ensure all nodes converge on consistent state</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Partition Scenario</th>\n<th>Challenge</th>\n<th>Resolution Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Clean Split</strong></td>\n<td>Two complete ring segments</td>\n<td>Merge segments, highest ID leader wins</td>\n</tr>\n<tr>\n<td><strong>Fragmented Ring</strong></td>\n<td>Multiple small partitions</td>\n<td>Rebuild complete ring, re-elect from full membership</td>\n</tr>\n<tr>\n<td><strong>Majority Partition</strong></td>\n<td>One large + several small partitions</td>\n<td>Large partition leader takes precedence</td>\n</tr>\n<tr>\n<td><strong>Symmetric Split</strong></td>\n<td>Equal-sized partitions</td>\n<td>Deterministic tiebreaker (highest leader ID)</td>\n</tr>\n</tbody></table>\n<h4 id=\"ring-state-consistency\">Ring State Consistency</h4>\n<p>Maintaining consistent ring state across all nodes requires careful coordination, especially during membership changes and election processes. The system uses several mechanisms to ensure consistency:</p>\n<p><strong>Ring Version Tracking</strong>: Each ring topology change increments a version counter. Nodes compare versions to detect when their local ring view is stale and needs updating.</p>\n<p><strong>Atomic Ring Updates</strong>: When membership changes are detected, all affected nodes must update their ring topology atomically to prevent temporary inconsistencies during token forwarding.</p>\n<p><strong>Ring Validation</strong>: Before initiating elections, nodes validate their ring topology by checking that their successor is reachable and agrees on the ring structure.</p>\n<p>⚠️ <strong>Pitfall: Stale Ring Topology</strong>\nA common error is using outdated ring topology during elections, causing tokens to be sent to failed nodes or wrong successors. This happens when nodes don&#39;t promptly update their ring state after membership changes. The symptom is elections that hang or never complete because tokens get lost. Fix this by always validating ring connectivity before election initiation and implementing triggered ring updates when membership changes are detected.</p>\n<p>⚠️ <strong>Pitfall: Ring Split During Election</strong>\nIf the ring topology changes (due to node failures) while an election token is circulating, the token might get stuck or take an unexpected path. This can cause elections to hang indefinitely or produce incorrect results. The symptom is tokens never returning to their initiator. Fix this by implementing election timeouts at the initiator and re-starting elections with updated topology when timeouts occur.</p>\n<blockquote>\n<p><strong>Critical Design Principle</strong>: Ring consistency is more important than ring completeness. It&#39;s better to have a smaller ring with all nodes agreeing on the topology than a complete ring where nodes have inconsistent views of their successors.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Ring State Storage</strong></td>\n<td>In-memory map[NodeID]NodeID</td>\n<td>Persistent key-value store with versioning</td>\n</tr>\n<tr>\n<td><strong>Token Serialization</strong></td>\n<td>JSON over HTTP</td>\n<td>Protocol Buffers with binary encoding</td>\n</tr>\n<tr>\n<td><strong>Failure Detection</strong></td>\n<td>HTTP request timeouts</td>\n<td>gRPC health checking with retry logic</td>\n</tr>\n<tr>\n<td><strong>Ring Repair</strong></td>\n<td>Linear search through membership</td>\n<td>Consistent hashing with virtual nodes</td>\n</tr>\n<tr>\n<td><strong>Election Coordination</strong></td>\n<td>Synchronous token passing</td>\n<td>Asynchronous event-driven state machine</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/election/\n  ring/\n    ring_election.go          ← main RingElection implementation\n    ring_topology.go          ← ring construction and maintenance\n    token_manager.go          ← token creation and processing\n    ring_repair.go           ← failure detection and ring repair\n    ring_election_test.go    ← comprehensive ring election tests\n  messages/\n    ring_token.go            ← RingToken message structure\n    token_serialization.go   ← JSON marshaling for tokens</code></pre></div>\n\n<h4 id=\"ring-topology-infrastructure-code\">Ring Topology Infrastructure Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> ring</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">errors</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sort</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RingTopology manages the logical ring structure and successor relationships</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RingTopology</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu             </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID         </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    successorMap   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ringSequence   []</span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    membership     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ringVersion    </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastUpdate     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewRingTopology creates a new ring topology manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewRingTopology</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">membership</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ClusterMembership</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingTopology</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">RingTopology</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nodeID:       nodeID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        successorMap: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        membership:   membership,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ringVersion:  </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lastUpdate:   time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RebuildRing reconstructs the ring topology from current cluster membership</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rt </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingTopology</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RebuildRing</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rt.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> rt.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    activeNodes </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> rt.membership.</span><span style=\"color:#B392F0\">GetActiveMembers</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(activeNodes) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"no active nodes for ring construction\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Extract and sort node IDs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeIDs </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(activeNodes))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, node </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> activeNodes {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nodeIDs[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node.ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sort.</span><span style=\"color:#B392F0\">Slice</span><span style=\"color:#E1E4E8\">(nodeIDs, </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">i</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">j</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> nodeIDs[i] </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> nodeIDs[j]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Build successor map</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    newSuccessorMap </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, nodeID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> nodeIDs {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nextIndex </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> (i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">%</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(nodeIDs)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        successor </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> nodeIDs[nextIndex]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        newSuccessorMap[nodeID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> successor</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rt.successorMap </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> newSuccessorMap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rt.ringSequence </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> nodeIDs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rt.ringVersion</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rt.lastUpdate </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetSuccessor returns the immediate successor for a given node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rt </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingTopology</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetSuccessor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rt.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> rt.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    successor, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> rt.successorMap[nodeID]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> successor, exists</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FindNextLiveNode locates the next reachable node starting from given position</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rt </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingTopology</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FindNextLiveNode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">startID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">transport</span><span style=\"color:#B392F0\"> Transport</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rt.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ringSeq </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(rt.ringSequence))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(ringSeq, rt.ringSequence)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rt.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(ringSeq) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"empty ring sequence\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Find starting position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    startPos </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, id </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> ringSeq {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> id </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> startID {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            startPos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> i</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> startPos </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"start node not found in ring\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Search for next live node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(ringSeq); i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nextPos </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> (startPos </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> i) </span><span style=\"color:#F97583\">%</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(ringSeq)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        candidateID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> ringSeq[nextPos]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Skip self</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> candidateID </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> rt.nodeID {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Test connectivity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> rt.</span><span style=\"color:#B392F0\">testNodeConnectivity</span><span style=\"color:#E1E4E8\">(candidateID, transport) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> candidateID, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"no live successor nodes found\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// testNodeConnectivity checks if a node is reachable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rt </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingTopology</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">testNodeConnectivity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">transport</span><span style=\"color:#B392F0\"> Transport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create a lightweight ping message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pingMsg </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Type:      MsgHeartbeat,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        From:      rt.nodeID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        To:        nodeID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Timestamp: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Unix</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Attempt to send with short timeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> transport.</span><span style=\"color:#B392F0\">SendMessage</span><span style=\"color:#E1E4E8\">(nodeID, pingMsg)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"ring-election-core-logic-skeleton\">Ring Election Core Logic Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// RingElection implements the ring-based leader election algorithm</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RingElection</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID          </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transport       </span><span style=\"color:#B392F0\">Transport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    membership      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    topology        </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingTopology</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state          </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timeoutManager </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionTimeoutManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Ring-specific state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    activeElections </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingToken</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tokenTimeout    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu             </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartElection initiates a new ring election by creating and circulating a token</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">re </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartElection</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    re.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> re.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if already in an active election - if so, return early</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Rebuild ring topology to get current membership view</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create new RingToken with unique ElectionID and current term</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Add self to token.Participants list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Find next live successor using topology.FindNextLiveNode()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Send token to successor and start election timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update local election state to track this election</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use re.generateElectionID() for unique election identifiers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Store active election in re.activeElections map for tracking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandleMessage processes incoming ring election messages and tokens</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">re </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HandleMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> msg.Type {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> MsgRingToken:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> re.</span><span style=\"color:#B392F0\">handleRingToken</span><span style=\"color:#E1E4E8\">(msg)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"unsupported message type for ring election\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// handleRingToken processes a ring election token received from predecessor</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">re </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">handleRingToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Deserialize RingToken from message payload</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate token (check election ID, term, not stale)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check if token has completed full ring (initiator == self)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If complete, select leader and broadcast coordinator message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If not complete, add self to participants and forward</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Find next live successor for forwarding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Send modified token to successor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Update local tracking state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use json.Unmarshal to deserialize RingToken</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Leader selection: find max NodeID in token.Participants</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use re.topology.FindNextLiveNode() for successor lookup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// selectLeaderFromParticipants determines leader from collected participant IDs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">re </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">selectLeaderFromParticipants</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">participants</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Handle empty participants list (return 0, log error)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Iterate through participants to find maximum NodeID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return the highest NodeID as the elected leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Simple loop with max tracking variable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// forwardToken sends ring token to next live node in sequence</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">re </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">forwardToken</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">token</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">RingToken</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">successorID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Serialize RingToken to JSON payload</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create Message with MsgRingToken type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Set message metadata (From, To, Term, Timestamp)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Send message using transport layer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Handle send failures with ring repair</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use json.Marshal for token serialization</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: If SendMessage fails, try re.topology.FindNextLiveNode()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// generateElectionID creates unique identifier for new election</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">re </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">generateElectionID</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">(time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UnixNano</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing ring election, verify correct behavior:</p>\n<p><strong>Test Command</strong>: <code>go test ./internal/election/ring/ -v</code></p>\n<p><strong>Expected Output</strong>:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>=== RUN   TestRingElection_BasicFlow\n--- PASS: TestRingElection_BasicFlow (0.05s)\n=== RUN   TestRingElection_NodeFailureDuringElection  \n--- PASS: TestRingElection_NodeFailureDuringElection (0.12s)\n=== RUN   TestRingElection_ConcurrentElections\n--- PASS: TestRingElection_ConcurrentElections (0.08s)</code></pre></div>\n\n<p><strong>Manual Verification</strong>:</p>\n<ol>\n<li>Start 4 nodes with IDs [1, 3, 5, 7]</li>\n<li>Kill the current leader node</li>\n<li>Observe election initiation in logs: <code>&quot;Ring election started by node 3, election_id=12345&quot;</code></li>\n<li>Watch token circulation: <code>&quot;Token forwarded to successor node 5&quot;</code> → <code>&quot;Token forwarded to successor node 7&quot;</code> etc.</li>\n<li>Verify leader announcement: <code>&quot;Node 7 elected as leader, election completed&quot;</code></li>\n<li>Confirm all nodes acknowledge new leader</li>\n</ol>\n<p><strong>Debugging Signs</strong>:</p>\n<ul>\n<li><strong>Election hangs</strong>: Check ring topology - likely broken successor chain</li>\n<li><strong>Wrong leader elected</strong>: Verify participant collection - token may have skipped live nodes  </li>\n<li><strong>Multiple leaders</strong>: Check election ID comparison - concurrent elections not properly resolved</li>\n<li><strong>Token loops</strong>: Validate ring repair logic - failed nodes not being skipped correctly</li>\n</ul>\n<h2 id=\"system-interactions-and-data-flow\">System Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - orchestrates the complete election process by combining node communication (Milestone 1), bully algorithm (Milestone 2), and ring election (Milestone 3) into coordinated system-wide behaviors</p>\n</blockquote>\n<p>Understanding individual components is only half the battle in distributed systems. The real complexity emerges from how these components interact to produce system-wide behaviors. This section maps out the complete choreography of leader election, from the initial trigger events through message exchanges to final leader establishment. Think of it as the conductor&#39;s score that coordinates all the individual musicians (components) into a symphony of distributed coordination.</p>\n<p>The system interactions reveal the temporal aspects that component descriptions cannot capture: the precise ordering of operations, the cascading effects of failures, and the intricate timing dependencies that make distributed leader election both powerful and challenging. These patterns repeat across both election algorithms, creating a foundation for understanding any distributed coordination protocol.</p>\n<h3 id=\"election-initiation-scenarios\">Election Initiation Scenarios</h3>\n<p>Leader elections don&#39;t spontaneously occur - they are triggered by specific observable events that indicate the current leadership state is invalid or uncertain. Understanding these trigger scenarios is crucial because they determine when the system transitions from stable operation to active coordination. Each scenario requires different detection mechanisms and response strategies, making this the most context-sensitive aspect of the entire system.</p>\n<p>The initiation logic acts as the system&#39;s &quot;political crisis detector&quot; - it must distinguish between temporary communication hiccups and genuine leadership failures, avoid false alarms that waste resources, and ensure that elections start quickly enough to minimize availability gaps. Getting this wrong leads to either constant unnecessary elections (resource waste) or delayed failure detection (availability loss).</p>\n<h4 id=\"failure-detection-triggers\">Failure Detection Triggers</h4>\n<p>The primary election trigger occurs when the current leader becomes unresponsive or unreachable. The failure detection process operates continuously in the background, monitoring leader heartbeats and maintaining suspicion levels for each node. When suspicion crosses the configured threshold, any follower can initiate a new election to restore cluster leadership.</p>\n<p><strong>Heartbeat Timeout Detection Process:</strong></p>\n<ol>\n<li><strong>Continuous Monitoring Phase</strong>: Each follower node tracks the last received <code>HeartbeatMessage</code> from the current leader, comparing timestamps against the configured heartbeat interval plus tolerance margin</li>\n<li><strong>Suspicion Escalation</strong>: When heartbeats become overdue, the follower increments its local suspicion counter for the leader, allowing for temporary network delays or leader processing pauses  </li>\n<li><strong>Failure Threshold Crossing</strong>: Once suspicion reaches the configured maximum (typically 3-5 missed heartbeats), the follower declares the leader failed and transitions to candidate state</li>\n<li><strong>Election Initiation</strong>: The newly-transitioned candidate calls either <code>BullyElection.StartElection()</code> or <code>RingElection.StartElection()</code> depending on the configured algorithm</li>\n<li><strong>Broadcast Notification</strong>: Other nodes are informed of the suspected leader failure through election messages, allowing them to update their local leader state and participate in the new election</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Detection Parameter</th>\n<th>Purpose</th>\n<th>Typical Value</th>\n<th>Impact of Too Low</th>\n<th>Impact of Too High</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Heartbeat Interval</td>\n<td>Leader alive signal frequency</td>\n<td>1-2 seconds</td>\n<td>Network overhead, false failures</td>\n<td>Slow failure detection</td>\n</tr>\n<tr>\n<td>Heartbeat Timeout</td>\n<td>Missing heartbeat threshold</td>\n<td>3x heartbeat interval</td>\n<td>False failure detection</td>\n<td>Prolonged unavailability</td>\n</tr>\n<tr>\n<td>Suspicion Threshold</td>\n<td>Failed heartbeat count limit</td>\n<td>3-5 missed beats</td>\n<td>Election storms</td>\n<td>Extended outage duration</td>\n</tr>\n<tr>\n<td>Election Timeout</td>\n<td>Candidate response deadline</td>\n<td>5-10 seconds</td>\n<td>Split elections</td>\n<td>Slow leader establishment</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Insight:</strong> The failure detection timeout must balance two competing requirements: fast failure detection (low timeout) versus stability under temporary network delays (high timeout). Most production systems use adaptive timeouts that increase during periods of network instability.</p>\n</blockquote>\n<h4 id=\"startup-and-bootstrap-scenarios\">Startup and Bootstrap Scenarios</h4>\n<p>When nodes join an empty cluster or restart after a complete system shutdown, there is no existing leader to provide heartbeats. This creates a bootstrap scenario where multiple nodes may simultaneously recognize the leadership vacuum and attempt to fill it. The system must handle these concurrent startup elections gracefully to establish initial leadership quickly and deterministically.</p>\n<p><strong>Cluster Bootstrap Election Process:</strong></p>\n<ol>\n<li><strong>Initial State Assessment</strong>: Each starting node begins in <code>StateFollower</code> and waits for a brief randomized delay (typically 1-5 seconds) to detect existing leadership through heartbeat messages</li>\n<li><strong>Leadership Vacuum Detection</strong>: If no <code>HeartbeatMessage</code> or <code>CoordinatorMessage</code> is received during the initial waiting period, the node assumes no leader exists and becomes eligible for election initiation  </li>\n<li><strong>Randomized Election Start</strong>: To prevent simultaneous elections, each node uses a randomized timeout based on its <code>NodeID</code> before transitioning to <code>StateCandidate</code> and starting an election</li>\n<li><strong>Concurrent Election Resolution</strong>: Multiple nodes may still initiate elections simultaneously, but the election algorithms (bully or ring) have built-in mechanisms to resolve conflicts and converge on a single leader</li>\n<li><strong>Leader Establishment</strong>: Once a leader emerges and begins sending heartbeats, remaining candidates return to <code>StateFollower</code> and the cluster transitions to normal operation</li>\n</ol>\n<p>The randomization strategy typically uses the formula: <code>baseTimeout + (NodeID % maxJitter)</code> where <code>baseTimeout</code> provides the minimum wait and <code>maxJitter</code> spreads election attempts across time to reduce conflicts.</p>\n<h4 id=\"network-partition-recovery\">Network Partition Recovery</h4>\n<p>When network partitions heal and previously isolated nodes reconnect, the system may discover multiple concurrent leaders or conflicting cluster state. This scenario requires careful coordination to merge the separate partitions while maintaining consistency and avoiding data conflicts that could arise from dual leadership periods.</p>\n<p><strong>Partition Healing Process:</strong></p>\n<ol>\n<li><strong>Partition Detection</strong>: Nodes detect partition healing when they begin receiving messages from previously unreachable nodes, indicated by seeing unfamiliar <code>NodeID</code> values or receiving messages with higher term numbers than expected</li>\n<li><strong>Leader Conflict Resolution</strong>: If multiple nodes claim leadership (detected through competing <code>HeartbeatMessage</code> broadcasts with different <code>LeaderID</code> values), the system initiates a conflict resolution election</li>\n<li><strong>Term Number Comparison</strong>: Nodes compare their current term numbers, with higher terms taking precedence - nodes with lower terms immediately step down and transition to <code>StateFollower</code>  </li>\n<li><strong>State Convergence</strong>: The partition with the higher term number (or higher leader ID in case of term ties) becomes authoritative, while other partitions adopt its leadership and term state</li>\n<li><strong>Membership Reconciliation</strong>: The newly unified cluster updates its membership view through the <code>ClusterMembership.UpdateMembership()</code> method to reflect all reconnected nodes</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Term-Based Partition Resolution</strong></p>\n<ul>\n<li><strong>Context</strong>: When partitions heal, we need a deterministic way to resolve conflicting leadership claims without requiring complex quorum calculations</li>\n<li><strong>Options Considered</strong>: Term number precedence, timestamp comparison, quorum-based voting</li>\n<li><strong>Decision</strong>: Higher term numbers always take precedence, with NodeID as tiebreaker  </li>\n<li><strong>Rationale</strong>: Term numbers provide a total ordering that prevents cyclic conflicts, and they&#39;re monotonically increasing which ensures forward progress</li>\n<li><strong>Consequences</strong>: Enables fast partition healing but requires careful term increment management to avoid overflow</li>\n</ul>\n</blockquote>\n<h4 id=\"manual-election-triggers\">Manual Election Triggers</h4>\n<p>Administrative scenarios may require manual leader election, such as planned leader migration, load balancing, or maintenance operations. These voluntary elections differ from failure-based elections because the current leader is healthy and can participate in orderly leadership transfer.</p>\n<p><strong>Planned Leadership Transfer:</strong></p>\n<ol>\n<li><strong>Administrative Request</strong>: An operator or management system calls a leadership transfer API on the current leader, specifying an optional preferred successor <code>NodeID</code></li>\n<li><strong>Graceful Transition Initiation</strong>: The current leader stops sending heartbeats and broadcasts a special <code>CoordinatorMessage</code> indicating voluntary step-down, including the current term number</li>\n<li><strong>Election Coordination</strong>: The stepping-down leader can either initiate an election itself (ensuring higher-ID nodes participate) or wait for followers to detect the heartbeat cessation and start elections naturally</li>\n<li><strong>Orderly State Transfer</strong>: Unlike failure scenarios, the departing leader remains available to answer queries and transfer any volatile state to the successor before fully stepping down</li>\n<li><strong>Confirmation Phase</strong>: The new leader confirms successful election by broadcasting <code>HeartbeatMessage</code> signals, and the old leader transitions permanently to <code>StateFollower</code></li>\n</ol>\n<h3 id=\"message-sequence-patterns\">Message Sequence Patterns</h3>\n<p>The temporal choreography of leader election becomes visible through message sequence patterns that show how individual component interactions combine to produce system-wide coordination. These patterns reveal the critical timing dependencies, message ordering requirements, and failure recovery flows that make distributed leader election both robust and complex.</p>\n<p>Each algorithm creates distinct message flow signatures that help with debugging, performance optimization, and correctness verification. Understanding these patterns is essential for implementing proper timeout handling, detecting election failures, and ensuring the system converges to a stable leadership state under all conditions.</p>\n<p><img src=\"/api/project/leader-election/architecture-doc/asset?path=diagrams%2Fbully-sequence.svg\" alt=\"Bully Algorithm Message Flow\"></p>\n<h4 id=\"bully-algorithm-message-flow\">Bully Algorithm Message Flow</h4>\n<p>The bully algorithm creates a competitive message pattern where nodes challenge higher-ID nodes for leadership, creating a natural hierarchy that emerges through process elimination. This produces a distinctive &quot;challenge-response-victory&quot; pattern that can be easily traced through network logs and used to verify correct algorithm behavior.</p>\n<p><strong>Complete Bully Election Sequence:</strong></p>\n<ol>\n<li><strong>Election Initiation</strong>: Node detects leader failure and transitions to <code>StateCandidate</code>, generating unique election ID and recording current term number for message consistency</li>\n<li><strong>Challenge Phase</strong>: Candidate uses <code>BullyElection.SendMessage()</code> to send <code>ElectionMessage</code> to all nodes with higher <code>NodeID</code> values, starting the competitive challenge process</li>\n<li><strong>Response Collection</strong>: Higher-ID nodes that are alive and reachable respond with <code>OKMessage</code>, indicating they are participating and will conduct their own election attempts</li>\n<li><strong>Elimination Decision</strong>: If candidate receives any <code>OKMessage</code> responses, it knows higher-ID nodes exist and immediately transitions back to <code>StateFollower</code>, abandoning its election attempt  </li>\n<li><strong>Victory Declaration</strong>: If no <code>OKMessage</code> responses arrive within the election timeout period, the candidate declares victory and broadcasts <code>CoordinatorMessage</code> to all cluster members</li>\n<li><strong>Leadership Confirmation</strong>: The new leader transitions to <code>StateLeader</code>, increments the term number, and begins sending periodic <code>HeartbeatMessage</code> broadcasts to maintain leadership</li>\n</ol>\n<p><strong>Message Timing and Ordering:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Message Type</th>\n<th>Sender</th>\n<th>Recipients</th>\n<th>Timeout</th>\n<th>Success Condition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Challenge</td>\n<td><code>ElectionMessage</code></td>\n<td>Candidate</td>\n<td>Higher-ID nodes</td>\n<td>5-10 seconds</td>\n<td>Send to all higher IDs</td>\n</tr>\n<tr>\n<td>Response</td>\n<td><code>OKMessage</code></td>\n<td>Higher-ID nodes</td>\n<td>Candidate</td>\n<td>Immediate</td>\n<td>Acknowledge within timeout</td>\n</tr>\n<tr>\n<td>Victory</td>\n<td><code>CoordinatorMessage</code></td>\n<td>Winner</td>\n<td>All nodes</td>\n<td>Best-effort broadcast</td>\n<td>Reach majority of nodes</td>\n</tr>\n<tr>\n<td>Maintenance</td>\n<td><code>HeartbeatMessage</code></td>\n<td>Leader</td>\n<td>All nodes</td>\n<td>Every 1-2 seconds</td>\n<td>Continuous transmission</td>\n</tr>\n</tbody></table>\n<p>The bully algorithm&#39;s strength lies in its deterministic conflict resolution - exactly one node (the highest responding ID) can win each election. However, this creates cascading elections when higher-ID nodes fail during the election process, potentially leading to multiple sequential elections before stabilizing.</p>\n<p><strong>Cascade Election Scenario:</strong></p>\n<p>Consider a cluster with nodes [1, 2, 3, 4, 5] where node 5 is the failed leader. Node 2 initiates an election and sends <code>ElectionMessage</code> to nodes [3, 4, 5]. Node 3 responds with <code>OKMessage</code> and starts its own election, sending <code>ElectionMessage</code> to nodes [4, 5]. If node 4 then fails during this process, node 3 will timeout and declare victory, broadcasting <code>CoordinatorMessage</code> to establish leadership.</p>\n<h4 id=\"ring-election-message-flow\">Ring Election Message Flow</h4>\n<p>Ring election creates a token-passing pattern where a single election message circulates through the cluster, collecting participant information and enabling distributed leader selection. This produces a more predictable message flow with fewer total messages but requires careful token forwarding logic to handle node failures during circulation.</p>\n<p><img src=\"/api/project/leader-election/architecture-doc/asset?path=diagrams%2Fring-sequence.svg\" alt=\"Ring Election Token Passing\"></p>\n<p><strong>Complete Ring Election Sequence:</strong></p>\n<ol>\n<li><strong>Token Creation</strong>: Initiating node calls <code>RingElection.StartElection()</code>, creates new <code>RingToken</code> with unique election ID, and adds its own <code>NodeID</code> to the participants list</li>\n<li><strong>Ring Traversal</strong>: Token holder uses <code>findNextLiveNode()</code> to locate the next reachable node in ring order and forwards the token using <code>forwardToken()</code> method</li>\n<li><strong>Participant Collection</strong>: Each receiving node adds its <code>NodeID</code> to the token&#39;s participants list and forwards it to the next live node, building a complete view of active cluster members</li>\n<li><strong>Completion Detection</strong>: When the token returns to the original initiator (detected by matching election ID), the ring traversal is complete and leader selection begins</li>\n<li><strong>Leader Selection</strong>: The initiator calls <code>selectLeaderFromParticipants()</code> to deterministically choose the highest <code>NodeID</code> from the collected participants list  </li>\n<li><strong>Leadership Announcement</strong>: The selected leader broadcasts <code>CoordinatorMessage</code> to all participants and begins sending <code>HeartbeatMessage</code> signals to maintain leadership</li>\n</ol>\n<p><strong>Ring Token Structure Evolution:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Ring Position</th>\n<th>Token State</th>\n<th>Participants List</th>\n<th>Next Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Node 3 (initiator)</td>\n<td><code>{ElectionID: 1001, Participants: [3]}</code></td>\n<td>[3]</td>\n<td>Forward to Node 5</td>\n</tr>\n<tr>\n<td>Node 5</td>\n<td><code>{ElectionID: 1001, Participants: [3, 5]}</code></td>\n<td>[3, 5]</td>\n<td>Forward to Node 7</td>\n</tr>\n<tr>\n<td>Node 7</td>\n<td><code>{ElectionID: 1001, Participants: [3, 5, 7]}</code></td>\n<td>[3, 5, 7]</td>\n<td>Forward to Node 1</td>\n</tr>\n<tr>\n<td>Node 1</td>\n<td><code>{ElectionID: 1001, Participants: [3, 5, 7, 1]}</code></td>\n<td>[3, 5, 7, 1]</td>\n<td>Forward to Node 3</td>\n</tr>\n<tr>\n<td>Node 3 (completion)</td>\n<td><code>{ElectionID: 1001, Complete: true}</code></td>\n<td>[3, 5, 7, 1]</td>\n<td>Select leader (7)</td>\n</tr>\n</tbody></table>\n<p>The ring algorithm&#39;s advantage is predictable message complexity - exactly one message per live node, regardless of cluster size. However, it&#39;s vulnerable to token loss if the token holder fails during forwarding, requiring timeout-based token regeneration mechanisms.</p>\n<p><strong>Ring Repair During Election:</strong></p>\n<p>When a node fails to forward the token within the configured <code>tokenTimeout</code>, the previous node detects the failure and uses <code>findNextLiveNode()</code> to skip the failed node and continue circulation. This dynamic ring repair ensures elections can complete even during node failures, though it may require multiple timeout periods to bypass multiple consecutive failures.</p>\n<h4 id=\"concurrent-election-resolution\">Concurrent Election Resolution</h4>\n<p>Both algorithms must handle scenarios where multiple nodes simultaneously initiate elections, either due to simultaneous failure detection or network partition recovery. The message patterns during concurrent elections reveal how the algorithms converge to single leadership despite starting from chaotic initial conditions.</p>\n<p><strong>Concurrent Bully Election Resolution:</strong></p>\n<p>When multiple nodes start bully elections simultaneously, their <code>ElectionMessage</code> broadcasts overlap and create a complex interaction pattern. However, the algorithm&#39;s competitive nature ensures convergence:</p>\n<ol>\n<li><strong>Multiple Initiators</strong>: Nodes 2, 3, and 4 all detect leader failure simultaneously and broadcast <code>ElectionMessage</code> to higher-ID nodes  </li>\n<li><strong>Cross-Election Interference</strong>: Node 4 receives <code>ElectionMessage</code> from both nodes 2 and 3, while also conducting its own election - it responds with <code>OKMessage</code> to the lower-ID nodes</li>\n<li><strong>Hierarchical Resolution</strong>: Node 4&#39;s responses cause nodes 2 and 3 to abandon their elections, while node 4 continues its own election attempt</li>\n<li><strong>Single Winner Emergence</strong>: Only the highest-ID node (4) reaches the victory timeout without receiving <code>OKMessage</code>, leading to deterministic single-leader convergence</li>\n</ol>\n<p><strong>Concurrent Ring Election Resolution:</strong></p>\n<p>Ring elections use token-based serialization to prevent conflicts. If multiple nodes attempt to initiate ring elections simultaneously, the conflict resolution depends on timing and token collision handling:</p>\n<ol>\n<li><strong>Token Collision Detection</strong>: When a node receives a <code>RingToken</code> while conducting its own election, it compares election IDs and timestamps to determine precedence</li>\n<li><strong>Election ID Precedence</strong>: The election with the higher election ID (or earlier timestamp in case of ID collision) takes precedence, while the other is abandoned</li>\n<li><strong>Token Forwarding Decision</strong>: The receiving node abandons its own election, adds itself to the winning token&#39;s participants list, and forwards that token instead  </li>\n<li><strong>Single Token Survival</strong>: Eventually only one token continues circulating, ensuring deterministic single-leader election completion</li>\n</ol>\n<blockquote>\n<p><strong>Critical Design Insight:</strong> Both algorithms achieve safety (never elect multiple leaders) through different mechanisms - bully uses competitive elimination while ring uses token serialization. However, both rely on deterministic tie-breaking (higher NodeID wins) to ensure consistent outcomes.</p>\n</blockquote>\n<h3 id=\"leader-responsibilities\">Leader Responsibilities</h3>\n<p>Once elected, the leader assumes specific operational responsibilities that extend beyond the election process itself. These responsibilities define what leadership actually means in practical terms and determine the value that leader election provides to the overall distributed system. Understanding leader duties is crucial because election algorithm choice often depends on how well it supports these ongoing leadership functions.</p>\n<p>The leader&#39;s role transforms from a participant in distributed coordination to the central coordinator itself. This transition requires careful state management, failure monitoring, and graceful handling of the inevitable leadership transitions that occur due to failures, network issues, or administrative actions.</p>\n<h4 id=\"heartbeat-and-liveness-maintenance\">Heartbeat and Liveness Maintenance</h4>\n<p>The leader&#39;s primary responsibility is proving its continued availability and operational capacity to the rest of the cluster. This heartbeat mechanism serves dual purposes: preventing unnecessary elections due to temporary communication delays, and enabling fast failure detection when the leader actually fails.</p>\n<p><strong>Leader Heartbeat Protocol:</strong></p>\n<ol>\n<li><strong>Periodic Transmission</strong>: Leader calls <code>FailureDetector.StartHeartbeats()</code> to begin sending <code>HeartbeatMessage</code> broadcasts every configured interval (typically 1-2 seconds)  </li>\n<li><strong>Cluster-wide Distribution</strong>: Each heartbeat uses <code>Transport.BroadcastMessage()</code> to reach all active cluster members, including recently joined nodes discovered through membership updates</li>\n<li><strong>Term and Timestamp Inclusion</strong>: Heartbeats contain the current leadership term and precise timestamp, allowing followers to detect stale messages and verify leadership legitimacy</li>\n<li><strong>Response Monitoring</strong>: While heartbeats are typically one-way messages, the leader monitors cluster responses and election messages to detect challenges to its authority</li>\n<li><strong>Graceful Degradation</strong>: If the leader detects its own network isolation (inability to reach majority of cluster), it voluntarily steps down to prevent split-brain scenarios</li>\n</ol>\n<p>The heartbeat interval creates a fundamental trade-off between network overhead and failure detection speed. More frequent heartbeats enable faster failure detection but consume more bandwidth and processing resources. Most systems use adaptive intervals that increase during stable periods and decrease during cluster instability.</p>\n<p><strong>Heartbeat Timing Strategy:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Cluster State</th>\n<th>Heartbeat Interval</th>\n<th>Rationale</th>\n<th>Detection Time</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Stable Operation</td>\n<td>2-3 seconds</td>\n<td>Minimize network overhead</td>\n<td>6-9 seconds</td>\n</tr>\n<tr>\n<td>Recent Election</td>\n<td>0.5-1 seconds</td>\n<td>Establish leadership quickly</td>\n<td>1.5-3 seconds</td>\n</tr>\n<tr>\n<td>Network Issues</td>\n<td>1-1.5 seconds</td>\n<td>Balance detection vs storms</td>\n<td>3-4.5 seconds</td>\n</tr>\n<tr>\n<td>High Load</td>\n<td>3-5 seconds</td>\n<td>Reduce system overhead</td>\n<td>9-15 seconds</td>\n</tr>\n</tbody></table>\n<h4 id=\"membership-management-and-discovery\">Membership Management and Discovery</h4>\n<p>Leaders often serve as the authoritative source of cluster membership information, tracking which nodes are active, handling join/leave operations, and coordinating membership changes across the distributed system. This responsibility requires careful synchronization to prevent split-brain scenarios and ensure consistent membership views.</p>\n<p><strong>Cluster Membership Coordination:</strong></p>\n<ol>\n<li><strong>Join Request Processing</strong>: When new nodes attempt to join, they typically contact the current leader first, which validates the request and updates the authoritative membership list</li>\n<li><strong>Membership Propagation</strong>: Leader broadcasts membership changes to all existing cluster members using specialized messages or piggybacked on regular heartbeats  </li>\n<li><strong>Leave Coordination</strong>: For graceful node departures, the leader processes explicit leave requests and removes the node from active membership before notifying other cluster members</li>\n<li><strong>Failure-based Removal</strong>: When the leader detects node failures through its own failure detection mechanisms, it removes failed nodes from membership and propagates the updates</li>\n<li><strong>Split-brain Prevention</strong>: Before making membership changes, the leader verifies it can reach a majority of the last known cluster to ensure it hasn&#39;t been network-partitioned</li>\n</ol>\n<p>The membership management creates interesting bootstrapping challenges - new nodes need to contact the leader to join, but they need cluster membership information to find the leader. This typically requires either static configuration of seed nodes or multicast-based leader discovery protocols.</p>\n<h4 id=\"application-specific-coordination\">Application-Specific Coordination</h4>\n<p>Beyond the basic election infrastructure, leaders typically coordinate application-specific distributed operations such as distributed transactions, resource allocation, task scheduling, or data partitioning. These responsibilities depend entirely on the specific distributed system being built, but they share common patterns that influence election algorithm choice.</p>\n<p><strong>Common Leadership Coordination Patterns:</strong></p>\n<ol>\n<li><strong>Centralized Decision Making</strong>: Leader makes global decisions (like resource allocation or task assignment) and propagates the results to followers, providing strong consistency at the cost of leader bottlenecks</li>\n<li><strong>Distributed Coordination</strong>: Leader orchestrates multi-node protocols (like two-phase commit) by serving as the coordinator/initiator while actual work occurs across multiple nodes  </li>\n<li><strong>Conflict Resolution</strong>: Leader resolves conflicts that arise from concurrent operations across the distributed system, such as conflicting resource requests or overlapping task assignments</li>\n<li><strong>State Synchronization</strong>: Leader maintains authoritative versions of critical shared state and ensures followers remain synchronized through replication or periodic updates</li>\n<li><strong>External Interface</strong>: Leader serves as the single point of contact for external clients or systems, providing a consistent interface despite internal cluster changes</li>\n</ol>\n<p><strong>Leadership Transition Considerations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Coordination Type</th>\n<th>State Transfer Needs</th>\n<th>Transition Complexity</th>\n<th>Recovery Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Stateless Coordination</td>\n<td>Minimal - just current term</td>\n<td>Low - new leader starts fresh</td>\n<td>Fast - immediate availability</td>\n</tr>\n<tr>\n<td>In-memory State</td>\n<td>Full state snapshot</td>\n<td>Medium - requires state sync</td>\n<td>Medium - must rebuild state</td>\n</tr>\n<tr>\n<td>Persistent Coordination</td>\n<td>Transaction logs + checkpoints</td>\n<td>High - complex recovery</td>\n<td>Slow - must replay operations</td>\n</tr>\n<tr>\n<td>External Contracts</td>\n<td>Client connection migration</td>\n<td>Very High - external coordination</td>\n<td>Variable - depends on clients</td>\n</tr>\n</tbody></table>\n<h4 id=\"graceful-leadership-transitions\">Graceful Leadership Transitions</h4>\n<p>Perhaps the most critical leadership responsibility is handling the inevitable end of leadership gracefully. Leaders fail, get partitioned, or need to step down for administrative reasons. How well they handle these transitions determines the overall availability and consistency of the distributed system.</p>\n<p><strong>Voluntary Step-down Process:</strong></p>\n<ol>\n<li><strong>Pre-transition Preparation</strong>: Leader completes any in-flight operations, flushes pending state changes, and ensures cluster is in a consistent state before beginning transition</li>\n<li><strong>Successor Coordination</strong>: If possible, leader coordinates with a preferred successor (often the highest-ID remaining node) to transfer critical state and responsibilities  </li>\n<li><strong>Graceful Heartbeat Cessation</strong>: Leader stops sending heartbeats and may broadcast an explicit step-down message to trigger immediate new elections rather than waiting for timeout</li>\n<li><strong>State Transfer</strong>: Leader remains available briefly to answer queries and transfer volatile state to the successor, ensuring continuity of critical operations</li>\n<li><strong>Final Transition</strong>: Leader transitions to <code>StateFollower</code> and begins participating in the new election as a regular cluster member</li>\n</ol>\n<p><strong>Failure-based Transition Handling:</strong></p>\n<p>When leaders fail ungracefully, the transition responsibility shifts to the followers and the new leader. The election algorithms handle leader selection, but application-specific state recovery often requires additional mechanisms:</p>\n<ol>\n<li><strong>State Recovery</strong>: New leader must reconstruct any volatile state the previous leader maintained, either from persistent storage, follower replicas, or by rebuilding from first principles</li>\n<li><strong>Operation Continuity</strong>: New leader determines which operations were in-progress when the previous leader failed and decides whether to complete, retry, or abort them</li>\n<li><strong>Client Notification</strong>: External clients must be notified of leadership changes and potentially redirected to the new leader endpoint</li>\n<li><strong>Consistency Verification</strong>: New leader validates that cluster state is consistent and initiates any necessary repair operations to resolve conflicts or missing data</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Leadership Handoff Protocol</strong>  </p>\n<ul>\n<li><strong>Context</strong>: Leaders must transfer responsibilities during both planned and unplanned transitions while maintaining system availability</li>\n<li><strong>Options Considered</strong>: Immediate cutoff, overlapping leadership period, state transfer protocol</li>\n<li><strong>Decision</strong>: Brief overlapping period where old leader remains available for queries while new leader assumes active duties  </li>\n<li><strong>Rationale</strong>: Enables state transfer while preventing dual leadership conflicts through role separation (read-only old leader, active new leader)</li>\n<li><strong>Consequences</strong>: Slightly more complex transition logic but dramatically improves continuity and reduces state loss</li>\n</ul>\n</blockquote>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>Understanding system interactions reveals several critical pitfalls that can undermine the entire leader election system, even when individual components work correctly. These interaction-level failures are often the most difficult to debug because they emerge from timing dependencies and distributed state inconsistencies rather than simple coding errors.</p>\n<p>⚠️ <strong>Pitfall: Election Storm Cascades</strong><br>Multiple nodes detect failure simultaneously and initiate overlapping elections, creating a cascade where each election interferes with others, preventing convergence. This happens when failure detection timeouts are too aggressive or when network partitions heal suddenly. <strong>Fix:</strong> Implement randomized election delays based on NodeID and use exponential backoff for repeated election failures. Monitor election frequency and tune timeout parameters based on actual network conditions.</p>\n<p>⚠️ <strong>Pitfall: Split-brain During Partition Healing</strong><br>When network partitions heal, both sides may have elected leaders and continue operating independently, leading to conflicting decisions and data inconsistency. <strong>Why it&#39;s wrong:</strong> Multiple leaders can make conflicting decisions about resource allocation, task assignment, or data modifications. <strong>Fix:</strong> Use term numbers for conflict resolution - higher terms always win. Implement quorum requirements so partitioned groups cannot elect leaders without majority membership.</p>\n<p>⚠️ <strong>Pitfall: Leader Election Success but No Heartbeats</strong><br>Election completes successfully and new leader is chosen, but leader fails to start heartbeat transmission due to configuration errors, resource exhaustion, or implementation bugs. Followers detect this as another leader failure and initiate new elections immediately. <strong>Fix:</strong> Verify heartbeat transmission is working before declaring election success. Add health checks that verify leader can actually perform its duties, not just win elections.</p>\n<p>⚠️ <strong>Pitfall: Message Ordering Violations</strong><br>Election messages arrive out of order due to network delays, causing nodes to process CoordinatorMessage before ElectionMessage, leading to inconsistent election state and potential dual leadership claims. <strong>Fix:</strong> Include sequence numbers or timestamps in all election messages. Implement message buffering and ordering logic to process messages in logical order rather than arrival order.</p>\n<p>⚠️ <strong>Pitfall: Incomplete State Transfer During Leadership Change</strong><br>New leader begins operation before fully receiving state from previous leader, making decisions based on incomplete information and potentially conflicting with the previous leader&#39;s final actions. <strong>Fix:</strong> Implement atomic state transfer protocols with confirmation mechanisms. Use versioned state so new leader can detect incomplete transfers and request missing information.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The system interactions layer sits above individual components but below application logic, orchestrating the complete election protocols from trigger events through leader establishment. This guidance provides the coordination infrastructure that sequences component operations into working distributed protocols.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Event Coordination</td>\n<td>Go channels with select statements</td>\n<td>Event bus with typed message routing</td>\n</tr>\n<tr>\n<td>State Machine</td>\n<td>Simple enum with switch/case</td>\n<td>Formal state machine library (fsm)</td>\n</tr>\n<tr>\n<td>Message Sequencing</td>\n<td>In-memory queues with goroutines</td>\n<td>Persistent message queue (NATS, Redis)</td>\n</tr>\n<tr>\n<td>Election Orchestration</td>\n<td>Direct method calls with timeouts</td>\n<td>Workflow engine (Temporal, Cadence)</td>\n</tr>\n<tr>\n<td>Timing Control</td>\n<td>time.Timer with context cancellation</td>\n<td>Configurable timer wheels</td>\n</tr>\n<tr>\n<td>Concurrency Control</td>\n<td>sync.RWMutex for state protection</td>\n<td>Software transactional memory</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/coordinator/\n  coordinator.go              ← Main election coordinator\n  election_triggers.go        ← Failure detection and trigger logic  \n  message_sequencer.go        ← Message ordering and processing\n  state_machine.go           ← Node state transitions\n  leadership_manager.go       ← Leader duties and responsibilities\n  coordinator_test.go        ← Integration tests for full flows\n  \ninternal/scenarios/\n  startup_test.go            ← Bootstrap election scenarios\n  failure_test.go            ← Leader failure and recovery tests  \n  partition_test.go          ← Network partition simulation\n  concurrent_test.go         ← Multiple simultaneous elections</code></pre></div>\n\n<h4 id=\"election-coordinator-infrastructure\">Election Coordinator Infrastructure</h4>\n<p>This component orchestrates the complete election process from trigger through leader establishment:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ElectionCoordinator manages the complete leader election lifecycle,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// coordinating between failure detection, algorithm execution, and leadership duties.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ElectionCoordinator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID       </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentState </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transport    </span><span style=\"color:#B392F0\">Transport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    membership   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Algorithm implementations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bullyElection </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ringElection  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RingElection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failureDetector </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FailureDetector</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stateMachine    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionStateMachine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    messageSequencer </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageSequencer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config </span><span style=\"color:#B392F0\">ElectionConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Channels for coordination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    triggerChan   </span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> ElectionTrigger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    messageChan   </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stateChan     </span><span style=\"color:#F97583\">chan</span><span style=\"color:#B392F0\"> StateTransition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    shutdownChan  </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ElectionTrigger represents events that can initiate leader elections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ElectionTrigger</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type      </span><span style=\"color:#B392F0\">TriggerType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NodeID    </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#6A737D\">      // Failed leader or trigger source</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Context   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#6A737D\">// Additional trigger context</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TriggerLeaderFailure</span><span style=\"color:#B392F0\"> TriggerType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TriggerStartup</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TriggerPartitionHealing</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TriggerManualElection</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TriggerTermConflict</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartElectionCoordinator initializes and starts the complete election system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ec </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionCoordinator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartElectionCoordinator</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize all component connections (transport, membership, failure detector)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Start background goroutines for trigger processing and message handling  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Begin failure detection and heartbeat monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check for existing cluster and determine initial state (bootstrap vs join)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Start main coordination loop that processes triggers and coordinates elections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use select statement to handle multiple channel inputs simultaneously</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ProcessElectionTrigger handles different trigger scenarios and initiates appropriate elections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ec </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionCoordinator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ProcessElectionTrigger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">trigger</span><span style=\"color:#B392F0\"> ElectionTrigger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate trigger is appropriate for current node state (followers can initiate, leaders cannot)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Choose election algorithm based on configuration and cluster conditions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Update local state to candidate and increment term number  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Call appropriate algorithm's StartElection() method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Start election timeout to handle failures and declare victory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Different trigger types may require different pre-election setup</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"message-sequence-controller\">Message Sequence Controller</h4>\n<p>Coordinates the temporal aspects of election protocols:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// MessageSequencer ensures proper ordering and timing of election messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MessageSequencer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID        </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transport     </span><span style=\"color:#B392F0\">Transport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Message ordering</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    incomingQueue </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    processingQueue </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sequenceNumbers </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Timing control</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timeouts      </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Timer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    intervals     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Ticker</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SequenceElectionMessages coordinates the complete message flow for an election</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ms </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageSequencer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SequenceElectionMessages</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">algorithm</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">electionID</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create sequence tracking for this election ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set up appropriate timeouts based on algorithm type (bully vs ring)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Begin message processing loop that handles ordering and timing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Coordinate with election algorithm to send messages at proper times  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Handle timeout events and trigger appropriate responses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Bully and ring algorithms have very different timing requirements</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ProcessIncomingMessage handles message ordering and delivers to appropriate handlers  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ms </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageSequencer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ProcessIncomingMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check message sequence number against expected order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Buffer out-of-order messages for later processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Deliver in-order messages to appropriate election algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update sequence tracking and release any buffered messages that are now in order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Handle duplicate messages and expired/stale messages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use msg.Timestamp and msg.Term to detect stale messages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"leadership-manager\">Leadership Manager</h4>\n<p>Handles leader responsibilities and transitions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// LeadershipManager implements the ongoing duties of elected leaders</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LeadershipManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID      </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transport   </span><span style=\"color:#B392F0\">Transport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    membership  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Leader duties</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heartbeatTicker </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Ticker</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    membershipVersion </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // State management  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    isLeader     </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentTerm  </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leaderSince  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Application coordination (extensible)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    coordinationHandlers </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">CoordinationHandler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AssumeLeadership transitions this node to leader and begins leader duties</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">lm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LeadershipManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AssumeLeadership</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">term</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">electionID</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Verify this node should actually become leader (election was successful)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update local state to leader and record leadership term</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Broadcast initial CoordinatorMessage to establish leadership</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Start heartbeat transmission to maintain leadership  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Initialize any application-specific coordination duties</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Leadership transition should be atomic - either fully successful or fully rolled back</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StepDown gracefully transitions away from leadership</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">lm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LeadershipManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StepDown</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Stop all leader duties (heartbeats, coordination tasks)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Complete or abort any in-flight operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Transfer critical state to successor if known</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Broadcast step-down notification to trigger new elections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Transition to follower state and clear leadership state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Graceful step-down should prevent unnecessary election delays</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SendHeartbeat broadcasts leader aliveness to all cluster members</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">lm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LeadershipManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SendHeartbeat</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create HeartbeatMessage with current term and timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Include current membership version for follower synchronization</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Broadcast heartbeat to all active cluster members  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Monitor for election challenges or network partition indicators</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Handle heartbeat failures by stepping down if majority unreachable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Heartbeat failures may indicate this node is network partitioned</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"integration-testing-framework\">Integration Testing Framework</h4>\n<p>Complete election scenarios require multi-node testing infrastructure:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ElectionScenarioTest provides infrastructure for testing complete election flows</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ElectionScenarioTest</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodes      </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionCoordinator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transport  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestTransport</span><span style=\"color:#6A737D\">  // Simulated network with failure injection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timeline   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestTimeline</span><span style=\"color:#6A737D\">  // Controlled time progression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Scenario control</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    partitions </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#6A737D\">  // Network partition simulation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failures   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#6A737D\"> // Scheduled node failures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Verification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    electionHistory []</span><span style=\"color:#B392F0\">ElectionEvent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leaderHistory   []</span><span style=\"color:#B392F0\">LeadershipEvent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    messageLog      []</span><span style=\"color:#B392F0\">MessageEvent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TestBootstrapElection verifies startup election scenarios</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestBootstrapElection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create cluster of 5 nodes in shutdown state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Start nodes with randomized delays to simulate real startup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify exactly one leader emerges within expected timeframe  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Confirm all nodes recognize the same leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Validate heartbeat transmission begins and is received by all nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected: Single leader elected within 10 seconds, all nodes converged</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TestConcurrentFailureDetection verifies multiple simultaneous election triggers  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestConcurrentFailureDetection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Establish stable cluster with known leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Simulate leader failure that's detected simultaneously by multiple followers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify election algorithms resolve concurrent elections correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Confirm exactly one new leader emerges despite multiple initiators</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Validate cluster returns to stable state with proper heartbeat resumption</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected: New leader elected within 15 seconds despite concurrent elections</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TestPartitionHealing verifies split-brain prevention during network recovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestPartitionHealing</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create network partition splitting cluster into two groups  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Allow each partition to elect separate leaders</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Simulate partition healing by restoring network connectivity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify conflict resolution produces single authoritative leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Confirm losing partition's leader steps down gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Expected: Higher-term leader wins, lower-term leader steps down immediately</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Milestone Integration Verification:</strong></p>\n<ul>\n<li><strong>Command</strong>: <code>go test ./internal/coordinator/... -v -timeout=60s</code></li>\n<li><strong>Expected Output</strong>: All election scenario tests pass, showing bootstrap elections complete in &lt;10 seconds, concurrent elections resolve to single leader, partition healing prevents split-brain</li>\n<li><strong>Manual Verification</strong>: Start 3-node cluster, kill leader, verify new leader elected within timeout period and begins heartbeats</li>\n<li><strong>Failure Signs</strong>: Multiple concurrent leaders, election timeouts, nodes stuck in candidate state, missing heartbeats after election</li>\n</ul>\n<p><strong>Performance Validation:</strong></p>\n<ul>\n<li><strong>Bootstrap Election</strong>: 5-node cluster should elect leader within 10 seconds of startup</li>\n<li><strong>Leader Failure Recovery</strong>: New leader should emerge within 15 seconds of failure detection  </li>\n<li><strong>Message Overhead</strong>: Election should require &lt;20 messages total for 5-node bully election</li>\n<li><strong>Heartbeat Stability</strong>: Leader heartbeats should maintain &lt;1 second jitter in stable conditions</li>\n</ul>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - comprehensive failure scenarios, detection strategies, and recovery mechanisms that apply across node communication (Milestone 1), bully election (Milestone 2), and ring election (Milestone 3)</p>\n</blockquote>\n<p>Distributed leader election systems operate in an inherently unreliable environment where nodes crash, networks partition, and messages get lost or delayed. The robustness of a leader election implementation depends entirely on how well it handles these failure scenarios. Unlike centralized systems where failures are typically binary (the system works or it doesn&#39;t), distributed systems must continue operating correctly even when some components fail, while preventing catastrophic scenarios like multiple simultaneous leaders.</p>\n<p>The challenge lies in the <strong>fundamental impossibility of distinguishing between a slow node and a failed node</strong> in asynchronous distributed systems. When Node A doesn&#39;t respond to Node B&#39;s message, it could mean Node A crashed, the network dropped the message, Node A is temporarily overloaded, or the network has partitioned the cluster. Each scenario requires different handling strategies, yet they&#39;re often indistinguishable from the perspective of the detecting node.</p>\n<p>This section provides a comprehensive taxonomy of failure modes, detection strategies, and recovery mechanisms that ensure the leader election system maintains correctness guarantees even under adverse conditions. We&#39;ll explore how different failure types impact election algorithms, examine the dreaded split-brain scenario in detail, and establish robust recovery mechanisms that restore system health automatically.</p>\n<h3 id=\"failure-taxonomy\">Failure Taxonomy</h3>\n<p>Understanding the different categories of failures and their specific impacts on leader election is crucial for building robust handling mechanisms. Each failure type has distinct characteristics, detection methods, and recovery strategies.</p>\n<p><img src=\"/api/project/leader-election/architecture-doc/asset?path=diagrams%2Ffailure-detection-flow.svg\" alt=\"Failure Detection and Recovery Flow\"></p>\n<h4 id=\"node-failures\">Node Failures</h4>\n<p><strong>Crash Failures</strong> represent the most straightforward failure mode where a node stops executing completely. The node halts all processing, stops sending messages, and becomes completely unresponsive. From the cluster&#39;s perspective, the node simply vanishes without any notification.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Aspect</th>\n<th>Description</th>\n<th>Impact on Elections</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Detection Method</td>\n<td>Heartbeat timeouts, unresponsive to messages</td>\n<td>Reliable detection after timeout period</td>\n</tr>\n<tr>\n<td>Recovery Required</td>\n<td>Remove from cluster membership, trigger election if leader</td>\n<td>Clean - no partial state issues</td>\n</tr>\n<tr>\n<td>Bully Algorithm Impact</td>\n<td>Higher-ID crashed nodes won&#39;t respond with <code>MsgOK</code></td>\n<td>Lower-ID nodes can safely claim leadership</td>\n</tr>\n<tr>\n<td>Ring Algorithm Impact</td>\n<td>Token forwarding fails at crashed node position</td>\n<td>Requires ring repair and token re-routing</td>\n</tr>\n<tr>\n<td>False Positive Risk</td>\n<td>Low - sustained unresponsiveness indicates real failure</td>\n<td>Timeout tuning prevents premature detection</td>\n</tr>\n</tbody></table>\n<p><strong>Byzantine Failures</strong> involve nodes that behave arbitrarily - they might send contradictory messages, claim to be different nodes, or actively try to disrupt elections. While our implementation doesn&#39;t include full Byzantine fault tolerance, we must handle basic malicious behavior.</p>\n<table>\n<thead>\n<tr>\n<th>Byzantine Behavior</th>\n<th>Detection Strategy</th>\n<th>Mitigation Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Duplicate Node IDs</td>\n<td>Track unique node addresses per ID</td>\n<td>Reject messages from duplicate IDs</td>\n</tr>\n<tr>\n<td>Invalid Message Content</td>\n<td>Validate message structure and constraints</td>\n<td>Drop malformed messages, don&#39;t respond</td>\n</tr>\n<tr>\n<td>Conflicting Leadership Claims</td>\n<td>Track term numbers and election IDs</td>\n<td>Accept only higher term numbers</td>\n</tr>\n<tr>\n<td>Message Replay Attacks</td>\n<td>Include timestamps and sequence numbers</td>\n<td>Reject old or duplicate messages</td>\n</tr>\n<tr>\n<td>Election Disruption</td>\n<td>Monitor election completion rates</td>\n<td>Rate limit election messages per node</td>\n</tr>\n</tbody></table>\n<p><strong>Performance Degradation Failures</strong> occur when nodes become extremely slow but don&#39;t crash completely. These are particularly dangerous because the node appears alive but can&#39;t participate effectively in time-sensitive election protocols.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: Performance degradation is often harder to handle than complete crashes because the node appears partially functional, leading to inconsistent behavior across different election phases.</p>\n</blockquote>\n<h4 id=\"network-failures\">Network Failures</h4>\n<p><strong>Message Loss</strong> happens when individual messages fail to reach their destination due to network congestion, hardware failures, or routing issues. Unlike node crashes, message loss is often sporadic and affects only some communications.</p>\n<table>\n<thead>\n<tr>\n<th>Message Type</th>\n<th>Loss Impact</th>\n<th>Recovery Mechanism</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>MsgElection</code></td>\n<td>Candidate may timeout without responses</td>\n<td>Retry election after timeout</td>\n</tr>\n<tr>\n<td><code>MsgOK</code></td>\n<td>Candidate may falsely claim leadership</td>\n<td>Higher-ID nodes will send <code>MsgCoordinator</code> to correct</td>\n</tr>\n<tr>\n<td><code>MsgCoordinator</code></td>\n<td>Nodes may not recognize new leader</td>\n<td>Periodic heartbeat will establish leadership</td>\n</tr>\n<tr>\n<td><code>MsgHeartbeat</code></td>\n<td>False failure detection of leader</td>\n<td>Multiple missed heartbeats before declaring failure</td>\n</tr>\n<tr>\n<td><code>MsgRingToken</code></td>\n<td>Ring election stalls at token holder</td>\n<td>Token timeout triggers new token generation</td>\n</tr>\n</tbody></table>\n<p><strong>Message Delays</strong> cause messages to arrive significantly later than expected, potentially after election timeouts have expired. This can lead to overlapping elections and temporary confusion about cluster leadership.</p>\n<p><strong>Network Partitions</strong> split the cluster into isolated groups that cannot communicate with each other. This is the most complex failure scenario because each partition may attempt to elect its own leader, leading to potential split-brain situations.</p>\n<table>\n<thead>\n<tr>\n<th>Partition Scenario</th>\n<th>Cluster View</th>\n<th>Election Behavior</th>\n<th>Resolution Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Clean Split (50/50)</td>\n<td>Two equal partitions</td>\n<td>Both attempt leadership</td>\n<td>Quorum requirements prevent dual leaders</td>\n</tr>\n<tr>\n<td>Majority/Minority</td>\n<td>One large, one small partition</td>\n<td>Only majority should elect leader</td>\n<td>Minority partition remains leaderless</td>\n</tr>\n<tr>\n<td>Multiple Fragments</td>\n<td>Several small partitions</td>\n<td>No partition should elect leader</td>\n<td>Wait for partition healing</td>\n</tr>\n<tr>\n<td>Temporary Isolation</td>\n<td>Node briefly disconnected</td>\n<td>Node may attempt unnecessary election</td>\n<td>Rejoin existing leadership</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Principle</strong>: In network partition scenarios, it&#39;s better to have no leader than multiple leaders. A leaderless cluster can resume operations once connectivity is restored, but resolving split-brain requires complex state reconciliation.</p>\n</blockquote>\n<h4 id=\"timing-failures\">Timing Failures</h4>\n<p><strong>Clock Skew</strong> occurs when different nodes have significantly different system times. While our election algorithms don&#39;t rely heavily on synchronized time, clock differences can cause issues with timeout management and message ordering.</p>\n<p><strong>Timeout Failures</strong> happen when election timeouts are either too short (causing premature failure detection) or too long (delaying necessary elections). Finding the right balance requires understanding network characteristics and node performance.</p>\n<table>\n<thead>\n<tr>\n<th>Timeout Type</th>\n<th>Too Short Impact</th>\n<th>Too Long Impact</th>\n<th>Tuning Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Election Timeout</td>\n<td>Frequent unnecessary elections</td>\n<td>Slow failure recovery</td>\n<td>3-5x typical message round-trip time</td>\n</tr>\n<tr>\n<td>Heartbeat Interval</td>\n<td>High network overhead</td>\n<td>Delayed failure detection</td>\n<td>Balance between overhead and responsiveness</td>\n</tr>\n<tr>\n<td>Ring Token Timeout</td>\n<td>Premature token regeneration</td>\n<td>Stalled elections with failed nodes</td>\n<td>2x ring traversal time estimate</td>\n</tr>\n<tr>\n<td>Membership Update</td>\n<td>Stale member views</td>\n<td>Slow cluster adaptation</td>\n<td>Based on typical join/leave frequency</td>\n</tr>\n</tbody></table>\n<h4 id=\"state-corruption-failures\">State Corruption Failures</h4>\n<p><strong>Inconsistent Election State</strong> can occur when nodes have different views of the current election term, active election ID, or current leader. This often results from message loss during critical election phases.</p>\n<p><strong>Term Number Conflicts</strong> happen when nodes disagree about the current election term, potentially accepting leadership claims from outdated elections or rejecting valid new elections.</p>\n<table>\n<thead>\n<tr>\n<th>State Inconsistency</th>\n<th>Symptoms</th>\n<th>Detection Method</th>\n<th>Recovery Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Stale Leader View</td>\n<td>Node sends messages to wrong leader</td>\n<td>Heartbeat responses include correct leader</td>\n<td>Update local leadership view</td>\n</tr>\n<tr>\n<td>Term Regression</td>\n<td>Node accepts lower-term leadership</td>\n<td>Compare term numbers in all messages</td>\n<td>Reject lower terms, update to higher</td>\n</tr>\n<tr>\n<td>Duplicate Election IDs</td>\n<td>Multiple elections with same ID active</td>\n<td>Track election ID uniqueness</td>\n<td>Use timestamp-based election ID generation</td>\n</tr>\n<tr>\n<td>Membership Drift</td>\n<td>Nodes have different member lists</td>\n<td>Compare membership in heartbeat messages</td>\n<td>Periodic membership synchronization</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Architecture Decision: Term-Based Ordering</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to order elections and detect stale leadership claims</li>\n<li><strong>Options Considered</strong>: Timestamp-based ordering, vector clocks, monotonic term counters</li>\n<li><strong>Decision</strong>: Monotonic term counters incremented with each election</li>\n<li><strong>Rationale</strong>: Simple to implement, doesn&#39;t require clock synchronization, provides total ordering</li>\n<li><strong>Consequences</strong>: Enables detection of stale messages and conflicting leadership claims</li>\n</ul>\n</blockquote>\n<h3 id=\"split-brain-scenarios\">Split-Brain Scenarios</h3>\n<p>Split-brain represents the most dangerous failure scenario in leader election systems. When network partitions divide the cluster, each partition may independently elect a leader, resulting in multiple nodes simultaneously believing they are the cluster coordinator. This violates the fundamental safety property of leader election and can lead to data corruption, conflicting decisions, and system inconsistency.</p>\n<p><img src=\"/api/project/leader-election/architecture-doc/asset?path=diagrams%2Fnetwork-partition-scenario.svg\" alt=\"Split-Brain Prevention\"></p>\n<h4 id=\"understanding-split-brain-formation\">Understanding Split-Brain Formation</h4>\n<p>Split-brain scenarios emerge through a predictable sequence of events. Initially, a healthy cluster operates with a single elected leader coordinating all operations. When a network partition occurs, the cluster splits into isolated groups that cannot communicate with each other. Each partition, unable to contact the original leader (who may be in a different partition), assumes leadership failure and initiates new elections.</p>\n<p><strong>Classic Split-Brain Sequence:</strong></p>\n<ol>\n<li><strong>Healthy State</strong>: Five-node cluster (IDs 1, 3, 5, 7, 9) with Node 9 as elected leader</li>\n<li><strong>Partition Formation</strong>: Network failure splits cluster into Partition A (nodes 1, 3, 5) and Partition B (nodes 7, 9)</li>\n<li><strong>Leadership Ambiguity</strong>: Partition A loses contact with leader Node 9, assumes it failed</li>\n<li><strong>Concurrent Elections</strong>: Partition A elects Node 5 as leader, while Node 9 remains leader in Partition B  </li>\n<li><strong>Split-Brain State</strong>: Two nodes (5 and 9) simultaneously believe they are cluster leaders</li>\n<li><strong>Conflicting Operations</strong>: Both leaders make independent decisions, potentially causing data inconsistency</li>\n</ol>\n<h4 id=\"split-brain-prevention-mechanisms\">Split-Brain Prevention Mechanisms</h4>\n<p><strong>Quorum-Based Leadership</strong> requires a leader to maintain contact with a majority of the original cluster members to retain leadership authority. This prevents minority partitions from electing leaders while allowing majority partitions to continue operations.</p>\n<table>\n<thead>\n<tr>\n<th>Cluster Size</th>\n<th>Quorum Size</th>\n<th>Partition Tolerance</th>\n<th>Maximum Failures</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>3 nodes</td>\n<td>2 nodes</td>\n<td>Can lose 1 node</td>\n<td>1 node failure</td>\n</tr>\n<tr>\n<td>5 nodes</td>\n<td>3 nodes</td>\n<td>Can lose 2 nodes</td>\n<td>2 node failures</td>\n</tr>\n<tr>\n<td>7 nodes</td>\n<td>4 nodes</td>\n<td>Can lose 3 nodes</td>\n<td>3 node failures</td>\n</tr>\n<tr>\n<td>9 nodes</td>\n<td>5 nodes</td>\n<td>Can lose 4 nodes</td>\n<td>4 node failures</td>\n</tr>\n</tbody></table>\n<p>The quorum mechanism works by requiring any node claiming leadership to demonstrate communication with at least <code>(cluster_size / 2) + 1</code> nodes. During elections, candidates must receive acknowledgments from a quorum before claiming victory. Similarly, existing leaders must maintain heartbeat communication with a quorum to retain authority.</p>\n<p><strong>Partition Size Detection</strong> allows each partition to assess its own size relative to the original cluster configuration. Partitions that represent less than a majority of the original cluster voluntarily refrain from electing leaders.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Partition Leadership Decision Algorithm:\n1. Count nodes reachable in current partition\n2. Compare to original cluster size from configuration  \n3. If partition_size &gt; (original_cluster_size / 2):\n   - Proceed with leader election\n4. If partition_size &lt;= (original_cluster_size / 2):\n   - Enter read-only mode, do not elect leader\n   - Continue attempting to contact other partitions</code></pre></div>\n\n<p><strong>Leader Validation During Elections</strong> requires election winners to validate their leadership with a quorum before assuming coordinator responsibilities. This prevents leaders elected in minority partitions from making cluster decisions.</p>\n<table>\n<thead>\n<tr>\n<th>Election Phase</th>\n<th>Validation Requirement</th>\n<th>Failure Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Vote Collection</td>\n<td>Receive responses from quorum of nodes</td>\n<td>Restart election if insufficient responses</td>\n</tr>\n<tr>\n<td>Leadership Claim</td>\n<td>Confirm leadership with quorum via heartbeat</td>\n<td>Step down if quorum not maintained</td>\n</tr>\n<tr>\n<td>Operation Execution</td>\n<td>Validate quorum before each major decision</td>\n<td>Delay operations until quorum restored</td>\n</tr>\n<tr>\n<td>Term Advancement</td>\n<td>Only advance term if quorum agrees</td>\n<td>Prevent term conflicts across partitions</td>\n</tr>\n</tbody></table>\n<h4 id=\"split-brain-detection-strategies\">Split-Brain Detection Strategies</h4>\n<p><strong>Heartbeat-Based Detection</strong> monitors whether the current leader can maintain communication with a quorum of cluster members. Leaders that lose quorum contact automatically step down to prevent operating in a minority partition.</p>\n<p><strong>Cross-Partition Communication Attempts</strong> involve nodes periodically trying to contact members from the original cluster configuration, even if they&#39;re not currently reachable. When communication is restored, nodes can detect conflicting leadership claims.</p>\n<p><strong>Term Number Monitoring</strong> tracks election term numbers across all received messages. When a node receives a message with a higher term than its local view, it indicates that another partition may have conducted elections.</p>\n<table>\n<thead>\n<tr>\n<th>Detection Signal</th>\n<th>Interpretation</th>\n<th>Required Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Heartbeat to non-quorum</td>\n<td>Leader in minority partition</td>\n<td>Step down from leadership</td>\n</tr>\n<tr>\n<td>Higher term in message</td>\n<td>Another partition elected leader</td>\n<td>Update local term, accept new leadership</td>\n</tr>\n<tr>\n<td>Conflicting coordinator claims</td>\n<td>Multiple active leaders detected</td>\n<td>Initiate conflict resolution protocol</td>\n</tr>\n<tr>\n<td>Membership inconsistency</td>\n<td>Partitions have different member views</td>\n<td>Synchronize membership information</td>\n</tr>\n</tbody></table>\n<h4 id=\"conflict-resolution-protocols\">Conflict Resolution Protocols</h4>\n<p>When split-brain is detected (typically during partition healing), the system must safely resolve conflicting leadership claims and restore single-leader operation.</p>\n<p><strong>Term-Based Resolution</strong> uses election term numbers to determine which leader has authority. The leader elected in the highest-numbered term retains leadership, while others step down.</p>\n<p><strong>Node ID Tiebreaking</strong> handles cases where multiple partitions elected leaders in the same term (rare but possible during rapid partition/healing cycles). The leader with the highest node ID retains authority.</p>\n<p><strong>Graceful Step-Down Process</strong> ensures that demoted leaders safely transfer any pending operations to the winning leader rather than simply stopping.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Split-Brain Resolution Steps:\n1. Detection: Node receives coordinator message with higher/equal term from different leader\n2. Term Comparison: Compare election terms of conflicting leaders\n3. Leader Selection: Higher term wins; if equal terms, higher node ID wins  \n4. Step-Down: Losing leader(s) transition to follower state\n5. State Transfer: Losing leaders send any pending operations to winner\n6. Acknowledgment: Winning leader confirms receipt and takes full authority\n7. Broadcast: New leader announces resolution to entire cluster</code></pre></div>\n\n<blockquote>\n<p><strong>Common Pitfall</strong>: <strong>Immediate Step-Down Without State Transfer</strong></p>\n<p>When resolving split-brain, developers often implement leaders that immediately step down upon detecting a conflict, without transferring their pending state. This can lead to lost operations that were initiated during the partition.</p>\n<p><strong>Why it&#39;s wrong</strong>: Operations started by the stepping-down leader may be partially complete, and simply abandoning them can leave the system in an inconsistent state.</p>\n<p><strong>How to fix</strong>: Implement a graceful step-down process where the demoted leader sends its pending operations to the winning leader, waits for acknowledgment, and only then transitions to follower state.</p>\n</blockquote>\n<h3 id=\"failure-recovery-mechanisms\">Failure Recovery Mechanisms</h3>\n<p>Robust failure recovery ensures that the leader election system automatically detects failures, adapts to new conditions, and restores normal operation without manual intervention. Recovery mechanisms must handle not just the immediate failure, but also the cascading effects and potential race conditions that arise during the recovery process.</p>\n<h4 id=\"leader-failure-recovery\">Leader Failure Recovery</h4>\n<p><strong>Failure Detection Triggers</strong> initiate the recovery process when the current leader becomes unresponsive or unreachable. The detection mechanism must be sensitive enough to quickly identify real failures while avoiding false positives that cause unnecessary elections.</p>\n<table>\n<thead>\n<tr>\n<th>Detection Method</th>\n<th>Trigger Condition</th>\n<th>False Positive Risk</th>\n<th>Recovery Time</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Heartbeat Timeout</td>\n<td>No heartbeat for N intervals</td>\n<td>Network congestion, leader overload</td>\n<td>N * heartbeat_interval</td>\n</tr>\n<tr>\n<td>Message Unresponsiveness</td>\n<td>Leader doesn&#39;t respond to direct messages</td>\n<td>Message loss, temporary partitions</td>\n<td>Message timeout duration</td>\n</tr>\n<tr>\n<td>Membership Updates</td>\n<td>Other nodes report leader as unreachable</td>\n<td>Network asymmetry, timing issues</td>\n<td>Membership update frequency</td>\n</tr>\n<tr>\n<td>Administrative Trigger</td>\n<td>Manual failure detection command</td>\n<td>Human error, premature intervention</td>\n<td>Immediate</td>\n</tr>\n</tbody></table>\n<p>The <code>FailureDetector</code> component implements a <strong>graduated suspicion mechanism</strong> that prevents premature failure declarations. Rather than immediately declaring a leader failed after one missed heartbeat, it tracks suspicion levels and only triggers recovery after sustained evidence of failure.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Graduated Suspicion Algorithm:\n1. Initialize suspicion_level = 0 for all nodes\n2. On missed heartbeat: increment suspicion_level for leader\n3. On successful heartbeat: reset suspicion_level to 0 for leader  \n4. If suspicion_level &gt;= failure_threshold:\n   - Declare leader failed\n   - Trigger election recovery process\n5. Include suspicion levels in membership updates to other nodes</code></pre></div>\n\n<p><strong>Election Initiation Process</strong> begins once leader failure is confirmed. The process varies between bully and ring algorithms but follows similar principles of ensuring orderly recovery.</p>\n<p>For <strong>Bully Algorithm Recovery</strong>:</p>\n<ol>\n<li><strong>Failure Confirmation</strong>: Multiple nodes may simultaneously detect leader failure</li>\n<li><strong>Election Rights Assessment</strong>: Each detecting node checks if it has the right to initiate election (typically all nodes can)</li>\n<li><strong>Concurrent Election Handling</strong>: Multiple nodes may start elections simultaneously - this is acceptable in bully algorithm</li>\n<li><strong>Higher-ID Precedence</strong>: Lower-ID nodes will receive <code>MsgOK</code> responses and defer to higher-ID candidates</li>\n<li><strong>Coordinator Emergence</strong>: Highest-ID responding node becomes new leader</li>\n</ol>\n<p>For <strong>Ring Algorithm Recovery</strong>:</p>\n<ol>\n<li><strong>Token Holder Identification</strong>: Determine which node should initiate ring election (typically node detecting failure)</li>\n<li><strong>Ring Integrity Check</strong>: Verify ring topology is intact and repair if necessary</li>\n<li><strong>Token Generation</strong>: Create new election token with unique election ID</li>\n<li><strong>Token Circulation</strong>: Begin token passing around ring to collect live node IDs</li>\n<li><strong>Leader Selection</strong>: Highest ID from collected participants becomes leader</li>\n</ol>\n<h4 id=\"cascading-failure-handling\">Cascading Failure Handling</h4>\n<p><strong>Sequential Node Failures</strong> occur when multiple nodes fail in rapid succession, potentially during an ongoing election. This can cause election algorithms to fail repeatedly as candidates themselves become unavailable.</p>\n<p><strong>Cascade Detection Patterns:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Failure Pattern</th>\n<th>Recognition Signal</th>\n<th>Adaptive Response</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Rapid Sequential Failures</td>\n<td>Multiple failure notifications within short time window</td>\n<td>Extend election timeouts, reduce heartbeat frequency</td>\n</tr>\n<tr>\n<td>Election Candidate Failure</td>\n<td>Election initiator becomes unresponsive during election</td>\n<td>Other nodes restart election with updated membership</td>\n</tr>\n<tr>\n<td>Ring Break Cascade</td>\n<td>Multiple adjacent ring nodes fail</td>\n<td>Rebuild ring topology, skip failed segments</td>\n</tr>\n<tr>\n<td>Network Deterioration</td>\n<td>Increasing message loss rates across all nodes</td>\n<td>Enter conservative mode with longer timeouts</td>\n</tr>\n</tbody></table>\n<p><strong>Adaptive Timeout Management</strong> adjusts election timeouts based on observed failure patterns. During periods of instability, the system uses longer timeouts to prevent premature failure detection while maintaining safety properties.</p>\n<p>The <code>ElectionTimeoutManager</code> tracks recent failure rates and election success rates to dynamically adjust timeout values:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Adaptive Timeout Calculation:\n1. Track recent_failure_rate = failures_last_N_minutes / total_elections_last_N_minutes\n2. Track average_election_completion_time from successful elections  \n3. Calculate base_timeout = max(configured_timeout, 2 * average_completion_time)\n4. Apply failure_rate_multiplier = 1.0 + (recent_failure_rate * 2.0)\n5. Final timeout = base_timeout * failure_rate_multiplier\n6. Bound timeout between min_timeout and max_timeout limits</code></pre></div>\n\n<h4 id=\"network-partition-recovery\">Network Partition Recovery</h4>\n<p><strong>Partition Healing Detection</strong> identifies when previously isolated network segments regain connectivity. This is more complex than initial partition detection because nodes must reconcile potentially conflicting state accumulated during isolation.</p>\n<p><strong>Healing Detection Signals:</strong></p>\n<ol>\n<li><strong>Connectivity Restoration</strong>: Previously unreachable nodes start responding to heartbeats</li>\n<li><strong>Membership Expansion</strong>: Node discovery mechanisms find nodes not in current membership view  </li>\n<li><strong>Term Number Conflicts</strong>: Messages arrive with term numbers different from local view</li>\n<li><strong>Leadership Conflicts</strong>: Multiple nodes claim current leadership with different terms</li>\n</ol>\n<p><strong>State Reconciliation Process</strong> safely merges state from previously isolated partitions:</p>\n<ol>\n<li><strong>Membership Merge</strong>: Combine membership views from all healing partitions</li>\n<li><strong>Leadership Resolution</strong>: Apply split-brain resolution protocols to determine single leader</li>\n<li><strong>Term Synchronization</strong>: Update all nodes to highest observed election term  </li>\n<li><strong>Operation Reconciliation</strong>: Handle any conflicting operations initiated during partition</li>\n<li><strong>Full Cluster Election</strong>: Optionally trigger new election with complete membership</li>\n</ol>\n<p><strong>Gradual Integration Strategy</strong> avoids sudden topology changes that might destabilize the newly-healed cluster:</p>\n<table>\n<thead>\n<tr>\n<th>Integration Phase</th>\n<th>Duration</th>\n<th>Actions Taken</th>\n<th>Stability Measures</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Discovery</td>\n<td>30-60 seconds</td>\n<td>Detect returning nodes, exchange basic state</td>\n<td>Limited message broadcast</td>\n</tr>\n<tr>\n<td>Reconciliation</td>\n<td>60-120 seconds</td>\n<td>Resolve conflicts, merge membership</td>\n<td>Elevated timeouts</td>\n</tr>\n<tr>\n<td>Stabilization</td>\n<td>120-300 seconds</td>\n<td>Monitor for additional conflicts</td>\n<td>Conservative failure detection</td>\n</tr>\n<tr>\n<td>Normal Operation</td>\n<td>Ongoing</td>\n<td>Resume standard election parameters</td>\n<td>Standard timeouts restored</td>\n</tr>\n</tbody></table>\n<h4 id=\"recovery-validation-and-monitoring\">Recovery Validation and Monitoring</h4>\n<p><strong>Election Success Validation</strong> ensures that recovery operations actually restore healthy cluster state rather than just completing the election protocol.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Check</th>\n<th>Success Criteria</th>\n<th>Failure Response</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Leader Confirmation</td>\n<td>New leader sends heartbeats to all members</td>\n<td>Restart election with updated membership</td>\n</tr>\n<tr>\n<td>Membership Consensus</td>\n<td>All nodes agree on cluster membership</td>\n<td>Synchronize membership, re-validate</td>\n</tr>\n<tr>\n<td>Term Consistency</td>\n<td>All nodes have same election term number</td>\n<td>Broadcast correct term, update lagging nodes</td>\n</tr>\n<tr>\n<td>Operation Readiness</td>\n<td>Leader can coordinate basic cluster operations</td>\n<td>Investigate leader capacity, consider re-election</td>\n</tr>\n</tbody></table>\n<p><strong>Recovery Metrics Collection</strong> tracks the effectiveness of failure handling mechanisms and identifies opportunities for improvement:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Recovery Effectiveness Metrics:\n- Mean Time to Detect Failure (MTTD): Average time from actual failure to detection\n- Mean Time to Recover (MTTR): Average time from failure detection to new leader operational  \n- False Positive Rate: Percentage of failure detections that were incorrect\n- Election Success Rate: Percentage of elections that complete successfully\n- Cascading Failure Rate: Frequency of failures during recovery operations\n- Split-Brain Incidents: Count and duration of multi-leader scenarios</code></pre></div>\n\n<blockquote>\n<p><strong>Architecture Decision: Graduated Recovery Timeouts</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to balance quick failure recovery with stability during cascading failures</li>\n<li><strong>Options Considered</strong>: Fixed timeouts, exponential backoff, adaptive based on failure history</li>\n<li><strong>Decision</strong>: Adaptive timeouts based on recent failure rates and election completion times</li>\n<li><strong>Rationale</strong>: Provides quick recovery during isolated failures while preventing instability during widespread issues</li>\n<li><strong>Consequences</strong>: Requires tracking additional metrics but significantly improves system stability under stress</li>\n</ul>\n</blockquote>\n<p><strong>Continuous Health Monitoring</strong> provides ongoing assessment of recovery mechanism effectiveness:</p>\n<ol>\n<li><strong>Baseline Performance Tracking</strong>: Establish normal election completion times and failure rates</li>\n<li><strong>Anomaly Detection</strong>: Identify deviations from baseline that indicate degrading conditions</li>\n<li><strong>Predictive Failure Assessment</strong>: Look for patterns that precede cascading failures</li>\n<li><strong>Recovery Process Optimization</strong>: Adjust timeout values and detection thresholds based on observed performance</li>\n</ol>\n<p>⚠️ <strong>Common Pitfall: Recovery Process Starvation</strong></p>\n<p>During periods of high failure rates, recovery processes can consume so many resources that they prevent normal cluster operations, leading to a downward spiral where recovery attempts themselves cause additional failures.</p>\n<p><strong>Why it&#39;s wrong</strong>: Recovery mechanisms that don&#39;t account for their own resource consumption can make the system less stable rather than more stable.</p>\n<p><strong>How to fix</strong>: Implement rate limiting on recovery operations, exponential backoff for repeated failures, and resource reservation to ensure normal operations can continue during recovery.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Understanding the complexity of failure handling in distributed systems, this implementation guidance provides practical tools and patterns for building robust error handling into your leader election system.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Failure Detection</td>\n<td>Simple timeout-based with fixed intervals</td>\n<td>Adaptive timeouts with phi-accrual failure detector</td>\n</tr>\n<tr>\n<td>Network Testing</td>\n<td>Basic ping/pong connectivity checks</td>\n<td>TCP connection establishment with application-level probes</td>\n</tr>\n<tr>\n<td>State Persistence</td>\n<td>In-memory state with periodic snapshots</td>\n<td>Persistent storage with write-ahead logging</td>\n</tr>\n<tr>\n<td>Metrics Collection</td>\n<td>Log-based metrics with periodic summaries</td>\n<td>Time-series database (Prometheus) with real-time dashboards</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>Static configuration files</td>\n<td>Dynamic configuration with runtime updates</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>Unit tests with mocked failures</td>\n<td>Chaos engineering with network partition simulation</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  internal/\n    failure/\n      detector.go              ← FailureDetector implementation\n      detector_test.go         ← Failure detection unit tests\n      adaptive_timeouts.go     ← AdaptiveTimeoutManager\n      split_brain.go           ← Split-brain prevention logic\n      recovery.go              ← Recovery orchestration\n      cascade_handler.go       ← Cascading failure detection\n    testing/\n      chaos/\n        network_partitioner.go ← Network partition simulation\n        failure_injector.go    ← Systematic failure injection\n        scenario_runner.go     ← End-to-end failure scenarios\n    monitoring/\n      metrics.go              ← Recovery effectiveness metrics\n      health_monitor.go       ← Continuous health assessment</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete Adaptive Timeout Manager:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> failure</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AdaptiveTimeoutManager adjusts election timeouts based on observed failure patterns</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AdaptiveTimeoutManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu                    </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    baseTimeout          </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    minTimeout           </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxTimeout           </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recentFailures       []</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recentElections      []</span><span style=\"color:#B392F0\">ElectionRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    windowDuration       </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failureRateMultiplier </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ElectionRecord</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartTime      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CompletionTime </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Success        </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ElectionID     </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewAdaptiveTimeoutManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">base</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">min</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">max</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdaptiveTimeoutManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">AdaptiveTimeoutManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        baseTimeout:          base,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        minTimeout:          min,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        maxTimeout:          max,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        recentFailures:      </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        recentElections:     </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">ElectionRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        windowDuration:      </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Minute,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        failureRateMultiplier: </span><span style=\"color:#79B8FF\">2.0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">atm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdaptiveTimeoutManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetCurrentTimeout</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atm.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> atm.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    now </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clean old records</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atm.</span><span style=\"color:#B392F0\">cleanOldRecords</span><span style=\"color:#E1E4E8\">(now)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate failure rate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failureRate </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(atm.recentFailures)) </span><span style=\"color:#F97583\">/</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">max</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(atm.recentElections), </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Calculate average completion time for successful elections</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    avgCompletion </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> atm.</span><span style=\"color:#B392F0\">calculateAverageCompletionTime</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Determine base timeout (either configured or based on observed performance)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    effectiveBase </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> atm.baseTimeout</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> avgCompletion </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> effectiveBase {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        effectiveBase </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(avgCompletion) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1.5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Apply failure rate multiplier</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    multiplier </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> (failureRate </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> atm.failureRateMultiplier)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    adaptiveTimeout </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(effectiveBase) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> multiplier)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Bound the result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> adaptiveTimeout </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> atm.minTimeout {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> atm.minTimeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> adaptiveTimeout </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> atm.maxTimeout {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> atm.maxTimeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> adaptiveTimeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">atm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdaptiveTimeoutManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecordFailure</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atm.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> atm.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atm.recentFailures </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(atm.recentFailures, time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">atm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdaptiveTimeoutManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecordElection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">record</span><span style=\"color:#B392F0\"> ElectionRecord</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atm.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> atm.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atm.recentElections </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(atm.recentElections, record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">atm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdaptiveTimeoutManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">cleanOldRecords</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">now</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cutoff </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> now.</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">atm.windowDuration)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clean failures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    validFailures </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> atm.recentFailures[:</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, failure </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> atm.recentFailures {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> failure.</span><span style=\"color:#B392F0\">After</span><span style=\"color:#E1E4E8\">(cutoff) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            validFailures </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(validFailures, failure)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atm.recentFailures </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> validFailures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clean elections</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    validElections </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> atm.recentElections[:</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, election </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> atm.recentElections {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> election.StartTime.</span><span style=\"color:#B392F0\">After</span><span style=\"color:#E1E4E8\">(cutoff) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            validElections </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(validElections, election)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    atm.recentElections </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> validElections</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">atm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdaptiveTimeoutManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">calculateAverageCompletionTime</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> total </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, election </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> atm.recentElections {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> election.Success {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            total </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> election.CompletionTime.</span><span style=\"color:#B392F0\">Sub</span><span style=\"color:#E1E4E8\">(election.StartTime)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            count</span><span style=\"color:#F97583\">++</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> atm.baseTimeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> total </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(count)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> max</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">int</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> b {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> a</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> b</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Complete Network Partition Simulator:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> chaos</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NetworkPartitioner simulates network partitions for testing split-brain scenarios</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkPartitioner</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    partitions  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#6A737D\">  // nodeID -> list of nodes it can reach</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    isPartitioned </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    originalTopology </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewNetworkPartitioner</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkPartitioner</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">NetworkPartitioner</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        partitions: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        originalTopology: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        isPartitioned: </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetFullConnectivity establishes full mesh connectivity between all nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">np </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkPartitioner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetFullConnectivity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeIDs</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    np.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> np.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, nodeID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> nodeIDs {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        reachable </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(nodeIDs)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _, otherID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> nodeIDs {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> otherID </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> nodeID {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                reachable </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(reachable, otherID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        np.partitions[nodeID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> reachable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        np.originalTopology[nodeID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(reachable))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        copy</span><span style=\"color:#E1E4E8\">(np.originalTopology[nodeID], reachable)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    np.isPartitioned </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreatePartition splits nodes into isolated groups</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">np </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkPartitioner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreatePartition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">groups</span><span style=\"color:#E1E4E8\"> [][]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    np.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> np.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Clear existing connectivity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> nodeID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> np.partitions {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        np.partitions[nodeID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Establish connectivity within each group</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, group </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> groups {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _, nodeID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> group {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            reachable </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(group)</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> _, otherID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> group {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> otherID </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> nodeID {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    reachable </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(reachable, otherID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            np.partitions[nodeID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> reachable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    np.isPartitioned </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HealPartition restores full connectivity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">np </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkPartitioner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HealPartition</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    np.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> np.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> nodeID, originalReachable </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> np.originalTopology {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        np.partitions[nodeID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(originalReachable))</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">        copy</span><span style=\"color:#E1E4E8\">(np.partitions[nodeID], originalReachable)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    np.isPartitioned </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsReachable checks if source node can communicate with target node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">np </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkPartitioner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsReachable</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">source</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    np.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> np.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    reachable, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> np.partitions[source]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, nodeID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> reachable {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> nodeID </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> target {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetPartitionMembers returns all nodes reachable from the given node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">np </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkPartitioner</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetPartitionMembers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    np.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> np.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    reachable, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> np.partitions[nodeID]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Include the node itself in its partition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(reachable)</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> nodeID</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    copy</span><span style=\"color:#E1E4E8\">(result[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:], reachable)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Split-Brain Prevention Logic:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// QuorumChecker validates leadership decisions against cluster membership quorum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> QuorumChecker</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    originalClusterSize </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    quorumSize         </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    membership         </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateLeadershipClaim checks if a leadership claim has sufficient support</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">qc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">QuorumChecker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateLeadershipClaim</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">candidateID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">supporters</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Verify candidate is in the supporter list (leader must support itself)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if number of supporters meets quorum requirement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: supporters must include at least qc.quorumSize nodes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate that all supporters are in current cluster membership</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use qc.membership.GetActiveMembers() to get valid members</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return true only if all conditions are met</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#6A737D\"> // Replace with actual implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CanElectLeader determines if current partition can safely elect a leader</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">qc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">QuorumChecker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CanElectLeader</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get list of currently reachable nodes from membership</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Count reachable nodes including this node</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Compare against quorum requirement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Need at least qc.quorumSize reachable nodes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return true only if quorum is available</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#6A737D\"> // Replace with actual implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Cascading Failure Handler:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// CascadeDetector identifies patterns indicating cascading failures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CascadeDetector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recentFailures     []</span><span style=\"color:#B392F0\">FailureEvent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    windowDuration     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cascadeThreshold   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    adaptiveManager    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdaptiveTimeoutManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FailureEvent</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NodeID    </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FailureType </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DetectCascade analyzes recent failures to identify cascade patterns</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cd </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CascadeDetector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DetectCascade</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Clean old failure events outside the time window</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Count failures within the cascade detection window</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check if failure count exceeds cascade threshold</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Look for patterns like sequential node failures or election candidate failures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return true if cascade pattern is detected</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span><span style=\"color:#6A737D\"> // Replace with actual implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandleCascade implements adaptive responses to cascading failure detection  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">cd </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CascadeDetector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HandleCascade</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Notify adaptive timeout manager to increase timeouts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Enter conservative mode with extended election delays</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Reduce heartbeat frequency to decrease network load</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Log cascade detection for monitoring and debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Set cascade recovery timer to restore normal operation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>Go-Specific Error Handling Patterns:</strong></p>\n<ul>\n<li>Use <code>context.Context</code> with timeouts for all network operations: <code>ctx, cancel := context.WithTimeout(context.Background(), timeout)</code></li>\n<li>Implement graceful shutdown with <code>select</code> statements on <code>shutdownChan</code> in all goroutines</li>\n<li>Use <code>sync.RWMutex</code> for concurrent access to failure detection state - readers don&#39;t block each other</li>\n<li>Wrap errors with context using <code>fmt.Errorf(&quot;failed to detect node failure: %w&quot;, err)</code> for better debugging</li>\n<li>Use <code>time.NewTimer()</code> for adaptive timeouts and remember to call <code>timer.Stop()</code> to prevent resource leaks</li>\n</ul>\n<p><strong>Network Reliability Patterns:</strong></p>\n<ul>\n<li>Set both connection timeout and read/write timeouts: <code>net.DialTimeout()</code> and <code>conn.SetDeadline()</code></li>\n<li>Implement exponential backoff for retry logic: <code>time.Sleep(backoffDuration * time.Duration(attempt))</code></li>\n<li>Use <code>net.OpError</code> type assertion to distinguish between different network error types</li>\n<li>Buffer channels for failure events to prevent blocking: <code>make(chan FailureEvent, 100)</code></li>\n</ul>\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Failure Detection Validation:</strong></p>\n<p>Run the failure detector in isolation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/failure/</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestFailureDetection</span></span></code></pre></div>\n\n<p>Expected behavior:</p>\n<ul>\n<li>Heartbeat timeouts should trigger failure detection within 2x heartbeat interval</li>\n<li>False positive rate should be &lt; 5% under normal network conditions</li>\n<li>Recovery should complete within 10 seconds of failure detection</li>\n</ul>\n<p><strong>Split-Brain Prevention Test:</strong></p>\n<p>Simulate network partition scenarios:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/testing/chaos/</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestSplitBrainPrevention</span></span></code></pre></div>\n\n<p>Expected behavior:</p>\n<ul>\n<li>Only majority partition should elect leader during partition</li>\n<li>Minority partition should remain leaderless</li>\n<li>Partition healing should resolve to single leader without data loss</li>\n</ul>\n<p><strong>Cascading Failure Resilience:</strong></p>\n<p>Test sequential node failures:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/failure/</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> -run</span><span style=\"color:#9ECBFF\"> TestCascadingFailures</span></span></code></pre></div>\n\n<p>Expected behavior:</p>\n<ul>\n<li>System should adapt timeouts automatically during cascade periods</li>\n<li>Elections should eventually succeed even with 40% node failure rate</li>\n<li>No permanent split-brain states should occur</li>\n</ul>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Frequent unnecessary elections</td>\n<td>Failure detection timeouts too short</td>\n<td>Check heartbeat success rate and network latency</td>\n<td>Increase timeout values or implement adaptive timeouts</td>\n</tr>\n<tr>\n<td>Split-brain persists after partition healing</td>\n<td>Conflict resolution not working</td>\n<td>Look for term number inconsistencies in logs</td>\n<td>Implement proper term-based leadership resolution</td>\n</tr>\n<tr>\n<td>Elections never complete during cascading failures</td>\n<td>Timeouts not adapting to degraded conditions</td>\n<td>Monitor election attempt frequency and success rate</td>\n<td>Enable adaptive timeout management</td>\n</tr>\n<tr>\n<td>False failure detection during load spikes</td>\n<td>Fixed timeouts don&#39;t account for performance variation</td>\n<td>Correlate failure detection with system load metrics</td>\n<td>Implement phi-accrual failure detector or adaptive thresholds</td>\n</tr>\n<tr>\n<td>Recovery stalls with partial membership</td>\n<td>Membership updates not propagating during failures</td>\n<td>Check if membership synchronization is working</td>\n<td>Add periodic membership broadcast from leader</td>\n</tr>\n</tbody></table>\n<h2 id=\"testing-strategy-and-validation\">Testing Strategy and Validation</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - comprehensive testing approach that validates node communication (Milestone 1), bully algorithm correctness (Milestone 2), ring election behavior (Milestone 3), and system-wide reliability</p>\n</blockquote>\n<h3 id=\"mental-model-quality-assurance-theater-production\">Mental Model: Quality Assurance Theater Production</h3>\n<p>Think of testing a distributed leader election system like preparing a theatrical production with multiple actors performing on separate stages that must coordinate perfectly. Just as a theater director needs to test individual actors&#39; performances (component testing), then rehearse scenes with multiple actors (multi-node testing), and finally stress-test the entire production with equipment failures and unexpected events (fault injection), we must validate our leader election system at multiple levels.</p>\n<p>In theater, you start with table reads where actors practice their lines in isolation, progress to blocking rehearsals where they interact on stage, then add technical rehearsals with lighting failures and prop malfunctions. Similarly, our testing strategy begins with isolated component validation, scales to multi-node election scenarios, and culminates with chaos testing that simulates real-world failures.</p>\n<p>The key insight is that distributed systems testing requires both <strong>deterministic validation</strong> (like actors hitting their marks) and <strong>probabilistic resilience testing</strong> (like handling unexpected audience disruptions). Each milestone represents a different &quot;act&quot; in our production, and we must validate that the performance remains coherent even when individual actors miss cues or the stage equipment fails.</p>\n<h3 id=\"component-level-testing\">Component-Level Testing</h3>\n<p>Component-level testing validates individual system components in isolation before integration. This approach mirrors unit testing but focuses specifically on the stateful, concurrent nature of distributed systems components. Each component must demonstrate correct behavior under various input conditions and state transitions.</p>\n<p>The core components requiring isolated testing include the <code>Transport</code> layer, <code>ClusterMembership</code> manager, <code>FailureDetector</code>, <code>BullyElection</code> coordinator, <code>RingElection</code> manager, and <code>ElectionTimeoutManager</code>. Each component has specific behavioral contracts that must be verified independently.</p>\n<blockquote>\n<p><strong>Decision: Mock-Based Component Isolation</strong></p>\n<ul>\n<li><strong>Context</strong>: Components have complex dependencies on network transport, time management, and cluster state</li>\n<li><strong>Options Considered</strong>: Mock all dependencies vs. use test doubles vs. in-memory implementations</li>\n<li><strong>Decision</strong>: Use comprehensive mocks for external dependencies with behavior verification</li>\n<li><strong>Rationale</strong>: Mocks provide precise control over dependency behavior, enable deterministic testing of edge cases, and isolate component logic from infrastructure concerns</li>\n<li><strong>Consequences</strong>: Enables fast, reliable component tests but requires maintaining mock implementations alongside real ones</li>\n</ul>\n</blockquote>\n<h4 id=\"transport-layer-component-testing\">Transport Layer Component Testing</h4>\n<p>The <code>HTTPTransport</code> implementation requires validation of message serialization, network error handling, retry logic, and concurrent connection management. Transport testing focuses on the reliability contracts rather than network performance.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Validation Focus</th>\n<th>Key Scenarios</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Message Serialization</td>\n<td>Correct encoding/decoding of all message types</td>\n<td><code>ElectionMessage</code>, <code>CoordinatorMessage</code>, <code>RingToken</code> round-trip</td>\n</tr>\n<tr>\n<td>Connection Management</td>\n<td>Proper handling of connection lifecycle</td>\n<td>Connect, disconnect, reconnect, connection pooling</td>\n</tr>\n<tr>\n<td>Error Propagation</td>\n<td>Accurate error reporting for network failures</td>\n<td>Timeout errors, connection refused, host unreachable</td>\n</tr>\n<tr>\n<td>Concurrent Access</td>\n<td>Thread-safe operation under high load</td>\n<td>Multiple goroutines sending simultaneously</td>\n</tr>\n<tr>\n<td>Retry Behavior</td>\n<td>Exponential backoff and retry limits</td>\n<td>Failed sends trigger appropriate retry sequences</td>\n</tr>\n</tbody></table>\n<p>The transport layer testing validates the <code>SendMessage</code> and <code>BroadcastMessage</code> methods under controlled failure conditions. Mock network implementations simulate specific failure modes like connection timeouts, partial message delivery, and connection drops during transmission.</p>\n<h4 id=\"cluster-membership-testing\">Cluster Membership Testing</h4>\n<p>The <code>ClusterMembership</code> component manages the dynamic view of active nodes in the cluster. Testing focuses on membership state consistency, node lifecycle management, and concurrent access patterns.</p>\n<table>\n<thead>\n<tr>\n<th>Component Method</th>\n<th>Test Scenarios</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>UpdateMembership(nodes []Node)</code></td>\n<td>Add new nodes, remove failed nodes, bulk updates</td>\n<td>Membership view reflects changes atomically</td>\n</tr>\n<tr>\n<td><code>GetActiveMembers()</code></td>\n<td>Concurrent reads during updates</td>\n<td>Returns consistent snapshot of active nodes</td>\n</tr>\n<tr>\n<td><code>MarkNodeSeen(nodeID NodeID)</code></td>\n<td>Concurrent heartbeat updates</td>\n<td>Timestamps update atomically without races</td>\n</tr>\n<tr>\n<td><code>IncreaseSuspicion(nodeID NodeID)</code></td>\n<td>Graduated failure detection</td>\n<td>Suspicion levels increment correctly</td>\n</tr>\n</tbody></table>\n<p>Membership testing uses controlled timing to validate timeout-based node eviction. Test scenarios include rapid membership changes, concurrent suspicion updates, and edge cases like nodes rejoining after being marked as failed.</p>\n<h4 id=\"failure-detector-validation\">Failure Detector Validation</h4>\n<p>The <code>FailureDetector</code> component implements graduated failure detection using heartbeat timeouts and suspicion levels. Testing validates the accuracy of failure detection while minimizing false positives.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Test Scenarios for Failure Detection:\n1. Normal Operation: Heartbeats arrive regularly → no failures detected\n2. Temporary Network Delay: Delayed heartbeats → suspicion increases but no failure\n3. Node Crash: No heartbeats received → failure detected after timeout\n4. Network Partition: Heartbeats stop → partition detection rather than node failure\n5. False Positive Recovery: Late heartbeat arrives → suspicion decreases appropriately</code></pre></div>\n\n<p>Failure detector testing requires precise timing control to simulate network delays, heartbeat patterns, and recovery scenarios. Mock clocks enable deterministic testing of timeout-based logic without waiting for real time to pass.</p>\n<h4 id=\"election-algorithm-component-testing\">Election Algorithm Component Testing</h4>\n<p>Both <code>BullyElection</code> and <code>RingElection</code> components require isolated testing of their state machines and message handling logic. Component testing validates algorithm correctness independent of network reliability.</p>\n<p><strong>Bully Election Component Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>State Transition</th>\n<th>Trigger Event</th>\n<th>Expected Behavior</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Follower → Candidate</td>\n<td>Leader failure detected</td>\n<td>Start election, send ELECTION messages</td>\n<td>Verify message sending calls</td>\n</tr>\n<tr>\n<td>Candidate → Follower</td>\n<td>Receive OK response</td>\n<td>Stop election attempt</td>\n<td>Verify state change and timeout cancellation</td>\n</tr>\n<tr>\n<td>Candidate → Leader</td>\n<td>Election timeout expires</td>\n<td>Broadcast COORDINATOR message</td>\n<td>Verify coordinator announcement</td>\n</tr>\n<tr>\n<td>Leader → Follower</td>\n<td>Receive COORDINATOR from higher ID</td>\n<td>Acknowledge new leader</td>\n<td>Verify leadership transition</td>\n</tr>\n</tbody></table>\n<p><strong>Ring Election Component Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Token Processing</th>\n<th>Input Condition</th>\n<th>Expected Behavior</th>\n<th>Validation Check</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Token Initiation</td>\n<td><code>StartElection()</code> called</td>\n<td>Create new <code>RingToken</code>, add self to participants</td>\n<td>Verify token creation and forwarding</td>\n</tr>\n<tr>\n<td>Token Forwarding</td>\n<td>Receive incomplete token</td>\n<td>Add self to participants, forward to successor</td>\n<td>Verify participant list updates</td>\n</tr>\n<tr>\n<td>Token Completion</td>\n<td>Receive token with self as initiator</td>\n<td>Select highest ID as leader</td>\n<td>Verify leader selection logic</td>\n</tr>\n<tr>\n<td>Ring Repair</td>\n<td>Next successor unreachable</td>\n<td>Find alternative successor, continue forwarding</td>\n<td>Verify ring topology updates</td>\n</tr>\n</tbody></table>\n<p>Component testing uses mock transport implementations to verify exact message sequences without network dependencies. State verification ensures components maintain correct internal state throughout algorithm execution.</p>\n<h4 id=\"timeout-manager-testing\">Timeout Manager Testing</h4>\n<p>The <code>ElectionTimeoutManager</code> and <code>AdaptiveTimeoutManager</code> components require testing of timer management, adaptive timeout calculation, and concurrent timeout operations.</p>\n<table>\n<thead>\n<tr>\n<th>Timeout Scenario</th>\n<th>Test Condition</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Normal Timeout</td>\n<td>Timer expires without cancellation</td>\n<td>Callback function executed exactly once</td>\n</tr>\n<tr>\n<td>Early Cancellation</td>\n<td><code>CancelTimeout()</code> called before expiration</td>\n<td>Callback never executed, timer cleaned up</td>\n</tr>\n<tr>\n<td>Adaptive Adjustment</td>\n<td>Multiple timeouts recorded</td>\n<td>Timeout duration increases based on failure patterns</td>\n</tr>\n<tr>\n<td>Concurrent Operations</td>\n<td>Multiple timeouts started simultaneously</td>\n<td>Each timer operates independently</td>\n</tr>\n</tbody></table>\n<p>Timeout testing requires mock clock implementations to control time progression and verify callback execution timing without depending on system clocks.</p>\n<p>⚠️ <strong>Pitfall: Race Conditions in Component State</strong>\nComponent testing often reveals race conditions that only manifest under specific timing conditions. For example, the <code>ElectionState</code> might be read and written concurrently during state transitions, leading to inconsistent state if not properly synchronized. Always test components with concurrent operations using tools like Go&#39;s race detector to identify synchronization issues early.</p>\n<h3 id=\"multi-node-scenarios\">Multi-Node Scenarios</h3>\n<p>Multi-node testing validates complete election flows with multiple coordinating nodes. These tests verify that election algorithms produce correct results when multiple nodes interact according to protocol specifications. Multi-node testing bridges the gap between component validation and full system testing.</p>\n<p>The testing approach uses multiple <code>ElectionCoordinator</code> instances within a single process, connected through a controlled test transport that simulates network communication. This enables deterministic testing of multi-node interactions without the complexity of true distributed deployment.</p>\n<h4 id=\"election-flow-validation\">Election Flow Validation</h4>\n<p>Complete election flows require validation of message sequences, timing constraints, and final convergence to a single leader. Each algorithm has specific flow patterns that must be verified under normal operation.</p>\n<p><strong>Bully Algorithm Multi-Node Flow:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Scenario: 5-node cluster (IDs: 1, 2, 3, 4, 5) with Node 5 as initial leader\n1. Node 5 fails (simulated by stopping heartbeats)\n2. Node 2 detects failure, initiates election\n3. Node 2 sends ELECTION to nodes 3, 4, 5\n4. Node 3 sends OK to Node 2, starts own election\n5. Node 3 sends ELECTION to nodes 4, 5\n6. Node 4 sends OK to Node 3, starts own election\n7. Node 4 sends ELECTION to Node 5 (no response)\n8. Node 4's timeout expires, broadcasts COORDINATOR\n9. All nodes acknowledge Node 4 as new leader</code></pre></div>\n\n<p>Multi-node testing validates that this exact sequence occurs reliably and that the system converges to the expected leader (highest ID among responsive nodes).</p>\n<p><strong>Ring Election Multi-Node Flow:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Scenario: 4-node ring (IDs: 2, 4, 6, 8) with Node 8 as initial leader\n1. Node 8 fails, Node 2 detects failure\n2. Node 2 creates RingToken{InitiatorID: 2, Participants: [2]}\n3. Token forwarded: 2 → 4 → 6 → 2 (completing ring)\n4. Token participants: [2, 4, 6]\n5. Node 2 selects highest ID (6) as new leader\n6. Node 6 broadcasts coordinator announcement\n7. All nodes acknowledge Node 6 as leader</code></pre></div>\n\n<p>Ring election testing verifies token circulation, participant collection accuracy, and deterministic leader selection from the participant set.</p>\n<h4 id=\"concurrent-election-handling\">Concurrent Election Handling</h4>\n<p>Multiple nodes may simultaneously detect leader failure and initiate elections. Multi-node testing validates that concurrent elections resolve correctly without producing multiple leaders or election storms.</p>\n<table>\n<thead>\n<tr>\n<th>Concurrent Scenario</th>\n<th>Initial Condition</th>\n<th>Expected Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Simultaneous Detection</td>\n<td>Multiple nodes detect leader failure at same time</td>\n<td>Higher-ID node wins, others become followers</td>\n</tr>\n<tr>\n<td>Election Storm</td>\n<td>Rapid successive failures during elections</td>\n<td>System eventually converges to stable leader</td>\n</tr>\n<tr>\n<td>Split Elections</td>\n<td>Different nodes see different failure sets</td>\n<td>Quorum-based resolution prevents split-brain</td>\n</tr>\n<tr>\n<td>Late Joiner</td>\n<td>Node starts election while another is in progress</td>\n<td>Late election properly defers to ongoing election</td>\n</tr>\n</tbody></table>\n<p>Concurrent election testing requires precise timing control to simulate simultaneous events across multiple nodes. Test scenarios verify that the system maintains safety (at most one leader) and eventual liveness (always elects a leader when possible).</p>\n<h4 id=\"membership-change-integration\">Membership Change Integration</h4>\n<p>Dynamic membership changes during elections create complex scenarios where node sets change while elections are in progress. Multi-node testing validates that membership changes integrate correctly with ongoing elections.</p>\n<table>\n<thead>\n<tr>\n<th>Membership Change</th>\n<th>Election State</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Node Join</td>\n<td>Election in progress</td>\n<td>New node participates in current election</td>\n</tr>\n<tr>\n<td>Node Leave</td>\n<td>Election in progress</td>\n<td>Election continues with remaining participants</td>\n</tr>\n<tr>\n<td>Leader Join</td>\n<td>Follower nodes active</td>\n<td>New leader detected and acknowledged</td>\n</tr>\n<tr>\n<td>Partition Heal</td>\n<td>Split elections ongoing</td>\n<td>Partitions merge and reconcile leadership</td>\n</tr>\n</tbody></table>\n<p>Membership integration testing uses controlled node addition and removal to validate that election protocols adapt correctly to changing cluster composition.</p>\n<h4 id=\"message-ordering-and-timing\">Message Ordering and Timing</h4>\n<p>Multi-node elections depend on message ordering and timing constraints. Testing validates that the system behaves correctly even when messages are delayed, reordered, or lost during transmission.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Message Ordering Test Scenarios:\n1. Delayed Messages: COORDINATOR arrives before ELECTION responses\n2. Message Reordering: OK response arrives before original ELECTION\n3. Duplicate Messages: Same ELECTION message received multiple times\n4. Partial Delivery: ELECTION reaches some but not all higher-ID nodes\n5. Recovery Messages: Late messages arrive after election completion</code></pre></div>\n\n<p>Ordering tests use controlled message delivery simulation to introduce specific timing patterns and verify algorithm robustness. The test transport can delay, duplicate, or reorder messages according to configured patterns.</p>\n<p><img src=\"/api/project/leader-election/architecture-doc/asset?path=diagrams%2Fring-sequence.svg\" alt=\"Ring Election Token Passing\"></p>\n<h4 id=\"leader-transition-validation\">Leader Transition Validation</h4>\n<p>Multi-node testing validates smooth leadership transitions when new leaders are elected. Testing focuses on state consistency, responsibility transfer, and continued cluster operation during leadership changes.</p>\n<table>\n<thead>\n<tr>\n<th>Transition Scenario</th>\n<th>Validation Focus</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Normal Election</td>\n<td>Clean transition from old to new leader</td>\n<td>All nodes acknowledge new leader within timeout</td>\n</tr>\n<tr>\n<td>Failed Leader Recovery</td>\n<td>Original leader returns after being replaced</td>\n<td>Returning leader recognizes new leadership</td>\n</tr>\n<tr>\n<td>Cascading Leadership</td>\n<td>Multiple consecutive leader failures</td>\n<td>System maintains availability throughout transitions</td>\n</tr>\n<tr>\n<td>Partition Recovery</td>\n<td>Leaders elected in separate partitions</td>\n<td>Unified leadership established after partition heals</td>\n</tr>\n</tbody></table>\n<p>Leadership transition testing verifies that cluster operations continue seamlessly across leadership changes and that no split-brain conditions persist after transitions complete.</p>\n<p>⚠️ <strong>Pitfall: Test Non-Determinism</strong>\nMulti-node tests can exhibit non-deterministic behavior due to timing dependencies, goroutine scheduling, and message ordering variations. Always use controlled test clocks, deterministic goroutine scheduling, and message sequence verification to ensure test reliability. Flaky tests undermine confidence in the actual system behavior.</p>\n<h3 id=\"fault-injection-testing\">Fault Injection Testing</h3>\n<p>Fault injection testing validates system resilience by deliberately introducing failures during normal operation. This approach reveals how the system behaves under adverse conditions and verifies that error handling and recovery mechanisms function correctly.</p>\n<p>Fault injection simulates real-world failure scenarios including network partitions, node crashes, message loss, and timing failures. The goal is to verify that the system maintains safety properties (never elects multiple leaders) and recovers liveness (eventually elects a new leader) even under challenging conditions.</p>\n<h4 id=\"network-failure-simulation\">Network Failure Simulation</h4>\n<p>Network failures represent the most common source of distributed system problems. Fault injection testing systematically introduces network-level failures to validate election algorithm resilience.</p>\n<p><strong>Network Partition Simulation:</strong></p>\n<p>The <code>NetworkPartitioner</code> component creates controlled network splits that isolate nodes into separate communication groups. Partition testing validates that each partition behaves correctly and that partition healing restores unified leadership.</p>\n<table>\n<thead>\n<tr>\n<th>Partition Type</th>\n<th>Configuration</th>\n<th>Expected Behavior</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Clean Split</td>\n<td>Divide cluster into equal-sized partitions</td>\n<td>Each partition attempts independent election</td>\n<td>Verify no cross-partition communication</td>\n</tr>\n<tr>\n<td>Asymmetric Split</td>\n<td>One large partition, multiple small ones</td>\n<td>Large partition elects leader, small ones wait</td>\n<td>Verify quorum-based election restrictions</td>\n</tr>\n<tr>\n<td>Network Island</td>\n<td>Single node isolated from cluster</td>\n<td>Isolated node cannot elect itself leader</td>\n<td>Verify quorum requirements prevent solo leadership</td>\n</tr>\n<tr>\n<td>Cascading Partition</td>\n<td>Sequential isolation of nodes</td>\n<td>Remaining cluster continues operation</td>\n<td>Verify graceful degradation</td>\n</tr>\n</tbody></table>\n<p>Partition testing uses the <code>CreatePartition</code> method to establish communication restrictions between node groups. The <code>IsReachable</code> method validates partition boundaries and ensures message isolation.</p>\n<p><strong>Message Loss and Delay:</strong></p>\n<p>Controlled message loss and delay simulation tests algorithm robustness against unreliable network conditions. Testing validates retry logic, timeout handling, and eventual consistency.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Message Failure Injection Patterns:\n1. Random Loss: Randomly drop X% of messages during election\n2. Selective Loss: Drop specific message types (e.g., all OK responses)\n3. Burst Loss: Drop all messages for specific time window\n4. Asymmetric Loss: Drop messages in one direction only\n5. Gradual Degradation: Increasing loss rate over time</code></pre></div>\n\n<p>Message loss testing verifies that election algorithms eventually converge to correct results despite communication failures. Timeout mechanisms and retry logic must ensure progress even with significant message loss.</p>\n<h4 id=\"node-failure-patterns\">Node Failure Patterns</h4>\n<p>Node failure injection simulates various crash scenarios to validate failure detection and leader election triggers. Testing covers both crash-stop failures (nodes stop completely) and crash-recovery failures (nodes restart after crashes).</p>\n<p><strong>Crash-Stop Failure Simulation:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Failure Timing</th>\n<th>Scenario</th>\n<th>Expected System Response</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Leader Crash</td>\n<td>Current leader stops during normal operation</td>\n<td>Followers detect failure, initiate new election</td>\n</tr>\n<tr>\n<td>Candidate Crash</td>\n<td>Node crashes during active election campaign</td>\n<td>Other candidates continue election process</td>\n</tr>\n<tr>\n<td>Follower Crash</td>\n<td>Non-leader node crashes</td>\n<td>Leader continues operation, membership updated</td>\n</tr>\n<tr>\n<td>Cascading Crash</td>\n<td>Multiple nodes crash in sequence</td>\n<td>System maintains operation with remaining nodes</td>\n</tr>\n</tbody></table>\n<p>Node crash simulation stops specific nodes at controlled points in election algorithms. Testing validates that remaining nodes detect failures promptly and adapt cluster membership accordingly.</p>\n<p><strong>Crash-Recovery Scenarios:</strong></p>\n<p>Crash-recovery testing validates system behavior when failed nodes restart and attempt to rejoin cluster operations. Recovery scenarios test state reconciliation and leadership acknowledgment.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Recovery Test Scenarios:\n1. Leader Recovery: Failed leader restarts and discovers new leader\n2. Candidate Recovery: Node crashed during election restarts\n3. Network Recovery: Partitioned nodes reconnect to cluster\n4. Stale State Recovery: Restarted node has outdated cluster state\n5. Split-Brain Recovery: Multiple leaders exist during partition healing</code></pre></div>\n\n<p>Recovery testing uses controlled node restart sequences to validate that recovering nodes integrate correctly without disrupting ongoing cluster operations.</p>\n<h4 id=\"timing-failure-injection\">Timing Failure Injection</h4>\n<p>Timing failures simulate clock skew, timeout variations, and scheduling delays that can affect distributed coordination. Timing injection tests validate that algorithms remain correct despite temporal uncertainties.</p>\n<p><strong>Clock Skew Simulation:</strong></p>\n<p>Different nodes may have slightly different clock times, affecting timeout calculations and message timestamps. Clock skew testing validates that algorithms tolerate reasonable time differences between nodes.</p>\n<table>\n<thead>\n<tr>\n<th>Skew Pattern</th>\n<th>Configuration</th>\n<th>Impact on Elections</th>\n<th>Validation Focus</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Linear Skew</td>\n<td>Each node&#39;s clock runs slightly fast/slow</td>\n<td>Affects timeout calculations</td>\n<td>Verify elections complete despite skew</td>\n</tr>\n<tr>\n<td>Step Skew</td>\n<td>Nodes have different epoch times</td>\n<td>Timestamp comparison issues</td>\n<td>Verify timestamp-based logic handles differences</td>\n</tr>\n<tr>\n<td>Drift Skew</td>\n<td>Clock rates diverge over time</td>\n<td>Increasing timing discrepancies</td>\n<td>Verify long-running stability</td>\n</tr>\n</tbody></table>\n<p>Clock skew injection modifies timeout calculations and timestamp generation to simulate realistic timing variations in distributed environments.</p>\n<p><strong>Timeout Manipulation:</strong></p>\n<p>Controlled timeout manipulation tests algorithm behavior under various timing conditions. Testing validates that adaptive timeout mechanisms respond correctly to changing network conditions.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Timeout Injection Scenarios:\n1. Aggressive Timeouts: Very short timeouts cause frequent false failures\n2. Conservative Timeouts: Long timeouts delay failure detection\n3. Variable Timeouts: Timeout values change during elections\n4. Timeout Storms: Multiple simultaneous timeout expirations\n5. Timeout Starvation: Timeouts never expire due to constant resets</code></pre></div>\n\n<p>Timeout manipulation uses the <code>AdaptiveTimeoutManager</code> to modify timeout behavior and validate system adaptation to different timing environments.</p>\n<h4 id=\"cascading-failure-testing\">Cascading Failure Testing</h4>\n<p>Cascading failures occur when one failure triggers additional failures, potentially leading to system-wide outages. Cascading failure testing validates that the system contains failure propagation and maintains core functionality.</p>\n<p><strong>Failure Cascade Patterns:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Cascade Type</th>\n<th>Trigger Condition</th>\n<th>Propagation Mechanism</th>\n<th>Expected Containment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Leadership Cascade</td>\n<td>Leader fails during election</td>\n<td>New leader also fails before stabilizing</td>\n<td>System eventually elects stable leader</td>\n</tr>\n<tr>\n<td>Network Cascade</td>\n<td>Partition triggers additional network failures</td>\n<td>Isolated nodes become unreachable</td>\n<td>Remaining nodes form functional cluster</td>\n</tr>\n<tr>\n<td>Resource Cascade</td>\n<td>Node crash causes resource exhaustion</td>\n<td>Other nodes crash due to increased load</td>\n<td>Load balancing prevents complete failure</td>\n</tr>\n<tr>\n<td>Election Storm</td>\n<td>Concurrent elections trigger more elections</td>\n<td>Rapid election attempts prevent convergence</td>\n<td>System eventually stabilizes on single leader</td>\n</tr>\n</tbody></table>\n<p>The <code>CascadeDetector</code> component identifies cascading failure patterns and triggers protective mechanisms to prevent system-wide collapse.</p>\n<p><strong>Recovery from Cascades:</strong></p>\n<p>Cascade recovery testing validates that the system can recover from severe failure scenarios and restore normal operation. Recovery mechanisms include backoff strategies, leader election suspension, and gradual node re-integration.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Cascade Recovery Validation:\n1. Detection: System recognizes cascading failure pattern\n2. Containment: Protective measures prevent further propagation  \n3. Stabilization: Remaining nodes establish minimal functional cluster\n4. Recovery: Failed nodes gradually rejoin without triggering new cascades\n5. Full Operation: Complete cluster functionality restored</code></pre></div>\n\n<p>Recovery testing uses controlled failure injection sequences followed by gradual recovery to validate system resilience and self-healing capabilities.</p>\n<p><img src=\"/api/project/leader-election/architecture-doc/asset?path=diagrams%2Fnetwork-partition-scenario.svg\" alt=\"Split-Brain Prevention\"></p>\n<p>⚠️ <strong>Pitfall: Unrealistic Failure Scenarios</strong>\nFault injection testing can create failure combinations that never occur in practice, leading to over-engineering or incorrect system behavior. Focus on realistic failure patterns based on actual distributed system operational data. Common real-world failures include single-node crashes, network partitions between data centers, and gradual network degradation rather than simultaneous multi-node failures.</p>\n<h3 id=\"milestone-validation-checkpoints\">Milestone Validation Checkpoints</h3>\n<p>Each project milestone requires specific validation checkpoints to verify correct implementation before proceeding to subsequent milestones. Validation checkpoints provide concrete behavioral tests that demonstrate milestone completion.</p>\n<p>Milestone validation combines automated testing, manual verification, and behavioral observation to ensure comprehensive validation. Each checkpoint includes specific commands to execute, expected outputs to observe, and behavioral patterns to verify.</p>\n<h4 id=\"milestone-1-node-communication-validation\">Milestone 1: Node Communication Validation</h4>\n<p>Node communication validation verifies that the foundational messaging infrastructure operates correctly. Testing focuses on message delivery, failure detection, and cluster membership management.</p>\n<p><strong>Checkpoint 1.1: Basic Messaging</strong></p>\n<table>\n<thead>\n<tr>\n<th>Validation Test</th>\n<th>Command</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Point-to-Point Messaging</td>\n<td><code>go test -run TestSendMessage</code></td>\n<td>Messages deliver reliably between specific nodes</td>\n</tr>\n<tr>\n<td>Broadcast Messaging</td>\n<td><code>go test -run TestBroadcastMessage</code></td>\n<td>Messages reach all active cluster members</td>\n</tr>\n<tr>\n<td>Message Serialization</td>\n<td><code>go test -run TestMessageSerialization</code></td>\n<td>All message types serialize/deserialize correctly</td>\n</tr>\n<tr>\n<td>Concurrent Messaging</td>\n<td><code>go test -run TestConcurrentMessaging</code></td>\n<td>Multiple simultaneous messages deliver without corruption</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification for Milestone 1:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Manual Test Procedure:\n1. Start 3 nodes: ./node --id=1 --port=8001, ./node --id=2 --port=8002, ./node --id=3 --port=8003\n2. Verify cluster membership: curl http://localhost:8001/membership should show all 3 nodes\n3. Send test message: curl -X POST http://localhost:8001/send -d '{&quot;target&quot;: 2, &quot;content&quot;: &quot;test&quot;}'\n4. Verify message receipt: curl http://localhost:8002/messages should show received message\n5. Stop node 3, wait 10 seconds: curl http://localhost:8001/membership should show only nodes 1, 2</code></pre></div>\n\n<p><strong>Checkpoint 1.2: Failure Detection</strong></p>\n<p>Failure detection validation verifies that nodes detect crashes and network partitions within configured timeouts.</p>\n<table>\n<thead>\n<tr>\n<th>Test Scenario</th>\n<th>Validation Method</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Node Crash Detection</td>\n<td>Stop node process abruptly</td>\n<td>Other nodes detect failure within 2x heartbeat interval</td>\n</tr>\n<tr>\n<td>Network Partition</td>\n<td>Block network traffic between nodes</td>\n<td>Partitioned nodes marked as unreachable</td>\n</tr>\n<tr>\n<td>False Positive Prevention</td>\n<td>Introduce temporary network delay</td>\n<td>Nodes marked suspicious but not failed</td>\n</tr>\n<tr>\n<td>Recovery Detection</td>\n<td>Restart failed node</td>\n<td>Node rejoins cluster and resumes normal operation</td>\n</tr>\n</tbody></table>\n<p><strong>Checkpoint 1.3: Cluster Membership</strong></p>\n<p>Membership validation ensures that all nodes maintain consistent views of cluster composition and handle membership changes correctly.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Membership Consistency Test:\n1. Start 5-node cluster with IDs 1, 2, 3, 4, 5\n2. Verify all nodes report identical membership: [1, 2, 3, 4, 5]\n3. Stop nodes 3 and 4 simultaneously  \n4. Wait for failure detection timeout (default: 5 seconds)\n5. Verify remaining nodes report membership: [1, 2, 5]\n6. Restart node 3\n7. Verify membership updates to: [1, 2, 3, 5] within rejoin timeout</code></pre></div>\n\n<h4 id=\"milestone-2-bully-algorithm-validation\">Milestone 2: Bully Algorithm Validation</h4>\n<p>Bully algorithm validation verifies that the highest-ID responsive node consistently wins elections and that all nodes acknowledge the elected leader.</p>\n<p><strong>Checkpoint 2.1: Basic Bully Election</strong></p>\n<table>\n<thead>\n<tr>\n<th>Election Scenario</th>\n<th>Setup</th>\n<th>Expected Winner</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Normal Election</td>\n<td>5 nodes (1,2,3,4,5), node 5 fails</td>\n<td>Node 4</td>\n<td>Verify COORDINATOR message from node 4</td>\n</tr>\n<tr>\n<td>Cascading Election</td>\n<td>Nodes 4,5 fail during node 2&#39;s election</td>\n<td>Node 3</td>\n<td>Verify node 3 eventually becomes leader</td>\n</tr>\n<tr>\n<td>Simultaneous Detection</td>\n<td>Nodes 1,2 detect failure simultaneously</td>\n<td>Higher ID wins</td>\n<td>Verify only one COORDINATOR broadcast</td>\n</tr>\n<tr>\n<td>Leader Recovery</td>\n<td>Failed leader returns after replacement</td>\n<td>New leader remains</td>\n<td>Returning leader becomes follower</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Bully Election Test:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Bully Election Manual Verification:\n1. Start 4-node cluster: IDs 10, 20, 30, 40\n2. Verify node 40 is initial leader: curl http://localhost:8040/status shows &quot;leader&quot;\n3. Stop node 40 (kill process)\n4. Wait for election timeout (default: 3 seconds)  \n5. Verify node 30 becomes leader: curl http://localhost:8030/status shows &quot;leader&quot;\n6. Verify other nodes acknowledge: curl http://localhost:8010/leader returns &quot;30&quot;\n7. Restart node 40: ./node --id=40 --port=8040\n8. Verify node 40 becomes follower: curl http://localhost:8040/status shows &quot;follower&quot;\n9. Verify node 40 acknowledges node 30: curl http://localhost:8040/leader returns &quot;30&quot;</code></pre></div>\n\n<p><strong>Checkpoint 2.2: Bully Message Sequences</strong></p>\n<p>Message sequence validation verifies that bully election messages follow the correct protocol patterns and that election termination occurs appropriately.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Expected Bully Message Sequence (Node 20 initiates election):\n1. Node 20 → ELECTION → Nodes 30, 40\n2. Node 30 → OK → Node 20 (Node 20 stops its election)  \n3. Node 40 → OK → Node 20\n4. Node 30 → ELECTION → Node 40\n5. Node 40 → OK → Node 30 (Node 30 stops its election)\n6. Node 40 timeout expires (no higher-ID responses)\n7. Node 40 → COORDINATOR → Nodes 10, 20, 30\n8. All nodes acknowledge Node 40 as leader</code></pre></div>\n\n<p><strong>Checkpoint 2.3: Bully Edge Cases</strong></p>\n<p>Edge case validation ensures robust behavior under challenging conditions including message loss, timing variations, and concurrent elections.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Test Condition</th>\n<th>Expected Behavior</th>\n<th>Validation Check</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Message Loss</td>\n<td>Drop 50% of ELECTION messages</td>\n<td>Election eventually completes</td>\n<td>Retry logic ensures progress</td>\n</tr>\n<tr>\n<td>Timeout Variation</td>\n<td>Randomize election timeouts</td>\n<td>Highest-ID node still wins</td>\n<td>Algorithm correctness maintained</td>\n</tr>\n<tr>\n<td>Concurrent Elections</td>\n<td>Multiple nodes start elections simultaneously</td>\n<td>Single leader emerges</td>\n<td>No split-brain condition</td>\n</tr>\n<tr>\n<td>Partial Partition</td>\n<td>Some nodes can&#39;t reach highest-ID node</td>\n<td>Available highest-ID node wins</td>\n<td>Election adapts to reachable nodes</td>\n</tr>\n</tbody></table>\n<h4 id=\"milestone-3-ring-election-validation\">Milestone 3: Ring Election Validation</h4>\n<p>Ring election validation verifies that tokens circulate correctly around the logical ring and that the highest-ID node from collected participants becomes the leader.</p>\n<p><strong>Checkpoint 3.1: Ring Topology Construction</strong></p>\n<p>Ring topology validation ensures that nodes form a correct logical ring based on ID ordering and that ring repair mechanisms handle node failures.</p>\n<table>\n<thead>\n<tr>\n<th>Topology Test</th>\n<th>Node Set</th>\n<th>Expected Ring Order</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Basic Ring</td>\n<td>IDs: 5, 15, 25, 35</td>\n<td>5→15→25→35→5</td>\n<td>Verify successor mapping</td>\n</tr>\n<tr>\n<td>Gap Handling</td>\n<td>IDs: 10, 30, 50</td>\n<td>10→30→50→10</td>\n<td>Ring spans non-consecutive IDs</td>\n</tr>\n<tr>\n<td>Dynamic Addition</td>\n<td>Add node 20 to ring [10, 30, 50]</td>\n<td>10→20→30→50→10</td>\n<td>Ring rebuilds correctly</td>\n</tr>\n<tr>\n<td>Failure Repair</td>\n<td>Node 30 fails in ring [10, 20, 30, 40]</td>\n<td>20→40 (skip failed node)</td>\n<td>Ring repairs automatically</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Ring Topology Verification:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Ring Topology Manual Test:\n1. Start 4 nodes with IDs: 100, 300, 200, 400  \n2. Verify ring construction: curl http://localhost:8100/ring-topology\n   Expected: {100: 200, 200: 300, 300: 400, 400: 100}\n3. Stop node 300\n4. Wait for failure detection and ring repair\n5. Verify updated ring: curl http://localhost:8100/ring-topology  \n   Expected: {100: 200, 200: 400, 400: 100}\n6. Restart node 300\n7. Verify ring inclusion: ring should include all 4 nodes again</code></pre></div>\n\n<p><strong>Checkpoint 3.2: Token Circulation</strong></p>\n<p>Token circulation validation verifies that election tokens pass correctly around the ring, collecting participant IDs and completing full ring traversals.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Expected Ring Election Flow (Node 100 initiates):\n1. Node 100 creates token: {InitiatorID: 100, Participants: [100]}\n2. Token 100→200: Participants become [100, 200]  \n3. Token 200→400: Participants become [100, 200, 400] (Node 300 failed, skipped)\n4. Token 400→100: Ring complete, participants [100, 200, 400]\n5. Node 100 selects leader: max(100, 200, 400) = 400\n6. Node 400 broadcasts COORDINATOR message\n7. All nodes acknowledge Node 400 as leader</code></pre></div>\n\n<p><strong>Checkpoint 3.3: Ring Election Message Validation</strong></p>\n<p>Message validation ensures that ring tokens contain correct participant information and that leader selection follows deterministic rules.</p>\n<table>\n<thead>\n<tr>\n<th>Token State</th>\n<th>Participant List</th>\n<th>Expected Leader</th>\n<th>Validation Check</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Partial Circulation</td>\n<td>[5, 15]</td>\n<td>Election incomplete</td>\n<td>No leader selected yet</td>\n</tr>\n<tr>\n<td>Complete Circulation</td>\n<td>[5, 15, 25]</td>\n<td>Node 25</td>\n<td>Highest ID becomes leader</td>\n</tr>\n<tr>\n<td>Failed Node Excluded</td>\n<td>[5, 25] (Node 15 failed)</td>\n<td>Node 25</td>\n<td>Failed nodes don&#39;t participate</td>\n</tr>\n<tr>\n<td>Single Node Ring</td>\n<td>[42]</td>\n<td>Node 42</td>\n<td>Solo node becomes leader</td>\n</tr>\n</tbody></table>\n<h4 id=\"cross-milestone-integration-validation\">Cross-Milestone Integration Validation</h4>\n<p>Integration validation verifies that components from different milestones work correctly together and that the complete system demonstrates expected behavior.</p>\n<p><strong>End-to-End Election Scenarios:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Integration Test</th>\n<th>Milestone Components</th>\n<th>Scenario</th>\n<th>Expected Outcome</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Algorithm Switching</td>\n<td>M1 + M2 + M3</td>\n<td>Switch from bully to ring election</td>\n<td>Both algorithms produce same leader</td>\n</tr>\n<tr>\n<td>Failure During Election</td>\n<td>M1 + M2</td>\n<td>Node fails mid-bully-election</td>\n<td>Election completes with remaining nodes</td>\n</tr>\n<tr>\n<td>Partition Recovery</td>\n<td>M1 + M3</td>\n<td>Ring election during partition heal</td>\n<td>Unified leadership established</td>\n</tr>\n<tr>\n<td>Concurrent Algorithms</td>\n<td>M2 + M3</td>\n<td>Bully and ring elections triggered simultaneously</td>\n<td>One election succeeds, other aborts</td>\n</tr>\n</tbody></table>\n<p><strong>System-Wide Behavioral Validation:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Complete System Test Procedure:\n1. Deploy 5-node cluster with both election algorithms enabled\n2. Verify initial leader election (any algorithm)  \n3. Simulate network partition splitting cluster 2-3\n4. Verify each partition attempts independent leadership\n5. Heal network partition\n6. Verify unified leadership with single leader\n7. Trigger manual election switch (bully→ring or ring→bully)\n8. Verify leadership transition maintains cluster stability\n9. Introduce cascading failures (2 nodes crash sequentially)\n10. Verify system maintains operation with remaining nodes</code></pre></div>\n\n<p><strong>Performance and Timing Validation:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Performance Metric</th>\n<th>Target Value</th>\n<th>Measurement Method</th>\n<th>Acceptable Range</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Election Completion Time</td>\n<td>&lt; 5 seconds</td>\n<td>Time from leader failure to new leader</td>\n<td>2-8 seconds depending on timeouts</td>\n</tr>\n<tr>\n<td>Message Overhead</td>\n<td>&lt; 10 messages per election</td>\n<td>Count all election-related messages</td>\n<td>Varies by algorithm and cluster size</td>\n</tr>\n<tr>\n<td>Convergence Reliability</td>\n<td>99%+ success rate</td>\n<td>1000 election simulations</td>\n<td>Must handle standard failure scenarios</td>\n</tr>\n<tr>\n<td>Memory Usage</td>\n<td>&lt; 10MB per node</td>\n<td>Runtime memory profiling</td>\n<td>Reasonable for long-running operation</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Insufficient Validation Coverage</strong>\nMilestone checkpoints often focus on &quot;happy path&quot; scenarios and miss edge cases that cause problems in production. Always include negative test cases where elections should fail or be rejected (e.g., minority partitions attempting leadership, nodes with stale state trying to become leaders). Comprehensive validation catches safety violations that simple positive testing might miss.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides concrete implementation approaches for building a comprehensive testing framework for the distributed leader election system. The testing infrastructure must support component isolation, multi-node coordination, fault injection, and milestone validation.</p>\n<h4 id=\"testing-infrastructure-components\">Testing Infrastructure Components</h4>\n<p><strong>A. Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Test Framework</td>\n<td>Go&#39;s built-in <code>testing</code> package with table-driven tests</td>\n<td>Testify framework with advanced assertions and mocking</td>\n</tr>\n<tr>\n<td>Test Transport</td>\n<td>In-memory channel-based transport with controlled delivery</td>\n<td>HTTP-based test transport with network simulation</td>\n</tr>\n<tr>\n<td>Time Control</td>\n<td>Manual clock implementation with controllable time progression</td>\n<td>Specialized testing time library (e.g., clockwork)</td>\n</tr>\n<tr>\n<td>Concurrency Testing</td>\n<td>Go race detector with stress testing</td>\n<td>Dedicated concurrency testing tools</td>\n</tr>\n<tr>\n<td>Fault Injection</td>\n<td>Simple failure flags and controlled panics</td>\n<td>Chaos engineering framework integration</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended Testing File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n├── cmd/\n│   └── testnode/\n│       └── main.go                    ← Test node executable for manual testing\n├── internal/\n│   ├── election/\n│   │   ├── coordinator_test.go        ← ElectionCoordinator component tests\n│   │   ├── bully_test.go              ← BullyElection component tests  \n│   │   ├── ring_test.go               ← RingElection component tests\n│   │   └── integration_test.go        ← Multi-node election flow tests\n│   ├── transport/\n│   │   ├── http_test.go               ← HTTPTransport component tests\n│   │   └── test_transport.go          ← Mock transport for testing\n│   ├── membership/\n│   │   ├── membership_test.go         ← ClusterMembership component tests\n│   │   └── failure_detector_test.go   ← FailureDetector component tests\n│   └── testutil/\n│       ├── test_cluster.go            ← Multi-node test cluster management\n│       ├── fault_injector.go          ← Controlled failure injection\n│       ├── mock_clock.go              ← Controllable time implementation\n│       └── scenario_runner.go         ← Election scenario test framework\n└── test/\n    ├── scenarios/\n    │   ├── bully_scenarios_test.go     ← Milestone 2 validation scenarios\n    │   ├── ring_scenarios_test.go      ← Milestone 3 validation scenarios\n    │   └── integration_scenarios_test.go ← Cross-milestone integration tests\n    └── chaos/\n        ├── partition_test.go           ← Network partition chaos tests\n        ├── failure_test.go             ← Node failure chaos tests\n        └── timing_test.go              ← Timing failure chaos tests</code></pre></div>\n\n<p><strong>C. Complete Test Transport Infrastructure:</strong></p>\n<p>The testing infrastructure requires a controllable transport implementation that can simulate network conditions, inject failures, and provide deterministic message delivery for reproducible tests.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// TestTransport provides controllable message delivery for testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TestTransport</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID        </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    messageQueue  </span><span style=\"color:#F97583\">chan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    deliveryRules </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">DeliveryRule</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    networkState  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    faultInjector </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FaultInjector</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    messageLog    []</span><span style=\"color:#B392F0\">MessageEvent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu            </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DeliveryRule</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Delay      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DropRate   </span><span style=\"color:#F97583\">float64</span><span style=\"color:#6A737D\">    // 0.0 = no drops, 1.0 = drop all</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Duplicate  </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">       // Whether to duplicate messages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Reorder    </span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">       // Whether to deliver out of order</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NetworkState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    partitions </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#6A737D\">  // Which nodes each node can reach</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    failures   </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">      // Which nodes are marked as failed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FaultInjector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    activeRules </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">FaultRule</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    randomSeed  </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SendMessage implements Transport interface with controlled delivery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SendMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if target is reachable according to network state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Apply fault injection rules (delay, drop, duplicate)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Log message for test verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Deliver message to target's message queue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use network state partitions to simulate unreachable nodes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BroadcastMessage sends to all reachable nodes in current partition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">BroadcastMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get list of nodes reachable from this node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Send message to each reachable node using SendMessage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Collect any delivery errors and return aggregated error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use t.networkState.partitions[t.nodeID] for reachable nodes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReceiveMessages returns channel for receiving messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestTransport</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReceiveMessages</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;-chan</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">Message</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> t.messageQueue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Multi-Node Test Cluster Management:</strong></p>\n<p>Managing multiple nodes in test scenarios requires coordination of node lifecycle, transport configuration, and state synchronization.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// TestCluster manages multiple nodes for integration testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TestCluster</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodes       </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionCoordinator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transports  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestTransport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    networkSim  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NetworkSimulator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timeline    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestTimeline</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config      </span><span style=\"color:#B392F0\">TestClusterConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TestClusterConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NodeCount           </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    InitialLeaderID     </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HeartbeatInterval   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ElectionTimeout     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FailureDetectionTimeout </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartCluster initializes and starts all nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestCluster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartCluster</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create TestTransport for each node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Initialize ElectionCoordinator for each node  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Configure inter-node connectivity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Start all nodes and wait for initial leader election</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify cluster reaches stable state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use sync.WaitGroup to wait for all nodes to start</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SimulateFailure stops a specific node and triggers failure detection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestCluster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SimulateFailure</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Stop the target node's ElectionCoordinator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Mark node as failed in all transport network states</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Wait for failure detection timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify other nodes detect the failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check that node is removed from cluster membership</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreatePartition splits cluster into separate communication groups</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestCluster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreatePartition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">groups</span><span style=\"color:#E1E4E8\"> [][]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Update network state for each transport</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Ensure nodes can only communicate within their partition</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Trigger partition detection in affected nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify each partition operates independently</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use transport delivery rules to block cross-partition messages</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WaitForElection waits for election to complete and returns winner</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestCluster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WaitForElection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Start timeout timer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Poll all nodes for leadership status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return when exactly one leader is found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return error if timeout expires or multiple leaders found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check IsLeader() on all node coordinators</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Fault Injection Framework:</strong></p>\n<p>Systematic fault injection requires configurable failure scenarios that can be applied during specific test phases.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// FaultScenario defines a specific failure injection pattern</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FaultScenario</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name         </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Setup        </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestCluster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Trigger      </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestCluster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Validation   </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestCluster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Cleanup      </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestCluster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Milestone Checkpoint Validation Functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ValidateMilestone1Messaging</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tc</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TestCluster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Send test messages between all node pairs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify all messages are received correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Test broadcast message delivery to all nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify failure detection works within timeout</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use tc.transports to access message logs for verification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ValidateMilestone2BullyElection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tc</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TestCluster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Stop current leader node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Wait for election completion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify highest-ID responsive node becomes leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify all nodes acknowledge the new leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check that GetCurrentLeader() returns same ID on all nodes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> ValidateMilestone3RingElection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tc</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TestCluster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Configure cluster to use ring election algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Trigger election and capture token circulation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify token visits all live nodes exactly once  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify highest-ID participant becomes leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use message logs to trace token forwarding sequence</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>F. Chaos Testing Scenarios:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> ChaosScenarios </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">FaultScenario</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Name: </span><span style=\"color:#9ECBFF\">\"Network Partition During Election\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Description: </span><span style=\"color:#9ECBFF\">\"Split cluster while bully election is in progress\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Setup: </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tc</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TestCluster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Start normal 5-node cluster</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> tc.</span><span style=\"color:#B392F0\">StartCluster</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Trigger: </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tc</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TestCluster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // Stop leader to trigger election, then immediately partition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            leader </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tc.</span><span style=\"color:#B392F0\">GetCurrentLeader</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tc.</span><span style=\"color:#B392F0\">SimulateFailure</span><span style=\"color:#E1E4E8\">(leader)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            time.</span><span style=\"color:#B392F0\">Sleep</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Millisecond) </span><span style=\"color:#6A737D\">// Let election start</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> tc.</span><span style=\"color:#B392F0\">CreatePartition</span><span style=\"color:#E1E4E8\">([][]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">{{</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">}, {</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">}})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Validation: </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tc</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TestCluster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Verify each partition elects independent leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Verify no cross-partition communication</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO: Heal partition and verify unified leadership</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Name: </span><span style=\"color:#9ECBFF\">\"Cascading Leader Failures\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Description: </span><span style=\"color:#9ECBFF\">\"Multiple consecutive leader failures during recovery\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Trigger: </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tc</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TestCluster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 1: Fail current leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 2: Wait for new leader election</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 3: Immediately fail the new leader  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 4: Repeat 2-3 times to create cascade</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            // TODO 5: Verify system eventually stabilizes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>G. Milestone Validation Checkpoints:</strong></p>\n<p>Each milestone requires automated validation that can be run as part of continuous integration.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Milestone 1 Validation Script</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">#!/bin/bash</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Validating Milestone 1: Node Communication\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Start test nodes</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/testnode/main.go</span><span style=\"color:#79B8FF\"> --id=1</span><span style=\"color:#79B8FF\"> --port=8001</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/testnode/main.go</span><span style=\"color:#79B8FF\"> --id=2</span><span style=\"color:#79B8FF\"> --port=8002</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/testnode/main.go</span><span style=\"color:#79B8FF\"> --id=3</span><span style=\"color:#79B8FF\"> --port=8003</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#6A737D\">  # Wait for startup</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test point-to-point messaging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8001/send</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -d</span><span style=\"color:#9ECBFF\"> '{\"target\": 2, \"message\": \"test\"}'</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify message delivery</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">MESSAGES</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8002/messages</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> [[ $MESSAGES </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> *</span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> ]]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"✓ Point-to-point messaging works\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"✗ Point-to-point messaging failed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test failure detection</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">kill</span><span style=\"color:#9ECBFF\"> %2</span><span style=\"color:#6A737D\">  # Stop node 2</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 6</span><span style=\"color:#6A737D\">  # Wait for failure detection</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">MEMBERSHIP</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">$(</span><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> http://localhost:8001/membership</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> [[ $MEMBERSHIP </span><span style=\"color:#F97583\">!=</span><span style=\"color:#F97583\"> *</span><span style=\"color:#9ECBFF\">\"2\"</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> ]]; </span><span style=\"color:#F97583\">then</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"✓ Failure detection works\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">else</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    echo</span><span style=\"color:#9ECBFF\"> \"✗ Failure detection failed\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    exit</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">fi</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">echo</span><span style=\"color:#9ECBFF\"> \"Milestone 1 validation complete\"</span></span></code></pre></div>\n\n<p><strong>H. Performance and Load Testing:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// LoadTest runs election algorithms under high message volume</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> LoadTestElections</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cluster </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewTestCluster</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// 10-node cluster</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> cluster.</span><span style=\"color:#B392F0\">Cleanup</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Generate background message load</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        go</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                // Send random messages between nodes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                cluster.</span><span style=\"color:#B392F0\">SendRandomMessage</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                time.</span><span style=\"color:#B392F0\">Sleep</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Millisecond)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Run 50 consecutive elections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 50</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        leader </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cluster.</span><span style=\"color:#B392F0\">GetCurrentLeader</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cluster.</span><span style=\"color:#B392F0\">SimulateFailure</span><span style=\"color:#E1E4E8\">(leader)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        newLeader, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> cluster.</span><span style=\"color:#B392F0\">WaitForElection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        require.</span><span style=\"color:#B392F0\">NoError</span><span style=\"color:#E1E4E8\">(t, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        require.</span><span style=\"color:#B392F0\">NotEqual</span><span style=\"color:#E1E4E8\">(t, leader, newLeader)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Verify election completed correctly under load</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cluster.</span><span style=\"color:#B392F0\">ValidateLeadershipConsistency</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>This testing infrastructure provides comprehensive validation coverage for all project milestones while enabling both automated testing and manual verification of distributed leader election behavior.</p>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - systematic troubleshooting approach for node communication (Milestone 1), bully election correctness (Milestone 2), ring election reliability (Milestone 3), and integration issues across all components</p>\n</blockquote>\n<p>Distributed leader election systems present unique debugging challenges because failures often manifest as subtle timing issues, message ordering problems, or complex interactions between multiple nodes. Unlike traditional single-process applications where stack traces and debuggers provide clear failure paths, distributed systems require a systematic approach to correlate events across multiple nodes, understand the temporal relationships between messages, and identify root causes that may be separated in time and space from their visible symptoms.</p>\n<h3 id=\"mental-model-detective-work-with-multiple-witnesses\">Mental Model: Detective Work with Multiple Witnesses</h3>\n<p>Think of debugging a distributed leader election system like solving a crime with multiple witnesses who each saw different parts of the story. Each node is a witness that observed certain events (messages received, timeouts triggered, state transitions) but has an incomplete picture of what happened across the entire cluster. Your job as the debugging detective is to:</p>\n<ol>\n<li><strong>Collect testimony from all witnesses</strong> - gather logs from every node to understand their individual perspectives</li>\n<li><strong>Establish a timeline</strong> - correlate timestamps across nodes to understand the sequence of events</li>\n<li><strong>Identify inconsistencies</strong> - look for places where different nodes have conflicting views of reality</li>\n<li><strong>Trace the chain of causation</strong> - follow how one event (like a network partition) led to downstream effects (like split-brain)</li>\n<li><strong>Reconstruct the complete story</strong> - piece together what actually happened from the distributed evidence</li>\n</ol>\n<p>The key insight is that no single node has the complete picture. A network partition might look like &quot;leader stopped responding&quot; from one side and &quot;followers became unreachable&quot; from the other side. Only by combining perspectives can you understand that the network split, creating two isolated groups.</p>\n<h3 id=\"symptom-cause-fix-reference\">Symptom-Cause-Fix Reference</h3>\n<p>The following table provides a systematic approach to diagnosing common leader election problems. Each entry maps observable symptoms to their most likely root causes, provides specific diagnostic steps, and suggests concrete fixes.</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Root Cause</th>\n<th>Diagnostic Steps</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>No leader elected after cluster starts</td>\n<td>Bootstrap election never initiated</td>\n<td>Check if any node has <code>StateFollower</code> and no <code>currentLeader</code> set; verify <code>ElectionTrigger</code> with <code>TriggerStartup</code> was generated</td>\n<td>Add bootstrap logic in cluster initialization: <code>ProcessElectionTrigger(ElectionTrigger{Type: TriggerStartup, NodeID: nodeID, Timestamp: time.Now().UnixNano()})</code></td>\n</tr>\n<tr>\n<td>Elections start but never complete</td>\n<td>Election messages not reaching higher-ID nodes</td>\n<td>Examine transport layer logs for <code>SendMessage</code> failures to specific nodes; check <code>ClusterMembership.activeMembers</code> for missing high-ID nodes</td>\n<td>Fix node discovery mechanism; ensure <code>UpdateMembership</code> includes all cluster nodes; verify TCP connectivity to high-ID nodes</td>\n</tr>\n<tr>\n<td>Multiple nodes claim leadership simultaneously</td>\n<td>Split-brain during network partition</td>\n<td>Check if cluster split into multiple groups by analyzing <code>HeartbeatMessage</code> delivery patterns; verify each group elected separate leaders</td>\n<td>Implement quorum-based election: only allow leadership if <code>CanElectLeader()</code> returns true based on majority membership</td>\n</tr>\n<tr>\n<td>Bully elections timeout with no responses</td>\n<td>Higher-ID nodes crashed or partitioned</td>\n<td>Use <code>FailureDetector.CheckForFailures()</code> to identify unresponsive nodes; verify <code>ElectionMessage</code> sent to correct node IDs</td>\n<td>Remove failed nodes from <code>ClusterMembership</code> before election; implement adaptive timeouts with <code>AdaptiveTimeoutManager</code></td>\n</tr>\n<tr>\n<td>Ring elections circulate forever</td>\n<td>Token never returns to initiator</td>\n<td>Trace <code>RingToken.Participants</code> growth around ring; check if <code>findNextLiveNode</code> skipping failed nodes correctly; verify <code>Complete</code> field set when token returns to initiator</td>\n<td>Fix ring topology with <code>RebuildRing()</code> after failures; add hop count limit to detect broken rings; ensure <code>Complete</code> flag set when <code>InitiatorID</code> receives own token</td>\n</tr>\n<tr>\n<td>Rapid succession of elections (election storm)</td>\n<td>Cascading failures during recovery</td>\n<td>Monitor <code>ElectionRecord</code> timing; check if new elections start before previous ones complete; look for <code>CascadeDetector</code> warnings</td>\n<td>Implement election backoff: delay new elections exponentially; use <code>ElectionState.activeElectionID</code> to prevent concurrent elections; add cooling period after failed elections</td>\n</tr>\n<tr>\n<td>Leader elected but immediately steps down</td>\n<td>Term conflicts or immediate re-election</td>\n<td>Check <code>LeadershipManager.currentTerm</code> consistency; verify no higher-term messages arriving immediately after election</td>\n<td>Ensure term increment before election; validate term numbers in all messages; implement graceful leadership transition with state synchronization</td>\n</tr>\n<tr>\n<td>Nodes receive messages out of order</td>\n<td>Network reordering or delayed delivery</td>\n<td>Compare <code>Message.Timestamp</code> with processing order; check <code>MessageSequencer</code> queue states; verify sequence numbers in logs</td>\n<td>Enable message sequencing with proper ordering; add sequence numbers to all message types; implement reorder buffers in transport layer</td>\n</tr>\n<tr>\n<td>Elections succeed but leader doesn&#39;t perform duties</td>\n<td><code>LeadershipManager</code> not starting after election</td>\n<td>Verify <code>AssumeLeadership</code> called after election victory; check if <code>SendHeartbeat</code> and coordination handlers started</td>\n<td>Call <code>AssumeLeadership</code> immediately after <code>CoordinatorMessage</code> broadcast; start heartbeat ticker and register coordination handlers</td>\n</tr>\n<tr>\n<td>False failure detection triggers unnecessary elections</td>\n<td>Aggressive timeout values or network latency spikes</td>\n<td>Analyze <code>HeartbeatMessage</code> delivery times vs <code>FailureDetector</code> timeout; check for network latency patterns; verify suspicion levels before declaring failures</td>\n<td>Tune failure detection timeouts; implement graduated suspicion with <code>IncreaseSuspicion</code>; use adaptive timeouts based on observed network conditions</td>\n</tr>\n<tr>\n<td>Node rejoining cluster disrupts stable leadership</td>\n<td>Rejoining node triggers election unnecessarily</td>\n<td>Check if rejoining node has stale term number; verify membership updates don&#39;t trigger elections; ensure graceful reintegration</td>\n<td>Update rejoining node&#39;s term to current leader&#39;s term; implement graceful re-joining that doesn&#39;t disrupt stable leadership</td>\n</tr>\n<tr>\n<td>Elections work in testing but fail in production</td>\n<td>Race conditions under real network delays</td>\n<td>Run tests with realistic network delays; enable fault injection with message reordering; test with multiple concurrent elections</td>\n<td>Add proper synchronization around state transitions; implement atomic operations for critical sections; test under various network conditions</td>\n</tr>\n</tbody></table>\n<p>This reference table covers the most common failure scenarios encountered when implementing leader election systems. Each symptom typically has a specific debugging approach that leads to the root cause and a concrete fix.</p>\n<h3 id=\"debugging-strategies\">Debugging Strategies</h3>\n<p>Effective debugging of distributed leader election systems requires a combination of observational techniques, state inspection tools, and systematic investigation approaches. The following strategies provide a methodical framework for identifying and resolving issues across the distributed system.</p>\n<p><strong>State Correlation Across Nodes</strong></p>\n<p>The most powerful debugging technique for distributed systems is correlating state across multiple nodes at specific points in time. Each node maintains its own view of the cluster state through <code>ElectionState</code>, <code>ClusterMembership</code>, and algorithm-specific state in <code>BullyElection</code> or <code>RingElection</code>. Inconsistencies between these views often reveal the root cause of election failures.</p>\n<p>To perform state correlation effectively, capture snapshots of key state at regular intervals and during significant events. The <code>ElectionState</code> should show each node&#39;s view of the current leader, term, and election status. The <code>ClusterMembership</code> reveals which nodes each node believes are alive. Algorithm-specific state like <code>RingTopology.successorMap</code> shows whether nodes agree on ring structure.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: Distributed bugs often manifest as state inconsistencies between nodes. A node that believes it&#39;s the leader while others don&#39;t recognize its authority indicates a coordination failure that can be traced through message logs.</p>\n</blockquote>\n<p><strong>Message Flow Analysis</strong></p>\n<p>Message flow analysis involves tracing the complete path of election messages through the cluster to identify where the protocol deviates from expected behavior. This is particularly valuable for debugging complex scenarios like concurrent elections or message reordering.</p>\n<p>Start by identifying a specific election using its <code>ElectionMessage.ElectionID</code>, then trace all related messages chronologically across all nodes. For bully elections, verify that <code>ElectionMessage</code> instances reach all higher-ID nodes, <code>OKMessage</code> responses return to the initiator, and <code>CoordinatorMessage</code> broadcasts reach all nodes. For ring elections, follow the <code>RingToken</code> as it travels around the ring, checking that <code>Participants</code> grows correctly and the token eventually returns to the initiator.</p>\n<p><strong>Timing Analysis and Race Condition Detection</strong></p>\n<p>Many leader election bugs stem from timing issues where the order of operations differs from expected behavior. Race conditions can cause scenarios like multiple nodes starting elections simultaneously or messages arriving after timeouts have already fired.</p>\n<p>Analyze timing by comparing <code>Message.Timestamp</code> values across the cluster with local event timestamps. Look for patterns where timeouts fire just before expected messages arrive, or where concurrent operations create unexpected interleavings. The <code>ElectionTimeoutManager</code> logs provide insight into when timeouts were set, fired, or canceled.</p>\n<p><strong>Transport Layer Inspection</strong></p>\n<p>Since all inter-node communication flows through the <code>Transport</code> interface, transport layer problems can cause symptoms that appear to be election algorithm bugs. Network partitions, message loss, and delivery delays all manifest as election failures.</p>\n<p>Inspect transport layer behavior by examining message delivery patterns. Verify that <code>SendMessage</code> calls succeed and that <code>ReceiveMessages</code> delivers messages in reasonable time. Look for patterns where messages to specific nodes consistently fail, indicating network connectivity issues. Check whether <code>BroadcastMessage</code> reaches all intended recipients.</p>\n<p><strong>Failure Injection and Reproducibility</strong></p>\n<p>Many distributed systems bugs only occur under specific timing or failure conditions that are difficult to reproduce naturally. Controlled failure injection helps reproduce problems consistently and validate fixes.</p>\n<p>Use <code>TestTransport</code> with configurable <code>DeliveryRule</code> settings to inject message delays, drops, and reordering. Simulate node failures at specific points in the election process. Create network partitions that isolate different subsets of nodes. This systematic approach helps identify edge cases and validate the robustness of error handling code.</p>\n<p><strong>Component Isolation Testing</strong></p>\n<p>When facing complex integration issues, isolate individual components to determine whether problems originate in specific subsystems or their interactions. Test the <code>FailureDetector</code>, <code>ClusterMembership</code>, and election algorithms separately before debugging their integration.</p>\n<p>For example, test whether <code>FailureDetector.CheckForFailures()</code> correctly identifies unresponsive nodes independent of election logic. Verify that <code>ClusterMembership.UpdateMembership()</code> maintains consistent member lists. Validate that <code>BullyElection.StartElection()</code> sends correct messages when membership is stable. This approach narrows down the problem domain significantly.</p>\n<p>The following table summarizes these debugging strategies with specific techniques and tools:</p>\n<table>\n<thead>\n<tr>\n<th>Strategy</th>\n<th>Technique</th>\n<th>Tools/Methods</th>\n<th>When to Use</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>State Correlation</td>\n<td>Compare node states at same logical time</td>\n<td>Snapshot <code>ElectionState</code>, <code>ClusterMembership</code> across nodes</td>\n<td>Multiple nodes disagree on leader or membership</td>\n</tr>\n<tr>\n<td>Message Flow Analysis</td>\n<td>Trace election messages chronologically</td>\n<td>Filter logs by <code>ElectionID</code>, correlate timestamps</td>\n<td>Elections start but don&#39;t complete properly</td>\n</tr>\n<tr>\n<td>Timing Analysis</td>\n<td>Identify race conditions and ordering issues</td>\n<td>Compare <code>Message.Timestamp</code> with local events</td>\n<td>Intermittent failures or timing-dependent bugs</td>\n</tr>\n<tr>\n<td>Transport Inspection</td>\n<td>Examine message delivery patterns</td>\n<td>Monitor <code>SendMessage</code>/<code>ReceiveMessages</code> success rates</td>\n<td>Messages appear lost or delayed</td>\n</tr>\n<tr>\n<td>Failure Injection</td>\n<td>Reproduce bugs with controlled failures</td>\n<td>Use <code>TestTransport</code> with fault injection</td>\n<td>Hard-to-reproduce edge cases</td>\n</tr>\n<tr>\n<td>Component Isolation</td>\n<td>Test subsystems independently</td>\n<td>Unit tests for <code>FailureDetector</code>, <code>ClusterMembership</code></td>\n<td>Complex integration problems</td>\n</tr>\n</tbody></table>\n<h3 id=\"logging-and-observability\">Logging and Observability</h3>\n<p>Effective observability is crucial for debugging distributed leader election systems because problems often involve complex interactions between multiple nodes over time. The logging strategy must capture enough detail to reconstruct distributed execution flows while remaining performant enough for production use.</p>\n<p><strong>Structured Election Event Logging</strong></p>\n<p>All election-related events should use structured logging with consistent field names and formats to enable automated analysis and correlation. Each log entry should include the node ID, timestamp, election ID (when applicable), current term, and current state to provide context for the event.</p>\n<p>Critical events that must always be logged include election initiation (<code>StartElection</code> calls), state transitions (follower to candidate to leader), message sending and receiving, timeout events, and leadership changes. These events form the backbone of election flow analysis and help reconstruct the complete timeline of distributed operations.</p>\n<p>The following table defines the essential log events and their required fields:</p>\n<table>\n<thead>\n<tr>\n<th>Event Type</th>\n<th>Required Fields</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Election Started</td>\n<td>NodeID, ElectionID, Term, Trigger</td>\n<td>Node initiates new election</td>\n<td><code>{&quot;event&quot;: &quot;election_started&quot;, &quot;node&quot;: 3, &quot;election_id&quot;: 12345, &quot;term&quot;: 5, &quot;trigger&quot;: &quot;leader_failure&quot;}</code></td>\n</tr>\n<tr>\n<td>Message Sent</td>\n<td>NodeID, MessageType, Target, ElectionID, Term</td>\n<td>Outgoing election message</td>\n<td><code>{&quot;event&quot;: &quot;message_sent&quot;, &quot;node&quot;: 3, &quot;type&quot;: &quot;ELECTION&quot;, &quot;target&quot;: 5, &quot;election_id&quot;: 12345}</code></td>\n</tr>\n<tr>\n<td>Message Received</td>\n<td>NodeID, MessageType, Source, ElectionID, Term</td>\n<td>Incoming election message</td>\n<td><code>{&quot;event&quot;: &quot;message_received&quot;, &quot;node&quot;: 5, &quot;type&quot;: &quot;ELECTION&quot;, &quot;source&quot;: 3, &quot;election_id&quot;: 12345}</code></td>\n</tr>\n<tr>\n<td>State Transition</td>\n<td>NodeID, OldState, NewState, Term, Reason</td>\n<td>Node state changes</td>\n<td><code>{&quot;event&quot;: &quot;state_transition&quot;, &quot;node&quot;: 3, &quot;old_state&quot;: &quot;Follower&quot;, &quot;new_state&quot;: &quot;Candidate&quot;, &quot;term&quot;: 5}</code></td>\n</tr>\n<tr>\n<td>Leader Change</td>\n<td>NodeID, OldLeader, NewLeader, Term, ElectionID</td>\n<td>Leadership change detected</td>\n<td><code>{&quot;event&quot;: &quot;leader_change&quot;, &quot;node&quot;: 3, &quot;old_leader&quot;: 7, &quot;new_leader&quot;: 5, &quot;term&quot;: 6}</code></td>\n</tr>\n<tr>\n<td>Timeout Event</td>\n<td>NodeID, TimeoutType, ElectionID, Duration</td>\n<td>Timeout fired or canceled</td>\n<td><code>{&quot;event&quot;: &quot;timeout&quot;, &quot;node&quot;: 3, &quot;type&quot;: &quot;election_timeout&quot;, &quot;election_id&quot;: 12345, &quot;duration&quot;: &quot;2s&quot;}</code></td>\n</tr>\n<tr>\n<td>Failure Detected</td>\n<td>NodeID, FailedNode, SuspicionLevel, Method</td>\n<td>Node failure detection</td>\n<td><code>{&quot;event&quot;: &quot;failure_detected&quot;, &quot;node&quot;: 3, &quot;failed_node&quot;: 7, &quot;suspicion&quot;: 3, &quot;method&quot;: &quot;heartbeat_timeout&quot;}</code></td>\n</tr>\n</tbody></table>\n<p><strong>Cross-Node Message Correlation</strong></p>\n<p>To trace message flows across the distributed system, each message must include correlation identifiers that link related events on different nodes. The <code>Message.ElectionID</code> serves as the primary correlation key for election-related messages, while <code>Message.Term</code> provides ordering context.</p>\n<p>When logging message events, always include both the local perspective (what this node did) and the remote context (what election or term this relates to). This dual perspective enables reconstruction of distributed message flows by joining log entries from different nodes on shared correlation IDs.</p>\n<p>Implement message correlation logging in the <code>Transport</code> layer so it&#39;s captured consistently regardless of which election algorithm generates the messages. Log both successful message delivery and failures, including timeout and network error details.</p>\n<p><strong>Performance and Resource Monitoring</strong></p>\n<p>Leader election performance directly impacts cluster availability, so monitoring election timing, message volume, and resource usage is essential for both debugging and operational health. Track metrics like election duration, message count per election, timeout frequency, and failure detection accuracy.</p>\n<p>Key performance metrics to monitor include:</p>\n<ul>\n<li>Election completion time (from initiation to coordinator announcement)</li>\n<li>Message volume per election (total messages sent/received)</li>\n<li>Timeout frequency (how often elections timeout without completion)</li>\n<li>False positive rate (failures detected but node was actually alive)</li>\n<li>Leadership stability (how long leaders remain in power)</li>\n</ul>\n<p>These metrics help identify performance problems and validate that optimizations don&#39;t introduce correctness issues.</p>\n<p><strong>Distributed Tracing for Election Flows</strong></p>\n<p>For complex debugging scenarios, implement distributed tracing that follows individual elections across all participating nodes. Each election gets a unique trace ID (the <code>ElectionID</code>), and all related operations on all nodes contribute spans to that trace.</p>\n<p>A complete election trace includes spans for election initiation, message sending/receiving, timeout management, state transitions, and coordinator announcement. This provides a visual timeline of how an election progresses through the distributed system and helps identify bottlenecks or failure points.</p>\n<p><strong>Log Aggregation and Analysis</strong></p>\n<p>In production deployments with multiple nodes, log aggregation becomes essential for effective debugging. All nodes should ship logs to a centralized system where they can be correlated by timestamp and election ID.</p>\n<p>Implement log analysis tools that can automatically identify common failure patterns like election storms, split-brain scenarios, and cascading failures. These tools should parse structured logs, correlate events across nodes, and generate summaries of election behavior over time.</p>\n<p>The following table outlines the recommended log levels and their appropriate use:</p>\n<table>\n<thead>\n<tr>\n<th>Log Level</th>\n<th>Usage</th>\n<th>Examples</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ERROR</td>\n<td>Critical failures that prevent elections</td>\n<td>Failed to send election message, corrupted state</td>\n<td>Minimal - rare events</td>\n</tr>\n<tr>\n<td>WARN</td>\n<td>Recoverable issues or suspicious conditions</td>\n<td>Election timeout, potential split-brain detected</td>\n<td>Low - occasional events</td>\n</tr>\n<tr>\n<td>INFO</td>\n<td>Normal election events and state changes</td>\n<td>Election started, leader elected, state transitions</td>\n<td>Moderate - regular events</td>\n</tr>\n<tr>\n<td>DEBUG</td>\n<td>Detailed message flows and internal state</td>\n<td>Message contents, membership updates, ring topology</td>\n<td>High - verbose logging</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>Fine-grained debugging information</td>\n<td>Function entry/exit, detailed state snapshots</td>\n<td>Very high - development only</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical tools and code structures for implementing effective debugging capabilities in your leader election system. The focus is on building observability and diagnostic capabilities that work across distributed nodes.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Logging</td>\n<td><code>log/slog</code> with JSON formatting</td>\n<td>Structured logging with OpenTelemetry</td>\n</tr>\n<tr>\n<td>Metrics</td>\n<td>Simple counters with periodic output</td>\n<td>Prometheus metrics with Grafana dashboards</td>\n</tr>\n<tr>\n<td>Tracing</td>\n<td>Basic correlation IDs in logs</td>\n<td>Distributed tracing with Jaeger</td>\n</tr>\n<tr>\n<td>Log Analysis</td>\n<td>grep/jq for log correlation</td>\n<td>ELK stack or similar log aggregation</td>\n</tr>\n</tbody></table>\n<h4 id=\"structured-logging-infrastructure\">Structured Logging Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> main</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">log/slog</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ElectionLogger provides structured logging for election events</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ElectionLogger</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">slog</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Logger</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewElectionLogger creates a logger with node context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewElectionLogger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionLogger</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    opts </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">slog</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">HandlerOptions</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Level: slog.LevelInfo,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        AddSource: </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    handler </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> slog.</span><span style=\"color:#B392F0\">NewJSONHandler</span><span style=\"color:#E1E4E8\">(os.Stdout, opts)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> slog.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">(handler)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ElectionLogger</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        logger: logger.</span><span style=\"color:#B392F0\">With</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"node_id\"</span><span style=\"color:#E1E4E8\">, nodeID),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nodeID: nodeID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LogElectionStarted records election initiation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">el </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">LogElectionStarted</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">electionID</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">term</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">trigger</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    el.logger.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"election_started\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"election_id\"</span><span style=\"color:#E1E4E8\">, electionID,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"term\"</span><span style=\"color:#E1E4E8\">, term,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"trigger\"</span><span style=\"color:#E1E4E8\">, trigger,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"timestamp\"</span><span style=\"color:#E1E4E8\">, time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UnixNano</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LogMessageSent records outgoing election message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">el </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">LogMessageSent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msgType</span><span style=\"color:#B392F0\"> MessageType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">electionID</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    el.logger.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"message_sent\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"message_type\"</span><span style=\"color:#E1E4E8\">, msgType,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"target_node\"</span><span style=\"color:#E1E4E8\">, target,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"election_id\"</span><span style=\"color:#E1E4E8\">, electionID,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"timestamp\"</span><span style=\"color:#E1E4E8\">, time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UnixNano</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// LogStateTransition records node state changes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">el </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionLogger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">LogStateTransition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">oldState</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">newState</span><span style=\"color:#B392F0\"> NodeState</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">term</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    el.logger.</span><span style=\"color:#B392F0\">Info</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"state_transition\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"old_state\"</span><span style=\"color:#E1E4E8\">, oldState,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"new_state\"</span><span style=\"color:#E1E4E8\">, newState,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"term\"</span><span style=\"color:#E1E4E8\">, term,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"reason\"</span><span style=\"color:#E1E4E8\">, reason,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"timestamp\"</span><span style=\"color:#E1E4E8\">, time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UnixNano</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"debug-state-snapshot-utilities\">Debug State Snapshot Utilities</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> main</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NodeStateSnapshot captures complete node state for debugging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> NodeStateSnapshot</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NodeID           </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\">                 `json:\"node_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp        </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">                  `json:\"timestamp\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ElectionState    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionState</span><span style=\"color:#9ECBFF\">         `json:\"election_state\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Membership       []</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\">               `json:\"active_members\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RingTopology     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\">      `json:\"ring_successors,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PendingMessages  </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">                    `json:\"pending_messages\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastSeen         </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">       `json:\"last_seen\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DebugStateCollector gathers state snapshots across cluster</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DebugStateCollector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    snapshots </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NodeStateSnapshot</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu        </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewDebugStateCollector creates collector for state debugging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewDebugStateCollector</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DebugStateCollector</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">DebugStateCollector</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        snapshots: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">NodeStateSnapshot</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CaptureSnapshot records current node state</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">dsc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DebugStateCollector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CaptureSnapshot</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">coordinator</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ElectionCoordinator</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Extract current election state from coordinator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Get active membership list from ClusterMembership</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Capture ring topology if using ring election</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Count pending messages in transport queues</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Record last seen timestamps for failure detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    snapshot </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">NodeStateSnapshot</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        NodeID:    coordinator.nodeID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Timestamp: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UnixNano</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Fill in other fields based on coordinator state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dsc.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dsc.snapshots[coordinator.nodeID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> snapshot</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dsc.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CompareStates identifies inconsistencies between node states</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">dsc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DebugStateCollector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CompareStates</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Compare election states - do all nodes agree on current leader?</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Compare membership views - do all nodes see same active members?</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Compare ring topology - is ring structure consistent?</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Identify nodes with stale or inconsistent state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inconsistencies </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dsc.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> dsc.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Implementation provides framework for state comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> inconsistencies</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"message-flow-tracer\">Message Flow Tracer</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> main</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MessageTrace represents a single message in an election flow</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MessageTrace</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ElectionID  </span><span style=\"color:#F97583\">uint64</span><span style=\"color:#9ECBFF\">      `json:\"election_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MessageType </span><span style=\"color:#B392F0\">MessageType</span><span style=\"color:#9ECBFF\"> `json:\"message_type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Source      </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\">      `json:\"source\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Target      </span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#9ECBFF\">      `json:\"target\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp   </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">       `json:\"timestamp\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Success     </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">        `json:\"success\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Error       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"error,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ElectionFlowTracer tracks message flows for debugging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ElectionFlowTracer</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    traces </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageTrace</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu     </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewElectionFlowTracer creates tracer for election debugging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewElectionFlowTracer</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionFlowTracer</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ElectionFlowTracer</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        traces: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MessageTrace</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TraceMessageSent records outgoing message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">eft </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionFlowTracer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TraceMessageSent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">electionID</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msgType</span><span style=\"color:#B392F0\"> MessageType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">source</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    trace </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">MessageTrace</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ElectionID:  electionID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        MessageType: msgType,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Source:      source,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Target:      target,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Timestamp:   time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">UnixNano</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Success:     </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eft.mu.</span><span style=\"color:#B392F0\">Lock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eft.traces[electionID] </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(eft.traces[electionID], trace)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eft.mu.</span><span style=\"color:#B392F0\">Unlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AnalyzeElectionFlow identifies problems in message sequences</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">eft </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionFlowTracer</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AnalyzeElectionFlow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">electionID</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if all expected messages were sent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify message ordering matches algorithm requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Identify missing acknowledgments or coordinator messages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Detect timing issues like messages sent after timeouts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    issues </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eft.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    traces </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> eft.traces[electionID]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eft.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Framework for analyzing message flow patterns</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> issues</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"fault-injection-testing-framework\">Fault Injection Testing Framework</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> main</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">math/rand</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FaultInjector enables controlled failure scenarios for testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FaultInjector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dropRate    </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    delayRange  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    partitions  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    enabled     </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewFaultInjector creates configurable fault injection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewFaultInjector</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FaultInjector</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">FaultInjector</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        partitions: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        enabled:    </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EnableMessageDrop configures message loss simulation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fi </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FaultInjector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">EnableMessageDrop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rate</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Set drop rate for random message loss</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Enable fault injection in transport layer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fi.dropRate </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> rate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fi.enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateNetworkPartition simulates cluster split</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fi </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FaultInjector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateNetworkPartition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">groups</span><span style=\"color:#E1E4E8\"> [][]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Configure which nodes can communicate with each other</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Block messages between different partition groups</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update transport routing to respect partitions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fi.partitions </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, group </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> groups {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _, node </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> group {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            fi.partitions[node] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> group</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ShouldDropMessage determines if message should be lost</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">fi </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">FaultInjector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ShouldDropMessage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">source</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">fi.enabled {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check partition rules - can source reach target?</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Apply random drop rate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return true if message should be dropped</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> rand.</span><span style=\"color:#B392F0\">Float64</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> fi.dropRate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-debugging-checkpoints\">Milestone Debugging Checkpoints</h4>\n<p><strong>Milestone 1 Validation (Node Communication)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test basic messaging</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/node/main.go</span><span style=\"color:#79B8FF\"> --id=1</span><span style=\"color:#79B8FF\"> --peers=2,3</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/node/main.go</span><span style=\"color:#79B8FF\"> --id=2</span><span style=\"color:#79B8FF\"> --peers=1,3</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/node/main.go</span><span style=\"color:#79B8FF\"> --id=3</span><span style=\"color:#79B8FF\"> --peers=1,2</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: All nodes discover each other and establish heartbeats</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check logs for: \"membership_updated\", \"heartbeat_sent\", \"heartbeat_received\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test failure detection</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">kill</span><span style=\"color:#79B8FF\"> -STOP</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> \"id=3\"</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Simulate node 3 failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Nodes 1 and 2 detect node 3 failure within timeout period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check logs for: \"failure_detected\", \"membership_updated\" removing node 3</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Validation (Bully Election)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start cluster with node 3 as initial leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Kill leader to trigger bully election</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">kill</span><span style=\"color:#79B8FF\"> -TERM</span><span style=\"color:#E1E4E8\"> $(</span><span style=\"color:#B392F0\">pgrep</span><span style=\"color:#79B8FF\"> -f</span><span style=\"color:#9ECBFF\"> \"id=3\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Node 2 (highest remaining ID) becomes new leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check logs for proper message sequence:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 1. \"failure_detected\" on nodes 1,2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 2. \"election_started\" from node with highest ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 3. \"message_sent\" ELECTION messages to higher nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 4. \"message_sent\" COORDINATOR from winner</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 5. \"leader_change\" on all nodes</span></span></code></pre></div>\n\n<p><strong>Milestone 3 Validation (Ring Election)</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Configure ring topology: 1→2→3→1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Trigger ring election from node 1</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8001/debug/start-election</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected: Token circulates through ring and node 3 wins</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Check logs for:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 1. \"ring_election_started\" with initial token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 2. \"token_forwarded\" as token travels ring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 3. \"participants_updated\" as nodes join token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 4. \"election_completed\" when token returns to initiator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># 5. \"coordinator_announced\" with highest-ID winner</span></span></code></pre></div>\n\n<h4 id=\"common-debugging-symptoms-and-fixes\">Common Debugging Symptoms and Fixes</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Debug Command</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Elections never start</td>\n<td><code>grep &quot;election_started&quot; *.log</code></td>\n<td>Check failure detection and trigger logic</td>\n</tr>\n<tr>\n<td>Messages not delivered</td>\n<td><code>grep &quot;message_sent|message_received&quot; *.log | sort</code></td>\n<td>Verify transport layer and network connectivity</td>\n</tr>\n<tr>\n<td>Split-brain detected</td>\n<td><code>grep &quot;leader_change&quot; *.log | uniq</code></td>\n<td>Implement quorum-based elections</td>\n</tr>\n<tr>\n<td>Ring election loops</td>\n<td><code>grep &quot;token_forwarded&quot; *.log | tail -20</code></td>\n<td>Fix ring topology and add hop limits</td>\n</tr>\n</tbody></table>\n<h2 id=\"future-extensions-and-improvements\">Future Extensions and Improvements</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Extension beyond all milestones - advanced features and optimizations that could be added to enhance the basic leader election system after completing node communication (Milestone 1), bully algorithm (Milestone 2), and ring election (Milestone 3)</p>\n</blockquote>\n<p>After implementing the foundational leader election algorithms and node communication infrastructure, numerous opportunities emerge to enhance performance, reliability, and operational capabilities. This section explores advanced optimizations, alternative algorithms, and production-readiness features that transform a basic leader election system into an enterprise-grade distributed coordination service.</p>\n<h3 id=\"performance-improvements\">Performance Improvements</h3>\n<p>The basic bully and ring election algorithms prioritize correctness and simplicity over performance. However, several optimization strategies can dramatically reduce election latency, network overhead, and system resource consumption while maintaining correctness guarantees.</p>\n<h4 id=\"adaptive-timeout-management\">Adaptive Timeout Management</h4>\n<p>Traditional election algorithms use fixed timeouts for failure detection and election phases. This approach creates a fundamental trade-off: short timeouts enable fast failure detection but increase false positives during network congestion, while long timeouts reduce false positives but slow down legitimate elections.</p>\n<blockquote>\n<p><strong>Decision: Implement Adaptive Timeout Management</strong></p>\n<ul>\n<li><strong>Context</strong>: Fixed timeouts cannot adapt to varying network conditions, cluster sizes, and load patterns, leading to either unnecessary elections or slow failure recovery</li>\n<li><strong>Options Considered</strong>: Fixed conservative timeouts, fixed aggressive timeouts, adaptive timeout adjustment</li>\n<li><strong>Decision</strong>: Implement adaptive timeout management that adjusts based on observed network behavior</li>\n<li><strong>Rationale</strong>: Network conditions vary dramatically in real deployments - adaptive timeouts maintain responsiveness during normal operation while preventing election storms during congestion</li>\n<li><strong>Consequences</strong>: Reduces false failure detections by 70-90% while maintaining sub-second failure detection during actual node crashes</li>\n</ul>\n</blockquote>\n<p>The <code>AdaptiveTimeoutManager</code> tracks recent election success rates, network round-trip times, and failure patterns to dynamically adjust timeout values. When elections frequently succeed within the timeout window, the system gradually reduces timeouts to improve responsiveness. Conversely, when elections time out frequently or network latency increases, timeouts are extended to prevent unnecessary re-elections.</p>\n<table>\n<thead>\n<tr>\n<th>Metric</th>\n<th>Threshold</th>\n<th>Timeout Adjustment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Election success rate &gt; 90%</td>\n<td>Last 10 elections</td>\n<td>Decrease timeout by 10% (min: baseTimeout/2)</td>\n</tr>\n<tr>\n<td>Election success rate &lt; 60%</td>\n<td>Last 10 elections</td>\n<td>Increase timeout by 25% (max: baseTimeout*3)</td>\n</tr>\n<tr>\n<td>Average RTT increase &gt; 50%</td>\n<td>Rolling 60-second window</td>\n<td>Set timeout to 3*RTT + base processing time</td>\n</tr>\n<tr>\n<td>Cascade failure detected</td>\n<td>3+ failures in 30 seconds</td>\n<td>Triple timeout for next 5 minutes</td>\n</tr>\n</tbody></table>\n<h4 id=\"batched-message-delivery\">Batched Message Delivery</h4>\n<p>Standard election algorithms send individual messages for each election phase, creating significant network overhead in large clusters. A node participating in a bully election might send separate <code>ElectionMessage</code> instances to 20 higher-ID nodes, then receive individual <code>OKMessage</code> responses, generating 40+ network round-trips.</p>\n<p>Batched message delivery aggregates multiple election messages into single network transmissions, reducing both network overhead and processing latency. The <code>MessageBatcher</code> collects outgoing messages over a brief window (typically 5-50ms) and combines them into batch transmissions.</p>\n<table>\n<thead>\n<tr>\n<th>Batching Strategy</th>\n<th>Description</th>\n<th>Network Reduction</th>\n<th>Latency Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Time-based batching</td>\n<td>Collect messages for fixed duration</td>\n<td>60-80% fewer packets</td>\n<td>+10-50ms per batch</td>\n</tr>\n<tr>\n<td>Size-based batching</td>\n<td>Send when batch reaches target size</td>\n<td>70-90% fewer packets</td>\n<td>Variable (0-100ms)</td>\n</tr>\n<tr>\n<td>Adaptive batching</td>\n<td>Adjust window based on message rate</td>\n<td>65-85% fewer packets</td>\n<td>+5-30ms average</td>\n</tr>\n</tbody></table>\n<p>The adaptive approach monitors message transmission patterns and adjusts batching windows dynamically. During election storms with high message rates, larger batches reduce network congestion. During normal operation with sparse messages, smaller batches maintain low latency.</p>\n<h4 id=\"concurrent-election-resolution\">Concurrent Election Resolution</h4>\n<p>Multiple concurrent elections create significant inefficiency in standard algorithms. When several nodes simultaneously detect leader failure, each initiates independent elections that often interfere with each other. The <code>ConcurrentElectionResolver</code> implements several strategies to minimize this overhead.</p>\n<p><strong>Election Coordination Strategy</strong>: When a node receives an <code>ElectionMessage</code> while conducting its own election, it compares election IDs and election terms. Lower-priority elections are immediately abandoned in favor of higher-priority ones, preventing redundant network traffic and state transitions.</p>\n<table>\n<thead>\n<tr>\n<th>Concurrent Election Scenario</th>\n<th>Standard Behavior</th>\n<th>Optimized Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>3 nodes detect failure simultaneously</td>\n<td>3 separate elections, potential conflicts</td>\n<td>Highest-priority election proceeds, others abort</td>\n</tr>\n<tr>\n<td>Election in progress when new failure detected</td>\n<td>New election interrupts existing one</td>\n<td>Existing election incorporates new failure</td>\n</tr>\n<tr>\n<td>Network partition heals during election</td>\n<td>Conflicting elections in each partition</td>\n<td>Term-based resolution, single election continues</td>\n</tr>\n</tbody></table>\n<p><strong>Pre-emptive Leader Selection</strong>: Instead of waiting for complete election protocols, nodes can pre-emptively identify the likely winner based on current cluster membership and immediately begin following that node. This optimization reduces election latency by 40-70% in large clusters.</p>\n<h4 id=\"optimized-ring-maintenance\">Optimized Ring Maintenance</h4>\n<p>Ring election performance degrades significantly when the logical ring requires frequent reconstruction due to node failures and additions. Traditional ring algorithms rebuild the entire ring structure whenever membership changes, creating O(n²) complexity in dynamic environments.</p>\n<p>The optimized <code>RingTopologyManager</code> maintains incremental ring updates using a versioned ring structure. When nodes join or leave, only the affected ring segments are updated, preserving most of the existing topology.</p>\n<table>\n<thead>\n<tr>\n<th>Ring Operation</th>\n<th>Standard Complexity</th>\n<th>Optimized Complexity</th>\n<th>Performance Gain</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single node failure</td>\n<td>O(n) rebuild</td>\n<td>O(1) local repair</td>\n<td>10-100x faster</td>\n</tr>\n<tr>\n<td>Multiple node failures</td>\n<td>O(n) per failure</td>\n<td>O(k) for k failures</td>\n<td>2-10x faster</td>\n</tr>\n<tr>\n<td>Node recovery/rejoin</td>\n<td>O(n) rebuild</td>\n<td>O(log n) insertion</td>\n<td>5-50x faster</td>\n</tr>\n<tr>\n<td>Ring traversal</td>\n<td>O(n) every time</td>\n<td>O(1) with caching</td>\n<td>Constant time</td>\n</tr>\n</tbody></table>\n<p><strong>Lazy Ring Repair</strong>: Instead of immediately repairing ring breaks, the system marks failed nodes as &quot;bypassed&quot; and repairs ring connectivity during the next election cycle. This approach prevents expensive ring maintenance operations during cascading failures while ensuring elections can still complete successfully.</p>\n<h3 id=\"other-election-algorithms\">Other Election Algorithms</h3>\n<p>While bully and ring algorithms provide excellent learning foundations, production systems often benefit from more sophisticated election approaches that offer better partition tolerance, lower latency, or stronger consistency guarantees.</p>\n<h4 id=\"raft-leader-election\">Raft Leader Election</h4>\n<p>The Raft consensus algorithm includes a highly optimized leader election protocol that provides stronger safety guarantees than traditional algorithms. Unlike bully elections where any node can claim leadership, Raft leader election requires explicit votes from a majority of nodes.</p>\n<blockquote>\n<p><strong>Decision: Add Raft Leader Election as Advanced Algorithm</strong></p>\n<ul>\n<li><strong>Context</strong>: Bully and ring algorithms can produce split-brain scenarios during network partitions, while Raft provides stronger safety guarantees</li>\n<li><strong>Options Considered</strong>: Pure Raft implementation, simplified Raft election only, hybrid bully-raft approach</li>\n<li><strong>Decision</strong>: Implement Raft leader election protocol with term-based voting</li>\n<li><strong>Rationale</strong>: Raft&#39;s majority-vote requirement prevents split-brain scenarios that plague simpler algorithms, critical for production systems</li>\n<li><strong>Consequences</strong>: Higher network overhead (requires majority votes) but eliminates split-brain risks and provides cleaner partition tolerance</li>\n</ul>\n</blockquote>\n<p>Raft leader election operates through <strong>election terms</strong> - monotonically increasing counters that order elections across time. When a follower node detects leader failure, it increments its term, transitions to candidate state, and requests votes from other nodes. A candidate becomes leader only after receiving votes from a strict majority of the cluster.</p>\n<table>\n<thead>\n<tr>\n<th>Raft Election Phase</th>\n<th>Messages Sent</th>\n<th>Safety Guarantee</th>\n<th>Failure Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Term increment</td>\n<td>None</td>\n<td>Prevents old leaders</td>\n<td>Candidates with stale terms ignored</td>\n</tr>\n<tr>\n<td>Vote request</td>\n<td>RequestVote to all nodes</td>\n<td>Only one vote per term</td>\n<td>Candidate steps down if higher term seen</td>\n</tr>\n<tr>\n<td>Majority collection</td>\n<td>None</td>\n<td>Prevents split elections</td>\n<td>Election fails if majority unavailable</td>\n</tr>\n<tr>\n<td>Leader establishment</td>\n<td>Heartbeat to all nodes</td>\n<td>Single leader per term</td>\n<td>Old leaders step down on higher term</td>\n</tr>\n</tbody></table>\n<p><strong>Vote Splitting Resolution</strong>: When multiple candidates request votes simultaneously, vote splitting can prevent any candidate from achieving a majority. Raft uses randomized election timeouts to reduce this probability - each node waits a random duration before starting elections, making simultaneous candidacy unlikely.</p>\n<h4 id=\"swim-based-failure-detection\">SWIM-based Failure Detection</h4>\n<p>The Scalable Weakly-consistent Infection-style process group Membership (SWIM) protocol provides highly efficient failure detection that scales to thousands of nodes. Unlike heartbeat-based approaches that generate O(n²) network traffic, SWIM achieves O(n) communication complexity with better failure detection accuracy.</p>\n<p>SWIM operates through <strong>infection-style gossip</strong> where failure suspicions spread through the cluster like epidemics. When a node suspects another node has failed, it piggybacks this suspicion on messages to other nodes. Suspicions either get confirmed (leading to member removal) or refuted (leading to suspicion clearing).</p>\n<table>\n<thead>\n<tr>\n<th>SWIM Component</th>\n<th>Purpose</th>\n<th>Network Overhead</th>\n<th>Detection Latency</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Periodic ping</td>\n<td>Detect immediate neighbors</td>\n<td>O(1) per node</td>\n<td>1-2 ping intervals</td>\n</tr>\n<tr>\n<td>Indirect ping</td>\n<td>Verify suspected failures</td>\n<td>O(k) where k=3-5</td>\n<td>2-4 ping intervals</td>\n</tr>\n<tr>\n<td>Gossip dissemination</td>\n<td>Spread membership changes</td>\n<td>O(log n) per change</td>\n<td>log(n) gossip rounds</td>\n</tr>\n<tr>\n<td>Suspicion mechanism</td>\n<td>Avoid false positives</td>\n<td>None</td>\n<td>Configurable window</td>\n</tr>\n</tbody></table>\n<p><strong>Integration with Leader Election</strong>: SWIM failure detection can trigger leader elections much more efficiently than heartbeat-based approaches. When SWIM confirms a leader failure, it can immediately provide the updated membership view to election algorithms, eliminating the membership convergence delay that plagues traditional systems.</p>\n<h4 id=\"weighted-election-algorithms\">Weighted Election Algorithms</h4>\n<p>Production environments often have heterogeneous nodes with different capabilities, network connectivity, or reliability characteristics. Weighted election algorithms consider these factors when selecting leaders, improving overall system performance.</p>\n<p><strong>Capability-based Weighting</strong>: Nodes with higher CPU, memory, or network bandwidth receive higher election weights. This ensures that more capable nodes are preferred as leaders, improving cluster performance.</p>\n<table>\n<thead>\n<tr>\n<th>Weighting Factor</th>\n<th>Measurement Method</th>\n<th>Impact on Election</th>\n<th>Typical Weight Range</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CPU capacity</td>\n<td>Benchmark score or core count</td>\n<td>Higher CPU preferred as leader</td>\n<td>1.0x to 3.0x</td>\n</tr>\n<tr>\n<td>Memory capacity</td>\n<td>Available RAM</td>\n<td>Prefer nodes that can handle large states</td>\n<td>1.0x to 2.0x</td>\n</tr>\n<tr>\n<td>Network bandwidth</td>\n<td>Measured throughput</td>\n<td>Prefer well-connected nodes</td>\n<td>0.5x to 2.0x</td>\n</tr>\n<tr>\n<td>Historical reliability</td>\n<td>Uptime percentage</td>\n<td>Avoid frequently-failing nodes</td>\n<td>0.1x to 1.5x</td>\n</tr>\n</tbody></table>\n<p><strong>Geographic Distribution</strong>: In geographically distributed clusters, leader location significantly impacts client latency. Weighted algorithms can prefer leaders in specific regions or datacenters based on client distribution patterns.</p>\n<h4 id=\"byzantine-fault-tolerant-elections\">Byzantine Fault Tolerant Elections</h4>\n<p>While crash-failure leader election handles node failures and network partitions, some environments require tolerance for <strong>Byzantine failures</strong> where nodes behave arbitrarily or maliciously. Byzantine Fault Tolerant (BFT) leader election protocols can handle up to f Byzantine failures in a cluster of 3f+1 nodes.</p>\n<p>PBFT (Practical Byzantine Fault Tolerance) leader election uses cryptographic signatures and multiple voting rounds to ensure that Byzantine nodes cannot manipulate election outcomes. Each election requires 2f+1 signatures from different nodes, making it computationally infeasible for f Byzantine nodes to forge a false election result.</p>\n<h3 id=\"production-readiness-features\">Production Readiness Features</h3>\n<p>Transitioning from a learning implementation to production deployment requires extensive operational tooling, monitoring capabilities, and configuration management features that enable reliable operation at scale.</p>\n<h4 id=\"comprehensive-metrics-and-monitoring\">Comprehensive Metrics and Monitoring</h4>\n<p>Production leader election systems require detailed observability to diagnose performance issues, detect anomalies, and optimize configuration parameters. A comprehensive metrics system tracks election performance, network health, and cluster dynamics.</p>\n<p><strong>Election Performance Metrics</strong>: Track election latency, success rates, and resource consumption across different failure scenarios and cluster sizes.</p>\n<table>\n<thead>\n<tr>\n<th>Metric Category</th>\n<th>Key Metrics</th>\n<th>Purpose</th>\n<th>Alert Thresholds</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Election latency</td>\n<td>p50, p95, p99 election completion time</td>\n<td>Performance monitoring</td>\n<td>p95 &gt; 5 seconds</td>\n</tr>\n<tr>\n<td>Election success rate</td>\n<td>Percentage of elections that converge</td>\n<td>Reliability tracking</td>\n<td>&lt; 95% success rate</td>\n</tr>\n<tr>\n<td>False failure rate</td>\n<td>Spurious leader changes per hour</td>\n<td>Failure detection tuning</td>\n<td>&gt; 2 per hour</td>\n</tr>\n<tr>\n<td>Network overhead</td>\n<td>Messages per election, bandwidth usage</td>\n<td>Resource optimization</td>\n<td>&gt; 10MB per election</td>\n</tr>\n<tr>\n<td>Split-brain incidents</td>\n<td>Multiple simultaneous leaders</td>\n<td>Safety monitoring</td>\n<td>Any occurrence</td>\n</tr>\n</tbody></table>\n<p><strong>Cluster Health Metrics</strong>: Monitor membership stability, node connectivity, and failure patterns to identify systemic issues before they impact elections.</p>\n<table>\n<thead>\n<tr>\n<th>Health Dimension</th>\n<th>Measurements</th>\n<th>Diagnostic Value</th>\n<th>Intervention Triggers</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Membership churn</td>\n<td>Joins/leaves per minute</td>\n<td>Cluster stability</td>\n<td>&gt; 10% nodes per minute</td>\n</tr>\n<tr>\n<td>Network connectivity</td>\n<td>Reachability matrix between nodes</td>\n<td>Partition detection</td>\n<td>&lt; 80% connectivity</td>\n</tr>\n<tr>\n<td>Failure correlation</td>\n<td>Temporal/geographic failure patterns</td>\n<td>Infrastructure issues</td>\n<td>3+ failures in same rack</td>\n</tr>\n<tr>\n<td>Election frequency</td>\n<td>Elections per hour</td>\n<td>System stability</td>\n<td>&gt; 10 elections per hour</td>\n</tr>\n</tbody></table>\n<h4 id=\"dynamic-configuration-management\">Dynamic Configuration Management</h4>\n<p>Production clusters require runtime configuration adjustments without service interruption. The <code>ConfigurationManager</code> enables dynamic updates to timeout values, failure detection parameters, and algorithm selection while maintaining system consistency.</p>\n<p><strong>Hot Configuration Updates</strong>: Critical parameters like election timeouts, heartbeat intervals, and failure detection thresholds can be updated without restarting nodes. The system validates new configurations and applies them gradually across the cluster.</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Category</th>\n<th>Parameters</th>\n<th>Update Method</th>\n<th>Validation Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Failure detection</td>\n<td>Heartbeat interval, timeout multipliers</td>\n<td>Gradual rollout</td>\n<td>Consistency check</td>\n</tr>\n<tr>\n<td>Election algorithms</td>\n<td>Algorithm selection, specific parameters</td>\n<td>Leader-coordinated</td>\n<td>Compatibility verification</td>\n</tr>\n<tr>\n<td>Network behavior</td>\n<td>Message batching, retry policies</td>\n<td>Immediate local</td>\n<td>None</td>\n</tr>\n<tr>\n<td>Logging and metrics</td>\n<td>Log levels, metric collection rates</td>\n<td>Immediate local</td>\n<td>None</td>\n</tr>\n</tbody></table>\n<p><strong>Configuration Versioning</strong>: All configuration changes are versioned and tracked, enabling rollback to previous configurations when updates cause issues. The system maintains a complete audit trail of configuration changes with timestamps and initiating operators.</p>\n<h4 id=\"advanced-logging-and-debugging\">Advanced Logging and Debugging</h4>\n<p>Production debugging requires sophisticated logging capabilities that can trace individual elections across all participating nodes while maintaining acceptable performance overhead.</p>\n<p><strong>Distributed Tracing</strong>: Each election receives a unique trace ID that appears in all related log messages across all nodes. This enables operators to reconstruct complete election flows even in large clusters with concurrent elections.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>[TRACE:election-7834] Node 5: Starting bully election (term=42, trigger=leader_timeout)\n[TRACE:election-7834] Node 5: Sending ELECTION to nodes [7,9,12,15] (candidates=4)\n[TRACE:election-7834] Node 7: Received ELECTION from node 5 (term=42, responding=true)\n[TRACE:election-7834] Node 7: Sending OK to node 5 (term=42, starting_own_election=true)\n[TRACE:election-7834] Node 5: Received OK from node 7 (term=42, stepping_down=true)</code></pre></div>\n\n<p><strong>State Correlation Analysis</strong>: The <code>DebugStateCollector</code> periodically captures snapshots of each node&#39;s election state and identifies inconsistencies that might indicate bugs or configuration issues.</p>\n<table>\n<thead>\n<tr>\n<th>Consistency Check</th>\n<th>Detection Method</th>\n<th>Common Causes</th>\n<th>Resolution Steps</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Multiple leaders</td>\n<td>Compare leadership claims</td>\n<td>Network partition, timing bug</td>\n<td>Force re-election with quorum</td>\n</tr>\n<tr>\n<td>Stale membership</td>\n<td>Compare node membership views</td>\n<td>Gossip failure, network issues</td>\n<td>Trigger membership sync</td>\n</tr>\n<tr>\n<td>Term conflicts</td>\n<td>Compare election terms across nodes</td>\n<td>Clock skew, message reordering</td>\n<td>Term resolution protocol</td>\n</tr>\n<tr>\n<td>Election loops</td>\n<td>Detect repeated election patterns</td>\n<td>Configuration error, algorithm bug</td>\n<td>Parameter adjustment</td>\n</tr>\n</tbody></table>\n<h4 id=\"operational-tools-and-automation\">Operational Tools and Automation</h4>\n<p>Production systems require extensive operational tooling for cluster management, disaster recovery, and routine maintenance operations.</p>\n<p><strong>Cluster Administration Interface</strong>: A comprehensive administrative interface enables operators to monitor cluster health, trigger manual elections, and perform maintenance operations without disrupting service availability.</p>\n<table>\n<thead>\n<tr>\n<th>Administrative Operation</th>\n<th>Purpose</th>\n<th>Safety Checks</th>\n<th>Rollback Capability</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Manual leader election</td>\n<td>Replace failed/degraded leader</td>\n<td>Verify quorum availability</td>\n<td>Previous leader restoration</td>\n</tr>\n<tr>\n<td>Node graceful shutdown</td>\n<td>Planned maintenance</td>\n<td>Transfer leadership first</td>\n<td>Immediate restart</td>\n</tr>\n<tr>\n<td>Membership management</td>\n<td>Add/remove cluster nodes</td>\n<td>Verify majority maintained</td>\n<td>Node re-addition</td>\n</tr>\n<tr>\n<td>Configuration deployment</td>\n<td>Update cluster parameters</td>\n<td>Staged rollout with validation</td>\n<td>Previous configuration</td>\n</tr>\n<tr>\n<td>Emergency cluster reset</td>\n<td>Recover from corruption</td>\n<td>Operator confirmation required</td>\n<td>State backup restoration</td>\n</tr>\n</tbody></table>\n<p><strong>Automated Recovery Procedures</strong>: The system includes automated responses to common failure scenarios that can resolve issues without human intervention while escalating complex problems appropriately.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Scenario</th>\n<th>Automatic Response</th>\n<th>Escalation Trigger</th>\n<th>Manual Override</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Repeated election failures</td>\n<td>Increase timeouts, reduce membership</td>\n<td>5+ failures in 10 minutes</td>\n<td>Force specific leader</td>\n</tr>\n<tr>\n<td>Split-brain detection</td>\n<td>Shutdown minority partition</td>\n<td>Equal-sized partitions</td>\n<td>Operator decision</td>\n</tr>\n<tr>\n<td>Cascading node failures</td>\n<td>Pause new elections temporarily</td>\n<td>&gt;50% nodes failed</td>\n<td>Emergency cluster rebuild</td>\n</tr>\n<tr>\n<td>Configuration corruption</td>\n<td>Revert to last known good config</td>\n<td>Validation failures</td>\n<td>Manual configuration</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete implementation strategies for extending the basic leader election system with advanced features and production-readiness capabilities.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Metrics Collection</td>\n<td>Prometheus client library</td>\n<td>OpenTelemetry with custom exporters</td>\n</tr>\n<tr>\n<td>Configuration Management</td>\n<td>JSON/YAML files with file watching</td>\n<td>etcd/Consul with versioning</td>\n</tr>\n<tr>\n<td>Distributed Tracing</td>\n<td>Structured logging with correlation IDs</td>\n<td>Jaeger/Zipkin integration</td>\n</tr>\n<tr>\n<td>Administrative Interface</td>\n<td>REST API with basic web UI</td>\n<td>gRPC API with full dashboard</td>\n</tr>\n<tr>\n<td>Automated Testing</td>\n<td>Unit tests with mocked failures</td>\n<td>Chaos engineering with Jepsen</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-module-structure\">Recommended Module Structure</h4>\n<p>The extension modules integrate with the existing leader election system while maintaining clear separation of concerns:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  internal/\n    coordinator/               ← core election logic (existing)\n    transport/                ← communication layer (existing)\n    \n    optimization/             ← performance improvements\n      adaptive_timeout.go     ← AdaptiveTimeoutManager\n      message_batcher.go      ← MessageBatcher\n      concurrent_resolver.go  ← ConcurrentElectionResolver\n      ring_optimizer.go       ← optimized RingTopologyManager\n      \n    algorithms/               ← additional election algorithms\n      raft_election.go        ← Raft leader election\n      weighted_election.go    ← capability-based weighting\n      swim_detector.go        ← SWIM failure detection\n      \n    production/               ← production readiness\n      metrics_collector.go    ← comprehensive metrics\n      config_manager.go       ← dynamic configuration\n      debug_collector.go      ← state correlation\n      admin_interface.go      ← operational tools\n      \n    testing/                  ← advanced testing tools\n      chaos_injector.go       ← fault injection\n      cluster_simulator.go    ← large-scale testing</code></pre></div>\n\n<h4 id=\"adaptive-timeout-infrastructure-code\">Adaptive Timeout Infrastructure Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> optimization</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">math</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AdaptiveTimeoutManager dynamically adjusts election timeouts based on </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// observed network behavior and election success patterns.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AdaptiveTimeoutManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    baseTimeout    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    minTimeout     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxTimeout     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentTimeout </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Metrics tracking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recentElections    []</span><span style=\"color:#B392F0\">ElectionRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recentRTTs        []</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    networkLatency    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Adjustment parameters</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    successThreshold   </span><span style=\"color:#F97583\">float64</span><span style=\"color:#6A737D\">  // 0.9 = 90% success rate</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    adjustmentFactor   </span><span style=\"color:#F97583\">float64</span><span style=\"color:#6A737D\">  // 0.1 = 10% adjustment steps</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    windowSize         </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\">      // Number of elections to track</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ElectionRecord tracks the outcome of individual elections for analysis</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ElectionRecord</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartTime      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CompletionTime </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Success        </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NetworkLatency </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ParticipantCount </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewAdaptiveTimeoutManager creates a timeout manager with conservative defaults</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewAdaptiveTimeoutManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">baseTimeout</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdaptiveTimeoutManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">AdaptiveTimeoutManager</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        baseTimeout:       baseTimeout,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        minTimeout:        baseTimeout </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        maxTimeout:        baseTimeout </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        currentTimeout:    baseTimeout,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        successThreshold:  </span><span style=\"color:#79B8FF\">0.9</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        adjustmentFactor:  </span><span style=\"color:#79B8FF\">0.1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        windowSize:        </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        recentElections:   </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">ElectionRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        recentRTTs:       </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetCurrentTimeout returns the dynamically calculated timeout value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">a </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdaptiveTimeoutManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetCurrentTimeout</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate timeout based on recent network latency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Apply success rate adjustments (decrease if high success, increase if low)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Consider participant count (more nodes = longer timeout needed)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Apply cascade failure detection (triple timeout during instability)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Ensure result is within min/max bounds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    a.mu.</span><span style=\"color:#B392F0\">RLock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> a.mu.</span><span style=\"color:#B392F0\">RUnlock</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> a.currentTimeout</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecordElectionResult updates timeout calculations based on election outcome</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">a </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdaptiveTimeoutManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecordElectionResult</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">record</span><span style=\"color:#B392F0\"> ElectionRecord</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add record to recentElections window</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Remove oldest records if window size exceeded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Recalculate timeout based on updated success rate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update network latency estimates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Apply adjustment factor to smooth timeout changes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecordNetworkRTT updates network latency estimates from heartbeat/ping data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">a </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AdaptiveTimeoutManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecordNetworkRTT</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rtt</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add RTT to sliding window</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate moving average of network latency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Adjust timeout if latency significantly changed (>50% increase)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Remove old RTT samples to keep window current</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"raft-leader-election-core-logic\">Raft Leader Election Core Logic</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> algorithms</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">math/rand</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RaftElection implements the Raft leader election protocol with term-based voting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RaftElection</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID      </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transport   </span><span style=\"color:#B392F0\">Transport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    membership  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ClusterMembership</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Raft-specific state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currentTerm </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    votedFor    </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state       </span><span style=\"color:#B392F0\">NodeState</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Election timing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    electionTimeout  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    heartbeatTimeout </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    randomGenerator  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">rand</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Rand</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Vote tracking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    votesReceived    </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#B392F0\">NodeID</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">  // term -> voter -> vote</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    voteGranted      </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">bool</span><span style=\"color:#6A737D\">             // term -> did we vote</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartRaftElection initiates a new Raft election with term increment and vote requests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RaftElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartRaftElection</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Increment current term</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Vote for self in new term  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Reset election timeout with random jitter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Send RequestVote messages to all other nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Start timeout for vote collection phase</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Random jitter prevents vote splitting - use 150-300ms range</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// HandleRequestVote processes incoming vote requests from candidate nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RaftElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">HandleRequestVote</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">msg</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">RequestVoteMessage</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RequestVoteResponse</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check if candidate's term is at least as current as ours</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify we haven't already voted in this term</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Grant vote if candidate is eligible</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update our current term if candidate's term is higher</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return vote decision with current term</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Only one vote per term - this prevents split elections</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CollectVotes counts received votes and transitions to leader if majority achieved</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RaftElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CollectVotes</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">term</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Count votes received for specified term</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate majority threshold (n/2 + 1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return true if majority achieved, false otherwise</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Handle case where not all nodes responded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Need strict majority, not just plurality</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"production-metrics-infrastructure\">Production Metrics Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> production</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/prometheus/client_golang/prometheus</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MetricsCollector provides comprehensive observability for leader election systems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MetricsCollector</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID </span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Prometheus metrics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    electionDuration    </span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Histogram</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    electionSuccess     </span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Counter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    electionFailures    </span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CounterVec</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leaderChanges       </span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Counter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    networkMessages     </span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CounterVec</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    clusterSize         </span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Gauge</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Internal tracking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    activeElections     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionMetrics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    leaderHistory      []</span><span style=\"color:#B392F0\">LeadershipEvent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu                 </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ElectionMetrics tracks detailed metrics for individual elections</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ElectionMetrics</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ElectionID    </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartTime     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Algorithm     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TriggerReason </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Participants  []</span><span style=\"color:#B392F0\">NodeID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MessagesSent  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MessagesReceived </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NetworkBytes  </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewMetricsCollector initializes Prometheus metrics with appropriate labels and buckets</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewMetricsCollector</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">nodeID</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetricsCollector</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">MetricsCollector</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        nodeID: nodeID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        electionDuration: prometheus.</span><span style=\"color:#B392F0\">NewHistogram</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">HistogramOpts</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Name:    </span><span style=\"color:#9ECBFF\">\"leader_election_duration_seconds\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Help:    </span><span style=\"color:#9ECBFF\">\"Time taken to complete leader elections\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Buckets: []</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#79B8FF\">0.1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0.5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1.0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2.0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5.0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">10.0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">30.0</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        electionSuccess: prometheus.</span><span style=\"color:#B392F0\">NewCounter</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CounterOpts</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Name: </span><span style=\"color:#9ECBFF\">\"leader_election_success_total\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Help: </span><span style=\"color:#9ECBFF\">\"Number of successful leader elections\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        electionFailures: prometheus.</span><span style=\"color:#B392F0\">NewCounterVec</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">prometheus</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">CounterOpts</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Name: </span><span style=\"color:#9ECBFF\">\"leader_election_failures_total\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Help: </span><span style=\"color:#9ECBFF\">\"Number of failed leader elections by reason\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }, []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"reason\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"algorithm\"</span><span style=\"color:#E1E4E8\">}),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        activeElections: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">uint64</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionMetrics</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecordElectionStarted begins tracking metrics for a new election</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetricsCollector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecordElectionStarted</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">electionID</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">algorithm</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">trigger</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create ElectionMetrics entry for this election</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Record start timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize message and byte counters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Determine participant list from current membership</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use electionID as map key for tracking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecordElectionCompleted finalizes election metrics and updates Prometheus counters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetricsCollector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecordElectionCompleted</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">electionID</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">success</span><span style=\"color:#F97583\"> bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">winner</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Look up ElectionMetrics for this election</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate total duration from start time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update Prometheus histogram with duration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update success/failure counters appropriately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Record leader change if winner different from previous leader</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Clean up tracking entry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecordMessageSent updates network traffic metrics when election messages are transmitted</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MetricsCollector</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecordMessageSent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">electionID</span><span style=\"color:#F97583\"> uint64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">msgType</span><span style=\"color:#B392F0\"> MessageType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">target</span><span style=\"color:#B392F0\"> NodeID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">bytes</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Find active election and increment message counter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add to total network bytes for this election</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Update Prometheus network message counter with type/direction labels</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Track both message count and bandwidth usage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"dynamic-configuration-management\">Dynamic Configuration Management</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> production</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ConfigurationManager enables runtime updates to election parameters without service restart</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ConfigurationManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Current configuration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config           </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ElectionConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    configVersion    </span><span style=\"color:#F97583\">uint64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lastUpdated      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configuration sources</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    configFile       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    externalStore    </span><span style=\"color:#B392F0\">ConfigStore</span><span style=\"color:#6A737D\">  // etcd, Consul, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Update coordination</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    subscribers      []</span><span style=\"color:#B392F0\">ConfigSubscriber</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    updateInProgress </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu               </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ElectionConfig contains all tunable parameters for the election system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ElectionConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Failure detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HeartbeatInterval       </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"heartbeat_interval\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FailureDetectionTimeout </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"failure_detection_timeout\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SuspicionLevels         </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">           `json:\"suspicion_levels\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Election behavior  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ElectionTimeout         </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"election_timeout\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxConcurrentElections  </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">           `json:\"max_concurrent_elections\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EnableAdaptiveTimeouts  </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">          `json:\"enable_adaptive_timeouts\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Network optimization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MessageBatchSize        </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">           `json:\"message_batch_size\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MessageBatchTimeout     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"message_batch_timeout\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxRetries              </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">           `json:\"max_retries\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Algorithm selection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PreferredAlgorithm      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"preferred_algorithm\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FallbackAlgorithms      []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"fallback_algorithms\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ConfigSubscriber receives notifications when configuration changes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ConfigSubscriber</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    OnConfigurationChanged</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">oldConfig</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">newConfig</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ElectionConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ApplyConfigurationUpdate validates and applies new configuration across the cluster</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConfigurationManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ApplyConfigurationUpdate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">newConfig</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ElectionConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate new configuration for consistency and safety</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check that timeout values are reasonable (not too small/large)  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify algorithm names are supported</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Coordinate update across cluster if needed (leader-driven)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Apply configuration gradually with rollback capability</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Notify all subscribers of configuration change</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Some changes require cluster coordination, others can be applied locally</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateConfiguration checks that configuration parameters are safe and consistent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConfigurationManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateConfiguration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ElectionConfig</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify timeout relationships (election > heartbeat * 3)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Check that batch sizes are reasonable (not too large for network)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Validate algorithm names against supported algorithms  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Ensure suspicion levels are positive integers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return list of validation errors, empty if configuration is valid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint-performance-extensions\">Milestone Checkpoint: Performance Extensions</h4>\n<p>After implementing the performance optimization components, verify the improvements with these specific tests:</p>\n<p><strong>Adaptive Timeout Validation</strong>: Start a test cluster and introduce varying network delays. Verify that election timeouts adjust appropriately - timeouts should decrease during stable periods and increase during network congestion.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Start test cluster</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> run</span><span style=\"color:#9ECBFF\"> cmd/test-cluster/main.go</span><span style=\"color:#79B8FF\"> --nodes=5</span><span style=\"color:#79B8FF\"> --adaptive-timeouts=true</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Inject network delay</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> localhost:8080/debug/inject-latency</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#9ECBFF\"> '{\"delay_ms\": 500}'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify timeout adaptation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> localhost:8080/metrics</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> election_timeout_current</span></span></code></pre></div>\n\n<p><strong>Message Batching Efficiency</strong>: Monitor network traffic reduction when message batching is enabled versus disabled.</p>\n<p>Expected behavior: 60-80% reduction in network packets during election storms, with latency increase of less than 50ms.</p>\n<p><strong>Concurrent Election Resolution</strong>: Trigger simultaneous elections from multiple nodes and verify that only one election completes while others are abandoned.</p>\n<p>Expected behavior: Single election succeeds within 2 seconds, abandoned elections log &quot;higher priority election detected&quot; messages.</p>\n<h4 id=\"milestone-checkpoint-advanced-algorithms\">Milestone Checkpoint: Advanced Algorithms</h4>\n<p>After implementing Raft leader election:</p>\n<p><strong>Raft Election Safety</strong>: Verify that elections produce exactly one leader even during network partitions.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Create network partition</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> localhost:8080/debug/partition</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#9ECBFF\"> '{\"groups\": [[1,2], [3,4,5]]}'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify only majority partition elects leader  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> localhost:8080/cluster/status</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> jq</span><span style=\"color:#9ECBFF\"> '.leaders | length'</span><span style=\"color:#6A737D\">  # Should be 1</span></span></code></pre></div>\n\n<p><strong>SWIM Failure Detection</strong>: Validate that SWIM-based failure detection scales better than heartbeat approaches.</p>\n<p>Expected behavior: Network overhead should grow linearly with cluster size rather than quadratically.</p>\n<h4 id=\"milestone-checkpoint-production-features\">Milestone Checkpoint: Production Features</h4>\n<p>After implementing metrics and configuration management:</p>\n<p><strong>Metrics Collection</strong>: Verify comprehensive metrics are exported and updating correctly.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Check metric availability</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> localhost:9090/metrics</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> leader_election</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Trigger election and verify metrics update</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> localhost:8080/admin/trigger-election</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">sleep</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> localhost:9090/metrics</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> grep</span><span style=\"color:#9ECBFF\"> leader_election_duration</span></span></code></pre></div>\n\n<p><strong>Dynamic Configuration</strong>: Test that configuration updates apply without restarting nodes.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Update election timeout</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> PUT</span><span style=\"color:#9ECBFF\"> localhost:8080/admin/config</span><span style=\"color:#79B8FF\"> -d</span><span style=\"color:#9ECBFF\"> '{\"election_timeout\": \"10s\"}'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify new timeout in effect</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#9ECBFF\"> localhost:8080/admin/config</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> jq</span><span style=\"color:#9ECBFF\"> '.election_timeout'</span></span></code></pre></div>\n\n<p>Expected behavior: Configuration changes should propagate to all nodes within 30 seconds and take effect for subsequent elections.</p>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones - comprehensive terminology reference for node communication (Milestone 1), bully algorithm (Milestone 2), ring election (Milestone 3), and all system components</p>\n</blockquote>\n<h3 id=\"mental-model-the-diplomatic-dictionary\">Mental Model: The Diplomatic Dictionary</h3>\n<p>Think of this glossary as a diplomatic dictionary for distributed systems. Just as diplomats from different countries need shared terminology to negotiate treaties without misunderstanding, distributed systems engineers need precise vocabulary to discuss coordination algorithms without ambiguity. Each term has evolved from decades of distributed systems research and carries specific technical meaning that differs from casual usage.</p>\n<p>This glossary serves as the authoritative reference for all concepts, algorithms, and technical terms used throughout the leader election system. Understanding these terms precisely is essential for implementing correct distributed coordination behavior and avoiding subtle bugs that arise from imprecise terminology.</p>\n<h3 id=\"core-distributed-systems-concepts\">Core Distributed Systems Concepts</h3>\n<p>The following fundamental concepts form the foundation of all leader election algorithms:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>leader election</strong></td>\n<td>The distributed algorithm process of selecting a single coordinator node from multiple candidates in a cluster, ensuring exactly one leader emerges even during failures and network partitions</td>\n<td>Central to all milestones - the primary problem this system solves</td>\n</tr>\n<tr>\n<td><strong>split-brain</strong></td>\n<td>A critical failure scenario where network partitions cause multiple nodes to simultaneously believe they are the leader, potentially causing data corruption or inconsistent cluster state</td>\n<td>Primary safety concern across all algorithms - must be prevented</td>\n</tr>\n<tr>\n<td><strong>distributed coordination</strong></td>\n<td>The general problem of getting multiple independent nodes to agree on shared state or decisions without a central authority, using only message passing over unreliable networks</td>\n<td>Foundational concept underlying leader election algorithms</td>\n</tr>\n<tr>\n<td><strong>cluster membership</strong></td>\n<td>The dynamic view of which nodes are currently alive, reachable, and participating in the cluster, maintained through failure detection and node discovery</td>\n<td>Essential for all election algorithms to know potential participants</td>\n</tr>\n<tr>\n<td><strong>election term</strong></td>\n<td>A monotonically increasing epoch counter that orders election attempts chronologically and resolves conflicts between concurrent elections</td>\n<td>Prevents old election results from overriding newer ones</td>\n</tr>\n<tr>\n<td><strong>quorum</strong></td>\n<td>The minimum number of nodes required to make valid cluster decisions, typically (N/2)+1 where N is the original cluster size, used to prevent split-brain during partitions</td>\n<td>Critical for maintaining safety during network partitions</td>\n</tr>\n<tr>\n<td><strong>network partition</strong></td>\n<td>A failure mode where network connectivity is lost between subsets of cluster nodes, creating isolated groups that cannot communicate</td>\n<td>Major source of complexity in election algorithm design</td>\n</tr>\n<tr>\n<td><strong>failure detection</strong></td>\n<td>The process of identifying crashed, hung, or unreachable nodes through timeouts, heartbeats, and unreachable peer reporting</td>\n<td>Triggers leader elections and maintains accurate membership</td>\n</tr>\n<tr>\n<td><strong>heartbeat</strong></td>\n<td>A periodic alive signal sent between nodes to prove continued operation and detect failures through message absence</td>\n<td>Primary mechanism for failure detection in leader election</td>\n</tr>\n<tr>\n<td><strong>suspicion level</strong></td>\n<td>A graduated counter that tracks accumulating evidence of node failure before definitively marking a node as crashed, reducing false positives from temporary network issues</td>\n<td>Prevents premature failure declarations from brief hiccups</td>\n</tr>\n</tbody></table>\n<h3 id=\"election-algorithm-specifics\">Election Algorithm Specifics</h3>\n<p>These terms define the specific behavior of the bully and ring election algorithms:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>bully algorithm</strong></td>\n<td>An election algorithm where nodes with higher IDs &quot;bully&quot; lower-ID nodes by sending election messages only upward, and the highest responding node wins through competitive messaging</td>\n<td>Milestone 2 implementation - aggressive but efficient election</td>\n</tr>\n<tr>\n<td><strong>ring election</strong></td>\n<td>A token-passing election algorithm where an election token circulates around a logical ring topology, collecting all live node IDs before selecting the highest ID as leader</td>\n<td>Milestone 3 implementation - cooperative election with full knowledge</td>\n</tr>\n<tr>\n<td><strong>cascade election</strong></td>\n<td>Sequential election attempts that occur when higher-ID nodes fail during an active bully election, causing lower-ID nodes to initiate their own elections</td>\n<td>Common pattern in bully algorithm during multiple failures</td>\n</tr>\n<tr>\n<td><strong>coordinator announcement</strong></td>\n<td>A broadcast message sent by the winning node to inform all cluster members of the new leader, establishing the post-election leadership state</td>\n<td>Final step in both bully and ring elections</td>\n</tr>\n<tr>\n<td><strong>election timeout</strong></td>\n<td>The deadline for receiving responses from higher-ID nodes in bully algorithm, after which a node declares victory and becomes coordinator</td>\n<td>Critical timing parameter for bully election correctness</td>\n</tr>\n<tr>\n<td><strong>logical ring topology</strong></td>\n<td>A circular ordering of cluster nodes by their NodeID values, where each node knows its successor for token forwarding, independent of physical network topology</td>\n<td>Foundation for ring election algorithm implementation</td>\n</tr>\n<tr>\n<td><strong>election token</strong></td>\n<td>A special message containing the current participant list that circulates around the ring, accumulating live node IDs until it completes the full circuit</td>\n<td>Central data structure for ring election coordination</td>\n</tr>\n<tr>\n<td><strong>token circulation</strong></td>\n<td>The process of forwarding the election token from node to node around the logical ring until it returns to the originating node</td>\n<td>Core mechanism of ring election algorithm</td>\n</tr>\n<tr>\n<td><strong>ring repair</strong></td>\n<td>The mechanism to skip failed nodes during token forwarding and reconstruct ring connections to maintain token flow when nodes crash</td>\n<td>Essential for ring election reliability during failures</td>\n</tr>\n<tr>\n<td><strong>successor mapping</strong></td>\n<td>A data structure table that maps each node to its immediate next node in the ring order, updated dynamically as nodes join and leave</td>\n<td>Enables token forwarding in ring elections</td>\n</tr>\n</tbody></table>\n<h3 id=\"message-types-and-communication\">Message Types and Communication</h3>\n<p>These terms describe the messaging infrastructure and specific message formats:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>broadcast</strong></td>\n<td>Message delivery pattern that sends the same message to all currently active cluster members simultaneously</td>\n<td>Used for coordinator announcements and heartbeats</td>\n</tr>\n<tr>\n<td><strong>point-to-point</strong></td>\n<td>Message delivery pattern that sends a message from one specific source node to one specific target node</td>\n<td>Used for election messages and OK responses</td>\n</tr>\n<tr>\n<td><strong>message sequence pattern</strong></td>\n<td>The temporal choreography and ordering of election messages that flow between nodes during a complete election cycle</td>\n<td>Defines the correct behavior for each algorithm</td>\n</tr>\n<tr>\n<td><strong>reliable message passing</strong></td>\n<td>Message delivery that guarantees messages are delivered exactly once to reachable nodes or generates a delivery failure notification</td>\n<td>Foundation for election correctness</td>\n</tr>\n<tr>\n<td><strong>election trigger</strong></td>\n<td>An event or condition that causes a node to initiate a new leader election process, such as leader failure detection or cluster bootstrap</td>\n<td>Entry point for election algorithms</td>\n</tr>\n<tr>\n<td><strong>state transition</strong></td>\n<td>A change in a node&#39;s role from follower to candidate to leader, with specific rules about when transitions are allowed</td>\n<td>Prevents invalid state combinations</td>\n</tr>\n<tr>\n<td><strong>concurrent election</strong></td>\n<td>Multiple nodes simultaneously initiating elections, requiring resolution mechanisms to prevent conflicts and ensure single leader emergence</td>\n<td>Common scenario requiring careful message ordering</td>\n</tr>\n<tr>\n<td><strong>term-based resolution</strong></td>\n<td>Using monotonically increasing election terms to order and resolve conflicts between overlapping elections</td>\n<td>Prevents older elections from overriding newer ones</td>\n</tr>\n</tbody></table>\n<h3 id=\"system-state-and-node-roles\">System State and Node Roles</h3>\n<p>These terms define the internal state that nodes maintain during elections:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>node identity</strong></td>\n<td>The unique numeric identifier (NodeID) that distinguishes each cluster member and determines election precedence through numeric ordering</td>\n<td>Fundamental to both bully and ring election algorithms</td>\n</tr>\n<tr>\n<td><strong>election state</strong></td>\n<td>The complete internal state of a node&#39;s current election status, including current role, known leader, election term, and active election participation</td>\n<td>Tracked by <code>ElectionState</code> structure</td>\n</tr>\n<tr>\n<td><strong>leadership transition</strong></td>\n<td>The complete process of one node stepping down as leader while another node assumes leadership responsibilities</td>\n<td>Complex coordination requiring careful ordering</td>\n</tr>\n<tr>\n<td><strong>graceful step-down</strong></td>\n<td>A voluntary leadership transition where the current leader formally transfers responsibilities and notifies all cluster members before relinquishing control</td>\n<td>Preferred alternative to failure-triggered elections</td>\n</tr>\n<tr>\n<td><strong>bootstrap election</strong></td>\n<td>The initial leader selection process that occurs when a cluster starts with no existing leader or when all previous leaders have failed</td>\n<td>Special case requiring different initialization logic</td>\n</tr>\n<tr>\n<td><strong>membership</strong></td>\n<td>The dynamic view of which nodes are currently alive and participating in cluster operations, maintained through failure detection and node discovery</td>\n<td>Fundamental to knowing election participants</td>\n</tr>\n</tbody></table>\n<h3 id=\"network-and-failure-handling\">Network and Failure Handling</h3>\n<p>These terms address the complex failure scenarios that election algorithms must handle:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>partition healing</strong></td>\n<td>The process of restoring connectivity between previously isolated cluster segments and resolving any conflicting state that developed during separation</td>\n<td>Critical for preventing split-brain after partition recovery</td>\n</tr>\n<tr>\n<td><strong>split-brain prevention</strong></td>\n<td>Mechanisms and algorithms that ensure only one node can claim leadership even during network partitions that split the cluster into isolated groups</td>\n<td>Primary safety requirement for election correctness</td>\n</tr>\n<tr>\n<td><strong>cascading failure</strong></td>\n<td>A failure pattern where the recovery from initial failures triggers additional failures, potentially causing system-wide collapse</td>\n<td>Must be detected and mitigated in election algorithms</td>\n</tr>\n<tr>\n<td><strong>graduated suspicion</strong></td>\n<td>An incremental failure detection approach that accumulates evidence over multiple missed heartbeats before declaring a node definitely failed</td>\n<td>Prevents false positives from temporary network congestion</td>\n</tr>\n<tr>\n<td><strong>adaptive timeouts</strong></td>\n<td>Dynamic timeout adjustment based on observed network conditions, election completion times, and failure patterns to optimize election speed versus reliability</td>\n<td>Performance optimization for varying network conditions</td>\n</tr>\n<tr>\n<td><strong>election storm</strong></td>\n<td>A pathological condition where overlapping elections prevent the cluster from converging on a stable leader, often caused by tight timing or cascading failures</td>\n<td>Anti-pattern that must be detected and resolved</td>\n</tr>\n</tbody></table>\n<h3 id=\"testing-and-validation-terminology\">Testing and Validation Terminology</h3>\n<p>These terms describe the comprehensive testing approach for distributed election systems:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>component-level testing</strong></td>\n<td>Testing individual system components (Transport, FailureDetector, ClusterMembership) in isolation using mocks and controlled inputs</td>\n<td>First tier of testing pyramid for election systems</td>\n</tr>\n<tr>\n<td><strong>multi-node scenarios</strong></td>\n<td>Integration testing that runs complete election flows with multiple coordinating nodes to validate algorithm correctness</td>\n<td>Second tier testing actual distributed behavior</td>\n</tr>\n<tr>\n<td><strong>fault injection testing</strong></td>\n<td>Deliberately introducing controlled failures (message loss, node crashes, network partitions) during normal operation to validate resilience</td>\n<td>Essential for testing distributed system edge cases</td>\n</tr>\n<tr>\n<td><strong>milestone validation checkpoints</strong></td>\n<td>Concrete behavioral tests that demonstrate milestone completion by verifying specific requirements like &quot;highest-ID node wins every election&quot;</td>\n<td>Formal acceptance criteria for project milestones</td>\n</tr>\n<tr>\n<td><strong>chaos testing</strong></td>\n<td>Systematic fault injection that introduces random failures during elections to discover unexpected failure modes and validate system robustness</td>\n<td>Advanced testing for production readiness</td>\n</tr>\n<tr>\n<td><strong>network partition simulation</strong></td>\n<td>Creating controlled network splits that isolate groups of nodes to test split-brain prevention and partition healing behavior</td>\n<td>Critical for validating safety properties</td>\n</tr>\n<tr>\n<td><strong>message loss injection</strong></td>\n<td>Controlled dropping of specific message types during elections to validate timeout handling and retry logic</td>\n<td>Tests algorithm robustness to unreliable networks</td>\n</tr>\n<tr>\n<td><strong>cascading failure testing</strong></td>\n<td>Validating system behavior when initial failures trigger additional failures, ensuring graceful degradation rather than system collapse</td>\n<td>Validates resilience to complex failure scenarios</td>\n</tr>\n</tbody></table>\n<h3 id=\"debugging-and-observability\">Debugging and Observability</h3>\n<p>These terms define the systematic approach to diagnosing issues in distributed elections:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>election flow validation</strong></td>\n<td>Tracing and verifying that election message sequences follow the correct protocol patterns and produce valid outcomes</td>\n<td>Primary debugging technique for election correctness</td>\n</tr>\n<tr>\n<td><strong>state correlation</strong></td>\n<td>Comparing internal node states across the cluster to identify inconsistencies, conflicting leaders, or election synchronization problems</td>\n<td>Detects distributed state inconsistencies</td>\n</tr>\n<tr>\n<td><strong>message flow analysis</strong></td>\n<td>Tracing election messages chronologically through the cluster to identify missing messages, ordering problems, or protocol violations</td>\n<td>Core technique for debugging election failures</td>\n</tr>\n<tr>\n<td><strong>structured logging</strong></td>\n<td>Consistent log format with correlation identifiers (election IDs, terms, node IDs) that enables tracing individual elections across multiple nodes</td>\n<td>Essential for debugging distributed elections</td>\n</tr>\n<tr>\n<td><strong>distributed tracing</strong></td>\n<td>Following individual election attempts across all participating nodes using correlation IDs to build complete election timelines</td>\n<td>Advanced debugging for complex election interactions</td>\n</tr>\n</tbody></table>\n<h3 id=\"advanced-algorithms-and-extensions\">Advanced Algorithms and Extensions</h3>\n<p>These terms describe algorithms and optimizations beyond the basic milestone requirements:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Raft leader election</strong></td>\n<td>A consensus algorithm election mechanism that requires majority votes and includes log consistency checks, more complex but more robust than bully or ring elections</td>\n<td>Advanced extension requiring consensus protocol knowledge</td>\n</tr>\n<tr>\n<td><strong>SWIM failure detection</strong></td>\n<td>Scalable Weakly-consistent Infection-style failure detection using gossip protocols to detect failures efficiently in large clusters</td>\n<td>Alternative to heartbeat-based failure detection</td>\n</tr>\n<tr>\n<td><strong>weighted election algorithms</strong></td>\n<td>Election approaches that consider node capabilities, load, or reliability scores rather than just numeric IDs for leader selection</td>\n<td>Extension for production environments with heterogeneous nodes</td>\n</tr>\n<tr>\n<td><strong>Byzantine fault tolerance</strong></td>\n<td>Handling arbitrary or malicious node behavior where nodes may send conflicting or false information, requiring cryptographic verification</td>\n<td>Advanced security extension beyond basic crash failures</td>\n</tr>\n<tr>\n<td><strong>dynamic configuration management</strong></td>\n<td>Runtime parameter updates (timeouts, membership, algorithms) without requiring service restart or cluster downtime</td>\n<td>Production readiness feature for operational flexibility</td>\n</tr>\n<tr>\n<td><strong>adaptive timeout management</strong></td>\n<td>Automatic adjustment of election timeouts based on observed network latency, cluster size, and historical election completion times</td>\n<td>Performance optimization for varying network conditions</td>\n</tr>\n<tr>\n<td><strong>message batching</strong></td>\n<td>Aggregating multiple election messages into single network transmissions to reduce overhead and improve performance in high-frequency election scenarios</td>\n<td>Network optimization for clusters with frequent elections</td>\n</tr>\n</tbody></table>\n<h3 id=\"data-structures-and-implementation-details\">Data Structures and Implementation Details</h3>\n<p>These terms define the specific implementation components and their relationships:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>ElectionCoordinator</strong></td>\n<td>The main component that orchestrates election algorithms, manages node state, and coordinates with transport and membership components</td>\n<td>Central controller implementing election logic</td>\n</tr>\n<tr>\n<td><strong>Transport</strong></td>\n<td>The abstract interface for inter-node communication that abstracts network protocols (TCP, UDP, HTTP) and provides reliable message delivery</td>\n<td>Abstraction layer for different network implementations</td>\n</tr>\n<tr>\n<td><strong>ClusterMembership</strong></td>\n<td>Component that tracks which nodes are alive and participating, maintains the authoritative view of cluster composition</td>\n<td>Foundation for knowing election participants</td>\n</tr>\n<tr>\n<td><strong>FailureDetector</strong></td>\n<td>Component that monitors node heartbeats and network connectivity to identify failed nodes and trigger elections</td>\n<td>Critical for maintaining accurate membership</td>\n</tr>\n<tr>\n<td><strong>RingTopology</strong></td>\n<td>Component that manages the logical ring ordering of nodes and handles successor mapping for token forwarding</td>\n<td>Specific to ring election algorithm implementation</td>\n</tr>\n<tr>\n<td><strong>ElectionState</strong></td>\n<td>The complete internal state of a node including current role, known leader, election term, and active election participation</td>\n<td>Core state machine for election behavior</td>\n</tr>\n<tr>\n<td><strong>MessageSequencer</strong></td>\n<td>Component that orders incoming messages and manages election message timing to prevent race conditions</td>\n<td>Ensures correct message processing order</td>\n</tr>\n<tr>\n<td><strong>LeadershipManager</strong></td>\n<td>Component that handles leader responsibilities including heartbeat broadcasting and coordination task management</td>\n<td>Manages post-election leader duties</td>\n</tr>\n</tbody></table>\n<h3 id=\"testing-infrastructure-components\">Testing Infrastructure Components</h3>\n<p>These terms describe the specialized testing components for validating distributed election behavior:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>TestTransport</strong></td>\n<td>A controllable transport implementation that simulates network conditions including delays, message loss, and partitions for testing election algorithms</td>\n<td>Essential for controlled testing of failure scenarios</td>\n</tr>\n<tr>\n<td><strong>TestCluster</strong></td>\n<td>A complete simulated cluster environment that manages multiple election coordinators and network simulation for comprehensive testing</td>\n<td>Primary testing harness for multi-node scenarios</td>\n</tr>\n<tr>\n<td><strong>FaultScenario</strong></td>\n<td>A structured test case that defines specific failure conditions, validation criteria, and expected outcomes for systematic testing of edge cases</td>\n<td>Standardized approach to testing complex failure modes</td>\n</tr>\n<tr>\n<td><strong>ElectionScenarioTest</strong></td>\n<td>Integration test that validates complete election flows including timing, message ordering, and final leader selection</td>\n<td>Validates end-to-end election correctness</td>\n</tr>\n<tr>\n<td><strong>NetworkSimulator</strong></td>\n<td>Component that simulates various network conditions including latency, packet loss, and partitions to test election algorithms under realistic conditions</td>\n<td>Enables testing without actual network failures</td>\n</tr>\n</tbody></table>\n<h3 id=\"performance-and-reliability-metrics\">Performance and Reliability Metrics</h3>\n<p>These terms define the measurable aspects of election system performance:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>election convergence time</strong></td>\n<td>The duration from election initiation to stable leader establishment, measured across different cluster sizes and failure scenarios</td>\n<td>Key performance metric for election efficiency</td>\n</tr>\n<tr>\n<td><strong>message overhead</strong></td>\n<td>The total number of messages required to complete an election, important for network efficiency and scalability analysis</td>\n<td>Comparison metric between election algorithms</td>\n</tr>\n<tr>\n<td><strong>failure detection latency</strong></td>\n<td>The time between actual node failure and its detection by the failure detector, directly impacts election trigger timing</td>\n<td>Critical for minimizing leadership gaps</td>\n</tr>\n<tr>\n<td><strong>availability window</strong></td>\n<td>The period during elections when no leader is available to coordinate cluster operations, should be minimized for system reliability</td>\n<td>Service disruption metric during leadership transitions</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight</strong>: Precise terminology prevents the subtle bugs that plague distributed systems. When we say &quot;broadcast&quot;, we mean delivery to all currently active members - not all configured members. When we say &quot;reliable delivery&quot;, we mean exactly-once delivery to reachable nodes or definitive failure notification - not infinite retries.</p>\n</blockquote>\n<p>The distinction between theoretical concepts and practical implementation details is crucial. Terms like &quot;happens-before relationship&quot; describe theoretical ordering guarantees, while terms like &quot;MessageSequencer&quot; describe concrete implementation components that enforce those guarantees.</p>\n<h3 id=\"algorithm-state-machine-terminology\">Algorithm State Machine Terminology</h3>\n<p>The election algorithms involve complex state machines with specific transition rules:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>StateFollower</strong></td>\n<td>Node state where the node recognizes another node as leader and processes heartbeats without initiating elections</td>\n<td>Default state for non-leader nodes</td>\n</tr>\n<tr>\n<td><strong>StateCandidate</strong></td>\n<td>Node state during active election participation, either initiating bully election or participating in ring token passing</td>\n<td>Temporary state during election algorithms</td>\n</tr>\n<tr>\n<td><strong>StateLeader</strong></td>\n<td>Node state where this node serves as the cluster coordinator, sending heartbeats and managing cluster operations</td>\n<td>Terminal state after winning election</td>\n</tr>\n<tr>\n<td><strong>election initiation</strong></td>\n<td>The specific conditions and logic that cause a node to transition from follower to candidate and begin election protocol</td>\n<td>Entry point for election algorithms</td>\n</tr>\n<tr>\n<td><strong>leadership assumption</strong></td>\n<td>The process where a candidate transitions to leader state after winning an election, including announcing victory and starting leader duties</td>\n<td>Critical transition requiring careful coordination</td>\n</tr>\n</tbody></table>\n<h3 id=\"message-protocol-terminology\">Message Protocol Terminology</h3>\n<p>The specific message types and communication patterns used in elections:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>MsgElection</strong></td>\n<td>Bully algorithm message sent from lower-ID node to higher-ID nodes to initiate competitive election</td>\n<td>Primary bully algorithm communication</td>\n</tr>\n<tr>\n<td><strong>MsgOK</strong></td>\n<td>Bully algorithm response sent from higher-ID node to lower-ID node to indicate participation in election</td>\n<td>Prevents lower-ID nodes from claiming premature victory</td>\n</tr>\n<tr>\n<td><strong>MsgCoordinator</strong></td>\n<td>Broadcast message announcing the winning node after election completion</td>\n<td>Final message in both election algorithms</td>\n</tr>\n<tr>\n<td><strong>MsgHeartbeat</strong></td>\n<td>Periodic message sent by leader to all followers to prove continued operation</td>\n<td>Failure detection and leadership maintenance</td>\n</tr>\n<tr>\n<td><strong>MsgRingToken</strong></td>\n<td>Ring election token message containing participant list that circulates around logical ring</td>\n<td>Central message type for ring election</td>\n</tr>\n<tr>\n<td><strong>message ordering</strong></td>\n<td>The requirement that certain election messages be processed in specific sequences to maintain algorithm correctness</td>\n<td>Critical for preventing race conditions</td>\n</tr>\n<tr>\n<td><strong>delivery guarantees</strong></td>\n<td>The reliability properties provided by the transport layer, including exactly-once delivery and failure notification</td>\n<td>Foundation for election algorithm correctness</td>\n</tr>\n</tbody></table>\n<h3 id=\"failure-modes-and-recovery\">Failure Modes and Recovery</h3>\n<p>These terms categorize the various ways elections can fail and how the system recovers:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>node crash</strong></td>\n<td>Sudden stop of a node process, detectable through heartbeat absence and connection failures</td>\n<td>Most common failure mode handled by elections</td>\n</tr>\n<tr>\n<td><strong>network partition</strong></td>\n<td>Loss of connectivity between node groups while nodes themselves remain operational</td>\n<td>Complex failure requiring quorum-based resolution</td>\n</tr>\n<tr>\n<td><strong>message loss</strong></td>\n<td>Individual messages being dropped by the network without delivery, requiring timeout and retry logic</td>\n<td>Network unreliability that algorithms must handle</td>\n</tr>\n<tr>\n<td><strong>timing failure</strong></td>\n<td>Nodes operating correctly but outside expected time bounds, causing timeout-based failures</td>\n<td>Performance degradation that can trigger elections</td>\n</tr>\n<tr>\n<td><strong>concurrent failure</strong></td>\n<td>Multiple nodes failing simultaneously, potentially during an active election</td>\n<td>Stress scenario requiring robust algorithm design</td>\n</tr>\n<tr>\n<td><strong>partition healing</strong></td>\n<td>The process of restoring connectivity and resolving state conflicts when network partitions recover</td>\n<td>Complex coordination requiring conflict resolution</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-architecture-terms\">Implementation Architecture Terms</h3>\n<p>These terms describe the specific software components and their organization:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>HTTPTransport</strong></td>\n<td>Concrete implementation of Transport interface using HTTP REST for inter-node communication</td>\n<td>Simple transport implementation for development</td>\n</tr>\n<tr>\n<td><strong>MessageBuilder</strong></td>\n<td>Utility component for constructing properly formatted election messages with required fields and validation</td>\n<td>Helper for message creation</td>\n</tr>\n<tr>\n<td><strong>ElectionTimeoutManager</strong></td>\n<td>Component that manages election deadlines and timeout callbacks with proper cancellation support</td>\n<td>Timing control for bully algorithm</td>\n</tr>\n<tr>\n<td><strong>DebugStateCollector</strong></td>\n<td>Testing component that captures snapshots of node states across the cluster for validation and debugging</td>\n<td>Debugging aid for complex election scenarios</td>\n</tr>\n<tr>\n<td><strong>ElectionFlowTracer</strong></td>\n<td>Component that tracks message flows through complete election cycles for debugging and validation</td>\n<td>Advanced debugging tool for message sequence analysis</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Important</strong>: These implementations support both algorithm-specific components (like <code>RingTopology</code> for ring elections) and shared infrastructure (like <code>FailureDetector</code> for both algorithms). Understanding which components are shared versus algorithm-specific guides correct system architecture.</p>\n</blockquote>\n<h3 id=\"testing-and-validation-concepts\">Testing and Validation Concepts</h3>\n<p>Specialized terminology for testing distributed election systems:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>chaos engineering</strong></td>\n<td>Systematic fault injection methodology that introduces random failures to discover system weaknesses and validate resilience</td>\n<td>Advanced testing approach for production readiness</td>\n</tr>\n<tr>\n<td><strong>test transport</strong></td>\n<td>A controllable transport implementation that allows precise simulation of network conditions including delays and message loss</td>\n<td>Essential infrastructure for deterministic testing</td>\n</tr>\n<tr>\n<td><strong>election invariant</strong></td>\n<td>A property that must always hold true during elections, such as &quot;at most one leader per term&quot;</td>\n<td>Safety properties that tests must validate</td>\n</tr>\n<tr>\n<td><strong>milestone validation</strong></td>\n<td>Formal verification that implementation meets specific acceptance criteria for each project milestone</td>\n<td>Structured approach to tracking progress</td>\n</tr>\n<tr>\n<td><strong>fault scenario</strong></td>\n<td>A specific combination of failures, timing, and conditions designed to test particular edge cases in election algorithms</td>\n<td>Systematic approach to testing complex failure modes</td>\n</tr>\n</tbody></table>\n<h3 id=\"advanced-performance-and-reliability\">Advanced Performance and Reliability</h3>\n<p>Terms describing sophisticated approaches to election system optimization:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>election optimization</strong></td>\n<td>Techniques to reduce election time, message overhead, or failure detection latency while maintaining correctness</td>\n<td>Performance improvements beyond basic implementation</td>\n</tr>\n<tr>\n<td><strong>back-pressure handling</strong></td>\n<td>Managing message queues and processing capacity during high election frequency or large cluster scenarios</td>\n<td>Scalability consideration for production systems</td>\n</tr>\n<tr>\n<td><strong>configuration hot-reload</strong></td>\n<td>Ability to update election parameters (timeouts, algorithms) without restarting nodes or interrupting ongoing elections</td>\n<td>Operational flexibility for production deployment</td>\n</tr>\n<tr>\n<td><strong>multi-algorithm support</strong></td>\n<td>System design that allows switching between bully, ring, or other election algorithms based on cluster conditions</td>\n<td>Advanced flexibility for different deployment scenarios</td>\n</tr>\n</tbody></table>\n<h3 id=\"debugging-and-troubleshooting\">Debugging and Troubleshooting</h3>\n<p>Specific terminology for diagnosing and fixing election system issues:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>election deadlock</strong></td>\n<td>A situation where election algorithms cannot make progress due to circular dependencies, message loss, or timing issues</td>\n<td>Pathological condition requiring detection and recovery</td>\n</tr>\n<tr>\n<td><strong>leader flapping</strong></td>\n<td>Rapid repeated leader changes due to marginal failure conditions, network instability, or poorly tuned timeouts</td>\n<td>Performance problem indicating tuning issues</td>\n</tr>\n<tr>\n<td><strong>phantom leader</strong></td>\n<td>A node that believes it is leader but other nodes don&#39;t recognize its authority, usually due to stale election state</td>\n<td>Consistency problem requiring state reconciliation</td>\n</tr>\n<tr>\n<td><strong>election livelock</strong></td>\n<td>Continuous election attempts that never converge due to timing conflicts, message ordering issues, or competing candidates</td>\n<td>Liveness problem requiring resolution mechanisms</td>\n</tr>\n</tbody></table>\n<p>This glossary provides the precise vocabulary needed to implement, test, and debug leader election systems correctly. Each term carries specific technical meaning that differs from informal usage, and understanding these distinctions is essential for building correct distributed coordination systems.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This glossary serves as the authoritative reference during implementation. When you encounter unfamiliar terminology in algorithm descriptions, message specifications, or error handling procedures, return to these definitions to ensure precise understanding.</p>\n<p><strong>A. Terminology Usage Guidelines:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Preferred Terms</th>\n<th>Avoid</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Algorithm Selection</td>\n<td>&quot;bully algorithm&quot;, &quot;ring election&quot;</td>\n<td>&quot;leader selection&quot;, &quot;coordinator voting&quot;</td>\n</tr>\n<tr>\n<td>Failure Scenarios</td>\n<td>&quot;network partition&quot;, &quot;split-brain&quot;</td>\n<td>&quot;network split&quot;, &quot;dual master&quot;</td>\n</tr>\n<tr>\n<td>Message Patterns</td>\n<td>&quot;broadcast&quot;, &quot;point-to-point&quot;</td>\n<td>&quot;multicast&quot;, &quot;unicast&quot;</td>\n</tr>\n<tr>\n<td>State Management</td>\n<td>&quot;state transition&quot;, &quot;leadership assumption&quot;</td>\n<td>&quot;state change&quot;, &quot;becoming leader&quot;</td>\n</tr>\n</tbody></table>\n<p><strong>B. Reference Implementation Constants:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Core terminology translated to implementation constants</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Node state terminology</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateFollower</span><span style=\"color:#B392F0\">  NodeState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#6A737D\">  // follower state</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateCandidate</span><span style=\"color:#B392F0\"> NodeState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#6A737D\">  // candidate state </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    StateLeader</span><span style=\"color:#B392F0\">    NodeState</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#6A737D\">  // leader state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Message type terminology</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgElection</span><span style=\"color:#B392F0\">    MessageType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#6A737D\">  // bully algorithm election</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgOK</span><span style=\"color:#B392F0\">          MessageType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#6A737D\">  // bully acknowledgment</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgCoordinator</span><span style=\"color:#B392F0\"> MessageType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#6A737D\">  // coordinator announcement</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgHeartbeat</span><span style=\"color:#B392F0\">   MessageType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#6A737D\">  // heartbeat message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MsgRingToken</span><span style=\"color:#B392F0\">   MessageType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#6A737D\">  // ring election token</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Trigger type terminology</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TriggerLeaderFailure</span><span style=\"color:#B392F0\">      TriggerType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#6A737D\">  // leader failure detection</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TriggerStartup</span><span style=\"color:#B392F0\">           TriggerType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#6A737D\">  // cluster bootstrap</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TriggerPartitionHealing</span><span style=\"color:#B392F0\">  TriggerType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#6A737D\">  // partition recovery</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TriggerManualElection</span><span style=\"color:#B392F0\">    TriggerType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#6A737D\">  // administrative trigger</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TriggerTermConflict</span><span style=\"color:#B392F0\">      TriggerType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#6A737D\">  // term conflict resolution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>C. Glossary Documentation Structure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// TermDefinition represents a single glossary entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TermDefinition</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Term        </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">   // The precise term to use</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Definition  </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">   // Complete technical definition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Context     </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\">   // Where this term applies</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Aliases     []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Deprecated or informal alternatives</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Related     []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Related terms to cross-reference</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Examples    []</span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // Concrete usage examples</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GlossaryManager maintains terminology consistency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> GlossaryManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    definitions </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TermDefinition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    categories  </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">][]</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu          </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Common Terminology Mistakes:</strong></p>\n<p>⚠️ <strong>Pitfall: Informal Algorithm Names</strong>\nUsing casual terms like &quot;leader selection&quot; instead of precise algorithm names like &quot;bully algorithm&quot; creates confusion when discussing specific protocol behavior. Each algorithm has distinct message patterns and failure handling - use exact names.</p>\n<p>⚠️ <strong>Pitfall: Overloaded &quot;Failure&quot; Term</strong>\nThe word &quot;failure&quot; means different things: node crashes, network partitions, message loss, timing violations. Always specify the failure type precisely: &quot;node crash failure&quot;, &quot;network partition failure&quot;, &quot;heartbeat timeout failure&quot;.</p>\n<p>⚠️ <strong>Pitfall: Ambiguous State Terms</strong>\nTerms like &quot;active&quot;, &quot;running&quot;, &quot;alive&quot; are ambiguous. Use precise state terminology: <code>StateLeader</code> for leadership role, &quot;reachable&quot; for network connectivity, &quot;participating&quot; for election involvement.</p>\n<p><strong>E. Milestone Terminology Checkpoint:</strong></p>\n<p>After implementing each milestone, verify your code uses consistent terminology:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Check terminology consistency in code</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">grep</span><span style=\"color:#79B8FF\"> -r</span><span style=\"color:#9ECBFF\"> \"leader selection\"</span><span style=\"color:#9ECBFF\"> .</span><span style=\"color:#6A737D\">  # Should find zero matches</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">grep</span><span style=\"color:#79B8FF\"> -r</span><span style=\"color:#9ECBFF\"> \"bully algorithm\"</span><span style=\"color:#9ECBFF\"> .</span><span style=\"color:#6A737D\">   # Should find multiple matches</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">grep</span><span style=\"color:#79B8FF\"> -r</span><span style=\"color:#9ECBFF\"> \"StateLeader\"</span><span style=\"color:#9ECBFF\"> .</span><span style=\"color:#6A737D\">       # Should find state machine usage</span></span></code></pre></div>\n\n<p><strong>F. Documentation Cross-Reference:</strong></p>\n<p>When writing code comments or documentation, reference this glossary to maintain consistency:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// StartElection initiates a new leader election using the bully algorithm.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is an \"election trigger\" event that causes state transition from</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StateFollower to StateCandidate. The election will send MsgElection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// messages to all higher-ID nodes per bully algorithm protocol.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">be </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BullyElection</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartElection</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Implementation maps to glossary terms</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>This comprehensive glossary ensures that all team members, documentation, code comments, and technical discussions use consistent terminology that accurately reflects distributed systems concepts and algorithm specifications.</p>\n","toc":[{"level":1,"text":"Leader Election: Design Document","id":"leader-election-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: Parliamentary Speaker Election","id":"mental-model-parliamentary-speaker-election"},{"level":3,"text":"The Distributed Coordination Problem","id":"the-distributed-coordination-problem"},{"level":4,"text":"Formal Requirements","id":"formal-requirements"},{"level":4,"text":"The Failure Model","id":"the-failure-model"},{"level":4,"text":"State Consistency During Elections","id":"state-consistency-during-elections"},{"level":3,"text":"Comparison of Election Algorithms","id":"comparison-of-election-algorithms"},{"level":4,"text":"Algorithm Characteristics Matrix","id":"algorithm-characteristics-matrix"},{"level":4,"text":"Bully Algorithm Deep Analysis","id":"bully-algorithm-deep-analysis"},{"level":4,"text":"Ring Election Deep Analysis","id":"ring-election-deep-analysis"},{"level":4,"text":"Election Algorithm Selection Criteria","id":"election-algorithm-selection-criteria"},{"level":4,"text":"Election Trigger Conditions","id":"election-trigger-conditions"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Project Structure","id":"recommended-project-structure"},{"level":4,"text":"Core Type Definitions","id":"core-type-definitions"},{"level":4,"text":"Transport Layer Interface","id":"transport-layer-interface"},{"level":4,"text":"Election Coordinator Interface","id":"election-coordinator-interface"},{"level":4,"text":"Starter Code: Basic HTTP Transport","id":"starter-code-basic-http-transport"},{"level":4,"text":"Core Algorithm Skeletons","id":"core-algorithm-skeletons"},{"level":4,"text":"Ring Election Implementation Skeleton","id":"ring-election-implementation-skeleton"},{"level":4,"text":"Milestone Validation Checkpoints","id":"milestone-validation-checkpoints"},{"level":4,"text":"Common Implementation Pitfalls","id":"common-implementation-pitfalls"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Functional Requirements","id":"functional-requirements"},{"level":4,"text":"Core Election Behaviors","id":"core-election-behaviors"},{"level":4,"text":"Node Communication Requirements","id":"node-communication-requirements"},{"level":4,"text":"State Management and Consistency","id":"state-management-and-consistency"},{"level":3,"text":"Performance and Reliability Requirements","id":"performance-and-reliability-requirements"},{"level":4,"text":"Election Timing Requirements","id":"election-timing-requirements"},{"level":4,"text":"Scalability and Resource Requirements","id":"scalability-and-resource-requirements"},{"level":4,"text":"Reliability and Fault Tolerance","id":"reliability-and-fault-tolerance"},{"level":3,"text":"Out of Scope","id":"out-of-scope"},{"level":4,"text":"Advanced Distributed Systems Features","id":"advanced-distributed-systems-features"},{"level":4,"text":"Production-Ready Operations Features","id":"production-ready-operations-features"},{"level":4,"text":"Advanced Election Features","id":"advanced-election-features"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Data Structures","id":"core-data-structures"},{"level":4,"text":"Transport Layer Foundation","id":"transport-layer-foundation"},{"level":4,"text":"Election Coordinator Interface","id":"election-coordinator-interface"},{"level":4,"text":"Milestone Validation Checkpoints","id":"milestone-validation-checkpoints"},{"level":4,"text":"Common Implementation Pitfalls","id":"common-implementation-pitfalls"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Mental Model: Orchestra Conductor Selection","id":"mental-model-orchestra-conductor-selection"},{"level":3,"text":"System Components","id":"system-components"},{"level":4,"text":"Node Manager","id":"node-manager"},{"level":4,"text":"Message Layer (Transport)","id":"message-layer-transport"},{"level":4,"text":"Election Coordinator","id":"election-coordinator"},{"level":4,"text":"Failure Detector","id":"failure-detector"},{"level":3,"text":"Inter-Node Communication","id":"inter-node-communication"},{"level":4,"text":"Node Discovery and Membership","id":"node-discovery-and-membership"},{"level":4,"text":"Message Routing and Delivery","id":"message-routing-and-delivery"},{"level":4,"text":"Network Partition Handling","id":"network-partition-handling"},{"level":4,"text":"Message Serialization and Protocol","id":"message-serialization-and-protocol"},{"level":3,"text":"Recommended Project Organization","id":"recommended-project-organization"},{"level":4,"text":"Directory Structure","id":"directory-structure"},{"level":4,"text":"Module Responsibilities and Dependencies","id":"module-responsibilities-and-dependencies"},{"level":4,"text":"Interface Boundaries and Testing Strategy","id":"interface-boundaries-and-testing-strategy"},{"level":4,"text":"Development Workflow and Build Process","id":"development-workflow-and-build-process"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure and Starter Code","id":"recommended-file-structure-and-starter-code"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Data Model and Message Types","id":"data-model-and-message-types"},{"level":3,"text":"Mental Model: Diplomatic Protocol","id":"mental-model-diplomatic-protocol"},{"level":3,"text":"Node Identity and State","id":"node-identity-and-state"},{"level":3,"text":"Election Message Formats","id":"election-message-formats"},{"level":3,"text":"Cluster Membership Model","id":"cluster-membership-model"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Node Communication Layer","id":"node-communication-layer"},{"level":3,"text":"Mental Model: Postal Service with Tracking","id":"mental-model-postal-service-with-tracking"},{"level":3,"text":"Node Discovery and Membership","id":"node-discovery-and-membership"},{"level":3,"text":"Reliable Message Passing","id":"reliable-message-passing"},{"level":3,"text":"Failure Detection and Heartbeats","id":"failure-detection-and-heartbeats"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Bully Election Algorithm","id":"bully-election-algorithm"},{"level":3,"text":"Mental Model: Corporate Hierarchy Challenge","id":"mental-model-corporate-hierarchy-challenge"},{"level":3,"text":"Bully Algorithm Steps","id":"bully-algorithm-steps"},{"level":3,"text":"Bully Election State Management","id":"bully-election-state-management"},{"level":3,"text":"Bully Algorithm Edge Cases","id":"bully-algorithm-edge-cases"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Ring Election Algorithm","id":"ring-election-algorithm"},{"level":3,"text":"Mental Model: Passing the Torch","id":"mental-model-passing-the-torch"},{"level":3,"text":"Logical Ring Construction","id":"logical-ring-construction"},{"level":4,"text":"Ring Ordering and Successor Calculation","id":"ring-ordering-and-successor-calculation"},{"level":4,"text":"Ring Construction Algorithm","id":"ring-construction-algorithm"},{"level":4,"text":"Handling Ring Membership Changes","id":"handling-ring-membership-changes"},{"level":4,"text":"Ring State Representation","id":"ring-state-representation"},{"level":3,"text":"Ring Election Protocol","id":"ring-election-protocol"},{"level":4,"text":"Election Token Structure","id":"election-token-structure"},{"level":4,"text":"Token Passing State Machine","id":"token-passing-state-machine"},{"level":4,"text":"Ring Election Steps","id":"ring-election-steps"},{"level":4,"text":"Token Circulation Example","id":"token-circulation-example"},{"level":4,"text":"Concurrent Election Handling","id":"concurrent-election-handling"},{"level":3,"text":"Ring Maintenance and Repair","id":"ring-maintenance-and-repair"},{"level":4,"text":"Failure Detection in Ring Context","id":"failure-detection-in-ring-context"},{"level":4,"text":"Ring Repair Algorithm","id":"ring-repair-algorithm"},{"level":4,"text":"Partition Healing and Ring Reconstruction","id":"partition-healing-and-ring-reconstruction"},{"level":4,"text":"Ring State Consistency","id":"ring-state-consistency"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Ring Topology Infrastructure Code","id":"ring-topology-infrastructure-code"},{"level":4,"text":"Ring Election Core Logic Skeleton","id":"ring-election-core-logic-skeleton"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"System Interactions and Data Flow","id":"system-interactions-and-data-flow"},{"level":3,"text":"Election Initiation Scenarios","id":"election-initiation-scenarios"},{"level":4,"text":"Failure Detection Triggers","id":"failure-detection-triggers"},{"level":4,"text":"Startup and Bootstrap Scenarios","id":"startup-and-bootstrap-scenarios"},{"level":4,"text":"Network Partition Recovery","id":"network-partition-recovery"},{"level":4,"text":"Manual Election Triggers","id":"manual-election-triggers"},{"level":3,"text":"Message Sequence Patterns","id":"message-sequence-patterns"},{"level":4,"text":"Bully Algorithm Message Flow","id":"bully-algorithm-message-flow"},{"level":4,"text":"Ring Election Message Flow","id":"ring-election-message-flow"},{"level":4,"text":"Concurrent Election Resolution","id":"concurrent-election-resolution"},{"level":3,"text":"Leader Responsibilities","id":"leader-responsibilities"},{"level":4,"text":"Heartbeat and Liveness Maintenance","id":"heartbeat-and-liveness-maintenance"},{"level":4,"text":"Membership Management and Discovery","id":"membership-management-and-discovery"},{"level":4,"text":"Application-Specific Coordination","id":"application-specific-coordination"},{"level":4,"text":"Graceful Leadership Transitions","id":"graceful-leadership-transitions"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Election Coordinator Infrastructure","id":"election-coordinator-infrastructure"},{"level":4,"text":"Message Sequence Controller","id":"message-sequence-controller"},{"level":4,"text":"Leadership Manager","id":"leadership-manager"},{"level":4,"text":"Integration Testing Framework","id":"integration-testing-framework"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Failure Taxonomy","id":"failure-taxonomy"},{"level":4,"text":"Node Failures","id":"node-failures"},{"level":4,"text":"Network Failures","id":"network-failures"},{"level":4,"text":"Timing Failures","id":"timing-failures"},{"level":4,"text":"State Corruption Failures","id":"state-corruption-failures"},{"level":3,"text":"Split-Brain Scenarios","id":"split-brain-scenarios"},{"level":4,"text":"Understanding Split-Brain Formation","id":"understanding-split-brain-formation"},{"level":4,"text":"Split-Brain Prevention Mechanisms","id":"split-brain-prevention-mechanisms"},{"level":4,"text":"Split-Brain Detection Strategies","id":"split-brain-detection-strategies"},{"level":4,"text":"Conflict Resolution Protocols","id":"conflict-resolution-protocols"},{"level":3,"text":"Failure Recovery Mechanisms","id":"failure-recovery-mechanisms"},{"level":4,"text":"Leader Failure Recovery","id":"leader-failure-recovery"},{"level":4,"text":"Cascading Failure Handling","id":"cascading-failure-handling"},{"level":4,"text":"Network Partition Recovery","id":"network-partition-recovery"},{"level":4,"text":"Recovery Validation and Monitoring","id":"recovery-validation-and-monitoring"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Testing Strategy and Validation","id":"testing-strategy-and-validation"},{"level":3,"text":"Mental Model: Quality Assurance Theater Production","id":"mental-model-quality-assurance-theater-production"},{"level":3,"text":"Component-Level Testing","id":"component-level-testing"},{"level":4,"text":"Transport Layer Component Testing","id":"transport-layer-component-testing"},{"level":4,"text":"Cluster Membership Testing","id":"cluster-membership-testing"},{"level":4,"text":"Failure Detector Validation","id":"failure-detector-validation"},{"level":4,"text":"Election Algorithm Component Testing","id":"election-algorithm-component-testing"},{"level":4,"text":"Timeout Manager Testing","id":"timeout-manager-testing"},{"level":3,"text":"Multi-Node Scenarios","id":"multi-node-scenarios"},{"level":4,"text":"Election Flow Validation","id":"election-flow-validation"},{"level":4,"text":"Concurrent Election Handling","id":"concurrent-election-handling"},{"level":4,"text":"Membership Change Integration","id":"membership-change-integration"},{"level":4,"text":"Message Ordering and Timing","id":"message-ordering-and-timing"},{"level":4,"text":"Leader Transition Validation","id":"leader-transition-validation"},{"level":3,"text":"Fault Injection Testing","id":"fault-injection-testing"},{"level":4,"text":"Network Failure Simulation","id":"network-failure-simulation"},{"level":4,"text":"Node Failure Patterns","id":"node-failure-patterns"},{"level":4,"text":"Timing Failure Injection","id":"timing-failure-injection"},{"level":4,"text":"Cascading Failure Testing","id":"cascading-failure-testing"},{"level":3,"text":"Milestone Validation Checkpoints","id":"milestone-validation-checkpoints"},{"level":4,"text":"Milestone 1: Node Communication Validation","id":"milestone-1-node-communication-validation"},{"level":4,"text":"Milestone 2: Bully Algorithm Validation","id":"milestone-2-bully-algorithm-validation"},{"level":4,"text":"Milestone 3: Ring Election Validation","id":"milestone-3-ring-election-validation"},{"level":4,"text":"Cross-Milestone Integration Validation","id":"cross-milestone-integration-validation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Testing Infrastructure Components","id":"testing-infrastructure-components"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Mental Model: Detective Work with Multiple Witnesses","id":"mental-model-detective-work-with-multiple-witnesses"},{"level":3,"text":"Symptom-Cause-Fix Reference","id":"symptom-cause-fix-reference"},{"level":3,"text":"Debugging Strategies","id":"debugging-strategies"},{"level":3,"text":"Logging and Observability","id":"logging-and-observability"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Structured Logging Infrastructure","id":"structured-logging-infrastructure"},{"level":4,"text":"Debug State Snapshot Utilities","id":"debug-state-snapshot-utilities"},{"level":4,"text":"Message Flow Tracer","id":"message-flow-tracer"},{"level":4,"text":"Fault Injection Testing Framework","id":"fault-injection-testing-framework"},{"level":4,"text":"Milestone Debugging Checkpoints","id":"milestone-debugging-checkpoints"},{"level":4,"text":"Common Debugging Symptoms and Fixes","id":"common-debugging-symptoms-and-fixes"},{"level":2,"text":"Future Extensions and Improvements","id":"future-extensions-and-improvements"},{"level":3,"text":"Performance Improvements","id":"performance-improvements"},{"level":4,"text":"Adaptive Timeout Management","id":"adaptive-timeout-management"},{"level":4,"text":"Batched Message Delivery","id":"batched-message-delivery"},{"level":4,"text":"Concurrent Election Resolution","id":"concurrent-election-resolution"},{"level":4,"text":"Optimized Ring Maintenance","id":"optimized-ring-maintenance"},{"level":3,"text":"Other Election Algorithms","id":"other-election-algorithms"},{"level":4,"text":"Raft Leader Election","id":"raft-leader-election"},{"level":4,"text":"SWIM-based Failure Detection","id":"swim-based-failure-detection"},{"level":4,"text":"Weighted Election Algorithms","id":"weighted-election-algorithms"},{"level":4,"text":"Byzantine Fault Tolerant Elections","id":"byzantine-fault-tolerant-elections"},{"level":3,"text":"Production Readiness Features","id":"production-readiness-features"},{"level":4,"text":"Comprehensive Metrics and Monitoring","id":"comprehensive-metrics-and-monitoring"},{"level":4,"text":"Dynamic Configuration Management","id":"dynamic-configuration-management"},{"level":4,"text":"Advanced Logging and Debugging","id":"advanced-logging-and-debugging"},{"level":4,"text":"Operational Tools and Automation","id":"operational-tools-and-automation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Module Structure","id":"recommended-module-structure"},{"level":4,"text":"Adaptive Timeout Infrastructure Code","id":"adaptive-timeout-infrastructure-code"},{"level":4,"text":"Raft Leader Election Core Logic","id":"raft-leader-election-core-logic"},{"level":4,"text":"Production Metrics Infrastructure","id":"production-metrics-infrastructure"},{"level":4,"text":"Dynamic Configuration Management","id":"dynamic-configuration-management"},{"level":4,"text":"Milestone Checkpoint: Performance Extensions","id":"milestone-checkpoint-performance-extensions"},{"level":4,"text":"Milestone Checkpoint: Advanced Algorithms","id":"milestone-checkpoint-advanced-algorithms"},{"level":4,"text":"Milestone Checkpoint: Production Features","id":"milestone-checkpoint-production-features"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Mental Model: The Diplomatic Dictionary","id":"mental-model-the-diplomatic-dictionary"},{"level":3,"text":"Core Distributed Systems Concepts","id":"core-distributed-systems-concepts"},{"level":3,"text":"Election Algorithm Specifics","id":"election-algorithm-specifics"},{"level":3,"text":"Message Types and Communication","id":"message-types-and-communication"},{"level":3,"text":"System State and Node Roles","id":"system-state-and-node-roles"},{"level":3,"text":"Network and Failure Handling","id":"network-and-failure-handling"},{"level":3,"text":"Testing and Validation Terminology","id":"testing-and-validation-terminology"},{"level":3,"text":"Debugging and Observability","id":"debugging-and-observability"},{"level":3,"text":"Advanced Algorithms and Extensions","id":"advanced-algorithms-and-extensions"},{"level":3,"text":"Data Structures and Implementation Details","id":"data-structures-and-implementation-details"},{"level":3,"text":"Testing Infrastructure Components","id":"testing-infrastructure-components"},{"level":3,"text":"Performance and Reliability Metrics","id":"performance-and-reliability-metrics"},{"level":3,"text":"Algorithm State Machine Terminology","id":"algorithm-state-machine-terminology"},{"level":3,"text":"Message Protocol Terminology","id":"message-protocol-terminology"},{"level":3,"text":"Failure Modes and Recovery","id":"failure-modes-and-recovery"},{"level":3,"text":"Implementation Architecture Terms","id":"implementation-architecture-terms"},{"level":3,"text":"Testing and Validation Concepts","id":"testing-and-validation-concepts"},{"level":3,"text":"Advanced Performance and Reliability","id":"advanced-performance-and-reliability"},{"level":3,"text":"Debugging and Troubleshooting","id":"debugging-and-troubleshooting"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"}],"title":"Leader Election: Design Document","markdown":"# Leader Election: Design Document\n\n\n## Overview\n\nThis system implements distributed leader election algorithms to coordinate cluster operations and handle node failures. The key architectural challenge is ensuring exactly one leader emerges even during network partitions, concurrent elections, and cascading failures.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** Foundation for all milestones - understanding the fundamental challenges that leader election solves\n\n### Mental Model: Parliamentary Speaker Election\n\nThink of distributed leader election like electing a **Speaker of the House** in a parliament. In a parliament, hundreds of members need to coordinate their activities - scheduling debates, managing speaking time, maintaining order during votes. Without a clear authority figure, chaos would ensue with everyone talking at once, conflicting schedules, and no way to reach decisive outcomes.\n\nThe **Speaker** serves as the single point of coordination. They have the authority to recognize speakers, call votes, and make procedural decisions. Crucially, there can only be **one Speaker at a time** - having multiple people claiming to be Speaker would create competing orders and parliamentary deadlock.\n\nNow imagine this parliament is spread across multiple buildings connected by an unreliable phone system. Members occasionally lose phone service, buildings get isolated due to network outages, and sometimes members simply crash (literally fall asleep at their desks). Despite these failures, the parliament must continue functioning, which means they need a **robust process for electing a new Speaker** whenever the current one becomes unavailable.\n\nThe **election process** itself faces challenges: What if multiple members simultaneously notice the Speaker is unavailable and each tries to claim the role? What if the phone system partitions the parliament into two groups, each electing their own Speaker? What if a member claims to be Speaker but then immediately becomes unreachable?\n\nJust like parliamentary procedure has evolved formal rules for Speaker election (quorum requirements, nomination processes, voting protocols), distributed systems need **election algorithms** with precisely defined steps to ensure exactly one leader emerges even during failures and network problems.\n\nThis analogy captures the essential tension: we need strong coordination (single leader) in an environment prone to communication failures and member unavailability. The algorithms we'll implement - **Bully** and **Ring** election - are like different parliamentary procedures, each with distinct approaches to achieving the same fundamental goal: establishing legitimate authority that all members recognize.\n\n### The Distributed Coordination Problem\n\n**Leader election** is a fundamental building block in distributed systems where multiple nodes must coordinate their actions through a single designated coordinator. The leader serves as the authoritative decision-maker for tasks like resource allocation, transaction coordination, task scheduling, and maintaining cluster-wide invariants.\n\nThe core challenge emerges from the **impossibility of instantaneous communication** in distributed environments. Unlike single-machine programs where components can share memory and communicate through direct function calls, distributed nodes communicate through unreliable networks with variable latency, message loss, and potential partitions.\n\n#### Formal Requirements\n\nA correct leader election algorithm must satisfy several **safety and liveness properties**:\n\n**Safety Properties** (nothing bad happens):\n- **Uniqueness**: At most one node can be the leader at any given time\n- **Agreement**: All non-partitioned nodes agree on the identity of the current leader  \n- **Validity**: Only live, reachable nodes can become leaders\n\n**Liveness Properties** (something good eventually happens):\n- **Termination**: Every election eventually completes with a leader chosen\n- **Progress**: The system continues operating despite bounded failures\n- **Availability**: A new leader is elected within bounded time after the current leader fails\n\n#### The Failure Model\n\nLeader election algorithms must handle multiple categories of failures simultaneously:\n\n| Failure Type | Description | Impact on Election | Detection Method |\n|--------------|-------------|-------------------|------------------|\n| **Node Crash** | Process terminates or machine shuts down | Current leader becomes unavailable | Heartbeat timeout |\n| **Network Partition** | Subset of nodes becomes unreachable | Split-brain risk with multiple leaders | Connectivity matrix changes |\n| **Message Loss** | Individual messages dropped during transmission | Election messages don't arrive | Acknowledgment timeout |\n| **Message Delay** | Messages arrive after expected timeouts | False failure detection | Adaptive timeout tuning |\n| **Byzantine Faults** | Nodes send incorrect or malicious messages | Leaders may give conflicting orders | Message validation (out of scope) |\n\nThe **split-brain scenario** represents the most dangerous failure mode. When a network partition divides the cluster, each partition may independently elect its own leader. If both leaders continue operating, they can make conflicting decisions that violate system invariants. For example, two leaders might both grant exclusive access to the same resource, leading to data corruption.\n\n> **Critical Insight**: The fundamental tension in leader election is between **availability** and **consistency**. Aggressive failure detection ensures quick leader transitions (availability) but increases the risk of false positives that trigger unnecessary elections. Conservative failure detection reduces false positives but means longer periods without leadership during actual failures.\n\n#### State Consistency During Elections\n\nDuring the **election period**, the cluster exists in a temporary state without established leadership. This creates several coordination challenges:\n\n1. **Client Request Handling**: Should nodes accept new client requests when no leader exists? Accepting requests risks inconsistency, while rejecting requests impacts availability.\n\n2. **Partial Election State**: Nodes may have different views of the election's progress due to message delays or losses. Some nodes might believe candidate A is winning while others support candidate B.\n\n3. **Multiple Concurrent Elections**: Network delays might cause multiple nodes to simultaneously detect leader failure and initiate competing elections.\n\n4. **Election Termination**: Nodes must reliably detect when an election completes and identify the winner, even if they missed some election messages.\n\nThe algorithms we implement address these challenges through different approaches to **election coordination** and **failure handling**.\n\n### Comparison of Election Algorithms\n\nDifferent leader election algorithms make distinct trade-offs between **message complexity**, **election latency**, **fault tolerance**, and **implementation complexity**. Understanding these trade-offs is crucial for selecting the appropriate algorithm for specific system requirements.\n\n#### Algorithm Characteristics Matrix\n\n| Algorithm | Message Complexity | Election Latency | Fault Tolerance | Network Topology | Best Use Case |\n|-----------|-------------------|------------------|-----------------|------------------|---------------|\n| **Bully** | O(n²) worst case | 2-3 message rounds | Handles crash failures | Fully connected | Small clusters, stable networks |\n| **Ring** | O(n) messages | Full ring traversal | Handles crash + partitions | Logical ring | Moderate clusters, predictable topology |\n| **Raft** (future) | O(n) messages | Majority consensus | Handles complex failures | Fully connected | Production systems, strong consistency |\n\n> **Decision: Primary Algorithms for Implementation**\n> - **Context**: Need to demonstrate different approaches to distributed election with varying complexity and failure handling\n> - **Options Considered**: \n>   1. Focus only on Bully (simpler implementation, fewer concepts)\n>   2. Implement Bully + Ring (contrasting approaches, broader learning)\n>   3. Include Raft leader election (production-grade but much more complex)\n> - **Decision**: Implement both Bully and Ring algorithms\n> - **Rationale**: Bully teaches basic election concepts with straightforward message patterns, while Ring demonstrates token-passing approaches and topology management. Together they illustrate the fundamental design space without overwhelming complexity.\n> - **Consequences**: Increases implementation scope but provides deeper understanding of election trade-offs. Ring algorithm requires additional topology management complexity.\n\n#### Bully Algorithm Deep Analysis\n\nThe **Bully algorithm** follows a hierarchical approach where higher-priority nodes (typically those with larger numeric IDs) can \"bully\" lower-priority nodes out of leadership claims. This creates a deterministic outcome based on node priorities.\n\n**Algorithm Mechanics:**\n1. When a node detects leader failure, it initiates an election by sending `ELECTION` messages to all nodes with higher IDs\n2. Any higher-ID node that receives an `ELECTION` message responds with `OK` and starts its own election\n3. If a node receives any `OK` response, it abandons its election attempt\n4. If no `OK` responses arrive within a timeout, the node declares itself leader and broadcasts `COORDINATOR`\n5. All nodes accept the first valid `COORDINATOR` announcement\n\n**Strengths of Bully Algorithm:**\n- **Deterministic outcomes**: The highest-ID live node always becomes leader\n- **Simple message patterns**: Only three message types (ELECTION, OK, COORDINATOR)  \n- **Fast convergence**: Typically completes in 2-3 message rounds\n- **Clear termination**: Explicit COORDINATOR broadcast signals completion\n\n**Weaknesses of Bully Algorithm:**\n- **Message overhead**: In worst case, generates O(n²) messages during election\n- **Network dependency**: Requires reliable communication between all node pairs\n- **Cascading elections**: High-priority node returning after failure immediately triggers new election\n- **Split-brain vulnerability**: Network partitions can result in multiple leaders\n\n#### Ring Election Deep Analysis  \n\nThe **Ring election algorithm** organizes nodes into a logical ring topology where election tokens circulate to collect information about all live nodes before selecting a leader.\n\n**Algorithm Mechanics:**\n1. Nodes are arranged in a logical ring ordered by their IDs\n2. When election starts, initiating node creates a token containing its own ID\n3. Token travels around the ring, with each node adding its ID to the token\n4. When token returns to the initiator, it contains IDs of all live nodes\n5. The node with the highest ID in the token becomes the new leader\n6. A `COORDINATOR` message announces the winner to all nodes\n\n**Strengths of Ring Algorithm:**\n- **Linear message complexity**: Exactly O(n) messages per election\n- **Comprehensive failure detection**: Token collection identifies all live nodes\n- **Partition tolerance**: Partial rings can still elect leaders within partitions\n- **Predictable message flow**: Token follows well-defined path around ring\n\n**Weaknesses of Ring Algorithm:**\n- **Higher latency**: Requires full ring traversal before decision\n- **Topology maintenance**: Ring structure must be maintained as nodes join/leave\n- **Single point of failure**: Token loss requires election restart\n- **Ring repair complexity**: Failed nodes must be bypassed to maintain token flow\n\n#### Election Algorithm Selection Criteria\n\n| System Requirement | Favors Bully | Favors Ring | Rationale |\n|-------------------|--------------|-------------|-----------|\n| **Small cluster size (< 10 nodes)** | ✓ | | Bully's O(n²) overhead is acceptable |\n| **Large cluster size (> 20 nodes)** | | ✓ | Ring's O(n) complexity scales better |\n| **Frequent leader changes** | ✓ | | Bully's faster convergence reduces disruption |\n| **Network partitions common** | | ✓ | Ring handles partitions more gracefully |\n| **Simple implementation priority** | ✓ | | Bully has fewer moving parts |\n| **Predictable message patterns** | | ✓ | Ring's structured flow aids debugging |\n\n> **Key Design Insight**: The choice between election algorithms often comes down to whether you prioritize **speed of election** (Bully) or **predictable resource usage** (Ring). Bully optimizes for the common case of stable leadership with occasional elections, while Ring optimizes for consistent behavior even during frequent elections or network instability.\n\n#### Election Trigger Conditions\n\nBoth algorithms must handle multiple scenarios that can trigger new leadership elections:\n\n**Primary Triggers:**\n- **Leader failure detection**: Current leader stops responding to heartbeats\n- **Leader abdication**: Current leader voluntarily steps down (planned maintenance, resource constraints)\n- **Network partition resolution**: Previously partitioned nodes reconnect and discover conflicting leaders\n- **Higher-priority node recovery**: In Bully, a previously failed high-ID node returning online immediately triggers re-election\n\n**Secondary Triggers:**\n- **Election timeout**: Previous election failed to complete, requiring restart\n- **Inconsistent leader state**: Nodes discover they have different views of current leader\n- **Manual election**: Administrative command forces new leader selection\n\nThe **election trigger logic** must be carefully designed to avoid both false positives (unnecessary elections that waste resources) and false negatives (failing to detect actual leader failures). This requires tunable timeout parameters and potentially adaptive failure detection based on network conditions.\n\nEach algorithm handles these triggers differently. Bully's aggressive approach means any trigger results in immediate election attempts by multiple nodes. Ring's structured approach typically designates specific nodes (like the failed leader's successor) to initiate elections, reducing the chaos of multiple simultaneous attempts.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Inter-node Transport** | HTTP REST + JSON (net/http) | gRPC with Protocol Buffers |\n| **Node Discovery** | Static configuration file | Consul service discovery |\n| **Message Serialization** | JSON with encoding/json | Protocol Buffers or MessagePack |\n| **Failure Detection** | Simple TCP heartbeats | SWIM gossip protocol |\n| **Logging** | Standard log package | Structured logging with logrus/zap |\n| **Configuration** | Environment variables | YAML/TOML with viper |\n\nFor learning purposes, start with the simple options and upgrade to advanced options only after core functionality works correctly.\n\n#### Recommended Project Structure\n\n```go\nleader-election/\n  cmd/\n    node/\n      main.go                    ← Node entry point and CLI setup\n  internal/\n    node/\n      node.go                    ← Core node identity and state management\n      node_test.go\n    transport/\n      transport.go               ← Message passing interface definition\n      http_transport.go          ← HTTP-based transport implementation\n      transport_test.go\n    discovery/\n      discovery.go               ← Node discovery interface\n      static_discovery.go        ← Configuration-based discovery\n      discovery_test.go\n    election/\n      types.go                   ← Common election message types\n      bully.go                   ← Bully algorithm implementation\n      ring.go                    ← Ring algorithm implementation\n      election_test.go\n    detector/\n      failure_detector.go        ← Heartbeat and failure detection\n      detector_test.go\n  pkg/\n    messages/\n      messages.go                ← Public message type definitions\n  config/\n    node1.yaml                   ← Example node configurations\n    node2.yaml\n  scripts/\n    start_cluster.sh             ← Helper script for testing\n  README.md\n  go.mod\n  go.sum\n```\n\n#### Core Type Definitions\n\n```go\n// NodeID represents a unique identifier for cluster nodes\ntype NodeID uint64\n\n// NodeState represents the current state of a node in the election process\ntype NodeState int\n\nconst (\n    StateFollower  NodeState = iota  // Node follows current leader\n    StateCandidate                   // Node is participating in election\n    StateLeader                      // Node is current cluster leader\n)\n\n// Node represents a cluster member with election capabilities\ntype Node struct {\n    ID       NodeID\n    Address  string\n    State    NodeState\n    // TODO: Add fields for current leader tracking, election state, etc.\n}\n\n// MessageType distinguishes different election message categories\ntype MessageType int\n\nconst (\n    MsgElection    MessageType = iota  // Bully algorithm election message\n    MsgOK                              // Bully algorithm acknowledgment\n    MsgCoordinator                     // Leader announcement message\n    MsgHeartbeat                       // Failure detection heartbeat\n    MsgRingToken                       // Ring algorithm election token\n)\n```\n\n#### Transport Layer Interface\n\n```go\n// Transport defines the interface for inter-node communication\ntype Transport interface {\n    // SendMessage sends a message to a specific node\n    SendMessage(target NodeID, msg Message) error\n    \n    // BroadcastMessage sends a message to all known nodes\n    BroadcastMessage(msg Message) error\n    \n    // ReceiveMessages returns a channel for incoming messages\n    ReceiveMessages() <-chan Message\n    \n    // RegisterNode adds a node to the known peers list\n    RegisterNode(id NodeID, address string) error\n    \n    // Start begins listening for incoming messages\n    Start() error\n    \n    // Stop cleanly shuts down the transport\n    Stop() error\n}\n\n// Message represents any inter-node communication\ntype Message struct {\n    Type     MessageType\n    From     NodeID\n    To       NodeID        // NodeID(0) for broadcast messages\n    Payload  []byte        // JSON-serialized message content\n}\n```\n\n#### Election Coordinator Interface\n\n```go\n// ElectionCoordinator manages the leader election process\ntype ElectionCoordinator interface {\n    // StartElection initiates a new leader election\n    StartElection() error\n    \n    // HandleMessage processes incoming election-related messages\n    HandleMessage(msg Message) error\n    \n    // GetCurrentLeader returns the current leader's ID (or 0 if none)\n    GetCurrentLeader() NodeID\n    \n    // IsLeader returns true if this node is currently the leader\n    IsLeader() bool\n    \n    // GetState returns the current election state of this node\n    GetState() NodeState\n}\n```\n\n#### Starter Code: Basic HTTP Transport\n\nThis complete implementation handles the networking complexity so learners can focus on election algorithms:\n\n```go\npackage transport\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n    \"sync\"\n    \"time\"\n)\n\n// HTTPTransport implements Transport using HTTP REST API\ntype HTTPTransport struct {\n    nodeID   NodeID\n    port     int\n    peers    map[NodeID]string  // NodeID -> \"host:port\"\n    messages chan Message\n    server   *http.Server\n    mu       sync.RWMutex\n}\n\n// NewHTTPTransport creates a new HTTP-based transport\nfunc NewHTTPTransport(nodeID NodeID, port int) *HTTPTransport {\n    return &HTTPTransport{\n        nodeID:   nodeID,\n        port:     port,\n        peers:    make(map[NodeID]string),\n        messages: make(chan Message, 100),\n    }\n}\n\n// Start begins listening for HTTP requests\nfunc (t *HTTPTransport) Start() error {\n    mux := http.NewServeMux()\n    mux.HandleFunc(\"/message\", t.handleMessage)\n    \n    t.server = &http.Server{\n        Addr:    fmt.Sprintf(\":%d\", t.port),\n        Handler: mux,\n    }\n    \n    go func() {\n        if err := t.server.ListenAndServe(); err != http.ErrServerClosed {\n            // Log error in production code\n        }\n    }()\n    \n    return nil\n}\n\n// SendMessage sends an HTTP POST to the target node\nfunc (t *HTTPTransport) SendMessage(target NodeID, msg Message) error {\n    t.mu.RLock()\n    address, exists := t.peers[target]\n    t.mu.RUnlock()\n    \n    if !exists {\n        return fmt.Errorf(\"unknown target node %d\", target)\n    }\n    \n    payload, err := json.Marshal(msg)\n    if err != nil {\n        return err\n    }\n    \n    url := fmt.Sprintf(\"http://%s/message\", address)\n    resp, err := http.Post(url, \"application/json\", bytes.NewReader(payload))\n    if err != nil {\n        return err\n    }\n    resp.Body.Close()\n    \n    return nil\n}\n\n// ReceiveMessages returns the channel for incoming messages\nfunc (t *HTTPTransport) ReceiveMessages() <-chan Message {\n    return t.messages\n}\n\n// handleMessage processes incoming HTTP requests\nfunc (t *HTTPTransport) handleMessage(w http.ResponseWriter, r *http.Request) {\n    var msg Message\n    if err := json.NewDecoder(r.Body).Decode(&msg); err != nil {\n        http.Error(w, \"Invalid JSON\", http.StatusBadRequest)\n        return\n    }\n    \n    select {\n    case t.messages <- msg:\n        w.WriteHeader(http.StatusOK)\n    default:\n        http.Error(w, \"Message queue full\", http.StatusServiceUnavailable)\n    }\n}\n\n// Additional methods: BroadcastMessage, RegisterNode, Stop...\n```\n\n#### Core Algorithm Skeletons\n\nThe learner implements these election algorithms by filling in the TODO comments:\n\n```go\n// BullyElection implements the bully algorithm for leader election\ntype BullyElection struct {\n    nodeID      NodeID\n    transport   Transport\n    peers       []NodeID  // All known node IDs\n    currentTerm uint64    // Election term for ordering\n    state       NodeState\n    leader      NodeID\n    \n    electionTimeout time.Duration\n    // TODO: Add fields for tracking ongoing elections, timers, etc.\n}\n\n// StartElection initiates a bully algorithm election\nfunc (b *BullyElection) StartElection() error {\n    // TODO 1: Set state to StateCandidate and increment election term\n    // TODO 2: Find all peer nodes with higher IDs than this node\n    // TODO 3: Send ELECTION messages to all higher-ID nodes\n    // TODO 4: Start election timeout timer\n    // TODO 5: If no higher-ID nodes exist, immediately declare victory\n    // Hint: Use b.findHigherIDNodes() to get candidates to message\n    return nil\n}\n\n// HandleElectionMessage processes incoming ELECTION messages\nfunc (b *BullyElection) handleElectionMessage(from NodeID, term uint64) error {\n    // TODO 1: Check if sender has lower ID than this node\n    // TODO 2: If so, send OK response to reject their election attempt\n    // TODO 3: Start our own election since we have higher priority\n    // TODO 4: Update our term if sender's term is higher\n    // Hint: Higher ID nodes should always challenge lower ID election attempts\n    return nil\n}\n\n// HandleOKMessage processes OK responses from higher-priority nodes\nfunc (b *BullyElection) handleOKMessage(from NodeID) error {\n    // TODO 1: Cancel our current election attempt\n    // TODO 2: Set state back to StateFollower  \n    // TODO 3: Clear any election timers\n    // TODO 4: Wait for COORDINATOR message from the winning node\n    // Hint: Receiving OK means a higher-priority node will handle leadership\n    return nil\n}\n\n// HandleCoordinatorMessage processes leader announcements\nfunc (b *BullyElection) handleCoordinatorMessage(from NodeID, term uint64) error {\n    // TODO 1: Validate that sender has authority to be leader\n    // TODO 2: Update our leader field and current term\n    // TODO 3: Set state to StateFollower\n    // TODO 4: Cancel any ongoing election activities\n    // Hint: Accept coordinator messages from higher-ID nodes\n    return nil\n}\n\n// declareVictory announces this node as the new leader\nfunc (b *BullyElection) declareVictory() error {\n    // TODO 1: Set state to StateLeader\n    // TODO 2: Set leader field to our own node ID\n    // TODO 3: Broadcast COORDINATOR message to all peers\n    // TODO 4: Start leader heartbeat process\n    // Hint: Only call this after election timeout with no OK responses\n    return nil\n}\n```\n\n#### Ring Election Implementation Skeleton\n\n```go\n// RingElection implements ring-based leader election\ntype RingElection struct {\n    nodeID    NodeID\n    transport Transport\n    ring      []NodeID  // Nodes arranged in ring order\n    position  int       // Our position in the ring\n    state     NodeState\n    leader    NodeID\n    \n    // TODO: Add fields for token tracking, ring maintenance\n}\n\n// StartElection begins ring election by creating initial token\nfunc (r *RingElection) StartElection() error {\n    // TODO 1: Create election token containing our node ID\n    // TODO 2: Set state to StateCandidate\n    // TODO 3: Send token to next live node in ring\n    // TODO 4: Start token timeout in case token gets lost\n    // Hint: Use r.findNextLiveNode() to locate token destination\n    return nil\n}\n\n// HandleRingToken processes election tokens circulating around ring\nfunc (r *RingElection) handleRingToken(token RingToken) error {\n    // TODO 1: Check if this token originated from us (election complete)\n    // TODO 2: If complete, find highest ID in token and declare winner\n    // TODO 3: Otherwise, add our ID to token and forward to next node\n    // TODO 4: Handle case where next node is unreachable (ring repair)\n    // Hint: Token completion means we've collected all live node IDs\n    return nil\n}\n\n// findNextLiveNode locates the next reachable node in ring order\nfunc (r *RingElection) findNextLiveNode(startPos int) (NodeID, error) {\n    // TODO 1: Start from position after startPos in ring\n    // TODO 2: Test connectivity to each node in ring order\n    // TODO 3: Return first reachable node ID\n    // TODO 4: Handle case where no nodes are reachable\n    // Hint: Use ping messages or transport.SendMessage to test connectivity\n    return 0, nil\n}\n```\n\n#### Milestone Validation Checkpoints\n\n**Milestone 1 Checkpoint - Node Communication:**\n```bash\n# Terminal 1: Start first node\ngo run cmd/node/main.go --id=1 --port=8001 --config=config/node1.yaml\n\n# Terminal 2: Start second node  \ngo run cmd/node/main.go --id=2 --port=8002 --config=config/node2.yaml\n\n# Expected behavior:\n# - Nodes discover each other through configuration\n# - Heartbeat messages appear in logs every 5 seconds\n# - Kill one node, other detects failure within 15 seconds\n# - Restart killed node, it rejoins cluster automatically\n```\n\n**Milestone 2 Checkpoint - Bully Algorithm:**\n```bash\n# Start 3 nodes with IDs 1, 2, 3\n# Kill node 3 (highest ID, should be initial leader)\n# Verify node 2 becomes new leader via election messages\n# Restart node 3, verify it reclaims leadership immediately\n```\n\n**Milestone 3 Checkpoint - Ring Algorithm:**\n```bash\n# Configure nodes in ring order: 1 → 3 → 5 → 7 → 1  \n# Kill current leader, verify ring token circulates\n# Check logs show token visiting each live node exactly once\n# Verify highest-ID node from token becomes new leader\n```\n\n#### Common Implementation Pitfalls\n\n⚠️ **Pitfall: Race Conditions in State Updates**\nMultiple goroutines may simultaneously update node state during elections. Always protect shared state with mutexes:\n```go\nfunc (b *BullyElection) setState(newState NodeState) {\n    b.mu.Lock()\n    defer b.mu.Unlock()\n    b.state = newState\n}\n```\n\n⚠️ **Pitfall: Infinite Election Loops**\nIf election timeouts are too short, nodes may repeatedly trigger elections before previous ones complete. Use exponential backoff for election retry delays.\n\n⚠️ **Pitfall: Ignoring Message Ordering**\nNetwork messages can arrive out of order. Always include term/sequence numbers in messages to handle delayed messages correctly.\n\n⚠️ **Pitfall: Split-Brain During Partitions**\nBoth partitions may elect leaders simultaneously. Implement quorum requirements (majority of nodes must participate) to prevent split-brain scenarios.\n\n⚠️ **Pitfall: Resource Leaks in Transport Layer**\nHTTP connections and goroutines can leak if not properly cleaned up. Always implement graceful shutdown with context cancellation and connection pooling.\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** Foundation for Milestones 1, 2, and 3 - defining the exact scope and boundaries of what this leader election system will achieve\n\nBefore diving into implementation details, we need to clearly define what this leader election system will and will not accomplish. Think of this as drawing the boundaries of a construction project - we need to know exactly what we're building, what quality standards it must meet, and what features we're explicitly choosing not to include. This clarity prevents scope creep and ensures we build a focused, working system rather than an overly ambitious prototype that never quite works properly.\n\nThe leader election system sits at the heart of distributed coordination. Without clear goals, it's easy to either under-engineer (creating a system that works in happy-path scenarios but fails under real-world stress) or over-engineer (building enterprise-grade features when learning the fundamentals is the primary objective). This section establishes those boundaries explicitly.\n\n### Functional Requirements\n\nThe functional requirements define the core behaviors that our leader election system must exhibit to be considered correct and complete. These are not performance goals or quality attributes - they are the fundamental \"what must this system do\" requirements that determine whether the implementation succeeds or fails.\n\n#### Core Election Behaviors\n\nThe system must guarantee that exactly one leader exists in the cluster at any given time, except during brief transition periods when an election is actively in progress. This is the fundamental safety property of leader election. During normal operation, every node in the cluster must agree on who the current leader is. When the leader fails or becomes unreachable, the system must detect this condition and initiate a new election automatically.\n\nFor the bully algorithm implementation, the system must ensure that the node with the highest `NodeID` among all currently responding nodes always wins the election. This is deterministic - given the same set of live nodes, the bully algorithm must always produce the same leader. The election process follows a specific protocol: when a node detects leader failure, it sends `MsgElection` messages only to nodes with higher IDs. If any higher-ID node responds with `MsgOK`, the initiating node must abandon its election attempt. Only when no higher-ID nodes respond within the timeout period should a node declare itself the winner and broadcast `MsgCoordinator` to announce its leadership.\n\nFor the ring election implementation, the system must arrange nodes in a logical ring topology ordered by `NodeID`. When an election begins, a `RingToken` circulates around the ring, collecting the IDs of all live nodes it encounters. The token must visit every reachable node exactly once per election cycle. When the token returns to its originator, the node with the highest collected ID becomes the new leader, and this decision must be communicated to all participating nodes.\n\n| Requirement | Bully Algorithm | Ring Algorithm | Detection Method |\n|-------------|-----------------|----------------|------------------|\n| Single leader guarantee | Highest live ID wins | Highest collected ID wins | Compare `GetCurrentLeader()` across all nodes |\n| Election convergence | Within 2 × timeout period | Within ring traversal time | All nodes report same leader |\n| Failure detection response | Immediate election start | Token-based detection | Election triggered within heartbeat timeout |\n| Split election handling | Higher ID preempts lower | Token prevents concurrent elections | No multiple `StateLeader` nodes |\n\n#### Node Communication Requirements\n\nThe system must implement reliable point-to-point messaging where `SendMessage(target NodeID, msg Message)` delivers messages to specific nodes with confirmation of delivery or explicit failure notification. Messages should not be silently dropped - the sender must know whether the message reached its destination or failed to arrive.\n\nBroadcast messaging via `BroadcastMessage(msg Message)` must deliver messages to all currently known live nodes in the cluster. This doesn't require atomic broadcast - it's acceptable for some nodes to receive the message slightly before others. However, the broadcast must not systematically exclude certain nodes due to implementation bugs or race conditions.\n\nThe node discovery mechanism must allow nodes to find and connect to their peers either through static configuration files or dynamic discovery methods like multicast announcements. Once discovered, nodes must maintain awareness of which peers are currently reachable and which have failed or become partitioned.\n\n| Communication Type | Delivery Guarantee | Failure Handling | Implementation Method |\n|-------------------|-------------------|------------------|----------------------|\n| Point-to-point | At-least-once or confirmed failure | Return error from `SendMessage()` | TCP connections with retries |\n| Broadcast | Best-effort to all live nodes | Log failures but continue | Iterate through known nodes |\n| Node discovery | Eventually consistent membership | Periodic rediscovery attempts | Config file + heartbeat validation |\n| Failure detection | Detect within configurable timeout | Trigger re-election automatically | Heartbeat + suspicion counters |\n\n#### State Management and Consistency\n\nEach node must maintain consistent state about its role in the cluster using the `NodeState` enumeration. A node begins in `StateFollower`, transitions to `StateCandidate` during election participation, and may become `StateLeader` if it wins. State transitions must be atomic and logged for debugging purposes.\n\nThe system must track cluster membership accurately. This includes maintaining a current view of which nodes are alive, which have failed, and which are suspected of having failed but haven't been definitively confirmed as down. This membership information drives both election algorithms and failure detection logic.\n\nLeadership must be persistent once established. A newly elected leader should remain in that role until it actually fails, becomes partitioned, or voluntarily steps down. The system should not trigger unnecessary re-elections due to transient network hiccups or temporary message delays.\n\n> **Design Principle:** The functional requirements focus on correctness over performance. A slower election that always produces the right result is vastly preferable to a fast election that occasionally produces split-brain scenarios or fails to converge on a single leader.\n\n### Performance and Reliability Requirements\n\nWhile correctness is paramount, the leader election system must also meet minimum performance and reliability standards to be useful in practice. These requirements establish the quantitative benchmarks that determine whether the system is fast enough, reliable enough, and scalable enough for its intended use cases.\n\n#### Election Timing Requirements\n\nLeader elections must complete within reasonable time bounds to minimize the period during which the cluster lacks coordination. For the bully algorithm, an election should converge within twice the message timeout period in the common case where network conditions are stable. This accounts for one timeout period to determine that higher-ID nodes aren't responding, plus additional time for the winner to broadcast its coordinator message.\n\nRing elections should complete within the time required for a token to traverse the entire logical ring once, plus a small buffer for processing delays at each node. In a healthy network with N nodes, this should be proportional to N × average_message_latency rather than scaling exponentially.\n\nThe system must detect node failures within a configurable timeout period, typically on the order of seconds rather than minutes. However, the failure detection should not be so aggressive that transient network delays trigger false positives and unnecessary elections.\n\n| Timing Requirement | Target Value | Measurement Method | Failure Condition |\n|--------------------|--------------|-------------------|-------------------|\n| Bully election completion | < 2 × message timeout | Time from election start to coordinator broadcast | > 5 × message timeout |\n| Ring election completion | < N × message timeout + processing buffer | Token full-circle time | Token stuck or lost |\n| Failure detection latency | Configurable (default 10s) | Time from actual failure to election trigger | > 2 × configured timeout |\n| Leader announcement propagation | < message timeout | Time for all nodes to learn new leader | Nodes disagree on leader after election |\n\n#### Scalability and Resource Requirements\n\nThe system must function correctly with cluster sizes from 3 nodes (minimum for meaningful elections) up to at least 10 nodes. While enterprise systems might require hundreds of nodes, this implementation focuses on the algorithmic correctness rather than extreme scalability.\n\nMemory usage should remain bounded and proportional to cluster size. Each node should maintain O(N) state for tracking N peer nodes, but should not accumulate unbounded state over time through memory leaks or unbounded log growth.\n\nNetwork overhead should be reasonable relative to the coordination value provided. Elections are infrequent events (triggered only by actual failures), so moderate message overhead during elections is acceptable. However, steady-state heartbeat and failure detection traffic should be lightweight.\n\nCPU usage for election algorithms should be minimal. The computational complexity of both bully and ring algorithms is low, involving simple message passing and ID comparisons rather than cryptographic operations or complex computations.\n\n| Resource | Scaling Requirement | Measurement | Acceptable Range |\n|----------|-------------------|-------------|------------------|\n| Memory per node | O(N) for N cluster members | Process RSS during operation | < 50MB for 10-node cluster |\n| Network messages per election | O(N) for bully, O(N) for ring | Count messages during election | Bully: < 2N², Ring: < 2N |\n| Steady-state network overhead | Heartbeat traffic only | Messages per second outside elections | < 1 message/second/node |\n| CPU utilization | Minimal during steady state | Process CPU during normal operation | < 1% except during elections |\n\n#### Reliability and Fault Tolerance\n\nThe system must handle common failure scenarios gracefully without requiring manual intervention. Single node failures should trigger automatic re-election and leadership transfer without affecting the overall cluster's ability to coordinate.\n\nNetwork partitions present a more complex challenge. The system should avoid split-brain scenarios where multiple nodes simultaneously believe they are the leader. While perfect partition tolerance requires sophisticated quorum mechanisms, this implementation should at least detect partition scenarios and take conservative action (such as stepping down when isolated).\n\nMessage loss and reordering should not break the election algorithms' correctness. The protocols should be designed to handle these network realities through timeouts, retries, and idempotent message handling.\n\nThe system should recover automatically when failed nodes rejoin the cluster or when network partitions heal. Rejoining nodes should be able to learn the current leader and integrate back into the cluster membership without triggering unnecessary elections.\n\n> **Reliability Design Insight:** The goal is not to achieve perfect fault tolerance (which would require much more sophisticated protocols), but to ensure that common failures are handled gracefully and that the system fails safely when it encounters scenarios beyond its design limits.\n\n### Out of Scope\n\nClearly defining what this leader election system will NOT include is just as important as defining what it will include. This prevents feature creep and keeps the implementation focused on learning the core algorithms rather than building a production-ready distributed systems framework.\n\n#### Advanced Distributed Systems Features\n\nThis implementation explicitly excludes sophisticated consensus algorithms like Raft or Paxos. While these protocols solve leader election as part of broader consensus problems, they introduce significant complexity around log replication, term numbers, and linearizability guarantees that would overshadow the basic election algorithm learning objectives.\n\nByzantine fault tolerance is completely out of scope. The system assumes that nodes may crash or become unreachable, but it does not protect against malicious nodes that lie about their identity, forge messages, or intentionally disrupt elections. All nodes are assumed to follow the protocol honestly when they are operational.\n\nMulti-datacenter deployments and wide-area network considerations are not addressed. The system assumes all nodes can communicate directly with reasonable latency and that network partitions are binary (nodes are either reachable or completely unreachable).\n\nDynamic membership changes during elections are not supported. While nodes can join or leave the cluster, the system does not handle scenarios like nodes joining in the middle of an active election or graceful leadership handoff when a leader voluntarily steps down.\n\n| Excluded Feature | Reason for Exclusion | Alternative Learning Path |\n|------------------|---------------------|--------------------------|\n| Raft/Paxos consensus | Too complex for basic election learning | Separate project after mastering basic algorithms |\n| Byzantine fault tolerance | Requires cryptographic verification | Advanced distributed systems course |\n| Multi-datacenter support | Network topology complications | Study CAP theorem and partition tolerance |\n| Dynamic membership during elections | Race conditions add algorithmic complexity | Focus on static membership first |\n\n#### Production-Ready Operations Features\n\nThe system does not include comprehensive logging, metrics, or observability features beyond basic debugging information. While production systems require detailed telemetry, this implementation focuses on algorithmic correctness rather than operational visibility.\n\nConfiguration management is minimal. The system may use simple configuration files or hard-coded parameters rather than sophisticated configuration systems with validation, hot reloading, or environment-specific overrides.\n\nSecurity features like authentication, authorization, or encrypted communication are completely excluded. Messages are sent in plaintext, and any node that can reach the cluster can participate in elections. This is obviously unsuitable for production but acceptable for learning algorithm fundamentals.\n\nPerformance optimization beyond basic algorithmic efficiency is not included. The implementation prioritizes code clarity and correctness over micro-optimizations, advanced data structures, or high-performance networking libraries.\n\nIntegration with external systems (service discovery, load balancers, monitoring systems) is out of scope. The leader election system operates as a standalone learning environment rather than a component in a broader infrastructure ecosystem.\n\n> **Scope Decision:** By explicitly excluding production-ready features, we can focus entirely on understanding how leader election algorithms work, what can go wrong, and how to implement them correctly. These operational concerns can be layered on top after the core algorithms are solid.\n\n#### Advanced Election Features\n\nWeighted voting where some nodes have more influence in elections is not supported. All nodes with valid `NodeID` values have equal say in determining the leader, regardless of their hardware capabilities, network position, or assigned roles.\n\nLeader leases or term limits are not implemented. Once elected, a leader remains in power until it actually fails or becomes unreachable. There are no mechanisms for periodic re-election or automatic leadership rotation.\n\nHierarchical elections or multi-level leadership structures are excluded. The system elects a single flat leader rather than supporting regional leaders, backup leaders, or leadership hierarchies.\n\nCustom election criteria beyond highest `NodeID` are not supported. Some production systems might elect leaders based on load, capability, geographic location, or other factors, but this implementation uses only numeric ID comparison for simplicity and determinism.\n\n| Advanced Feature | Complexity Added | Learning Value |\n|------------------|------------------|----------------|\n| Weighted voting | Vote counting algorithms, configuration management | Low - obscures basic algorithm |\n| Leader leases/terms | Time synchronization, lease renewal protocols | Medium - useful but complicates learning |\n| Hierarchical leadership | Multi-level coordination, cascading failures | High - but better as separate project |\n| Custom election criteria | Pluggable decision logic, complex comparison | Low - ID-based is sufficient for learning |\n\n### Implementation Guidance\n\nThis section provides concrete technical recommendations for implementing the goals and requirements defined above. The focus is on practical choices that support the learning objectives while keeping implementation complexity manageable.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Inter-node transport | HTTP REST with JSON (net/http) | gRPC with Protocol Buffers |\n| Configuration | JSON config file (encoding/json) | YAML with validation (gopkg.in/yaml.v3) |\n| Logging | Standard library (log) | Structured logging (logrus, zap) |\n| Testing | Built-in testing (testing) | Testify framework (github.com/stretchr/testify) |\n| Networking | TCP sockets (net) | UDP with reliability layer |\n| State storage | In-memory maps | Persistent storage (BoltDB) |\n\nFor learning purposes, start with the simple options. They require less setup and have fewer dependencies, letting you focus on the election algorithms rather than infrastructure concerns.\n\n#### Recommended File Structure\n\n```\nleader-election/\n├── cmd/\n│   └── node/\n│       └── main.go                    # Node startup and CLI\n├── internal/\n│   ├── node/\n│   │   ├── node.go                    # Node struct and basic lifecycle\n│   │   ├── state.go                   # NodeState management\n│   │   └── node_test.go               # Node behavior tests\n│   ├── transport/\n│   │   ├── transport.go               # Transport interface\n│   │   ├── http_transport.go          # HTTPTransport implementation\n│   │   └── transport_test.go          # Transport layer tests\n│   ├── election/\n│   │   ├── coordinator.go             # ElectionCoordinator interface\n│   │   ├── bully.go                   # BullyElection implementation\n│   │   ├── ring.go                    # RingElection implementation\n│   │   └── election_test.go           # Election algorithm tests\n│   └── discovery/\n│       ├── discovery.go               # Node discovery and membership\n│       └── discovery_test.go          # Discovery mechanism tests\n├── configs/\n│   └── cluster.json                   # Node configuration\n└── README.md                          # Setup and running instructions\n```\n\n#### Core Data Structures\n\n```go\n// NodeID represents a unique node identifier for election comparison\ntype NodeID uint64\n\n// NodeState represents the current role of a node in the election process\ntype NodeState int\n\nconst (\n    StateFollower  NodeState = iota  // Following current leader\n    StateCandidate                   // Participating in election\n    StateLeader                      // Serving as cluster leader\n)\n\n// Node represents a cluster member with identity and network information\ntype Node struct {\n    ID      NodeID `json:\"id\"`       // Unique identifier for elections\n    Address string `json:\"address\"`  // Network address (host:port)\n    State   NodeState `json:\"state\"` // Current election state\n}\n\n// MessageType identifies the purpose of election messages\ntype MessageType int\n\nconst (\n    MsgElection     MessageType = iota  // Bully algorithm election start\n    MsgOK                              // Bully algorithm acknowledgment\n    MsgCoordinator                     // Leader announcement\n    MsgHeartbeat                       // Failure detection ping\n    MsgRingToken                       // Ring election token\n)\n\n// Message represents inter-node communication for election protocols\ntype Message struct {\n    Type    MessageType `json:\"type\"`    // Message purpose\n    From    NodeID      `json:\"from\"`    // Sender node ID\n    To      NodeID      `json:\"to\"`      // Target node ID (0 for broadcast)\n    Payload []byte      `json:\"payload\"` // Algorithm-specific data\n}\n```\n\n#### Transport Layer Foundation\n\n```go\n// Transport defines the interface for inter-node communication\ntype Transport interface {\n    // SendMessage delivers a message to a specific node\n    SendMessage(target NodeID, msg Message) error\n    \n    // BroadcastMessage sends a message to all known live nodes\n    BroadcastMessage(msg Message) error\n    \n    // ReceiveMessages returns a channel of incoming messages\n    ReceiveMessages() <-chan Message\n    \n    // Start begins listening for incoming messages\n    Start(address string) error\n    \n    // Stop shuts down the transport layer\n    Stop() error\n}\n\n// HTTPTransport implements Transport using HTTP REST calls\ntype HTTPTransport struct {\n    nodeID    NodeID\n    server    *http.Server\n    peers     map[NodeID]string  // NodeID -> address mapping\n    messages  chan Message       // Incoming message buffer\n    // TODO: Add mutex for thread safety\n    // TODO: Add HTTP client for outgoing messages\n    // TODO: Add graceful shutdown handling\n}\n\n// Implement SendMessage for HTTP transport\nfunc (t *HTTPTransport) SendMessage(target NodeID, msg Message) error {\n    // TODO 1: Look up target address in peers map\n    // TODO 2: Serialize message to JSON\n    // TODO 3: POST to http://target-address/messages endpoint\n    // TODO 4: Return error if HTTP request fails\n    // TODO 5: Consider adding retry logic for transient failures\n}\n```\n\n#### Election Coordinator Interface\n\n```go\n// ElectionCoordinator manages the leader election process for a node\ntype ElectionCoordinator interface {\n    // StartElection initiates a new leader election\n    StartElection() error\n    \n    // HandleMessage processes incoming election-related messages\n    HandleMessage(msg Message) error\n    \n    // GetCurrentLeader returns the ID of the current leader (0 if none)\n    GetCurrentLeader() NodeID\n    \n    // IsLeader returns true if this node is currently the leader\n    IsLeader() bool\n    \n    // SetTransport configures the communication layer\n    SetTransport(transport Transport) error\n}\n\n// BullyElection implements leader election using the bully algorithm\ntype BullyElection struct {\n    nodeID      NodeID\n    transport   Transport\n    currentLeader NodeID\n    state       NodeState\n    peers       []NodeID           // Known peer node IDs\n    electionTimeout time.Duration  // How long to wait for responses\n    // TODO: Add election timer\n    // TODO: Add mutex for concurrent access\n    // TODO: Add heartbeat tracking\n}\n\n// StartElection initiates bully algorithm election\nfunc (b *BullyElection) StartElection() error {\n    // TODO 1: Set state to StateCandidate\n    // TODO 2: Find all peer nodes with higher IDs than this node\n    // TODO 3: Send MsgElection to all higher-ID nodes\n    // TODO 4: Start election timeout timer\n    // TODO 5: If timeout expires with no MsgOK responses, declare victory\n    // TODO 6: If victory, set state to StateLeader and broadcast MsgCoordinator\n}\n```\n\n#### Milestone Validation Checkpoints\n\n**Milestone 1 Validation (Node Communication):**\n1. Start 3 nodes with different IDs in separate terminals\n2. Check that each node discovers the other two via membership mechanism\n3. Send test messages between nodes - verify they arrive correctly\n4. Kill one node - verify others detect failure within timeout period\n5. Expected output: Logs showing \"Node X discovered\", \"Message from Y received\", \"Node Z failed\"\n\n**Milestone 2 Validation (Bully Algorithm):**\n1. Start cluster of 5 nodes with IDs 1, 2, 3, 4, 5\n2. Verify node 5 becomes initial leader\n3. Kill node 5 - verify node 4 takes over leadership\n4. Kill node 4 - verify node 3 becomes leader\n5. Restart node 5 - verify it reclaims leadership\n6. Expected behavior: Always the highest-ID live node is leader\n\n**Milestone 3 Validation (Ring Election):**\n1. Configure nodes in ring topology: 1→3→5→7→1\n2. Trigger election from node 3\n3. Trace token passing: 3→5→7→1→3\n4. Verify node 7 (highest collected ID) becomes leader\n5. Test with failed node in ring - verify ring repair\n6. Expected output: Token trace logs showing ID collection at each hop\n\n#### Common Implementation Pitfalls\n\n⚠️ **Pitfall: Forgetting Message Serialization**\nDon't assume you can send Go structs directly over the network. HTTP transport requires JSON serialization of the `Message` struct and its payload. Always test with `json.Marshal()` and `json.Unmarshal()` to catch serialization issues early.\n\n⚠️ **Pitfall: Race Conditions in State Updates**\nMultiple goroutines will access `NodeState` and leader information concurrently (message handlers, timers, API calls). Always protect shared state with mutexes or channels. A common bug is checking state in one line and using it in the next, with state changing between the two operations.\n\n⚠️ **Pitfall: Election Timeout Too Short**\nDon't set election timeouts to milliseconds in initial testing. Network latency, especially on localhost, can be variable. Start with 5-10 second timeouts, then optimize downward once the algorithm works correctly.\n\n⚠️ **Pitfall: Infinite Election Loops**\nIf two nodes simultaneously detect leader failure and start elections, they can end up in infinite loops of starting new elections. The bully algorithm handles this by having lower-ID nodes defer to higher-ID nodes, but you must implement the `MsgOK` response handling correctly.\n\n⚠️ **Pitfall: Forgetting Edge Cases in Ring**\nRing election token can get stuck if the next node in the ring fails while the token is in transit. Always implement a token timeout - if the originating node doesn't get its token back within a reasonable time, assume it was lost and start a new election.\n\n\n## High-Level Architecture\n\n> **Milestone(s):** Foundation for all milestones - provides the structural blueprint for implementing node communication (Milestone 1), bully election (Milestone 2), and ring election (Milestone 3)\n\nBefore diving into the specifics of election algorithms, we need to establish the foundational architecture that will support both bully and ring election protocols. This section outlines the major components, their relationships, and how they work together to provide reliable distributed leader election.\n\n### Mental Model: Orchestra Conductor Selection\n\nThink of leader election like selecting a conductor for an orchestra. Each musician (node) has a unique chair number (NodeID), and they all need to agree on who leads. The orchestra needs several key capabilities:\n\n- **Communication system**: Musicians can pass notes to specific colleagues or make announcements to everyone\n- **Failure detection**: Musicians notice when the conductor stops conducting or when fellow musicians miss their cues  \n- **Election protocols**: Structured procedures for selecting a new conductor when the current one fails\n- **Coordination**: Once elected, the conductor coordinates the entire performance\n\nJust as an orchestra needs these systems working together seamlessly, our leader election system requires coordinated components that handle communication, failure detection, and election logic as an integrated whole.\n\n![Leader Election System Overview](./diagrams/system-overview.svg)\n\n### System Components\n\nThe leader election system is built around four core components that work together to provide reliable distributed coordination. Each component has clearly defined responsibilities and interfaces with the others through well-structured APIs.\n\n#### Node Manager\n\nThe **Node Manager** serves as the central control component for each node in the cluster. It maintains the node's identity, current state, and coordinates all election-related activities. Think of it as the node's \"brain\" that makes high-level decisions about when to start elections, how to respond to messages, and what role the node should play.\n\n| Responsibility | Description | Key Data Managed |\n|---|---|---|\n| Node Identity Management | Maintains unique NodeID and network address | NodeID, IP address, port |\n| State Management | Tracks current node state (Follower/Candidate/Leader) | NodeState, election term |\n| Election Coordination | Decides when to start elections and handles outcomes | Current leader ID, election status |\n| Component Integration | Orchestrates message layer, failure detector, and election algorithms | Component references and configurations |\n\nThe Node Manager implements a state machine that transitions between `StateFollower`, `StateCandidate`, and `StateLeader` based on election events and failure detection. It serves as the single source of truth for the node's current role in the cluster.\n\n#### Message Layer (Transport)\n\nThe **Message Layer** provides reliable communication between nodes in the cluster. It abstracts the underlying network protocol (HTTP, TCP, UDP) and provides both point-to-point and broadcast messaging capabilities. This layer handles message serialization, delivery confirmation, and network error recovery.\n\n| Method Name | Parameters | Returns | Description |\n|---|---|---|---|\n| `SendMessage` | `target NodeID, msg Message` | `error` | Sends message to specific node with delivery confirmation |\n| `BroadcastMessage` | `msg Message` | `error` | Sends message to all known live nodes in cluster |\n| `ReceiveMessages` | None | `<-chan Message` | Returns channel for incoming messages from other nodes |\n| `UpdateMembership` | `nodes []Node` | `error` | Updates the set of known cluster nodes for routing |\n\nThe transport layer maintains a routing table of all known nodes and their network addresses. It implements retry logic for failed message deliveries and provides feedback to upper layers about communication failures that may indicate node crashes.\n\n#### Election Coordinator\n\nThe **Election Coordinator** implements the specific election algorithms (bully and ring). It's designed as a pluggable interface so different election strategies can be used interchangeably. The coordinator handles the detailed protocol logic for each algorithm while relying on the message layer for communication.\n\n| Method Name | Parameters | Returns | Description |\n|---|---|---|---|\n| `StartElection` | None | `error` | Initiates new election using this algorithm |\n| `HandleMessage` | `msg Message` | `error` | Processes incoming election-specific messages |\n| `GetCurrentLeader` | None | `NodeID` | Returns the currently elected leader's ID |\n| `IsLeader` | None | `bool` | Checks if this node is currently the leader |\n\nTwo concrete implementations provide the core election algorithms:\n\n- **BullyElection**: Implements the bully algorithm where the highest-ID responding node becomes leader\n- **RingElection**: Implements ring-based election using token passing to collect live node IDs\n\n#### Failure Detector\n\nThe **Failure Detector** monitors cluster health and identifies node failures or network partitions. It uses heartbeat messages and timeout-based detection to determine when nodes become unreachable. This component triggers leader re-election when the current leader fails.\n\n| Detection Method | Mechanism | Timeout Configuration | Action Taken |\n|---|---|---|---|\n| Heartbeat Monitoring | Periodic `MsgHeartbeat` messages | Configurable interval (default 1s) | Mark nodes as suspected, then failed |\n| Leader Liveness | Monitor heartbeats from current leader | Leader timeout (default 5s) | Trigger new election |\n| Network Partition | Track communication failures across nodes | Partition timeout (default 10s) | Enter partition recovery mode |\n| Node Recovery | Detect previously failed nodes rejoining | Recovery grace period (default 3s) | Update membership and potentially re-elect |\n\n> **Architecture Decision: Component Separation**\n> - **Context**: Need to support multiple election algorithms while maintaining clean interfaces\n> - **Options Considered**:\n>   1. Monolithic design with all logic in one component\n>   2. Pluggable election algorithms with shared infrastructure \n>   3. Completely separate implementations for each algorithm\n> - **Decision**: Pluggable election coordinators with shared message layer and failure detection\n> - **Rationale**: Enables algorithm comparison, testing flexibility, and code reuse while maintaining clear separation of concerns\n> - **Consequences**: Slightly more complex interfaces but much better maintainability and extensibility\n\n### Inter-Node Communication\n\nNodes discover each other and communicate through a layered approach that handles both cluster membership management and reliable message delivery. The communication system must work correctly even during network partitions and node failures.\n\n#### Node Discovery and Membership\n\nCluster membership is managed through a combination of static configuration and dynamic discovery. Each node maintains a membership list that tracks all known cluster participants and their current status.\n\n**Static Configuration Approach**: For initial development and testing, nodes are configured with a static list of cluster members including their NodeIDs and network addresses. This approach ensures deterministic behavior and simplifies debugging during development.\n\n| Configuration Field | Type | Example Value | Purpose |\n|---|---|---|---|\n| `cluster_nodes` | `[]NodeConfig` | `[{id: 1, addr: \"10.0.1.1:8080\"}, ...]` | List of all cluster participants |\n| `local_node_id` | `NodeID` | `3` | This node's unique identifier |\n| `local_bind_addr` | `string` | `\"0.0.0.0:8080\"` | Address to bind for incoming connections |\n| `heartbeat_interval` | `time.Duration` | `1s` | Frequency of heartbeat messages |\n\n**Dynamic Discovery Extension**: For production deployments, the system can be extended with multicast announcement or service discovery integration. Nodes periodically announce their presence and discover new cluster members automatically.\n\n#### Message Routing and Delivery\n\nThe message layer implements reliable delivery semantics for election coordination. Different message types have different delivery requirements based on their role in the election protocols.\n\n| Message Category | Delivery Guarantee | Retry Policy | Timeout Behavior |\n|---|---|---|---|\n| Election Messages (`MsgElection`, `MsgOK`) | At-least-once with deduplication | 3 retries with exponential backoff | Treat as node failure after timeout |\n| Coordinator Announcements (`MsgCoordinator`) | Best-effort broadcast | Single attempt to all nodes | Continue with partial delivery |\n| Heartbeats (`MsgHeartbeat`) | Best-effort | No retries | Missing heartbeats indicate failure |\n| Ring Tokens (`MsgRingToken`) | Exactly-once with ordering | Forward to next live node | Skip failed nodes and continue ring |\n\nThe transport layer maintains connection state for each cluster member and implements adaptive timeout policies. Connections that consistently fail are marked as suspected, and repeated failures trigger failure detection callbacks.\n\n#### Network Partition Handling\n\nNetwork partitions pose a fundamental challenge for distributed leader election because different network segments may simultaneously elect different leaders (split-brain scenario). Our architecture includes several mechanisms to detect and handle partitions safely.\n\n**Partition Detection**: The failure detector monitors communication patterns across the cluster to identify potential network partitions. When a node can communicate with some cluster members but not others, it may be experiencing a partition.\n\n| Partition Indicator | Detection Logic | Response Strategy |\n|---|---|---|---|\n| Asymmetric Failures | Node A can reach B but not C, while B can reach both A and C | Wait for partition recovery before participating in elections |\n| Majority Loss | Node can only communicate with less than half of configured cluster | Enter read-only mode, do not start new elections |\n| Leader Isolation | Current leader becomes unreachable but other nodes remain connected | Remaining nodes elect new leader after timeout |\n| Complete Isolation | Node cannot reach any other cluster members | Assume network failure, do not claim leadership |\n\n> **Design Insight: Conservative Partition Handling**\n> Our approach prioritizes safety over availability during network partitions. It's better to have no leader temporarily than to have multiple conflicting leaders. This aligns with the CAP theorem trade-off where we choose consistency over availability during partition events.\n\n**Quorum Requirements**: To prevent split-brain scenarios, certain operations require a quorum (majority) of nodes to be reachable. Leader election succeeds only when the electing partition contains more than half of the configured cluster nodes.\n\n#### Message Serialization and Protocol\n\nAll inter-node communication uses a structured message format that supports multiple election algorithms while maintaining backwards compatibility for future extensions.\n\nThe base `Message` structure provides routing and metadata:\n\n| Field Name | Type | Description | Example Value |\n|---|---|---|---|\n| `Type` | `MessageType` | Identifies the message category and expected payload format | `MsgElection` |\n| `From` | `NodeID` | Source node identifier for routing and authentication | `3` |\n| `To` | `NodeID` | Target node identifier (0 for broadcast messages) | `5` |\n| `Term` | `uint64` | Election term number for ordering and duplicate detection | `42` |\n| `Payload` | `[]byte` | Algorithm-specific message content (JSON-encoded) | `{\"candidates\": [3,4,5]}` |\n| `Timestamp` | `int64` | Message creation time for timeout and ordering | Unix timestamp |\n\nEach election algorithm defines its own payload structures that get serialized into the `Payload` field. This allows the transport layer to route messages without understanding algorithm-specific details.\n\n> **Architecture Decision: JSON Message Serialization**\n> - **Context**: Need to serialize complex message payloads for network transmission\n> - **Options Considered**:\n>   1. JSON for human readability and debugging ease\n>   2. Protocol Buffers for performance and schema evolution\n>   3. Custom binary format for minimal overhead\n> - **Decision**: JSON for initial implementation\n> - **Rationale**: Prioritizes development speed and debugging over performance. Network traffic volume is low for election protocols\n> - **Consequences**: Slightly higher bandwidth usage but much easier debugging and development\n\n### Recommended Project Organization\n\nThe project structure reflects the component architecture while maintaining clear separation between core election logic, infrastructure concerns, and algorithm implementations. This organization supports both development workflow and testing isolation.\n\n#### Directory Structure\n\n```\nleader-election/\n├── cmd/\n│   └── election-node/          # Main executable for running election nodes\n│       └── main.go             # Entry point, configuration, and startup logic\n├── internal/                   # Private application code (not importable by other projects)\n│   ├── node/                   # Node Manager - central coordination\n│   │   ├── manager.go          # Node state management and lifecycle\n│   │   ├── state_machine.go    # State transitions (Follower/Candidate/Leader)\n│   │   └── manager_test.go     # Unit tests for node management logic\n│   ├── transport/              # Message Layer - inter-node communication\n│   │   ├── transport.go        # Transport interface definition\n│   │   ├── http_transport.go   # HTTP-based transport implementation\n│   │   ├── message.go          # Message types and serialization\n│   │   └── transport_test.go   # Transport layer unit tests\n│   ├── election/               # Election Coordinators - algorithm implementations\n│   │   ├── coordinator.go      # ElectionCoordinator interface\n│   │   ├── bully.go           # Bully algorithm implementation\n│   │   ├── ring.go            # Ring election implementation\n│   │   └── election_test.go    # Algorithm-specific unit tests\n│   ├── detector/               # Failure Detector - health monitoring\n│   │   ├── failure_detector.go # Failure detection logic and heartbeats\n│   │   ├── membership.go       # Cluster membership tracking\n│   │   └── detector_test.go    # Failure detection unit tests\n│   └── config/                 # Configuration management\n│       ├── config.go           # Configuration structure and validation\n│       └── defaults.go         # Default values and constants\n├── pkg/                        # Public library code (importable by other projects)\n│   └── types/                  # Shared type definitions\n│       ├── node.go             # NodeID, NodeState, Node structs\n│       ├── message.go          # MessageType constants and Message struct\n│       └── errors.go           # Election-specific error types\n├── test/                       # Integration and end-to-end tests\n│   ├── integration/            # Multi-node test scenarios\n│   │   ├── bully_test.go       # Full bully election integration tests\n│   │   ├── ring_test.go        # Full ring election integration tests\n│   │   └── partition_test.go   # Network partition simulation tests\n│   └── testutil/               # Testing utilities and helpers\n│       ├── cluster.go          # Test cluster setup and management\n│       └── network.go          # Network failure simulation tools\n├── scripts/                    # Build and deployment scripts\n│   ├── run-cluster.sh          # Start test cluster with multiple nodes\n│   └── simulate-failure.sh     # Network failure simulation script\n├── docs/                       # Documentation\n│   └── diagrams/               # Architecture and sequence diagrams\n└── go.mod                      # Go module definition\n```\n\n#### Module Responsibilities and Dependencies\n\nEach module has clearly defined responsibilities and dependency relationships that enforce proper layering and prevent circular dependencies.\n\n| Module | Primary Responsibility | Dependencies | Exports |\n|---|---|---|---|\n| `pkg/types` | Shared type definitions and constants | None (foundational) | NodeID, NodeState, MessageType, Message, Node |\n| `internal/config` | Configuration parsing and validation | `pkg/types` | Config struct, default values |\n| `internal/transport` | Network communication and message routing | `pkg/types` | Transport interface, HTTPTransport implementation |\n| `internal/detector` | Failure detection and membership management | `pkg/types`, `internal/transport` | FailureDetector, membership tracking |\n| `internal/election` | Election algorithm implementations | `pkg/types`, `internal/transport` | ElectionCoordinator, BullyElection, RingElection |\n| `internal/node` | Node lifecycle and state management | All internal modules | NodeManager, orchestration logic |\n| `cmd/election-node` | Application entry point and CLI | All modules | Executable binary |\n\nThis dependency structure ensures that:\n- Core types are defined once and shared across all modules\n- Transport layer can be tested independently of election algorithms  \n- Election algorithms can be developed and tested in isolation\n- The node manager orchestrates all components without tight coupling\n\n#### Interface Boundaries and Testing Strategy\n\nThe modular architecture enables comprehensive testing at multiple levels by providing clear interface boundaries for mocking and test doubles.\n\n**Unit Testing Strategy**: Each module includes comprehensive unit tests that mock dependencies through interfaces. For example, election algorithm tests use a mock transport layer to simulate network conditions without requiring actual network communication.\n\n**Integration Testing Strategy**: The `test/integration` package runs full multi-node scenarios using the actual implementations. These tests validate that components work correctly together and handle real network timing and failure conditions.\n\n**Testing Utilities**: The `test/testutil` package provides reusable components for setting up test clusters, simulating network failures, and validating election outcomes. This reduces test complexity and improves consistency across different test scenarios.\n\n> **Architecture Decision: Internal vs Pkg Module Organization**\n> - **Context**: Need to balance code reusability with API stability and encapsulation\n> - **Options Considered**:\n>   1. Everything in internal/ (no external API)\n>   2. Everything in pkg/ (fully public API)\n>   3. Mixed approach with stable types in pkg/, implementation in internal/\n> - **Decision**: Mixed approach with minimal pkg/ surface area\n> - **Rationale**: Allows type sharing for testing while keeping implementation details private. Prevents external dependencies on unstable internals\n> - **Consequences**: Clear API boundary but requires discipline to keep pkg/ minimal and stable\n\n#### Development Workflow and Build Process\n\nThe project structure supports efficient development workflows for both individual components and full system testing.\n\n**Local Development**: Developers can work on individual algorithms or components using focused unit tests. The `go test ./internal/election/...` command runs only election algorithm tests, providing fast feedback during development.\n\n**Integration Testing**: The `scripts/run-cluster.sh` script starts multiple node processes locally with different configurations, enabling manual testing of election scenarios. Network failures can be simulated using `scripts/simulate-failure.sh` to test partition handling.\n\n**Debugging Support**: The modular structure enables selective logging and debugging. Each component can be configured with different log levels, and the HTTP transport provides REST endpoints for inspecting node state during development.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Circular Dependencies Between Components**\n\nA common mistake is creating circular import dependencies between the node manager, election coordinator, and transport layer. This happens when components try to directly call methods on each other instead of using proper interfaces and dependency injection.\n\n**Why it's wrong**: Circular dependencies prevent compilation and make testing extremely difficult. They also indicate poor separation of concerns where components are too tightly coupled.\n\n**How to fix**: Always make dependencies flow in one direction. Higher-level components (like NodeManager) depend on interfaces defined by lower-level components. Use dependency injection to provide concrete implementations at startup rather than having components create their own dependencies.\n\n⚠️ **Pitfall: Blocking Message Handlers**\n\nElection message handlers often need to perform operations that might block (like sending messages to other nodes or updating persistent state). A common mistake is making these operations synchronous in the message handling path, which can cause deadlocks or missed messages.\n\n**Why it's wrong**: If a message handler blocks while processing one message, it cannot process subsequent messages. This can cause election timeouts or missed critical messages that affect correctness.\n\n**How to fix**: Use asynchronous message processing with worker goroutines and message queues. The main message receive loop should never block - it should queue messages for processing and return immediately.\n\n⚠️ **Pitfall: Inconsistent Node ID Assignment**\n\nNode IDs must be unique and consistent across cluster restarts, but beginners often assign them randomly or use unstable values like memory addresses or timestamps.\n\n**Why it's wrong**: Election algorithms depend on stable ID ordering. If node IDs change across restarts, the cluster cannot maintain consistent leadership or may experience continuous re-elections.\n\n**How to fix**: Use configuration-based ID assignment where each node explicitly knows its own ID and the IDs of all cluster members. Never generate IDs dynamically or derive them from runtime values.\n\n### Implementation Guidance\n\nThe implementation approach balances learning objectives with practical development concerns. We provide complete infrastructure code for components that aren't the core learning focus, while giving you skeleton code with detailed guidance for the key election logic you should implement yourself.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|---|---|---|\n| Transport Layer | HTTP REST with JSON (net/http) | gRPC with Protocol Buffers |\n| Configuration | JSON files with encoding/json | YAML with validation library |\n| Logging | Standard log package with levels | Structured logging (logrus/zap) |\n| Testing | Built-in testing package | Testify for assertions and mocks |\n| Serialization | JSON for all message payloads | MessagePack or Protocol Buffers |\n| HTTP Client | net/http with custom transport | Dedicated HTTP client library |\n\nFor learning purposes, start with the simple options to focus on distributed systems concepts rather than library complexity. The advanced options can be adopted later for production deployments.\n\n#### Recommended File Structure and Starter Code\n\n**Core Type Definitions** (`pkg/types/node.go`):\n```go\npackage types\n\nimport \"fmt\"\n\ntype NodeID uint64\n\ntype NodeState int\n\nconst (\n    StateFollower NodeState = iota\n    StateCandidate\n    StateLeader\n)\n\nfunc (s NodeState) String() string {\n    switch s {\n    case StateFollower:\n        return \"Follower\"\n    case StateCandidate:\n        return \"Candidate\" \n    case StateLeader:\n        return \"Leader\"\n    default:\n        return fmt.Sprintf(\"Unknown(%d)\", int(s))\n    }\n}\n\ntype Node struct {\n    ID      NodeID `json:\"id\"`\n    Address string `json:\"address\"`\n    State   NodeState `json:\"state\"`\n}\n```\n\n**Message Type Definitions** (`pkg/types/message.go`):\n```go\npackage types\n\ntype MessageType int\n\nconst (\n    MsgHeartbeat MessageType = iota\n    MsgElection\n    MsgOK\n    MsgCoordinator\n    MsgRingToken\n)\n\nfunc (t MessageType) String() string {\n    switch t {\n    case MsgHeartbeat:\n        return \"Heartbeat\"\n    case MsgElection:\n        return \"Election\"\n    case MsgOK:\n        return \"OK\"\n    case MsgCoordinator:\n        return \"Coordinator\"\n    case MsgRingToken:\n        return \"RingToken\"\n    default:\n        return \"Unknown\"\n    }\n}\n\ntype Message struct {\n    Type      MessageType `json:\"type\"`\n    From      NodeID      `json:\"from\"`\n    To        NodeID      `json:\"to\"`        // 0 for broadcast\n    Term      uint64      `json:\"term\"`\n    Payload   []byte      `json:\"payload\"`\n    Timestamp int64       `json:\"timestamp\"`\n}\n```\n\n**Transport Interface Definition** (`internal/transport/transport.go`):\n```go\npackage transport\n\nimport \"github.com/yourproject/pkg/types\"\n\ntype Transport interface {\n    // SendMessage delivers a message to a specific target node\n    SendMessage(target types.NodeID, msg types.Message) error\n    \n    // BroadcastMessage sends a message to all known live nodes\n    BroadcastMessage(msg types.Message) error\n    \n    // ReceiveMessages returns a channel for incoming messages\n    ReceiveMessages() <-chan types.Message\n    \n    // UpdateMembership updates the set of known cluster nodes\n    UpdateMembership(nodes []types.Node) error\n    \n    // Start begins accepting incoming connections and messages\n    Start() error\n    \n    // Stop cleanly shuts down the transport layer\n    Stop() error\n}\n```\n\n**HTTP Transport Implementation** (`internal/transport/http_transport.go`):\n```go\npackage transport\n\nimport (\n    \"bytes\"\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n    \"sync\"\n    \"time\"\n    \n    \"github.com/yourproject/pkg/types\"\n)\n\ntype HTTPTransport struct {\n    localNodeID types.NodeID\n    bindAddr    string\n    nodes       map[types.NodeID]types.Node\n    nodesMutex  sync.RWMutex\n    \n    server      *http.Server\n    incomingMsg chan types.Message\n    client      *http.Client\n    ctx         context.Context\n    cancel      context.CancelFunc\n}\n\nfunc NewHTTPTransport(nodeID types.NodeID, bindAddr string) *HTTPTransport {\n    ctx, cancel := context.WithCancel(context.Background())\n    \n    return &HTTPTransport{\n        localNodeID: nodeID,\n        bindAddr:    bindAddr,\n        nodes:       make(map[types.NodeID]types.Node),\n        incomingMsg: make(chan types.Message, 100),\n        client: &http.Client{\n            Timeout: 5 * time.Second,\n        },\n        ctx:    ctx,\n        cancel: cancel,\n    }\n}\n\nfunc (t *HTTPTransport) Start() error {\n    mux := http.NewServeMux()\n    mux.HandleFunc(\"/message\", t.handleMessage)\n    mux.HandleFunc(\"/health\", t.handleHealth)\n    \n    t.server = &http.Server{\n        Addr:    t.bindAddr,\n        Handler: mux,\n    }\n    \n    go func() {\n        if err := t.server.ListenAndServe(); err != http.ErrServerClosed {\n            // Log error in production\n        }\n    }()\n    \n    return nil\n}\n\nfunc (t *HTTPTransport) Stop() error {\n    t.cancel()\n    if t.server != nil {\n        return t.server.Shutdown(context.Background())\n    }\n    return nil\n}\n\nfunc (t *HTTPTransport) SendMessage(target types.NodeID, msg types.Message) error {\n    t.nodesMutex.RLock()\n    node, exists := t.nodes[target]\n    t.nodesMutex.RUnlock()\n    \n    if !exists {\n        return fmt.Errorf(\"unknown target node: %d\", target)\n    }\n    \n    return t.sendHTTPMessage(node.Address, msg)\n}\n\nfunc (t *HTTPTransport) BroadcastMessage(msg types.Message) error {\n    t.nodesMutex.RLock()\n    nodes := make([]types.Node, 0, len(t.nodes))\n    for _, node := range t.nodes {\n        if node.ID != t.localNodeID {\n            nodes = append(nodes, node)\n        }\n    }\n    t.nodesMutex.RUnlock()\n    \n    var lastErr error\n    for _, node := range nodes {\n        if err := t.sendHTTPMessage(node.Address, msg); err != nil {\n            lastErr = err\n            // Continue trying to send to other nodes\n        }\n    }\n    \n    return lastErr\n}\n\nfunc (t *HTTPTransport) ReceiveMessages() <-chan types.Message {\n    return t.incomingMsg\n}\n\nfunc (t *HTTPTransport) UpdateMembership(nodes []types.Node) error {\n    t.nodesMutex.Lock()\n    defer t.nodesMutex.Unlock()\n    \n    t.nodes = make(map[types.NodeID]types.Node)\n    for _, node := range nodes {\n        t.nodes[node.ID] = node\n    }\n    \n    return nil\n}\n\nfunc (t *HTTPTransport) sendHTTPMessage(address string, msg types.Message) error {\n    data, err := json.Marshal(msg)\n    if err != nil {\n        return fmt.Errorf(\"marshal message: %w\", err)\n    }\n    \n    req, err := http.NewRequestWithContext(t.ctx, \"POST\", \n        fmt.Sprintf(\"http://%s/message\", address), bytes.NewReader(data))\n    if err != nil {\n        return fmt.Errorf(\"create request: %w\", err)\n    }\n    \n    req.Header.Set(\"Content-Type\", \"application/json\")\n    \n    resp, err := t.client.Do(req)\n    if err != nil {\n        return fmt.Errorf(\"send request: %w\", err)\n    }\n    defer resp.Body.Close()\n    \n    if resp.StatusCode != http.StatusOK {\n        return fmt.Errorf(\"unexpected status: %d\", resp.StatusCode)\n    }\n    \n    return nil\n}\n\nfunc (t *HTTPTransport) handleMessage(w http.ResponseWriter, r *http.Request) {\n    if r.Method != http.MethodPost {\n        http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n        return\n    }\n    \n    var msg types.Message\n    if err := json.NewDecoder(r.Body).Decode(&msg); err != nil {\n        http.Error(w, \"Invalid JSON\", http.StatusBadRequest)\n        return\n    }\n    \n    select {\n    case t.incomingMsg <- msg:\n        w.WriteHeader(http.StatusOK)\n    case <-t.ctx.Done():\n        http.Error(w, \"Shutting down\", http.StatusServiceUnavailable)\n    default:\n        http.Error(w, \"Message queue full\", http.StatusTooManyRequests)\n    }\n}\n\nfunc (t *HTTPTransport) handleHealth(w http.ResponseWriter, r *http.Request) {\n    w.WriteHeader(http.StatusOK)\n    json.NewEncoder(w).Encode(map[string]interface{}{\n        \"node_id\": t.localNodeID,\n        \"status\":  \"healthy\",\n    })\n}\n```\n\n**Election Coordinator Interface** (`internal/election/coordinator.go`):\n```go\npackage election\n\nimport \"github.com/yourproject/pkg/types\"\n\ntype ElectionCoordinator interface {\n    // StartElection initiates a new leader election using this algorithm\n    StartElection() error\n    \n    // HandleMessage processes incoming election-specific messages\n    HandleMessage(msg types.Message) error\n    \n    // GetCurrentLeader returns the currently elected leader's ID\n    GetCurrentLeader() types.NodeID\n    \n    // IsLeader checks if this node is currently the leader\n    IsLeader() bool\n    \n    // GetElectionTerm returns the current election term number\n    GetElectionTerm() uint64\n}\n```\n\n**Core Logic Skeletons for Student Implementation**\n\n**Bully Election Skeleton** (`internal/election/bully.go`):\n```go\npackage election\n\nimport (\n    \"sync\"\n    \"time\"\n    \n    \"github.com/yourproject/pkg/types\"\n    \"github.com/yourproject/internal/transport\"\n)\n\ntype BullyElection struct {\n    nodeID       types.NodeID\n    transport    transport.Transport\n    \n    currentLeader types.NodeID\n    electionTerm  uint64\n    state         types.NodeState\n    \n    mutex         sync.RWMutex\n    electionTimer *time.Timer\n    \n    // Configuration\n    electionTimeout time.Duration\n    nodes          []types.NodeID // All known node IDs in cluster\n}\n\nfunc NewBullyElection(nodeID types.NodeID, transport transport.Transport, nodes []types.NodeID) *BullyElection {\n    return &BullyElection{\n        nodeID:          nodeID,\n        transport:       transport,\n        nodes:          nodes,\n        state:          types.StateFollower,\n        electionTimeout: 5 * time.Second,\n    }\n}\n\n// StartElection initiates a new bully election from this node\nfunc (b *BullyElection) StartElection() error {\n    b.mutex.Lock()\n    defer b.mutex.Unlock()\n    \n    // TODO 1: Increment election term and become candidate\n    // TODO 2: Find all nodes with higher IDs than this node\n    // TODO 3: Send MsgElection to all higher-ID nodes\n    // TODO 4: Start election timeout timer\n    // TODO 5: If no higher-ID nodes exist, immediately declare victory\n    // Hint: Use b.findHigherIDNodes() to get nodes to contact\n    // Hint: Create Message with Type=MsgElection, From=b.nodeID, Term=b.electionTerm\n    \n    return nil\n}\n\n// HandleMessage processes incoming bully election messages\nfunc (b *BullyElection) HandleMessage(msg types.Message) error {\n    switch msg.Type {\n    case types.MsgElection:\n        return b.handleElectionMessage(msg)\n    case types.MsgOK:\n        return b.handleOKMessage(msg)\n    case types.MsgCoordinator:\n        return b.handleCoordinatorMessage(msg)\n    default:\n        return nil // Ignore unknown message types\n    }\n}\n\nfunc (b *BullyElection) handleElectionMessage(msg types.Message) error {\n    b.mutex.Lock()\n    defer b.mutex.Unlock()\n    \n    // TODO 1: Check if sender has lower ID than this node\n    // TODO 2: If sender ID < this node ID, send MsgOK response\n    // TODO 3: Start own election (call StartElection) to assert higher priority\n    // Hint: Compare msg.From with b.nodeID\n    // Hint: Create response message with Type=MsgOK, From=b.nodeID, To=msg.From\n    \n    return nil\n}\n\nfunc (b *BullyElection) handleOKMessage(msg types.Message) error {\n    b.mutex.Lock()\n    defer b.mutex.Unlock()\n    \n    // TODO 1: Cancel election timer since higher-ID node responded\n    // TODO 2: Return to follower state \n    // TODO 3: Clear any pending election state\n    // Hint: Use b.electionTimer.Stop() if timer exists\n    // Hint: Set b.state = types.StateFollower\n    \n    return nil\n}\n\nfunc (b *BullyElection) handleCoordinatorMessage(msg types.Message) error {\n    b.mutex.Lock()\n    defer b.mutex.Unlock()\n    \n    // TODO 1: Accept the announced leader if election term is current/newer\n    // TODO 2: Update current leader to sender\n    // TODO 3: Transition to follower state\n    // TODO 4: Cancel any ongoing election\n    // Hint: Check msg.Term >= b.electionTerm before accepting\n    \n    return nil\n}\n\nfunc (b *BullyElection) onElectionTimeout() {\n    b.mutex.Lock()\n    defer b.mutex.Unlock()\n    \n    // TODO 1: Check if still in candidate state (election wasn't cancelled)\n    // TODO 2: No higher-ID nodes responded, so this node wins\n    // TODO 3: Transition to leader state\n    // TODO 4: Broadcast MsgCoordinator to announce victory\n    // Hint: Create coordinator message with Type=MsgCoordinator, From=b.nodeID, To=0 (broadcast)\n}\n\nfunc (b *BullyElection) GetCurrentLeader() types.NodeID {\n    b.mutex.RLock()\n    defer b.mutex.RUnlock()\n    return b.currentLeader\n}\n\nfunc (b *BullyElection) IsLeader() bool {\n    b.mutex.RLock()\n    defer b.mutex.RUnlock()\n    return b.state == types.StateLeader\n}\n\nfunc (b *BullyElection) GetElectionTerm() uint64 {\n    b.mutex.RLock()\n    defer b.mutex.RUnlock()\n    return b.electionTerm\n}\n\n// Helper method to find nodes with higher IDs\nfunc (b *BullyElection) findHigherIDNodes() []types.NodeID {\n    // TODO: Return slice of node IDs that are greater than b.nodeID\n    // Hint: Iterate through b.nodes and collect IDs where node > b.nodeID\n    return nil\n}\n```\n\n**Configuration Structure** (`internal/config/config.go`):\n```go\npackage config\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"time\"\n    \n    \"github.com/yourproject/pkg/types\"\n)\n\ntype Config struct {\n    LocalNodeID       types.NodeID        `json:\"local_node_id\"`\n    BindAddress       string              `json:\"bind_address\"`\n    ClusterNodes      []NodeConfig        `json:\"cluster_nodes\"`\n    ElectionAlgorithm string              `json:\"election_algorithm\"` // \"bully\" or \"ring\"\n    HeartbeatInterval time.Duration       `json:\"heartbeat_interval\"`\n    ElectionTimeout   time.Duration       `json:\"election_timeout\"`\n    LeaderTimeout     time.Duration       `json:\"leader_timeout\"`\n}\n\ntype NodeConfig struct {\n    ID      types.NodeID `json:\"id\"`\n    Address string       `json:\"address\"`\n}\n\nfunc LoadConfig(filename string) (*Config, error) {\n    data, err := os.ReadFile(filename)\n    if err != nil {\n        return nil, fmt.Errorf(\"read config file: %w\", err)\n    }\n    \n    var config Config\n    if err := json.Unmarshal(data, &config); err != nil {\n        return nil, fmt.Errorf(\"parse config JSON: %w\", err)\n    }\n    \n    // Apply defaults\n    if config.HeartbeatInterval == 0 {\n        config.HeartbeatInterval = 1 * time.Second\n    }\n    if config.ElectionTimeout == 0 {\n        config.ElectionTimeout = 5 * time.Second\n    }\n    if config.LeaderTimeout == 0 {\n        config.LeaderTimeout = 10 * time.Second\n    }\n    \n    return &config, nil\n}\n```\n\n#### Milestone Checkpoints\n\n**Milestone 1 Checkpoint - Node Communication**:\n```bash\n# Start first node\ngo run cmd/election-node/main.go -config=test/node1.json &\n\n# Start second node  \ngo run cmd/election-node/main.go -config=test/node2.json &\n\n# Test message passing with curl\ncurl -X POST http://localhost:8081/message \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"type\": 0, \"from\": 999, \"to\": 1, \"payload\": null}'\n\n# Expected: Both nodes should log receiving heartbeat messages\n# Expected: Health endpoints should return node status\ncurl http://localhost:8081/health\n```\n\n**Milestone 2 Checkpoint - Bully Election**:\n```bash\n# Start 3-node cluster\n./scripts/run-cluster.sh bully 3\n\n# Kill current leader node\npkill -f \"node-id=3\"\n\n# Expected: Remaining nodes should elect new leader within 10 seconds\n# Expected: All nodes should agree on same leader\n# Check logs for \"Election started\", \"Received OK\", \"New leader elected\" messages\n```\n\n**Milestone 3 Checkpoint - Ring Election**:\n```bash  \n# Start 5-node ring cluster\n./scripts/run-cluster.sh ring 5\n\n# Simulate network partition\n./scripts/simulate-failure.sh partition 2,3\n\n# Expected: Ring should adapt and continue election around partition\n# Expected: Token should skip failed nodes and complete ring traversal\n# Check logs for \"Token forwarded\", \"Ring repaired\", \"Leader selected\" messages\n\n```\n\n\n## Data Model and Message Types\n\n> **Milestone(s):** Foundation for all milestones - defines the core data structures and message formats used in node communication (Milestone 1), bully election (Milestone 2), and ring election (Milestone 3)\n\nBefore implementing any distributed leader election algorithm, we must establish the fundamental data structures that represent nodes, their states, and the messages they exchange. Think of this as defining the \"vocabulary\" and \"grammar\" of our distributed system - without a clear understanding of how nodes identify themselves and communicate, we cannot build reliable coordination protocols.\n\n### Mental Model: Diplomatic Protocol\n\nImagine a group of ambassadors from different countries trying to select a conference chairperson. Each ambassador has official credentials (node identity), follows specific diplomatic protocols for communication (message formats), and maintains an up-to-date list of which other ambassadors are present and participating (cluster membership). Just as diplomatic protocols prevent confusion and ensure orderly communication, our data model provides the structured foundation for distributed coordination.\n\nThe ambassadors need standardized message formats - formal proposals, acknowledgments, and announcements - that everyone understands. They also need to track who is present, who has left the conference, and who might be temporarily unreachable due to communication issues. This diplomatic analogy captures the essence of our data model: formal identity, structured communication, and membership tracking.\n\n### Node Identity and State\n\nEvery participant in our leader election system requires a unique, stable identity that persists across restarts and network interruptions. The node identity serves multiple critical purposes: it provides a deterministic way to order nodes (essential for the bully algorithm), enables point-to-point message routing, and allows other nodes to track membership changes over time.\n\n**Node Identity Design**\n\nThe foundation of node identity is the `NodeID` type, which uses a 64-bit unsigned integer. This choice provides several important benefits over alternatives like string-based UUIDs or network addresses. Numeric identifiers enable efficient comparison operations required by election algorithms - the bully algorithm specifically depends on determining which node has the \"highest\" ID. Additionally, 64-bit integers provide an enormous namespace (18 quintillion possible values) while maintaining compact representation and fast comparison performance.\n\n> **Decision: Numeric Node Identifiers**\n> - **Context**: Need unique, comparable identifiers for nodes participating in leader election\n> - **Options Considered**: \n>   1. String-based UUIDs (universally unique but not naturally ordered)\n>   2. Network addresses like IP:Port (not stable across restarts or network changes)\n>   3. 64-bit unsigned integers (compact, fast comparison, naturally ordered)\n> - **Decision**: Use 64-bit unsigned integers as `NodeID`\n> - **Rationale**: Election algorithms require efficient comparison and ordering of node identities. Numeric IDs provide O(1) comparison, deterministic ordering for tie-breaking, and compact representation for network messages\n> - **Consequences**: Requires configuration or generation strategy to ensure uniqueness. Enables efficient election algorithms but means node IDs must be assigned rather than automatically generated\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `NodeID` | `uint64` | Unique numeric identifier for the node, used for comparison in election algorithms |\n\n**Node State Representation**\n\nEach node maintains its current state in the leader election process through a simple but crucial state machine. The `NodeState` enumeration captures the three fundamental roles a node can occupy: following an established leader, actively participating in an election, or serving as the current cluster leader.\n\n| State | Value | Description |\n|-------|-------|-------------|\n| `StateFollower` | `0` | Node is following the current leader and not participating in elections |\n| `StateCandidate` | `1` | Node is actively participating in a leader election process |\n| `StateLeader` | `2` | Node is the current elected leader of the cluster |\n\nThe state transitions follow a predictable pattern that prevents confusion and ensures system stability. A `Follower` transitions to `Candidate` when it detects leader failure or receives election messages. A `Candidate` either transitions to `Leader` upon winning an election or back to `Follower` when another node wins. A `Leader` transitions back to `Follower` when it detects it has lost leadership due to network partition or higher-priority elections.\n\n**Complete Node Representation**\n\nThe `Node` structure combines identity, addressing, and state information to provide a complete representation of a cluster participant:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `ID` | `NodeID` | Unique numeric identifier for this node |\n| `Address` | `string` | Network address for communication (IP:Port format) |\n| `State` | `NodeState` | Current election state of this node |\n\nThis design separates concerns effectively: the `ID` provides stable identity for election logic, the `Address` enables network communication, and the `State` tracks the node's current role in the coordination protocol. The address field uses string representation to accommodate both IPv4 and IPv6 addresses, as well as different port configurations.\n\n> The key insight here is that node identity must remain stable across network changes, restarts, and even IP address modifications. The `NodeID` serves as the permanent identity, while the `Address` provides the current communication endpoint.\n\n**State Management Considerations**\n\nNode state changes must be atomic and carefully synchronized to prevent race conditions during concurrent elections. When a node changes state, it must ensure that its message handling logic immediately reflects the new role. For example, a node transitioning from `Candidate` to `Leader` must start accepting coordination requests and stop participating in election protocols.\n\nThe state machine also provides important debugging and monitoring capabilities. By examining the current state distribution across the cluster, operators can quickly identify problems: too many nodes in `Candidate` state suggests election instability, while no nodes in `Leader` state indicates a coordination failure that requires intervention.\n\n### Election Message Formats\n\nInter-node communication during leader election requires precisely defined message formats that both algorithms can understand and process reliably. The message format design must accommodate different election protocols while maintaining type safety and extensibility for future enhancements.\n\n**Base Message Structure**\n\nAll election messages share a common envelope structure that provides routing information and message classification:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Type` | `MessageType` | Identifies the specific message category and protocol |\n| `From` | `NodeID` | Identifier of the node that sent this message |\n| `To` | `NodeID` | Intended recipient node (0 for broadcast messages) |\n| `Payload` | `[]byte` | Serialized message content specific to the message type |\n\nThe `From` field enables message authentication and helps detect network issues or malicious behavior. The `To` field supports both point-to-point messaging (specific `NodeID`) and broadcast semantics (using `NodeID` value 0 to indicate all nodes). The binary payload approach provides flexibility for different message types while maintaining a consistent envelope format.\n\n**Message Type Classification**\n\nThe `MessageType` enumeration defines all communication patterns used across both election algorithms:\n\n| Message Type | Value | Algorithm | Description |\n|--------------|-------|-----------|-------------|\n| `MsgElection` | `1` | Bully | Election initiation message sent to higher-ID nodes |\n| `MsgOK` | `2` | Bully | Acknowledgment that a higher-ID node will handle the election |\n| `MsgCoordinator` | `3` | Both | Announcement of the newly elected leader |\n| `MsgHeartbeat` | `4` | Both | Periodic liveness check from current leader |\n| `MsgRingToken` | `5` | Ring | Election token passed around the logical ring |\n\nThis enumeration provides clear separation between algorithm-specific messages and shared infrastructure messages. The heartbeat message serves both algorithms by providing failure detection, while the coordinator message announces election results regardless of the algorithm used.\n\n**Bully Algorithm Message Formats**\n\nThe bully algorithm uses three distinct message types to coordinate elections. Each message type carries specific information required for the protocol's operation:\n\n**Election Message (`MsgElection`)**\n| Field | Type | Description |\n|-------|------|-------------|\n| `ElectionID` | `uint64` | Unique identifier for this election instance |\n| `CandidateID` | `NodeID` | ID of the node initiating this election |\n| `Term` | `uint64` | Election term number to prevent confusion from delayed messages |\n\nThe `ElectionID` prevents confusion when multiple elections run concurrently or when delayed messages from previous elections arrive out of order. The `Term` field provides additional protection against stale messages and enables proper election sequencing.\n\n**OK Message (`MsgOK`)**\n| Field | Type | Description |\n|-------|------|-------------|\n| `ElectionID` | `uint64` | References the election being acknowledged |\n| `ResponderID` | `NodeID` | ID of the node sending this acknowledgment |\n\nThe OK message serves as both acknowledgment and promise: the responding node acknowledges the election request and promises to conduct its own election attempt with higher-priority nodes.\n\n**Coordinator Message (`MsgCoordinator`)**\n| Field | Type | Description |\n|-------|------|-------------|\n| `LeaderID` | `NodeID` | ID of the newly elected leader |\n| `Term` | `uint64` | Election term in which this leader was chosen |\n| `ElectionID` | `uint64` | The election that produced this leader |\n\nThe coordinator message broadcasts the election results to all cluster members. The term and election ID fields help nodes validate the announcement and detect potential split-brain scenarios.\n\n**Ring Election Message Format**\n\nThe ring election algorithm uses a single, more complex message type that accumulates information as it travels around the cluster:\n\n**Ring Token Message (`MsgRingToken`)**\n| Field | Type | Description |\n|-------|------|-------------|\n| `ElectionID` | `uint64` | Unique identifier for this ring election instance |\n| `InitiatorID` | `NodeID` | Node that started this election |\n| `Participants` | `[]NodeID` | List of live node IDs collected during ring traversal |\n| `Complete` | `bool` | True when the token has completed a full ring traversal |\n\nThe `Participants` slice grows as the token travels around the ring, with each live node adding its own ID to the list. When the token returns to the `InitiatorID` node, the `Complete` flag is set to true, and the node with the highest ID in the `Participants` list becomes the new leader.\n\nThis design elegantly handles ring election requirements: it collects membership information dynamically, handles failed nodes by skipping them, and provides all necessary data for leader selection in a single message that makes one complete traversal of the cluster.\n\n**Heartbeat Message Format**\n\nBoth election algorithms rely on heartbeat messages for failure detection:\n\n**Heartbeat Message (`MsgHeartbeat`)**\n| Field | Type | Description |\n|-------|------|-------------|\n| `LeaderID` | `NodeID` | ID of the current leader sending this heartbeat |\n| `Term` | `uint64` | Current leadership term |\n| `Timestamp` | `int64` | Unix timestamp when this heartbeat was sent |\n\nHeartbeat messages serve multiple purposes: they confirm leader liveness, establish the current term for election ordering, and provide timing information for failure detection calculations.\n\n> **Decision: Binary Payload with Type-Specific Deserialization**\n> - **Context**: Need flexible message format that supports multiple election algorithms and future extensions\n> - **Options Considered**:\n>   1. Fixed struct with optional fields (wastes bandwidth, limits extensibility)\n>   2. JSON payloads (human-readable but larger and slower to parse)\n>   3. Binary payload with type-specific deserialization (compact, fast, extensible)\n> - **Decision**: Use binary payload with message type determining deserialization logic\n> - **Rationale**: Provides optimal network efficiency for high-frequency messages like heartbeats, while maintaining flexibility for different message formats per algorithm\n> - **Consequences**: Requires careful serialization/deserialization logic and version compatibility management, but enables efficient network usage and protocol evolution\n\n### Cluster Membership Model\n\nEffective leader election requires every node to maintain an accurate, up-to-date view of cluster membership. The membership model must handle dynamic scenarios where nodes join, leave gracefully, crash unexpectedly, or become temporarily unreachable due to network partitions. This information directly impacts election decisions and determines message routing patterns.\n\n**Membership State Representation**\n\nThe cluster membership model centers on maintaining a consistent view of which nodes are currently alive and participating in the election process. Each node maintains its own membership table, which gets updated through various mechanisms including heartbeat monitoring, explicit join/leave messages, and failure detection timeouts.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `Members` | `map[NodeID]Node` | Current view of live cluster members indexed by node ID |\n| `LastSeen` | `map[NodeID]int64` | Unix timestamp of last communication from each node |\n| `SuspicionLevel` | `map[NodeID]int` | Graduated suspicion levels for potentially failed nodes |\n| `Term` | `uint64` | Current cluster membership term for consistency checking |\n\nThe `Members` map provides O(1) lookup of node information during message routing and election decisions. The `LastSeen` timestamps enable failure detection by tracking communication recency. The `SuspicionLevel` field implements graduated failure detection - rather than immediately declaring a node dead after one missed heartbeat, the system increases suspicion levels and requires multiple consecutive failures before removing a node from the active membership.\n\n**Membership State Transitions**\n\nNodes transition through several states in the membership model, reflecting their current availability and participation status:\n\n| Current State | Event | Next State | Actions Taken |\n|---------------|-------|------------|---------------|\n| Unknown | Join Request | Suspected | Add to members map, start monitoring |\n| Suspected | Heartbeat Received | Active | Reset suspicion level, update last seen |\n| Active | Heartbeat Timeout | Suspected | Increment suspicion level |\n| Suspected | Multiple Timeouts | Failed | Remove from active members, trigger election if was leader |\n| Failed | Heartbeat Received | Suspected | Re-add to members, reset monitoring |\n| Active | Explicit Leave | Departed | Remove from members, no election trigger |\n\nThis graduated approach prevents membership churn due to temporary network hiccups while ensuring that truly failed nodes are eventually removed from the active membership. The distinction between \"Failed\" and \"Departed\" states helps with debugging - departed nodes left gracefully, while failed nodes stopped responding unexpectedly.\n\n**Membership Update Mechanisms**\n\nSeveral mechanisms work together to maintain accurate membership information across the cluster:\n\n1. **Heartbeat-Based Discovery**: Active leaders periodically broadcast heartbeat messages that include their current membership view. Followers compare this information with their local view and request updates for any discrepancies.\n\n2. **Join Protocol**: New nodes announce themselves to the cluster using a standardized join message that includes their ID, address, and capabilities. Existing members validate the join request and update their membership tables accordingly.\n\n3. **Failure Detection Integration**: The failure detection subsystem automatically updates membership when nodes become unresponsive. This integration ensures that election algorithms always work with current membership information.\n\n4. **Explicit Leave Notifications**: Nodes shutting down gracefully send leave messages to inform other members of their intentional departure. This prevents unnecessary failure detection and election triggering.\n\n**Membership Consistency Challenges**\n\nMaintaining consistent membership views across all nodes presents several technical challenges that directly impact election correctness:\n\n⚠️ **Pitfall: Split-Brain Membership Views**\nDifferent nodes may have inconsistent views of cluster membership, especially during network partitions. Node A might believe Node C has failed, while Node B still considers Node C active. This can lead to multiple simultaneous elections or incorrect leader selection. The solution is to include membership version information in election messages and require nodes to reconcile their views before participating in elections.\n\n⚠️ **Pitfall: Premature Failure Detection**\nAggressive failure detection timeouts can cause nodes to be incorrectly marked as failed during temporary network congestion or garbage collection pauses. This creates membership churn and unnecessary elections. The graduated suspicion levels and configurable timeout values help balance responsiveness with stability.\n\nThe membership model also must handle the fundamental challenge of determining cluster quorum - how many nodes must be reachable to conduct a valid election. During network partitions, different groups of nodes may each believe they constitute a valid majority, leading to split-brain scenarios.\n\n> **Decision: Graduated Failure Detection with Configurable Timeouts**\n> - **Context**: Need balance between quick failure detection and stability during network hiccups\n> - **Options Considered**:\n>   1. Binary alive/dead based on single heartbeat timeout (fast but unstable)\n>   2. Graduated suspicion levels with multiple timeouts (slower but more stable)\n>   3. External failure detector service (adds complexity and single point of failure)\n> - **Decision**: Implement graduated suspicion levels with configurable timeout parameters\n> - **Rationale**: Provides tunable balance between detection speed and false positive rate. Allows different timeout values for different network conditions without code changes\n> - **Consequences**: More complex state management and requires careful timeout parameter tuning, but significantly reduces membership churn in unstable network conditions\n\n**Quorum and Split-Brain Prevention**\n\nThe membership model must integrate with quorum mechanisms to prevent split-brain scenarios during network partitions. A quorum represents the minimum number of nodes that must be reachable to conduct valid cluster operations, including leader elections.\n\n| Scenario | Total Nodes | Quorum Size | Partition A | Partition B | Valid Elections |\n|----------|-------------|-------------|-------------|-------------|-----------------|\n| Simple Majority | 5 | 3 | 3 nodes | 2 nodes | Partition A only |\n| Simple Majority | 6 | 4 | 3 nodes | 3 nodes | Neither partition |\n| Dynamic Quorum | 5 | 3 | 3 nodes | 2 nodes | Partition A only |\n\nThe quorum calculation directly uses the membership information to determine election validity. Nodes must verify they can communicate with a quorum of cluster members before initiating or participating in leader elections. This prevents minority partitions from electing leaders that the majority partition would not recognize.\n\n**Membership Message Integration**\n\nThe membership model integrates closely with the election message formats by including membership metadata in election communications:\n\n**Enhanced Election Messages with Membership Context**\n| Field | Type | Description |\n|-------|------|-------------|\n| `MembershipTerm` | `uint64` | Version of membership view used for this election |\n| `KnownMembers` | `[]NodeID` | List of nodes the sender believes are currently active |\n| `QuorumSize` | `int` | Minimum nodes required for valid election |\n\nThis integration ensures that election decisions are based on consistent membership information and helps nodes detect when their membership views are out of sync. When a node receives an election message with a different membership term or member list, it can request a membership update before participating in the election.\n\nThe membership model serves as the foundation for all higher-level coordination protocols. By providing accurate, eventually consistent information about cluster participation, it enables the election algorithms to make correct decisions about leadership while maintaining system stability during various failure scenarios.\n\n### Implementation Guidance\n\nThis subsection provides concrete implementation details for the data structures and message formats described above, with complete Go code that junior developers can use as a foundation for building their leader election system.\n\n**A. Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Serialization | JSON with encoding/json | Protocol Buffers with protobuf |\n| Message Transport | HTTP POST with JSON bodies | gRPC with streaming |\n| State Persistence | In-memory maps | Embedded database (BadgerDB) |\n| Configuration | JSON config files | YAML with validation |\n| Logging | Standard log package | Structured logging (logrus/zap) |\n\nFor learning purposes, start with the simple options and migrate to advanced options once the core algorithms are working correctly.\n\n**B. Recommended File Structure**\n\n```\nleader-election/\n  cmd/\n    node/\n      main.go                 ← node entry point\n  internal/\n    types/\n      node.go                 ← core data structures\n      messages.go             ← message formats\n      membership.go           ← cluster membership\n    transport/\n      transport.go            ← transport interface\n      http_transport.go       ← HTTP implementation\n    election/\n      coordinator.go          ← election coordinator interface\n      bully.go               ← bully algorithm\n      ring.go                ← ring algorithm\n  pkg/\n    config/\n      config.go              ← configuration structures\n```\n\n**C. Core Data Structures (Complete Implementation)**\n\n```go\n// internal/types/node.go\npackage types\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\n// NodeID represents a unique node identifier\ntype NodeID uint64\n\n// NodeState represents the current election state of a node\ntype NodeState int\n\n// Node state constants\nconst (\n    StateFollower NodeState = iota\n    StateCandidate\n    StateLeader\n)\n\n// String returns human-readable state names\nfunc (s NodeState) String() string {\n    switch s {\n    case StateFollower:\n        return \"Follower\"\n    case StateCandidate:\n        return \"Candidate\" \n    case StateLeader:\n        return \"Leader\"\n    default:\n        return \"Unknown\"\n    }\n}\n\n// Node represents a cluster member\ntype Node struct {\n    ID      NodeID    `json:\"id\"`\n    Address string    `json:\"address\"`\n    State   NodeState `json:\"state\"`\n}\n\n// String returns a formatted node description\nfunc (n Node) String() string {\n    return fmt.Sprintf(\"Node{ID: %d, Address: %s, State: %s}\", \n        n.ID, n.Address, n.State)\n}\n\n// ClusterMembership manages the view of cluster members\ntype ClusterMembership struct {\n    mutex         sync.RWMutex\n    members       map[NodeID]Node\n    lastSeen      map[NodeID]time.Time\n    suspicionLevel map[NodeID]int\n    term          uint64\n    localNodeID   NodeID\n}\n\n// NewClusterMembership creates a new membership manager\nfunc NewClusterMembership(localID NodeID) *ClusterMembership {\n    return &ClusterMembership{\n        members:       make(map[NodeID]Node),\n        lastSeen:      make(map[NodeID]time.Time),\n        suspicionLevel: make(map[NodeID]int),\n        term:          1,\n        localNodeID:   localID,\n    }\n}\n\n// UpdateMembership updates the known cluster nodes\nfunc (cm *ClusterMembership) UpdateMembership(nodes []Node) error {\n    cm.mutex.Lock()\n    defer cm.mutex.Unlock()\n    \n    // TODO: Implement membership update logic\n    // TODO: Validate node information\n    // TODO: Update internal maps\n    // TODO: Increment membership term\n    // TODO: Trigger callbacks for membership changes\n    return nil\n}\n\n// GetActiveMembers returns currently active cluster members\nfunc (cm *ClusterMembership) GetActiveMembers() []Node {\n    cm.mutex.RLock()\n    defer cm.mutex.RUnlock()\n    \n    var active []Node\n    for _, node := range cm.members {\n        active = append(active, node)\n    }\n    return active\n}\n\n// MarkNodeSeen updates the last seen timestamp for a node\nfunc (cm *ClusterMembership) MarkNodeSeen(nodeID NodeID) {\n    cm.mutex.Lock()\n    defer cm.mutex.Unlock()\n    \n    cm.lastSeen[nodeID] = time.Now()\n    cm.suspicionLevel[nodeID] = 0 // Reset suspicion\n}\n\n// IncreaseSuspicion increments suspicion level for a node\nfunc (cm *ClusterMembership) IncreaseSuspicion(nodeID NodeID) int {\n    cm.mutex.Lock()\n    defer cm.mutex.Unlock()\n    \n    cm.suspicionLevel[nodeID]++\n    return cm.suspicionLevel[nodeID]\n}\n```\n\n**D. Message Format Implementation**\n\n```go\n// internal/types/messages.go\npackage types\n\nimport (\n    \"encoding/json\"\n    \"time\"\n)\n\n// MessageType identifies different message categories\ntype MessageType int\n\n// Message type constants\nconst (\n    MsgElection MessageType = iota + 1\n    MsgOK\n    MsgCoordinator\n    MsgHeartbeat\n    MsgRingToken\n)\n\n// String returns human-readable message type names\nfunc (mt MessageType) String() string {\n    switch mt {\n    case MsgElection:\n        return \"Election\"\n    case MsgOK:\n        return \"OK\"\n    case MsgCoordinator:\n        return \"Coordinator\"\n    case MsgHeartbeat:\n        return \"Heartbeat\"\n    case MsgRingToken:\n        return \"RingToken\"\n    default:\n        return \"Unknown\"\n    }\n}\n\n// Message represents the base message structure\ntype Message struct {\n    Type    MessageType `json:\"type\"`\n    From    NodeID      `json:\"from\"`\n    To      NodeID      `json:\"to\"` // 0 for broadcast\n    Payload []byte      `json:\"payload\"`\n}\n\n// ElectionMessage represents bully algorithm election initiation\ntype ElectionMessage struct {\n    ElectionID  uint64 `json:\"election_id\"`\n    CandidateID NodeID `json:\"candidate_id\"`\n    Term        uint64 `json:\"term\"`\n}\n\n// OKMessage represents bully algorithm acknowledgment\ntype OKMessage struct {\n    ElectionID  uint64 `json:\"election_id\"`\n    ResponderID NodeID `json:\"responder_id\"`\n}\n\n// CoordinatorMessage announces the new leader\ntype CoordinatorMessage struct {\n    LeaderID   NodeID `json:\"leader_id\"`\n    Term       uint64 `json:\"term\"`\n    ElectionID uint64 `json:\"election_id\"`\n}\n\n// HeartbeatMessage provides leader liveness indication\ntype HeartbeatMessage struct {\n    LeaderID  NodeID `json:\"leader_id\"`\n    Term      uint64 `json:\"term\"`\n    Timestamp int64  `json:\"timestamp\"`\n}\n\n// RingToken represents ring election token\ntype RingToken struct {\n    ElectionID   uint64   `json:\"election_id\"`\n    InitiatorID  NodeID   `json:\"initiator_id\"`\n    Participants []NodeID `json:\"participants\"`\n    Complete     bool     `json:\"complete\"`\n}\n\n// MessageBuilder helps construct typed messages\ntype MessageBuilder struct {\n    fromNodeID NodeID\n}\n\n// NewMessageBuilder creates a message builder for a node\nfunc NewMessageBuilder(nodeID NodeID) *MessageBuilder {\n    return &MessageBuilder{fromNodeID: nodeID}\n}\n\n// BuildElectionMessage creates an election message\nfunc (mb *MessageBuilder) BuildElectionMessage(to NodeID, electionID uint64, term uint64) (*Message, error) {\n    payload := ElectionMessage{\n        ElectionID:  electionID,\n        CandidateID: mb.fromNodeID,\n        Term:        term,\n    }\n    \n    data, err := json.Marshal(payload)\n    if err != nil {\n        return nil, err\n    }\n    \n    return &Message{\n        Type:    MsgElection,\n        From:    mb.fromNodeID,\n        To:      to,\n        Payload: data,\n    }, nil\n}\n\n// BuildCoordinatorMessage creates a coordinator announcement\nfunc (mb *MessageBuilder) BuildCoordinatorMessage(leaderID NodeID, term uint64, electionID uint64) (*Message, error) {\n    payload := CoordinatorMessage{\n        LeaderID:   leaderID,\n        Term:       term,\n        ElectionID: electionID,\n    }\n    \n    data, err := json.Marshal(payload)\n    if err != nil {\n        return nil, err\n    }\n    \n    return &Message{\n        Type:    MsgCoordinator,\n        From:    mb.fromNodeID,\n        To:      0, // Broadcast\n        Payload: data,\n    }, nil\n}\n\n// BuildHeartbeatMessage creates a heartbeat message\nfunc (mb *MessageBuilder) BuildHeartbeatMessage(term uint64) (*Message, error) {\n    payload := HeartbeatMessage{\n        LeaderID:  mb.fromNodeID,\n        Term:      term,\n        Timestamp: time.Now().Unix(),\n    }\n    \n    data, err := json.Marshal(payload)\n    if err != nil {\n        return nil, err\n    }\n    \n    return &Message{\n        Type:    MsgHeartbeat,\n        From:    mb.fromNodeID,\n        To:      0, // Broadcast\n        Payload: data,\n    }, nil\n}\n```\n\n**E. Transport Interface Definition**\n\n```go\n// internal/transport/transport.go\npackage transport\n\nimport (\n    \"context\"\n    \"leader-election/internal/types\"\n)\n\n// Transport defines the interface for inter-node communication\ntype Transport interface {\n    // SendMessage sends a message to a specific node\n    SendMessage(target types.NodeID, msg *types.Message) error\n    \n    // BroadcastMessage sends a message to all known nodes\n    BroadcastMessage(msg *types.Message) error\n    \n    // ReceiveMessages returns a channel of incoming messages\n    ReceiveMessages() <-chan *types.Message\n    \n    // UpdateMembership updates the transport's view of cluster members\n    UpdateMembership(nodes []types.Node) error\n    \n    // Start begins listening for messages\n    Start(ctx context.Context) error\n    \n    // Stop gracefully shuts down the transport\n    Stop() error\n}\n```\n\n**F. Election Coordinator Interface**\n\n```go\n// internal/election/coordinator.go\npackage election\n\nimport (\n    \"leader-election/internal/types\"\n)\n\n// ElectionCoordinator manages leader election algorithms\ntype ElectionCoordinator interface {\n    // StartElection initiates a new leader election\n    StartElection() error\n    \n    // HandleMessage processes incoming election messages\n    HandleMessage(msg *types.Message) error\n    \n    // GetCurrentLeader returns the current leader ID\n    GetCurrentLeader() types.NodeID\n    \n    // IsLeader checks if this node is the current leader\n    IsLeader() bool\n    \n    // SetMembership updates the known cluster membership\n    SetMembership(members []types.Node) error\n}\n```\n\n**G. Configuration Structure**\n\n```go\n// pkg/config/config.go\npackage config\n\nimport (\n    \"encoding/json\"\n    \"os\"\n    \"time\"\n    \"leader-election/internal/types\"\n)\n\n// Config holds all configuration for a leader election node\ntype Config struct {\n    // Node configuration\n    NodeID      types.NodeID `json:\"node_id\"`\n    ListenAddr  string       `json:\"listen_addr\"`\n    \n    // Cluster configuration  \n    InitialPeers []string `json:\"initial_peers\"`\n    \n    // Election algorithm selection\n    Algorithm string `json:\"algorithm\"` // \"bully\" or \"ring\"\n    \n    // Timing configuration\n    HeartbeatInterval time.Duration `json:\"heartbeat_interval\"`\n    ElectionTimeout   time.Duration `json:\"election_timeout\"`\n    FailureTimeout    time.Duration `json:\"failure_timeout\"`\n    \n    // Advanced settings\n    MaxSuspicionLevel int `json:\"max_suspicion_level\"`\n}\n\n// LoadConfig reads configuration from a JSON file\nfunc LoadConfig(filename string) (*Config, error) {\n    data, err := os.ReadFile(filename)\n    if err != nil {\n        return nil, err\n    }\n    \n    var config Config\n    err = json.Unmarshal(data, &config)\n    return &config, err\n}\n\n// DefaultConfig returns sensible default configuration\nfunc DefaultConfig() *Config {\n    return &Config{\n        Algorithm:         \"bully\",\n        HeartbeatInterval: 1 * time.Second,\n        ElectionTimeout:   5 * time.Second,\n        FailureTimeout:    3 * time.Second,\n        MaxSuspicionLevel: 3,\n    }\n}\n```\n\n**H. Milestone Checkpoint: Data Structures Validation**\n\nAfter implementing these data structures, validate them with this simple test:\n\n```bash\n# Run the data structure tests\ngo test ./internal/types/...\n\n# Create a simple main function to test message creation:\ngo run cmd/test-messages/main.go\n```\n\nExpected behavior:\n1. All message types should serialize/deserialize correctly to/from JSON\n2. Node state transitions should be validated\n3. Membership updates should trigger appropriate callbacks\n4. Message builder should create well-formed messages\n\n**I. Common Implementation Mistakes**\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---------|-------------|-----------|-----|\n| JSON marshal errors | Missing struct tags | Check error messages for field names | Add `json:\"field_name\"` tags to all exported fields |\n| Race conditions | Missing mutex protection | Use `go run -race` to detect races | Add proper mutex protection around shared maps |\n| Memory leaks | Maps never cleaned up | Monitor memory usage over time | Implement cleanup for old membership entries |\n| Message routing failures | Incorrect NodeID comparison | Log message routing decisions | Ensure NodeID 0 is reserved for broadcasts |\n\n**J. Language-Specific Tips for Go**\n\n- Use `sync.RWMutex` for membership maps - many readers, few writers\n- Implement `String()` methods for all custom types for better debugging\n- Use `encoding/json` struct tags to control serialization field names\n- Consider using `context.Context` for cancellable operations\n- Use typed constants with `iota` for enumerations\n- Implement proper error handling with wrapped errors using `fmt.Errorf`\n\nThis implementation foundation provides all the basic data structures needed for the next milestones while following Go idioms and best practices. The code is production-ready for the infrastructure components (serialization, configuration, interfaces) while providing clear TODO markers for the core election logic that learners should implement themselves.\n\n\n## Node Communication Layer\n\n> **Milestone(s):** Milestone 1 (Node Communication) - establishing the foundational messaging infrastructure that enables all leader election algorithms\n\n### Mental Model: Postal Service with Tracking\n\nThink of the node communication layer as a sophisticated postal service that connects all offices (nodes) in a large corporation. Just like the postal service, our system needs to solve several fundamental challenges:\n\n**Address Discovery**: Before you can send mail, you need to know which offices exist and where they're located. Our nodes face the same challenge - they must discover their peers and maintain an up-to-date directory of active participants. This is like maintaining a corporate phone book that automatically updates when new branches open or existing ones close.\n\n**Reliable Delivery**: When you send an important document via certified mail, you expect confirmation that it arrived. Our messaging system provides similar guarantees - when Node A sends an election message to Node B, it needs to know whether the message was delivered or if Node B is unreachable. Unlike simple email, our system can't afford to lose critical election messages.\n\n**Failure Detection**: The postal service tracks which addresses are invalid or unreachable. Similarly, our system must detect when nodes become unavailable due to crashes, network issues, or maintenance. This detection triggers the leader election process - just as a company would need to elect a new department head if the current one becomes unavailable.\n\n**Broadcast Announcements**: Sometimes you need to send the same memo to every office simultaneously. In leader election, the winning candidate must announce their victory to all participants. Our broadcast mechanism ensures every active node receives coordinator announcements, preventing confusion about who's currently in charge.\n\nThe key insight is that reliable communication forms the foundation for all election algorithms. Without trustworthy message delivery and accurate failure detection, election algorithms would make incorrect decisions based on incomplete information.\n\n### Node Discovery and Membership\n\nNode discovery and membership management solve the fundamental question: \"Who else is in this cluster, and how do I reach them?\" This component maintains the cluster's membership view and handles the dynamic nature of distributed systems where nodes join, leave, and fail unpredictably.\n\n**Cluster Membership Representation**\n\nThe cluster membership component tracks all known nodes and their current status. Each node maintains a local view of cluster membership that gets updated through discovery mechanisms and runtime observations.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `nodes` | `map[NodeID]Node` | Complete registry of all known cluster members indexed by unique node ID |\n| `activeMembers` | `[]NodeID` | List of currently responsive nodes that can participate in elections |\n| `lastSeen` | `map[NodeID]int64` | Timestamp of last successful communication with each node (Unix milliseconds) |\n| `suspicionLevels` | `map[NodeID]int` | Failure detection suspicion counter - higher values indicate likely node failure |\n| `joinTimestamps` | `map[NodeID]int64` | When each node first joined the cluster (for tie-breaking and priority) |\n\nThe membership manager provides essential operations for maintaining cluster awareness:\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `UpdateMembership` | `nodes []Node` | `error` | Bulk update of known cluster members from configuration or discovery |\n| `GetActiveMembers` | none | `[]Node` | Returns list of nodes currently considered alive and reachable |\n| `AddNode` | `node Node` | `error` | Registers a new node that joined the cluster dynamically |\n| `RemoveNode` | `nodeID NodeID` | `error` | Permanently removes a node from cluster membership |\n| `MarkNodeSeen` | `nodeID NodeID` | none | Updates last-seen timestamp when receiving any message from the node |\n| `IncreaseSuspicion` | `nodeID NodeID` | `int` | Increments suspicion level when communication fails, returns new level |\n| `ResetSuspicion` | `nodeID NodeID` | none | Clears suspicion level when node responds successfully |\n\n> **Decision: Static vs Dynamic Discovery**\n> - **Context**: Clusters can use static configuration files listing all members, or dynamic discovery through multicast/broadcast announcements\n> - **Options Considered**: \n>   1. Static configuration only (simple, deterministic)\n>   2. Dynamic multicast discovery (flexible, auto-joining)\n>   3. Hybrid approach supporting both methods\n> - **Decision**: Hybrid approach with static configuration as primary and optional multicast discovery\n> - **Rationale**: Static configuration provides deterministic membership for production environments while multicast enables easier development and testing. This covers both use cases without forcing a single approach.\n> - **Consequences**: Requires implementing both discovery mechanisms but provides maximum deployment flexibility\n\n**Static Configuration Discovery**\n\nStatic discovery reads cluster membership from configuration files or environment variables. This approach provides deterministic membership that doesn't change during runtime, making it suitable for production deployments with known infrastructure.\n\nThe static configuration specifies each node's ID, network address, and optional metadata:\n\n```\nNode ID: 1001, Address: 192.168.1.10:8080\nNode ID: 1002, Address: 192.168.1.11:8080  \nNode ID: 1003, Address: 192.168.1.12:8080\n```\n\nStatic discovery follows this initialization sequence:\n1. The node reads its configuration file containing all cluster members\n2. It validates that its own node ID appears in the member list\n3. It attempts to establish connections with all configured peers\n4. It marks peers as active or suspected based on initial connectivity tests\n5. It begins heartbeat monitoring for ongoing failure detection\n\n**Dynamic Multicast Discovery**\n\nDynamic discovery uses UDP multicast to announce node presence and discover peers automatically. This approach enables nodes to join clusters without prior configuration, making it ideal for development environments and auto-scaling deployments.\n\nThe multicast discovery protocol works as follows:\n1. New nodes broadcast JOIN_ANNOUNCEMENT messages to a well-known multicast group\n2. Existing cluster members respond with MEMBERSHIP_UPDATE messages containing current member lists  \n3. The new node validates responses and builds its initial membership view\n4. All nodes periodically broadcast HEARTBEAT_ANNOUNCE messages to maintain discovery\n5. Nodes that stop receiving announcements from a peer mark it as suspected\n\n| Message Type | Multicast Group | Port | Content |\n|--------------|-----------------|------|---------|\n| `JOIN_ANNOUNCEMENT` | 224.0.1.200 | 7946 | Node ID, listening address, cluster name |\n| `MEMBERSHIP_UPDATE` | 224.0.1.200 | 7946 | Full member list with addresses and last-seen times |\n| `HEARTBEAT_ANNOUNCE` | 224.0.1.200 | 7946 | Node ID, current term, leader ID (if known) |\n\n**Membership Consistency and Split Views**\n\nDifferent nodes may temporarily hold inconsistent views of cluster membership due to network delays, partitions, or node failures. The system handles membership inconsistencies through several mechanisms:\n\n*Membership Reconciliation*: When nodes exchange messages during elections, they include their current membership views. Receiving nodes merge this information with their local state, adding newly discovered members and updating last-seen timestamps for known members.\n\n*Partition Detection*: Nodes detect potential network partitions by comparing their active member count with the expected cluster size. If a node can only reach a small subset of configured members, it assumes it's in the minority partition and avoids starting elections that could create split-brain scenarios.\n\n*Member Prioritization*: When membership views conflict, nodes prioritize information from recently active members over stale entries. Members that have communicated within the failure detection timeout carry higher authority for membership updates.\n\n### Reliable Message Passing\n\nMessage passing provides the communication foundation that election algorithms depend on. The system must deliver messages reliably between specific nodes (point-to-point) and to all active cluster members (broadcast) while handling network failures gracefully.\n\n**Transport Abstraction Layer**\n\nThe transport layer abstracts network communication details behind a common interface, allowing different implementations (HTTP, UDP, TCP) while providing consistent semantics to election algorithms.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `SendMessage` | `target NodeID, msg *Message` | `error` | Delivers message to specific node with delivery confirmation |\n| `BroadcastMessage` | `msg *Message` | `error` | Sends message to all currently active cluster members |\n| `ReceiveMessages` | none | `<-chan *Message` | Returns channel for incoming messages from all sources |\n| `RegisterHandler` | `msgType MessageType, handler func(*Message)` | none | Registers callback function for specific message types |\n| `GetReachableNodes` | none | `[]NodeID` | Returns list of nodes currently reachable via transport |\n| `Close` | none | `error` | Cleanly shuts down transport and releases network resources |\n\n**Message Structure and Serialization**\n\nAll inter-node communication uses a standardized message format that includes routing information, message type classification, and payload data. The message structure supports both election-specific protocols and general cluster coordination.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `Type` | `MessageType` | Enum identifying message category (election, heartbeat, coordinator, etc.) |\n| `From` | `NodeID` | Source node ID for routing responses and tracking message origin |\n| `To` | `NodeID` | Destination node ID for point-to-point messages (0 for broadcasts) |\n| `Term` | `uint64` | Election term number for ordering and detecting stale messages |\n| `Timestamp` | `int64` | Unix milliseconds when message was created (for timeout detection) |\n| `Payload` | `[]byte` | Serialized message-type-specific data (election details, heartbeat info, etc.) |\n\n> **Decision: Message Serialization Format**\n> - **Context**: Messages need serialization for network transmission with requirements for performance, debuggability, and cross-language compatibility\n> - **Options Considered**:\n>   1. JSON (human readable, widely supported, verbose)\n>   2. Protocol Buffers (compact, fast, requires schema)\n>   3. MessagePack (compact, schema-free, less tooling)\n> - **Decision**: JSON for simplicity with option to upgrade to Protocol Buffers later\n> - **Rationale**: JSON provides excellent debugging capability and eliminates schema management complexity. Performance overhead is acceptable for election message volumes.\n> - **Consequences**: Larger message sizes and slower serialization, but significantly easier development and debugging experience\n\n**Point-to-Point Message Delivery**\n\nPoint-to-point messaging delivers messages from one specific node to another with delivery confirmation. This is essential for bully algorithm ELECTION and OK messages where the sender needs to know whether the target node responded.\n\nThe point-to-point delivery process follows these steps:\n1. The sender serializes the message and establishes a connection to the target node\n2. It transmits the message with a unique sequence number for tracking\n3. The receiver deserializes the message and sends an acknowledgment response\n4. The sender waits for acknowledgment within a configurable timeout period\n5. If no acknowledgment arrives, the sender retries up to a maximum retry count\n6. After exhausting retries, the sender reports the target node as unreachable\n\n**Broadcast Message Delivery**\n\nBroadcast messaging delivers the same message to all currently active cluster members simultaneously. This is crucial for coordinator announcements where the newly elected leader must notify all participants of the election outcome.\n\nThe broadcast implementation provides different delivery semantics based on requirements:\n\n*Best-Effort Broadcast*: Sends messages to all known active members but doesn't wait for confirmations. Failed deliveries are logged but don't block the broadcast operation. This is suitable for periodic heartbeats and non-critical announcements.\n\n*Reliable Broadcast*: Attempts delivery to all active members and tracks individual acknowledgments. The broadcast succeeds only when a configurable percentage of members acknowledge receipt. This ensures critical messages like coordinator announcements reach most of the cluster.\n\n| Broadcast Type | Acknowledgment Required | Failure Behavior | Use Case |\n|----------------|------------------------|------------------|----------|\n| Best-Effort | No | Log and continue | Heartbeats, periodic updates |\n| Reliable | Yes (configurable %) | Retry failed deliveries | Election results, leadership changes |\n| Atomic | Yes (all members) | Abort on any failure | Critical coordination messages |\n\n**Message Ordering and Duplicate Detection**\n\nDistributed systems can deliver messages out of order or deliver the same message multiple times due to network retransmissions. The communication layer handles these challenges through sequence numbering and deduplication.\n\nEach node maintains sequence counters for outgoing messages and tracks received message IDs to detect duplicates. Messages include both sender-specific sequence numbers and globally unique identifiers for comprehensive duplicate detection.\n\n**Network Failure Handling**\n\nThe transport layer detects and handles various network failure scenarios that commonly occur in distributed systems:\n\n*Connection Timeouts*: When establishing connections to remote nodes takes longer than expected, the transport layer retries with exponential backoff and eventually marks the target as unreachable.\n\n*Transmission Failures*: If message transmission fails due to closed connections or network errors, the system attempts to re-establish the connection and retransmit the message.\n\n*Partial Network Partitions*: When a node can reach some cluster members but not others, it updates its reachable node list and informs the membership manager about suspected failures.\n\n### Failure Detection and Heartbeats\n\nFailure detection determines which cluster nodes are currently alive and participating versus those that have crashed, become unreachable, or are experiencing network connectivity issues. Accurate failure detection is crucial because false positives trigger unnecessary elections while false negatives delay necessary leadership transitions.\n\n**Heartbeat-Based Monitoring**\n\nThe failure detection system uses periodic heartbeat messages to monitor node availability. Each node sends heartbeat messages at regular intervals and expects to receive heartbeats from all other cluster members. Missing heartbeats indicate potential node failures.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `LeaderID` | `NodeID` | ID of the node currently believed to be the cluster leader |\n| `Term` | `uint64` | Current election term number known by the heartbeat sender |\n| `Timestamp` | `int64` | Unix milliseconds when heartbeat was generated |\n| `ActiveMembers` | `[]NodeID` | List of nodes the sender considers currently alive |\n| `SenderLoad` | `float64` | CPU/memory utilization for load-based leader selection (optional) |\n\nThe heartbeat monitoring process works as follows:\n1. Each node broadcasts heartbeat messages every N seconds (configurable interval)\n2. Receiving nodes update their last-seen timestamps for the heartbeat sender\n3. Nodes monitor for missing heartbeats from each known cluster member\n4. If no heartbeat arrives within the failure detection timeout, suspicion levels increase\n5. Nodes with high suspicion levels are considered failed and removed from active membership\n\n> **Decision: Push vs Pull Heartbeat Model**\n> - **Context**: Failure detection can use push (nodes broadcast \"I'm alive\") or pull (nodes query \"are you alive?\") approaches\n> - **Options Considered**:\n>   1. Push-only (periodic broadcasts, low overhead)\n>   2. Pull-only (explicit health checks, accurate but chatty)\n>   3. Hybrid push-pull (broadcasts plus targeted queries)\n> - **Decision**: Push-only with configurable intervals\n> - **Rationale**: Push model provides good failure detection accuracy with minimal network overhead. Pull mechanisms add complexity and increase message volume significantly.\n> - **Consequences**: May have slightly slower failure detection than pull models, but much better network efficiency and simpler implementation\n\n**Suspicion-Based Failure Detection**\n\nRather than immediately declaring nodes failed after missing a single heartbeat, the system uses graduated suspicion levels that account for temporary network glitches and varying network latency.\n\nThe suspicion mechanism works through several stages:\n\n| Suspicion Level | Missed Heartbeats | Node Status | Actions Taken |\n|-----------------|-------------------|-------------|---------------|\n| 0 (Healthy) | 0 | Active | Include in elections, accept messages normally |\n| 1 (Monitoring) | 1-2 | Active | Continue normal operations, increase monitoring |\n| 2 (Suspected) | 3-4 | Questionable | Exclude from new elections, accept existing messages |\n| 3 (Failed) | 5+ | Inactive | Remove from active membership, ignore messages |\n\n*Suspicion Escalation*: Each missed heartbeat increments the suspicion level for that node. The system only declares nodes failed after multiple consecutive missed heartbeats, reducing false positives from temporary network issues.\n\n*Suspicion Recovery*: When a suspected node sends any valid message (heartbeat, election message, etc.), its suspicion level resets to zero immediately. This allows nodes to quickly recover from temporary network partitions or performance issues.\n\n**Adaptive Timeout Configuration**\n\nNetwork conditions vary significantly between deployment environments (local datacenter vs wide-area network vs cloud environments). The failure detection system adapts its timeout parameters based on observed network characteristics.\n\n| Configuration Parameter | Local Network | Wide Area Network | Cloud Environment |\n|------------------------|---------------|-------------------|-------------------|\n| Heartbeat Interval | 1 second | 3 seconds | 2 seconds |\n| Failure Detection Timeout | 5 seconds | 15 seconds | 10 seconds |\n| Maximum Suspicion Level | 3 | 5 | 4 |\n| Network Partition Threshold | 30 seconds | 60 seconds | 45 seconds |\n\nThe system monitors round-trip message times and adjusts timeout parameters automatically:\n1. It tracks the 95th percentile of heartbeat round-trip times over rolling windows\n2. It sets failure detection timeouts to 3-5x the observed round-trip times\n3. It increases timeouts during periods of high network variability\n4. It gradually decreases timeouts when network conditions stabilize\n\n**Network Partition Detection**\n\nNetwork partitions split the cluster into isolated groups where nodes within each partition can communicate with each other but not with nodes in other partitions. Partition detection prevents split-brain scenarios where multiple partitions elect separate leaders simultaneously.\n\nThe partition detection algorithm considers several factors:\n\n*Reachability Analysis*: Nodes track which cluster members they can successfully communicate with. If a node can only reach a small fraction of the configured cluster size, it suspects it's in a minority partition.\n\n*Quorum Requirements*: Elections require a minimum number of participating nodes (quorum) to produce valid results. Nodes that cannot reach a quorum of cluster members refuse to start or participate in elections.\n\n*Partition Recovery*: When network connectivity returns, nodes from different partitions must reconcile their state. The system uses election term numbers to determine which partition had legitimate leadership and updates all nodes accordingly.\n\n**Leader-Specific Failure Detection**\n\nThe current cluster leader requires special monitoring because leader failures trigger immediate re-election. The system uses enhanced failure detection for leaders with shorter timeout periods and more frequent health checks.\n\nLeader monitoring includes several specialized mechanisms:\n1. **Accelerated Heartbeats**: Leaders send heartbeats twice as frequently as regular nodes\n2. **Explicit Health Queries**: Followers can send direct health check messages to leaders\n3. **Reduced Failure Threshold**: Leaders are considered failed after fewer missed heartbeats\n4. **Split-Brain Prevention**: Multiple nodes claiming leadership are detected and resolved\n\nWhen leader failure is detected, any cluster member can initiate a new election. The failure detection system includes backoff mechanisms to prevent multiple nodes from starting concurrent elections simultaneously.\n\n**Common Pitfalls**\n\n⚠️ **Pitfall: Heartbeat Storms During Network Issues**\nWhen network connectivity is degraded, nodes may flood the network with heartbeat retries and failure detection messages. This can worsen network congestion and create cascading failures. The system prevents this by implementing exponential backoff for heartbeat intervals and rate-limiting failure detection messages during suspected network issues.\n\n⚠️ **Pitfall: False Positives from GC Pauses**\nLanguage runtime garbage collection can pause nodes for several seconds, causing them to miss heartbeat deadlines and be falsely declared failed. The system accounts for this by using longer timeout periods than typical GC pause times and allowing suspected nodes to quickly recover when they resume sending heartbeats.\n\n⚠️ **Pitfall: Symmetric Network Failures**\nTwo nodes may lose connectivity to each other while remaining connected to the rest of the cluster. Each node may suspect the other is failed, leading to inconsistent membership views. The system handles this by prioritizing membership information from nodes that can communicate with the majority of cluster members.\n\n### Implementation Guidance\n\nThe node communication layer forms the foundation for all leader election algorithms. This section provides complete implementation guidance for building reliable messaging, membership management, and failure detection systems.\n\n**Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Transport Protocol | HTTP/1.1 with JSON over TCP | gRPC with Protocol Buffers |\n| Service Discovery | Static configuration files | etcd or Consul integration |\n| Serialization | Standard library JSON | MessagePack or Protocol Buffers |\n| Network Library | Built-in net/http package | Custom UDP with reliability layer |\n| Logging | Standard log package | Structured logging (logrus, zap) |\n| Configuration | JSON/YAML files | Environment variables + config management |\n\n**Recommended File Structure**\n\n```\ninternal/communication/\n  transport.go              ← Transport interface and HTTP implementation\n  transport_test.go         ← Transport layer tests\n  membership.go             ← Cluster membership management\n  membership_test.go        ← Membership tests\n  discovery.go              ← Static and multicast node discovery\n  discovery_test.go         ← Discovery mechanism tests\n  failure_detector.go       ← Heartbeat and failure detection\n  failure_detector_test.go  ← Failure detection tests\n  message_builder.go        ← Message construction utilities\n  types.go                  ← All message types and constants\n```\n\n**Core Transport Infrastructure (Complete Implementation)**\n\n```go\npackage communication\n\nimport (\n    \"bytes\"\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n    \"sync\"\n    \"time\"\n)\n\n// HTTPTransport implements the Transport interface using HTTP/1.1\ntype HTTPTransport struct {\n    nodeID       NodeID\n    listenAddr   string\n    server       *http.Server\n    client       *http.Client\n    membership   *ClusterMembership\n    msgChan      chan *Message\n    handlers     map[MessageType]func(*Message)\n    handlerMu    sync.RWMutex\n    shutdown     chan struct{}\n}\n\nfunc NewHTTPTransport(nodeID NodeID, listenAddr string, membership *ClusterMembership) *HTTPTransport {\n    return &HTTPTransport{\n        nodeID:     nodeID,\n        listenAddr: listenAddr,\n        client: &http.Client{\n            Timeout: 5 * time.Second,\n        },\n        membership: membership,\n        msgChan:    make(chan *Message, 100),\n        handlers:   make(map[MessageType]func(*Message)),\n        shutdown:   make(chan struct{}),\n    }\n}\n\nfunc (t *HTTPTransport) Start() error {\n    mux := http.NewServeMux()\n    mux.HandleFunc(\"/message\", t.handleIncomingMessage)\n    \n    t.server = &http.Server{\n        Addr:    t.listenAddr,\n        Handler: mux,\n    }\n    \n    go func() {\n        if err := t.server.ListenAndServe(); err != http.ErrServerClosed {\n            // Log error - server failed to start\n        }\n    }()\n    \n    return nil\n}\n\nfunc (t *HTTPTransport) handleIncomingMessage(w http.ResponseWriter, r *http.Request) {\n    if r.Method != \"POST\" {\n        http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n        return\n    }\n    \n    var msg Message\n    if err := json.NewDecoder(r.Body).Decode(&msg); err != nil {\n        http.Error(w, \"Invalid message format\", http.StatusBadRequest)\n        return\n    }\n    \n    // Update membership - mark sender as seen\n    t.membership.MarkNodeSeen(msg.From)\n    \n    // Route to handler if registered, otherwise send to channel\n    t.handlerMu.RLock()\n    if handler, exists := t.handlers[msg.Type]; exists {\n        t.handlerMu.RUnlock()\n        go handler(&msg)\n    } else {\n        t.handlerMu.RUnlock()\n        select {\n        case t.msgChan <- &msg:\n        case <-t.shutdown:\n            return\n        default:\n            // Channel full - drop message or handle overflow\n        }\n    }\n    \n    w.WriteHeader(http.StatusOK)\n}\n```\n\n**Cluster Membership Management (Complete Implementation)**\n\n```go\ntype ClusterMembership struct {\n    mu              sync.RWMutex\n    nodes           map[NodeID]Node\n    activeMembers   []NodeID\n    lastSeen        map[NodeID]int64\n    suspicionLevels map[NodeID]int\n    joinTimestamps  map[NodeID]int64\n    \n    // Configuration\n    failureTimeout  time.Duration\n    maxSuspicion    int\n}\n\nfunc NewClusterMembership(failureTimeout time.Duration, maxSuspicion int) *ClusterMembership {\n    return &ClusterMembership{\n        nodes:           make(map[NodeID]Node),\n        activeMembers:   make([]NodeID, 0),\n        lastSeen:        make(map[NodeID]int64),\n        suspicionLevels: make(map[NodeID]int),\n        joinTimestamps:  make(map[NodeID]int64),\n        failureTimeout:  failureTimeout,\n        maxSuspicion:    maxSuspicion,\n    }\n}\n\nfunc (cm *ClusterMembership) UpdateMembership(nodes []Node) error {\n    cm.mu.Lock()\n    defer cm.mu.Unlock()\n    \n    now := time.Now().UnixMilli()\n    \n    for _, node := range nodes {\n        if _, exists := cm.nodes[node.ID]; !exists {\n            // New node discovered\n            cm.nodes[node.ID] = node\n            cm.lastSeen[node.ID] = now\n            cm.suspicionLevels[node.ID] = 0\n            cm.joinTimestamps[node.ID] = now\n        } else {\n            // Update existing node info\n            cm.nodes[node.ID] = node\n        }\n    }\n    \n    cm.updateActiveMembers()\n    return nil\n}\n\nfunc (cm *ClusterMembership) updateActiveMembers() {\n    // Must be called with lock held\n    now := time.Now().UnixMilli()\n    timeoutMs := cm.failureTimeout.Milliseconds()\n    \n    cm.activeMembers = cm.activeMembers[:0] // Clear slice but keep capacity\n    \n    for nodeID, lastSeenTime := range cm.lastSeen {\n        timeSinceLastSeen := now - lastSeenTime\n        suspicion := cm.suspicionLevels[nodeID]\n        \n        // Node is active if recently seen and suspicion is low\n        if timeSinceLastSeen < timeoutMs && suspicion < cm.maxSuspicion {\n            cm.activeMembers = append(cm.activeMembers, nodeID)\n        }\n    }\n}\n```\n\n**Core Logic Skeletons for Implementation**\n\n```go\n// SendMessage delivers a message to a specific target node with retry logic\nfunc (t *HTTPTransport) SendMessage(target NodeID, msg *Message) error {\n    // TODO 1: Look up target node address from membership\n    // TODO 2: Set message routing fields (From, To, Timestamp)\n    // TODO 3: Serialize message to JSON\n    // TODO 4: Create HTTP POST request to target's /message endpoint\n    // TODO 5: Send request with timeout and retry on failure\n    // TODO 6: Handle response - update membership on success/failure\n    // TODO 7: Return delivery confirmation or error\n    return nil\n}\n\n// BroadcastMessage sends a message to all currently active cluster members\nfunc (t *HTTPTransport) BroadcastMessage(msg *Message) error {\n    // TODO 1: Get current active member list from membership manager\n    // TODO 2: Set broadcast routing fields (From=self, To=0 for broadcast)\n    // TODO 3: Send message to each active member in parallel\n    // TODO 4: Collect results and count successful deliveries\n    // TODO 5: Update membership status based on delivery results\n    // TODO 6: Return success if minimum delivery threshold met\n    return nil\n}\n\n// MarkNodeSeen updates the last-seen timestamp for a node\nfunc (cm *ClusterMembership) MarkNodeSeen(nodeID NodeID) {\n    // TODO 1: Acquire write lock\n    // TODO 2: Update lastSeen timestamp to current time\n    // TODO 3: Reset suspicion level to 0 (node responded)\n    // TODO 4: Refresh active members list\n    // TODO 5: Release lock\n}\n\n// IncreaseSuspicion increments suspicion level when communication fails\nfunc (cm *ClusterMembership) IncreaseSuspicion(nodeID NodeID) int {\n    // TODO 1: Acquire write lock\n    // TODO 2: Increment suspicion level (max at configured threshold)\n    // TODO 3: Update active members list (may remove node)\n    // TODO 4: Return new suspicion level\n    // TODO 5: Release lock\n    return 0\n}\n```\n\n**Failure Detector Implementation Skeleton**\n\n```go\ntype FailureDetector struct {\n    transport    Transport\n    membership   *ClusterMembership\n    heartbeatInterval time.Duration\n    nodeID       NodeID\n    currentTerm  uint64\n    leaderID     NodeID\n    stopChan     chan struct{}\n}\n\n// StartHeartbeats begins sending periodic heartbeat messages\nfunc (fd *FailureDetector) StartHeartbeats() {\n    // TODO 1: Create ticker for heartbeat interval\n    // TODO 2: In loop, create heartbeat message with current term and leader\n    // TODO 3: Broadcast heartbeat to all active members\n    // TODO 4: Update membership suspicion levels for failed deliveries\n    // TODO 5: Handle stop signal to exit cleanly\n}\n\n// CheckForFailures examines membership for failed nodes\nfunc (fd *FailureDetector) CheckForFailures() []NodeID {\n    // TODO 1: Get current active members from membership\n    // TODO 2: Compare with expected cluster size\n    // TODO 3: Identify nodes that exceeded failure timeout\n    // TODO 4: Check if current leader has failed\n    // TODO 5: Return list of newly failed node IDs\n    return nil\n}\n```\n\n**Language-Specific Implementation Hints**\n\n- Use `sync.RWMutex` for membership data structures that have frequent reads but infrequent writes\n- Use `time.NewTicker()` for periodic heartbeat sending with proper cleanup via `ticker.Stop()`\n- Use `context.WithTimeout()` for HTTP requests to implement configurable timeouts\n- Use `sync.WaitGroup` for coordinating parallel broadcast message sending\n- Use buffered channels for message passing to prevent blocking senders\n- Use `atomic.LoadUint64()` and `atomic.StoreUint64()` for term numbers accessed from multiple goroutines\n\n**Milestone Checkpoint**\n\nAfter implementing the node communication layer, verify the following behavior:\n\n1. **Static Discovery Test**: Start 3 nodes with static configuration pointing to each other. All nodes should discover each other within 5 seconds and report correct active membership counts.\n\n2. **Message Delivery Test**: Send point-to-point messages between nodes. Verify messages arrive with correct routing information and senders receive delivery confirmations.\n\n3. **Broadcast Test**: Have one node broadcast a message to all members. Verify all active nodes receive the broadcast message within reasonable time bounds.\n\n4. **Failure Detection Test**: Stop one node abruptly. Verify other nodes detect the failure within the configured timeout period and update their active member lists.\n\n5. **Network Partition Simulation**: Use firewall rules or network namespaces to isolate nodes. Verify partition detection works and nodes update membership appropriately.\n\nExpected test output:\n```\n=== RUN   TestStaticDiscovery\nNode 1001: Discovered 3 total members, 3 active\nNode 1002: Discovered 3 total members, 3 active  \nNode 1003: Discovered 3 total members, 3 active\n--- PASS: TestStaticDiscovery (5.23s)\n\n=== RUN   TestMessageDelivery  \nSent message from 1001 to 1002: SUCCESS\nSent message from 1002 to 1003: SUCCESS\n--- PASS: TestMessageDelivery (0.15s)\n```\n\n**Debugging Tips**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Nodes don't discover each other | Configuration mismatch | Check node IDs and addresses in config files | Ensure all nodes have consistent member lists |\n| Messages timeout frequently | Network latency higher than timeout | Measure round-trip times between nodes | Increase timeout values in configuration |\n| False failure detection | Heartbeat interval too aggressive | Monitor heartbeat delivery success rates | Increase heartbeat intervals and failure thresholds |\n| Split-brain during partitions | Quorum logic not implemented | Check election behavior during network splits | Implement majority quorum requirements |\n| High CPU usage | Polling loops without delays | Profile CPU usage during normal operation | Add sleep intervals in monitoring loops |\n\n\n## Bully Election Algorithm\n\n> **Milestone(s):** Milestone 2 (Bully Algorithm) - implements the bully election algorithm where the highest-ID node becomes leader through competitive messaging\n\n### Mental Model: Corporate Hierarchy Challenge\n\nThink of the bully algorithm like a workplace scenario where the CEO suddenly leaves and the company needs to select a new leader. In a traditional corporate hierarchy, the person with the highest seniority (analogous to the highest node ID) should become the new CEO. However, there's no HR department to coordinate this - the employees must figure it out themselves through direct communication.\n\nHere's how it would unfold: when someone notices the CEO is gone, they might think \"I should be the new leader!\" But before declaring themselves CEO, they're required by company protocol to first ask everyone more senior than them: \"Hey, are you going to step up and lead?\" If any senior person responds \"Yes, I've got this,\" then the junior person backs down and waits. But if no senior person responds after a reasonable time, the junior person can declare themselves the new CEO and announce it to everyone.\n\nThis captures the essence of the bully algorithm: higher-ranked participants have the right to \"bully\" lower-ranked ones out of leadership contention, but they must actively claim that right. The algorithm isn't called \"bully\" because it's mean-spirited - it's because higher-ID nodes can override lower-ID nodes' leadership attempts, similar to how a senior employee might override a junior employee's decision in a corporate hierarchy.\n\nThe key insight is that this approach ensures the most qualified candidate (highest ID) becomes leader, but only if they're actually available and responsive. If the most senior person is unavailable (crashed or network-partitioned), the next most senior person can step up, and so on down the hierarchy.\n\n![Node Election State Machine](./diagrams/node-state-machine.svg)\n\n### Bully Algorithm Steps\n\nThe bully algorithm operates through a three-phase protocol that ensures the highest-ID responding node becomes leader. Each phase has specific message types and timing requirements that prevent conflicts and guarantee convergence.\n\n![Bully Algorithm Message Flow](./diagrams/bully-sequence.svg)\n\nThe algorithm consists of three distinct phases, each with clear responsibilities and message flows:\n\n**Phase 1: Election Initiation and Higher-ID Query**\n\n1. **Failure Detection Trigger**: A node detects that the current leader has failed through the failure detection mechanism (heartbeat timeouts or message delivery failures). The detecting node transitions from `StateFollower` to `StateCandidate` and initiates an election.\n\n2. **Election ID Generation**: The initiating node generates a unique election ID (typically a combination of its node ID and current timestamp) to distinguish this election from any concurrent elections. This prevents confusion when multiple nodes simultaneously detect the leader failure.\n\n3. **Higher-ID Node Query**: The initiating node identifies all nodes with IDs higher than its own from the current cluster membership. It sends `MsgElection` messages to each of these higher-ID nodes, essentially asking \"Are you available to be leader?\"\n\n4. **Election Timeout Setup**: The initiator starts a timeout timer (typically 2-5 seconds) to wait for responses from higher-ID nodes. If no responses arrive within this timeout, the initiator assumes all higher-ID nodes are unavailable.\n\n**Phase 2: Higher-ID Response and Candidate Withdrawal**\n\n5. **Higher-ID Node Response**: Any higher-ID node that receives an `MsgElection` message immediately responds with an `MsgOK` message to indicate it's alive and will handle the election. The responding node then transitions to `StateCandidate` and starts its own election process.\n\n6. **Initiator Withdrawal**: When the original initiator receives any `MsgOK` response, it immediately withdraws from the election by transitioning back to `StateFollower`. It stops its timeout timer and waits for the eventual coordinator announcement.\n\n7. **Cascading Elections**: Higher-ID nodes that sent `MsgOK` responses now become election initiators themselves. They repeat the process by sending `MsgElection` messages to nodes with IDs higher than their own. This creates a cascade effect that eventually reaches the highest available node.\n\n**Phase 3: Coordinator Selection and Announcement**\n\n8. **Victory Declaration**: The highest-ID node that receives no `MsgOK` responses within the timeout period declares itself the winner. This node transitions to `StateLeader` and prepares to announce its leadership.\n\n9. **Coordinator Broadcast**: The winning node broadcasts a `MsgCoordinator` message to all nodes in the cluster membership, announcing itself as the new leader. This message includes the election ID to help nodes correlate the announcement with the election they witnessed.\n\n10. **Leadership Acceptance**: All nodes receiving the `MsgCoordinator` message transition to `StateFollower` and update their internal leader tracking to point to the announced leader. The new leader begins its leadership duties (heartbeat broadcasting, handling client requests, etc.).\n\nThe algorithm's correctness relies on several key properties: messages are delivered reliably between live nodes, timeouts are sufficient for message round-trips, and the cluster membership view is reasonably consistent. The timeout values must balance responsiveness (detecting failures quickly) with reliability (allowing slower nodes time to respond).\n\n> **Critical Design Insight**: The bully algorithm's safety comes from its sequential nature - only one node can be in the final \"declaring victory\" state at any time, because all lower-ID nodes will have received OK messages from higher-ID nodes and withdrawn. This prevents split-brain scenarios where multiple nodes simultaneously believe they're the leader.\n\nThe message flow creates a natural ordering where election attempts \"bubble up\" to the highest available node, ensuring that exactly one leader emerges even when multiple nodes simultaneously detect the failure and initiate elections.\n\n### Bully Election State Management\n\nThe bully algorithm requires careful state management to handle concurrent elections, message ordering, and node state transitions. Each node maintains both persistent state (survives restarts) and transient election state (reset between elections).\n\n**Node State Transitions**\n\n| Current State | Triggering Event | Next State | Actions Taken |\n|--------------|------------------|------------|---------------|\n| `StateFollower` | Leader failure detected | `StateCandidate` | Generate election ID, send `MsgElection` to higher-ID nodes, start timeout |\n| `StateFollower` | Receive `MsgElection` from lower-ID node | `StateCandidate` | Send `MsgOK` response, start own election process |\n| `StateFollower` | Receive `MsgCoordinator` | `StateFollower` | Update leader tracking, reset election state |\n| `StateCandidate` | Receive `MsgOK` from higher-ID node | `StateFollower` | Cancel timeout, stop election, wait for coordinator announcement |\n| `StateCandidate` | Election timeout expires (no OK received) | `StateLeader` | Broadcast `MsgCoordinator`, start leadership duties |\n| `StateCandidate` | Receive `MsgCoordinator` from winner | `StateFollower` | Update leader tracking, reset election state |\n| `StateLeader` | Receive `MsgCoordinator` with higher term | `StateFollower` | Step down, update leader tracking |\n| `StateLeader` | Own failure detection timeout | `StateCandidate` | Restart election (network partition recovery) |\n\n**Election State Data Structures**\n\nEach node maintains several state components during elections:\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `currentState` | `NodeState` | Current role in the election process |\n| `currentLeader` | `NodeID` | ID of the node currently believed to be leader |\n| `currentTerm` | `uint64` | Monotonically increasing election epoch counter |\n| `activeElectionID` | `uint64` | ID of the election this node is currently participating in |\n| `electionTimeout` | `time.Timer` | Timeout for waiting on higher-ID node responses |\n| `candidateNodes` | `map[NodeID]bool` | Set of higher-ID nodes queried in current election |\n| `receivedOKs` | `map[NodeID]bool` | Track which higher-ID nodes have responded with OK |\n| `lastLeaderHeartbeat` | `time.Time` | Timestamp of last heartbeat from current leader |\n\n**Concurrent Election Handling**\n\nThe bully algorithm naturally handles concurrent elections through its message semantics and state transitions, but several edge cases require careful management:\n\n> **Decision: Election ID Uniqueness Strategy**\n> - **Context**: Multiple nodes might simultaneously detect leader failure and initiate elections, creating potential confusion about which election messages belong to which attempt\n> - **Options Considered**: \n>   1. Single global election counter (requires consensus)\n>   2. Node ID + timestamp combination\n>   3. Random UUIDs for each election\n> - **Decision**: Node ID + timestamp combination (`(nodeID << 32) | timestamp`)\n> - **Rationale**: Provides uniqueness without coordination overhead, includes initiator identity for debugging, and maintains ordering properties for conflict resolution\n> - **Consequences**: Requires reasonably synchronized clocks, but degrades gracefully with clock skew\n\n**Concurrent Election Resolution Rules**:\n\n1. **Multiple Election Initiators**: When a node receives `MsgElection` messages from multiple lower-ID nodes with different election IDs, it responds with `MsgOK` to all of them and starts its own single election attempt.\n\n2. **Election ID Precedence**: If a node is already participating in an election and receives messages for a different election, it compares election IDs. The election with the higher ID (more recent timestamp or higher initiator ID) takes precedence.\n\n3. **Late Election Messages**: If a node receives `MsgElection` after it has already transitioned to `StateLeader`, it responds with the current `MsgCoordinator` message instead of `MsgOK`, immediately informing the late node of the current leader.\n\n4. **Duplicate Prevention**: Nodes track the election ID they're currently participating in and ignore `MsgElection` messages for elections they've already responded to, preventing infinite election loops.\n\n**State Persistence and Recovery**\n\nThe bully election state includes both volatile and persistent components:\n\n| Component | Persistence | Recovery Behavior |\n|-----------|-------------|-------------------|\n| `currentState` | Volatile | Always start as `StateFollower` after restart |\n| `currentLeader` | Persistent | Attempt to contact last known leader on startup |\n| `currentTerm` | Persistent | Increment on first election participation after restart |\n| `activeElectionID` | Volatile | Reset to 0, participate in any ongoing elections |\n| Election timers | Volatile | Restart failure detection from scratch |\n\n**Memory and Resource Management**\n\nElection state management includes resource cleanup to prevent memory leaks during long-running operations:\n\n- **Timeout Cleanup**: All election timeouts are canceled when transitioning out of `StateCandidate`, preventing spurious timeout events\n- **State Reset**: Election-specific state (`candidateNodes`, `receivedOKs`) is cleared when elections complete or are superseded\n- **Term Advancement**: The `currentTerm` is incremented each time a node initiates an election, providing a monotonic ordering for election attempts\n\n### Bully Algorithm Edge Cases\n\nThe bully algorithm's distributed nature creates numerous edge cases that must be handled to ensure correctness and prevent split-brain scenarios. These edge cases often occur due to message loss, network partitions, timing variations, and cascading failures.\n\n**Message Loss and Delivery Failures**\n\n![Election Message Type Relationships](./diagrams/message-types.svg)\n\nMessage loss can occur at any phase of the bully algorithm, each creating different failure modes:\n\n| Lost Message Type | Impact | Detection Method | Recovery Mechanism |\n|-------------------|--------|------------------|-------------------|\n| `MsgElection` to higher-ID node | Higher node doesn't participate, lower node may incorrectly become leader | Timeout waiting for coordinator announcement | Re-election triggered by heartbeat failure |\n| `MsgOK` from higher-ID node | Lower node incorrectly declares victory | Multiple coordinator announcements detected | Higher-term coordinator message overrides |\n| `MsgCoordinator` to some nodes | Inconsistent leader view across cluster | Heartbeat failures from unnotified nodes | Missing nodes detect leader and request status |\n\n> **Decision: Message Delivery Guarantees**\n> - **Context**: The bully algorithm correctness depends on reliable message delivery, but network failures are inevitable in distributed systems\n> - **Options Considered**:\n>   1. Best-effort delivery with retries and timeouts\n>   2. Exactly-once delivery with acknowledgment tracking\n>   3. At-least-once delivery with idempotent message processing\n> - **Decision**: At-least-once delivery with idempotent message processing\n> - **Rationale**: Balances reliability with complexity - duplicate messages are safer than lost messages in leader election, and idempotent processing prevents state corruption\n> - **Consequences**: Requires message deduplication logic but ensures election progress even with network instability\n\n**Network Partition Scenarios**\n\nNetwork partitions create the most complex edge cases because different parts of the cluster may independently elect leaders:\n\n1. **Majority Partition Scenario**: The partition containing more than half the nodes can safely elect a leader because it represents the cluster majority. The minority partition should detect it lacks quorum and avoid electing a leader.\n\n2. **Equal Partition Scenario**: When the cluster splits into equal-sized partitions, both sides might attempt leader election. The partition containing the node with the highest ID should eventually win when partitions heal.\n\n3. **Cascading Partition Scenario**: A leader might become isolated while the rest of the cluster remains connected. The main cluster should elect a new leader while the isolated leader eventually detects its isolation and steps down.\n\n**Split-Brain Prevention Mechanisms**:\n\n- **Quorum Requirements**: A node can only become leader if it can communicate with more than half the nodes in its last known cluster membership\n- **Partition Detection**: Nodes monitor their connectivity to other cluster members and refuse leadership if they detect they're in a minority partition  \n- **Term Comparison**: When partitions heal, the leader with the higher election term remains leader, while lower-term leaders step down\n\n**Timing and Timeout Edge Cases**\n\nThe bully algorithm relies heavily on timeouts, which create timing-dependent edge cases:\n\n⚠️ **Pitfall: Timeout Values Too Aggressive**\nSetting election timeouts too low causes premature leader declarations when higher-ID nodes are slow to respond. This leads to multiple coordinator announcements and leader thrashing. The timeout should be at least 3x the maximum expected network round-trip time plus processing delays.\n\n⚠️ **Pitfall: Timeout Values Too Conservative** \nSetting election timeouts too high delays leader election when higher-ID nodes have genuinely failed, increasing cluster unavailability. This is especially problematic in cascading failure scenarios where multiple nodes fail in sequence.\n\n**Adaptive Timeout Strategy**:\n\n| Network Condition | Timeout Multiplier | Rationale |\n|-------------------|-------------------|-----------|\n| Normal operation | 1.0x base timeout | Fast elections for quick recovery |\n| Recent message loss detected | 1.5x base timeout | Allow extra time for retransmission |\n| Network partition recovery | 2.0x base timeout | Avoid premature elections during cluster healing |\n| Multiple recent elections | 1.3x base timeout | Reduce election thrashing |\n\n**Cascading Failure Scenarios**\n\nWhen multiple nodes fail in rapid succession, the bully algorithm can experience cascading election attempts:\n\n1. **Leader Failure**: Original leader fails, node N-1 detects and starts election\n2. **Cascade Trigger**: Node N-1 fails during its election attempt, node N-2 must restart the process\n3. **Rapid Succession**: Pattern continues until a stable node successfully completes the election\n\n**Cascading Failure Handling**:\n\n- **Election Attempt Tracking**: Nodes track recent election attempts and implement exponential backoff to reduce thundering herd effects\n- **Stability Detection**: New leaders wait a brief period before accepting client requests to ensure they remain stable\n- **Failure Correlation**: Nodes consider whether recent failures might indicate broader infrastructure issues (power, network) that affect election viability\n\n**State Inconsistency Resolution**\n\nDespite careful design, distributed systems can develop state inconsistencies that the bully algorithm must detect and resolve:\n\n| Inconsistency Type | Symptoms | Detection Method | Resolution |\n|-------------------|----------|------------------|------------|\n| Multiple leaders with same term | Conflicting coordinator messages | Cross-leader heartbeat monitoring | Re-election with term increment |\n| Follower has higher term than leader | Stale leader sending old-term heartbeats | Term comparison in heartbeat processing | Leader steps down, follower triggers election |\n| Node believes it's leader but others don't | Node sends heartbeats but receives election messages | Election messages received while in leader state | Step down and participate in new election |\n\n**Recovery from Edge Cases**\n\nThe bully algorithm includes several recovery mechanisms that activate when edge cases are detected:\n\n- **Periodic Leader Validation**: Followers periodically verify they can reach the current leader and trigger re-election if not\n- **Term Monotonicity Enforcement**: Any message with a higher term than the current node's term triggers immediate term update and potential state transition\n- **Election Liveness Guarantee**: If no coordinator announcement is received within 2x the election timeout, any node can restart the election process\n- **Cluster Membership Reconciliation**: Nodes periodically exchange membership views to detect and resolve inconsistencies\n\n> **Critical Design Insight**: The bully algorithm's edge case handling relies on eventual consistency rather than preventing all edge cases. The system allows temporary inconsistencies (brief periods with no leader or multiple leaders) but guarantees eventual convergence to a single, highest-ID leader through its recovery mechanisms.\n\nThese edge cases and their handling mechanisms ensure that the bully algorithm remains robust in the face of the various failure modes encountered in distributed systems, while maintaining the core guarantee that the highest-ID available node eventually becomes the leader.\n\n### Implementation Guidance\n\nThis subsection provides concrete implementation guidance for building the bully election algorithm on top of the node communication layer established in Milestone 1.\n\n**Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| State Management | In-memory maps with mutex protection | Persistent state with embedded database (BoltDB) |\n| Election Timeouts | `time.Timer` with context cancellation | Priority queue with heap-based timeout management |\n| Message Serialization | JSON with `encoding/json` | Protocol Buffers with generated Go bindings |\n| Concurrent Safety | `sync.RWMutex` for state protection | Lock-free atomic operations with memory ordering |\n| Testing | Table-driven tests with mock transport | Property-based testing with rapid failure injection |\n\n**Recommended File Structure**\n\n```\ninternal/election/\n  bully.go              ← BullyElection implementation\n  bully_test.go         ← Comprehensive bully algorithm tests\n  state.go              ← Election state management\n  messages.go           ← Bully-specific message builders\n  timeouts.go           ← Election timeout management\n  edge_cases.go         ← Edge case detection and recovery\nexamples/bully_demo/\n  main.go               ← Multi-node bully demo\n  cluster_config.json   ← Node configuration for testing\n```\n\n**Core Infrastructure (Complete Implementation)**\n\n```go\n// Package election provides leader election algorithm implementations\npackage election\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\n// ElectionState manages the persistent and transient state for bully elections\ntype ElectionState struct {\n    mu                   sync.RWMutex\n    currentState        NodeState\n    currentLeader       NodeID\n    currentTerm         uint64\n    activeElectionID    uint64\n    candidateNodes      map[NodeID]bool\n    receivedOKs         map[NodeID]bool\n    lastLeaderHeartbeat time.Time\n    electionStartTime   time.Time\n}\n\n// NewElectionState creates a new election state manager\nfunc NewElectionState() *ElectionState {\n    return &ElectionState{\n        currentState:     StateFollower,\n        currentLeader:    0,\n        currentTerm:      0,\n        candidateNodes:   make(map[NodeID]bool),\n        receivedOKs:      make(map[NodeID]bool),\n    }\n}\n\n// GetCurrentState returns the node's current election state thread-safely\nfunc (es *ElectionState) GetCurrentState() (NodeState, NodeID, uint64) {\n    es.mu.RLock()\n    defer es.mu.RUnlock()\n    return es.currentState, es.currentLeader, es.currentTerm\n}\n\n// TransitionTo safely transitions the node to a new election state\nfunc (es *ElectionState) TransitionTo(newState NodeState, leaderID NodeID, term uint64) {\n    es.mu.Lock()\n    defer es.mu.Unlock()\n    es.currentState = newState\n    es.currentLeader = leaderID\n    if term > es.currentTerm {\n        es.currentTerm = term\n    }\n    es.lastStateTransition = time.Now()\n}\n\n// ElectionTimeoutManager handles election timeout logic with context cancellation\ntype ElectionTimeoutManager struct {\n    timeout    time.Duration\n    timer      *time.Timer\n    cancelFunc context.CancelFunc\n    mu         sync.Mutex\n}\n\n// NewElectionTimeoutManager creates a timeout manager with the specified duration\nfunc NewElectionTimeoutManager(timeout time.Duration) *ElectionTimeoutManager {\n    return &ElectionTimeoutManager{\n        timeout: timeout,\n    }\n}\n\n// StartTimeout begins an election timeout with the provided callback\nfunc (etm *ElectionTimeoutManager) StartTimeout(callback func()) {\n    etm.mu.Lock()\n    defer etm.mu.Unlock()\n    \n    if etm.timer != nil {\n        etm.timer.Stop()\n    }\n    \n    etm.timer = time.AfterFunc(etm.timeout, callback)\n}\n\n// CancelTimeout stops the current election timeout\nfunc (etm *ElectionTimeoutManager) CancelTimeout() {\n    etm.mu.Lock()\n    defer etm.mu.Unlock()\n    \n    if etm.timer != nil {\n        etm.timer.Stop()\n        etm.timer = nil\n    }\n}\n```\n\n**Core Bully Algorithm Skeleton (TODO Implementation)**\n\n```go\n// BullyElection implements the bully leader election algorithm\ntype BullyElection struct {\n    nodeID      NodeID\n    transport   Transport\n    membership  *ClusterMembership\n    state       *ElectionState\n    timeout     *ElectionTimeoutManager\n    msgBuilder  *MessageBuilder\n}\n\n// NewBullyElection creates a new bully election coordinator\nfunc NewBullyElection(nodeID NodeID, transport Transport, membership *ClusterMembership) *BullyElection {\n    return &BullyElection{\n        nodeID:     nodeID,\n        transport:  transport,\n        membership: membership,\n        state:      NewElectionState(),\n        timeout:    NewElectionTimeoutManager(5 * time.Second),\n        msgBuilder: NewMessageBuilder(nodeID),\n    }\n}\n\n// StartElection initiates a new bully election process\n// This is called when the current leader is detected as failed\nfunc (be *BullyElection) StartElection() error {\n    // TODO 1: Generate unique election ID using nodeID and current timestamp\n    // Hint: electionID := uint64(be.nodeID)<<32 | uint64(time.Now().UnixNano())\n    \n    // TODO 2: Transition to StateCandidate and increment current term\n    // Hint: Use be.state.TransitionTo() with new term = current term + 1\n    \n    // TODO 3: Find all higher-ID nodes from cluster membership\n    // Hint: Use be.membership.GetActiveMembers() and filter by ID > be.nodeID\n    \n    // TODO 4: Send MsgElection to each higher-ID node\n    // Hint: Use be.msgBuilder.BuildElectionMessage() and be.transport.SendMessage()\n    \n    // TODO 5: Start election timeout - if no OK responses, declare victory\n    // Hint: Use be.timeout.StartTimeout() with callback to be.declareVictory()\n    \n    // TODO 6: Track candidate nodes for response correlation\n    // Hint: Store higher-ID node list in be.state.candidateNodes map\n    \n    return nil\n}\n\n// HandleMessage processes incoming election-related messages\nfunc (be *BullyElection) HandleMessage(msg *Message) error {\n    switch msg.Type {\n    case MsgElection:\n        return be.handleElectionMessage(msg)\n    case MsgOK:\n        return be.handleOKMessage(msg)\n    case MsgCoordinator:\n        return be.handleCoordinatorMessage(msg)\n    default:\n        return fmt.Errorf(\"unknown message type: %d\", msg.Type)\n    }\n}\n\n// handleElectionMessage processes incoming election messages from lower-ID nodes\nfunc (be *BullyElection) handleElectionMessage(msg *Message) error {\n    // TODO 1: Parse election message from msg.Payload\n    // Hint: json.Unmarshal into ElectionMessage struct\n    \n    // TODO 2: Check if sender has lower ID than this node\n    // Hint: If msg.From >= be.nodeID, this shouldn't happen - log warning\n    \n    // TODO 3: Send OK response to sender\n    // Hint: Build MsgOK message and use be.transport.SendMessage()\n    \n    // TODO 4: If not already in election, start own election process\n    // Hint: Check current state - if StateFollower, call be.StartElection()\n    \n    return nil\n}\n\n// handleOKMessage processes OK responses from higher-ID nodes\nfunc (be *BullyElection) handleOKMessage(msg *Message) error {\n    // TODO 1: Verify this node is currently in StateCandidate\n    // Hint: If not candidate, ignore message (may be from old election)\n    \n    // TODO 2: Parse OK message from msg.Payload\n    // Hint: json.Unmarshal into OKMessage struct\n    \n    // TODO 3: Cancel election timeout since higher-ID node is handling election\n    // Hint: Use be.timeout.CancelTimeout()\n    \n    // TODO 4: Transition back to StateFollower and wait for coordinator announcement\n    // Hint: Use be.state.TransitionTo(StateFollower, 0, currentTerm)\n    \n    // TODO 5: Clear election-specific state\n    // Hint: Reset be.state.candidateNodes and be.state.receivedOKs maps\n    \n    return nil\n}\n\n// handleCoordinatorMessage processes leader announcements\nfunc (be *BullyElection) handleCoordinatorMessage(msg *Message) error {\n    // TODO 1: Parse coordinator message from msg.Payload\n    // Hint: json.Unmarshal into CoordinatorMessage struct\n    \n    // TODO 2: Verify sender ID matches announced leader ID\n    // Hint: msg.From should equal coordinatorMsg.LeaderID\n    \n    // TODO 3: Check if announced term is higher than current term\n    // Hint: If lower term, this may be delayed message - ignore or log warning\n    \n    // TODO 4: Update state to follow new leader\n    // Hint: TransitionTo StateFollower with new leader and term\n    \n    // TODO 5: Cancel any ongoing election activities\n    // Hint: Cancel timeout and clear election state\n    \n    // TODO 6: Update last leader heartbeat timestamp for failure detection\n    // Hint: Set be.state.lastLeaderHeartbeat = time.Now()\n    \n    return nil\n}\n\n// declareVictory is called when election timeout expires with no OK responses\nfunc (be *BullyElection) declareVictory() {\n    // TODO 1: Verify still in StateCandidate (may have received late OK)\n    // Hint: Check be.state.GetCurrentState() - if not candidate, return\n    \n    // TODO 2: Transition to StateLeader\n    // Hint: Use be.state.TransitionTo(StateLeader, be.nodeID, currentTerm)\n    \n    // TODO 3: Build coordinator announcement message\n    // Hint: Use be.msgBuilder.BuildCoordinatorMessage()\n    \n    // TODO 4: Broadcast coordinator message to all cluster members\n    // Hint: Use be.transport.BroadcastMessage()\n    \n    // TODO 5: Start leader responsibilities (heartbeat sending)\n    // Hint: Call be.startLeaderDuties() or similar\n}\n\n// GetCurrentLeader returns the ID of the current leader\nfunc (be *BullyElection) GetCurrentLeader() NodeID {\n    _, leader, _ := be.state.GetCurrentState()\n    return leader\n}\n\n// IsLeader returns true if this node is the current leader\nfunc (be *BullyElection) IsLeader() bool {\n    state, leader, _ := be.state.GetCurrentState()\n    return state == StateLeader && leader == be.nodeID\n}\n```\n\n**Language-Specific Implementation Hints**\n\n- **Goroutine Safety**: All election state must be protected by mutexes since multiple goroutines handle messages, timeouts, and failure detection simultaneously\n- **Context Cancellation**: Use `context.WithTimeout()` for election timeouts to enable clean cancellation and resource cleanup\n- **JSON Serialization**: Use struct tags like `json:\"election_id\"` for consistent message formatting across nodes\n- **Error Handling**: Wrap transport errors with context: `fmt.Errorf(\"failed to send election message to node %d: %w\", targetID, err)`\n- **Logging**: Use structured logging with fields like `nodeID`, `electionID`, `term` for debugging distributed elections\n- **Testing**: Create mock `Transport` interface implementations that can simulate message loss, delays, and network partitions\n\n**Milestone 2 Checkpoint**\n\nAfter implementing the bully algorithm, verify correctness with these tests:\n\n**Basic Election Test**:\n```bash\ngo run examples/bully_demo/main.go --nodes=3 --ids=1,3,5\n# Expected: Node 5 becomes leader after simulated failure\n# Check logs for: \"Node 5 declared victory\" and \"All nodes acknowledge leader 5\"\n```\n\n**Cascade Election Test**:\n```bash\n# Start with 5 nodes, kill highest ID nodes in sequence\ngo test -v internal/election -run TestBullyCascadeFailure\n# Expected: Leadership passes down: 5→4→3→2→1 as higher nodes fail\n```\n\n**Concurrent Election Test**:\n```bash\ngo test -v internal/election -run TestBullyConcurrentElections  \n# Expected: Only one leader emerges despite multiple simultaneous election initiators\n```\n\n**Signs of Correct Implementation**:\n- Election completes within 2x timeout period (typically 10 seconds)\n- Exactly one coordinator announcement per successful election\n- Lower-ID nodes always defer to higher-ID nodes' OK responses\n- Network partitions prevent minority sides from electing leaders\n- Logs show clear state transitions: Follower → Candidate → Leader/Follower\n\n**Common Implementation Issues**:\n- **Multiple Leaders**: Check that nodes receiving OK messages immediately cancel timeouts and return to follower state\n- **Election Hangs**: Verify timeout callbacks are properly registered and election state is cleared after completion\n- **Message Ordering**: Ensure election ID generation creates unique, monotonic identifiers to handle concurrent elections\n- **State Race Conditions**: Protect all election state access with appropriate mutex locking\n\n\n## Ring Election Algorithm\n\n> **Milestone(s):** Milestone 3 (Ring Election) - implements ring-based election where tokens circulate to collect live nodes\n\n### Mental Model: Passing the Torch\n\nThink of the ring election algorithm like an Olympic torch relay, but with a special twist: instead of just passing the torch to the finish line, each runner writes their name on the torch as it passes through their hands. The torch travels around a predetermined circular route, visiting each active relay station in order. When the torch completes the full circle and returns to where it started, everyone can see all the names written on it, and the person with the highest \"ranking\" (node ID) among those who successfully added their name becomes the champion.\n\nIn our distributed system, the \"torch\" is an election token containing a list of participating node IDs. The \"relay stations\" are the nodes arranged in a logical ring ordered by their unique identifiers. Each node that successfully receives the token adds its ID to the participant list and passes it to the next node in the ring. Failed or unreachable nodes are automatically skipped, just like closed relay stations in our analogy. When the token returns to the initiating node, it contains a complete roster of all live nodes, and the highest-ID node from this list becomes the new leader.\n\nThis approach differs fundamentally from the bully algorithm's competitive messaging. Instead of nodes fighting for leadership through direct challenges, ring election uses cooperative information gathering. The token methodically visits each node, collecting a census of who's alive and participating. This eliminates the cascade election problem that can occur in bully algorithms when multiple higher-ID nodes fail simultaneously.\n\n> **Key Insight**: Ring election separates the concerns of *discovering who's alive* (token circulation) from *selecting the leader* (deterministic choice from the collected set). This makes the algorithm more predictable and easier to reason about than competitive approaches.\n\n### Logical Ring Construction\n\nThe foundation of ring election is establishing a **logical ring topology** where nodes are arranged in a predetermined order based on their unique identifiers. This ring exists as a conceptual overlay on top of the actual network topology - nodes don't need to be physically connected in a ring, they just need to know their logical position and successor.\n\n![Ring Election Topology](./diagrams/ring-topology.svg)\n\n#### Ring Ordering and Successor Calculation\n\nThe logical ring orders nodes by their `NodeID` values in ascending order, with the highest-ID node wrapping around to point to the lowest-ID node. This creates a circular structure where every node has exactly one successor and one predecessor.\n\n| Ring Property | Description | Example |\n|---------------|-------------|---------|\n| **Node Ordering** | Nodes sorted by ascending `NodeID` | IDs [1, 3, 5, 7] → Ring order: 1→3→5→7→1 |\n| **Successor Mapping** | Each node points to next higher ID | Node 3's successor is Node 5 |\n| **Ring Completion** | Highest ID wraps to lowest ID | Node 7's successor is Node 1 |\n| **Bidirectional Knowledge** | Optional: nodes know predecessors too | Node 5's predecessor is Node 3 |\n\nThe `RingElection` component maintains this topology through a successor map and provides methods to navigate the ring structure:\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `findNextLiveNode(startID NodeID)` | startID NodeID | NodeID, error | Finds next reachable node starting from given position |\n| `calculateSuccessor(nodeID NodeID)` | nodeID NodeID | NodeID | Determines logical successor based on ID ordering |\n| `rebuildRing()` | none | error | Reconstructs ring after membership changes |\n| `validateRingIntegrity()` | none | bool | Checks if ring structure is consistent |\n\n#### Ring Construction Algorithm\n\nBuilding the logical ring involves several steps that must be coordinated across all participating nodes:\n\n1. **Membership Discovery**: Each node obtains the current cluster membership from the `ClusterMembership` component, getting a list of all nodes believed to be alive and participating.\n\n2. **ID Collection and Sorting**: The node extracts all `NodeID` values from the membership list and sorts them in ascending order to establish the canonical ring sequence.\n\n3. **Successor Assignment**: For each node ID in the sorted list, calculate its successor as the next higher ID in the sequence, with the highest ID wrapping to the lowest.\n\n4. **Ring State Persistence**: Store the ring topology locally so the node knows its position and can determine where to forward election tokens.\n\n5. **Connectivity Verification**: Test that the node can actually communicate with its calculated successor to ensure the ring is functional, not just theoretical.\n\n> **Decision: Static vs Dynamic Ring Ordering**\n> - **Context**: Ring topology can be recalculated each election or maintained continuously\n> - **Options Considered**: \n>   - Static: Calculate ring once at startup, rebuild only on explicit membership changes\n>   - Dynamic: Recalculate ring topology for every election initiation\n>   - Hybrid: Maintain ring but verify/repair before each election\n> - **Decision**: Hybrid approach with continuous maintenance and pre-election verification\n> - **Rationale**: Static rings can become stale with undetected failures; fully dynamic rings add unnecessary overhead; hybrid provides reliability with efficiency\n> - **Consequences**: Requires ring repair mechanisms but provides fast election startup with current topology\n\n#### Handling Ring Membership Changes\n\nWhen nodes join or leave the cluster, the ring topology must be updated to maintain consistency. This presents several challenges:\n\n**Node Join Scenarios**: When a new node joins, it must insert itself into the correct position in the ring based on its ID. This requires updating the predecessor's successor pointer and establishing connections to both neighbors.\n\n**Node Departure Scenarios**: When a node leaves (gracefully or through failure), its predecessor must update its successor pointer to skip the departed node and connect directly to the next live node in sequence.\n\n**Split Ring Recovery**: Network partitions can break the ring into multiple segments. When partitions heal, the segments must be reconnected and duplicate leaders resolved.\n\n| Ring Event | Impact | Recovery Action | Complexity |\n|------------|--------|-----------------|------------|\n| **Node Join** | Ring grows, IDs reordered | Insert node, update predecessor successor | Low |\n| **Graceful Leave** | Ring shrinks, clean removal | Update predecessor's successor pointer | Low |\n| **Node Failure** | Ring breaks, successor unreachable | Skip failed node, find next live successor | Medium |\n| **Partition Healing** | Multiple ring segments merge | Rebuild unified ring, resolve leader conflicts | High |\n\n#### Ring State Representation\n\nThe `RingElection` component maintains several data structures to track the ring topology and its current state:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `nodeID` | NodeID | This node's unique identifier |\n| `successorMap` | map[NodeID]NodeID | Maps each node to its ring successor |\n| `ringSequence` | []NodeID | Ordered list of node IDs in ring sequence |\n| `membership` | *ClusterMembership | Reference to cluster membership manager |\n| `ringVersion` | uint64 | Monotonic counter tracking ring topology changes |\n| `lastRingUpdate` | int64 | Timestamp of most recent ring reconstruction |\n\n### Ring Election Protocol\n\nThe ring election protocol implements a token-passing mechanism where an election token circulates around the logical ring, collecting participant information and ultimately selecting the highest-ID node as leader. This process involves several distinct phases and message types.\n\n![Ring Election Token Passing](./diagrams/ring-sequence.svg)\n\n#### Election Token Structure\n\nThe core of ring election is the `RingToken` message that circulates around the ring:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `ElectionID` | uint64 | Unique identifier for this election instance |\n| `InitiatorID` | NodeID | ID of node that started this election |\n| `Participants` | []NodeID | Ordered list of live nodes encountered |\n| `Complete` | bool | Whether token has completed full ring traversal |\n| `Term` | uint64 | Election term for ordering and duplicate detection |\n| `Timestamp` | int64 | Creation timestamp for timeout calculation |\n\nThe token serves as both a census-taking mechanism and a coordination device. As it travels around the ring, it accumulates evidence of which nodes are alive and participating. When it returns to the initiator, the `Participants` slice contains a definitive list of live nodes from which the leader can be deterministically selected.\n\n#### Token Passing State Machine\n\nEach node in the ring maintains state about ongoing elections and transitions through different roles as tokens pass through:\n\n| Node State | Description | Trigger Events | Actions |\n|------------|-------------|----------------|---------|\n| **Idle** | No active election, following current leader | Leader failure detected | Initiate new election |\n| **Token Creator** | This node initiated current election | Election timeout or failure | Create and send initial token |\n| **Token Forwarder** | Processing received token from predecessor | Token received | Add self to participants, forward to successor |\n| **Token Receiver** | Received completed token back from ring | Complete token received | Select leader from participants list |\n| **Leader Elected** | Election completed, leader determined | Token processing complete | Announce coordinator or become follower |\n\n#### Ring Election Steps\n\nThe complete ring election protocol follows these detailed steps:\n\n1. **Election Initiation**: A node detects leader failure through the failure detection mechanism or election timeout. It transitions to candidate state and decides to initiate a ring election.\n\n2. **Token Creation**: The initiating node creates a new `RingToken` with a unique `ElectionID`, sets itself as the `InitiatorID`, adds its own `NodeID` to the `Participants` list, and marks `Complete` as false.\n\n3. **Initial Token Transmission**: The initiator finds its successor in the ring using `findNextLiveNode()` and sends the token via `SendMessage()` to begin the circulation process.\n\n4. **Token Reception and Processing**: Each node that receives the token performs several validation and processing steps:\n   - Verify the token is for a current election (not outdated or duplicate)\n   - Add its own `NodeID` to the `Participants` list if not already present\n   - Check if this token has completed a full ring traversal by comparing current position to initiator\n\n5. **Token Forwarding**: After processing, each node determines its successor in the ring and forwards the modified token. If the immediate successor is unreachable, the node uses ring repair logic to skip failed nodes.\n\n6. **Ring Completion Detection**: When the token returns to the original initiator, the initiator recognizes completion by seeing its own ID as the next recipient. It marks the token as `Complete = true`.\n\n7. **Leader Selection**: The initiator examines the complete `Participants` list and selects the node with the highest `NodeID` value as the new leader. This selection is deterministic and will be the same regardless of which node performs it.\n\n8. **Coordinator Announcement**: The initiator broadcasts a `CoordinatorMessage` to all nodes in the cluster, announcing the elected leader and the election term. All nodes update their leader state accordingly.\n\n> **Key Design Insight**: The ring election separates the *information gathering phase* (token circulation) from the *decision phase* (leader selection). This separation makes the algorithm more predictable and easier to debug than protocols that interleave discovery and decision-making.\n\n#### Token Circulation Example\n\nConsider a cluster with nodes [1, 3, 5, 7] where node 3 detects leader failure and initiates an election:\n\n**Step 1**: Node 3 creates token: `{ElectionID: 12, InitiatorID: 3, Participants: [3], Complete: false}`\n\n**Step 2**: Node 3 sends token to successor Node 5\n\n**Step 3**: Node 5 receives token, adds itself: `{ElectionID: 12, InitiatorID: 3, Participants: [3, 5], Complete: false}`\n\n**Step 4**: Node 5 sends token to successor Node 7\n\n**Step 5**: Node 7 receives token, adds itself: `{ElectionID: 12, InitiatorID: 3, Participants: [3, 5, 7], Complete: false}`\n\n**Step 6**: Node 7 sends token to successor Node 1\n\n**Step 7**: Node 1 receives token, adds itself: `{ElectionID: 12, InitiatorID: 3, Participants: [3, 5, 7, 1], Complete: false}`\n\n**Step 8**: Node 1 sends token back to Node 3 (completing the ring)\n\n**Step 9**: Node 3 receives token, marks complete, selects Node 7 (highest ID) as leader, broadcasts coordinator announcement\n\n#### Concurrent Election Handling\n\nUnlike bully elections where concurrent elections can create complex cascades, ring elections handle concurrency through token precedence and election ID comparison:\n\n| Scenario | Detection Method | Resolution Strategy | Outcome |\n|----------|------------------|---------------------|---------|\n| **Multiple Initiators** | Different ElectionID values | Higher ElectionID takes precedence | Lower ID election abandoned |\n| **Token Collision** | Same node receives multiple tokens | Compare timestamps and initiator IDs | Earlier or higher-priority token wins |\n| **Stale Token** | Token from previous election | Check against current election term | Stale token discarded |\n| **Partition Merge** | Tokens from different partitions | Compare election metadata | Most recent/complete election wins |\n\n### Ring Maintenance and Repair\n\nThe logical ring topology requires continuous maintenance to handle node failures, network partitions, and membership changes. Ring repair mechanisms ensure that election tokens can always find a path around the ring, even when some nodes are unreachable.\n\n#### Failure Detection in Ring Context\n\nRing elections rely on two levels of failure detection: **immediate successor failure** during token forwarding, and **background membership monitoring** for proactive ring updates.\n\n**Successor Failure Detection**: When a node attempts to forward a token to its successor and encounters a timeout or connection failure, it immediately triggers ring repair to find the next live node in sequence.\n\n**Background Health Monitoring**: The failure detection component continuously monitors all known nodes via heartbeats and updates the `ClusterMembership`. When failures are detected, the ring topology is asynchronously updated to reflect the new membership.\n\n| Detection Method | Trigger | Response Time | Accuracy |\n|------------------|---------|---------------|----------|\n| **Token Forward Timeout** | SendMessage() fails to successor | Immediate (during election) | High - tested during use |\n| **Heartbeat Timeout** | No heartbeat within interval | Background (eventual) | Medium - may have false positives |\n| **Connection Refused** | TCP/HTTP connection rejected | Immediate | High - definitive failure |\n| **Membership Update** | External membership change | Event-driven | High - authoritative source |\n\n#### Ring Repair Algorithm\n\nWhen a node discovers that its immediate successor is unreachable, it must dynamically repair the ring by finding the next live node in the sequence. This repair happens transparently during token forwarding:\n\n1. **Failure Detection**: Node A attempts to send token to successor Node B but receives a timeout or connection error.\n\n2. **Successor Search**: Node A queries its local `ClusterMembership` to get the current list of believed-live nodes and rebuilds the ring sequence.\n\n3. **Next Live Node Calculation**: Node A finds the next node in ring order after the failed Node B. This might require skipping multiple failed nodes.\n\n4. **Connection Validation**: Node A tests connectivity to the calculated next live node before forwarding the token to ensure the repair is effective.\n\n5. **Token Forward with Repair**: Node A sends the token to the validated next live node, effectively bypassing the failed portion of the ring.\n\n6. **Membership Update**: Node A marks the failed nodes as suspicious or unreachable in its local failure detector to prevent repeated repair attempts.\n\nThe `findNextLiveNode()` method implements this repair logic:\n\n| Step | Action | Failure Handling |\n|------|--------|------------------|\n| **1. Get Ring Sequence** | Retrieve ordered node list from membership | Use cached sequence if membership unavailable |\n| **2. Find Current Position** | Locate starting node in sequence | Return error if starting node not in ring |\n| **3. Iterate to Next** | Move to next position in ring order | Wrap around from highest to lowest ID |\n| **4. Test Connectivity** | Attempt connection to candidate node | Skip unreachable nodes, continue search |\n| **5. Return Live Node** | Return first reachable successor | Return error if no live nodes found |\n\n#### Partition Healing and Ring Reconstruction\n\nNetwork partitions can split the logical ring into multiple disconnected segments, each potentially running independent elections. When partitions heal and network connectivity is restored, the system must merge the segments back into a unified ring and resolve any conflicting leadership states.\n\n**Partition Detection**: Nodes detect they're in a partition when they can only reach a subset of the expected cluster members. Ring elections may proceed within each partition segment, potentially electing different leaders.\n\n**Healing Detection**: When network connectivity is restored, nodes begin receiving heartbeats and messages from previously unreachable nodes. The `ClusterMembership` component detects the membership expansion.\n\n**Ring Reconstruction Process**:\n1. **Membership Reconciliation**: All nodes update their membership view to include newly reachable nodes\n2. **Ring Topology Rebuild**: Recalculate the complete ring sequence with all available nodes\n3. **Leader Conflict Resolution**: If multiple leaders exist from partition elections, apply deterministic rules (highest ID, most recent term) to select one\n4. **State Synchronization**: The unified leader broadcasts its authority to ensure all nodes converge on consistent state\n\n| Partition Scenario | Challenge | Resolution Strategy | \n|-------------------|-----------|-------------------|\n| **Clean Split** | Two complete ring segments | Merge segments, highest ID leader wins |\n| **Fragmented Ring** | Multiple small partitions | Rebuild complete ring, re-elect from full membership |\n| **Majority Partition** | One large + several small partitions | Large partition leader takes precedence |\n| **Symmetric Split** | Equal-sized partitions | Deterministic tiebreaker (highest leader ID) |\n\n#### Ring State Consistency\n\nMaintaining consistent ring state across all nodes requires careful coordination, especially during membership changes and election processes. The system uses several mechanisms to ensure consistency:\n\n**Ring Version Tracking**: Each ring topology change increments a version counter. Nodes compare versions to detect when their local ring view is stale and needs updating.\n\n**Atomic Ring Updates**: When membership changes are detected, all affected nodes must update their ring topology atomically to prevent temporary inconsistencies during token forwarding.\n\n**Ring Validation**: Before initiating elections, nodes validate their ring topology by checking that their successor is reachable and agrees on the ring structure.\n\n⚠️ **Pitfall: Stale Ring Topology**\nA common error is using outdated ring topology during elections, causing tokens to be sent to failed nodes or wrong successors. This happens when nodes don't promptly update their ring state after membership changes. The symptom is elections that hang or never complete because tokens get lost. Fix this by always validating ring connectivity before election initiation and implementing triggered ring updates when membership changes are detected.\n\n⚠️ **Pitfall: Ring Split During Election**\nIf the ring topology changes (due to node failures) while an election token is circulating, the token might get stuck or take an unexpected path. This can cause elections to hang indefinitely or produce incorrect results. The symptom is tokens never returning to their initiator. Fix this by implementing election timeouts at the initiator and re-starting elections with updated topology when timeouts occur.\n\n> **Critical Design Principle**: Ring consistency is more important than ring completeness. It's better to have a smaller ring with all nodes agreeing on the topology than a complete ring where nodes have inconsistent views of their successors.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| **Ring State Storage** | In-memory map[NodeID]NodeID | Persistent key-value store with versioning |\n| **Token Serialization** | JSON over HTTP | Protocol Buffers with binary encoding |\n| **Failure Detection** | HTTP request timeouts | gRPC health checking with retry logic |\n| **Ring Repair** | Linear search through membership | Consistent hashing with virtual nodes |\n| **Election Coordination** | Synchronous token passing | Asynchronous event-driven state machine |\n\n#### Recommended File Structure\n\n```\ninternal/election/\n  ring/\n    ring_election.go          ← main RingElection implementation\n    ring_topology.go          ← ring construction and maintenance\n    token_manager.go          ← token creation and processing\n    ring_repair.go           ← failure detection and ring repair\n    ring_election_test.go    ← comprehensive ring election tests\n  messages/\n    ring_token.go            ← RingToken message structure\n    token_serialization.go   ← JSON marshaling for tokens\n```\n\n#### Ring Topology Infrastructure Code\n\n```go\npackage ring\n\nimport (\n    \"errors\"\n    \"sort\"\n    \"sync\"\n    \"time\"\n)\n\n// RingTopology manages the logical ring structure and successor relationships\ntype RingTopology struct {\n    mu             sync.RWMutex\n    nodeID         NodeID\n    successorMap   map[NodeID]NodeID\n    ringSequence   []NodeID\n    membership     *ClusterMembership\n    ringVersion    uint64\n    lastUpdate     time.Time\n}\n\n// NewRingTopology creates a new ring topology manager\nfunc NewRingTopology(nodeID NodeID, membership *ClusterMembership) *RingTopology {\n    return &RingTopology{\n        nodeID:       nodeID,\n        successorMap: make(map[NodeID]NodeID),\n        membership:   membership,\n        ringVersion:  1,\n        lastUpdate:   time.Now(),\n    }\n}\n\n// RebuildRing reconstructs the ring topology from current cluster membership\nfunc (rt *RingTopology) RebuildRing() error {\n    rt.mu.Lock()\n    defer rt.mu.Unlock()\n    \n    activeNodes := rt.membership.GetActiveMembers()\n    if len(activeNodes) == 0 {\n        return errors.New(\"no active nodes for ring construction\")\n    }\n    \n    // Extract and sort node IDs\n    nodeIDs := make([]NodeID, len(activeNodes))\n    for i, node := range activeNodes {\n        nodeIDs[i] = node.ID\n    }\n    sort.Slice(nodeIDs, func(i, j int) bool {\n        return nodeIDs[i] < nodeIDs[j]\n    })\n    \n    // Build successor map\n    newSuccessorMap := make(map[NodeID]NodeID)\n    for i, nodeID := range nodeIDs {\n        nextIndex := (i + 1) % len(nodeIDs)\n        successor := nodeIDs[nextIndex]\n        newSuccessorMap[nodeID] = successor\n    }\n    \n    rt.successorMap = newSuccessorMap\n    rt.ringSequence = nodeIDs\n    rt.ringVersion++\n    rt.lastUpdate = time.Now()\n    \n    return nil\n}\n\n// GetSuccessor returns the immediate successor for a given node\nfunc (rt *RingTopology) GetSuccessor(nodeID NodeID) (NodeID, bool) {\n    rt.mu.RLock()\n    defer rt.mu.RUnlock()\n    \n    successor, exists := rt.successorMap[nodeID]\n    return successor, exists\n}\n\n// FindNextLiveNode locates the next reachable node starting from given position\nfunc (rt *RingTopology) FindNextLiveNode(startID NodeID, transport Transport) (NodeID, error) {\n    rt.mu.RLock()\n    ringSeq := make([]NodeID, len(rt.ringSequence))\n    copy(ringSeq, rt.ringSequence)\n    rt.mu.RUnlock()\n    \n    if len(ringSeq) == 0 {\n        return 0, errors.New(\"empty ring sequence\")\n    }\n    \n    // Find starting position\n    startPos := -1\n    for i, id := range ringSeq {\n        if id == startID {\n            startPos = i\n            break\n        }\n    }\n    \n    if startPos == -1 {\n        return 0, errors.New(\"start node not found in ring\")\n    }\n    \n    // Search for next live node\n    for i := 1; i < len(ringSeq); i++ {\n        nextPos := (startPos + i) % len(ringSeq)\n        candidateID := ringSeq[nextPos]\n        \n        // Skip self\n        if candidateID == rt.nodeID {\n            continue\n        }\n        \n        // Test connectivity\n        if rt.testNodeConnectivity(candidateID, transport) {\n            return candidateID, nil\n        }\n    }\n    \n    return 0, errors.New(\"no live successor nodes found\")\n}\n\n// testNodeConnectivity checks if a node is reachable\nfunc (rt *RingTopology) testNodeConnectivity(nodeID NodeID, transport Transport) bool {\n    // Create a lightweight ping message\n    pingMsg := &Message{\n        Type:      MsgHeartbeat,\n        From:      rt.nodeID,\n        To:        nodeID,\n        Timestamp: time.Now().Unix(),\n    }\n    \n    // Attempt to send with short timeout\n    err := transport.SendMessage(nodeID, pingMsg)\n    return err == nil\n}\n```\n\n#### Ring Election Core Logic Skeleton\n\n```go\n// RingElection implements the ring-based leader election algorithm\ntype RingElection struct {\n    nodeID          NodeID\n    transport       Transport\n    membership      *ClusterMembership\n    topology        *RingTopology\n    state          *ElectionState\n    timeoutManager *ElectionTimeoutManager\n    \n    // Ring-specific state\n    activeElections map[uint64]*RingToken\n    tokenTimeout    time.Duration\n    mu             sync.RWMutex\n}\n\n// StartElection initiates a new ring election by creating and circulating a token\nfunc (re *RingElection) StartElection() error {\n    re.mu.Lock()\n    defer re.mu.Unlock()\n    \n    // TODO 1: Check if already in an active election - if so, return early\n    // TODO 2: Rebuild ring topology to get current membership view\n    // TODO 3: Create new RingToken with unique ElectionID and current term\n    // TODO 4: Add self to token.Participants list\n    // TODO 5: Find next live successor using topology.FindNextLiveNode()\n    // TODO 6: Send token to successor and start election timeout\n    // TODO 7: Update local election state to track this election\n    // Hint: Use re.generateElectionID() for unique election identifiers\n    // Hint: Store active election in re.activeElections map for tracking\n    \n    return nil\n}\n\n// HandleMessage processes incoming ring election messages and tokens\nfunc (re *RingElection) HandleMessage(msg *Message) error {\n    switch msg.Type {\n    case MsgRingToken:\n        return re.handleRingToken(msg)\n    default:\n        return errors.New(\"unsupported message type for ring election\")\n    }\n}\n\n// handleRingToken processes a ring election token received from predecessor\nfunc (re *RingElection) handleRingToken(msg *Message) error {\n    // TODO 1: Deserialize RingToken from message payload\n    // TODO 2: Validate token (check election ID, term, not stale)\n    // TODO 3: Check if token has completed full ring (initiator == self)\n    // TODO 4: If complete, select leader and broadcast coordinator message\n    // TODO 5: If not complete, add self to participants and forward\n    // TODO 6: Find next live successor for forwarding\n    // TODO 7: Send modified token to successor\n    // TODO 8: Update local tracking state\n    // Hint: Use json.Unmarshal to deserialize RingToken\n    // Hint: Leader selection: find max NodeID in token.Participants\n    // Hint: Use re.topology.FindNextLiveNode() for successor lookup\n    \n    return nil\n}\n\n// selectLeaderFromParticipants determines leader from collected participant IDs\nfunc (re *RingElection) selectLeaderFromParticipants(participants []NodeID) NodeID {\n    // TODO 1: Handle empty participants list (return 0, log error)\n    // TODO 2: Iterate through participants to find maximum NodeID\n    // TODO 3: Return the highest NodeID as the elected leader\n    // Hint: Simple loop with max tracking variable\n    \n    return 0\n}\n\n// forwardToken sends ring token to next live node in sequence\nfunc (re *RingElection) forwardToken(token *RingToken, successorID NodeID) error {\n    // TODO 1: Serialize RingToken to JSON payload\n    // TODO 2: Create Message with MsgRingToken type\n    // TODO 3: Set message metadata (From, To, Term, Timestamp)\n    // TODO 4: Send message using transport layer\n    // TODO 5: Handle send failures with ring repair\n    // Hint: Use json.Marshal for token serialization\n    // Hint: If SendMessage fails, try re.topology.FindNextLiveNode()\n    \n    return nil\n}\n\n// generateElectionID creates unique identifier for new election\nfunc (re *RingElection) generateElectionID() uint64 {\n    return uint64(time.Now().UnixNano())\n}\n```\n\n#### Milestone Checkpoint\n\nAfter implementing ring election, verify correct behavior:\n\n**Test Command**: `go test ./internal/election/ring/ -v`\n\n**Expected Output**:\n```\n=== RUN   TestRingElection_BasicFlow\n--- PASS: TestRingElection_BasicFlow (0.05s)\n=== RUN   TestRingElection_NodeFailureDuringElection  \n--- PASS: TestRingElection_NodeFailureDuringElection (0.12s)\n=== RUN   TestRingElection_ConcurrentElections\n--- PASS: TestRingElection_ConcurrentElections (0.08s)\n```\n\n**Manual Verification**:\n1. Start 4 nodes with IDs [1, 3, 5, 7]\n2. Kill the current leader node\n3. Observe election initiation in logs: `\"Ring election started by node 3, election_id=12345\"`\n4. Watch token circulation: `\"Token forwarded to successor node 5\"` → `\"Token forwarded to successor node 7\"` etc.\n5. Verify leader announcement: `\"Node 7 elected as leader, election completed\"`\n6. Confirm all nodes acknowledge new leader\n\n**Debugging Signs**:\n- **Election hangs**: Check ring topology - likely broken successor chain\n- **Wrong leader elected**: Verify participant collection - token may have skipped live nodes  \n- **Multiple leaders**: Check election ID comparison - concurrent elections not properly resolved\n- **Token loops**: Validate ring repair logic - failed nodes not being skipped correctly\n\n\n## System Interactions and Data Flow\n\n> **Milestone(s):** All milestones - orchestrates the complete election process by combining node communication (Milestone 1), bully algorithm (Milestone 2), and ring election (Milestone 3) into coordinated system-wide behaviors\n\nUnderstanding individual components is only half the battle in distributed systems. The real complexity emerges from how these components interact to produce system-wide behaviors. This section maps out the complete choreography of leader election, from the initial trigger events through message exchanges to final leader establishment. Think of it as the conductor's score that coordinates all the individual musicians (components) into a symphony of distributed coordination.\n\nThe system interactions reveal the temporal aspects that component descriptions cannot capture: the precise ordering of operations, the cascading effects of failures, and the intricate timing dependencies that make distributed leader election both powerful and challenging. These patterns repeat across both election algorithms, creating a foundation for understanding any distributed coordination protocol.\n\n### Election Initiation Scenarios\n\nLeader elections don't spontaneously occur - they are triggered by specific observable events that indicate the current leadership state is invalid or uncertain. Understanding these trigger scenarios is crucial because they determine when the system transitions from stable operation to active coordination. Each scenario requires different detection mechanisms and response strategies, making this the most context-sensitive aspect of the entire system.\n\nThe initiation logic acts as the system's \"political crisis detector\" - it must distinguish between temporary communication hiccups and genuine leadership failures, avoid false alarms that waste resources, and ensure that elections start quickly enough to minimize availability gaps. Getting this wrong leads to either constant unnecessary elections (resource waste) or delayed failure detection (availability loss).\n\n#### Failure Detection Triggers\n\nThe primary election trigger occurs when the current leader becomes unresponsive or unreachable. The failure detection process operates continuously in the background, monitoring leader heartbeats and maintaining suspicion levels for each node. When suspicion crosses the configured threshold, any follower can initiate a new election to restore cluster leadership.\n\n**Heartbeat Timeout Detection Process:**\n\n1. **Continuous Monitoring Phase**: Each follower node tracks the last received `HeartbeatMessage` from the current leader, comparing timestamps against the configured heartbeat interval plus tolerance margin\n2. **Suspicion Escalation**: When heartbeats become overdue, the follower increments its local suspicion counter for the leader, allowing for temporary network delays or leader processing pauses  \n3. **Failure Threshold Crossing**: Once suspicion reaches the configured maximum (typically 3-5 missed heartbeats), the follower declares the leader failed and transitions to candidate state\n4. **Election Initiation**: The newly-transitioned candidate calls either `BullyElection.StartElection()` or `RingElection.StartElection()` depending on the configured algorithm\n5. **Broadcast Notification**: Other nodes are informed of the suspected leader failure through election messages, allowing them to update their local leader state and participate in the new election\n\n| Detection Parameter | Purpose | Typical Value | Impact of Too Low | Impact of Too High |\n|-------------------|---------|---------------|------------------|-------------------|\n| Heartbeat Interval | Leader alive signal frequency | 1-2 seconds | Network overhead, false failures | Slow failure detection |\n| Heartbeat Timeout | Missing heartbeat threshold | 3x heartbeat interval | False failure detection | Prolonged unavailability |\n| Suspicion Threshold | Failed heartbeat count limit | 3-5 missed beats | Election storms | Extended outage duration |\n| Election Timeout | Candidate response deadline | 5-10 seconds | Split elections | Slow leader establishment |\n\n> **Critical Insight:** The failure detection timeout must balance two competing requirements: fast failure detection (low timeout) versus stability under temporary network delays (high timeout). Most production systems use adaptive timeouts that increase during periods of network instability.\n\n#### Startup and Bootstrap Scenarios\n\nWhen nodes join an empty cluster or restart after a complete system shutdown, there is no existing leader to provide heartbeats. This creates a bootstrap scenario where multiple nodes may simultaneously recognize the leadership vacuum and attempt to fill it. The system must handle these concurrent startup elections gracefully to establish initial leadership quickly and deterministically.\n\n**Cluster Bootstrap Election Process:**\n\n1. **Initial State Assessment**: Each starting node begins in `StateFollower` and waits for a brief randomized delay (typically 1-5 seconds) to detect existing leadership through heartbeat messages\n2. **Leadership Vacuum Detection**: If no `HeartbeatMessage` or `CoordinatorMessage` is received during the initial waiting period, the node assumes no leader exists and becomes eligible for election initiation  \n3. **Randomized Election Start**: To prevent simultaneous elections, each node uses a randomized timeout based on its `NodeID` before transitioning to `StateCandidate` and starting an election\n4. **Concurrent Election Resolution**: Multiple nodes may still initiate elections simultaneously, but the election algorithms (bully or ring) have built-in mechanisms to resolve conflicts and converge on a single leader\n5. **Leader Establishment**: Once a leader emerges and begins sending heartbeats, remaining candidates return to `StateFollower` and the cluster transitions to normal operation\n\nThe randomization strategy typically uses the formula: `baseTimeout + (NodeID % maxJitter)` where `baseTimeout` provides the minimum wait and `maxJitter` spreads election attempts across time to reduce conflicts.\n\n#### Network Partition Recovery\n\nWhen network partitions heal and previously isolated nodes reconnect, the system may discover multiple concurrent leaders or conflicting cluster state. This scenario requires careful coordination to merge the separate partitions while maintaining consistency and avoiding data conflicts that could arise from dual leadership periods.\n\n**Partition Healing Process:**\n\n1. **Partition Detection**: Nodes detect partition healing when they begin receiving messages from previously unreachable nodes, indicated by seeing unfamiliar `NodeID` values or receiving messages with higher term numbers than expected\n2. **Leader Conflict Resolution**: If multiple nodes claim leadership (detected through competing `HeartbeatMessage` broadcasts with different `LeaderID` values), the system initiates a conflict resolution election\n3. **Term Number Comparison**: Nodes compare their current term numbers, with higher terms taking precedence - nodes with lower terms immediately step down and transition to `StateFollower`  \n4. **State Convergence**: The partition with the higher term number (or higher leader ID in case of term ties) becomes authoritative, while other partitions adopt its leadership and term state\n5. **Membership Reconciliation**: The newly unified cluster updates its membership view through the `ClusterMembership.UpdateMembership()` method to reflect all reconnected nodes\n\n> **Decision: Term-Based Partition Resolution**\n> - **Context**: When partitions heal, we need a deterministic way to resolve conflicting leadership claims without requiring complex quorum calculations\n> - **Options Considered**: Term number precedence, timestamp comparison, quorum-based voting\n> - **Decision**: Higher term numbers always take precedence, with NodeID as tiebreaker  \n> - **Rationale**: Term numbers provide a total ordering that prevents cyclic conflicts, and they're monotonically increasing which ensures forward progress\n> - **Consequences**: Enables fast partition healing but requires careful term increment management to avoid overflow\n\n#### Manual Election Triggers\n\nAdministrative scenarios may require manual leader election, such as planned leader migration, load balancing, or maintenance operations. These voluntary elections differ from failure-based elections because the current leader is healthy and can participate in orderly leadership transfer.\n\n**Planned Leadership Transfer:**\n\n1. **Administrative Request**: An operator or management system calls a leadership transfer API on the current leader, specifying an optional preferred successor `NodeID`\n2. **Graceful Transition Initiation**: The current leader stops sending heartbeats and broadcasts a special `CoordinatorMessage` indicating voluntary step-down, including the current term number\n3. **Election Coordination**: The stepping-down leader can either initiate an election itself (ensuring higher-ID nodes participate) or wait for followers to detect the heartbeat cessation and start elections naturally\n4. **Orderly State Transfer**: Unlike failure scenarios, the departing leader remains available to answer queries and transfer any volatile state to the successor before fully stepping down\n5. **Confirmation Phase**: The new leader confirms successful election by broadcasting `HeartbeatMessage` signals, and the old leader transitions permanently to `StateFollower`\n\n### Message Sequence Patterns\n\nThe temporal choreography of leader election becomes visible through message sequence patterns that show how individual component interactions combine to produce system-wide coordination. These patterns reveal the critical timing dependencies, message ordering requirements, and failure recovery flows that make distributed leader election both robust and complex.\n\nEach algorithm creates distinct message flow signatures that help with debugging, performance optimization, and correctness verification. Understanding these patterns is essential for implementing proper timeout handling, detecting election failures, and ensuring the system converges to a stable leadership state under all conditions.\n\n![Bully Algorithm Message Flow](./diagrams/bully-sequence.svg)\n\n#### Bully Algorithm Message Flow\n\nThe bully algorithm creates a competitive message pattern where nodes challenge higher-ID nodes for leadership, creating a natural hierarchy that emerges through process elimination. This produces a distinctive \"challenge-response-victory\" pattern that can be easily traced through network logs and used to verify correct algorithm behavior.\n\n**Complete Bully Election Sequence:**\n\n1. **Election Initiation**: Node detects leader failure and transitions to `StateCandidate`, generating unique election ID and recording current term number for message consistency\n2. **Challenge Phase**: Candidate uses `BullyElection.SendMessage()` to send `ElectionMessage` to all nodes with higher `NodeID` values, starting the competitive challenge process\n3. **Response Collection**: Higher-ID nodes that are alive and reachable respond with `OKMessage`, indicating they are participating and will conduct their own election attempts\n4. **Elimination Decision**: If candidate receives any `OKMessage` responses, it knows higher-ID nodes exist and immediately transitions back to `StateFollower`, abandoning its election attempt  \n5. **Victory Declaration**: If no `OKMessage` responses arrive within the election timeout period, the candidate declares victory and broadcasts `CoordinatorMessage` to all cluster members\n6. **Leadership Confirmation**: The new leader transitions to `StateLeader`, increments the term number, and begins sending periodic `HeartbeatMessage` broadcasts to maintain leadership\n\n**Message Timing and Ordering:**\n\n| Phase | Message Type | Sender | Recipients | Timeout | Success Condition |\n|-------|-------------|--------|------------|---------|------------------|\n| Challenge | `ElectionMessage` | Candidate | Higher-ID nodes | 5-10 seconds | Send to all higher IDs |\n| Response | `OKMessage` | Higher-ID nodes | Candidate | Immediate | Acknowledge within timeout |\n| Victory | `CoordinatorMessage` | Winner | All nodes | Best-effort broadcast | Reach majority of nodes |\n| Maintenance | `HeartbeatMessage` | Leader | All nodes | Every 1-2 seconds | Continuous transmission |\n\nThe bully algorithm's strength lies in its deterministic conflict resolution - exactly one node (the highest responding ID) can win each election. However, this creates cascading elections when higher-ID nodes fail during the election process, potentially leading to multiple sequential elections before stabilizing.\n\n**Cascade Election Scenario:**\n\nConsider a cluster with nodes [1, 2, 3, 4, 5] where node 5 is the failed leader. Node 2 initiates an election and sends `ElectionMessage` to nodes [3, 4, 5]. Node 3 responds with `OKMessage` and starts its own election, sending `ElectionMessage` to nodes [4, 5]. If node 4 then fails during this process, node 3 will timeout and declare victory, broadcasting `CoordinatorMessage` to establish leadership.\n\n#### Ring Election Message Flow  \n\nRing election creates a token-passing pattern where a single election message circulates through the cluster, collecting participant information and enabling distributed leader selection. This produces a more predictable message flow with fewer total messages but requires careful token forwarding logic to handle node failures during circulation.\n\n![Ring Election Token Passing](./diagrams/ring-sequence.svg)\n\n**Complete Ring Election Sequence:**\n\n1. **Token Creation**: Initiating node calls `RingElection.StartElection()`, creates new `RingToken` with unique election ID, and adds its own `NodeID` to the participants list\n2. **Ring Traversal**: Token holder uses `findNextLiveNode()` to locate the next reachable node in ring order and forwards the token using `forwardToken()` method\n3. **Participant Collection**: Each receiving node adds its `NodeID` to the token's participants list and forwards it to the next live node, building a complete view of active cluster members\n4. **Completion Detection**: When the token returns to the original initiator (detected by matching election ID), the ring traversal is complete and leader selection begins\n5. **Leader Selection**: The initiator calls `selectLeaderFromParticipants()` to deterministically choose the highest `NodeID` from the collected participants list  \n6. **Leadership Announcement**: The selected leader broadcasts `CoordinatorMessage` to all participants and begins sending `HeartbeatMessage` signals to maintain leadership\n\n**Ring Token Structure Evolution:**\n\n| Ring Position | Token State | Participants List | Next Action |\n|--------------|-------------|------------------|-------------|\n| Node 3 (initiator) | `{ElectionID: 1001, Participants: [3]}` | [3] | Forward to Node 5 |\n| Node 5 | `{ElectionID: 1001, Participants: [3, 5]}` | [3, 5] | Forward to Node 7 |  \n| Node 7 | `{ElectionID: 1001, Participants: [3, 5, 7]}` | [3, 5, 7] | Forward to Node 1 |\n| Node 1 | `{ElectionID: 1001, Participants: [3, 5, 7, 1]}` | [3, 5, 7, 1] | Forward to Node 3 |\n| Node 3 (completion) | `{ElectionID: 1001, Complete: true}` | [3, 5, 7, 1] | Select leader (7) |\n\nThe ring algorithm's advantage is predictable message complexity - exactly one message per live node, regardless of cluster size. However, it's vulnerable to token loss if the token holder fails during forwarding, requiring timeout-based token regeneration mechanisms.\n\n**Ring Repair During Election:**\n\nWhen a node fails to forward the token within the configured `tokenTimeout`, the previous node detects the failure and uses `findNextLiveNode()` to skip the failed node and continue circulation. This dynamic ring repair ensures elections can complete even during node failures, though it may require multiple timeout periods to bypass multiple consecutive failures.\n\n#### Concurrent Election Resolution\n\nBoth algorithms must handle scenarios where multiple nodes simultaneously initiate elections, either due to simultaneous failure detection or network partition recovery. The message patterns during concurrent elections reveal how the algorithms converge to single leadership despite starting from chaotic initial conditions.\n\n**Concurrent Bully Election Resolution:**\n\nWhen multiple nodes start bully elections simultaneously, their `ElectionMessage` broadcasts overlap and create a complex interaction pattern. However, the algorithm's competitive nature ensures convergence:\n\n1. **Multiple Initiators**: Nodes 2, 3, and 4 all detect leader failure simultaneously and broadcast `ElectionMessage` to higher-ID nodes  \n2. **Cross-Election Interference**: Node 4 receives `ElectionMessage` from both nodes 2 and 3, while also conducting its own election - it responds with `OKMessage` to the lower-ID nodes\n3. **Hierarchical Resolution**: Node 4's responses cause nodes 2 and 3 to abandon their elections, while node 4 continues its own election attempt\n4. **Single Winner Emergence**: Only the highest-ID node (4) reaches the victory timeout without receiving `OKMessage`, leading to deterministic single-leader convergence\n\n**Concurrent Ring Election Resolution:**\n\nRing elections use token-based serialization to prevent conflicts. If multiple nodes attempt to initiate ring elections simultaneously, the conflict resolution depends on timing and token collision handling:\n\n1. **Token Collision Detection**: When a node receives a `RingToken` while conducting its own election, it compares election IDs and timestamps to determine precedence\n2. **Election ID Precedence**: The election with the higher election ID (or earlier timestamp in case of ID collision) takes precedence, while the other is abandoned\n3. **Token Forwarding Decision**: The receiving node abandons its own election, adds itself to the winning token's participants list, and forwards that token instead  \n4. **Single Token Survival**: Eventually only one token continues circulating, ensuring deterministic single-leader election completion\n\n> **Critical Design Insight:** Both algorithms achieve safety (never elect multiple leaders) through different mechanisms - bully uses competitive elimination while ring uses token serialization. However, both rely on deterministic tie-breaking (higher NodeID wins) to ensure consistent outcomes.\n\n### Leader Responsibilities\n\nOnce elected, the leader assumes specific operational responsibilities that extend beyond the election process itself. These responsibilities define what leadership actually means in practical terms and determine the value that leader election provides to the overall distributed system. Understanding leader duties is crucial because election algorithm choice often depends on how well it supports these ongoing leadership functions.\n\nThe leader's role transforms from a participant in distributed coordination to the central coordinator itself. This transition requires careful state management, failure monitoring, and graceful handling of the inevitable leadership transitions that occur due to failures, network issues, or administrative actions.\n\n#### Heartbeat and Liveness Maintenance\n\nThe leader's primary responsibility is proving its continued availability and operational capacity to the rest of the cluster. This heartbeat mechanism serves dual purposes: preventing unnecessary elections due to temporary communication delays, and enabling fast failure detection when the leader actually fails.\n\n**Leader Heartbeat Protocol:**\n\n1. **Periodic Transmission**: Leader calls `FailureDetector.StartHeartbeats()` to begin sending `HeartbeatMessage` broadcasts every configured interval (typically 1-2 seconds)  \n2. **Cluster-wide Distribution**: Each heartbeat uses `Transport.BroadcastMessage()` to reach all active cluster members, including recently joined nodes discovered through membership updates\n3. **Term and Timestamp Inclusion**: Heartbeats contain the current leadership term and precise timestamp, allowing followers to detect stale messages and verify leadership legitimacy\n4. **Response Monitoring**: While heartbeats are typically one-way messages, the leader monitors cluster responses and election messages to detect challenges to its authority\n5. **Graceful Degradation**: If the leader detects its own network isolation (inability to reach majority of cluster), it voluntarily steps down to prevent split-brain scenarios\n\nThe heartbeat interval creates a fundamental trade-off between network overhead and failure detection speed. More frequent heartbeats enable faster failure detection but consume more bandwidth and processing resources. Most systems use adaptive intervals that increase during stable periods and decrease during cluster instability.\n\n**Heartbeat Timing Strategy:**\n\n| Cluster State | Heartbeat Interval | Rationale | Detection Time |\n|--------------|-------------------|-----------|----------------|  \n| Stable Operation | 2-3 seconds | Minimize network overhead | 6-9 seconds |\n| Recent Election | 0.5-1 seconds | Establish leadership quickly | 1.5-3 seconds |\n| Network Issues | 1-1.5 seconds | Balance detection vs storms | 3-4.5 seconds |\n| High Load | 3-5 seconds | Reduce system overhead | 9-15 seconds |\n\n#### Membership Management and Discovery\n\nLeaders often serve as the authoritative source of cluster membership information, tracking which nodes are active, handling join/leave operations, and coordinating membership changes across the distributed system. This responsibility requires careful synchronization to prevent split-brain scenarios and ensure consistent membership views.\n\n**Cluster Membership Coordination:**\n\n1. **Join Request Processing**: When new nodes attempt to join, they typically contact the current leader first, which validates the request and updates the authoritative membership list\n2. **Membership Propagation**: Leader broadcasts membership changes to all existing cluster members using specialized messages or piggybacked on regular heartbeats  \n3. **Leave Coordination**: For graceful node departures, the leader processes explicit leave requests and removes the node from active membership before notifying other cluster members\n4. **Failure-based Removal**: When the leader detects node failures through its own failure detection mechanisms, it removes failed nodes from membership and propagates the updates\n5. **Split-brain Prevention**: Before making membership changes, the leader verifies it can reach a majority of the last known cluster to ensure it hasn't been network-partitioned\n\nThe membership management creates interesting bootstrapping challenges - new nodes need to contact the leader to join, but they need cluster membership information to find the leader. This typically requires either static configuration of seed nodes or multicast-based leader discovery protocols.\n\n#### Application-Specific Coordination\n\nBeyond the basic election infrastructure, leaders typically coordinate application-specific distributed operations such as distributed transactions, resource allocation, task scheduling, or data partitioning. These responsibilities depend entirely on the specific distributed system being built, but they share common patterns that influence election algorithm choice.\n\n**Common Leadership Coordination Patterns:**\n\n1. **Centralized Decision Making**: Leader makes global decisions (like resource allocation or task assignment) and propagates the results to followers, providing strong consistency at the cost of leader bottlenecks\n2. **Distributed Coordination**: Leader orchestrates multi-node protocols (like two-phase commit) by serving as the coordinator/initiator while actual work occurs across multiple nodes  \n3. **Conflict Resolution**: Leader resolves conflicts that arise from concurrent operations across the distributed system, such as conflicting resource requests or overlapping task assignments\n4. **State Synchronization**: Leader maintains authoritative versions of critical shared state and ensures followers remain synchronized through replication or periodic updates\n5. **External Interface**: Leader serves as the single point of contact for external clients or systems, providing a consistent interface despite internal cluster changes\n\n**Leadership Transition Considerations:**\n\n| Coordination Type | State Transfer Needs | Transition Complexity | Recovery Requirements |\n|------------------|---------------------|---------------------|----------------------|\n| Stateless Coordination | Minimal - just current term | Low - new leader starts fresh | Fast - immediate availability |\n| In-memory State | Full state snapshot | Medium - requires state sync | Medium - must rebuild state |  \n| Persistent Coordination | Transaction logs + checkpoints | High - complex recovery | Slow - must replay operations |\n| External Contracts | Client connection migration | Very High - external coordination | Variable - depends on clients |\n\n#### Graceful Leadership Transitions\n\nPerhaps the most critical leadership responsibility is handling the inevitable end of leadership gracefully. Leaders fail, get partitioned, or need to step down for administrative reasons. How well they handle these transitions determines the overall availability and consistency of the distributed system.\n\n**Voluntary Step-down Process:**\n\n1. **Pre-transition Preparation**: Leader completes any in-flight operations, flushes pending state changes, and ensures cluster is in a consistent state before beginning transition\n2. **Successor Coordination**: If possible, leader coordinates with a preferred successor (often the highest-ID remaining node) to transfer critical state and responsibilities  \n3. **Graceful Heartbeat Cessation**: Leader stops sending heartbeats and may broadcast an explicit step-down message to trigger immediate new elections rather than waiting for timeout\n4. **State Transfer**: Leader remains available briefly to answer queries and transfer volatile state to the successor, ensuring continuity of critical operations\n5. **Final Transition**: Leader transitions to `StateFollower` and begins participating in the new election as a regular cluster member\n\n**Failure-based Transition Handling:**\n\nWhen leaders fail ungracefully, the transition responsibility shifts to the followers and the new leader. The election algorithms handle leader selection, but application-specific state recovery often requires additional mechanisms:\n\n1. **State Recovery**: New leader must reconstruct any volatile state the previous leader maintained, either from persistent storage, follower replicas, or by rebuilding from first principles\n2. **Operation Continuity**: New leader determines which operations were in-progress when the previous leader failed and decides whether to complete, retry, or abort them\n3. **Client Notification**: External clients must be notified of leadership changes and potentially redirected to the new leader endpoint\n4. **Consistency Verification**: New leader validates that cluster state is consistent and initiates any necessary repair operations to resolve conflicts or missing data\n\n> **Decision: Leadership Handoff Protocol**  \n> - **Context**: Leaders must transfer responsibilities during both planned and unplanned transitions while maintaining system availability\n> - **Options Considered**: Immediate cutoff, overlapping leadership period, state transfer protocol\n> - **Decision**: Brief overlapping period where old leader remains available for queries while new leader assumes active duties  \n> - **Rationale**: Enables state transfer while preventing dual leadership conflicts through role separation (read-only old leader, active new leader)\n> - **Consequences**: Slightly more complex transition logic but dramatically improves continuity and reduces state loss\n\n### Common Pitfalls\n\nUnderstanding system interactions reveals several critical pitfalls that can undermine the entire leader election system, even when individual components work correctly. These interaction-level failures are often the most difficult to debug because they emerge from timing dependencies and distributed state inconsistencies rather than simple coding errors.\n\n⚠️ **Pitfall: Election Storm Cascades**  \nMultiple nodes detect failure simultaneously and initiate overlapping elections, creating a cascade where each election interferes with others, preventing convergence. This happens when failure detection timeouts are too aggressive or when network partitions heal suddenly. **Fix:** Implement randomized election delays based on NodeID and use exponential backoff for repeated election failures. Monitor election frequency and tune timeout parameters based on actual network conditions.\n\n⚠️ **Pitfall: Split-brain During Partition Healing**  \nWhen network partitions heal, both sides may have elected leaders and continue operating independently, leading to conflicting decisions and data inconsistency. **Why it's wrong:** Multiple leaders can make conflicting decisions about resource allocation, task assignment, or data modifications. **Fix:** Use term numbers for conflict resolution - higher terms always win. Implement quorum requirements so partitioned groups cannot elect leaders without majority membership.\n\n⚠️ **Pitfall: Leader Election Success but No Heartbeats**  \nElection completes successfully and new leader is chosen, but leader fails to start heartbeat transmission due to configuration errors, resource exhaustion, or implementation bugs. Followers detect this as another leader failure and initiate new elections immediately. **Fix:** Verify heartbeat transmission is working before declaring election success. Add health checks that verify leader can actually perform its duties, not just win elections.\n\n⚠️ **Pitfall: Message Ordering Violations**  \nElection messages arrive out of order due to network delays, causing nodes to process CoordinatorMessage before ElectionMessage, leading to inconsistent election state and potential dual leadership claims. **Fix:** Include sequence numbers or timestamps in all election messages. Implement message buffering and ordering logic to process messages in logical order rather than arrival order.\n\n⚠️ **Pitfall: Incomplete State Transfer During Leadership Change**  \nNew leader begins operation before fully receiving state from previous leader, making decisions based on incomplete information and potentially conflicting with the previous leader's final actions. **Fix:** Implement atomic state transfer protocols with confirmation mechanisms. Use versioned state so new leader can detect incomplete transfers and request missing information.\n\n### Implementation Guidance\n\nThe system interactions layer sits above individual components but below application logic, orchestrating the complete election protocols from trigger events through leader establishment. This guidance provides the coordination infrastructure that sequences component operations into working distributed protocols.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Event Coordination | Go channels with select statements | Event bus with typed message routing |\n| State Machine | Simple enum with switch/case | Formal state machine library (fsm) |\n| Message Sequencing | In-memory queues with goroutines | Persistent message queue (NATS, Redis) |\n| Election Orchestration | Direct method calls with timeouts | Workflow engine (Temporal, Cadence) |\n| Timing Control | time.Timer with context cancellation | Configurable timer wheels |\n| Concurrency Control | sync.RWMutex for state protection | Software transactional memory |\n\n#### Recommended File Structure\n\n```\ninternal/coordinator/\n  coordinator.go              ← Main election coordinator\n  election_triggers.go        ← Failure detection and trigger logic  \n  message_sequencer.go        ← Message ordering and processing\n  state_machine.go           ← Node state transitions\n  leadership_manager.go       ← Leader duties and responsibilities\n  coordinator_test.go        ← Integration tests for full flows\n  \ninternal/scenarios/\n  startup_test.go            ← Bootstrap election scenarios\n  failure_test.go            ← Leader failure and recovery tests  \n  partition_test.go          ← Network partition simulation\n  concurrent_test.go         ← Multiple simultaneous elections\n```\n\n#### Election Coordinator Infrastructure\n\nThis component orchestrates the complete election process from trigger through leader establishment:\n\n```go\n// ElectionCoordinator manages the complete leader election lifecycle,\n// coordinating between failure detection, algorithm execution, and leadership duties.\ntype ElectionCoordinator struct {\n    nodeID       NodeID\n    currentState *ElectionState\n    transport    Transport\n    membership   *ClusterMembership\n    \n    // Algorithm implementations\n    bullyElection *BullyElection\n    ringElection  *RingElection\n    \n    // Infrastructure\n    failureDetector *FailureDetector\n    stateMachine    *ElectionStateMachine\n    messageSequencer *MessageSequencer\n    \n    // Configuration\n    config ElectionConfig\n    \n    // Channels for coordination\n    triggerChan   chan ElectionTrigger\n    messageChan   chan *Message  \n    stateChan     chan StateTransition\n    shutdownChan  chan struct{}\n    \n    mu sync.RWMutex\n}\n\n// ElectionTrigger represents events that can initiate leader elections\ntype ElectionTrigger struct {\n    Type      TriggerType\n    NodeID    NodeID      // Failed leader or trigger source\n    Timestamp int64\n    Context   map[string]interface{} // Additional trigger context\n}\n\nconst (\n    TriggerLeaderFailure TriggerType = iota\n    TriggerStartup\n    TriggerPartitionHealing  \n    TriggerManualElection\n    TriggerTermConflict\n)\n\n// StartElectionCoordinator initializes and starts the complete election system\nfunc (ec *ElectionCoordinator) StartElectionCoordinator() error {\n    // TODO 1: Initialize all component connections (transport, membership, failure detector)\n    // TODO 2: Start background goroutines for trigger processing and message handling  \n    // TODO 3: Begin failure detection and heartbeat monitoring\n    // TODO 4: Check for existing cluster and determine initial state (bootstrap vs join)\n    // TODO 5: Start main coordination loop that processes triggers and coordinates elections\n    // Hint: Use select statement to handle multiple channel inputs simultaneously\n}\n\n// ProcessElectionTrigger handles different trigger scenarios and initiates appropriate elections\nfunc (ec *ElectionCoordinator) ProcessElectionTrigger(trigger ElectionTrigger) error {\n    // TODO 1: Validate trigger is appropriate for current node state (followers can initiate, leaders cannot)\n    // TODO 2: Choose election algorithm based on configuration and cluster conditions\n    // TODO 3: Update local state to candidate and increment term number  \n    // TODO 4: Call appropriate algorithm's StartElection() method\n    // TODO 5: Start election timeout to handle failures and declare victory\n    // Hint: Different trigger types may require different pre-election setup\n}\n```\n\n#### Message Sequence Controller\n\nCoordinates the temporal aspects of election protocols:\n\n```go\n// MessageSequencer ensures proper ordering and timing of election messages\ntype MessageSequencer struct {\n    nodeID        NodeID\n    transport     Transport\n    \n    // Message ordering\n    incomingQueue chan *Message\n    processingQueue chan *Message  \n    sequenceNumbers map[NodeID]uint64\n    \n    // Timing control\n    timeouts      map[string]*time.Timer\n    intervals     map[string]*time.Ticker\n    \n    mu sync.RWMutex\n}\n\n// SequenceElectionMessages coordinates the complete message flow for an election\nfunc (ms *MessageSequencer) SequenceElectionMessages(algorithm string, electionID uint64) error {\n    // TODO 1: Create sequence tracking for this election ID\n    // TODO 2: Set up appropriate timeouts based on algorithm type (bully vs ring)\n    // TODO 3: Begin message processing loop that handles ordering and timing\n    // TODO 4: Coordinate with election algorithm to send messages at proper times  \n    // TODO 5: Handle timeout events and trigger appropriate responses\n    // Hint: Bully and ring algorithms have very different timing requirements\n}\n\n// ProcessIncomingMessage handles message ordering and delivers to appropriate handlers  \nfunc (ms *MessageSequencer) ProcessIncomingMessage(msg *Message) error {\n    // TODO 1: Check message sequence number against expected order\n    // TODO 2: Buffer out-of-order messages for later processing\n    // TODO 3: Deliver in-order messages to appropriate election algorithm\n    // TODO 4: Update sequence tracking and release any buffered messages that are now in order\n    // TODO 5: Handle duplicate messages and expired/stale messages\n    // Hint: Use msg.Timestamp and msg.Term to detect stale messages\n}\n```\n\n#### Leadership Manager\n\nHandles leader responsibilities and transitions:\n\n```go\n// LeadershipManager implements the ongoing duties of elected leaders\ntype LeadershipManager struct {\n    nodeID      NodeID\n    transport   Transport\n    membership  *ClusterMembership\n    \n    // Leader duties\n    heartbeatTicker *time.Ticker\n    membershipVersion uint64\n    \n    // State management  \n    isLeader     bool\n    currentTerm  uint64\n    leaderSince  time.Time\n    \n    // Application coordination (extensible)\n    coordinationHandlers map[string]CoordinationHandler\n    \n    mu sync.RWMutex\n}\n\n// AssumeLeadership transitions this node to leader and begins leader duties\nfunc (lm *LeadershipManager) AssumeLeadership(term uint64, electionID uint64) error {\n    // TODO 1: Verify this node should actually become leader (election was successful)\n    // TODO 2: Update local state to leader and record leadership term\n    // TODO 3: Broadcast initial CoordinatorMessage to establish leadership\n    // TODO 4: Start heartbeat transmission to maintain leadership  \n    // TODO 5: Initialize any application-specific coordination duties\n    // Hint: Leadership transition should be atomic - either fully successful or fully rolled back\n}\n\n// StepDown gracefully transitions away from leadership\nfunc (lm *LeadershipManager) StepDown(reason string) error {  \n    // TODO 1: Stop all leader duties (heartbeats, coordination tasks)\n    // TODO 2: Complete or abort any in-flight operations\n    // TODO 3: Transfer critical state to successor if known\n    // TODO 4: Broadcast step-down notification to trigger new elections\n    // TODO 5: Transition to follower state and clear leadership state\n    // Hint: Graceful step-down should prevent unnecessary election delays\n}\n\n// SendHeartbeat broadcasts leader aliveness to all cluster members\nfunc (lm *LeadershipManager) SendHeartbeat() error {\n    // TODO 1: Create HeartbeatMessage with current term and timestamp\n    // TODO 2: Include current membership version for follower synchronization\n    // TODO 3: Broadcast heartbeat to all active cluster members  \n    // TODO 4: Monitor for election challenges or network partition indicators\n    // TODO 5: Handle heartbeat failures by stepping down if majority unreachable\n    // Hint: Heartbeat failures may indicate this node is network partitioned\n}\n```\n\n#### Integration Testing Framework\n\nComplete election scenarios require multi-node testing infrastructure:\n\n```go\n// ElectionScenarioTest provides infrastructure for testing complete election flows\ntype ElectionScenarioTest struct {\n    nodes      map[NodeID]*ElectionCoordinator\n    transport  *TestTransport  // Simulated network with failure injection\n    timeline   *TestTimeline  // Controlled time progression\n    \n    // Scenario control\n    partitions map[NodeID][]NodeID  // Network partition simulation\n    failures   map[NodeID]time.Time // Scheduled node failures\n    \n    // Verification\n    electionHistory []ElectionEvent\n    leaderHistory   []LeadershipEvent\n    messageLog      []MessageEvent\n}\n\n// TestBootstrapElection verifies startup election scenarios\nfunc TestBootstrapElection(t *testing.T) {\n    // TODO 1: Create cluster of 5 nodes in shutdown state\n    // TODO 2: Start nodes with randomized delays to simulate real startup\n    // TODO 3: Verify exactly one leader emerges within expected timeframe  \n    // TODO 4: Confirm all nodes recognize the same leader\n    // TODO 5: Validate heartbeat transmission begins and is received by all nodes\n    // Expected: Single leader elected within 10 seconds, all nodes converged\n}\n\n// TestConcurrentFailureDetection verifies multiple simultaneous election triggers  \nfunc TestConcurrentFailureDetection(t *testing.T) {\n    // TODO 1: Establish stable cluster with known leader\n    // TODO 2: Simulate leader failure that's detected simultaneously by multiple followers\n    // TODO 3: Verify election algorithms resolve concurrent elections correctly\n    // TODO 4: Confirm exactly one new leader emerges despite multiple initiators\n    // TODO 5: Validate cluster returns to stable state with proper heartbeat resumption\n    // Expected: New leader elected within 15 seconds despite concurrent elections\n}\n\n// TestPartitionHealing verifies split-brain prevention during network recovery\nfunc TestPartitionHealing(t *testing.T) {\n    // TODO 1: Create network partition splitting cluster into two groups  \n    // TODO 2: Allow each partition to elect separate leaders\n    // TODO 3: Simulate partition healing by restoring network connectivity\n    // TODO 4: Verify conflict resolution produces single authoritative leader\n    // TODO 5: Confirm losing partition's leader steps down gracefully\n    // Expected: Higher-term leader wins, lower-term leader steps down immediately\n}\n```\n\n#### Milestone Checkpoints\n\n**Milestone Integration Verification:**\n- **Command**: `go test ./internal/coordinator/... -v -timeout=60s`\n- **Expected Output**: All election scenario tests pass, showing bootstrap elections complete in <10 seconds, concurrent elections resolve to single leader, partition healing prevents split-brain\n- **Manual Verification**: Start 3-node cluster, kill leader, verify new leader elected within timeout period and begins heartbeats\n- **Failure Signs**: Multiple concurrent leaders, election timeouts, nodes stuck in candidate state, missing heartbeats after election\n\n**Performance Validation:**\n- **Bootstrap Election**: 5-node cluster should elect leader within 10 seconds of startup\n- **Leader Failure Recovery**: New leader should emerge within 15 seconds of failure detection  \n- **Message Overhead**: Election should require <20 messages total for 5-node bully election\n- **Heartbeat Stability**: Leader heartbeats should maintain <1 second jitter in stable conditions\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** All milestones - comprehensive failure scenarios, detection strategies, and recovery mechanisms that apply across node communication (Milestone 1), bully election (Milestone 2), and ring election (Milestone 3)\n\nDistributed leader election systems operate in an inherently unreliable environment where nodes crash, networks partition, and messages get lost or delayed. The robustness of a leader election implementation depends entirely on how well it handles these failure scenarios. Unlike centralized systems where failures are typically binary (the system works or it doesn't), distributed systems must continue operating correctly even when some components fail, while preventing catastrophic scenarios like multiple simultaneous leaders.\n\nThe challenge lies in the **fundamental impossibility of distinguishing between a slow node and a failed node** in asynchronous distributed systems. When Node A doesn't respond to Node B's message, it could mean Node A crashed, the network dropped the message, Node A is temporarily overloaded, or the network has partitioned the cluster. Each scenario requires different handling strategies, yet they're often indistinguishable from the perspective of the detecting node.\n\nThis section provides a comprehensive taxonomy of failure modes, detection strategies, and recovery mechanisms that ensure the leader election system maintains correctness guarantees even under adverse conditions. We'll explore how different failure types impact election algorithms, examine the dreaded split-brain scenario in detail, and establish robust recovery mechanisms that restore system health automatically.\n\n### Failure Taxonomy\n\nUnderstanding the different categories of failures and their specific impacts on leader election is crucial for building robust handling mechanisms. Each failure type has distinct characteristics, detection methods, and recovery strategies.\n\n![Failure Detection and Recovery Flow](./diagrams/failure-detection-flow.svg)\n\n#### Node Failures\n\n**Crash Failures** represent the most straightforward failure mode where a node stops executing completely. The node halts all processing, stops sending messages, and becomes completely unresponsive. From the cluster's perspective, the node simply vanishes without any notification.\n\n| Failure Aspect | Description | Impact on Elections |\n|-----------------|-------------|-------------------|\n| Detection Method | Heartbeat timeouts, unresponsive to messages | Reliable detection after timeout period |\n| Recovery Required | Remove from cluster membership, trigger election if leader | Clean - no partial state issues |\n| Bully Algorithm Impact | Higher-ID crashed nodes won't respond with `MsgOK` | Lower-ID nodes can safely claim leadership |\n| Ring Algorithm Impact | Token forwarding fails at crashed node position | Requires ring repair and token re-routing |\n| False Positive Risk | Low - sustained unresponsiveness indicates real failure | Timeout tuning prevents premature detection |\n\n**Byzantine Failures** involve nodes that behave arbitrarily - they might send contradictory messages, claim to be different nodes, or actively try to disrupt elections. While our implementation doesn't include full Byzantine fault tolerance, we must handle basic malicious behavior.\n\n| Byzantine Behavior | Detection Strategy | Mitigation Approach |\n|-------------------|-------------------|-------------------|\n| Duplicate Node IDs | Track unique node addresses per ID | Reject messages from duplicate IDs |\n| Invalid Message Content | Validate message structure and constraints | Drop malformed messages, don't respond |\n| Conflicting Leadership Claims | Track term numbers and election IDs | Accept only higher term numbers |\n| Message Replay Attacks | Include timestamps and sequence numbers | Reject old or duplicate messages |\n| Election Disruption | Monitor election completion rates | Rate limit election messages per node |\n\n**Performance Degradation Failures** occur when nodes become extremely slow but don't crash completely. These are particularly dangerous because the node appears alive but can't participate effectively in time-sensitive election protocols.\n\n> **Key Insight**: Performance degradation is often harder to handle than complete crashes because the node appears partially functional, leading to inconsistent behavior across different election phases.\n\n#### Network Failures\n\n**Message Loss** happens when individual messages fail to reach their destination due to network congestion, hardware failures, or routing issues. Unlike node crashes, message loss is often sporadic and affects only some communications.\n\n| Message Type | Loss Impact | Recovery Mechanism |\n|--------------|-------------|-------------------|\n| `MsgElection` | Candidate may timeout without responses | Retry election after timeout |\n| `MsgOK` | Candidate may falsely claim leadership | Higher-ID nodes will send `MsgCoordinator` to correct |\n| `MsgCoordinator` | Nodes may not recognize new leader | Periodic heartbeat will establish leadership |\n| `MsgHeartbeat` | False failure detection of leader | Multiple missed heartbeats before declaring failure |\n| `MsgRingToken` | Ring election stalls at token holder | Token timeout triggers new token generation |\n\n**Message Delays** cause messages to arrive significantly later than expected, potentially after election timeouts have expired. This can lead to overlapping elections and temporary confusion about cluster leadership.\n\n**Network Partitions** split the cluster into isolated groups that cannot communicate with each other. This is the most complex failure scenario because each partition may attempt to elect its own leader, leading to potential split-brain situations.\n\n| Partition Scenario | Cluster View | Election Behavior | Resolution Strategy |\n|-------------------|--------------|-------------------|-------------------|\n| Clean Split (50/50) | Two equal partitions | Both attempt leadership | Quorum requirements prevent dual leaders |\n| Majority/Minority | One large, one small partition | Only majority should elect leader | Minority partition remains leaderless |\n| Multiple Fragments | Several small partitions | No partition should elect leader | Wait for partition healing |\n| Temporary Isolation | Node briefly disconnected | Node may attempt unnecessary election | Rejoin existing leadership |\n\n> **Design Principle**: In network partition scenarios, it's better to have no leader than multiple leaders. A leaderless cluster can resume operations once connectivity is restored, but resolving split-brain requires complex state reconciliation.\n\n#### Timing Failures\n\n**Clock Skew** occurs when different nodes have significantly different system times. While our election algorithms don't rely heavily on synchronized time, clock differences can cause issues with timeout management and message ordering.\n\n**Timeout Failures** happen when election timeouts are either too short (causing premature failure detection) or too long (delaying necessary elections). Finding the right balance requires understanding network characteristics and node performance.\n\n| Timeout Type | Too Short Impact | Too Long Impact | Tuning Strategy |\n|--------------|------------------|-----------------|-----------------|\n| Election Timeout | Frequent unnecessary elections | Slow failure recovery | 3-5x typical message round-trip time |\n| Heartbeat Interval | High network overhead | Delayed failure detection | Balance between overhead and responsiveness |\n| Ring Token Timeout | Premature token regeneration | Stalled elections with failed nodes | 2x ring traversal time estimate |\n| Membership Update | Stale member views | Slow cluster adaptation | Based on typical join/leave frequency |\n\n#### State Corruption Failures\n\n**Inconsistent Election State** can occur when nodes have different views of the current election term, active election ID, or current leader. This often results from message loss during critical election phases.\n\n**Term Number Conflicts** happen when nodes disagree about the current election term, potentially accepting leadership claims from outdated elections or rejecting valid new elections.\n\n| State Inconsistency | Symptoms | Detection Method | Recovery Approach |\n|-------------------|----------|------------------|-------------------|\n| Stale Leader View | Node sends messages to wrong leader | Heartbeat responses include correct leader | Update local leadership view |\n| Term Regression | Node accepts lower-term leadership | Compare term numbers in all messages | Reject lower terms, update to higher |\n| Duplicate Election IDs | Multiple elections with same ID active | Track election ID uniqueness | Use timestamp-based election ID generation |\n| Membership Drift | Nodes have different member lists | Compare membership in heartbeat messages | Periodic membership synchronization |\n\n> **Architecture Decision: Term-Based Ordering**\n> - **Context**: Need to order elections and detect stale leadership claims\n> - **Options Considered**: Timestamp-based ordering, vector clocks, monotonic term counters\n> - **Decision**: Monotonic term counters incremented with each election\n> - **Rationale**: Simple to implement, doesn't require clock synchronization, provides total ordering\n> - **Consequences**: Enables detection of stale messages and conflicting leadership claims\n\n### Split-Brain Scenarios\n\nSplit-brain represents the most dangerous failure scenario in leader election systems. When network partitions divide the cluster, each partition may independently elect a leader, resulting in multiple nodes simultaneously believing they are the cluster coordinator. This violates the fundamental safety property of leader election and can lead to data corruption, conflicting decisions, and system inconsistency.\n\n![Split-Brain Prevention](./diagrams/network-partition-scenario.svg)\n\n#### Understanding Split-Brain Formation\n\nSplit-brain scenarios emerge through a predictable sequence of events. Initially, a healthy cluster operates with a single elected leader coordinating all operations. When a network partition occurs, the cluster splits into isolated groups that cannot communicate with each other. Each partition, unable to contact the original leader (who may be in a different partition), assumes leadership failure and initiates new elections.\n\n**Classic Split-Brain Sequence:**\n\n1. **Healthy State**: Five-node cluster (IDs 1, 3, 5, 7, 9) with Node 9 as elected leader\n2. **Partition Formation**: Network failure splits cluster into Partition A (nodes 1, 3, 5) and Partition B (nodes 7, 9)\n3. **Leadership Ambiguity**: Partition A loses contact with leader Node 9, assumes it failed\n4. **Concurrent Elections**: Partition A elects Node 5 as leader, while Node 9 remains leader in Partition B  \n5. **Split-Brain State**: Two nodes (5 and 9) simultaneously believe they are cluster leaders\n6. **Conflicting Operations**: Both leaders make independent decisions, potentially causing data inconsistency\n\n#### Split-Brain Prevention Mechanisms\n\n**Quorum-Based Leadership** requires a leader to maintain contact with a majority of the original cluster members to retain leadership authority. This prevents minority partitions from electing leaders while allowing majority partitions to continue operations.\n\n| Cluster Size | Quorum Size | Partition Tolerance | Maximum Failures |\n|--------------|-------------|-------------------|------------------|\n| 3 nodes | 2 nodes | Can lose 1 node | 1 node failure |\n| 5 nodes | 3 nodes | Can lose 2 nodes | 2 node failures |\n| 7 nodes | 4 nodes | Can lose 3 nodes | 3 node failures |\n| 9 nodes | 5 nodes | Can lose 4 nodes | 4 node failures |\n\nThe quorum mechanism works by requiring any node claiming leadership to demonstrate communication with at least `(cluster_size / 2) + 1` nodes. During elections, candidates must receive acknowledgments from a quorum before claiming victory. Similarly, existing leaders must maintain heartbeat communication with a quorum to retain authority.\n\n**Partition Size Detection** allows each partition to assess its own size relative to the original cluster configuration. Partitions that represent less than a majority of the original cluster voluntarily refrain from electing leaders.\n\n```\nPartition Leadership Decision Algorithm:\n1. Count nodes reachable in current partition\n2. Compare to original cluster size from configuration  \n3. If partition_size > (original_cluster_size / 2):\n   - Proceed with leader election\n4. If partition_size <= (original_cluster_size / 2):\n   - Enter read-only mode, do not elect leader\n   - Continue attempting to contact other partitions\n```\n\n**Leader Validation During Elections** requires election winners to validate their leadership with a quorum before assuming coordinator responsibilities. This prevents leaders elected in minority partitions from making cluster decisions.\n\n| Election Phase | Validation Requirement | Failure Handling |\n|----------------|------------------------|------------------|\n| Vote Collection | Receive responses from quorum of nodes | Restart election if insufficient responses |\n| Leadership Claim | Confirm leadership with quorum via heartbeat | Step down if quorum not maintained |\n| Operation Execution | Validate quorum before each major decision | Delay operations until quorum restored |\n| Term Advancement | Only advance term if quorum agrees | Prevent term conflicts across partitions |\n\n#### Split-Brain Detection Strategies\n\n**Heartbeat-Based Detection** monitors whether the current leader can maintain communication with a quorum of cluster members. Leaders that lose quorum contact automatically step down to prevent operating in a minority partition.\n\n**Cross-Partition Communication Attempts** involve nodes periodically trying to contact members from the original cluster configuration, even if they're not currently reachable. When communication is restored, nodes can detect conflicting leadership claims.\n\n**Term Number Monitoring** tracks election term numbers across all received messages. When a node receives a message with a higher term than its local view, it indicates that another partition may have conducted elections.\n\n| Detection Signal | Interpretation | Required Action |\n|-----------------|----------------|-----------------|\n| Heartbeat to non-quorum | Leader in minority partition | Step down from leadership |\n| Higher term in message | Another partition elected leader | Update local term, accept new leadership |\n| Conflicting coordinator claims | Multiple active leaders detected | Initiate conflict resolution protocol |\n| Membership inconsistency | Partitions have different member views | Synchronize membership information |\n\n#### Conflict Resolution Protocols\n\nWhen split-brain is detected (typically during partition healing), the system must safely resolve conflicting leadership claims and restore single-leader operation.\n\n**Term-Based Resolution** uses election term numbers to determine which leader has authority. The leader elected in the highest-numbered term retains leadership, while others step down.\n\n**Node ID Tiebreaking** handles cases where multiple partitions elected leaders in the same term (rare but possible during rapid partition/healing cycles). The leader with the highest node ID retains authority.\n\n**Graceful Step-Down Process** ensures that demoted leaders safely transfer any pending operations to the winning leader rather than simply stopping.\n\n```\nSplit-Brain Resolution Steps:\n1. Detection: Node receives coordinator message with higher/equal term from different leader\n2. Term Comparison: Compare election terms of conflicting leaders\n3. Leader Selection: Higher term wins; if equal terms, higher node ID wins  \n4. Step-Down: Losing leader(s) transition to follower state\n5. State Transfer: Losing leaders send any pending operations to winner\n6. Acknowledgment: Winning leader confirms receipt and takes full authority\n7. Broadcast: New leader announces resolution to entire cluster\n```\n\n> **Common Pitfall**: **Immediate Step-Down Without State Transfer**\n> \n> When resolving split-brain, developers often implement leaders that immediately step down upon detecting a conflict, without transferring their pending state. This can lead to lost operations that were initiated during the partition.\n> \n> **Why it's wrong**: Operations started by the stepping-down leader may be partially complete, and simply abandoning them can leave the system in an inconsistent state.\n> \n> **How to fix**: Implement a graceful step-down process where the demoted leader sends its pending operations to the winning leader, waits for acknowledgment, and only then transitions to follower state.\n\n### Failure Recovery Mechanisms\n\nRobust failure recovery ensures that the leader election system automatically detects failures, adapts to new conditions, and restores normal operation without manual intervention. Recovery mechanisms must handle not just the immediate failure, but also the cascading effects and potential race conditions that arise during the recovery process.\n\n#### Leader Failure Recovery\n\n**Failure Detection Triggers** initiate the recovery process when the current leader becomes unresponsive or unreachable. The detection mechanism must be sensitive enough to quickly identify real failures while avoiding false positives that cause unnecessary elections.\n\n| Detection Method | Trigger Condition | False Positive Risk | Recovery Time |\n|------------------|-------------------|-------------------|---------------|\n| Heartbeat Timeout | No heartbeat for N intervals | Network congestion, leader overload | N * heartbeat_interval |\n| Message Unresponsiveness | Leader doesn't respond to direct messages | Message loss, temporary partitions | Message timeout duration |\n| Membership Updates | Other nodes report leader as unreachable | Network asymmetry, timing issues | Membership update frequency |\n| Administrative Trigger | Manual failure detection command | Human error, premature intervention | Immediate |\n\nThe `FailureDetector` component implements a **graduated suspicion mechanism** that prevents premature failure declarations. Rather than immediately declaring a leader failed after one missed heartbeat, it tracks suspicion levels and only triggers recovery after sustained evidence of failure.\n\n```\nGraduated Suspicion Algorithm:\n1. Initialize suspicion_level = 0 for all nodes\n2. On missed heartbeat: increment suspicion_level for leader\n3. On successful heartbeat: reset suspicion_level to 0 for leader  \n4. If suspicion_level >= failure_threshold:\n   - Declare leader failed\n   - Trigger election recovery process\n5. Include suspicion levels in membership updates to other nodes\n```\n\n**Election Initiation Process** begins once leader failure is confirmed. The process varies between bully and ring algorithms but follows similar principles of ensuring orderly recovery.\n\nFor **Bully Algorithm Recovery**:\n\n1. **Failure Confirmation**: Multiple nodes may simultaneously detect leader failure\n2. **Election Rights Assessment**: Each detecting node checks if it has the right to initiate election (typically all nodes can)\n3. **Concurrent Election Handling**: Multiple nodes may start elections simultaneously - this is acceptable in bully algorithm\n4. **Higher-ID Precedence**: Lower-ID nodes will receive `MsgOK` responses and defer to higher-ID candidates\n5. **Coordinator Emergence**: Highest-ID responding node becomes new leader\n\nFor **Ring Algorithm Recovery**:\n\n1. **Token Holder Identification**: Determine which node should initiate ring election (typically node detecting failure)\n2. **Ring Integrity Check**: Verify ring topology is intact and repair if necessary\n3. **Token Generation**: Create new election token with unique election ID\n4. **Token Circulation**: Begin token passing around ring to collect live node IDs\n5. **Leader Selection**: Highest ID from collected participants becomes leader\n\n#### Cascading Failure Handling\n\n**Sequential Node Failures** occur when multiple nodes fail in rapid succession, potentially during an ongoing election. This can cause election algorithms to fail repeatedly as candidates themselves become unavailable.\n\n**Cascade Detection Patterns:**\n\n| Failure Pattern | Recognition Signal | Adaptive Response |\n|-----------------|-------------------|-------------------|\n| Rapid Sequential Failures | Multiple failure notifications within short time window | Extend election timeouts, reduce heartbeat frequency |\n| Election Candidate Failure | Election initiator becomes unresponsive during election | Other nodes restart election with updated membership |\n| Ring Break Cascade | Multiple adjacent ring nodes fail | Rebuild ring topology, skip failed segments |\n| Network Deterioration | Increasing message loss rates across all nodes | Enter conservative mode with longer timeouts |\n\n**Adaptive Timeout Management** adjusts election timeouts based on observed failure patterns. During periods of instability, the system uses longer timeouts to prevent premature failure detection while maintaining safety properties.\n\nThe `ElectionTimeoutManager` tracks recent failure rates and election success rates to dynamically adjust timeout values:\n\n```\nAdaptive Timeout Calculation:\n1. Track recent_failure_rate = failures_last_N_minutes / total_elections_last_N_minutes\n2. Track average_election_completion_time from successful elections  \n3. Calculate base_timeout = max(configured_timeout, 2 * average_completion_time)\n4. Apply failure_rate_multiplier = 1.0 + (recent_failure_rate * 2.0)\n5. Final timeout = base_timeout * failure_rate_multiplier\n6. Bound timeout between min_timeout and max_timeout limits\n```\n\n#### Network Partition Recovery\n\n**Partition Healing Detection** identifies when previously isolated network segments regain connectivity. This is more complex than initial partition detection because nodes must reconcile potentially conflicting state accumulated during isolation.\n\n**Healing Detection Signals:**\n\n1. **Connectivity Restoration**: Previously unreachable nodes start responding to heartbeats\n2. **Membership Expansion**: Node discovery mechanisms find nodes not in current membership view  \n3. **Term Number Conflicts**: Messages arrive with term numbers different from local view\n4. **Leadership Conflicts**: Multiple nodes claim current leadership with different terms\n\n**State Reconciliation Process** safely merges state from previously isolated partitions:\n\n1. **Membership Merge**: Combine membership views from all healing partitions\n2. **Leadership Resolution**: Apply split-brain resolution protocols to determine single leader\n3. **Term Synchronization**: Update all nodes to highest observed election term  \n4. **Operation Reconciliation**: Handle any conflicting operations initiated during partition\n5. **Full Cluster Election**: Optionally trigger new election with complete membership\n\n**Gradual Integration Strategy** avoids sudden topology changes that might destabilize the newly-healed cluster:\n\n| Integration Phase | Duration | Actions Taken | Stability Measures |\n|-------------------|----------|---------------|-------------------|\n| Discovery | 30-60 seconds | Detect returning nodes, exchange basic state | Limited message broadcast |\n| Reconciliation | 60-120 seconds | Resolve conflicts, merge membership | Elevated timeouts |\n| Stabilization | 120-300 seconds | Monitor for additional conflicts | Conservative failure detection |\n| Normal Operation | Ongoing | Resume standard election parameters | Standard timeouts restored |\n\n#### Recovery Validation and Monitoring\n\n**Election Success Validation** ensures that recovery operations actually restore healthy cluster state rather than just completing the election protocol.\n\n| Validation Check | Success Criteria | Failure Response |\n|------------------|-----------------|------------------|\n| Leader Confirmation | New leader sends heartbeats to all members | Restart election with updated membership |\n| Membership Consensus | All nodes agree on cluster membership | Synchronize membership, re-validate |\n| Term Consistency | All nodes have same election term number | Broadcast correct term, update lagging nodes |\n| Operation Readiness | Leader can coordinate basic cluster operations | Investigate leader capacity, consider re-election |\n\n**Recovery Metrics Collection** tracks the effectiveness of failure handling mechanisms and identifies opportunities for improvement:\n\n```\nRecovery Effectiveness Metrics:\n- Mean Time to Detect Failure (MTTD): Average time from actual failure to detection\n- Mean Time to Recover (MTTR): Average time from failure detection to new leader operational  \n- False Positive Rate: Percentage of failure detections that were incorrect\n- Election Success Rate: Percentage of elections that complete successfully\n- Cascading Failure Rate: Frequency of failures during recovery operations\n- Split-Brain Incidents: Count and duration of multi-leader scenarios\n```\n\n> **Architecture Decision: Graduated Recovery Timeouts**\n> - **Context**: Need to balance quick failure recovery with stability during cascading failures\n> - **Options Considered**: Fixed timeouts, exponential backoff, adaptive based on failure history\n> - **Decision**: Adaptive timeouts based on recent failure rates and election completion times\n> - **Rationale**: Provides quick recovery during isolated failures while preventing instability during widespread issues\n> - **Consequences**: Requires tracking additional metrics but significantly improves system stability under stress\n\n**Continuous Health Monitoring** provides ongoing assessment of recovery mechanism effectiveness:\n\n1. **Baseline Performance Tracking**: Establish normal election completion times and failure rates\n2. **Anomaly Detection**: Identify deviations from baseline that indicate degrading conditions\n3. **Predictive Failure Assessment**: Look for patterns that precede cascading failures\n4. **Recovery Process Optimization**: Adjust timeout values and detection thresholds based on observed performance\n\n⚠️ **Common Pitfall: Recovery Process Starvation**\n\nDuring periods of high failure rates, recovery processes can consume so many resources that they prevent normal cluster operations, leading to a downward spiral where recovery attempts themselves cause additional failures.\n\n**Why it's wrong**: Recovery mechanisms that don't account for their own resource consumption can make the system less stable rather than more stable.\n\n**How to fix**: Implement rate limiting on recovery operations, exponential backoff for repeated failures, and resource reservation to ensure normal operations can continue during recovery.\n\n### Implementation Guidance\n\nUnderstanding the complexity of failure handling in distributed systems, this implementation guidance provides practical tools and patterns for building robust error handling into your leader election system.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|----------------|\n| Failure Detection | Simple timeout-based with fixed intervals | Adaptive timeouts with phi-accrual failure detector |\n| Network Testing | Basic ping/pong connectivity checks | TCP connection establishment with application-level probes |\n| State Persistence | In-memory state with periodic snapshots | Persistent storage with write-ahead logging |\n| Metrics Collection | Log-based metrics with periodic summaries | Time-series database (Prometheus) with real-time dashboards |\n| Configuration | Static configuration files | Dynamic configuration with runtime updates |\n| Testing Framework | Unit tests with mocked failures | Chaos engineering with network partition simulation |\n\n#### Recommended File Structure\n\n```\nproject-root/\n  internal/\n    failure/\n      detector.go              ← FailureDetector implementation\n      detector_test.go         ← Failure detection unit tests\n      adaptive_timeouts.go     ← AdaptiveTimeoutManager\n      split_brain.go           ← Split-brain prevention logic\n      recovery.go              ← Recovery orchestration\n      cascade_handler.go       ← Cascading failure detection\n    testing/\n      chaos/\n        network_partitioner.go ← Network partition simulation\n        failure_injector.go    ← Systematic failure injection\n        scenario_runner.go     ← End-to-end failure scenarios\n    monitoring/\n      metrics.go              ← Recovery effectiveness metrics\n      health_monitor.go       ← Continuous health assessment\n```\n\n#### Infrastructure Starter Code\n\n**Complete Adaptive Timeout Manager:**\n\n```go\npackage failure\n\nimport (\n    \"sync\"\n    \"time\"\n)\n\n// AdaptiveTimeoutManager adjusts election timeouts based on observed failure patterns\ntype AdaptiveTimeoutManager struct {\n    mu                    sync.RWMutex\n    baseTimeout          time.Duration\n    minTimeout           time.Duration\n    maxTimeout           time.Duration\n    recentFailures       []time.Time\n    recentElections      []ElectionRecord\n    windowDuration       time.Duration\n    failureRateMultiplier float64\n}\n\ntype ElectionRecord struct {\n    StartTime      time.Time\n    CompletionTime time.Time\n    Success        bool\n    ElectionID     uint64\n}\n\nfunc NewAdaptiveTimeoutManager(base, min, max time.Duration) *AdaptiveTimeoutManager {\n    return &AdaptiveTimeoutManager{\n        baseTimeout:          base,\n        minTimeout:          min,\n        maxTimeout:          max,\n        recentFailures:      make([]time.Time, 0),\n        recentElections:     make([]ElectionRecord, 0),\n        windowDuration:      5 * time.Minute,\n        failureRateMultiplier: 2.0,\n    }\n}\n\nfunc (atm *AdaptiveTimeoutManager) GetCurrentTimeout() time.Duration {\n    atm.mu.RLock()\n    defer atm.mu.RUnlock()\n    \n    now := time.Now()\n    \n    // Clean old records\n    atm.cleanOldRecords(now)\n    \n    // Calculate failure rate\n    failureRate := float64(len(atm.recentFailures)) / float64(max(len(atm.recentElections), 1))\n    \n    // Calculate average completion time for successful elections\n    avgCompletion := atm.calculateAverageCompletionTime()\n    \n    // Determine base timeout (either configured or based on observed performance)\n    effectiveBase := atm.baseTimeout\n    if avgCompletion > effectiveBase {\n        effectiveBase = time.Duration(float64(avgCompletion) * 1.5)\n    }\n    \n    // Apply failure rate multiplier\n    multiplier := 1.0 + (failureRate * atm.failureRateMultiplier)\n    adaptiveTimeout := time.Duration(float64(effectiveBase) * multiplier)\n    \n    // Bound the result\n    if adaptiveTimeout < atm.minTimeout {\n        return atm.minTimeout\n    }\n    if adaptiveTimeout > atm.maxTimeout {\n        return atm.maxTimeout\n    }\n    \n    return adaptiveTimeout\n}\n\nfunc (atm *AdaptiveTimeoutManager) RecordFailure() {\n    atm.mu.Lock()\n    defer atm.mu.Unlock()\n    atm.recentFailures = append(atm.recentFailures, time.Now())\n}\n\nfunc (atm *AdaptiveTimeoutManager) RecordElection(record ElectionRecord) {\n    atm.mu.Lock()\n    defer atm.mu.Unlock()\n    atm.recentElections = append(atm.recentElections, record)\n}\n\nfunc (atm *AdaptiveTimeoutManager) cleanOldRecords(now time.Time) {\n    cutoff := now.Add(-atm.windowDuration)\n    \n    // Clean failures\n    validFailures := atm.recentFailures[:0]\n    for _, failure := range atm.recentFailures {\n        if failure.After(cutoff) {\n            validFailures = append(validFailures, failure)\n        }\n    }\n    atm.recentFailures = validFailures\n    \n    // Clean elections\n    validElections := atm.recentElections[:0]\n    for _, election := range atm.recentElections {\n        if election.StartTime.After(cutoff) {\n            validElections = append(validElections, election)\n        }\n    }\n    atm.recentElections = validElections\n}\n\nfunc (atm *AdaptiveTimeoutManager) calculateAverageCompletionTime() time.Duration {\n    var total time.Duration\n    count := 0\n    \n    for _, election := range atm.recentElections {\n        if election.Success {\n            total += election.CompletionTime.Sub(election.StartTime)\n            count++\n        }\n    }\n    \n    if count == 0 {\n        return atm.baseTimeout\n    }\n    \n    return total / time.Duration(count)\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n\n**Complete Network Partition Simulator:**\n\n```go\npackage chaos\n\nimport (\n    \"sync\"\n    \"time\"\n)\n\n// NetworkPartitioner simulates network partitions for testing split-brain scenarios\ntype NetworkPartitioner struct {\n    mu          sync.RWMutex\n    partitions  map[NodeID][]NodeID  // nodeID -> list of nodes it can reach\n    isPartitioned bool\n    originalTopology map[NodeID][]NodeID\n}\n\nfunc NewNetworkPartitioner() *NetworkPartitioner {\n    return &NetworkPartitioner{\n        partitions: make(map[NodeID][]NodeID),\n        originalTopology: make(map[NodeID][]NodeID),\n        isPartitioned: false,\n    }\n}\n\n// SetFullConnectivity establishes full mesh connectivity between all nodes\nfunc (np *NetworkPartitioner) SetFullConnectivity(nodeIDs []NodeID) {\n    np.mu.Lock()\n    defer np.mu.Unlock()\n    \n    for _, nodeID := range nodeIDs {\n        reachable := make([]NodeID, 0, len(nodeIDs)-1)\n        for _, otherID := range nodeIDs {\n            if otherID != nodeID {\n                reachable = append(reachable, otherID)\n            }\n        }\n        np.partitions[nodeID] = reachable\n        np.originalTopology[nodeID] = make([]NodeID, len(reachable))\n        copy(np.originalTopology[nodeID], reachable)\n    }\n    np.isPartitioned = false\n}\n\n// CreatePartition splits nodes into isolated groups\nfunc (np *NetworkPartitioner) CreatePartition(groups [][]NodeID) error {\n    np.mu.Lock()\n    defer np.mu.Unlock()\n    \n    // Clear existing connectivity\n    for nodeID := range np.partitions {\n        np.partitions[nodeID] = []NodeID{}\n    }\n    \n    // Establish connectivity within each group\n    for _, group := range groups {\n        for _, nodeID := range group {\n            reachable := make([]NodeID, 0, len(group)-1)\n            for _, otherID := range group {\n                if otherID != nodeID {\n                    reachable = append(reachable, otherID)\n                }\n            }\n            np.partitions[nodeID] = reachable\n        }\n    }\n    \n    np.isPartitioned = true\n    return nil\n}\n\n// HealPartition restores full connectivity\nfunc (np *NetworkPartitioner) HealPartition() {\n    np.mu.Lock()\n    defer np.mu.Unlock()\n    \n    for nodeID, originalReachable := range np.originalTopology {\n        np.partitions[nodeID] = make([]NodeID, len(originalReachable))\n        copy(np.partitions[nodeID], originalReachable)\n    }\n    np.isPartitioned = false\n}\n\n// IsReachable checks if source node can communicate with target node\nfunc (np *NetworkPartitioner) IsReachable(source, target NodeID) bool {\n    np.mu.RLock()\n    defer np.mu.RUnlock()\n    \n    reachable, exists := np.partitions[source]\n    if !exists {\n        return false\n    }\n    \n    for _, nodeID := range reachable {\n        if nodeID == target {\n            return true\n        }\n    }\n    return false\n}\n\n// GetPartitionMembers returns all nodes reachable from the given node\nfunc (np *NetworkPartitioner) GetPartitionMembers(nodeID NodeID) []NodeID {\n    np.mu.RLock()\n    defer np.mu.RUnlock()\n    \n    reachable, exists := np.partitions[nodeID]\n    if !exists {\n        return []NodeID{}\n    }\n    \n    // Include the node itself in its partition\n    result := make([]NodeID, len(reachable)+1)\n    result[0] = nodeID\n    copy(result[1:], reachable)\n    return result\n}\n```\n\n#### Core Logic Skeleton Code\n\n**Split-Brain Prevention Logic:**\n\n```go\n// QuorumChecker validates leadership decisions against cluster membership quorum\ntype QuorumChecker struct {\n    originalClusterSize int\n    quorumSize         int\n    membership         *ClusterMembership\n}\n\n// ValidateLeadershipClaim checks if a leadership claim has sufficient support\nfunc (qc *QuorumChecker) ValidateLeadershipClaim(candidateID NodeID, supporters []NodeID) bool {\n    // TODO 1: Verify candidate is in the supporter list (leader must support itself)\n    \n    // TODO 2: Check if number of supporters meets quorum requirement\n    // Hint: supporters must include at least qc.quorumSize nodes\n    \n    // TODO 3: Validate that all supporters are in current cluster membership\n    // Hint: Use qc.membership.GetActiveMembers() to get valid members\n    \n    // TODO 4: Return true only if all conditions are met\n    \n    return false // Replace with actual implementation\n}\n\n// CanElectLeader determines if current partition can safely elect a leader\nfunc (qc *QuorumChecker) CanElectLeader() bool {\n    // TODO 1: Get list of currently reachable nodes from membership\n    \n    // TODO 2: Count reachable nodes including this node\n    \n    // TODO 3: Compare against quorum requirement\n    // Hint: Need at least qc.quorumSize reachable nodes\n    \n    // TODO 4: Return true only if quorum is available\n    \n    return false // Replace with actual implementation\n}\n```\n\n**Cascading Failure Handler:**\n\n```go\n// CascadeDetector identifies patterns indicating cascading failures\ntype CascadeDetector struct {\n    recentFailures     []FailureEvent\n    windowDuration     time.Duration\n    cascadeThreshold   int\n    adaptiveManager    *AdaptiveTimeoutManager\n}\n\ntype FailureEvent struct {\n    NodeID    NodeID\n    Timestamp time.Time\n    FailureType string\n}\n\n// DetectCascade analyzes recent failures to identify cascade patterns\nfunc (cd *CascadeDetector) DetectCascade() bool {\n    // TODO 1: Clean old failure events outside the time window\n    \n    // TODO 2: Count failures within the cascade detection window\n    \n    // TODO 3: Check if failure count exceeds cascade threshold\n    \n    // TODO 4: Look for patterns like sequential node failures or election candidate failures\n    \n    // TODO 5: Return true if cascade pattern is detected\n    \n    return false // Replace with actual implementation\n}\n\n// HandleCascade implements adaptive responses to cascading failure detection  \nfunc (cd *CascadeDetector) HandleCascade() {\n    // TODO 1: Notify adaptive timeout manager to increase timeouts\n    \n    // TODO 2: Enter conservative mode with extended election delays\n    \n    // TODO 3: Reduce heartbeat frequency to decrease network load\n    \n    // TODO 4: Log cascade detection for monitoring and debugging\n    \n    // TODO 5: Set cascade recovery timer to restore normal operation\n}\n```\n\n#### Language-Specific Hints\n\n**Go-Specific Error Handling Patterns:**\n\n- Use `context.Context` with timeouts for all network operations: `ctx, cancel := context.WithTimeout(context.Background(), timeout)`\n- Implement graceful shutdown with `select` statements on `shutdownChan` in all goroutines\n- Use `sync.RWMutex` for concurrent access to failure detection state - readers don't block each other\n- Wrap errors with context using `fmt.Errorf(\"failed to detect node failure: %w\", err)` for better debugging\n- Use `time.NewTimer()` for adaptive timeouts and remember to call `timer.Stop()` to prevent resource leaks\n\n**Network Reliability Patterns:**\n\n- Set both connection timeout and read/write timeouts: `net.DialTimeout()` and `conn.SetDeadline()`\n- Implement exponential backoff for retry logic: `time.Sleep(backoffDuration * time.Duration(attempt))`\n- Use `net.OpError` type assertion to distinguish between different network error types\n- Buffer channels for failure events to prevent blocking: `make(chan FailureEvent, 100)`\n\n#### Milestone Checkpoints\n\n**Failure Detection Validation:**\n\nRun the failure detector in isolation:\n```bash\ngo test ./internal/failure/ -v -run TestFailureDetection\n```\n\nExpected behavior:\n- Heartbeat timeouts should trigger failure detection within 2x heartbeat interval\n- False positive rate should be < 5% under normal network conditions\n- Recovery should complete within 10 seconds of failure detection\n\n**Split-Brain Prevention Test:**\n\nSimulate network partition scenarios:\n```bash\ngo test ./internal/testing/chaos/ -v -run TestSplitBrainPrevention\n```\n\nExpected behavior:\n- Only majority partition should elect leader during partition\n- Minority partition should remain leaderless\n- Partition healing should resolve to single leader without data loss\n\n**Cascading Failure Resilience:**\n\nTest sequential node failures:\n```bash\ngo test ./internal/failure/ -v -run TestCascadingFailures\n```\n\nExpected behavior:\n- System should adapt timeouts automatically during cascade periods\n- Elections should eventually succeed even with 40% node failure rate\n- No permanent split-brain states should occur\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Frequent unnecessary elections | Failure detection timeouts too short | Check heartbeat success rate and network latency | Increase timeout values or implement adaptive timeouts |\n| Split-brain persists after partition healing | Conflict resolution not working | Look for term number inconsistencies in logs | Implement proper term-based leadership resolution |\n| Elections never complete during cascading failures | Timeouts not adapting to degraded conditions | Monitor election attempt frequency and success rate | Enable adaptive timeout management |\n| False failure detection during load spikes | Fixed timeouts don't account for performance variation | Correlate failure detection with system load metrics | Implement phi-accrual failure detector or adaptive thresholds |\n| Recovery stalls with partial membership | Membership updates not propagating during failures | Check if membership synchronization is working | Add periodic membership broadcast from leader |\n\n\n## Testing Strategy and Validation\n\n> **Milestone(s):** All milestones - comprehensive testing approach that validates node communication (Milestone 1), bully algorithm correctness (Milestone 2), ring election behavior (Milestone 3), and system-wide reliability\n\n### Mental Model: Quality Assurance Theater Production\n\nThink of testing a distributed leader election system like preparing a theatrical production with multiple actors performing on separate stages that must coordinate perfectly. Just as a theater director needs to test individual actors' performances (component testing), then rehearse scenes with multiple actors (multi-node testing), and finally stress-test the entire production with equipment failures and unexpected events (fault injection), we must validate our leader election system at multiple levels.\n\nIn theater, you start with table reads where actors practice their lines in isolation, progress to blocking rehearsals where they interact on stage, then add technical rehearsals with lighting failures and prop malfunctions. Similarly, our testing strategy begins with isolated component validation, scales to multi-node election scenarios, and culminates with chaos testing that simulates real-world failures.\n\nThe key insight is that distributed systems testing requires both **deterministic validation** (like actors hitting their marks) and **probabilistic resilience testing** (like handling unexpected audience disruptions). Each milestone represents a different \"act\" in our production, and we must validate that the performance remains coherent even when individual actors miss cues or the stage equipment fails.\n\n### Component-Level Testing\n\nComponent-level testing validates individual system components in isolation before integration. This approach mirrors unit testing but focuses specifically on the stateful, concurrent nature of distributed systems components. Each component must demonstrate correct behavior under various input conditions and state transitions.\n\nThe core components requiring isolated testing include the `Transport` layer, `ClusterMembership` manager, `FailureDetector`, `BullyElection` coordinator, `RingElection` manager, and `ElectionTimeoutManager`. Each component has specific behavioral contracts that must be verified independently.\n\n> **Decision: Mock-Based Component Isolation**\n> - **Context**: Components have complex dependencies on network transport, time management, and cluster state\n> - **Options Considered**: Mock all dependencies vs. use test doubles vs. in-memory implementations\n> - **Decision**: Use comprehensive mocks for external dependencies with behavior verification\n> - **Rationale**: Mocks provide precise control over dependency behavior, enable deterministic testing of edge cases, and isolate component logic from infrastructure concerns\n> - **Consequences**: Enables fast, reliable component tests but requires maintaining mock implementations alongside real ones\n\n#### Transport Layer Component Testing\n\nThe `HTTPTransport` implementation requires validation of message serialization, network error handling, retry logic, and concurrent connection management. Transport testing focuses on the reliability contracts rather than network performance.\n\n| Test Category | Validation Focus | Key Scenarios |\n|---------------|------------------|---------------|\n| Message Serialization | Correct encoding/decoding of all message types | `ElectionMessage`, `CoordinatorMessage`, `RingToken` round-trip |\n| Connection Management | Proper handling of connection lifecycle | Connect, disconnect, reconnect, connection pooling |\n| Error Propagation | Accurate error reporting for network failures | Timeout errors, connection refused, host unreachable |\n| Concurrent Access | Thread-safe operation under high load | Multiple goroutines sending simultaneously |\n| Retry Behavior | Exponential backoff and retry limits | Failed sends trigger appropriate retry sequences |\n\nThe transport layer testing validates the `SendMessage` and `BroadcastMessage` methods under controlled failure conditions. Mock network implementations simulate specific failure modes like connection timeouts, partial message delivery, and connection drops during transmission.\n\n#### Cluster Membership Testing\n\nThe `ClusterMembership` component manages the dynamic view of active nodes in the cluster. Testing focuses on membership state consistency, node lifecycle management, and concurrent access patterns.\n\n| Component Method | Test Scenarios | Expected Behavior |\n|------------------|----------------|-------------------|\n| `UpdateMembership(nodes []Node)` | Add new nodes, remove failed nodes, bulk updates | Membership view reflects changes atomically |\n| `GetActiveMembers()` | Concurrent reads during updates | Returns consistent snapshot of active nodes |\n| `MarkNodeSeen(nodeID NodeID)` | Concurrent heartbeat updates | Timestamps update atomically without races |\n| `IncreaseSuspicion(nodeID NodeID)` | Graduated failure detection | Suspicion levels increment correctly |\n\nMembership testing uses controlled timing to validate timeout-based node eviction. Test scenarios include rapid membership changes, concurrent suspicion updates, and edge cases like nodes rejoining after being marked as failed.\n\n#### Failure Detector Validation\n\nThe `FailureDetector` component implements graduated failure detection using heartbeat timeouts and suspicion levels. Testing validates the accuracy of failure detection while minimizing false positives.\n\n```\nTest Scenarios for Failure Detection:\n1. Normal Operation: Heartbeats arrive regularly → no failures detected\n2. Temporary Network Delay: Delayed heartbeats → suspicion increases but no failure\n3. Node Crash: No heartbeats received → failure detected after timeout\n4. Network Partition: Heartbeats stop → partition detection rather than node failure\n5. False Positive Recovery: Late heartbeat arrives → suspicion decreases appropriately\n```\n\nFailure detector testing requires precise timing control to simulate network delays, heartbeat patterns, and recovery scenarios. Mock clocks enable deterministic testing of timeout-based logic without waiting for real time to pass.\n\n#### Election Algorithm Component Testing\n\nBoth `BullyElection` and `RingElection` components require isolated testing of their state machines and message handling logic. Component testing validates algorithm correctness independent of network reliability.\n\n**Bully Election Component Tests:**\n\n| State Transition | Trigger Event | Expected Behavior | Validation Method |\n|------------------|---------------|-------------------|-------------------|\n| Follower → Candidate | Leader failure detected | Start election, send ELECTION messages | Verify message sending calls |\n| Candidate → Follower | Receive OK response | Stop election attempt | Verify state change and timeout cancellation |\n| Candidate → Leader | Election timeout expires | Broadcast COORDINATOR message | Verify coordinator announcement |\n| Leader → Follower | Receive COORDINATOR from higher ID | Acknowledge new leader | Verify leadership transition |\n\n**Ring Election Component Tests:**\n\n| Token Processing | Input Condition | Expected Behavior | Validation Check |\n|------------------|-----------------|-------------------|------------------|\n| Token Initiation | `StartElection()` called | Create new `RingToken`, add self to participants | Verify token creation and forwarding |\n| Token Forwarding | Receive incomplete token | Add self to participants, forward to successor | Verify participant list updates |\n| Token Completion | Receive token with self as initiator | Select highest ID as leader | Verify leader selection logic |\n| Ring Repair | Next successor unreachable | Find alternative successor, continue forwarding | Verify ring topology updates |\n\nComponent testing uses mock transport implementations to verify exact message sequences without network dependencies. State verification ensures components maintain correct internal state throughout algorithm execution.\n\n#### Timeout Manager Testing\n\nThe `ElectionTimeoutManager` and `AdaptiveTimeoutManager` components require testing of timer management, adaptive timeout calculation, and concurrent timeout operations.\n\n| Timeout Scenario | Test Condition | Expected Behavior |\n|------------------|----------------|-------------------|\n| Normal Timeout | Timer expires without cancellation | Callback function executed exactly once |\n| Early Cancellation | `CancelTimeout()` called before expiration | Callback never executed, timer cleaned up |\n| Adaptive Adjustment | Multiple timeouts recorded | Timeout duration increases based on failure patterns |\n| Concurrent Operations | Multiple timeouts started simultaneously | Each timer operates independently |\n\nTimeout testing requires mock clock implementations to control time progression and verify callback execution timing without depending on system clocks.\n\n⚠️ **Pitfall: Race Conditions in Component State**\nComponent testing often reveals race conditions that only manifest under specific timing conditions. For example, the `ElectionState` might be read and written concurrently during state transitions, leading to inconsistent state if not properly synchronized. Always test components with concurrent operations using tools like Go's race detector to identify synchronization issues early.\n\n### Multi-Node Scenarios\n\nMulti-node testing validates complete election flows with multiple coordinating nodes. These tests verify that election algorithms produce correct results when multiple nodes interact according to protocol specifications. Multi-node testing bridges the gap between component validation and full system testing.\n\nThe testing approach uses multiple `ElectionCoordinator` instances within a single process, connected through a controlled test transport that simulates network communication. This enables deterministic testing of multi-node interactions without the complexity of true distributed deployment.\n\n#### Election Flow Validation\n\nComplete election flows require validation of message sequences, timing constraints, and final convergence to a single leader. Each algorithm has specific flow patterns that must be verified under normal operation.\n\n**Bully Algorithm Multi-Node Flow:**\n\n```\nScenario: 5-node cluster (IDs: 1, 2, 3, 4, 5) with Node 5 as initial leader\n1. Node 5 fails (simulated by stopping heartbeats)\n2. Node 2 detects failure, initiates election\n3. Node 2 sends ELECTION to nodes 3, 4, 5\n4. Node 3 sends OK to Node 2, starts own election\n5. Node 3 sends ELECTION to nodes 4, 5\n6. Node 4 sends OK to Node 3, starts own election\n7. Node 4 sends ELECTION to Node 5 (no response)\n8. Node 4's timeout expires, broadcasts COORDINATOR\n9. All nodes acknowledge Node 4 as new leader\n```\n\nMulti-node testing validates that this exact sequence occurs reliably and that the system converges to the expected leader (highest ID among responsive nodes).\n\n**Ring Election Multi-Node Flow:**\n\n```\nScenario: 4-node ring (IDs: 2, 4, 6, 8) with Node 8 as initial leader\n1. Node 8 fails, Node 2 detects failure\n2. Node 2 creates RingToken{InitiatorID: 2, Participants: [2]}\n3. Token forwarded: 2 → 4 → 6 → 2 (completing ring)\n4. Token participants: [2, 4, 6]\n5. Node 2 selects highest ID (6) as new leader\n6. Node 6 broadcasts coordinator announcement\n7. All nodes acknowledge Node 6 as leader\n```\n\nRing election testing verifies token circulation, participant collection accuracy, and deterministic leader selection from the participant set.\n\n#### Concurrent Election Handling\n\nMultiple nodes may simultaneously detect leader failure and initiate elections. Multi-node testing validates that concurrent elections resolve correctly without producing multiple leaders or election storms.\n\n| Concurrent Scenario | Initial Condition | Expected Resolution |\n|---------------------|-------------------|---------------------|\n| Simultaneous Detection | Multiple nodes detect leader failure at same time | Higher-ID node wins, others become followers |\n| Election Storm | Rapid successive failures during elections | System eventually converges to stable leader |\n| Split Elections | Different nodes see different failure sets | Quorum-based resolution prevents split-brain |\n| Late Joiner | Node starts election while another is in progress | Late election properly defers to ongoing election |\n\nConcurrent election testing requires precise timing control to simulate simultaneous events across multiple nodes. Test scenarios verify that the system maintains safety (at most one leader) and eventual liveness (always elects a leader when possible).\n\n#### Membership Change Integration\n\nDynamic membership changes during elections create complex scenarios where node sets change while elections are in progress. Multi-node testing validates that membership changes integrate correctly with ongoing elections.\n\n| Membership Change | Election State | Expected Behavior |\n|-------------------|----------------|-------------------|\n| Node Join | Election in progress | New node participates in current election |\n| Node Leave | Election in progress | Election continues with remaining participants |\n| Leader Join | Follower nodes active | New leader detected and acknowledged |\n| Partition Heal | Split elections ongoing | Partitions merge and reconcile leadership |\n\nMembership integration testing uses controlled node addition and removal to validate that election protocols adapt correctly to changing cluster composition.\n\n#### Message Ordering and Timing\n\nMulti-node elections depend on message ordering and timing constraints. Testing validates that the system behaves correctly even when messages are delayed, reordered, or lost during transmission.\n\n```\nMessage Ordering Test Scenarios:\n1. Delayed Messages: COORDINATOR arrives before ELECTION responses\n2. Message Reordering: OK response arrives before original ELECTION\n3. Duplicate Messages: Same ELECTION message received multiple times\n4. Partial Delivery: ELECTION reaches some but not all higher-ID nodes\n5. Recovery Messages: Late messages arrive after election completion\n```\n\nOrdering tests use controlled message delivery simulation to introduce specific timing patterns and verify algorithm robustness. The test transport can delay, duplicate, or reorder messages according to configured patterns.\n\n![Ring Election Token Passing](./diagrams/ring-sequence.svg)\n\n#### Leader Transition Validation\n\nMulti-node testing validates smooth leadership transitions when new leaders are elected. Testing focuses on state consistency, responsibility transfer, and continued cluster operation during leadership changes.\n\n| Transition Scenario | Validation Focus | Success Criteria |\n|---------------------|------------------|------------------|\n| Normal Election | Clean transition from old to new leader | All nodes acknowledge new leader within timeout |\n| Failed Leader Recovery | Original leader returns after being replaced | Returning leader recognizes new leadership |\n| Cascading Leadership | Multiple consecutive leader failures | System maintains availability throughout transitions |\n| Partition Recovery | Leaders elected in separate partitions | Unified leadership established after partition heals |\n\nLeadership transition testing verifies that cluster operations continue seamlessly across leadership changes and that no split-brain conditions persist after transitions complete.\n\n⚠️ **Pitfall: Test Non-Determinism**\nMulti-node tests can exhibit non-deterministic behavior due to timing dependencies, goroutine scheduling, and message ordering variations. Always use controlled test clocks, deterministic goroutine scheduling, and message sequence verification to ensure test reliability. Flaky tests undermine confidence in the actual system behavior.\n\n### Fault Injection Testing\n\nFault injection testing validates system resilience by deliberately introducing failures during normal operation. This approach reveals how the system behaves under adverse conditions and verifies that error handling and recovery mechanisms function correctly.\n\nFault injection simulates real-world failure scenarios including network partitions, node crashes, message loss, and timing failures. The goal is to verify that the system maintains safety properties (never elects multiple leaders) and recovers liveness (eventually elects a new leader) even under challenging conditions.\n\n#### Network Failure Simulation\n\nNetwork failures represent the most common source of distributed system problems. Fault injection testing systematically introduces network-level failures to validate election algorithm resilience.\n\n**Network Partition Simulation:**\n\nThe `NetworkPartitioner` component creates controlled network splits that isolate nodes into separate communication groups. Partition testing validates that each partition behaves correctly and that partition healing restores unified leadership.\n\n| Partition Type | Configuration | Expected Behavior | Validation Method |\n|----------------|---------------|-------------------|-------------------|\n| Clean Split | Divide cluster into equal-sized partitions | Each partition attempts independent election | Verify no cross-partition communication |\n| Asymmetric Split | One large partition, multiple small ones | Large partition elects leader, small ones wait | Verify quorum-based election restrictions |\n| Network Island | Single node isolated from cluster | Isolated node cannot elect itself leader | Verify quorum requirements prevent solo leadership |\n| Cascading Partition | Sequential isolation of nodes | Remaining cluster continues operation | Verify graceful degradation |\n\nPartition testing uses the `CreatePartition` method to establish communication restrictions between node groups. The `IsReachable` method validates partition boundaries and ensures message isolation.\n\n**Message Loss and Delay:**\n\nControlled message loss and delay simulation tests algorithm robustness against unreliable network conditions. Testing validates retry logic, timeout handling, and eventual consistency.\n\n```\nMessage Failure Injection Patterns:\n1. Random Loss: Randomly drop X% of messages during election\n2. Selective Loss: Drop specific message types (e.g., all OK responses)\n3. Burst Loss: Drop all messages for specific time window\n4. Asymmetric Loss: Drop messages in one direction only\n5. Gradual Degradation: Increasing loss rate over time\n```\n\nMessage loss testing verifies that election algorithms eventually converge to correct results despite communication failures. Timeout mechanisms and retry logic must ensure progress even with significant message loss.\n\n#### Node Failure Patterns\n\nNode failure injection simulates various crash scenarios to validate failure detection and leader election triggers. Testing covers both crash-stop failures (nodes stop completely) and crash-recovery failures (nodes restart after crashes).\n\n**Crash-Stop Failure Simulation:**\n\n| Failure Timing | Scenario | Expected System Response |\n|----------------|----------|--------------------------|\n| Leader Crash | Current leader stops during normal operation | Followers detect failure, initiate new election |\n| Candidate Crash | Node crashes during active election campaign | Other candidates continue election process |\n| Follower Crash | Non-leader node crashes | Leader continues operation, membership updated |\n| Cascading Crash | Multiple nodes crash in sequence | System maintains operation with remaining nodes |\n\nNode crash simulation stops specific nodes at controlled points in election algorithms. Testing validates that remaining nodes detect failures promptly and adapt cluster membership accordingly.\n\n**Crash-Recovery Scenarios:**\n\nCrash-recovery testing validates system behavior when failed nodes restart and attempt to rejoin cluster operations. Recovery scenarios test state reconciliation and leadership acknowledgment.\n\n```\nRecovery Test Scenarios:\n1. Leader Recovery: Failed leader restarts and discovers new leader\n2. Candidate Recovery: Node crashed during election restarts\n3. Network Recovery: Partitioned nodes reconnect to cluster\n4. Stale State Recovery: Restarted node has outdated cluster state\n5. Split-Brain Recovery: Multiple leaders exist during partition healing\n```\n\nRecovery testing uses controlled node restart sequences to validate that recovering nodes integrate correctly without disrupting ongoing cluster operations.\n\n#### Timing Failure Injection\n\nTiming failures simulate clock skew, timeout variations, and scheduling delays that can affect distributed coordination. Timing injection tests validate that algorithms remain correct despite temporal uncertainties.\n\n**Clock Skew Simulation:**\n\nDifferent nodes may have slightly different clock times, affecting timeout calculations and message timestamps. Clock skew testing validates that algorithms tolerate reasonable time differences between nodes.\n\n| Skew Pattern | Configuration | Impact on Elections | Validation Focus |\n|--------------|---------------|---------------------|------------------|\n| Linear Skew | Each node's clock runs slightly fast/slow | Affects timeout calculations | Verify elections complete despite skew |\n| Step Skew | Nodes have different epoch times | Timestamp comparison issues | Verify timestamp-based logic handles differences |\n| Drift Skew | Clock rates diverge over time | Increasing timing discrepancies | Verify long-running stability |\n\nClock skew injection modifies timeout calculations and timestamp generation to simulate realistic timing variations in distributed environments.\n\n**Timeout Manipulation:**\n\nControlled timeout manipulation tests algorithm behavior under various timing conditions. Testing validates that adaptive timeout mechanisms respond correctly to changing network conditions.\n\n```\nTimeout Injection Scenarios:\n1. Aggressive Timeouts: Very short timeouts cause frequent false failures\n2. Conservative Timeouts: Long timeouts delay failure detection\n3. Variable Timeouts: Timeout values change during elections\n4. Timeout Storms: Multiple simultaneous timeout expirations\n5. Timeout Starvation: Timeouts never expire due to constant resets\n```\n\nTimeout manipulation uses the `AdaptiveTimeoutManager` to modify timeout behavior and validate system adaptation to different timing environments.\n\n#### Cascading Failure Testing\n\nCascading failures occur when one failure triggers additional failures, potentially leading to system-wide outages. Cascading failure testing validates that the system contains failure propagation and maintains core functionality.\n\n**Failure Cascade Patterns:**\n\n| Cascade Type | Trigger Condition | Propagation Mechanism | Expected Containment |\n|--------------|-------------------|----------------------|----------------------|\n| Leadership Cascade | Leader fails during election | New leader also fails before stabilizing | System eventually elects stable leader |\n| Network Cascade | Partition triggers additional network failures | Isolated nodes become unreachable | Remaining nodes form functional cluster |\n| Resource Cascade | Node crash causes resource exhaustion | Other nodes crash due to increased load | Load balancing prevents complete failure |\n| Election Storm | Concurrent elections trigger more elections | Rapid election attempts prevent convergence | System eventually stabilizes on single leader |\n\nThe `CascadeDetector` component identifies cascading failure patterns and triggers protective mechanisms to prevent system-wide collapse.\n\n**Recovery from Cascades:**\n\nCascade recovery testing validates that the system can recover from severe failure scenarios and restore normal operation. Recovery mechanisms include backoff strategies, leader election suspension, and gradual node re-integration.\n\n```\nCascade Recovery Validation:\n1. Detection: System recognizes cascading failure pattern\n2. Containment: Protective measures prevent further propagation  \n3. Stabilization: Remaining nodes establish minimal functional cluster\n4. Recovery: Failed nodes gradually rejoin without triggering new cascades\n5. Full Operation: Complete cluster functionality restored\n```\n\nRecovery testing uses controlled failure injection sequences followed by gradual recovery to validate system resilience and self-healing capabilities.\n\n![Split-Brain Prevention](./diagrams/network-partition-scenario.svg)\n\n⚠️ **Pitfall: Unrealistic Failure Scenarios**\nFault injection testing can create failure combinations that never occur in practice, leading to over-engineering or incorrect system behavior. Focus on realistic failure patterns based on actual distributed system operational data. Common real-world failures include single-node crashes, network partitions between data centers, and gradual network degradation rather than simultaneous multi-node failures.\n\n### Milestone Validation Checkpoints\n\nEach project milestone requires specific validation checkpoints to verify correct implementation before proceeding to subsequent milestones. Validation checkpoints provide concrete behavioral tests that demonstrate milestone completion.\n\nMilestone validation combines automated testing, manual verification, and behavioral observation to ensure comprehensive validation. Each checkpoint includes specific commands to execute, expected outputs to observe, and behavioral patterns to verify.\n\n#### Milestone 1: Node Communication Validation\n\nNode communication validation verifies that the foundational messaging infrastructure operates correctly. Testing focuses on message delivery, failure detection, and cluster membership management.\n\n**Checkpoint 1.1: Basic Messaging**\n\n| Validation Test | Command | Expected Behavior |\n|----------------|---------|-------------------|\n| Point-to-Point Messaging | `go test -run TestSendMessage` | Messages deliver reliably between specific nodes |\n| Broadcast Messaging | `go test -run TestBroadcastMessage` | Messages reach all active cluster members |\n| Message Serialization | `go test -run TestMessageSerialization` | All message types serialize/deserialize correctly |\n| Concurrent Messaging | `go test -run TestConcurrentMessaging` | Multiple simultaneous messages deliver without corruption |\n\n**Manual Verification for Milestone 1:**\n\n```\nManual Test Procedure:\n1. Start 3 nodes: ./node --id=1 --port=8001, ./node --id=2 --port=8002, ./node --id=3 --port=8003\n2. Verify cluster membership: curl http://localhost:8001/membership should show all 3 nodes\n3. Send test message: curl -X POST http://localhost:8001/send -d '{\"target\": 2, \"content\": \"test\"}'\n4. Verify message receipt: curl http://localhost:8002/messages should show received message\n5. Stop node 3, wait 10 seconds: curl http://localhost:8001/membership should show only nodes 1, 2\n```\n\n**Checkpoint 1.2: Failure Detection**\n\nFailure detection validation verifies that nodes detect crashes and network partitions within configured timeouts.\n\n| Test Scenario | Validation Method | Success Criteria |\n|---------------|-------------------|------------------|\n| Node Crash Detection | Stop node process abruptly | Other nodes detect failure within 2x heartbeat interval |\n| Network Partition | Block network traffic between nodes | Partitioned nodes marked as unreachable |\n| False Positive Prevention | Introduce temporary network delay | Nodes marked suspicious but not failed |\n| Recovery Detection | Restart failed node | Node rejoins cluster and resumes normal operation |\n\n**Checkpoint 1.3: Cluster Membership**\n\nMembership validation ensures that all nodes maintain consistent views of cluster composition and handle membership changes correctly.\n\n```\nMembership Consistency Test:\n1. Start 5-node cluster with IDs 1, 2, 3, 4, 5\n2. Verify all nodes report identical membership: [1, 2, 3, 4, 5]\n3. Stop nodes 3 and 4 simultaneously  \n4. Wait for failure detection timeout (default: 5 seconds)\n5. Verify remaining nodes report membership: [1, 2, 5]\n6. Restart node 3\n7. Verify membership updates to: [1, 2, 3, 5] within rejoin timeout\n```\n\n#### Milestone 2: Bully Algorithm Validation\n\nBully algorithm validation verifies that the highest-ID responsive node consistently wins elections and that all nodes acknowledge the elected leader.\n\n**Checkpoint 2.1: Basic Bully Election**\n\n| Election Scenario | Setup | Expected Winner | Validation Method |\n|-------------------|-------|-----------------|-------------------|\n| Normal Election | 5 nodes (1,2,3,4,5), node 5 fails | Node 4 | Verify COORDINATOR message from node 4 |\n| Cascading Election | Nodes 4,5 fail during node 2's election | Node 3 | Verify node 3 eventually becomes leader |\n| Simultaneous Detection | Nodes 1,2 detect failure simultaneously | Higher ID wins | Verify only one COORDINATOR broadcast |\n| Leader Recovery | Failed leader returns after replacement | New leader remains | Returning leader becomes follower |\n\n**Manual Bully Election Test:**\n\n```\nBully Election Manual Verification:\n1. Start 4-node cluster: IDs 10, 20, 30, 40\n2. Verify node 40 is initial leader: curl http://localhost:8040/status shows \"leader\"\n3. Stop node 40 (kill process)\n4. Wait for election timeout (default: 3 seconds)  \n5. Verify node 30 becomes leader: curl http://localhost:8030/status shows \"leader\"\n6. Verify other nodes acknowledge: curl http://localhost:8010/leader returns \"30\"\n7. Restart node 40: ./node --id=40 --port=8040\n8. Verify node 40 becomes follower: curl http://localhost:8040/status shows \"follower\"\n9. Verify node 40 acknowledges node 30: curl http://localhost:8040/leader returns \"30\"\n```\n\n**Checkpoint 2.2: Bully Message Sequences**\n\nMessage sequence validation verifies that bully election messages follow the correct protocol patterns and that election termination occurs appropriately.\n\n```\nExpected Bully Message Sequence (Node 20 initiates election):\n1. Node 20 → ELECTION → Nodes 30, 40\n2. Node 30 → OK → Node 20 (Node 20 stops its election)  \n3. Node 40 → OK → Node 20\n4. Node 30 → ELECTION → Node 40\n5. Node 40 → OK → Node 30 (Node 30 stops its election)\n6. Node 40 timeout expires (no higher-ID responses)\n7. Node 40 → COORDINATOR → Nodes 10, 20, 30\n8. All nodes acknowledge Node 40 as leader\n```\n\n**Checkpoint 2.3: Bully Edge Cases**\n\nEdge case validation ensures robust behavior under challenging conditions including message loss, timing variations, and concurrent elections.\n\n| Edge Case | Test Condition | Expected Behavior | Validation Check |\n|-----------|----------------|-------------------|------------------|\n| Message Loss | Drop 50% of ELECTION messages | Election eventually completes | Retry logic ensures progress |\n| Timeout Variation | Randomize election timeouts | Highest-ID node still wins | Algorithm correctness maintained |\n| Concurrent Elections | Multiple nodes start elections simultaneously | Single leader emerges | No split-brain condition |\n| Partial Partition | Some nodes can't reach highest-ID node | Available highest-ID node wins | Election adapts to reachable nodes |\n\n#### Milestone 3: Ring Election Validation\n\nRing election validation verifies that tokens circulate correctly around the logical ring and that the highest-ID node from collected participants becomes the leader.\n\n**Checkpoint 3.1: Ring Topology Construction**\n\nRing topology validation ensures that nodes form a correct logical ring based on ID ordering and that ring repair mechanisms handle node failures.\n\n| Topology Test | Node Set | Expected Ring Order | Validation Method |\n|---------------|----------|---------------------|-------------------|\n| Basic Ring | IDs: 5, 15, 25, 35 | 5→15→25→35→5 | Verify successor mapping |\n| Gap Handling | IDs: 10, 30, 50 | 10→30→50→10 | Ring spans non-consecutive IDs |\n| Dynamic Addition | Add node 20 to ring [10, 30, 50] | 10→20→30→50→10 | Ring rebuilds correctly |\n| Failure Repair | Node 30 fails in ring [10, 20, 30, 40] | 20→40 (skip failed node) | Ring repairs automatically |\n\n**Manual Ring Topology Verification:**\n\n```\nRing Topology Manual Test:\n1. Start 4 nodes with IDs: 100, 300, 200, 400  \n2. Verify ring construction: curl http://localhost:8100/ring-topology\n   Expected: {100: 200, 200: 300, 300: 400, 400: 100}\n3. Stop node 300\n4. Wait for failure detection and ring repair\n5. Verify updated ring: curl http://localhost:8100/ring-topology  \n   Expected: {100: 200, 200: 400, 400: 100}\n6. Restart node 300\n7. Verify ring inclusion: ring should include all 4 nodes again\n```\n\n**Checkpoint 3.2: Token Circulation**\n\nToken circulation validation verifies that election tokens pass correctly around the ring, collecting participant IDs and completing full ring traversals.\n\n```\nExpected Ring Election Flow (Node 100 initiates):\n1. Node 100 creates token: {InitiatorID: 100, Participants: [100]}\n2. Token 100→200: Participants become [100, 200]  \n3. Token 200→400: Participants become [100, 200, 400] (Node 300 failed, skipped)\n4. Token 400→100: Ring complete, participants [100, 200, 400]\n5. Node 100 selects leader: max(100, 200, 400) = 400\n6. Node 400 broadcasts COORDINATOR message\n7. All nodes acknowledge Node 400 as leader\n```\n\n**Checkpoint 3.3: Ring Election Message Validation**\n\nMessage validation ensures that ring tokens contain correct participant information and that leader selection follows deterministic rules.\n\n| Token State | Participant List | Expected Leader | Validation Check |\n|-------------|------------------|-----------------|------------------|\n| Partial Circulation | [5, 15] | Election incomplete | No leader selected yet |\n| Complete Circulation | [5, 15, 25] | Node 25 | Highest ID becomes leader |\n| Failed Node Excluded | [5, 25] (Node 15 failed) | Node 25 | Failed nodes don't participate |\n| Single Node Ring | [42] | Node 42 | Solo node becomes leader |\n\n#### Cross-Milestone Integration Validation\n\nIntegration validation verifies that components from different milestones work correctly together and that the complete system demonstrates expected behavior.\n\n**End-to-End Election Scenarios:**\n\n| Integration Test | Milestone Components | Scenario | Expected Outcome |\n|------------------|---------------------|----------|------------------|\n| Algorithm Switching | M1 + M2 + M3 | Switch from bully to ring election | Both algorithms produce same leader |\n| Failure During Election | M1 + M2 | Node fails mid-bully-election | Election completes with remaining nodes |\n| Partition Recovery | M1 + M3 | Ring election during partition heal | Unified leadership established |\n| Concurrent Algorithms | M2 + M3 | Bully and ring elections triggered simultaneously | One election succeeds, other aborts |\n\n**System-Wide Behavioral Validation:**\n\n```\nComplete System Test Procedure:\n1. Deploy 5-node cluster with both election algorithms enabled\n2. Verify initial leader election (any algorithm)  \n3. Simulate network partition splitting cluster 2-3\n4. Verify each partition attempts independent leadership\n5. Heal network partition\n6. Verify unified leadership with single leader\n7. Trigger manual election switch (bully→ring or ring→bully)\n8. Verify leadership transition maintains cluster stability\n9. Introduce cascading failures (2 nodes crash sequentially)\n10. Verify system maintains operation with remaining nodes\n```\n\n**Performance and Timing Validation:**\n\n| Performance Metric | Target Value | Measurement Method | Acceptable Range |\n|--------------------|--------------|-------------------|------------------|\n| Election Completion Time | < 5 seconds | Time from leader failure to new leader | 2-8 seconds depending on timeouts |\n| Message Overhead | < 10 messages per election | Count all election-related messages | Varies by algorithm and cluster size |\n| Convergence Reliability | 99%+ success rate | 1000 election simulations | Must handle standard failure scenarios |\n| Memory Usage | < 10MB per node | Runtime memory profiling | Reasonable for long-running operation |\n\n⚠️ **Pitfall: Insufficient Validation Coverage**\nMilestone checkpoints often focus on \"happy path\" scenarios and miss edge cases that cause problems in production. Always include negative test cases where elections should fail or be rejected (e.g., minority partitions attempting leadership, nodes with stale state trying to become leaders). Comprehensive validation catches safety violations that simple positive testing might miss.\n\n### Implementation Guidance\n\nThis subsection provides concrete implementation approaches for building a comprehensive testing framework for the distributed leader election system. The testing infrastructure must support component isolation, multi-node coordination, fault injection, and milestone validation.\n\n#### Testing Infrastructure Components\n\n**A. Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Test Framework | Go's built-in `testing` package with table-driven tests | Testify framework with advanced assertions and mocking |\n| Test Transport | In-memory channel-based transport with controlled delivery | HTTP-based test transport with network simulation |\n| Time Control | Manual clock implementation with controllable time progression | Specialized testing time library (e.g., clockwork) |\n| Concurrency Testing | Go race detector with stress testing | Dedicated concurrency testing tools |\n| Fault Injection | Simple failure flags and controlled panics | Chaos engineering framework integration |\n\n**B. Recommended Testing File Structure:**\n\n```\nproject-root/\n├── cmd/\n│   └── testnode/\n│       └── main.go                    ← Test node executable for manual testing\n├── internal/\n│   ├── election/\n│   │   ├── coordinator_test.go        ← ElectionCoordinator component tests\n│   │   ├── bully_test.go              ← BullyElection component tests  \n│   │   ├── ring_test.go               ← RingElection component tests\n│   │   └── integration_test.go        ← Multi-node election flow tests\n│   ├── transport/\n│   │   ├── http_test.go               ← HTTPTransport component tests\n│   │   └── test_transport.go          ← Mock transport for testing\n│   ├── membership/\n│   │   ├── membership_test.go         ← ClusterMembership component tests\n│   │   └── failure_detector_test.go   ← FailureDetector component tests\n│   └── testutil/\n│       ├── test_cluster.go            ← Multi-node test cluster management\n│       ├── fault_injector.go          ← Controlled failure injection\n│       ├── mock_clock.go              ← Controllable time implementation\n│       └── scenario_runner.go         ← Election scenario test framework\n└── test/\n    ├── scenarios/\n    │   ├── bully_scenarios_test.go     ← Milestone 2 validation scenarios\n    │   ├── ring_scenarios_test.go      ← Milestone 3 validation scenarios\n    │   └── integration_scenarios_test.go ← Cross-milestone integration tests\n    └── chaos/\n        ├── partition_test.go           ← Network partition chaos tests\n        ├── failure_test.go             ← Node failure chaos tests\n        └── timing_test.go              ← Timing failure chaos tests\n```\n\n**C. Complete Test Transport Infrastructure:**\n\nThe testing infrastructure requires a controllable transport implementation that can simulate network conditions, inject failures, and provide deterministic message delivery for reproducible tests.\n\n```go\n// TestTransport provides controllable message delivery for testing\ntype TestTransport struct {\n    nodeID        NodeID\n    messageQueue  chan *Message\n    deliveryRules map[string]DeliveryRule\n    networkState  *NetworkState\n    faultInjector *FaultInjector\n    messageLog    []MessageEvent\n    mu            sync.RWMutex\n}\n\ntype DeliveryRule struct {\n    Delay      time.Duration\n    DropRate   float64    // 0.0 = no drops, 1.0 = drop all\n    Duplicate  bool       // Whether to duplicate messages\n    Reorder    bool       // Whether to deliver out of order\n}\n\ntype NetworkState struct {\n    partitions map[NodeID][]NodeID  // Which nodes each node can reach\n    failures   map[NodeID]bool      // Which nodes are marked as failed\n}\n\ntype FaultInjector struct {\n    activeRules map[string]FaultRule\n    randomSeed  int64\n}\n\n// SendMessage implements Transport interface with controlled delivery\nfunc (t *TestTransport) SendMessage(target NodeID, msg *Message) error {\n    // TODO 1: Check if target is reachable according to network state\n    // TODO 2: Apply fault injection rules (delay, drop, duplicate)\n    // TODO 3: Log message for test verification\n    // TODO 4: Deliver message to target's message queue\n    // Hint: Use network state partitions to simulate unreachable nodes\n}\n\n// BroadcastMessage sends to all reachable nodes in current partition\nfunc (t *TestTransport) BroadcastMessage(msg *Message) error {\n    // TODO 1: Get list of nodes reachable from this node\n    // TODO 2: Send message to each reachable node using SendMessage\n    // TODO 3: Collect any delivery errors and return aggregated error\n    // Hint: Use t.networkState.partitions[t.nodeID] for reachable nodes\n}\n\n// ReceiveMessages returns channel for receiving messages\nfunc (t *TestTransport) ReceiveMessages() <-chan *Message {\n    return t.messageQueue\n}\n```\n\n**D. Multi-Node Test Cluster Management:**\n\nManaging multiple nodes in test scenarios requires coordination of node lifecycle, transport configuration, and state synchronization.\n\n```go\n// TestCluster manages multiple nodes for integration testing\ntype TestCluster struct {\n    nodes       map[NodeID]*ElectionCoordinator\n    transports  map[NodeID]*TestTransport\n    networkSim  *NetworkSimulator\n    timeline    *TestTimeline\n    config      TestClusterConfig\n}\n\ntype TestClusterConfig struct {\n    NodeCount           int\n    InitialLeaderID     NodeID\n    HeartbeatInterval   time.Duration\n    ElectionTimeout     time.Duration\n    FailureDetectionTimeout time.Duration\n}\n\n// StartCluster initializes and starts all nodes\nfunc (tc *TestCluster) StartCluster() error {\n    // TODO 1: Create TestTransport for each node\n    // TODO 2: Initialize ElectionCoordinator for each node  \n    // TODO 3: Configure inter-node connectivity\n    // TODO 4: Start all nodes and wait for initial leader election\n    // TODO 5: Verify cluster reaches stable state\n    // Hint: Use sync.WaitGroup to wait for all nodes to start\n}\n\n// SimulateFailure stops a specific node and triggers failure detection\nfunc (tc *TestCluster) SimulateFailure(nodeID NodeID) error {\n    // TODO 1: Stop the target node's ElectionCoordinator\n    // TODO 2: Mark node as failed in all transport network states\n    // TODO 3: Wait for failure detection timeout\n    // TODO 4: Verify other nodes detect the failure\n    // Hint: Check that node is removed from cluster membership\n}\n\n// CreatePartition splits cluster into separate communication groups\nfunc (tc *TestCluster) CreatePartition(groups [][]NodeID) error {\n    // TODO 1: Update network state for each transport\n    // TODO 2: Ensure nodes can only communicate within their partition\n    // TODO 3: Trigger partition detection in affected nodes\n    // TODO 4: Verify each partition operates independently\n    // Hint: Use transport delivery rules to block cross-partition messages\n}\n\n// WaitForElection waits for election to complete and returns winner\nfunc (tc *TestCluster) WaitForElection(timeout time.Duration) (NodeID, error) {\n    // TODO 1: Start timeout timer\n    // TODO 2: Poll all nodes for leadership status\n    // TODO 3: Return when exactly one leader is found\n    // TODO 4: Return error if timeout expires or multiple leaders found\n    // Hint: Check IsLeader() on all node coordinators\n}\n```\n\n**E. Fault Injection Framework:**\n\nSystematic fault injection requires configurable failure scenarios that can be applied during specific test phases.\n\n```go\n// FaultScenario defines a specific failure injection pattern\ntype FaultScenario struct {\n    Name         string\n    Description  string\n    Setup        func(*TestCluster) error\n    Trigger      func(*TestCluster) error\n    Validation   func(*TestCluster) error\n    Cleanup      func(*TestCluster) error\n}\n\n// Milestone Checkpoint Validation Functions\nfunc ValidateMilestone1Messaging(tc *TestCluster) error {\n    // TODO 1: Send test messages between all node pairs\n    // TODO 2: Verify all messages are received correctly\n    // TODO 3: Test broadcast message delivery to all nodes\n    // TODO 4: Verify failure detection works within timeout\n    // Hint: Use tc.transports to access message logs for verification\n}\n\nfunc ValidateMilestone2BullyElection(tc *TestCluster) error {\n    // TODO 1: Stop current leader node\n    // TODO 2: Wait for election completion\n    // TODO 3: Verify highest-ID responsive node becomes leader\n    // TODO 4: Verify all nodes acknowledge the new leader\n    // Hint: Check that GetCurrentLeader() returns same ID on all nodes\n}\n\nfunc ValidateMilestone3RingElection(tc *TestCluster) error {\n    // TODO 1: Configure cluster to use ring election algorithm\n    // TODO 2: Trigger election and capture token circulation\n    // TODO 3: Verify token visits all live nodes exactly once  \n    // TODO 4: Verify highest-ID participant becomes leader\n    // Hint: Use message logs to trace token forwarding sequence\n}\n```\n\n**F. Chaos Testing Scenarios:**\n\n```go\nvar ChaosScenarios = []FaultScenario{\n    {\n        Name: \"Network Partition During Election\",\n        Description: \"Split cluster while bully election is in progress\",\n        Setup: func(tc *TestCluster) error {\n            // Start normal 5-node cluster\n            return tc.StartCluster()\n        },\n        Trigger: func(tc *TestCluster) error {\n            // Stop leader to trigger election, then immediately partition\n            leader := tc.GetCurrentLeader()\n            tc.SimulateFailure(leader)\n            time.Sleep(100 * time.Millisecond) // Let election start\n            return tc.CreatePartition([][]NodeID{{1, 2}, {3, 4, 5}})\n        },\n        Validation: func(tc *TestCluster) error {\n            // TODO: Verify each partition elects independent leader\n            // TODO: Verify no cross-partition communication\n            // TODO: Heal partition and verify unified leadership\n        },\n    },\n    \n    {\n        Name: \"Cascading Leader Failures\", \n        Description: \"Multiple consecutive leader failures during recovery\",\n        Trigger: func(tc *TestCluster) error {\n            // TODO 1: Fail current leader\n            // TODO 2: Wait for new leader election\n            // TODO 3: Immediately fail the new leader  \n            // TODO 4: Repeat 2-3 times to create cascade\n            // TODO 5: Verify system eventually stabilizes\n        },\n    },\n}\n```\n\n**G. Milestone Validation Checkpoints:**\n\nEach milestone requires automated validation that can be run as part of continuous integration.\n\n```bash\n# Milestone 1 Validation Script\n#!/bin/bash\necho \"Validating Milestone 1: Node Communication\"\n\n# Start test nodes\ngo run cmd/testnode/main.go --id=1 --port=8001 &\ngo run cmd/testnode/main.go --id=2 --port=8002 &\ngo run cmd/testnode/main.go --id=3 --port=8003 &\n\nsleep 2  # Wait for startup\n\n# Test point-to-point messaging\ncurl -X POST http://localhost:8001/send \\\n  -d '{\"target\": 2, \"message\": \"test\"}' \\\n  -H \"Content-Type: application/json\"\n\n# Verify message delivery\nMESSAGES=$(curl -s http://localhost:8002/messages)\nif [[ $MESSAGES == *\"test\"* ]]; then\n    echo \"✓ Point-to-point messaging works\"\nelse\n    echo \"✗ Point-to-point messaging failed\"\n    exit 1\nfi\n\n# Test failure detection\nkill %2  # Stop node 2\nsleep 6  # Wait for failure detection\n\nMEMBERSHIP=$(curl -s http://localhost:8001/membership)\nif [[ $MEMBERSHIP != *\"2\"* ]]; then\n    echo \"✓ Failure detection works\"\nelse\n    echo \"✗ Failure detection failed\"\n    exit 1  \nfi\n\necho \"Milestone 1 validation complete\"\n```\n\n**H. Performance and Load Testing:**\n\n```go\n// LoadTest runs election algorithms under high message volume\nfunc LoadTestElections(t *testing.T) {\n    cluster := NewTestCluster(10) // 10-node cluster\n    defer cluster.Cleanup()\n    \n    // Generate background message load\n    for i := 0; i < 100; i++ {\n        go func() {\n            for {\n                // Send random messages between nodes\n                cluster.SendRandomMessage()\n                time.Sleep(10 * time.Millisecond)\n            }\n        }()\n    }\n    \n    // Run 50 consecutive elections\n    for i := 0; i < 50; i++ {\n        leader := cluster.GetCurrentLeader()\n        cluster.SimulateFailure(leader)\n        \n        newLeader, err := cluster.WaitForElection(5 * time.Second)\n        require.NoError(t, err)\n        require.NotEqual(t, leader, newLeader)\n        \n        // Verify election completed correctly under load\n        cluster.ValidateLeadershipConsistency()\n    }\n}\n```\n\nThis testing infrastructure provides comprehensive validation coverage for all project milestones while enabling both automated testing and manual verification of distributed leader election behavior.\n\n\n## Debugging Guide\n\n> **Milestone(s):** All milestones - systematic troubleshooting approach for node communication (Milestone 1), bully election correctness (Milestone 2), ring election reliability (Milestone 3), and integration issues across all components\n\nDistributed leader election systems present unique debugging challenges because failures often manifest as subtle timing issues, message ordering problems, or complex interactions between multiple nodes. Unlike traditional single-process applications where stack traces and debuggers provide clear failure paths, distributed systems require a systematic approach to correlate events across multiple nodes, understand the temporal relationships between messages, and identify root causes that may be separated in time and space from their visible symptoms.\n\n### Mental Model: Detective Work with Multiple Witnesses\n\nThink of debugging a distributed leader election system like solving a crime with multiple witnesses who each saw different parts of the story. Each node is a witness that observed certain events (messages received, timeouts triggered, state transitions) but has an incomplete picture of what happened across the entire cluster. Your job as the debugging detective is to:\n\n1. **Collect testimony from all witnesses** - gather logs from every node to understand their individual perspectives\n2. **Establish a timeline** - correlate timestamps across nodes to understand the sequence of events\n3. **Identify inconsistencies** - look for places where different nodes have conflicting views of reality\n4. **Trace the chain of causation** - follow how one event (like a network partition) led to downstream effects (like split-brain)\n5. **Reconstruct the complete story** - piece together what actually happened from the distributed evidence\n\nThe key insight is that no single node has the complete picture. A network partition might look like \"leader stopped responding\" from one side and \"followers became unreachable\" from the other side. Only by combining perspectives can you understand that the network split, creating two isolated groups.\n\n### Symptom-Cause-Fix Reference\n\nThe following table provides a systematic approach to diagnosing common leader election problems. Each entry maps observable symptoms to their most likely root causes, provides specific diagnostic steps, and suggests concrete fixes.\n\n| Symptom | Root Cause | Diagnostic Steps | Fix |\n|---------|------------|------------------|-----|\n| No leader elected after cluster starts | Bootstrap election never initiated | Check if any node has `StateFollower` and no `currentLeader` set; verify `ElectionTrigger` with `TriggerStartup` was generated | Add bootstrap logic in cluster initialization: `ProcessElectionTrigger(ElectionTrigger{Type: TriggerStartup, NodeID: nodeID, Timestamp: time.Now().UnixNano()})` |\n| Elections start but never complete | Election messages not reaching higher-ID nodes | Examine transport layer logs for `SendMessage` failures to specific nodes; check `ClusterMembership.activeMembers` for missing high-ID nodes | Fix node discovery mechanism; ensure `UpdateMembership` includes all cluster nodes; verify TCP connectivity to high-ID nodes |\n| Multiple nodes claim leadership simultaneously | Split-brain during network partition | Check if cluster split into multiple groups by analyzing `HeartbeatMessage` delivery patterns; verify each group elected separate leaders | Implement quorum-based election: only allow leadership if `CanElectLeader()` returns true based on majority membership |\n| Bully elections timeout with no responses | Higher-ID nodes crashed or partitioned | Use `FailureDetector.CheckForFailures()` to identify unresponsive nodes; verify `ElectionMessage` sent to correct node IDs | Remove failed nodes from `ClusterMembership` before election; implement adaptive timeouts with `AdaptiveTimeoutManager` |\n| Ring elections circulate forever | Token never returns to initiator | Trace `RingToken.Participants` growth around ring; check if `findNextLiveNode` skipping failed nodes correctly; verify `Complete` field set when token returns to initiator | Fix ring topology with `RebuildRing()` after failures; add hop count limit to detect broken rings; ensure `Complete` flag set when `InitiatorID` receives own token |\n| Rapid succession of elections (election storm) | Cascading failures during recovery | Monitor `ElectionRecord` timing; check if new elections start before previous ones complete; look for `CascadeDetector` warnings | Implement election backoff: delay new elections exponentially; use `ElectionState.activeElectionID` to prevent concurrent elections; add cooling period after failed elections |\n| Leader elected but immediately steps down | Term conflicts or immediate re-election | Check `LeadershipManager.currentTerm` consistency; verify no higher-term messages arriving immediately after election | Ensure term increment before election; validate term numbers in all messages; implement graceful leadership transition with state synchronization |\n| Nodes receive messages out of order | Network reordering or delayed delivery | Compare `Message.Timestamp` with processing order; check `MessageSequencer` queue states; verify sequence numbers in logs | Enable message sequencing with proper ordering; add sequence numbers to all message types; implement reorder buffers in transport layer |\n| Elections succeed but leader doesn't perform duties | `LeadershipManager` not starting after election | Verify `AssumeLeadership` called after election victory; check if `SendHeartbeat` and coordination handlers started | Call `AssumeLeadership` immediately after `CoordinatorMessage` broadcast; start heartbeat ticker and register coordination handlers |\n| False failure detection triggers unnecessary elections | Aggressive timeout values or network latency spikes | Analyze `HeartbeatMessage` delivery times vs `FailureDetector` timeout; check for network latency patterns; verify suspicion levels before declaring failures | Tune failure detection timeouts; implement graduated suspicion with `IncreaseSuspicion`; use adaptive timeouts based on observed network conditions |\n| Node rejoining cluster disrupts stable leadership | Rejoining node triggers election unnecessarily | Check if rejoining node has stale term number; verify membership updates don't trigger elections; ensure graceful reintegration | Update rejoining node's term to current leader's term; implement graceful re-joining that doesn't disrupt stable leadership |\n| Elections work in testing but fail in production | Race conditions under real network delays | Run tests with realistic network delays; enable fault injection with message reordering; test with multiple concurrent elections | Add proper synchronization around state transitions; implement atomic operations for critical sections; test under various network conditions |\n\nThis reference table covers the most common failure scenarios encountered when implementing leader election systems. Each symptom typically has a specific debugging approach that leads to the root cause and a concrete fix.\n\n### Debugging Strategies\n\nEffective debugging of distributed leader election systems requires a combination of observational techniques, state inspection tools, and systematic investigation approaches. The following strategies provide a methodical framework for identifying and resolving issues across the distributed system.\n\n**State Correlation Across Nodes**\n\nThe most powerful debugging technique for distributed systems is correlating state across multiple nodes at specific points in time. Each node maintains its own view of the cluster state through `ElectionState`, `ClusterMembership`, and algorithm-specific state in `BullyElection` or `RingElection`. Inconsistencies between these views often reveal the root cause of election failures.\n\nTo perform state correlation effectively, capture snapshots of key state at regular intervals and during significant events. The `ElectionState` should show each node's view of the current leader, term, and election status. The `ClusterMembership` reveals which nodes each node believes are alive. Algorithm-specific state like `RingTopology.successorMap` shows whether nodes agree on ring structure.\n\n> **Key Insight**: Distributed bugs often manifest as state inconsistencies between nodes. A node that believes it's the leader while others don't recognize its authority indicates a coordination failure that can be traced through message logs.\n\n**Message Flow Analysis**\n\nMessage flow analysis involves tracing the complete path of election messages through the cluster to identify where the protocol deviates from expected behavior. This is particularly valuable for debugging complex scenarios like concurrent elections or message reordering.\n\nStart by identifying a specific election using its `ElectionMessage.ElectionID`, then trace all related messages chronologically across all nodes. For bully elections, verify that `ElectionMessage` instances reach all higher-ID nodes, `OKMessage` responses return to the initiator, and `CoordinatorMessage` broadcasts reach all nodes. For ring elections, follow the `RingToken` as it travels around the ring, checking that `Participants` grows correctly and the token eventually returns to the initiator.\n\n**Timing Analysis and Race Condition Detection**\n\nMany leader election bugs stem from timing issues where the order of operations differs from expected behavior. Race conditions can cause scenarios like multiple nodes starting elections simultaneously or messages arriving after timeouts have already fired.\n\nAnalyze timing by comparing `Message.Timestamp` values across the cluster with local event timestamps. Look for patterns where timeouts fire just before expected messages arrive, or where concurrent operations create unexpected interleavings. The `ElectionTimeoutManager` logs provide insight into when timeouts were set, fired, or canceled.\n\n**Transport Layer Inspection**\n\nSince all inter-node communication flows through the `Transport` interface, transport layer problems can cause symptoms that appear to be election algorithm bugs. Network partitions, message loss, and delivery delays all manifest as election failures.\n\nInspect transport layer behavior by examining message delivery patterns. Verify that `SendMessage` calls succeed and that `ReceiveMessages` delivers messages in reasonable time. Look for patterns where messages to specific nodes consistently fail, indicating network connectivity issues. Check whether `BroadcastMessage` reaches all intended recipients.\n\n**Failure Injection and Reproducibility**\n\nMany distributed systems bugs only occur under specific timing or failure conditions that are difficult to reproduce naturally. Controlled failure injection helps reproduce problems consistently and validate fixes.\n\nUse `TestTransport` with configurable `DeliveryRule` settings to inject message delays, drops, and reordering. Simulate node failures at specific points in the election process. Create network partitions that isolate different subsets of nodes. This systematic approach helps identify edge cases and validate the robustness of error handling code.\n\n**Component Isolation Testing**\n\nWhen facing complex integration issues, isolate individual components to determine whether problems originate in specific subsystems or their interactions. Test the `FailureDetector`, `ClusterMembership`, and election algorithms separately before debugging their integration.\n\nFor example, test whether `FailureDetector.CheckForFailures()` correctly identifies unresponsive nodes independent of election logic. Verify that `ClusterMembership.UpdateMembership()` maintains consistent member lists. Validate that `BullyElection.StartElection()` sends correct messages when membership is stable. This approach narrows down the problem domain significantly.\n\nThe following table summarizes these debugging strategies with specific techniques and tools:\n\n| Strategy | Technique | Tools/Methods | When to Use |\n|----------|-----------|---------------|-------------|\n| State Correlation | Compare node states at same logical time | Snapshot `ElectionState`, `ClusterMembership` across nodes | Multiple nodes disagree on leader or membership |\n| Message Flow Analysis | Trace election messages chronologically | Filter logs by `ElectionID`, correlate timestamps | Elections start but don't complete properly |\n| Timing Analysis | Identify race conditions and ordering issues | Compare `Message.Timestamp` with local events | Intermittent failures or timing-dependent bugs |\n| Transport Inspection | Examine message delivery patterns | Monitor `SendMessage`/`ReceiveMessages` success rates | Messages appear lost or delayed |\n| Failure Injection | Reproduce bugs with controlled failures | Use `TestTransport` with fault injection | Hard-to-reproduce edge cases |\n| Component Isolation | Test subsystems independently | Unit tests for `FailureDetector`, `ClusterMembership` | Complex integration problems |\n\n### Logging and Observability\n\nEffective observability is crucial for debugging distributed leader election systems because problems often involve complex interactions between multiple nodes over time. The logging strategy must capture enough detail to reconstruct distributed execution flows while remaining performant enough for production use.\n\n**Structured Election Event Logging**\n\nAll election-related events should use structured logging with consistent field names and formats to enable automated analysis and correlation. Each log entry should include the node ID, timestamp, election ID (when applicable), current term, and current state to provide context for the event.\n\nCritical events that must always be logged include election initiation (`StartElection` calls), state transitions (follower to candidate to leader), message sending and receiving, timeout events, and leadership changes. These events form the backbone of election flow analysis and help reconstruct the complete timeline of distributed operations.\n\nThe following table defines the essential log events and their required fields:\n\n| Event Type | Required Fields | Description | Example |\n|------------|-----------------|-------------|---------|\n| Election Started | NodeID, ElectionID, Term, Trigger | Node initiates new election | `{\"event\": \"election_started\", \"node\": 3, \"election_id\": 12345, \"term\": 5, \"trigger\": \"leader_failure\"}` |\n| Message Sent | NodeID, MessageType, Target, ElectionID, Term | Outgoing election message | `{\"event\": \"message_sent\", \"node\": 3, \"type\": \"ELECTION\", \"target\": 5, \"election_id\": 12345}` |\n| Message Received | NodeID, MessageType, Source, ElectionID, Term | Incoming election message | `{\"event\": \"message_received\", \"node\": 5, \"type\": \"ELECTION\", \"source\": 3, \"election_id\": 12345}` |\n| State Transition | NodeID, OldState, NewState, Term, Reason | Node state changes | `{\"event\": \"state_transition\", \"node\": 3, \"old_state\": \"Follower\", \"new_state\": \"Candidate\", \"term\": 5}` |\n| Leader Change | NodeID, OldLeader, NewLeader, Term, ElectionID | Leadership change detected | `{\"event\": \"leader_change\", \"node\": 3, \"old_leader\": 7, \"new_leader\": 5, \"term\": 6}` |\n| Timeout Event | NodeID, TimeoutType, ElectionID, Duration | Timeout fired or canceled | `{\"event\": \"timeout\", \"node\": 3, \"type\": \"election_timeout\", \"election_id\": 12345, \"duration\": \"2s\"}` |\n| Failure Detected | NodeID, FailedNode, SuspicionLevel, Method | Node failure detection | `{\"event\": \"failure_detected\", \"node\": 3, \"failed_node\": 7, \"suspicion\": 3, \"method\": \"heartbeat_timeout\"}` |\n\n**Cross-Node Message Correlation**\n\nTo trace message flows across the distributed system, each message must include correlation identifiers that link related events on different nodes. The `Message.ElectionID` serves as the primary correlation key for election-related messages, while `Message.Term` provides ordering context.\n\nWhen logging message events, always include both the local perspective (what this node did) and the remote context (what election or term this relates to). This dual perspective enables reconstruction of distributed message flows by joining log entries from different nodes on shared correlation IDs.\n\nImplement message correlation logging in the `Transport` layer so it's captured consistently regardless of which election algorithm generates the messages. Log both successful message delivery and failures, including timeout and network error details.\n\n**Performance and Resource Monitoring**\n\nLeader election performance directly impacts cluster availability, so monitoring election timing, message volume, and resource usage is essential for both debugging and operational health. Track metrics like election duration, message count per election, timeout frequency, and failure detection accuracy.\n\nKey performance metrics to monitor include:\n- Election completion time (from initiation to coordinator announcement)\n- Message volume per election (total messages sent/received)\n- Timeout frequency (how often elections timeout without completion)\n- False positive rate (failures detected but node was actually alive)\n- Leadership stability (how long leaders remain in power)\n\nThese metrics help identify performance problems and validate that optimizations don't introduce correctness issues.\n\n**Distributed Tracing for Election Flows**\n\nFor complex debugging scenarios, implement distributed tracing that follows individual elections across all participating nodes. Each election gets a unique trace ID (the `ElectionID`), and all related operations on all nodes contribute spans to that trace.\n\nA complete election trace includes spans for election initiation, message sending/receiving, timeout management, state transitions, and coordinator announcement. This provides a visual timeline of how an election progresses through the distributed system and helps identify bottlenecks or failure points.\n\n**Log Aggregation and Analysis**\n\nIn production deployments with multiple nodes, log aggregation becomes essential for effective debugging. All nodes should ship logs to a centralized system where they can be correlated by timestamp and election ID.\n\nImplement log analysis tools that can automatically identify common failure patterns like election storms, split-brain scenarios, and cascading failures. These tools should parse structured logs, correlate events across nodes, and generate summaries of election behavior over time.\n\nThe following table outlines the recommended log levels and their appropriate use:\n\n| Log Level | Usage | Examples | Performance Impact |\n|-----------|-------|----------|-------------------|\n| ERROR | Critical failures that prevent elections | Failed to send election message, corrupted state | Minimal - rare events |\n| WARN | Recoverable issues or suspicious conditions | Election timeout, potential split-brain detected | Low - occasional events |\n| INFO | Normal election events and state changes | Election started, leader elected, state transitions | Moderate - regular events |\n| DEBUG | Detailed message flows and internal state | Message contents, membership updates, ring topology | High - verbose logging |\n| TRACE | Fine-grained debugging information | Function entry/exit, detailed state snapshots | Very high - development only |\n\n### Implementation Guidance\n\nThis section provides practical tools and code structures for implementing effective debugging capabilities in your leader election system. The focus is on building observability and diagnostic capabilities that work across distributed nodes.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Logging | `log/slog` with JSON formatting | Structured logging with OpenTelemetry |\n| Metrics | Simple counters with periodic output | Prometheus metrics with Grafana dashboards |\n| Tracing | Basic correlation IDs in logs | Distributed tracing with Jaeger |\n| Log Analysis | grep/jq for log correlation | ELK stack or similar log aggregation |\n\n#### Structured Logging Infrastructure\n\n```go\npackage main\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"log/slog\"\n    \"os\"\n    \"time\"\n)\n\n// ElectionLogger provides structured logging for election events\ntype ElectionLogger struct {\n    logger *slog.Logger\n    nodeID NodeID\n}\n\n// NewElectionLogger creates a logger with node context\nfunc NewElectionLogger(nodeID NodeID) *ElectionLogger {\n    opts := &slog.HandlerOptions{\n        Level: slog.LevelInfo,\n        AddSource: false,\n    }\n    \n    handler := slog.NewJSONHandler(os.Stdout, opts)\n    logger := slog.New(handler)\n    \n    return &ElectionLogger{\n        logger: logger.With(\"node_id\", nodeID),\n        nodeID: nodeID,\n    }\n}\n\n// LogElectionStarted records election initiation\nfunc (el *ElectionLogger) LogElectionStarted(electionID uint64, term uint64, trigger string) {\n    el.logger.Info(\"election_started\",\n        \"election_id\", electionID,\n        \"term\", term,\n        \"trigger\", trigger,\n        \"timestamp\", time.Now().UnixNano(),\n    )\n}\n\n// LogMessageSent records outgoing election message\nfunc (el *ElectionLogger) LogMessageSent(msgType MessageType, target NodeID, electionID uint64) {\n    el.logger.Info(\"message_sent\",\n        \"message_type\", msgType,\n        \"target_node\", target,\n        \"election_id\", electionID,\n        \"timestamp\", time.Now().UnixNano(),\n    )\n}\n\n// LogStateTransition records node state changes\nfunc (el *ElectionLogger) LogStateTransition(oldState, newState NodeState, term uint64, reason string) {\n    el.logger.Info(\"state_transition\",\n        \"old_state\", oldState,\n        \"new_state\", newState,\n        \"term\", term,\n        \"reason\", reason,\n        \"timestamp\", time.Now().UnixNano(),\n    )\n}\n```\n\n#### Debug State Snapshot Utilities\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\n// NodeStateSnapshot captures complete node state for debugging\ntype NodeStateSnapshot struct {\n    NodeID           NodeID                 `json:\"node_id\"`\n    Timestamp        int64                  `json:\"timestamp\"`\n    ElectionState    *ElectionState         `json:\"election_state\"`\n    Membership       []NodeID               `json:\"active_members\"`\n    RingTopology     map[NodeID]NodeID      `json:\"ring_successors,omitempty\"`\n    PendingMessages  int                    `json:\"pending_messages\"`\n    LastSeen         map[NodeID]int64       `json:\"last_seen\"`\n}\n\n// DebugStateCollector gathers state snapshots across cluster\ntype DebugStateCollector struct {\n    snapshots map[NodeID]*NodeStateSnapshot\n    mu        sync.RWMutex\n}\n\n// NewDebugStateCollector creates collector for state debugging\nfunc NewDebugStateCollector() *DebugStateCollector {\n    return &DebugStateCollector{\n        snapshots: make(map[NodeID]*NodeStateSnapshot),\n    }\n}\n\n// CaptureSnapshot records current node state\nfunc (dsc *DebugStateCollector) CaptureSnapshot(coordinator *ElectionCoordinator) {\n    // TODO: Extract current election state from coordinator\n    // TODO: Get active membership list from ClusterMembership\n    // TODO: Capture ring topology if using ring election\n    // TODO: Count pending messages in transport queues\n    // TODO: Record last seen timestamps for failure detection\n    \n    snapshot := &NodeStateSnapshot{\n        NodeID:    coordinator.nodeID,\n        Timestamp: time.Now().UnixNano(),\n        // Fill in other fields based on coordinator state\n    }\n    \n    dsc.mu.Lock()\n    dsc.snapshots[coordinator.nodeID] = snapshot\n    dsc.mu.Unlock()\n}\n\n// CompareStates identifies inconsistencies between node states\nfunc (dsc *DebugStateCollector) CompareStates() map[string][]string {\n    // TODO: Compare election states - do all nodes agree on current leader?\n    // TODO: Compare membership views - do all nodes see same active members?\n    // TODO: Compare ring topology - is ring structure consistent?\n    // TODO: Identify nodes with stale or inconsistent state\n    \n    inconsistencies := make(map[string][]string)\n    \n    dsc.mu.RLock()\n    defer dsc.mu.RUnlock()\n    \n    // Implementation provides framework for state comparison\n    return inconsistencies\n}\n```\n\n#### Message Flow Tracer\n\n```go\npackage main\n\nimport (\n    \"sync\"\n    \"time\"\n)\n\n// MessageTrace represents a single message in an election flow\ntype MessageTrace struct {\n    ElectionID  uint64      `json:\"election_id\"`\n    MessageType MessageType `json:\"message_type\"`\n    Source      NodeID      `json:\"source\"`\n    Target      NodeID      `json:\"target\"`\n    Timestamp   int64       `json:\"timestamp\"`\n    Success     bool        `json:\"success\"`\n    Error       string      `json:\"error,omitempty\"`\n}\n\n// ElectionFlowTracer tracks message flows for debugging\ntype ElectionFlowTracer struct {\n    traces map[uint64][]*MessageTrace\n    mu     sync.RWMutex\n}\n\n// NewElectionFlowTracer creates tracer for election debugging\nfunc NewElectionFlowTracer() *ElectionFlowTracer {\n    return &ElectionFlowTracer{\n        traces: make(map[uint64][]*MessageTrace),\n    }\n}\n\n// TraceMessageSent records outgoing message\nfunc (eft *ElectionFlowTracer) TraceMessageSent(electionID uint64, msgType MessageType, source, target NodeID) {\n    trace := &MessageTrace{\n        ElectionID:  electionID,\n        MessageType: msgType,\n        Source:      source,\n        Target:      target,\n        Timestamp:   time.Now().UnixNano(),\n        Success:     true,\n    }\n    \n    eft.mu.Lock()\n    eft.traces[electionID] = append(eft.traces[electionID], trace)\n    eft.mu.Unlock()\n}\n\n// AnalyzeElectionFlow identifies problems in message sequences\nfunc (eft *ElectionFlowTracer) AnalyzeElectionFlow(electionID uint64) []string {\n    // TODO: Check if all expected messages were sent\n    // TODO: Verify message ordering matches algorithm requirements\n    // TODO: Identify missing acknowledgments or coordinator messages\n    // TODO: Detect timing issues like messages sent after timeouts\n    \n    issues := []string{}\n    \n    eft.mu.RLock()\n    traces := eft.traces[electionID]\n    eft.mu.RUnlock()\n    \n    // Framework for analyzing message flow patterns\n    return issues\n}\n```\n\n#### Fault Injection Testing Framework\n\n```go\npackage main\n\nimport (\n    \"context\"\n    \"math/rand\"\n    \"time\"\n)\n\n// FaultInjector enables controlled failure scenarios for testing\ntype FaultInjector struct {\n    dropRate    float64\n    delayRange  time.Duration\n    partitions  map[NodeID][]NodeID\n    enabled     bool\n}\n\n// NewFaultInjector creates configurable fault injection\nfunc NewFaultInjector() *FaultInjector {\n    return &FaultInjector{\n        partitions: make(map[NodeID][]NodeID),\n        enabled:    false,\n    }\n}\n\n// EnableMessageDrop configures message loss simulation\nfunc (fi *FaultInjector) EnableMessageDrop(rate float64) {\n    // TODO: Set drop rate for random message loss\n    // TODO: Enable fault injection in transport layer\n    fi.dropRate = rate\n    fi.enabled = true\n}\n\n// CreateNetworkPartition simulates cluster split\nfunc (fi *FaultInjector) CreateNetworkPartition(groups [][]NodeID) {\n    // TODO: Configure which nodes can communicate with each other\n    // TODO: Block messages between different partition groups\n    // TODO: Update transport routing to respect partitions\n    \n    fi.partitions = make(map[NodeID][]NodeID)\n    for _, group := range groups {\n        for _, node := range group {\n            fi.partitions[node] = group\n        }\n    }\n}\n\n// ShouldDropMessage determines if message should be lost\nfunc (fi *FaultInjector) ShouldDropMessage(source, target NodeID) bool {\n    if !fi.enabled {\n        return false\n    }\n    \n    // TODO: Check partition rules - can source reach target?\n    // TODO: Apply random drop rate\n    // TODO: Return true if message should be dropped\n    \n    return rand.Float64() < fi.dropRate\n}\n```\n\n#### Milestone Debugging Checkpoints\n\n**Milestone 1 Validation (Node Communication)**\n```bash\n# Test basic messaging\ngo run cmd/node/main.go --id=1 --peers=2,3 &\ngo run cmd/node/main.go --id=2 --peers=1,3 &\ngo run cmd/node/main.go --id=3 --peers=1,2 &\n\n# Expected: All nodes discover each other and establish heartbeats\n# Check logs for: \"membership_updated\", \"heartbeat_sent\", \"heartbeat_received\"\n\n# Test failure detection\nkill -STOP $(pgrep -f \"id=3\")  # Simulate node 3 failure\n# Expected: Nodes 1 and 2 detect node 3 failure within timeout period\n# Check logs for: \"failure_detected\", \"membership_updated\" removing node 3\n```\n\n**Milestone 2 Validation (Bully Election)**\n```bash\n# Start cluster with node 3 as initial leader\n# Kill leader to trigger bully election\nkill -TERM $(pgrep -f \"id=3\")\n\n# Expected: Node 2 (highest remaining ID) becomes new leader\n# Check logs for proper message sequence:\n# 1. \"failure_detected\" on nodes 1,2\n# 2. \"election_started\" from node with highest ID\n# 3. \"message_sent\" ELECTION messages to higher nodes\n# 4. \"message_sent\" COORDINATOR from winner\n# 5. \"leader_change\" on all nodes\n```\n\n**Milestone 3 Validation (Ring Election)**\n```bash\n# Configure ring topology: 1→2→3→1\n# Trigger ring election from node 1\ncurl -X POST http://localhost:8001/debug/start-election\n\n# Expected: Token circulates through ring and node 3 wins\n# Check logs for:\n# 1. \"ring_election_started\" with initial token\n# 2. \"token_forwarded\" as token travels ring\n# 3. \"participants_updated\" as nodes join token\n# 4. \"election_completed\" when token returns to initiator\n# 5. \"coordinator_announced\" with highest-ID winner\n```\n\n#### Common Debugging Symptoms and Fixes\n\n| Symptom | Debug Command | Fix |\n|---------|---------------|-----|\n| Elections never start | `grep \"election_started\" *.log` | Check failure detection and trigger logic |\n| Messages not delivered | `grep \"message_sent\\|message_received\" *.log \\| sort` | Verify transport layer and network connectivity |\n| Split-brain detected | `grep \"leader_change\" *.log \\| uniq` | Implement quorum-based elections |\n| Ring election loops | `grep \"token_forwarded\" *.log \\| tail -20` | Fix ring topology and add hop limits |\n\n\n## Future Extensions and Improvements\n\n> **Milestone(s):** Extension beyond all milestones - advanced features and optimizations that could be added to enhance the basic leader election system after completing node communication (Milestone 1), bully algorithm (Milestone 2), and ring election (Milestone 3)\n\nAfter implementing the foundational leader election algorithms and node communication infrastructure, numerous opportunities emerge to enhance performance, reliability, and operational capabilities. This section explores advanced optimizations, alternative algorithms, and production-readiness features that transform a basic leader election system into an enterprise-grade distributed coordination service.\n\n### Performance Improvements\n\nThe basic bully and ring election algorithms prioritize correctness and simplicity over performance. However, several optimization strategies can dramatically reduce election latency, network overhead, and system resource consumption while maintaining correctness guarantees.\n\n#### Adaptive Timeout Management\n\nTraditional election algorithms use fixed timeouts for failure detection and election phases. This approach creates a fundamental trade-off: short timeouts enable fast failure detection but increase false positives during network congestion, while long timeouts reduce false positives but slow down legitimate elections.\n\n> **Decision: Implement Adaptive Timeout Management**\n> - **Context**: Fixed timeouts cannot adapt to varying network conditions, cluster sizes, and load patterns, leading to either unnecessary elections or slow failure recovery\n> - **Options Considered**: Fixed conservative timeouts, fixed aggressive timeouts, adaptive timeout adjustment\n> - **Decision**: Implement adaptive timeout management that adjusts based on observed network behavior\n> - **Rationale**: Network conditions vary dramatically in real deployments - adaptive timeouts maintain responsiveness during normal operation while preventing election storms during congestion\n> - **Consequences**: Reduces false failure detections by 70-90% while maintaining sub-second failure detection during actual node crashes\n\nThe `AdaptiveTimeoutManager` tracks recent election success rates, network round-trip times, and failure patterns to dynamically adjust timeout values. When elections frequently succeed within the timeout window, the system gradually reduces timeouts to improve responsiveness. Conversely, when elections time out frequently or network latency increases, timeouts are extended to prevent unnecessary re-elections.\n\n| Metric | Threshold | Timeout Adjustment |\n|--------|-----------|-------------------|\n| Election success rate > 90% | Last 10 elections | Decrease timeout by 10% (min: baseTimeout/2) |\n| Election success rate < 60% | Last 10 elections | Increase timeout by 25% (max: baseTimeout*3) |\n| Average RTT increase > 50% | Rolling 60-second window | Set timeout to 3*RTT + base processing time |\n| Cascade failure detected | 3+ failures in 30 seconds | Triple timeout for next 5 minutes |\n\n#### Batched Message Delivery\n\nStandard election algorithms send individual messages for each election phase, creating significant network overhead in large clusters. A node participating in a bully election might send separate `ElectionMessage` instances to 20 higher-ID nodes, then receive individual `OKMessage` responses, generating 40+ network round-trips.\n\nBatched message delivery aggregates multiple election messages into single network transmissions, reducing both network overhead and processing latency. The `MessageBatcher` collects outgoing messages over a brief window (typically 5-50ms) and combines them into batch transmissions.\n\n| Batching Strategy | Description | Network Reduction | Latency Impact |\n|------------------|-------------|-------------------|----------------|\n| Time-based batching | Collect messages for fixed duration | 60-80% fewer packets | +10-50ms per batch |\n| Size-based batching | Send when batch reaches target size | 70-90% fewer packets | Variable (0-100ms) |\n| Adaptive batching | Adjust window based on message rate | 65-85% fewer packets | +5-30ms average |\n\nThe adaptive approach monitors message transmission patterns and adjusts batching windows dynamically. During election storms with high message rates, larger batches reduce network congestion. During normal operation with sparse messages, smaller batches maintain low latency.\n\n#### Concurrent Election Resolution\n\nMultiple concurrent elections create significant inefficiency in standard algorithms. When several nodes simultaneously detect leader failure, each initiates independent elections that often interfere with each other. The `ConcurrentElectionResolver` implements several strategies to minimize this overhead.\n\n**Election Coordination Strategy**: When a node receives an `ElectionMessage` while conducting its own election, it compares election IDs and election terms. Lower-priority elections are immediately abandoned in favor of higher-priority ones, preventing redundant network traffic and state transitions.\n\n| Concurrent Election Scenario | Standard Behavior | Optimized Behavior |\n|----------------------------|-------------------|-------------------|\n| 3 nodes detect failure simultaneously | 3 separate elections, potential conflicts | Highest-priority election proceeds, others abort |\n| Election in progress when new failure detected | New election interrupts existing one | Existing election incorporates new failure |\n| Network partition heals during election | Conflicting elections in each partition | Term-based resolution, single election continues |\n\n**Pre-emptive Leader Selection**: Instead of waiting for complete election protocols, nodes can pre-emptively identify the likely winner based on current cluster membership and immediately begin following that node. This optimization reduces election latency by 40-70% in large clusters.\n\n#### Optimized Ring Maintenance\n\nRing election performance degrades significantly when the logical ring requires frequent reconstruction due to node failures and additions. Traditional ring algorithms rebuild the entire ring structure whenever membership changes, creating O(n²) complexity in dynamic environments.\n\nThe optimized `RingTopologyManager` maintains incremental ring updates using a versioned ring structure. When nodes join or leave, only the affected ring segments are updated, preserving most of the existing topology.\n\n| Ring Operation | Standard Complexity | Optimized Complexity | Performance Gain |\n|---------------|-------------------|-------------------|-------------------|\n| Single node failure | O(n) rebuild | O(1) local repair | 10-100x faster |\n| Multiple node failures | O(n) per failure | O(k) for k failures | 2-10x faster |\n| Node recovery/rejoin | O(n) rebuild | O(log n) insertion | 5-50x faster |\n| Ring traversal | O(n) every time | O(1) with caching | Constant time |\n\n**Lazy Ring Repair**: Instead of immediately repairing ring breaks, the system marks failed nodes as \"bypassed\" and repairs ring connectivity during the next election cycle. This approach prevents expensive ring maintenance operations during cascading failures while ensuring elections can still complete successfully.\n\n### Other Election Algorithms\n\nWhile bully and ring algorithms provide excellent learning foundations, production systems often benefit from more sophisticated election approaches that offer better partition tolerance, lower latency, or stronger consistency guarantees.\n\n#### Raft Leader Election\n\nThe Raft consensus algorithm includes a highly optimized leader election protocol that provides stronger safety guarantees than traditional algorithms. Unlike bully elections where any node can claim leadership, Raft leader election requires explicit votes from a majority of nodes.\n\n> **Decision: Add Raft Leader Election as Advanced Algorithm**\n> - **Context**: Bully and ring algorithms can produce split-brain scenarios during network partitions, while Raft provides stronger safety guarantees\n> - **Options Considered**: Pure Raft implementation, simplified Raft election only, hybrid bully-raft approach\n> - **Decision**: Implement Raft leader election protocol with term-based voting\n> - **Rationale**: Raft's majority-vote requirement prevents split-brain scenarios that plague simpler algorithms, critical for production systems\n> - **Consequences**: Higher network overhead (requires majority votes) but eliminates split-brain risks and provides cleaner partition tolerance\n\nRaft leader election operates through **election terms** - monotonically increasing counters that order elections across time. When a follower node detects leader failure, it increments its term, transitions to candidate state, and requests votes from other nodes. A candidate becomes leader only after receiving votes from a strict majority of the cluster.\n\n| Raft Election Phase | Messages Sent | Safety Guarantee | Failure Handling |\n|--------------------|---------------|------------------|------------------|\n| Term increment | None | Prevents old leaders | Candidates with stale terms ignored |\n| Vote request | RequestVote to all nodes | Only one vote per term | Candidate steps down if higher term seen |\n| Majority collection | None | Prevents split elections | Election fails if majority unavailable |\n| Leader establishment | Heartbeat to all nodes | Single leader per term | Old leaders step down on higher term |\n\n**Vote Splitting Resolution**: When multiple candidates request votes simultaneously, vote splitting can prevent any candidate from achieving a majority. Raft uses randomized election timeouts to reduce this probability - each node waits a random duration before starting elections, making simultaneous candidacy unlikely.\n\n#### SWIM-based Failure Detection\n\nThe Scalable Weakly-consistent Infection-style process group Membership (SWIM) protocol provides highly efficient failure detection that scales to thousands of nodes. Unlike heartbeat-based approaches that generate O(n²) network traffic, SWIM achieves O(n) communication complexity with better failure detection accuracy.\n\nSWIM operates through **infection-style gossip** where failure suspicions spread through the cluster like epidemics. When a node suspects another node has failed, it piggybacks this suspicion on messages to other nodes. Suspicions either get confirmed (leading to member removal) or refuted (leading to suspicion clearing).\n\n| SWIM Component | Purpose | Network Overhead | Detection Latency |\n|---------------|---------|------------------|-------------------|\n| Periodic ping | Detect immediate neighbors | O(1) per node | 1-2 ping intervals |\n| Indirect ping | Verify suspected failures | O(k) where k=3-5 | 2-4 ping intervals |\n| Gossip dissemination | Spread membership changes | O(log n) per change | log(n) gossip rounds |\n| Suspicion mechanism | Avoid false positives | None | Configurable window |\n\n**Integration with Leader Election**: SWIM failure detection can trigger leader elections much more efficiently than heartbeat-based approaches. When SWIM confirms a leader failure, it can immediately provide the updated membership view to election algorithms, eliminating the membership convergence delay that plagues traditional systems.\n\n#### Weighted Election Algorithms\n\nProduction environments often have heterogeneous nodes with different capabilities, network connectivity, or reliability characteristics. Weighted election algorithms consider these factors when selecting leaders, improving overall system performance.\n\n**Capability-based Weighting**: Nodes with higher CPU, memory, or network bandwidth receive higher election weights. This ensures that more capable nodes are preferred as leaders, improving cluster performance.\n\n| Weighting Factor | Measurement Method | Impact on Election | Typical Weight Range |\n|-----------------|-------------------|-------------------|---------------------|\n| CPU capacity | Benchmark score or core count | Higher CPU preferred as leader | 1.0x to 3.0x |\n| Memory capacity | Available RAM | Prefer nodes that can handle large states | 1.0x to 2.0x |\n| Network bandwidth | Measured throughput | Prefer well-connected nodes | 0.5x to 2.0x |\n| Historical reliability | Uptime percentage | Avoid frequently-failing nodes | 0.1x to 1.5x |\n\n**Geographic Distribution**: In geographically distributed clusters, leader location significantly impacts client latency. Weighted algorithms can prefer leaders in specific regions or datacenters based on client distribution patterns.\n\n#### Byzantine Fault Tolerant Elections\n\nWhile crash-failure leader election handles node failures and network partitions, some environments require tolerance for **Byzantine failures** where nodes behave arbitrarily or maliciously. Byzantine Fault Tolerant (BFT) leader election protocols can handle up to f Byzantine failures in a cluster of 3f+1 nodes.\n\nPBFT (Practical Byzantine Fault Tolerance) leader election uses cryptographic signatures and multiple voting rounds to ensure that Byzantine nodes cannot manipulate election outcomes. Each election requires 2f+1 signatures from different nodes, making it computationally infeasible for f Byzantine nodes to forge a false election result.\n\n### Production Readiness Features\n\nTransitioning from a learning implementation to production deployment requires extensive operational tooling, monitoring capabilities, and configuration management features that enable reliable operation at scale.\n\n#### Comprehensive Metrics and Monitoring\n\nProduction leader election systems require detailed observability to diagnose performance issues, detect anomalies, and optimize configuration parameters. A comprehensive metrics system tracks election performance, network health, and cluster dynamics.\n\n**Election Performance Metrics**: Track election latency, success rates, and resource consumption across different failure scenarios and cluster sizes.\n\n| Metric Category | Key Metrics | Purpose | Alert Thresholds |\n|----------------|-------------|---------|-----------------|\n| Election latency | p50, p95, p99 election completion time | Performance monitoring | p95 > 5 seconds |\n| Election success rate | Percentage of elections that converge | Reliability tracking | < 95% success rate |\n| False failure rate | Spurious leader changes per hour | Failure detection tuning | > 2 per hour |\n| Network overhead | Messages per election, bandwidth usage | Resource optimization | > 10MB per election |\n| Split-brain incidents | Multiple simultaneous leaders | Safety monitoring | Any occurrence |\n\n**Cluster Health Metrics**: Monitor membership stability, node connectivity, and failure patterns to identify systemic issues before they impact elections.\n\n| Health Dimension | Measurements | Diagnostic Value | Intervention Triggers |\n|-----------------|---------------|------------------|----------------------|\n| Membership churn | Joins/leaves per minute | Cluster stability | > 10% nodes per minute |\n| Network connectivity | Reachability matrix between nodes | Partition detection | < 80% connectivity |\n| Failure correlation | Temporal/geographic failure patterns | Infrastructure issues | 3+ failures in same rack |\n| Election frequency | Elections per hour | System stability | > 10 elections per hour |\n\n#### Dynamic Configuration Management\n\nProduction clusters require runtime configuration adjustments without service interruption. The `ConfigurationManager` enables dynamic updates to timeout values, failure detection parameters, and algorithm selection while maintaining system consistency.\n\n**Hot Configuration Updates**: Critical parameters like election timeouts, heartbeat intervals, and failure detection thresholds can be updated without restarting nodes. The system validates new configurations and applies them gradually across the cluster.\n\n| Configuration Category | Parameters | Update Method | Validation Required |\n|-----------------------|-------------|---------------|-------------------|\n| Failure detection | Heartbeat interval, timeout multipliers | Gradual rollout | Consistency check |\n| Election algorithms | Algorithm selection, specific parameters | Leader-coordinated | Compatibility verification |\n| Network behavior | Message batching, retry policies | Immediate local | None |\n| Logging and metrics | Log levels, metric collection rates | Immediate local | None |\n\n**Configuration Versioning**: All configuration changes are versioned and tracked, enabling rollback to previous configurations when updates cause issues. The system maintains a complete audit trail of configuration changes with timestamps and initiating operators.\n\n#### Advanced Logging and Debugging\n\nProduction debugging requires sophisticated logging capabilities that can trace individual elections across all participating nodes while maintaining acceptable performance overhead.\n\n**Distributed Tracing**: Each election receives a unique trace ID that appears in all related log messages across all nodes. This enables operators to reconstruct complete election flows even in large clusters with concurrent elections.\n\n```\n[TRACE:election-7834] Node 5: Starting bully election (term=42, trigger=leader_timeout)\n[TRACE:election-7834] Node 5: Sending ELECTION to nodes [7,9,12,15] (candidates=4)\n[TRACE:election-7834] Node 7: Received ELECTION from node 5 (term=42, responding=true)\n[TRACE:election-7834] Node 7: Sending OK to node 5 (term=42, starting_own_election=true)\n[TRACE:election-7834] Node 5: Received OK from node 7 (term=42, stepping_down=true)\n```\n\n**State Correlation Analysis**: The `DebugStateCollector` periodically captures snapshots of each node's election state and identifies inconsistencies that might indicate bugs or configuration issues.\n\n| Consistency Check | Detection Method | Common Causes | Resolution Steps |\n|------------------|------------------|---------------|------------------|\n| Multiple leaders | Compare leadership claims | Network partition, timing bug | Force re-election with quorum |\n| Stale membership | Compare node membership views | Gossip failure, network issues | Trigger membership sync |\n| Term conflicts | Compare election terms across nodes | Clock skew, message reordering | Term resolution protocol |\n| Election loops | Detect repeated election patterns | Configuration error, algorithm bug | Parameter adjustment |\n\n#### Operational Tools and Automation\n\nProduction systems require extensive operational tooling for cluster management, disaster recovery, and routine maintenance operations.\n\n**Cluster Administration Interface**: A comprehensive administrative interface enables operators to monitor cluster health, trigger manual elections, and perform maintenance operations without disrupting service availability.\n\n| Administrative Operation | Purpose | Safety Checks | Rollback Capability |\n|-------------------------|---------|---------------|-------------------|\n| Manual leader election | Replace failed/degraded leader | Verify quorum availability | Previous leader restoration |\n| Node graceful shutdown | Planned maintenance | Transfer leadership first | Immediate restart |\n| Membership management | Add/remove cluster nodes | Verify majority maintained | Node re-addition |\n| Configuration deployment | Update cluster parameters | Staged rollout with validation | Previous configuration |\n| Emergency cluster reset | Recover from corruption | Operator confirmation required | State backup restoration |\n\n**Automated Recovery Procedures**: The system includes automated responses to common failure scenarios that can resolve issues without human intervention while escalating complex problems appropriately.\n\n| Failure Scenario | Automatic Response | Escalation Trigger | Manual Override |\n|------------------|-------------------|-------------------|----------------|\n| Repeated election failures | Increase timeouts, reduce membership | 5+ failures in 10 minutes | Force specific leader |\n| Split-brain detection | Shutdown minority partition | Equal-sized partitions | Operator decision |\n| Cascading node failures | Pause new elections temporarily | >50% nodes failed | Emergency cluster rebuild |\n| Configuration corruption | Revert to last known good config | Validation failures | Manual configuration |\n\n### Implementation Guidance\n\nThis section provides concrete implementation strategies for extending the basic leader election system with advanced features and production-readiness capabilities.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Metrics Collection | Prometheus client library | OpenTelemetry with custom exporters |\n| Configuration Management | JSON/YAML files with file watching | etcd/Consul with versioning |\n| Distributed Tracing | Structured logging with correlation IDs | Jaeger/Zipkin integration |\n| Administrative Interface | REST API with basic web UI | gRPC API with full dashboard |\n| Automated Testing | Unit tests with mocked failures | Chaos engineering with Jepsen |\n\n#### Recommended Module Structure\n\nThe extension modules integrate with the existing leader election system while maintaining clear separation of concerns:\n\n```\nproject-root/\n  internal/\n    coordinator/               ← core election logic (existing)\n    transport/                ← communication layer (existing)\n    \n    optimization/             ← performance improvements\n      adaptive_timeout.go     ← AdaptiveTimeoutManager\n      message_batcher.go      ← MessageBatcher\n      concurrent_resolver.go  ← ConcurrentElectionResolver\n      ring_optimizer.go       ← optimized RingTopologyManager\n      \n    algorithms/               ← additional election algorithms\n      raft_election.go        ← Raft leader election\n      weighted_election.go    ← capability-based weighting\n      swim_detector.go        ← SWIM failure detection\n      \n    production/               ← production readiness\n      metrics_collector.go    ← comprehensive metrics\n      config_manager.go       ← dynamic configuration\n      debug_collector.go      ← state correlation\n      admin_interface.go      ← operational tools\n      \n    testing/                  ← advanced testing tools\n      chaos_injector.go       ← fault injection\n      cluster_simulator.go    ← large-scale testing\n```\n\n#### Adaptive Timeout Infrastructure Code\n\n```go\npackage optimization\n\nimport (\n    \"context\"\n    \"math\"\n    \"sync\"\n    \"time\"\n)\n\n// AdaptiveTimeoutManager dynamically adjusts election timeouts based on \n// observed network behavior and election success patterns.\ntype AdaptiveTimeoutManager struct {\n    baseTimeout    time.Duration\n    minTimeout     time.Duration\n    maxTimeout     time.Duration\n    currentTimeout time.Duration\n    \n    // Metrics tracking\n    recentElections    []ElectionRecord\n    recentRTTs        []time.Duration\n    networkLatency    time.Duration\n    \n    // Adjustment parameters\n    successThreshold   float64  // 0.9 = 90% success rate\n    adjustmentFactor   float64  // 0.1 = 10% adjustment steps\n    windowSize         int      // Number of elections to track\n    \n    mu sync.RWMutex\n}\n\n// ElectionRecord tracks the outcome of individual elections for analysis\ntype ElectionRecord struct {\n    StartTime      time.Time\n    CompletionTime time.Time\n    Success        bool\n    NetworkLatency time.Duration\n    ParticipantCount int\n}\n\n// NewAdaptiveTimeoutManager creates a timeout manager with conservative defaults\nfunc NewAdaptiveTimeoutManager(baseTimeout time.Duration) *AdaptiveTimeoutManager {\n    return &AdaptiveTimeoutManager{\n        baseTimeout:       baseTimeout,\n        minTimeout:        baseTimeout / 2,\n        maxTimeout:        baseTimeout * 3,\n        currentTimeout:    baseTimeout,\n        successThreshold:  0.9,\n        adjustmentFactor:  0.1,\n        windowSize:        10,\n        recentElections:   make([]ElectionRecord, 0, 20),\n        recentRTTs:       make([]time.Duration, 0, 50),\n    }\n}\n\n// GetCurrentTimeout returns the dynamically calculated timeout value\nfunc (a *AdaptiveTimeoutManager) GetCurrentTimeout() time.Duration {\n    // TODO: Calculate timeout based on recent network latency\n    // TODO: Apply success rate adjustments (decrease if high success, increase if low)\n    // TODO: Consider participant count (more nodes = longer timeout needed)\n    // TODO: Apply cascade failure detection (triple timeout during instability)\n    // TODO: Ensure result is within min/max bounds\n    \n    a.mu.RLock()\n    defer a.mu.RUnlock()\n    return a.currentTimeout\n}\n\n// RecordElectionResult updates timeout calculations based on election outcome\nfunc (a *AdaptiveTimeoutManager) RecordElectionResult(record ElectionRecord) {\n    // TODO: Add record to recentElections window\n    // TODO: Remove oldest records if window size exceeded\n    // TODO: Recalculate timeout based on updated success rate\n    // TODO: Update network latency estimates\n    // TODO: Apply adjustment factor to smooth timeout changes\n}\n\n// RecordNetworkRTT updates network latency estimates from heartbeat/ping data\nfunc (a *AdaptiveTimeoutManager) RecordNetworkRTT(rtt time.Duration) {\n    // TODO: Add RTT to sliding window\n    // TODO: Calculate moving average of network latency\n    // TODO: Adjust timeout if latency significantly changed (>50% increase)\n    // TODO: Remove old RTT samples to keep window current\n}\n```\n\n#### Raft Leader Election Core Logic\n\n```go\npackage algorithms\n\nimport (\n    \"context\"\n    \"math/rand\"\n    \"time\"\n)\n\n// RaftElection implements the Raft leader election protocol with term-based voting\ntype RaftElection struct {\n    nodeID      NodeID\n    transport   Transport\n    membership  *ClusterMembership\n    \n    // Raft-specific state\n    currentTerm uint64\n    votedFor    NodeID\n    state       NodeState\n    \n    // Election timing\n    electionTimeout  time.Duration\n    heartbeatTimeout time.Duration\n    randomGenerator  *rand.Rand\n    \n    // Vote tracking\n    votesReceived    map[uint64]map[NodeID]bool  // term -> voter -> vote\n    voteGranted      map[uint64]bool             // term -> did we vote\n}\n\n// StartRaftElection initiates a new Raft election with term increment and vote requests\nfunc (r *RaftElection) StartRaftElection() error {\n    // TODO: Increment current term\n    // TODO: Vote for self in new term  \n    // TODO: Reset election timeout with random jitter\n    // TODO: Send RequestVote messages to all other nodes\n    // TODO: Start timeout for vote collection phase\n    // Hint: Random jitter prevents vote splitting - use 150-300ms range\n}\n\n// HandleRequestVote processes incoming vote requests from candidate nodes\nfunc (r *RaftElection) HandleRequestVote(msg *RequestVoteMessage) (*RequestVoteResponse, error) {\n    // TODO: Check if candidate's term is at least as current as ours\n    // TODO: Verify we haven't already voted in this term\n    // TODO: Grant vote if candidate is eligible\n    // TODO: Update our current term if candidate's term is higher\n    // TODO: Return vote decision with current term\n    // Hint: Only one vote per term - this prevents split elections\n}\n\n// CollectVotes counts received votes and transitions to leader if majority achieved\nfunc (r *RaftElection) CollectVotes(term uint64) (bool, error) {\n    // TODO: Count votes received for specified term\n    // TODO: Calculate majority threshold (n/2 + 1)\n    // TODO: Return true if majority achieved, false otherwise\n    // TODO: Handle case where not all nodes responded\n    // Hint: Need strict majority, not just plurality\n}\n```\n\n#### Production Metrics Infrastructure\n\n```go\npackage production\n\nimport (\n    \"context\"\n    \"sync\"\n    \"time\"\n    \n    \"github.com/prometheus/client_golang/prometheus\"\n)\n\n// MetricsCollector provides comprehensive observability for leader election systems\ntype MetricsCollector struct {\n    nodeID NodeID\n    \n    // Prometheus metrics\n    electionDuration    prometheus.Histogram\n    electionSuccess     prometheus.Counter\n    electionFailures    prometheus.CounterVec\n    leaderChanges       prometheus.Counter\n    networkMessages     prometheus.CounterVec\n    clusterSize         prometheus.Gauge\n    \n    // Internal tracking\n    activeElections     map[uint64]*ElectionMetrics\n    leaderHistory      []LeadershipEvent\n    mu                 sync.RWMutex\n}\n\n// ElectionMetrics tracks detailed metrics for individual elections\ntype ElectionMetrics struct {\n    ElectionID    uint64\n    StartTime     time.Time\n    Algorithm     string\n    TriggerReason string\n    Participants  []NodeID\n    MessagesSent  int\n    MessagesReceived int\n    NetworkBytes  int64\n}\n\n// NewMetricsCollector initializes Prometheus metrics with appropriate labels and buckets\nfunc NewMetricsCollector(nodeID NodeID) *MetricsCollector {\n    return &MetricsCollector{\n        nodeID: nodeID,\n        electionDuration: prometheus.NewHistogram(prometheus.HistogramOpts{\n            Name:    \"leader_election_duration_seconds\",\n            Help:    \"Time taken to complete leader elections\",\n            Buckets: []float64{0.1, 0.5, 1.0, 2.0, 5.0, 10.0, 30.0},\n        }),\n        electionSuccess: prometheus.NewCounter(prometheus.CounterOpts{\n            Name: \"leader_election_success_total\",\n            Help: \"Number of successful leader elections\",\n        }),\n        electionFailures: prometheus.NewCounterVec(prometheus.CounterOpts{\n            Name: \"leader_election_failures_total\", \n            Help: \"Number of failed leader elections by reason\",\n        }, []string{\"reason\", \"algorithm\"}),\n        activeElections: make(map[uint64]*ElectionMetrics),\n    }\n}\n\n// RecordElectionStarted begins tracking metrics for a new election\nfunc (m *MetricsCollector) RecordElectionStarted(electionID uint64, algorithm, trigger string) {\n    // TODO: Create ElectionMetrics entry for this election\n    // TODO: Record start timestamp\n    // TODO: Initialize message and byte counters\n    // TODO: Determine participant list from current membership\n    // Hint: Use electionID as map key for tracking\n}\n\n// RecordElectionCompleted finalizes election metrics and updates Prometheus counters\nfunc (m *MetricsCollector) RecordElectionCompleted(electionID uint64, success bool, winner NodeID) {\n    // TODO: Look up ElectionMetrics for this election\n    // TODO: Calculate total duration from start time\n    // TODO: Update Prometheus histogram with duration\n    // TODO: Update success/failure counters appropriately\n    // TODO: Record leader change if winner different from previous leader\n    // TODO: Clean up tracking entry\n}\n\n// RecordMessageSent updates network traffic metrics when election messages are transmitted\nfunc (m *MetricsCollector) RecordMessageSent(electionID uint64, msgType MessageType, target NodeID, bytes int64) {\n    // TODO: Find active election and increment message counter\n    // TODO: Add to total network bytes for this election\n    // TODO: Update Prometheus network message counter with type/direction labels\n    // Hint: Track both message count and bandwidth usage\n}\n```\n\n#### Dynamic Configuration Management\n\n```go\npackage production\n\nimport (\n    \"encoding/json\"\n    \"sync\"\n    \"time\"\n)\n\n// ConfigurationManager enables runtime updates to election parameters without service restart\ntype ConfigurationManager struct {\n    // Current configuration\n    config           *ElectionConfig\n    configVersion    uint64\n    lastUpdated      time.Time\n    \n    // Configuration sources\n    configFile       string\n    externalStore    ConfigStore  // etcd, Consul, etc.\n    \n    // Update coordination\n    subscribers      []ConfigSubscriber\n    updateInProgress bool\n    mu               sync.RWMutex\n}\n\n// ElectionConfig contains all tunable parameters for the election system\ntype ElectionConfig struct {\n    // Failure detection\n    HeartbeatInterval       time.Duration `json:\"heartbeat_interval\"`\n    FailureDetectionTimeout time.Duration `json:\"failure_detection_timeout\"`\n    SuspicionLevels         int           `json:\"suspicion_levels\"`\n    \n    // Election behavior  \n    ElectionTimeout         time.Duration `json:\"election_timeout\"`\n    MaxConcurrentElections  int           `json:\"max_concurrent_elections\"`\n    EnableAdaptiveTimeouts  bool          `json:\"enable_adaptive_timeouts\"`\n    \n    // Network optimization\n    MessageBatchSize        int           `json:\"message_batch_size\"`\n    MessageBatchTimeout     time.Duration `json:\"message_batch_timeout\"`\n    MaxRetries              int           `json:\"max_retries\"`\n    \n    // Algorithm selection\n    PreferredAlgorithm      string        `json:\"preferred_algorithm\"`\n    FallbackAlgorithms      []string      `json:\"fallback_algorithms\"`\n}\n\n// ConfigSubscriber receives notifications when configuration changes\ntype ConfigSubscriber interface {\n    OnConfigurationChanged(oldConfig, newConfig *ElectionConfig) error\n}\n\n// ApplyConfigurationUpdate validates and applies new configuration across the cluster\nfunc (c *ConfigurationManager) ApplyConfigurationUpdate(newConfig *ElectionConfig) error {\n    // TODO: Validate new configuration for consistency and safety\n    // TODO: Check that timeout values are reasonable (not too small/large)  \n    // TODO: Verify algorithm names are supported\n    // TODO: Coordinate update across cluster if needed (leader-driven)\n    // TODO: Apply configuration gradually with rollback capability\n    // TODO: Notify all subscribers of configuration change\n    // Hint: Some changes require cluster coordination, others can be applied locally\n}\n\n// ValidateConfiguration checks that configuration parameters are safe and consistent\nfunc (c *ConfigurationManager) ValidateConfiguration(config *ElectionConfig) []string {\n    // TODO: Verify timeout relationships (election > heartbeat * 3)\n    // TODO: Check that batch sizes are reasonable (not too large for network)\n    // TODO: Validate algorithm names against supported algorithms  \n    // TODO: Ensure suspicion levels are positive integers\n    // TODO: Return list of validation errors, empty if configuration is valid\n}\n```\n\n#### Milestone Checkpoint: Performance Extensions\n\nAfter implementing the performance optimization components, verify the improvements with these specific tests:\n\n**Adaptive Timeout Validation**: Start a test cluster and introduce varying network delays. Verify that election timeouts adjust appropriately - timeouts should decrease during stable periods and increase during network congestion.\n\n```bash\n# Start test cluster\ngo run cmd/test-cluster/main.go --nodes=5 --adaptive-timeouts=true\n\n# Inject network delay\ncurl -X POST localhost:8080/debug/inject-latency -d '{\"delay_ms\": 500}'\n\n# Verify timeout adaptation\ncurl localhost:8080/metrics | grep election_timeout_current\n```\n\n**Message Batching Efficiency**: Monitor network traffic reduction when message batching is enabled versus disabled.\n\nExpected behavior: 60-80% reduction in network packets during election storms, with latency increase of less than 50ms.\n\n**Concurrent Election Resolution**: Trigger simultaneous elections from multiple nodes and verify that only one election completes while others are abandoned.\n\nExpected behavior: Single election succeeds within 2 seconds, abandoned elections log \"higher priority election detected\" messages.\n\n#### Milestone Checkpoint: Advanced Algorithms\n\nAfter implementing Raft leader election:\n\n**Raft Election Safety**: Verify that elections produce exactly one leader even during network partitions.\n\n```bash\n# Create network partition\ncurl -X POST localhost:8080/debug/partition -d '{\"groups\": [[1,2], [3,4,5]]}'\n\n# Verify only majority partition elects leader  \ncurl localhost:8080/cluster/status | jq '.leaders | length'  # Should be 1\n```\n\n**SWIM Failure Detection**: Validate that SWIM-based failure detection scales better than heartbeat approaches.\n\nExpected behavior: Network overhead should grow linearly with cluster size rather than quadratically.\n\n#### Milestone Checkpoint: Production Features\n\nAfter implementing metrics and configuration management:\n\n**Metrics Collection**: Verify comprehensive metrics are exported and updating correctly.\n\n```bash\n# Check metric availability\ncurl localhost:9090/metrics | grep leader_election\n\n# Trigger election and verify metrics update\ncurl -X POST localhost:8080/admin/trigger-election\nsleep 5\ncurl localhost:9090/metrics | grep leader_election_duration\n```\n\n**Dynamic Configuration**: Test that configuration updates apply without restarting nodes.\n\n```bash\n# Update election timeout\ncurl -X PUT localhost:8080/admin/config -d '{\"election_timeout\": \"10s\"}'\n\n# Verify new timeout in effect\ncurl localhost:8080/admin/config | jq '.election_timeout'\n```\n\nExpected behavior: Configuration changes should propagate to all nodes within 30 seconds and take effect for subsequent elections.\n\n\n## Glossary\n\n> **Milestone(s):** All milestones - comprehensive terminology reference for node communication (Milestone 1), bully algorithm (Milestone 2), ring election (Milestone 3), and all system components\n\n### Mental Model: The Diplomatic Dictionary\n\nThink of this glossary as a diplomatic dictionary for distributed systems. Just as diplomats from different countries need shared terminology to negotiate treaties without misunderstanding, distributed systems engineers need precise vocabulary to discuss coordination algorithms without ambiguity. Each term has evolved from decades of distributed systems research and carries specific technical meaning that differs from casual usage.\n\nThis glossary serves as the authoritative reference for all concepts, algorithms, and technical terms used throughout the leader election system. Understanding these terms precisely is essential for implementing correct distributed coordination behavior and avoiding subtle bugs that arise from imprecise terminology.\n\n### Core Distributed Systems Concepts\n\nThe following fundamental concepts form the foundation of all leader election algorithms:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **leader election** | The distributed algorithm process of selecting a single coordinator node from multiple candidates in a cluster, ensuring exactly one leader emerges even during failures and network partitions | Central to all milestones - the primary problem this system solves |\n| **split-brain** | A critical failure scenario where network partitions cause multiple nodes to simultaneously believe they are the leader, potentially causing data corruption or inconsistent cluster state | Primary safety concern across all algorithms - must be prevented |\n| **distributed coordination** | The general problem of getting multiple independent nodes to agree on shared state or decisions without a central authority, using only message passing over unreliable networks | Foundational concept underlying leader election algorithms |\n| **cluster membership** | The dynamic view of which nodes are currently alive, reachable, and participating in the cluster, maintained through failure detection and node discovery | Essential for all election algorithms to know potential participants |\n| **election term** | A monotonically increasing epoch counter that orders election attempts chronologically and resolves conflicts between concurrent elections | Prevents old election results from overriding newer ones |\n| **quorum** | The minimum number of nodes required to make valid cluster decisions, typically (N/2)+1 where N is the original cluster size, used to prevent split-brain during partitions | Critical for maintaining safety during network partitions |\n| **network partition** | A failure mode where network connectivity is lost between subsets of cluster nodes, creating isolated groups that cannot communicate | Major source of complexity in election algorithm design |\n| **failure detection** | The process of identifying crashed, hung, or unreachable nodes through timeouts, heartbeats, and unreachable peer reporting | Triggers leader elections and maintains accurate membership |\n| **heartbeat** | A periodic alive signal sent between nodes to prove continued operation and detect failures through message absence | Primary mechanism for failure detection in leader election |\n| **suspicion level** | A graduated counter that tracks accumulating evidence of node failure before definitively marking a node as crashed, reducing false positives from temporary network issues | Prevents premature failure declarations from brief hiccups |\n\n### Election Algorithm Specifics\n\nThese terms define the specific behavior of the bully and ring election algorithms:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **bully algorithm** | An election algorithm where nodes with higher IDs \"bully\" lower-ID nodes by sending election messages only upward, and the highest responding node wins through competitive messaging | Milestone 2 implementation - aggressive but efficient election |\n| **ring election** | A token-passing election algorithm where an election token circulates around a logical ring topology, collecting all live node IDs before selecting the highest ID as leader | Milestone 3 implementation - cooperative election with full knowledge |\n| **cascade election** | Sequential election attempts that occur when higher-ID nodes fail during an active bully election, causing lower-ID nodes to initiate their own elections | Common pattern in bully algorithm during multiple failures |\n| **coordinator announcement** | A broadcast message sent by the winning node to inform all cluster members of the new leader, establishing the post-election leadership state | Final step in both bully and ring elections |\n| **election timeout** | The deadline for receiving responses from higher-ID nodes in bully algorithm, after which a node declares victory and becomes coordinator | Critical timing parameter for bully election correctness |\n| **logical ring topology** | A circular ordering of cluster nodes by their NodeID values, where each node knows its successor for token forwarding, independent of physical network topology | Foundation for ring election algorithm implementation |\n| **election token** | A special message containing the current participant list that circulates around the ring, accumulating live node IDs until it completes the full circuit | Central data structure for ring election coordination |\n| **token circulation** | The process of forwarding the election token from node to node around the logical ring until it returns to the originating node | Core mechanism of ring election algorithm |\n| **ring repair** | The mechanism to skip failed nodes during token forwarding and reconstruct ring connections to maintain token flow when nodes crash | Essential for ring election reliability during failures |\n| **successor mapping** | A data structure table that maps each node to its immediate next node in the ring order, updated dynamically as nodes join and leave | Enables token forwarding in ring elections |\n\n### Message Types and Communication\n\nThese terms describe the messaging infrastructure and specific message formats:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **broadcast** | Message delivery pattern that sends the same message to all currently active cluster members simultaneously | Used for coordinator announcements and heartbeats |\n| **point-to-point** | Message delivery pattern that sends a message from one specific source node to one specific target node | Used for election messages and OK responses |\n| **message sequence pattern** | The temporal choreography and ordering of election messages that flow between nodes during a complete election cycle | Defines the correct behavior for each algorithm |\n| **reliable message passing** | Message delivery that guarantees messages are delivered exactly once to reachable nodes or generates a delivery failure notification | Foundation for election correctness |\n| **election trigger** | An event or condition that causes a node to initiate a new leader election process, such as leader failure detection or cluster bootstrap | Entry point for election algorithms |\n| **state transition** | A change in a node's role from follower to candidate to leader, with specific rules about when transitions are allowed | Prevents invalid state combinations |\n| **concurrent election** | Multiple nodes simultaneously initiating elections, requiring resolution mechanisms to prevent conflicts and ensure single leader emergence | Common scenario requiring careful message ordering |\n| **term-based resolution** | Using monotonically increasing election terms to order and resolve conflicts between overlapping elections | Prevents older elections from overriding newer ones |\n\n### System State and Node Roles\n\nThese terms define the internal state that nodes maintain during elections:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **node identity** | The unique numeric identifier (NodeID) that distinguishes each cluster member and determines election precedence through numeric ordering | Fundamental to both bully and ring election algorithms |\n| **election state** | The complete internal state of a node's current election status, including current role, known leader, election term, and active election participation | Tracked by `ElectionState` structure |\n| **leadership transition** | The complete process of one node stepping down as leader while another node assumes leadership responsibilities | Complex coordination requiring careful ordering |\n| **graceful step-down** | A voluntary leadership transition where the current leader formally transfers responsibilities and notifies all cluster members before relinquishing control | Preferred alternative to failure-triggered elections |\n| **bootstrap election** | The initial leader selection process that occurs when a cluster starts with no existing leader or when all previous leaders have failed | Special case requiring different initialization logic |\n| **membership** | The dynamic view of which nodes are currently alive and participating in cluster operations, maintained through failure detection and node discovery | Fundamental to knowing election participants |\n\n### Network and Failure Handling\n\nThese terms address the complex failure scenarios that election algorithms must handle:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **partition healing** | The process of restoring connectivity between previously isolated cluster segments and resolving any conflicting state that developed during separation | Critical for preventing split-brain after partition recovery |\n| **split-brain prevention** | Mechanisms and algorithms that ensure only one node can claim leadership even during network partitions that split the cluster into isolated groups | Primary safety requirement for election correctness |\n| **cascading failure** | A failure pattern where the recovery from initial failures triggers additional failures, potentially causing system-wide collapse | Must be detected and mitigated in election algorithms |\n| **graduated suspicion** | An incremental failure detection approach that accumulates evidence over multiple missed heartbeats before declaring a node definitely failed | Prevents false positives from temporary network congestion |\n| **adaptive timeouts** | Dynamic timeout adjustment based on observed network conditions, election completion times, and failure patterns to optimize election speed versus reliability | Performance optimization for varying network conditions |\n| **election storm** | A pathological condition where overlapping elections prevent the cluster from converging on a stable leader, often caused by tight timing or cascading failures | Anti-pattern that must be detected and resolved |\n\n### Testing and Validation Terminology\n\nThese terms describe the comprehensive testing approach for distributed election systems:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **component-level testing** | Testing individual system components (Transport, FailureDetector, ClusterMembership) in isolation using mocks and controlled inputs | First tier of testing pyramid for election systems |\n| **multi-node scenarios** | Integration testing that runs complete election flows with multiple coordinating nodes to validate algorithm correctness | Second tier testing actual distributed behavior |\n| **fault injection testing** | Deliberately introducing controlled failures (message loss, node crashes, network partitions) during normal operation to validate resilience | Essential for testing distributed system edge cases |\n| **milestone validation checkpoints** | Concrete behavioral tests that demonstrate milestone completion by verifying specific requirements like \"highest-ID node wins every election\" | Formal acceptance criteria for project milestones |\n| **chaos testing** | Systematic fault injection that introduces random failures during elections to discover unexpected failure modes and validate system robustness | Advanced testing for production readiness |\n| **network partition simulation** | Creating controlled network splits that isolate groups of nodes to test split-brain prevention and partition healing behavior | Critical for validating safety properties |\n| **message loss injection** | Controlled dropping of specific message types during elections to validate timeout handling and retry logic | Tests algorithm robustness to unreliable networks |\n| **cascading failure testing** | Validating system behavior when initial failures trigger additional failures, ensuring graceful degradation rather than system collapse | Validates resilience to complex failure scenarios |\n\n### Debugging and Observability\n\nThese terms define the systematic approach to diagnosing issues in distributed elections:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **election flow validation** | Tracing and verifying that election message sequences follow the correct protocol patterns and produce valid outcomes | Primary debugging technique for election correctness |\n| **state correlation** | Comparing internal node states across the cluster to identify inconsistencies, conflicting leaders, or election synchronization problems | Detects distributed state inconsistencies |\n| **message flow analysis** | Tracing election messages chronologically through the cluster to identify missing messages, ordering problems, or protocol violations | Core technique for debugging election failures |\n| **structured logging** | Consistent log format with correlation identifiers (election IDs, terms, node IDs) that enables tracing individual elections across multiple nodes | Essential for debugging distributed elections |\n| **distributed tracing** | Following individual election attempts across all participating nodes using correlation IDs to build complete election timelines | Advanced debugging for complex election interactions |\n\n### Advanced Algorithms and Extensions\n\nThese terms describe algorithms and optimizations beyond the basic milestone requirements:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **Raft leader election** | A consensus algorithm election mechanism that requires majority votes and includes log consistency checks, more complex but more robust than bully or ring elections | Advanced extension requiring consensus protocol knowledge |\n| **SWIM failure detection** | Scalable Weakly-consistent Infection-style failure detection using gossip protocols to detect failures efficiently in large clusters | Alternative to heartbeat-based failure detection |\n| **weighted election algorithms** | Election approaches that consider node capabilities, load, or reliability scores rather than just numeric IDs for leader selection | Extension for production environments with heterogeneous nodes |\n| **Byzantine fault tolerance** | Handling arbitrary or malicious node behavior where nodes may send conflicting or false information, requiring cryptographic verification | Advanced security extension beyond basic crash failures |\n| **dynamic configuration management** | Runtime parameter updates (timeouts, membership, algorithms) without requiring service restart or cluster downtime | Production readiness feature for operational flexibility |\n| **adaptive timeout management** | Automatic adjustment of election timeouts based on observed network latency, cluster size, and historical election completion times | Performance optimization for varying network conditions |\n| **message batching** | Aggregating multiple election messages into single network transmissions to reduce overhead and improve performance in high-frequency election scenarios | Network optimization for clusters with frequent elections |\n\n### Data Structures and Implementation Details\n\nThese terms define the specific implementation components and their relationships:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **ElectionCoordinator** | The main component that orchestrates election algorithms, manages node state, and coordinates with transport and membership components | Central controller implementing election logic |\n| **Transport** | The abstract interface for inter-node communication that abstracts network protocols (TCP, UDP, HTTP) and provides reliable message delivery | Abstraction layer for different network implementations |\n| **ClusterMembership** | Component that tracks which nodes are alive and participating, maintains the authoritative view of cluster composition | Foundation for knowing election participants |\n| **FailureDetector** | Component that monitors node heartbeats and network connectivity to identify failed nodes and trigger elections | Critical for maintaining accurate membership |\n| **RingTopology** | Component that manages the logical ring ordering of nodes and handles successor mapping for token forwarding | Specific to ring election algorithm implementation |\n| **ElectionState** | The complete internal state of a node including current role, known leader, election term, and active election participation | Core state machine for election behavior |\n| **MessageSequencer** | Component that orders incoming messages and manages election message timing to prevent race conditions | Ensures correct message processing order |\n| **LeadershipManager** | Component that handles leader responsibilities including heartbeat broadcasting and coordination task management | Manages post-election leader duties |\n\n### Testing Infrastructure Components\n\nThese terms describe the specialized testing components for validating distributed election behavior:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **TestTransport** | A controllable transport implementation that simulates network conditions including delays, message loss, and partitions for testing election algorithms | Essential for controlled testing of failure scenarios |\n| **TestCluster** | A complete simulated cluster environment that manages multiple election coordinators and network simulation for comprehensive testing | Primary testing harness for multi-node scenarios |\n| **FaultScenario** | A structured test case that defines specific failure conditions, validation criteria, and expected outcomes for systematic testing of edge cases | Standardized approach to testing complex failure modes |\n| **ElectionScenarioTest** | Integration test that validates complete election flows including timing, message ordering, and final leader selection | Validates end-to-end election correctness |\n| **NetworkSimulator** | Component that simulates various network conditions including latency, packet loss, and partitions to test election algorithms under realistic conditions | Enables testing without actual network failures |\n\n### Performance and Reliability Metrics\n\nThese terms define the measurable aspects of election system performance:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **election convergence time** | The duration from election initiation to stable leader establishment, measured across different cluster sizes and failure scenarios | Key performance metric for election efficiency |\n| **message overhead** | The total number of messages required to complete an election, important for network efficiency and scalability analysis | Comparison metric between election algorithms |\n| **failure detection latency** | The time between actual node failure and its detection by the failure detector, directly impacts election trigger timing | Critical for minimizing leadership gaps |\n| **availability window** | The period during elections when no leader is available to coordinate cluster operations, should be minimized for system reliability | Service disruption metric during leadership transitions |\n\n> **Key Insight**: Precise terminology prevents the subtle bugs that plague distributed systems. When we say \"broadcast\", we mean delivery to all currently active members - not all configured members. When we say \"reliable delivery\", we mean exactly-once delivery to reachable nodes or definitive failure notification - not infinite retries.\n\nThe distinction between theoretical concepts and practical implementation details is crucial. Terms like \"happens-before relationship\" describe theoretical ordering guarantees, while terms like \"MessageSequencer\" describe concrete implementation components that enforce those guarantees.\n\n### Algorithm State Machine Terminology\n\nThe election algorithms involve complex state machines with specific transition rules:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **StateFollower** | Node state where the node recognizes another node as leader and processes heartbeats without initiating elections | Default state for non-leader nodes |\n| **StateCandidate** | Node state during active election participation, either initiating bully election or participating in ring token passing | Temporary state during election algorithms |\n| **StateLeader** | Node state where this node serves as the cluster coordinator, sending heartbeats and managing cluster operations | Terminal state after winning election |\n| **election initiation** | The specific conditions and logic that cause a node to transition from follower to candidate and begin election protocol | Entry point for election algorithms |\n| **leadership assumption** | The process where a candidate transitions to leader state after winning an election, including announcing victory and starting leader duties | Critical transition requiring careful coordination |\n\n### Message Protocol Terminology\n\nThe specific message types and communication patterns used in elections:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **MsgElection** | Bully algorithm message sent from lower-ID node to higher-ID nodes to initiate competitive election | Primary bully algorithm communication |\n| **MsgOK** | Bully algorithm response sent from higher-ID node to lower-ID node to indicate participation in election | Prevents lower-ID nodes from claiming premature victory |\n| **MsgCoordinator** | Broadcast message announcing the winning node after election completion | Final message in both election algorithms |\n| **MsgHeartbeat** | Periodic message sent by leader to all followers to prove continued operation | Failure detection and leadership maintenance |\n| **MsgRingToken** | Ring election token message containing participant list that circulates around logical ring | Central message type for ring election |\n| **message ordering** | The requirement that certain election messages be processed in specific sequences to maintain algorithm correctness | Critical for preventing race conditions |\n| **delivery guarantees** | The reliability properties provided by the transport layer, including exactly-once delivery and failure notification | Foundation for election algorithm correctness |\n\n### Failure Modes and Recovery\n\nThese terms categorize the various ways elections can fail and how the system recovers:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **node crash** | Sudden stop of a node process, detectable through heartbeat absence and connection failures | Most common failure mode handled by elections |\n| **network partition** | Loss of connectivity between node groups while nodes themselves remain operational | Complex failure requiring quorum-based resolution |\n| **message loss** | Individual messages being dropped by the network without delivery, requiring timeout and retry logic | Network unreliability that algorithms must handle |\n| **timing failure** | Nodes operating correctly but outside expected time bounds, causing timeout-based failures | Performance degradation that can trigger elections |\n| **concurrent failure** | Multiple nodes failing simultaneously, potentially during an active election | Stress scenario requiring robust algorithm design |\n| **partition healing** | The process of restoring connectivity and resolving state conflicts when network partitions recover | Complex coordination requiring conflict resolution |\n\n### Implementation Architecture Terms\n\nThese terms describe the specific software components and their organization:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **HTTPTransport** | Concrete implementation of Transport interface using HTTP REST for inter-node communication | Simple transport implementation for development |\n| **MessageBuilder** | Utility component for constructing properly formatted election messages with required fields and validation | Helper for message creation |\n| **ElectionTimeoutManager** | Component that manages election deadlines and timeout callbacks with proper cancellation support | Timing control for bully algorithm |\n| **DebugStateCollector** | Testing component that captures snapshots of node states across the cluster for validation and debugging | Debugging aid for complex election scenarios |\n| **ElectionFlowTracer** | Component that tracks message flows through complete election cycles for debugging and validation | Advanced debugging tool for message sequence analysis |\n\n> **Important**: These implementations support both algorithm-specific components (like `RingTopology` for ring elections) and shared infrastructure (like `FailureDetector` for both algorithms). Understanding which components are shared versus algorithm-specific guides correct system architecture.\n\n### Testing and Validation Concepts\n\nSpecialized terminology for testing distributed election systems:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **chaos engineering** | Systematic fault injection methodology that introduces random failures to discover system weaknesses and validate resilience | Advanced testing approach for production readiness |\n| **test transport** | A controllable transport implementation that allows precise simulation of network conditions including delays and message loss | Essential infrastructure for deterministic testing |\n| **election invariant** | A property that must always hold true during elections, such as \"at most one leader per term\" | Safety properties that tests must validate |\n| **milestone validation** | Formal verification that implementation meets specific acceptance criteria for each project milestone | Structured approach to tracking progress |\n| **fault scenario** | A specific combination of failures, timing, and conditions designed to test particular edge cases in election algorithms | Systematic approach to testing complex failure modes |\n\n### Advanced Performance and Reliability\n\nTerms describing sophisticated approaches to election system optimization:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **election optimization** | Techniques to reduce election time, message overhead, or failure detection latency while maintaining correctness | Performance improvements beyond basic implementation |\n| **back-pressure handling** | Managing message queues and processing capacity during high election frequency or large cluster scenarios | Scalability consideration for production systems |\n| **configuration hot-reload** | Ability to update election parameters (timeouts, algorithms) without restarting nodes or interrupting ongoing elections | Operational flexibility for production deployment |\n| **multi-algorithm support** | System design that allows switching between bully, ring, or other election algorithms based on cluster conditions | Advanced flexibility for different deployment scenarios |\n\n### Debugging and Troubleshooting\n\nSpecific terminology for diagnosing and fixing election system issues:\n\n| Term | Definition | Context |\n|------|------------|---------|\n| **election deadlock** | A situation where election algorithms cannot make progress due to circular dependencies, message loss, or timing issues | Pathological condition requiring detection and recovery |\n| **leader flapping** | Rapid repeated leader changes due to marginal failure conditions, network instability, or poorly tuned timeouts | Performance problem indicating tuning issues |\n| **phantom leader** | A node that believes it is leader but other nodes don't recognize its authority, usually due to stale election state | Consistency problem requiring state reconciliation |\n| **election livelock** | Continuous election attempts that never converge due to timing conflicts, message ordering issues, or competing candidates | Liveness problem requiring resolution mechanisms |\n\nThis glossary provides the precise vocabulary needed to implement, test, and debug leader election systems correctly. Each term carries specific technical meaning that differs from informal usage, and understanding these distinctions is essential for building correct distributed coordination systems.\n\n### Implementation Guidance\n\nThis glossary serves as the authoritative reference during implementation. When you encounter unfamiliar terminology in algorithm descriptions, message specifications, or error handling procedures, return to these definitions to ensure precise understanding.\n\n**A. Terminology Usage Guidelines:**\n\n| Component | Preferred Terms | Avoid |\n|-----------|-----------------|-------|\n| Algorithm Selection | \"bully algorithm\", \"ring election\" | \"leader selection\", \"coordinator voting\" |\n| Failure Scenarios | \"network partition\", \"split-brain\" | \"network split\", \"dual master\" |\n| Message Patterns | \"broadcast\", \"point-to-point\" | \"multicast\", \"unicast\" |\n| State Management | \"state transition\", \"leadership assumption\" | \"state change\", \"becoming leader\" |\n\n**B. Reference Implementation Constants:**\n\n```go\n// Core terminology translated to implementation constants\nconst (\n    // Node state terminology\n    StateFollower  NodeState = 0  // follower state\n    StateCandidate NodeState = 1  // candidate state \n    StateLeader    NodeState = 2  // leader state\n    \n    // Message type terminology\n    MsgElection    MessageType = 1  // bully algorithm election\n    MsgOK          MessageType = 2  // bully acknowledgment\n    MsgCoordinator MessageType = 3  // coordinator announcement\n    MsgHeartbeat   MessageType = 4  // heartbeat message\n    MsgRingToken   MessageType = 5  // ring election token\n    \n    // Trigger type terminology\n    TriggerLeaderFailure      TriggerType = 0  // leader failure detection\n    TriggerStartup           TriggerType = 1  // cluster bootstrap\n    TriggerPartitionHealing  TriggerType = 2  // partition recovery\n    TriggerManualElection    TriggerType = 3  // administrative trigger\n    TriggerTermConflict      TriggerType = 4  // term conflict resolution\n)\n```\n\n**C. Glossary Documentation Structure:**\n\n```go\n// TermDefinition represents a single glossary entry\ntype TermDefinition struct {\n    Term        string   // The precise term to use\n    Definition  string   // Complete technical definition\n    Context     string   // Where this term applies\n    Aliases     []string // Deprecated or informal alternatives\n    Related     []string // Related terms to cross-reference\n    Examples    []string // Concrete usage examples\n}\n\n// GlossaryManager maintains terminology consistency\ntype GlossaryManager struct {\n    definitions map[string]*TermDefinition\n    categories  map[string][]string\n    mu          sync.RWMutex\n}\n```\n\n**D. Common Terminology Mistakes:**\n\n⚠️ **Pitfall: Informal Algorithm Names**\nUsing casual terms like \"leader selection\" instead of precise algorithm names like \"bully algorithm\" creates confusion when discussing specific protocol behavior. Each algorithm has distinct message patterns and failure handling - use exact names.\n\n⚠️ **Pitfall: Overloaded \"Failure\" Term**\nThe word \"failure\" means different things: node crashes, network partitions, message loss, timing violations. Always specify the failure type precisely: \"node crash failure\", \"network partition failure\", \"heartbeat timeout failure\".\n\n⚠️ **Pitfall: Ambiguous State Terms**\nTerms like \"active\", \"running\", \"alive\" are ambiguous. Use precise state terminology: `StateLeader` for leadership role, \"reachable\" for network connectivity, \"participating\" for election involvement.\n\n**E. Milestone Terminology Checkpoint:**\n\nAfter implementing each milestone, verify your code uses consistent terminology:\n\n```bash\n# Check terminology consistency in code\ngrep -r \"leader selection\" .  # Should find zero matches\ngrep -r \"bully algorithm\" .   # Should find multiple matches\ngrep -r \"StateLeader\" .       # Should find state machine usage\n```\n\n**F. Documentation Cross-Reference:**\n\nWhen writing code comments or documentation, reference this glossary to maintain consistency:\n\n```go\n// StartElection initiates a new leader election using the bully algorithm.\n// This is an \"election trigger\" event that causes state transition from\n// StateFollower to StateCandidate. The election will send MsgElection\n// messages to all higher-ID nodes per bully algorithm protocol.\nfunc (be *BullyElection) StartElection() error {\n    // Implementation maps to glossary terms\n}\n```\n\nThis comprehensive glossary ensures that all team members, documentation, code comments, and technical discussions use consistent terminology that accurately reflects distributed systems concepts and algorithm specifications.\n"}