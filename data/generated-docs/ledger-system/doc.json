{"html":"<h1 id=\"double-entry-ledger-system-design-document\">Double-Entry Ledger System: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>A double-entry accounting system that ensures financial transaction integrity through balanced journal entries where every debit equals total credits. The key architectural challenge is maintaining immutable audit trails while providing efficient balance calculations and real-time financial reporting across multiple currencies.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones, as this section provides foundational understanding for the entire system</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<p>Building a reliable accounting system requires understanding not just the technical implementation, but the fundamental principles that make financial systems trustworthy. Double-entry bookkeeping, invented over 500 years ago, remains the backbone of modern financial systems because it provides built-in error detection and mathematical proof that transactions are recorded correctly. However, implementing these time-tested accounting principles in modern software systems introduces unique technical challenges around data consistency, immutability, performance, and regulatory compliance.</p>\n<h3 id=\"double-entry-accounting-mental-model\">Double-Entry Accounting Mental Model</h3>\n<p>Think of double-entry accounting like a <strong>perfectly balanced scale</strong> where every financial transaction must affect at least two sides, and the total weight on both sides must always remain equal. When you record a business transaction, you&#39;re not just noting that money moved—you&#39;re documenting the complete story of value exchange by showing exactly where value came from and where it went.</p>\n<p>Consider a simple analogy: when you buy coffee with cash, three things happen simultaneously in the business&#39;s accounting system. First, the business gains an asset (your cash payment). Second, the business loses an asset (the coffee beans, milk, and other inventory). Third, the business recognizes revenue (the profit from the sale). Each of these effects must be recorded as separate accounting entries, and the mathematical relationship between them provides automatic error checking—if the entries don&#39;t balance, something was recorded incorrectly.</p>\n<p>The <strong>fundamental equation</strong> that governs all double-entry systems is: <strong>Assets = Liabilities + Equity</strong>. This equation must hold true after every transaction, providing a built-in consistency check. Every business transaction can be viewed as an exchange that maintains this equilibrium. When a company borrows money from a bank, assets increase (cash received) and liabilities increase (debt owed) by exactly the same amount. When the company later repays the loan, both sides decrease equally.</p>\n<p><strong>Debits and credits</strong> are the mechanism for recording these balanced exchanges, but they&#39;re often misunderstood because their meaning differs from everyday language. In accounting, &quot;debit&quot; simply means &quot;left side of the ledger&quot; and &quot;credit&quot; means &quot;right side of the ledger.&quot; Different account types have different relationships to debits and credits based on their <strong>normal balance</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Account Type</th>\n<th>Normal Balance</th>\n<th>Increases With</th>\n<th>Decreases With</th>\n<th>Examples</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Assets</td>\n<td>Debit</td>\n<td>Debits</td>\n<td>Credits</td>\n<td>Cash, Equipment, Inventory</td>\n</tr>\n<tr>\n<td>Liabilities</td>\n<td>Credit</td>\n<td>Credits</td>\n<td>Debits</td>\n<td>Loans, Accounts Payable</td>\n</tr>\n<tr>\n<td>Equity</td>\n<td>Credit</td>\n<td>Credits</td>\n<td>Debits</td>\n<td>Owner Investment, Retained Earnings</td>\n</tr>\n<tr>\n<td>Revenue</td>\n<td>Credit</td>\n<td>Credits</td>\n<td>Debits</td>\n<td>Sales, Service Income</td>\n</tr>\n<tr>\n<td>Expenses</td>\n<td>Debit</td>\n<td>Debits</td>\n<td>Credits</td>\n<td>Rent, Salaries, Utilities</td>\n</tr>\n</tbody></table>\n<p>The power of this system becomes clear when you realize that <strong>every transaction tells a complete story</strong>. A journal entry recording the coffee shop sale might look like:</p>\n<table>\n<thead>\n<tr>\n<th>Account</th>\n<th>Debit</th>\n<th>Credit</th>\n<th>Explanation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cash</td>\n<td>$5.00</td>\n<td></td>\n<td>Asset increases (customer payment)</td>\n</tr>\n<tr>\n<td>Inventory</td>\n<td></td>\n<td>$1.50</td>\n<td>Asset decreases (coffee beans used)</td>\n</tr>\n<tr>\n<td>Revenue</td>\n<td></td>\n<td>$3.50</td>\n<td>Revenue recognized (profit earned)</td>\n</tr>\n<tr>\n<td><strong>Totals</strong></td>\n<td><strong>$5.00</strong></td>\n<td><strong>$5.00</strong></td>\n<td><strong>Balanced</strong></td>\n</tr>\n</tbody></table>\n<p>This transaction maintains the fundamental equation: assets increased by $3.50 net ($5.00 cash in, $1.50 inventory out), and equity increased by $3.50 (revenue). The business is $3.50 better off, and the accounting entries prove it mathematically.</p>\n<p><strong>Multi-currency transactions</strong> extend this model by requiring additional metadata about exchange rates and base currency conversions, but the fundamental balancing principle remains unchanged. If a U.S. company purchases inventory from a European supplier for €1,000 when the exchange rate is 1.10 USD/EUR, the transaction records $1,100 in inventory (debit) and $1,100 in accounts payable (credit), along with the original currency amounts for future reference.</p>\n<p>The <strong>immutability principle</strong> in double-entry accounting means that once a transaction is posted (officially recorded), it cannot be modified or deleted. Mistakes are corrected by creating <strong>reversing entries</strong> that exactly offset the original error, followed by new entries recording the correct transaction. This creates an audit trail showing what was originally recorded, what was wrong, and how it was fixed—crucial for regulatory compliance and fraud detection.</p>\n<h3 id=\"existing-accounting-system-approaches\">Existing Accounting System Approaches</h3>\n<p>Modern accounting systems fall into several architectural categories, each with distinct trade-offs for reliability, performance, and complexity. Understanding these approaches helps inform design decisions for building a new ledger system.</p>\n<p><strong>Single-Entry vs Double-Entry Systems</strong></p>\n<p>Single-entry accounting systems record each transaction once, typically in a chronological list similar to a checkbook register. While simpler to implement and understand, single-entry systems lack the built-in error detection and completeness validation that make double-entry systems suitable for business accounting.</p>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Single-Entry</th>\n<th>Double-Entry</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Detection</td>\n<td>Manual reconciliation required</td>\n<td>Automatic through trial balance</td>\n</tr>\n<tr>\n<td>Completeness</td>\n<td>Cannot verify all effects captured</td>\n<td>Mathematical proof of completeness</td>\n</tr>\n<tr>\n<td>Financial Reports</td>\n<td>Limited to cash flow</td>\n<td>Full financial statements possible</td>\n</tr>\n<tr>\n<td>Audit Trail</td>\n<td>Transaction sequence only</td>\n<td>Complete value flow documentation</td>\n</tr>\n<tr>\n<td>Regulatory Compliance</td>\n<td>Insufficient for most jurisdictions</td>\n<td>Meets accounting standards</td>\n</tr>\n<tr>\n<td>Implementation Complexity</td>\n<td>Low</td>\n<td>Higher but manageable</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Double-Entry Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to build a production-ready accounting system that meets business and regulatory requirements</li>\n<li><strong>Options Considered</strong>: Single-entry for simplicity, double-entry for completeness, hybrid approach</li>\n<li><strong>Decision</strong>: Full double-entry system with trial balance validation</li>\n<li><strong>Rationale</strong>: Built-in error detection and regulatory compliance requirements outweigh implementation complexity. Single-entry systems cannot provide the financial reporting capabilities needed for business use.</li>\n<li><strong>Consequences</strong>: Higher implementation complexity but significantly better data integrity and audit capabilities</li>\n</ul>\n</blockquote>\n<p><strong>Traditional vs Modern Ledger Architectures</strong></p>\n<p>Traditional accounting systems were designed for batch processing with end-of-day posting cycles and periodic reconciliation. Modern systems increasingly require real-time balance updates and immediate consistency checking, leading to different architectural approaches.</p>\n<p><strong>Batch-Processing Architecture</strong> follows the traditional accounting model where transactions are collected throughout the day and posted in batches during off-peak hours. This approach simplifies consistency management and allows for human review before posting, but delays balance updates and financial reporting.</p>\n<p><strong>Real-Time Processing Architecture</strong> posts transactions immediately as they occur, providing up-to-date balances and enabling real-time financial reporting. However, this requires more sophisticated concurrency control and consistency management.</p>\n<p><strong>Event Sourcing Architecture</strong> stores all changes as a sequence of immutable events rather than updating records in place. This provides perfect audit trails and enables time-travel queries, but can have performance implications for balance calculations.</p>\n<table>\n<thead>\n<tr>\n<th>Architecture</th>\n<th>Consistency Model</th>\n<th>Balance Updates</th>\n<th>Audit Trail</th>\n<th>Performance</th>\n<th>Best For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Batch Processing</td>\n<td>Eventually consistent</td>\n<td>Delayed</td>\n<td>Good</td>\n<td>High throughput</td>\n<td>Traditional businesses</td>\n</tr>\n<tr>\n<td>Real-Time</td>\n<td>Strong consistency</td>\n<td>Immediate</td>\n<td>Good</td>\n<td>Variable</td>\n<td>Modern applications</td>\n</tr>\n<tr>\n<td>Event Sourcing</td>\n<td>Immutable events</td>\n<td>Calculated</td>\n<td>Perfect</td>\n<td>Read-heavy</td>\n<td>High compliance needs</td>\n</tr>\n<tr>\n<td>Hybrid</td>\n<td>Configurable</td>\n<td>Configurable</td>\n<td>Excellent</td>\n<td>Balanced</td>\n<td>Most production systems</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Real-Time with Event Sourcing Elements</strong></p>\n<ul>\n<li><strong>Context</strong>: Modern applications require immediate balance updates while maintaining audit compliance</li>\n<li><strong>Options Considered</strong>: Pure batch processing, pure real-time, event sourcing, hybrid approach</li>\n<li><strong>Decision</strong>: Real-time posting with immutable journal entries and comprehensive audit logging</li>\n<li><strong>Rationale</strong>: Immediate consistency meets user expectations while immutable entries satisfy audit requirements. Event sourcing for transactions combined with materialized balance views provides both auditability and performance.</li>\n<li><strong>Consequences</strong>: More complex concurrency control but better user experience and audit compliance</li>\n</ul>\n</blockquote>\n<p><strong>Database Architecture Choices</strong></p>\n<p>The choice of database architecture significantly impacts the accounting system&#39;s consistency guarantees, performance characteristics, and operational complexity.</p>\n<p><strong>Relational Database Architecture</strong> uses traditional ACID transactions to maintain consistency across normalized tables. This approach provides strong consistency guarantees and is well-understood by developers, but can have performance limitations under high transaction volumes.</p>\n<p><strong>NoSQL with Application-Level Consistency</strong> moves consistency logic into the application layer, potentially improving performance but requiring careful design to maintain accounting accuracy.</p>\n<p><strong>Distributed Ledger Architecture</strong> replicates the ledger across multiple nodes with consensus protocols ensuring all nodes agree on transaction ordering. This provides high availability and audit transparency but introduces significant complexity.</p>\n<table>\n<thead>\n<tr>\n<th>Architecture</th>\n<th>Consistency</th>\n<th>Performance</th>\n<th>Complexity</th>\n<th>Audit Trail</th>\n<th>Recovery</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single RDBMS</td>\n<td>ACID guaranteed</td>\n<td>Limited by single node</td>\n<td>Low</td>\n<td>Database logs</td>\n<td>Backup/restore</td>\n</tr>\n<tr>\n<td>Replicated RDBMS</td>\n<td>ACID with lag</td>\n<td>Better read performance</td>\n<td>Medium</td>\n<td>Multiple copies</td>\n<td>Failover supported</td>\n</tr>\n<tr>\n<td>Sharded RDBMS</td>\n<td>Eventual consistency</td>\n<td>High performance</td>\n<td>High</td>\n<td>Complex aggregation</td>\n<td>Complex recovery</td>\n</tr>\n<tr>\n<td>NoSQL Document</td>\n<td>Application-managed</td>\n<td>Very high</td>\n<td>Medium-High</td>\n<td>Application-dependent</td>\n<td>Variable</td>\n</tr>\n<tr>\n<td>Distributed Ledger</td>\n<td>Consensus-based</td>\n<td>Variable</td>\n<td>Very high</td>\n<td>Cryptographically secure</td>\n<td>Byzantine fault tolerant</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Single RDBMS with Read Replicas</strong></p>\n<ul>\n<li><strong>Context</strong>: Need strong consistency for financial data while supporting read-heavy reporting workloads</li>\n<li><strong>Options Considered</strong>: Single database, master-slave replication, sharding, NoSQL, blockchain</li>\n<li><strong>Decision</strong>: PostgreSQL primary with read replicas for reporting</li>\n<li><strong>Rationale</strong>: ACID transactions essential for financial accuracy. Read replicas handle reporting load without compromising primary database performance. Proven technology with excellent consistency guarantees.</li>\n<li><strong>Consequences</strong>: Single point of failure for writes, but high availability solutions available. Strong consistency guaranteed but write scalability limited.</li>\n</ul>\n</blockquote>\n<h3 id=\"core-technical-challenges\">Core Technical Challenges</h3>\n<p>Building a reliable accounting system involves solving several interconnected technical challenges that go beyond typical application development. Each challenge has specific implications for system architecture and implementation approach.</p>\n<p><strong>Data Consistency and Integrity</strong></p>\n<p>Financial data consistency requirements exceed those of most applications because mathematical errors in accounting can have serious legal and business consequences. The system must maintain multiple levels of consistency simultaneously.</p>\n<p><strong>Transaction-Level Consistency</strong> ensures that individual journal entries balance (total debits equal total credits) and cannot be recorded in an incomplete state. This requires atomic database transactions that either record all line items or none of them.</p>\n<p><strong>Account-Level Consistency</strong> maintains accurate running balances for each account as transactions are posted. Balance updates must be synchronized with transaction posting to prevent temporary inconsistencies that could affect financial reports.</p>\n<p><strong>Cross-Account Consistency</strong> ensures that the fundamental accounting equation (Assets = Liabilities + Equity) holds across all accounts at all times. This requires validation that spans multiple database tables and accounts.</p>\n<p><strong>Multi-Currency Consistency</strong> adds complexity when dealing with foreign exchange transactions. The system must maintain consistency in both the original transaction currency and the reporting currency, requiring careful handling of exchange rate conversions and rounding differences.</p>\n<table>\n<thead>\n<tr>\n<th>Consistency Level</th>\n<th>Validation Points</th>\n<th>Failure Recovery</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Transaction</td>\n<td>Before posting each entry</td>\n<td>Rollback incomplete entry</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Account Balance</td>\n<td>After each transaction</td>\n<td>Recalculate from journal</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Trial Balance</td>\n<td>Periodic validation</td>\n<td>Identify and correct errors</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Multi-Currency</td>\n<td>Currency conversion points</td>\n<td>Re-apply exchange rates</td>\n<td>Variable</td>\n</tr>\n</tbody></table>\n<p><strong>Immutable Audit Requirements</strong></p>\n<p>Regulatory compliance and fraud prevention require that posted accounting transactions cannot be modified or deleted. This immutability requirement conflicts with typical application development practices where data can be updated freely.</p>\n<p><strong>Append-Only Transaction Storage</strong> means that journal entries, once posted, can only be corrected through additional reversing entries. The database schema must prevent UPDATE and DELETE operations on posted transactions while allowing normal CRUD operations on draft entries.</p>\n<p><strong>Change History Tracking</strong> requires comprehensive logging of who made what changes when, including attempts to modify posted entries. Every field change must be recorded with timestamps, user identification, and before/after values.</p>\n<p><strong>Cryptographic Integrity</strong> may be required for high-security environments, using hash chains or digital signatures to detect tampering with historical records. This adds computational overhead but provides mathematical proof of data integrity.</p>\n<p><strong>Retention and Archival</strong> policies must balance regulatory requirements (often 7+ years) with database performance. Old transactions cannot be deleted but may need to be moved to archival storage to maintain query performance.</p>\n<table>\n<thead>\n<tr>\n<th>Audit Requirement</th>\n<th>Implementation Approach</th>\n<th>Storage Overhead</th>\n<th>Query Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Immutable Entries</td>\n<td>Database constraints</td>\n<td>None</td>\n<td>None</td>\n</tr>\n<tr>\n<td>Change History</td>\n<td>Audit log tables</td>\n<td>2-3x storage</td>\n<td>Minimal</td>\n</tr>\n<tr>\n<td>Cryptographic Proof</td>\n<td>Hash chains</td>\n<td>10-20%</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Long-term Retention</td>\n<td>Tiered storage</td>\n<td>Variable</td>\n<td>Read latency</td>\n</tr>\n</tbody></table>\n<p><strong>Performance at Scale</strong></p>\n<p>Accounting systems must handle increasing transaction volumes while maintaining consistent response times for balance queries and report generation. Performance challenges compound as data volume grows over time.</p>\n<p><strong>Balance Calculation Performance</strong> becomes critical as accounts accumulate thousands or millions of transactions. Recalculating balances from scratch for each query becomes prohibitively expensive, requiring caching strategies that maintain consistency with new transactions.</p>\n<p><strong>Concurrent Access Patterns</strong> in accounting systems typically involve many read operations (balance queries, reports) and fewer write operations (transaction posting). However, write operations must maintain strong consistency while not blocking read operations unnecessarily.</p>\n<p><strong>Report Generation Scalability</strong> challenges arise when financial reports must aggregate data across thousands of accounts and millions of transactions. These operations can be memory-intensive and time-consuming without proper indexing and query optimization.</p>\n<p><strong>Historical Data Growth</strong> means that database size grows continuously without natural pruning points. Query performance must remain acceptable even as tables contain years of historical data.</p>\n<table>\n<thead>\n<tr>\n<th>Performance Challenge</th>\n<th>Typical Scale</th>\n<th>Mitigation Strategy</th>\n<th>Trade-offs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Balance Queries</td>\n<td>Sub-second response</td>\n<td>Materialized balance tables</td>\n<td>Storage overhead</td>\n</tr>\n<tr>\n<td>Concurrent Transactions</td>\n<td>100s per second</td>\n<td>Optimistic locking</td>\n<td>Retry complexity</td>\n</tr>\n<tr>\n<td>Report Generation</td>\n<td>Minutes acceptable</td>\n<td>Indexed aggregation queries</td>\n<td>Index maintenance cost</td>\n</tr>\n<tr>\n<td>Data Retention</td>\n<td>Years of history</td>\n<td>Partitioning by date</td>\n<td>Query complexity</td>\n</tr>\n</tbody></table>\n<p><strong>Regulatory Compliance and Standards</strong></p>\n<p>Accounting systems must comply with various financial reporting standards and regulatory requirements that constrain technical design choices.</p>\n<p><strong>Generally Accepted Accounting Principles (GAAP)</strong> and <strong>International Financial Reporting Standards (IFRS)</strong> define how financial transactions must be recorded and reported. These standards influence database schema design, validation rules, and report generation logic.</p>\n<p><strong>Sarbanes-Oxley (SOX) Compliance</strong> in the United States requires specific internal controls and audit trails for public companies. Technical systems must support segregation of duties, approval workflows, and comprehensive change logging.</p>\n<p><strong>Data Privacy Regulations</strong> like GDPR create tension with accounting immutability requirements. The system must maintain transaction integrity while potentially supporting data anonymization or deletion requests.</p>\n<p><strong>Industry-Specific Requirements</strong> may impose additional constraints. Banking systems must comply with Basel III capital requirements, while healthcare organizations must meet HIPAA privacy standards alongside accounting accuracy.</p>\n<table>\n<thead>\n<tr>\n<th>Compliance Area</th>\n<th>Technical Requirements</th>\n<th>Implementation Complexity</th>\n<th>Ongoing Burden</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GAAP/IFRS</td>\n<td>Standard chart of accounts</td>\n<td>Medium</td>\n<td>Periodic updates</td>\n</tr>\n<tr>\n<td>SOX Controls</td>\n<td>Approval workflows, audit logs</td>\n<td>High</td>\n<td>Continuous monitoring</td>\n</tr>\n<tr>\n<td>Data Privacy</td>\n<td>Anonymization capabilities</td>\n<td>High</td>\n<td>Request processing</td>\n</tr>\n<tr>\n<td>Industry Specific</td>\n<td>Custom validations</td>\n<td>Variable</td>\n<td>Regulatory changes</td>\n</tr>\n</tbody></table>\n<p><strong>Error Handling and Recovery</strong></p>\n<p>Financial systems require sophisticated error handling because accounting mistakes can have serious business and legal consequences. The system must detect, prevent, and recover from various failure modes.</p>\n<p><strong>Data Corruption Detection</strong> must identify when database integrity has been compromised, either through hardware failures, software bugs, or malicious activity. This requires checksum validation, consistency checking, and anomaly detection.</p>\n<p><strong>Partial Failure Recovery</strong> handles situations where multi-step operations fail partway through completion. For example, if posting a journal entry succeeds but updating account balances fails, the system must either complete the operation or roll back completely.</p>\n<p><strong>Concurrency Conflict Resolution</strong> manages situations where multiple users attempt to modify related data simultaneously. The system must either prevent conflicts through locking or resolve them through retry mechanisms.</p>\n<p><strong>Business Rule Violation Handling</strong> deals with attempts to create invalid transactions, such as posting to closed accounting periods or creating unbalanced journal entries. The system must validate business rules consistently and provide clear error messages.</p>\n<table>\n<thead>\n<tr>\n<th>Error Category</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n<th>Prevention Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Data Corruption</td>\n<td>Checksums, constraints</td>\n<td>Restore from backup</td>\n<td>Redundancy, validation</td>\n</tr>\n<tr>\n<td>Partial Failures</td>\n<td>Transaction logs</td>\n<td>Rollback or complete</td>\n<td>Atomic operations</td>\n</tr>\n<tr>\n<td>Concurrency Conflicts</td>\n<td>Version numbers</td>\n<td>Optimistic retry</td>\n<td>Lock ordering</td>\n</tr>\n<tr>\n<td>Business Rule Violations</td>\n<td>Validation rules</td>\n<td>User correction</td>\n<td>Input validation</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The fundamental insight is that accounting systems must be designed as <strong>correctness-first systems</strong> where data integrity takes precedence over performance optimization. Every technical decision must consider its impact on financial accuracy and audit compliance.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Building a double-entry ledger system requires careful selection of technologies and architectural patterns that support the unique requirements of financial systems. This guidance provides concrete recommendations for implementing the concepts described above.</p>\n<p><strong>A. Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database</td>\n<td>PostgreSQL with ACID transactions</td>\n<td>PostgreSQL with streaming replication</td>\n</tr>\n<tr>\n<td>Web Framework</td>\n<td>Go standard library net/http</td>\n<td>Gin or Echo web framework</td>\n</tr>\n<tr>\n<td>JSON Processing</td>\n<td>Go standard library encoding/json</td>\n<td>Custom JSON schema validation</td>\n</tr>\n<tr>\n<td>Decimal Arithmetic</td>\n<td>shopspring/decimal package</td>\n<td>Custom fixed-point arithmetic</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Go standard library log</td>\n<td>Structured logging with logrus or zap</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td>Go standard library testing</td>\n<td>Property-based testing with gopter</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>Environment variables</td>\n<td>Viper configuration management</td>\n</tr>\n<tr>\n<td>Database Migration</td>\n<td>golang-migrate/migrate</td>\n<td>Custom migration framework</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ledger-system/\n├── cmd/\n│   ├── ledger-server/\n│   │   └── main.go                 # Application entry point\n│   └── ledger-cli/\n│       └── main.go                 # CLI tools for administration\n├── internal/\n│   ├── accounts/\n│   │   ├── account.go              # Account domain model\n│   │   ├── manager.go              # Account management business logic\n│   │   ├── repository.go           # Account data access interface\n│   │   └── postgres_repository.go  # PostgreSQL account storage\n│   ├── transactions/\n│   │   ├── journal_entry.go        # Journal entry domain model\n│   │   ├── recorder.go             # Transaction recording business logic\n│   │   ├── validator.go            # Double-entry validation logic\n│   │   └── repository.go           # Transaction data access interface\n│   ├── balances/\n│   │   ├── calculator.go           # Balance calculation engine\n│   │   ├── cache.go                # Balance caching strategies\n│   │   └── repository.go           # Balance storage interface\n│   ├── audit/\n│   │   ├── trail.go                # Audit trail recording\n│   │   ├── integrity.go            # Hash chain validation\n│   │   └── repository.go           # Audit log storage\n│   ├── reports/\n│   │   ├── generator.go            # Financial report generation\n│   │   ├── trial_balance.go        # Trial balance calculation\n│   │   └── financial_statements.go # Balance sheet and income statement\n│   ├── currency/\n│   │   ├── money.go                # Multi-currency money type\n│   │   ├── exchange_rates.go       # Exchange rate management\n│   │   └── converter.go            # Currency conversion logic\n│   └── common/\n│       ├── decimal.go              # Decimal arithmetic utilities\n│       ├── database.go             # Database connection management\n│       └── errors.go               # Custom error types\n├── pkg/\n│   └── api/\n│       ├── handlers.go             # HTTP API handlers\n│       ├── middleware.go           # Authentication and logging middleware\n│       └── types.go                # API request/response types\n├── migrations/\n│   ├── 001_create_accounts.up.sql\n│   ├── 002_create_journal_entries.up.sql\n│   └── 003_create_audit_trail.up.sql\n├── scripts/\n│   ├── setup-db.sh                 # Database initialization script\n│   └── run-tests.sh                # Test execution script\n└── docker/\n    ├── Dockerfile\n    └── docker-compose.yml          # Development environment</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p>Here&#39;s complete infrastructure code for decimal arithmetic handling, which is critical for financial accuracy:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/common/decimal.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> common</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql/driver</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/shopspring/decimal</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">strconv</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Money represents a monetary amount with fixed-point precision</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Amount   </span><span style=\"color:#B392F0\">decimal</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Decimal</span><span style=\"color:#9ECBFF\"> `json:\"amount\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Currency </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"currency\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewMoney creates a new Money value from a float64 amount and currency code</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewMoney</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">amount</span><span style=\"color:#F97583\"> float64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">currency</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Amount:   decimal.</span><span style=\"color:#B392F0\">NewFromFloat</span><span style=\"color:#E1E4E8\">(amount),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Currency: currency,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewMoneyFromString creates Money from a string representation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewMoneyFromString</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">amount</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">currency</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    amt, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> decimal.</span><span style=\"color:#B392F0\">NewFromString</span><span style=\"color:#E1E4E8\">(amount)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">{}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid amount </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, amount, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">{Amount: amt, Currency: currency}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Add returns the sum of two Money values (must be same currency)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">other</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> m.Currency </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.Currency {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">{}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"currency mismatch: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> != </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, m.Currency, other.Currency)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Amount:   m.Amount.</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(other.Amount),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Currency: m.Currency,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Subtract returns the difference of two Money values (must be same currency)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Subtract</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">other</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> m.Currency </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.Currency {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">{}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"currency mismatch: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> != </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, m.Currency, other.Currency)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Amount:   m.Amount.</span><span style=\"color:#B392F0\">Sub</span><span style=\"color:#E1E4E8\">(other.Amount),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Currency: m.Currency,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsZero returns true if the amount is zero</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsZero</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> m.Amount.</span><span style=\"color:#B392F0\">IsZero</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsPositive returns true if the amount is greater than zero</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsPositive</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> m.Amount.</span><span style=\"color:#B392F0\">IsPositive</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// String returns a formatted string representation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#79B8FF\"> %s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, m.Amount.</span><span style=\"color:#B392F0\">StringFixed</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">), m.Currency)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Database storage support</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">driver</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">|</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, m.Amount.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(), m.Currency), </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Scan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    s, ok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> value.(</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">ok {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cannot scan </span><span style=\"color:#79B8FF\">%T</span><span style=\"color:#9ECBFF\"> into Money\"</span><span style=\"color:#E1E4E8\">, value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Parse format \"amount|currency\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parts </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> strings.</span><span style=\"color:#B392F0\">Split</span><span style=\"color:#E1E4E8\">(s, </span><span style=\"color:#9ECBFF\">\"|\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#B392F0\"> len</span><span style=\"color:#E1E4E8\">(parts) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid money format: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, s)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    amount, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> decimal.</span><span style=\"color:#B392F0\">NewFromString</span><span style=\"color:#E1E4E8\">(parts[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"invalid amount in money: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, parts[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m.Amount </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> amount</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    m.Currency </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parts[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Complete database connection management:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/common/database.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> common</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/lib/pq</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Host     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Port     </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    User     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Password </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DBName   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SSLMode  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewDatabase</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> DatabaseConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dsn </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"host=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> port=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> user=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> password=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> dbname=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> sslmode=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config.Host, config.Port, config.User, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config.Password, config.DBName, config.SSLMode,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sql.</span><span style=\"color:#B392F0\">Open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"postgres\"</span><span style=\"color:#E1E4E8\">, dsn)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to open database: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configure connection pool for financial system requirements</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">SetMaxOpenConns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">25</span><span style=\"color:#E1E4E8\">)                 </span><span style=\"color:#6A737D\">// Limit concurrent connections</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">SetMaxIdleConns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">)                  </span><span style=\"color:#6A737D\">// Keep some connections ready</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">SetConnMaxLifetime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Minute) </span><span style=\"color:#6A737D\">// Rotate connections periodically</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Test the connection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Ping</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to ping database: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> db, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WithTransaction executes a function within a database transaction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is critical for maintaining accounting integrity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> WithTransaction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fn</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Tx</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tx, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Begin</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to begin transaction: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> recover</span><span style=\"color:#E1E4E8\">(); p </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tx.</span><span style=\"color:#B392F0\">Rollback</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            panic</span><span style=\"color:#E1E4E8\">(p) </span><span style=\"color:#6A737D\">// Re-throw panic after rollback</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> fn</span><span style=\"color:#E1E4E8\">(tx); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> rbErr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tx.</span><span style=\"color:#B392F0\">Rollback</span><span style=\"color:#E1E4E8\">(); rbErr </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"transaction error: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">, rollback error: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err, rbErr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tx.</span><span style=\"color:#B392F0\">Commit</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to commit transaction: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p>Here are the key interfaces and method signatures that learners should implement:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/accounts/account.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> accounts</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">ledger-system/internal/common</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AccountType represents the five fundamental account categories</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AccountType</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeAsset</span><span style=\"color:#B392F0\">     AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ASSET\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeLiability</span><span style=\"color:#B392F0\"> AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"LIABILITY\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeEquity</span><span style=\"color:#B392F0\">    AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"EQUITY\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeRevenue</span><span style=\"color:#B392F0\">   AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"REVENUE\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeExpense</span><span style=\"color:#B392F0\">   AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"EXPENSE\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Account represents a single account in the chart of accounts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Account</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID           </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Code         </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"code\"`</span><span style=\"color:#6A737D\">         // Account number/code</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name         </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"name\"`</span><span style=\"color:#6A737D\">         // Human-readable name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type         </span><span style=\"color:#B392F0\">AccountType</span><span style=\"color:#9ECBFF\"> `json:\"type\"`</span><span style=\"color:#6A737D\">         // Asset, Liability, etc.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Currency     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"currency\"`</span><span style=\"color:#6A737D\">     // ISO currency code</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ParentID     </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">     `json:\"parent_id\"`</span><span style=\"color:#6A737D\">    // For account hierarchy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsActive     </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">        `json:\"is_active\"`</span><span style=\"color:#6A737D\">    // Can be used in transactions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">   `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ModifiedAt   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">   `json:\"modified_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NormalBalance returns whether this account type increases with debits or credits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">a </span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">NormalBalance</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return \"DEBIT\" for assets and expenses, \"CREDIT\" for liabilities, equity, and revenue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // This determines how the account balance is calculated from debit/credit amounts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsDebitNormal returns true if this account increases with debit entries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">a </span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsDebitNormal</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return true for ASSET and EXPENSE accounts, false for LIABILITY, EQUITY, and REVENUE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/transactions/journal_entry.go  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> transactions</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">ledger-system/internal/common</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EntryStatus represents the lifecycle state of a journal entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EntryStatus</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EntryStatusDraft</span><span style=\"color:#B392F0\">    EntryStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"DRAFT\"</span><span style=\"color:#6A737D\">    // Being composed</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EntryStatusPosted</span><span style=\"color:#B392F0\">   EntryStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"POSTED\"</span><span style=\"color:#6A737D\">   // Officially recorded</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EntryStatusReversed</span><span style=\"color:#B392F0\"> EntryStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"REVERSED\"</span><span style=\"color:#6A737D\"> // Canceled by reversal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// JournalEntry represents a complete double-entry transaction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> JournalEntry</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID          </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Date        </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">     `json:\"date\"`</span><span style=\"color:#6A737D\">        // Transaction date</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"description\"`</span><span style=\"color:#6A737D\"> // Transaction description</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Reference   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"reference\"`</span><span style=\"color:#6A737D\">   // External reference (invoice #, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status      </span><span style=\"color:#B392F0\">EntryStatus</span><span style=\"color:#9ECBFF\">   `json:\"status\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedBy   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"created_by\"`</span><span style=\"color:#6A737D\">  // User who created entry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PostedAt    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">    `json:\"posted_at\"`</span><span style=\"color:#6A737D\">   // When entry was posted</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Lines       []</span><span style=\"color:#B392F0\">EntryLine</span><span style=\"color:#9ECBFF\">   `json:\"lines\"`</span><span style=\"color:#6A737D\">       // Debit and credit lines</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">     `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EntryLine represents a single debit or credit within a journal entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EntryLine</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID            </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    JournalID     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"journal_id\"`</span><span style=\"color:#6A737D\">   // Parent journal entry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AccountID     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"account_id\"`</span><span style=\"color:#6A737D\">   // Account being debited/credited</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DebitAmount   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#9ECBFF\"> `json:\"debit_amount\"`</span><span style=\"color:#6A737D\">  // Amount if this is a debit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreditAmount  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#9ECBFF\"> `json:\"credit_amount\"`</span><span style=\"color:#6A737D\"> // Amount if this is a credit</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"description\"`</span><span style=\"color:#6A737D\">   // Line item description</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LineNumber    </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">         `json:\"line_number\"`</span><span style=\"color:#6A737D\">   // Order within entry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Validate checks if this journal entry follows double-entry rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">je </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Validate</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Verify entry has at least 2 lines (minimum for double-entry)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate total debits from all lines with DebitAmount != nil</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate total credits from all lines with CreditAmount != nil  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify total debits equals total credits exactly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify each line has exactly one of DebitAmount or CreditAmount (not both, not neither)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Verify all amounts are positive (negative amounts not allowed)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Verify all lines reference valid, active accounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Check that entry date is not in a closed accounting period</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TotalDebits calculates the sum of all debit amounts in this entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">je </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TotalDebits</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Iterate through Lines, sum up all DebitAmount values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle currency conversion if needed - all amounts should be same currency</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TotalCredits calculates the sum of all credit amounts in this entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">je </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TotalCredits</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Iterate through Lines, sum up all CreditAmount values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Handle currency conversion if needed - all amounts should be same currency</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<p><strong>Go-Specific Implementation Tips:</strong></p>\n<ul>\n<li>Use <code>database/sql</code> with prepared statements for all database operations to prevent SQL injection</li>\n<li>Implement proper error handling with wrapped errors using <code>fmt.Errorf(&quot;context: %w&quot;, err)</code></li>\n<li>Use <code>sql.NullString</code> and <code>sql.NullTime</code> for optional database fields</li>\n<li>Implement database transactions using <code>db.Begin()</code>, <code>tx.Commit()</code>, and <code>tx.Rollback()</code></li>\n<li>Use struct tags for JSON serialization: <code>json:&quot;field_name&quot;</code></li>\n<li>Implement the <code>Stringer</code> interface for custom string representations</li>\n<li>Use Go modules for dependency management with <code>go.mod</code></li>\n<li>Implement proper database connection pooling with connection limits</li>\n</ul>\n<p><strong>PostgreSQL Integration:</strong></p>\n<ul>\n<li>Use NUMERIC(19,4) column type for monetary amounts to avoid floating-point errors</li>\n<li>Create partial indexes on status columns: <code>CREATE INDEX idx_active_accounts ON accounts (id) WHERE is_active = true</code></li>\n<li>Use foreign key constraints to ensure referential integrity between tables</li>\n<li>Implement check constraints for business rules: <code>CONSTRAINT chk_positive_amount CHECK (amount &gt;= 0)</code></li>\n<li>Use database transactions for multi-table operations to maintain consistency</li>\n<li>Consider using PostgreSQL&#39;s <code>SERIAL</code> or <code>UUID</code> types for primary keys</li>\n</ul>\n<p><strong>F. Milestone Checkpoints</strong></p>\n<p>After implementing the foundation concepts in this section, verify the following behavior:</p>\n<p><strong>Milestone 1 Checkpoint - Account &amp; Entry Model:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run unit tests for account and entry models</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/accounts/...</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/transactions/...</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Expected output should show:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Account type validation tests passing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Normal balance calculation tests passing  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Journal entry validation tests passing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># - Double-entry balance validation tests passing</span></span></code></pre></div>\n\n<p><strong>Manual Verification Steps:</strong></p>\n<ol>\n<li>Create sample accounts of each type (Asset, Liability, Equity, Revenue, Expense)</li>\n<li>Attempt to create an unbalanced journal entry - should be rejected</li>\n<li>Create a balanced journal entry with multiple debit and credit lines - should be accepted</li>\n<li>Verify that account normal balance calculation matches expected debit/credit behavior</li>\n</ol>\n<p><strong>Expected Behavior:</strong></p>\n<ul>\n<li>Account creation succeeds with valid account types and fails with invalid types</li>\n<li>Journal entry validation rejects entries where total debits ≠ total credits</li>\n<li>Multi-currency money arithmetic works correctly without floating-point errors</li>\n<li>Database constraints prevent invalid data entry</li>\n</ul>\n<p><strong>G. Debugging Tips</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Unbalanced entry&quot; errors on valid transactions</td>\n<td>Rounding errors in decimal arithmetic</td>\n<td>Check decimal precision settings</td>\n<td>Use fixed-point arithmetic with sufficient precision</td>\n</tr>\n<tr>\n<td>Database constraint violations</td>\n<td>Missing foreign key references</td>\n<td>Check account IDs exist before creating entries</td>\n<td>Add validation to verify account existence</td>\n</tr>\n<tr>\n<td>Slow balance calculations</td>\n<td>Missing database indexes</td>\n<td>Run EXPLAIN on balance queries</td>\n<td>Add indexes on account_id and posting_date columns</td>\n</tr>\n<tr>\n<td>Transaction rollback failures</td>\n<td>Nested transaction attempts</td>\n<td>Review transaction boundary code</td>\n<td>Use single transaction per journal entry operation</td>\n</tr>\n<tr>\n<td>JSON serialization errors</td>\n<td>Pointer fields with nil values</td>\n<td>Check for nil pointer dereference</td>\n<td>Use proper null handling in struct tags</td>\n</tr>\n<tr>\n<td>Currency mismatch errors</td>\n<td>Mixed currencies in single entry</td>\n<td>Validate currency consistency</td>\n<td>Add business rule validation for currency matching</td>\n</tr>\n</tbody></table>\n<p>The foundation established in this section provides the conceptual framework and basic infrastructure needed to implement a production-quality double-entry ledger system. The key insight is that financial systems require different architectural trade-offs than typical applications, prioritizing correctness and auditability over raw performance.</p>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones, as this section establishes the scope and requirements that drive the design of each system component</p>\n</blockquote>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<p>Building a robust double-entry ledger system requires careful scoping to focus on core accounting principles while avoiding feature creep. Think of this system as the foundation of a skyscraper—it must be rock-solid in its fundamental capabilities before any additional features can be safely built on top. A ledger system that tries to do everything often ends up doing nothing well, particularly when it comes to the non-negotiable requirements of financial accuracy and auditability.</p>\n<p>This section establishes clear boundaries around what our ledger system will and will not accomplish. The distinction between goals and non-goals is critical because accounting systems sit at the intersection of complex business requirements, regulatory compliance, and technical performance demands. Every feature we include increases complexity and potential failure points, while every feature we exclude allows us to focus engineering effort on getting the core functionality absolutely right.</p>\n<h3 id=\"functional-requirements\">Functional Requirements</h3>\n<p>The functional requirements define the core accounting capabilities that our ledger system must provide. These requirements are derived from fundamental double-entry bookkeeping principles and represent the minimum viable feature set for a production-ready accounting system.</p>\n<h4 id=\"core-double-entry-bookkeeping-operations\">Core Double-Entry Bookkeeping Operations</h4>\n<p>The system must implement complete double-entry bookkeeping functionality with mathematical precision and business rule enforcement. Think of this as the &quot;physics&quot; of our accounting universe—these rules cannot be bent or broken without compromising the entire system&#39;s integrity.</p>\n<p><strong>Chart of Accounts Management</strong></p>\n<p>The system must provide comprehensive account management capabilities that support the five fundamental account types used in double-entry bookkeeping. Each account type has specific behavioral rules that the system must enforce automatically.</p>\n<table>\n<thead>\n<tr>\n<th>Account Type</th>\n<th>Normal Balance</th>\n<th>Examples</th>\n<th>Debit Effect</th>\n<th>Credit Effect</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Asset</td>\n<td>Debit</td>\n<td>Cash, Inventory, Equipment</td>\n<td>Increases</td>\n<td>Decreases</td>\n</tr>\n<tr>\n<td>Liability</td>\n<td>Credit</td>\n<td>Accounts Payable, Loans</td>\n<td>Decreases</td>\n<td>Increases</td>\n</tr>\n<tr>\n<td>Equity</td>\n<td>Credit</td>\n<td>Owner&#39;s Capital, Retained Earnings</td>\n<td>Decreases</td>\n<td>Increases</td>\n</tr>\n<tr>\n<td>Revenue</td>\n<td>Credit</td>\n<td>Sales, Service Income</td>\n<td>Decreases</td>\n<td>Increases</td>\n</tr>\n<tr>\n<td>Expense</td>\n<td>Debit</td>\n<td>Rent, Salaries, Utilities</td>\n<td>Increases</td>\n<td>Decreases</td>\n</tr>\n</tbody></table>\n<p>The account management system must support hierarchical organization through parent-child relationships, enabling users to create detailed sub-accounts while maintaining logical groupings. For example, a &quot;Cash&quot; parent account might have children like &quot;Checking Account - Bank A&quot; and &quot;Petty Cash&quot;. The system must validate that child accounts maintain the same normal balance orientation as their parents and prevent circular references in the hierarchy.</p>\n<p><strong>Journal Entry Recording and Validation</strong></p>\n<p>Every financial transaction must be recorded through journal entries that strictly enforce the fundamental accounting equation: Assets = Liabilities + Equity. The system must validate that every journal entry maintains perfect mathematical balance where total debits equal total credits.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Rule</th>\n<th>Description</th>\n<th>Failure Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Balance Requirement</td>\n<td>Total debits must equal total credits</td>\n<td>Reject entry with specific error message</td>\n</tr>\n<tr>\n<td>Account Existence</td>\n<td>All referenced accounts must exist and be active</td>\n<td>Reject entry with invalid account details</td>\n</tr>\n<tr>\n<td>Account Type Compatibility</td>\n<td>Debits/credits must respect account normal balances</td>\n<td>Allow but warn for unusual entries</td>\n</tr>\n<tr>\n<td>Date Validity</td>\n<td>Entry date must be reasonable (not future, not too old)</td>\n<td>Reject with date validation error</td>\n</tr>\n<tr>\n<td>Amount Precision</td>\n<td>Monetary amounts must have appropriate decimal precision</td>\n<td>Round or reject based on currency rules</td>\n</tr>\n</tbody></table>\n<p>The journal entry workflow must support both single-currency and multi-currency transactions. For multi-currency entries, the system must store exchange rates at the time of transaction and validate that converted amounts still balance in the reporting currency.</p>\n<p><strong>Transaction Templates and Common Patterns</strong></p>\n<p>To reduce errors and improve efficiency, the system must provide predefined transaction templates for common business operations. These templates encode best practices for recording standard transactions while allowing customization for specific business needs.</p>\n<table>\n<thead>\n<tr>\n<th>Transaction Type</th>\n<th>Accounts Affected</th>\n<th>Template Structure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cash Sale</td>\n<td>Cash (Debit), Sales Revenue (Credit)</td>\n<td>Simple two-line entry</td>\n</tr>\n<tr>\n<td>Credit Sale</td>\n<td>Accounts Receivable (Debit), Sales Revenue (Credit)</td>\n<td>Two-line entry with customer reference</td>\n</tr>\n<tr>\n<td>Cash Purchase</td>\n<td>Expense Account (Debit), Cash (Credit)</td>\n<td>Two-line entry with vendor reference</td>\n</tr>\n<tr>\n<td>Loan Payment</td>\n<td>Loan Principal (Debit), Interest Expense (Debit), Cash (Credit)</td>\n<td>Three-line entry with payment allocation</td>\n</tr>\n<tr>\n<td>Depreciation</td>\n<td>Depreciation Expense (Debit), Accumulated Depreciation (Credit)</td>\n<td>Two-line entry with asset reference</td>\n</tr>\n</tbody></table>\n<h4 id=\"balance-calculation-and-inquiry-system\">Balance Calculation and Inquiry System</h4>\n<p>The system must provide real-time access to accurate account balances while maintaining performance under high transaction volumes. Think of balance calculation as the &quot;pulse&quot; of the accounting system—it must be both immediate and absolutely reliable.</p>\n<p><strong>Current Balance Computation</strong></p>\n<p>Current balances must reflect all posted transactions and be available instantly for any account query. The system must handle the mathematical complexity of different account types having different normal balances.</p>\n<table>\n<thead>\n<tr>\n<th>Balance Calculation Method</th>\n<th>Use Case</th>\n<th>Performance Characteristics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Running Balance Cache</td>\n<td>High-frequency balance queries</td>\n<td>O(1) lookup, requires cache maintenance</td>\n</tr>\n<tr>\n<td>Real-time Aggregation</td>\n<td>Infrequent queries, maximum accuracy</td>\n<td>O(n) calculation, always current</td>\n</tr>\n<tr>\n<td>Hybrid Approach</td>\n<td>Most production scenarios</td>\n<td>Cached with incremental updates</td>\n</tr>\n</tbody></table>\n<p><strong>Point-in-Time Balance Queries</strong></p>\n<p>The system must support historical balance calculations that show account balances as of any specific date and time. This capability is essential for financial reporting, auditing, and understanding how balances evolved over time.</p>\n<p><strong>Trial Balance Generation and Validation</strong></p>\n<p>The system must automatically generate trial balance reports that prove the books are mathematically correct. A trial balance lists all accounts with their debit and credit balances, and the totals must always be equal. This is the primary mathematical proof that the double-entry system is working correctly.</p>\n<table>\n<thead>\n<tr>\n<th>Trial Balance Component</th>\n<th>Description</th>\n<th>Validation Rule</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Account Listing</td>\n<td>All active accounts with non-zero balances</td>\n<td>Must include all accounts with activity</td>\n</tr>\n<tr>\n<td>Debit Column</td>\n<td>Accounts with debit normal balances</td>\n<td>Asset and Expense accounts</td>\n</tr>\n<tr>\n<td>Credit Column</td>\n<td>Accounts with credit normal balances</td>\n<td>Liability, Equity, and Revenue accounts</td>\n</tr>\n<tr>\n<td>Column Totals</td>\n<td>Sum of debit and credit columns</td>\n<td>Must be equal or system is invalid</td>\n</tr>\n</tbody></table>\n<h4 id=\"financial-reporting-capabilities\">Financial Reporting Capabilities</h4>\n<p>The system must generate the three primary financial statements that businesses use to understand their financial position and performance. These reports form the foundation of business decision-making and regulatory compliance.</p>\n<p><strong>Balance Sheet Generation</strong></p>\n<p>The balance sheet provides a snapshot of financial position at a specific point in time, showing that assets equal liabilities plus equity. The system must automatically categorize accounts into the correct balance sheet sections and validate that the fundamental equation balances.</p>\n<table>\n<thead>\n<tr>\n<th>Balance Sheet Section</th>\n<th>Account Types Included</th>\n<th>Reporting Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Current Assets</td>\n<td>Short-term assets (Cash, Receivables, Inventory)</td>\n<td>Listed in order of liquidity</td>\n</tr>\n<tr>\n<td>Fixed Assets</td>\n<td>Long-term assets (Equipment, Buildings, Land)</td>\n<td>Shown at cost minus accumulated depreciation</td>\n</tr>\n<tr>\n<td>Current Liabilities</td>\n<td>Short-term obligations (Payables, Accrued expenses)</td>\n<td>Listed by payment due date</td>\n</tr>\n<tr>\n<td>Long-term Liabilities</td>\n<td>Long-term debt and obligations</td>\n<td>Shown with maturity information</td>\n</tr>\n<tr>\n<td>Equity</td>\n<td>Owner&#39;s equity and retained earnings</td>\n<td>Shows cumulative ownership and profits</td>\n</tr>\n</tbody></table>\n<p><strong>Income Statement Generation</strong></p>\n<p>The income statement shows profitability over a period by comparing revenues to expenses. The system must accurately filter transactions by date range and categorize them into revenue and expense sections.</p>\n<p><strong>Cash Flow Statement Foundation</strong></p>\n<p>While full cash flow statements require complex analysis, the system must provide the underlying data categorization that enables cash flow reporting. This includes identifying operating, investing, and financing activities through account classification and transaction metadata.</p>\n<blockquote>\n<p><strong>Design Insight: Separation of Core from Convenience</strong></p>\n<p>The functional requirements focus deliberately on core accounting operations rather than user convenience features. This separation allows us to build a mathematically sound foundation that can support various user interfaces and workflow tools without coupling the accounting logic to presentation concerns.</p>\n</blockquote>\n<h3 id=\"non-functional-requirements\">Non-Functional Requirements</h3>\n<p>Non-functional requirements define how well the system must perform its functional capabilities. For a financial system, these requirements often matter more than additional features because they determine whether the system can be trusted with an organization&#39;s financial data.</p>\n<h4 id=\"performance-and-scalability-requirements\">Performance and Scalability Requirements</h4>\n<p>The system must handle realistic business transaction volumes without degrading user experience or system reliability. Performance requirements are not just about speed—they&#39;re about predictable behavior under load.</p>\n<p><strong>Transaction Processing Performance</strong></p>\n<table>\n<thead>\n<tr>\n<th>Performance Metric</th>\n<th>Requirement</th>\n<th>Measurement Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Journal Entry Posting</td>\n<td>&lt; 100ms per entry (95th percentile)</td>\n<td>End-to-end API response time</td>\n</tr>\n<tr>\n<td>Balance Query Response</td>\n<td>&lt; 50ms per query (99th percentile)</td>\n<td>Database query to API response</td>\n</tr>\n<tr>\n<td>Trial Balance Generation</td>\n<td>&lt; 2 seconds for 10,000 accounts</td>\n<td>Report generation completion time</td>\n</tr>\n<tr>\n<td>Concurrent Users</td>\n<td>Support 50 simultaneous users</td>\n<td>Load testing with realistic workloads</td>\n</tr>\n<tr>\n<td>Transaction Volume</td>\n<td>10,000 journal entries per day</td>\n<td>Sustained throughput over 8-hour period</td>\n</tr>\n</tbody></table>\n<p><strong>Database Performance Characteristics</strong></p>\n<p>The system must maintain performance as data volume grows. Financial data never gets deleted, so the system must handle ever-increasing transaction history without slowdown.</p>\n<table>\n<thead>\n<tr>\n<th>Data Volume Scenario</th>\n<th>Expected Performance Impact</th>\n<th>Mitigation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1 million transactions</td>\n<td>Baseline performance</td>\n<td>Proper indexing and query optimization</td>\n</tr>\n<tr>\n<td>10 million transactions</td>\n<td>&lt; 20% performance degradation</td>\n<td>Partitioning and archive strategies</td>\n</tr>\n<tr>\n<td>100 million transactions</td>\n<td>May require infrastructure scaling</td>\n<td>Horizontal scaling or data tiering</td>\n</tr>\n</tbody></table>\n<h4 id=\"reliability-and-data-integrity-requirements\">Reliability and Data Integrity Requirements</h4>\n<p>Financial systems must be absolutely reliable because errors in accounting data can have serious legal and business consequences. The system must be designed with multiple layers of protection against data corruption, loss, or inconsistency.</p>\n<p><strong>Data Consistency Guarantees</strong></p>\n<p>The system must maintain ACID properties for all financial transactions, with particular emphasis on consistency and durability. Think of this as the &quot;insurance policy&quot; for financial data—every transaction must be all-or-nothing with permanent recording.</p>\n<table>\n<thead>\n<tr>\n<th>Consistency Requirement</th>\n<th>Implementation Need</th>\n<th>Failure Consequence</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Atomic Journal Entries</td>\n<td>Database transactions wrapping all entry lines</td>\n<td>Partial entries could unbalance books</td>\n</tr>\n<tr>\n<td>Double-Entry Balance</td>\n<td>Real-time validation before posting</td>\n<td>Unbalanced entries violate accounting principles</td>\n</tr>\n<tr>\n<td>Referential Integrity</td>\n<td>Foreign key constraints and application validation</td>\n<td>Orphaned data could corrupt reports</td>\n</tr>\n<tr>\n<td>Temporal Consistency</td>\n<td>Proper transaction ordering and timestamps</td>\n<td>Incorrect financial statement calculations</td>\n</tr>\n</tbody></table>\n<p><strong>Backup and Recovery Capabilities</strong></p>\n<p>The system must support comprehensive backup strategies that ensure financial data can be recovered completely and accurately after any type of failure.</p>\n<table>\n<thead>\n<tr>\n<th>Recovery Scenario</th>\n<th>Recovery Time Objective</th>\n<th>Recovery Point Objective</th>\n<th>Implementation Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Application Crash</td>\n<td>&lt; 5 minutes</td>\n<td>0 data loss</td>\n<td>Automatic restart with transaction log replay</td>\n</tr>\n<tr>\n<td>Database Corruption</td>\n<td>&lt; 30 minutes</td>\n<td>&lt; 1 minute data loss</td>\n<td>Point-in-time recovery from backups</td>\n</tr>\n<tr>\n<td>Hardware Failure</td>\n<td>&lt; 2 hours</td>\n<td>&lt; 5 minutes data loss</td>\n<td>Failover to backup infrastructure</td>\n</tr>\n<tr>\n<td>Site Disaster</td>\n<td>&lt; 24 hours</td>\n<td>&lt; 15 minutes data loss</td>\n<td>Geographic backup restoration</td>\n</tr>\n</tbody></table>\n<h4 id=\"security-and-compliance-requirements\">Security and Compliance Requirements</h4>\n<p>Financial systems must implement robust security controls and maintain compliance with accounting standards and regulations. Security is not just about preventing unauthorized access—it&#39;s about maintaining the integrity and trustworthiness of financial records.</p>\n<p><strong>Access Control and Authentication</strong></p>\n<table>\n<thead>\n<tr>\n<th>Security Control</th>\n<th>Requirement</th>\n<th>Implementation Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>User Authentication</td>\n<td>Strong password policies or multi-factor authentication</td>\n<td>Integration with enterprise identity systems</td>\n</tr>\n<tr>\n<td>Role-Based Access</td>\n<td>Granular permissions for different accounting functions</td>\n<td>Separation of duties for financial controls</td>\n</tr>\n<tr>\n<td>Session Management</td>\n<td>Automatic logout and session encryption</td>\n<td>Protection against unauthorized access</td>\n</tr>\n<tr>\n<td>API Security</td>\n<td>Authentication tokens and rate limiting</td>\n<td>Secure integration with other systems</td>\n</tr>\n</tbody></table>\n<p><strong>Audit and Compliance Capabilities</strong></p>\n<p>The system must maintain complete audit trails that satisfy regulatory requirements and support forensic investigation when needed.</p>\n<table>\n<thead>\n<tr>\n<th>Audit Requirement</th>\n<th>Retention Period</th>\n<th>Information Captured</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Transaction History</td>\n<td>7 years minimum</td>\n<td>All journal entries with timestamps and user information</td>\n</tr>\n<tr>\n<td>System Access Logs</td>\n<td>2 years minimum</td>\n<td>Login attempts, permission changes, system administration</td>\n</tr>\n<tr>\n<td>Data Modifications</td>\n<td>Permanent retention</td>\n<td>Before/after values for any data changes</td>\n</tr>\n<tr>\n<td>Report Generation</td>\n<td>1 year minimum</td>\n<td>What reports were generated when and by whom</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Insight: Auditability as a Feature</strong></p>\n<p>Many developers treat audit logging as an afterthought, but in financial systems, auditability must be designed into every component from the beginning. The audit trail is not just for compliance—it&#39;s often the primary tool for diagnosing and fixing accounting discrepancies.</p>\n</blockquote>\n<h3 id=\"explicit-non-goals\">Explicit Non-Goals</h3>\n<p>Clearly defining what the system will NOT do is as important as defining what it will do. These non-goals prevent scope creep and ensure engineering resources focus on core accounting functionality rather than peripheral business applications.</p>\n<h4 id=\"business-process-automation-explicitly-excluded\">Business Process Automation (Explicitly Excluded)</h4>\n<p>While many accounting systems include workflow and business process features, our ledger system deliberately excludes these capabilities to maintain focus on core accounting accuracy and reliability.</p>\n<p><strong>Excluded Business Processes</strong></p>\n<table>\n<thead>\n<tr>\n<th>Excluded Feature</th>\n<th>Rationale for Exclusion</th>\n<th>Alternative Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Invoice Generation</td>\n<td>Not core to double-entry bookkeeping</td>\n<td>External invoicing system posts to ledger</td>\n</tr>\n<tr>\n<td>Purchase Order Management</td>\n<td>Business process, not accounting transaction</td>\n<td>PO system creates journal entries when appropriate</td>\n</tr>\n<tr>\n<td>Payroll Processing</td>\n<td>Complex domain with specialized requirements</td>\n<td>Payroll system posts summary entries to ledger</td>\n</tr>\n<tr>\n<td>Inventory Management</td>\n<td>Operational system with different data models</td>\n<td>Inventory system posts value changes to ledger</td>\n</tr>\n<tr>\n<td>Customer Relationship Management</td>\n<td>Sales process, not financial recording</td>\n<td>CRM integrates with ledger for financial data</td>\n</tr>\n</tbody></table>\n<p><strong>Approval Workflow Exclusions</strong></p>\n<p>While some businesses require approval workflows for journal entries, implementing this capability would significantly complicate the core accounting engine. The system will provide hooks for external workflow systems rather than implementing approval logic directly.</p>\n<h4 id=\"tax-calculation-and-compliance-explicitly-excluded\">Tax Calculation and Compliance (Explicitly Excluded)</h4>\n<p>Tax calculation involves complex, jurisdiction-specific rules that change frequently and require specialized expertise. Including tax features would compromise the system&#39;s focus on fundamental accounting principles.</p>\n<p><strong>Tax-Related Exclusions</strong></p>\n<table>\n<thead>\n<tr>\n<th>Tax Feature</th>\n<th>Why Excluded</th>\n<th>Integration Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Sales Tax Calculation</td>\n<td>Jurisdiction-specific rules too complex</td>\n<td>Tax service calculates, posts results to ledger</td>\n</tr>\n<tr>\n<td>Income Tax Preparation</td>\n<td>Requires specialized tax accounting knowledge</td>\n<td>Tax software reads ledger data for preparation</td>\n</tr>\n<tr>\n<td>Regulatory Tax Reporting</td>\n<td>Different formats for each jurisdiction</td>\n<td>Reporting tools extract data from standardized ledger</td>\n</tr>\n<tr>\n<td>Tax Code Maintenance</td>\n<td>Requires legal and tax expertise</td>\n<td>External tax reference data integrated as needed</td>\n</tr>\n</tbody></table>\n<h4 id=\"user-interface-and-experience-features-explicitly-excluded\">User Interface and Experience Features (Explicitly Excluded)</h4>\n<p>The ledger system will provide robust APIs but will not include user interface components. This separation allows for specialized UI development while keeping the accounting engine focused on data integrity and performance.</p>\n<p><strong>UI/UX Exclusions</strong></p>\n<table>\n<thead>\n<tr>\n<th>Interface Feature</th>\n<th>Rationale for Exclusion</th>\n<th>API-First Alternative</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Web Dashboard</td>\n<td>UI frameworks change frequently</td>\n<td>REST/GraphQL APIs for any UI framework</td>\n</tr>\n<tr>\n<td>Mobile Applications</td>\n<td>Device-specific development requirements</td>\n<td>APIs support mobile app development</td>\n</tr>\n<tr>\n<td>Report Formatting</td>\n<td>Presentation layer separate from data layer</td>\n<td>Raw data APIs for custom report formatting</td>\n</tr>\n<tr>\n<td>User Preference Management</td>\n<td>Not related to accounting functionality</td>\n<td>External user management system integration</td>\n</tr>\n</tbody></table>\n<p><strong>Integration and Middleware Exclusions</strong></p>\n<p>While the system will provide integration capabilities, it will not include middleware or ETL functionality that goes beyond basic accounting data exchange.</p>\n<table>\n<thead>\n<tr>\n<th>Integration Feature</th>\n<th>Why Excluded</th>\n<th>Recommended Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Data Transformation Tools</td>\n<td>Not core to accounting logic</td>\n<td>External ETL tools work with ledger APIs</td>\n</tr>\n<tr>\n<td>Message Queue Management</td>\n<td>Infrastructure concern, not accounting</td>\n<td>Standard messaging systems integrate via APIs</td>\n</tr>\n<tr>\n<td>File Format Conversion</td>\n<td>Presentation layer responsibility</td>\n<td>Import/export APIs with standard formats</td>\n</tr>\n<tr>\n<td>Third-Party API Orchestration</td>\n<td>Business logic outside accounting scope</td>\n<td>Integration platform calls ledger APIs</td>\n</tr>\n</tbody></table>\n<h4 id=\"advanced-financial-analytics-explicitly-excluded\">Advanced Financial Analytics (Explicitly Excluded)</h4>\n<p>While the ledger provides foundation data for financial analysis, advanced analytics capabilities are deliberately excluded to maintain system focus and performance.</p>\n<p><strong>Analytics Exclusions</strong></p>\n<table>\n<thead>\n<tr>\n<th>Analytics Feature</th>\n<th>Rationale for Exclusion</th>\n<th>Data Access Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Predictive Financial Modeling</td>\n<td>Requires specialized algorithms and expertise</td>\n<td>Raw ledger data exported for analysis tools</td>\n</tr>\n<tr>\n<td>Business Intelligence Dashboards</td>\n<td>Presentation and analysis layer separate from ledger</td>\n<td>APIs provide data for BI tools</td>\n</tr>\n<tr>\n<td>Performance KPI Calculations</td>\n<td>Business-specific metrics beyond accounting scope</td>\n<td>Calculated by business intelligence systems</td>\n</tr>\n<tr>\n<td>Variance Analysis</td>\n<td>Requires budgeting data and business rules</td>\n<td>External planning systems analyze ledger actuals</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: API-First Architecture for Non-Core Features</strong></p>\n<ul>\n<li><strong>Context</strong>: Many accounting features could be built into the ledger system, but would significantly increase complexity and maintenance burden</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Monolithic system including all business features</li>\n<li>Modular system with optional feature modules  </li>\n<li>Pure ledger with comprehensive APIs for external integration</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Pure ledger with comprehensive APIs</li>\n<li><strong>Rationale</strong>: Allows specialized teams to build best-in-class solutions for each business domain while maintaining ledger system focus on accounting accuracy and performance</li>\n<li><strong>Consequences</strong>: Requires more integration work but results in better overall system architecture and allows independent scaling of different functional areas</li>\n</ul>\n</blockquote>\n<h3 id=\"requirements-validation-and-success-criteria\">Requirements Validation and Success Criteria</h3>\n<p>To ensure the system meets its goals, we must establish measurable success criteria for each category of requirements. These criteria will guide development priorities and provide objective measures of system completion.</p>\n<p><strong>Functional Requirements Validation</strong></p>\n<table>\n<thead>\n<tr>\n<th>Requirement Category</th>\n<th>Success Criteria</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Double-Entry Compliance</td>\n<td>100% of journal entries balance mathematically</td>\n<td>Automated testing with property-based test generation</td>\n</tr>\n<tr>\n<td>Account Management</td>\n<td>Support for all 5 account types with proper normal balance behavior</td>\n<td>Unit tests covering all account type scenarios</td>\n</tr>\n<tr>\n<td>Balance Calculation</td>\n<td>Current and historical balances always match transaction sum</td>\n<td>Reconciliation tests comparing calculated vs. aggregated balances</td>\n</tr>\n<tr>\n<td>Financial Reporting</td>\n<td>Trial balance always sums to zero, balance sheet always balances</td>\n<td>End-to-end reporting tests with known datasets</td>\n</tr>\n</tbody></table>\n<p><strong>Non-Functional Requirements Validation</strong></p>\n<table>\n<thead>\n<tr>\n<th>Performance Metric</th>\n<th>Target</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Transaction Throughput</td>\n<td>10,000 entries per day sustained</td>\n<td>Load testing with realistic transaction patterns</td>\n</tr>\n<tr>\n<td>Response Time</td>\n<td>95% of operations under specified time limits</td>\n<td>Automated performance testing in CI/CD pipeline</td>\n</tr>\n<tr>\n<td>Data Integrity</td>\n<td>Zero tolerance for data corruption</td>\n<td>Continuous integrity checks and audit trail validation</td>\n</tr>\n<tr>\n<td>System Availability</td>\n<td>99.9% uptime during business hours</td>\n<td>Infrastructure monitoring and incident tracking</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The requirements established in this section directly influence technology choices and implementation priorities. Understanding how to translate these requirements into working code requires careful consideration of architecture patterns and technology stack decisions.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database</td>\n<td>PostgreSQL with ACID transactions</td>\n<td>PostgreSQL with read replicas and connection pooling</td>\n</tr>\n<tr>\n<td>API Framework</td>\n<td>Go standard library net/http</td>\n<td>Gin or Echo web framework with middleware</td>\n</tr>\n<tr>\n<td>Validation</td>\n<td>Manual validation functions</td>\n<td>Validator library with struct tags</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td>Standard Go testing package</td>\n<td>Testify for assertions plus property-based testing</td>\n</tr>\n<tr>\n<td>Documentation</td>\n<td>Inline code comments</td>\n<td>OpenAPI/Swagger specification generation</td>\n</tr>\n<tr>\n<td>Monitoring</td>\n<td>Basic logging to stdout</td>\n<td>Structured logging with metrics collection</td>\n</tr>\n</tbody></table>\n<h4 id=\"core-requirements-implementation-structure\">Core Requirements Implementation Structure</h4>\n<p>The requirements drive a specific code organization that separates concerns cleanly and supports testing at multiple levels:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ledger-system/\n  cmd/\n    server/main.go              ← HTTP API server entry point\n    cli/main.go                 ← Command-line tools for administration\n  internal/\n    accounts/                   ← Chart of accounts management\n      types.go                  ← Account type definitions and validation\n      repository.go             ← Account persistence layer\n      service.go                ← Account business logic\n    entries/                    ← Journal entry recording\n      types.go                  ← Entry and line item structures\n      validator.go              ← Double-entry validation logic\n      repository.go             ← Entry persistence layer\n      service.go                ← Entry recording business logic\n    balances/                   ← Balance calculation engine\n      calculator.go             ← Current and historical balance computation\n      cache.go                  ← Running balance cache management\n      service.go                ← Balance query business logic\n    reports/                    ← Financial reporting\n      trial_balance.go          ← Trial balance generation\n      balance_sheet.go          ← Balance sheet generation\n      income_statement.go       ← Income statement generation\n    audit/                      ← Audit trail system\n      logger.go                 ← Change tracking and audit logging\n      trail.go                  ← Immutable audit trail management\n    api/                        ← HTTP API handlers\n      accounts.go               ← Account management endpoints\n      entries.go                ← Journal entry endpoints\n      balances.go               ← Balance query endpoints\n      reports.go                ← Financial report endpoints\n  pkg/\n    money/                      ← Monetary amount handling\n      money.go                  ← Fixed-point decimal arithmetic\n      currency.go               ← Multi-currency support\n    database/                   ← Database utilities\n      connection.go             ← Database connection management\n      migrations/               ← Database schema versioning\n  test/\n    integration/                ← End-to-end testing\n    fixtures/                   ← Test data for consistent testing</code></pre></div>\n\n<h4 id=\"requirements-driven-type-definitions\">Requirements-Driven Type Definitions</h4>\n<p>The functional requirements directly translate into core type definitions that enforce business rules at the type level:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Core account types that enforce double-entry principles</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AccountType</span><span style=\"color:#F97583\"> int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeAsset</span><span style=\"color:#B392F0\"> AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> iota</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeLiability</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeEquity</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeRevenue</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeExpense</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Account structure that supports hierarchical organization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Account</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID          </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">     `json:\"id\" db:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Code        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">     `json:\"code\" db:\"code\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">     `json:\"name\" db:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type        </span><span style=\"color:#B392F0\">AccountType</span><span style=\"color:#9ECBFF\"> `json:\"type\" db:\"type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Currency    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">     `json:\"currency\" db:\"currency\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ParentID    </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"parent_id,omitempty\" db:\"parent_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsActive    </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">       `json:\"is_active\" db:\"is_active\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">  `json:\"created_at\" db:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ModifiedAt  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">  `json:\"modified_at\" db:\"modified_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Money type that prevents floating-point errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Amount   </span><span style=\"color:#B392F0\">decimal</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Decimal</span><span style=\"color:#9ECBFF\"> `json:\"amount\" db:\"amount\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Currency </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">         `json:\"currency\" db:\"currency\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Journal entry that enforces double-entry balance requirements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> JournalEntry</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID          </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"id\" db:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Date        </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">     `json:\"date\" db:\"date\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"description\" db:\"description\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Reference   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"reference\" db:\"reference\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status      </span><span style=\"color:#B392F0\">EntryStatus</span><span style=\"color:#9ECBFF\">   `json:\"status\" db:\"status\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedBy   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"created_by\" db:\"created_by\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PostedAt    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">    `json:\"posted_at,omitempty\" db:\"posted_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Lines       []</span><span style=\"color:#B392F0\">EntryLine</span><span style=\"color:#9ECBFF\">   `json:\"lines\" db:\"-\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">     `json:\"created_at\" db:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"requirements-validation-implementation\">Requirements Validation Implementation</h4>\n<p>Each requirement category needs specific validation code that can be tested independently:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Double-entry validation that enforces fundamental accounting rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">je </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Validate</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Verify entry has at least 2 lines (minimum for double-entry)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate total debits and total credits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify debits equal credits within currency precision tolerance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate all referenced accounts exist and are active</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check that entry date is reasonable (not future, not too old)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Ensure description and reference fields are not empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Validate each line item has either debit or credit (not both)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Balance calculation that supports both current and point-in-time queries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bs </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BalanceService</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CalculateBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">accountID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">asOfDate</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Determine if this is current balance or point-in-time query</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For current balance, check if cached balance is available</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For point-in-time, filter transactions by date</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Sum debits and credits according to account normal balance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Apply account type sign conventions (asset/expense debit normal)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return balance in account's native currency</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Trial balance generation that proves mathematical correctness</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rs </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReportService</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateTrialBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">asOfDate</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">TrialBalance</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get all active accounts with non-zero balances</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate balance for each account as of the specified date</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Separate accounts into debit and credit columns based on normal balance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Sum debit and credit columns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify total debits equal total credits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return structured trial balance report</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"performance-requirements-implementation\">Performance Requirements Implementation</h4>\n<p>Performance requirements drive specific implementation choices for data storage and query patterns:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Running balance cache that provides O(1) balance lookups</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BalanceCache</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement balance caching strategy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Cache current balances for frequently queried accounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Invalidate cache when new entries are posted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Handle cache warming for report generation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Database configuration that supports performance requirements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Host            </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"host\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Port            </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `json:\"port\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    User            </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"user\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Password        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"password\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DBName          </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"database\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SSLMode         </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"ssl_mode\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxConnections  </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `json:\"max_connections\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ConnMaxLifetime </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"connection_max_lifetime\"`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add connection pooling and performance tuning parameters</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-verification-checkpoints\">Milestone Verification Checkpoints</h4>\n<p>After implementing the requirements analysis, verify that the foundation is properly established:</p>\n<p><strong>Functional Requirements Verification:</strong></p>\n<ul>\n<li>Run <code>go test ./internal/accounts/...</code> - all account type validation tests should pass</li>\n<li>Run <code>go test ./internal/entries/...</code> - double-entry balance validation should work</li>\n<li>Create a simple journal entry via API and verify it enforces balance requirements</li>\n<li>Generate a trial balance and confirm it sums to zero</li>\n</ul>\n<p><strong>Non-Functional Requirements Verification:</strong></p>\n<ul>\n<li>Load test with 100 concurrent journal entry creations - should maintain response times</li>\n<li>Create 1000 accounts and verify balance queries remain fast</li>\n<li>Simulate database connection loss and verify proper error handling</li>\n</ul>\n<p><strong>Non-Goals Verification:</strong></p>\n<ul>\n<li>Confirm no UI code exists in the ledger core modules</li>\n<li>Verify no tax calculation logic is included in transaction processing</li>\n<li>Ensure no business workflow logic exists in the accounting engine</li>\n</ul>\n<p><strong>Signs of Implementation Problems:</strong></p>\n<ul>\n<li>Trial balance doesn&#39;t sum to zero → Check double-entry validation logic</li>\n<li>Balance queries are slow → Verify database indexes and caching strategy</li>\n<li>Journal entries can be modified after posting → Check immutability enforcement</li>\n<li>Floating-point rounding errors in money calculations → Verify decimal arithmetic usage</li>\n</ul>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1-5 (All milestones), as this section establishes the foundational architecture that supports account modeling, transaction recording, balance calculation, audit trails, and financial reporting</p>\n</blockquote>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<p>The double-entry ledger system architecture follows a <strong>layered service pattern</strong> where each component has a single, well-defined responsibility that aligns with core accounting principles. Think of this architecture like a traditional accounting firm&#39;s organization: the Chart of Accounts department manages account structure, the Bookkeeping department records transactions, the Reconciliation department maintains balances, the Compliance department tracks all changes, and the Reporting department generates financial statements. Each department has specialized expertise and clear boundaries, but they all work together through established procedures to maintain the integrity of the financial records.</p>\n<p>The system&#39;s architecture prioritizes <strong>data consistency and auditability</strong> over raw performance, reflecting the fundamental requirement that accounting systems must be trustworthy above all else. Every component is designed with the understanding that financial data, once recorded, becomes part of a permanent record that may be subject to regulatory scrutiny years later. This drives architectural decisions toward immutable data structures, comprehensive audit trails, and fail-safe validation mechanisms.</p>\n<p><img src=\"/api/project/ledger-system/architecture-doc/asset?path=diagrams%2Fsystem-components.svg\" alt=\"High-Level System Component Architecture\"></p>\n<h3 id=\"component-responsibilities\">Component Responsibilities</h3>\n<p>The ledger system consists of five core components, each responsible for a specific aspect of double-entry bookkeeping. These components communicate through well-defined interfaces and share a common understanding of the fundamental accounting data model.</p>\n<h4 id=\"account-management-component\">Account Management Component</h4>\n<p>The <strong>Account Management Component</strong> serves as the foundation of the entire system, managing the chart of accounts that defines the structure for all financial recording. Think of this component as the architect of a building&#39;s blueprint - it establishes the framework that all other operations depend upon. This component owns the complete lifecycle of account definitions, from initial creation through hierarchical organization to eventual deactivation.</p>\n<p>The component maintains the <strong>chart of accounts hierarchy</strong>, ensuring that accounts are properly categorized according to standard accounting principles. It enforces business rules around account creation, such as preventing duplicate account codes and validating that parent-child relationships make logical sense within the accounting framework. The component also manages account metadata including currencies, normal balance rules, and activation status.</p>\n<p><strong>Account Management Component Responsibilities:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Data Owned</th>\n<th>Business Rules Enforced</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Account Creation</td>\n<td>Creates new accounts with proper type classification</td>\n<td>Account master records</td>\n<td>Account code uniqueness, valid account types</td>\n</tr>\n<tr>\n<td>Hierarchy Management</td>\n<td>Maintains parent-child account relationships</td>\n<td>Account hierarchy mappings</td>\n<td>Logical parent-child type relationships</td>\n</tr>\n<tr>\n<td>Account Validation</td>\n<td>Validates account configurations and relationships</td>\n<td>Account metadata</td>\n<td>Currency consistency, normal balance rules</td>\n</tr>\n<tr>\n<td>Account Lifecycle</td>\n<td>Manages account activation, deactivation, and archival</td>\n<td>Account status records</td>\n<td>Prevents deletion of accounts with transactions</td>\n</tr>\n</tbody></table>\n<p>The component exposes a clean interface for other system components to query account information, validate account references, and retrieve account hierarchies. It acts as the authoritative source for all account-related data and ensures that the chart of accounts remains consistent and compliant with accounting standards.</p>\n<h4 id=\"transaction-recording-engine\">Transaction Recording Engine</h4>\n<p>The <strong>Transaction Recording Engine</strong> handles the core business logic of double-entry bookkeeping - creating and posting journal entries that maintain the fundamental accounting equation. Think of this engine as a meticulous bookkeeper who never allows an unbalanced entry to be recorded and maintains perfect documentation of every transaction.</p>\n<p>This component orchestrates the complex process of journal entry creation, from initial validation through final posting. It ensures that every journal entry satisfies the double-entry principle where total debits equal total credits before any data is permanently recorded. The engine also manages the posting workflow, transitioning entries from draft status through validation to final posting with appropriate audit trails.</p>\n<p><strong>Transaction Recording Engine Responsibilities:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Data Owned</th>\n<th>Validation Rules</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entry Creation</td>\n<td>Creates journal entries with multiple line items</td>\n<td>Journal entry headers</td>\n<td>All required fields present, valid references</td>\n</tr>\n<tr>\n<td>Double-Entry Validation</td>\n<td>Ensures debits equal credits before posting</td>\n<td>Entry line items</td>\n<td>Mathematical balance, account compatibility</td>\n</tr>\n<tr>\n<td>Atomic Posting</td>\n<td>Posts entries atomically with database transactions</td>\n<td>Posted transaction records</td>\n<td>All-or-nothing posting, referential integrity</td>\n</tr>\n<tr>\n<td>Entry Reversal</td>\n<td>Creates offsetting entries to correct posted transactions</td>\n<td>Reversal entries</td>\n<td>Original entry exists and is posted</td>\n</tr>\n<tr>\n<td>Idempotency Management</td>\n<td>Prevents duplicate entries from repeated operations</td>\n<td>Idempotency keys</td>\n<td>Unique operation identification</td>\n</tr>\n</tbody></table>\n<p>The engine maintains strict boundaries around data modification, ensuring that posted entries become immutable and can only be corrected through explicit reversal entries. It provides comprehensive error reporting when validation failures occur, helping users understand exactly what prevented an entry from being posted.</p>\n<h4 id=\"balance-calculation-engine\">Balance Calculation Engine</h4>\n<p>The <strong>Balance Calculation Engine</strong> maintains real-time account balances and provides efficient balance queries across different time periods. Think of this engine as a financial calculator that instantly knows the balance of every account at any point in time, without having to manually add up all the individual transactions each time someone asks.</p>\n<p>This component solves the fundamental performance challenge in accounting systems: how to quickly answer &quot;what is the balance of account X as of date Y&quot; when there might be millions of transactions to consider. The engine maintains running balances that are incrementally updated as new transactions are posted, while also providing point-in-time balance calculations for historical reporting needs.</p>\n<p><strong>Balance Calculation Engine Responsibilities:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Data Maintained</th>\n<th>Performance Characteristics</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Running Balance Maintenance</td>\n<td>Updates account balances as transactions post</td>\n<td>Current balance cache</td>\n<td>Sub-second balance updates</td>\n</tr>\n<tr>\n<td>Point-in-Time Calculations</td>\n<td>Computes historical balances for any date</td>\n<td>Balance history snapshots</td>\n<td>Optimized date range queries</td>\n</tr>\n<tr>\n<td>Trial Balance Generation</td>\n<td>Validates that all account balances sum to zero</td>\n<td>Cross-account balance summaries</td>\n<td>Complete ledger validation</td>\n</tr>\n<tr>\n<td>Balance Cache Management</td>\n<td>Invalidates and refreshes cached balances</td>\n<td>Balance cache metadata</td>\n<td>Consistency with posted transactions</td>\n</tr>\n</tbody></table>\n<p>The engine handles the complexity of account type sign conventions, ensuring that debit balances are positive for asset and expense accounts while credit balances are positive for liability, equity, and revenue accounts. It provides both current balance queries for operational use and historical balance queries for financial reporting and audit purposes.</p>\n<h4 id=\"audit-trail-system\">Audit Trail System</h4>\n<p>The <strong>Audit Trail System</strong> creates an immutable record of all changes to the ledger, ensuring complete traceability and regulatory compliance. Think of this system as a security camera that records everything happening in the accounting department - not just what transactions were recorded, but who recorded them, when, and what approvals were obtained.</p>\n<p>This component addresses the critical requirement that accounting systems must provide complete audit trails for regulatory compliance and internal controls. It maintains detailed logs of every action taken within the system, from account creation through transaction posting to balance inquiries. The audit system ensures that once information is recorded, it cannot be modified or deleted without leaving a clear trail.</p>\n<p><strong>Audit Trail System Responsibilities:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Audit Data Captured</th>\n<th>Integrity Mechanisms</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Change Logging</td>\n<td>Records all modifications to ledger data</td>\n<td>Before/after values, timestamps, actors</td>\n<td>Cryptographic hash chains</td>\n</tr>\n<tr>\n<td>User Action Tracking</td>\n<td>Logs all user interactions with the system</td>\n<td>User identity, action type, affected records</td>\n<td>Non-repudiation controls</td>\n</tr>\n<tr>\n<td>Immutable Storage</td>\n<td>Prevents modification of historical audit records</td>\n<td>Complete change history</td>\n<td>Write-once storage guarantees</td>\n</tr>\n<tr>\n<td>Compliance Reporting</td>\n<td>Generates audit reports for regulatory requirements</td>\n<td>Audit trails for specified periods</td>\n<td>Tamper-evident export formats</td>\n</tr>\n</tbody></table>\n<p>The system implements cryptographic hash chains to detect any tampering with historical records, ensuring that audit trails can be trusted even in environments where database administrators have broad access privileges. It provides comprehensive audit reports that can be exported for external auditors and regulatory authorities.</p>\n<h4 id=\"financial-reporting-module\">Financial Reporting Module</h4>\n<p>The <strong>Financial Reporting Module</strong> generates standard financial statements and reports that summarize the ledger data for business and regulatory purposes. Think of this module as the publishing department that takes all the detailed transaction records and presents them in standardized formats that business managers, investors, and regulators expect to see.</p>\n<p>This component transforms the detailed transaction-level data maintained by other system components into the summary reports that drive business decision-making. It understands the relationships between different account types and how they should be presented in various financial statements, ensuring that reports comply with standard accounting presentation requirements.</p>\n<p><strong>Financial Reporting Module Responsibilities:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Report Types Generated</th>\n<th>Data Sources</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Trial Balance Reporting</td>\n<td>Lists all account balances to verify ledger balance</td>\n<td>Trial balance with debit/credit columns</td>\n<td>Account balances from Balance Engine</td>\n</tr>\n<tr>\n<td>Balance Sheet Generation</td>\n<td>Shows financial position at a specific date</td>\n<td>Assets, liabilities, equity statement</td>\n<td>Account balances by type</td>\n</tr>\n<tr>\n<td>Income Statement Generation</td>\n<td>Shows profit/loss over a specific period</td>\n<td>Revenue, expenses, net income statement</td>\n<td>Period-based account activity</td>\n</tr>\n<tr>\n<td>Period Closing</td>\n<td>Transfers income/expense balances to retained earnings</td>\n<td>Closing entries and period summaries</td>\n<td>Period-end account balances</td>\n</tr>\n</tbody></table>\n<p>The module handles complex accounting requirements such as multi-currency translation, where foreign currency balances must be converted to the reporting currency using appropriate exchange rates. It also manages the period closing process, which locks completed accounting periods and transfers temporary account balances to permanent accounts.</p>\n<h3 id=\"recommended-module-structure\">Recommended Module Structure</h3>\n<p>The Go implementation organizes code into logical packages that reflect the component responsibilities while maintaining clean separation of concerns. This structure supports independent development and testing of each component while providing clear interfaces for component integration.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ledger-system/\n├── cmd/\n│   └── ledger-server/\n│       └── main.go                    ← Application entry point\n├── internal/\n│   ├── accounts/\n│   │   ├── manager.go                 ← Account Management Component\n│   │   ├── hierarchy.go               ← Account hierarchy logic\n│   │   ├── validation.go              ← Account validation rules\n│   │   └── types.go                   ← Account type definitions\n│   ├── transactions/\n│   │   ├── engine.go                  ← Transaction Recording Engine\n│   │   ├── validation.go              ← Entry validation logic\n│   │   ├── posting.go                 ← Entry posting workflow\n│   │   └── reversal.go                ← Entry reversal mechanism\n│   ├── balances/\n│   │   ├── calculator.go              ← Balance Calculation Engine\n│   │   ├── cache.go                   ← Balance caching logic\n│   │   └── trial_balance.go           ← Trial balance generation\n│   ├── audit/\n│   │   ├── trail.go                   ← Audit Trail System\n│   │   ├── integrity.go               ← Cryptographic integrity\n│   │   └── reporting.go               ← Audit report generation\n│   ├── reporting/\n│   │   ├── generator.go               ← Financial Reporting Module\n│   │   ├── balance_sheet.go           ← Balance sheet logic\n│   │   ├── income_statement.go        ← Income statement logic\n│   │   └── period_closing.go          ← Period closing process\n│   ├── storage/\n│   │   ├── database.go                ← Database connection management\n│   │   ├── transactions.go            ← Database transaction helpers\n│   │   └── migrations/                ← Database schema migrations\n│   └── common/\n│       ├── types.go                   ← Shared type definitions\n│       ├── money.go                   ← Money arithmetic implementation\n│       └── errors.go                  ← Common error definitions\n├── pkg/\n│   └── ledgerapi/\n│       ├── client.go                  ← Public API client\n│       └── types.go                   ← Public API types\n├── api/\n│   ├── handlers/\n│   │   ├── accounts.go                ← Account management endpoints\n│   │   ├── transactions.go            ← Transaction recording endpoints\n│   │   └── reports.go                 ← Report generation endpoints\n│   └── middleware/\n│       ├── auth.go                    ← Authentication middleware\n│       └── audit.go                   ← Request audit logging\n└── docs/\n    ├── api/\n    │   └── openapi.yaml               ← API specification\n    └── accounting/\n        └── chart_of_accounts.md       ← Account structure documentation</code></pre></div>\n\n<p>This structure follows Go best practices by keeping implementation details in the <code>internal/</code> directory while exposing public APIs through the <code>pkg/</code> directory. Each component lives in its own package with clear boundaries and minimal cross-package dependencies.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: The package structure mirrors the component architecture, making it easy for developers to understand where specific functionality should be implemented. Each package focuses on a single concern and exposes interfaces that other packages can depend on without tight coupling.</p>\n</blockquote>\n<h3 id=\"component-dependencies\">Component Dependencies</h3>\n<p>The component dependency structure is carefully designed to prevent circular dependencies while allowing each component to fulfill its responsibilities. The dependencies flow in a clear hierarchy that reflects the natural order of operations in an accounting system.</p>\n<h4 id=\"core-dependency-flow\">Core Dependency Flow</h4>\n<p>The components have a natural dependency hierarchy that reflects the order in which accounting operations must occur. Account definitions must exist before transactions can reference them, transactions must be recorded before balances can be calculated, and all operations must be audited as they occur.</p>\n<p><strong>Component Dependency Hierarchy:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Direct Dependencies</th>\n<th>Indirect Dependencies</th>\n<th>Dependency Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Account Management</td>\n<td>Storage layer only</td>\n<td>None</td>\n<td>Foundation component, no business dependencies</td>\n</tr>\n<tr>\n<td>Transaction Recording</td>\n<td>Account Management, Storage, Audit</td>\n<td>Balance Calculation (async)</td>\n<td>Must validate accounts exist, needs audit trail</td>\n</tr>\n<tr>\n<td>Balance Calculation</td>\n<td>Account Management, Storage</td>\n<td>Transaction Recording (event-driven)</td>\n<td>Needs account definitions, triggered by transactions</td>\n</tr>\n<tr>\n<td>Audit Trail</td>\n<td>Storage layer only</td>\n<td>All other components (observes)</td>\n<td>Infrastructure component, observes all operations</td>\n</tr>\n<tr>\n<td>Financial Reporting</td>\n<td>All other components</td>\n<td>Storage (read-only)</td>\n<td>Consumer component, aggregates all system data</td>\n</tr>\n</tbody></table>\n<h4 id=\"interface-based-communication\">Interface-Based Communication</h4>\n<p>Components communicate through well-defined interfaces rather than direct package dependencies, enabling loose coupling and supporting independent testing and development. Each component exposes its functionality through interfaces that other components can depend on without creating tight coupling to implementation details.</p>\n<p><strong>Account Management Interface:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CreateAccount</code></td>\n<td><code>Account</code></td>\n<td><code>error</code></td>\n<td>Creates new account with validation</td>\n</tr>\n<tr>\n<td><code>GetAccount</code></td>\n<td><code>accountID string</code></td>\n<td><code>Account, error</code></td>\n<td>Retrieves account by ID</td>\n</tr>\n<tr>\n<td><code>GetAccountsByType</code></td>\n<td><code>accountType AccountType</code></td>\n<td><code>[]Account, error</code></td>\n<td>Lists accounts of specified type</td>\n</tr>\n<tr>\n<td><code>ValidateAccountReference</code></td>\n<td><code>accountID string</code></td>\n<td><code>bool, error</code></td>\n<td>Validates account exists and is active</td>\n</tr>\n<tr>\n<td><code>GetAccountHierarchy</code></td>\n<td><code>rootAccountID string</code></td>\n<td><code>[]Account, error</code></td>\n<td>Returns account hierarchy tree</td>\n</tr>\n</tbody></table>\n<p><strong>Transaction Recording Interface:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CreateJournalEntry</code></td>\n<td><code>entry JournalEntry</code></td>\n<td><code>string, error</code></td>\n<td>Creates and validates entry, returns ID</td>\n</tr>\n<tr>\n<td><code>PostJournalEntry</code></td>\n<td><code>entryID string</code></td>\n<td><code>error</code></td>\n<td>Posts validated entry atomically</td>\n</tr>\n<tr>\n<td><code>ReverseJournalEntry</code></td>\n<td><code>entryID, reason string</code></td>\n<td><code>string, error</code></td>\n<td>Creates reversal entry</td>\n</tr>\n<tr>\n<td><code>GetJournalEntry</code></td>\n<td><code>entryID string</code></td>\n<td><code>JournalEntry, error</code></td>\n<td>Retrieves entry with all line items</td>\n</tr>\n<tr>\n<td><code>ValidateEntry</code></td>\n<td><code>entry JournalEntry</code></td>\n<td><code>error</code></td>\n<td>Validates entry without creating</td>\n</tr>\n</tbody></table>\n<p><strong>Balance Calculation Interface:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>GetCurrentBalance</code></td>\n<td><code>accountID string</code></td>\n<td><code>Money, error</code></td>\n<td>Current account balance</td>\n</tr>\n<tr>\n<td><code>GetBalanceAsOfDate</code></td>\n<td><code>accountID string, date time.Time</code></td>\n<td><code>Money, error</code></td>\n<td>Historical balance query</td>\n</tr>\n<tr>\n<td><code>GenerateTrialBalance</code></td>\n<td><code>date time.Time</code></td>\n<td><code>TrialBalance, error</code></td>\n<td>All account balances</td>\n</tr>\n<tr>\n<td><code>RefreshAccountBalance</code></td>\n<td><code>accountID string</code></td>\n<td><code>error</code></td>\n<td>Recalculates cached balance</td>\n</tr>\n<tr>\n<td><code>ValidateTrialBalance</code></td>\n<td><code>date time.Time</code></td>\n<td><code>bool, error</code></td>\n<td>Verifies debits equal credits</td>\n</tr>\n</tbody></table>\n<h4 id=\"event-driven-updates\">Event-Driven Updates</h4>\n<p>Several components use an event-driven pattern to maintain consistency without creating tight coupling. When transactions are posted, the Transaction Recording Engine publishes events that trigger updates in the Balance Calculation Engine and Audit Trail System.</p>\n<blockquote>\n<p><strong>Decision: Event-Driven Balance Updates</strong></p>\n<ul>\n<li><strong>Context</strong>: Balance calculations need to stay synchronized with posted transactions, but we want to avoid tight coupling between the transaction engine and balance calculator</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Synchronous balance updates within transaction posting</li>\n<li>Event-driven asynchronous balance updates</li>\n<li>Periodic batch balance recalculation</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Event-driven asynchronous balance updates with eventual consistency</li>\n<li><strong>Rationale</strong>: Provides loose coupling between components while maintaining reasonable consistency. Failed balance updates can be retried without affecting transaction posting success</li>\n<li><strong>Consequences</strong>: Enables independent scaling and testing of components, but introduces eventual consistency where balances might be briefly stale after transaction posting</li>\n</ul>\n</blockquote>\n<p><strong>Transaction Events Published:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Event Type</th>\n<th>Event Data</th>\n<th>Triggered By</th>\n<th>Consumed By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>EntryPosted</code></td>\n<td><code>JournalEntry</code> with line items</td>\n<td>Transaction Recording</td>\n<td>Balance Calculation, Audit Trail</td>\n</tr>\n<tr>\n<td><code>EntryReversed</code></td>\n<td><code>originalEntryID, reversalEntryID</code></td>\n<td>Transaction Recording</td>\n<td>Balance Calculation, Audit Trail</td>\n</tr>\n<tr>\n<td><code>BalanceUpdated</code></td>\n<td><code>accountID, newBalance, updateTime</code></td>\n<td>Balance Calculation</td>\n<td>Financial Reporting</td>\n</tr>\n<tr>\n<td><code>AccountCreated</code></td>\n<td><code>Account</code> details</td>\n<td>Account Management</td>\n<td>Balance Calculation (cache initialization)</td>\n</tr>\n</tbody></table>\n<h4 id=\"data-flow-patterns\">Data Flow Patterns</h4>\n<p>The system implements several data flow patterns that ensure consistency while maintaining component independence. These patterns handle the reality that accounting operations often require coordination across multiple components.</p>\n<p><strong>Transaction Posting Flow:</strong></p>\n<ol>\n<li><strong>Validation Phase</strong>: Transaction Recording Engine validates entry format and calls Account Management to verify all referenced accounts exist and are active</li>\n<li><strong>Audit Preparation</strong>: Audit Trail System prepares to log the transaction posting operation with full context</li>\n<li><strong>Atomic Posting</strong>: Transaction Recording Engine posts the journal entry within a database transaction, ensuring either complete success or complete rollback</li>\n<li><strong>Event Publication</strong>: After successful posting, events are published to trigger balance updates and audit logging</li>\n<li><strong>Balance Update</strong>: Balance Calculation Engine processes the posted transaction and updates affected account balances</li>\n<li><strong>Audit Completion</strong>: Audit Trail System records the completed transaction with all metadata</li>\n</ol>\n<p><strong>Report Generation Flow:</strong></p>\n<ol>\n<li><strong>Data Collection</strong>: Financial Reporting Module queries Account Management for chart of accounts structure</li>\n<li><strong>Balance Aggregation</strong>: Module requests current or point-in-time balances from Balance Calculation Engine</li>\n<li><strong>Account Classification</strong>: Module groups accounts by type (asset, liability, etc.) according to financial statement requirements</li>\n<li><strong>Report Formatting</strong>: Module formats the aggregated data according to standard financial statement layouts</li>\n<li><strong>Audit Logging</strong>: Audit Trail System logs the report generation request and completion</li>\n</ol>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<h4 id=\"-pitfall-circular-dependencies-between-components\">⚠️ <strong>Pitfall: Circular Dependencies Between Components</strong></h4>\n<p>A common mistake is creating circular dependencies where Component A depends on Component B, which in turn depends on Component A. This often happens when developers try to make the Balance Calculation Engine directly call the Transaction Recording Engine to get transaction details, while the Transaction Recording Engine calls the Balance Calculation Engine to update balances.</p>\n<p><strong>Why it&#39;s wrong</strong>: Circular dependencies make the system impossible to test in isolation and create brittle coupling where changes to one component require changes to multiple other components.</p>\n<p><strong>How to fix</strong>: Use event-driven patterns and interface-based communication. The Transaction Recording Engine publishes events that the Balance Calculation Engine subscribes to, eliminating the circular dependency.</p>\n<h4 id=\"-pitfall-mixing-component-responsibilities\">⚠️ <strong>Pitfall: Mixing Component Responsibilities</strong></h4>\n<p>Developers often put balance calculation logic directly in the Transaction Recording Engine or account validation logic in the Financial Reporting Module, violating the single responsibility principle.</p>\n<p><strong>Why it&#39;s wrong</strong>: Mixed responsibilities make components harder to test, maintain, and scale independently. They also create unexpected dependencies that make the system fragile.</p>\n<p><strong>How to fix</strong>: Clearly define each component&#39;s responsibility and move functionality to the appropriate component. Use dependency injection to provide components with the interfaces they need from other components.</p>\n<h4 id=\"-pitfall-synchronous-cross-component-operations\">⚠️ <strong>Pitfall: Synchronous Cross-Component Operations</strong></h4>\n<p>Implementing all cross-component operations synchronously creates tight coupling and makes the system fragile to failures in any single component.</p>\n<p><strong>Why it&#39;s wrong</strong>: If balance calculation fails, it shouldn&#39;t prevent transaction posting from succeeding. Synchronous operations create cascading failures and make the system harder to scale.</p>\n<p><strong>How to fix</strong>: Use asynchronous event-driven patterns for operations that don&#39;t require immediate consistency. Only use synchronous calls for operations that must complete together, such as account validation during transaction creation.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database</td>\n<td>PostgreSQL with pgx driver</td>\n<td>PostgreSQL with connection pooling and read replicas</td>\n</tr>\n<tr>\n<td>HTTP Framework</td>\n<td>Standard library net/http with gorilla/mux</td>\n<td>gin-gonic/gin with middleware ecosystem</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>YAML files with gopkg.in/yaml.v2</td>\n<td>Viper with environment variable override</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard library log with structured output</td>\n<td>logrus or zap with structured logging</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td>Standard library testing with testify</td>\n<td>ginkgo/gomega for BDD-style tests</td>\n</tr>\n<tr>\n<td>Database Migrations</td>\n<td>Custom migration runner</td>\n<td>golang-migrate/migrate</td>\n</tr>\n<tr>\n<td>Validation</td>\n<td>Custom validation functions</td>\n<td>go-playground/validator</td>\n</tr>\n<tr>\n<td>Documentation</td>\n<td>Godoc with markdown README</td>\n<td>Swagger/OpenAPI with automated generation</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure-implementation\">Recommended File Structure Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/common/types.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> common</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/shopspring/decimal</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Core accounting types used across all components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AccountType</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeAsset</span><span style=\"color:#B392F0\">    AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ASSET\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeLiability</span><span style=\"color:#B392F0\"> AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"LIABILITY\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeEquity</span><span style=\"color:#B392F0\">   AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"EQUITY\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeRevenue</span><span style=\"color:#B392F0\">  AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"REVENUE\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeExpense</span><span style=\"color:#B392F0\">  AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"EXPENSE\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EntryStatus</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EntryStatusDraft</span><span style=\"color:#B392F0\">    EntryStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"DRAFT\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EntryStatusPosted</span><span style=\"color:#B392F0\">   EntryStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"POSTED\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EntryStatusReversed</span><span style=\"color:#B392F0\"> EntryStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"REVERSED\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Account</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID         </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"id\" db:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Code       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"code\" db:\"code\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"name\" db:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type       </span><span style=\"color:#B392F0\">AccountType</span><span style=\"color:#9ECBFF\"> `json:\"type\" db:\"type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Currency   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"currency\" db:\"currency\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ParentID   </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">     `json:\"parent_id\" db:\"parent_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsActive   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">        `json:\"is_active\" db:\"is_active\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">   `json:\"created_at\" db:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ModifiedAt </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">   `json:\"modified_at\" db:\"modified_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Amount   </span><span style=\"color:#B392F0\">decimal</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Decimal</span><span style=\"color:#9ECBFF\"> `json:\"amount\" db:\"amount\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Currency </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"currency\" db:\"currency\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> JournalEntry</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID          </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"id\" db:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Date        </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">   `json:\"date\" db:\"date\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"description\" db:\"description\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Reference   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"reference\" db:\"reference\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status      </span><span style=\"color:#B392F0\">EntryStatus</span><span style=\"color:#9ECBFF\"> `json:\"status\" db:\"status\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedBy   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"created_by\" db:\"created_by\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PostedAt    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">  `json:\"posted_at\" db:\"posted_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Lines       []</span><span style=\"color:#B392F0\">EntryLine</span><span style=\"color:#9ECBFF\"> `json:\"lines\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">   `json:\"created_at\" db:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EntryLine</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID           </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">  `json:\"id\" db:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    JournalID    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">  `json:\"journal_id\" db:\"journal_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AccountID    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">  `json:\"account_id\" db:\"account_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DebitAmount  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#9ECBFF\">  `json:\"debit_amount,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreditAmount </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#9ECBFF\">  `json:\"credit_amount,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">  `json:\"description\" db:\"description\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LineNumber   </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">     `json:\"line_number\" db:\"line_number\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/common/money.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> common</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/shopspring/decimal</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Add combines two Money values of the same currency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">other</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> m.Currency </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.Currency {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">{}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cannot add different currencies: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> and </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            m.Currency, other.Currency)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Amount:   m.Amount.</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(other.Amount),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Currency: m.Currency,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Subtract subtracts other Money value from this one</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Subtract</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">other</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> m.Currency </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.Currency {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">{}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cannot subtract different currencies: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> and </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            m.Currency, other.Currency)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Amount:   m.Amount.</span><span style=\"color:#B392F0\">Sub</span><span style=\"color:#E1E4E8\">(other.Amount),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Currency: m.Currency,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsZero returns true if the amount is zero</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsZero</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> m.Amount.</span><span style=\"color:#B392F0\">IsZero</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsPositive returns true if the amount is greater than zero</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsPositive</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> m.Amount.</span><span style=\"color:#B392F0\">IsPositive</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsNegative returns true if the amount is less than zero</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsNegative</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> m.Amount.</span><span style=\"color:#B392F0\">IsNegative</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/storage/database.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> storage</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/lib/pq</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Host     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"host\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Port     </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">    `yaml:\"port\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    User     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"user\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Password </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"password\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DBName   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"dbname\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SSLMode  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `yaml:\"sslmode\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DB</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    conn </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewDB creates a new database connection with the provided configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewDB</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> DatabaseConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dsn </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"host=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> port=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> user=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> password=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> dbname=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> sslmode=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config.Host, config.Port, config.User, config.Password, config.DBName, config.SSLMode)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    conn, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sql.</span><span style=\"color:#B392F0\">Open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"postgres\"</span><span style=\"color:#E1E4E8\">, dsn)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to open database: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> conn.</span><span style=\"color:#B392F0\">Ping</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to ping database: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">{conn: conn}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WithTransaction executes the provided function within a database transaction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WithTransaction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fn</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Tx</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tx, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.conn.</span><span style=\"color:#B392F0\">Begin</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to begin transaction: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> recover</span><span style=\"color:#E1E4E8\">(); r </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tx.</span><span style=\"color:#B392F0\">Rollback</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            panic</span><span style=\"color:#E1E4E8\">(r)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> fn</span><span style=\"color:#E1E4E8\">(tx); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> rollbackErr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tx.</span><span style=\"color:#B392F0\">Rollback</span><span style=\"color:#E1E4E8\">(); rollbackErr </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"transaction error: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">, rollback error: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err, rollbackErr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tx.</span><span style=\"color:#B392F0\">Commit</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to commit transaction: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Close closes the database connection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> db.conn.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-component-interface-skeletons\">Core Component Interface Skeletons</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/accounts/manager.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> accounts</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">ledger-system/internal/common</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Manager handles all account-related operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Manager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#B392F0\">Storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Storage</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CreateAccount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">account</span><span style=\"color:#B392F0\"> common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetAccount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetAccountsByType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountType</span><span style=\"color:#B392F0\"> common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AccountType</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    UpdateAccount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">account</span><span style=\"color:#B392F0\"> common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Add other storage methods needed for account management</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateAccount creates a new account with validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Manager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateAccount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">account</span><span style=\"color:#B392F0\"> common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Generate unique account ID if not provided</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate account code is unique within the organization</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate account type is one of the valid AccountType constants</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate currency code is valid (e.g., ISO 4217)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If ParentID is provided, validate parent account exists and is compatible type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Set creation timestamps</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Store account in database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Return generated account ID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NormalBalance returns the normal balance type for the account</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">a </span><span style=\"color:#B392F0\">common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">NormalBalance</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Return \"DEBIT\" for AccountTypeAsset and AccountTypeExpense</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Return \"CREDIT\" for AccountTypeLiability, AccountTypeEquity, and AccountTypeRevenue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsDebitNormal returns true if this account type normally has debit balances</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">a </span><span style=\"color:#B392F0\">common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsDebitNormal</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Return true for asset and expense accounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Return false for liability, equity, and revenue accounts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/transactions/engine.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> transactions</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">ledger-system/internal/common</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Engine handles journal entry creation and posting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Engine</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db           </span><span style=\"color:#B392F0\">Storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    accountMgr   </span><span style=\"color:#B392F0\">AccountManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    eventPub     </span><span style=\"color:#B392F0\">EventPublisher</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AccountManager</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ValidateAccountReference</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetAccount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EventPublisher</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    PublishEntryPosted</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#B392F0\"> common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    PublishEntryReversed</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">originalID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reversalID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateJournalEntry creates and validates a new journal entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateJournalEntry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#B392F0\"> common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Generate unique entry ID if not provided</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate all referenced accounts exist and are active</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate that entry has at least 2 line items</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Call Validate() method to ensure debits equal credits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Set entry status to EntryStatusDraft</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Store entry and all line items in database transaction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return generated entry ID</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Validate ensures the journal entry follows double-entry rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#B392F0\">common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Validate</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check that entry has at least 2 line items</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify that each line has either DebitAmount OR CreditAmount (not both, not neither)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate total debits using TotalDebits() method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Calculate total credits using TotalCredits() method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify total debits equals total credits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Check all amounts are positive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Validate all line items have same currency or handle multi-currency rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TotalDebits sums all debit amounts in the journal entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#B392F0\">common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TotalDebits</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize total Money with zero amount and first currency found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Iterate through all Lines in the journal entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each line with DebitAmount, add to running total using Money.Add()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle currency conversion if multiple currencies present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return final total</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TotalCredits sums all credit amounts in the journal entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#B392F0\">common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TotalCredits</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize total Money with zero amount and first currency found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Iterate through all Lines in the journal entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each line with CreditAmount, add to running total using Money.Add()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle currency conversion if multiple currencies present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return final total</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> common</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"language-specific-implementation-hints\">Language-Specific Implementation Hints</h4>\n<p><strong>Database Transactions in Go:</strong></p>\n<ul>\n<li>Use <code>sql.Tx</code> for database transactions with proper rollback handling</li>\n<li>Always defer rollback with panic recovery to handle unexpected errors</li>\n<li>Use context.Context for cancellation and timeout handling</li>\n<li>Implement retry logic for transient database errors</li>\n</ul>\n<p><strong>Decimal Arithmetic:</strong></p>\n<ul>\n<li>Use <code>github.com/shopspring/decimal</code> package to avoid floating-point precision errors</li>\n<li>Store decimal values as strings in the database with proper precision</li>\n<li>Always validate decimal input before performing calculations</li>\n<li>Use decimal.NewFromString() for parsing user input safely</li>\n</ul>\n<p><strong>Error Handling Patterns:</strong></p>\n<ul>\n<li>Wrap errors with context using <code>fmt.Errorf(&quot;operation failed: %w&quot;, err)</code></li>\n<li>Create custom error types for business rule violations</li>\n<li>Use sentinel errors for expected error conditions</li>\n<li>Log errors at the boundary where they&#39;re handled, not where they&#39;re generated</li>\n</ul>\n<p><strong>Concurrency Considerations:</strong></p>\n<ul>\n<li>Use database transactions for atomic operations across multiple tables</li>\n<li>Implement optimistic locking for concurrent balance updates</li>\n<li>Use channels for event publishing to avoid blocking transaction posting</li>\n<li>Consider using sync.RWMutex for read-heavy cached data</li>\n</ul>\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After implementing basic component structure:</strong></p>\n<ul>\n<li>Run <code>go build ./...</code> - should compile without errors</li>\n<li>Run <code>go test ./...</code> - should pass basic interface tests</li>\n<li>Verify that each component can be imported independently</li>\n<li>Check that circular dependencies are avoided using <code>go mod graph</code></li>\n</ul>\n<p><strong>After implementing core interfaces:</strong></p>\n<ul>\n<li>Create simple test that instantiates each component</li>\n<li>Verify that components can communicate through interfaces</li>\n<li>Test that dependency injection works correctly</li>\n<li>Run integration test creating an account and validating it</li>\n</ul>\n<p><strong>Integration verification:</strong></p>\n<ul>\n<li>Post a simple journal entry through the Transaction Recording Engine</li>\n<li>Verify that Account Management validates the referenced accounts</li>\n<li>Check that Balance Calculation Engine receives the posting event</li>\n<li>Confirm that Audit Trail System logs the complete operation</li>\n</ul>\n<p><strong>Performance baseline:</strong></p>\n<ul>\n<li>Measure time to post 1000 journal entries sequentially</li>\n<li>Test balance calculation performance with 10,000 transactions</li>\n<li>Verify that trial balance generation completes in under 5 seconds</li>\n<li>Check memory usage doesn&#39;t grow unbounded during batch operations</li>\n</ul>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1 (Account &amp; Entry Model), 2 (Transaction Recording), 4 (Audit Trail), as this section establishes the core database schema and data structures that support account hierarchies, double-entry transactions, monetary handling, and immutable audit logging</p>\n</blockquote>\n<p>The data model forms the foundation of our double-entry ledger system, defining how financial information is stored, related, and maintained. Think of the data model as the blueprint for a bank vault — it must be precisely engineered to ensure every dollar is accounted for, every transaction is traceable, and the integrity of financial records is absolutely guaranteed.</p>\n<h3 id=\"chart-of-accounts-structure\">Chart of Accounts Structure</h3>\n<p>The chart of accounts serves as the organizational backbone of any accounting system, much like how a library&#39;s cataloging system organizes books into categories that make them easy to find and understand. Each account represents a specific financial classification where monetary amounts can be recorded, whether that&#39;s cash in a checking account, amounts owed to suppliers, or revenue from customer sales.</p>\n<p>Our account structure follows the fundamental accounting equation: <strong>Assets = Liabilities + Equity</strong>, with the addition of Revenue and Expense accounts that ultimately flow into Equity through the closing process. This creates five primary account types that serve different purposes in tracking an organization&#39;s financial position and performance.</p>\n<p><img src=\"/api/project/ledger-system/architecture-doc/asset?path=diagrams%2Faccount-hierarchy.svg\" alt=\"Chart of Accounts Hierarchy Structure\"></p>\n<p>The <code>Account</code> entity serves as the fundamental building block of our chart of accounts. Each account contains identification information, categorization details, and hierarchical relationships that enable sophisticated financial reporting and analysis.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ID</td>\n<td>string</td>\n<td>Universally unique identifier for the account, typically a UUID</td>\n</tr>\n<tr>\n<td>Code</td>\n<td>string</td>\n<td>Human-readable account code following organizational numbering scheme</td>\n</tr>\n<tr>\n<td>Name</td>\n<td>string</td>\n<td>Descriptive name for the account (e.g., &quot;Accounts Receivable&quot;, &quot;Office Supplies&quot;)</td>\n</tr>\n<tr>\n<td>Type</td>\n<td>AccountType</td>\n<td>Classification as ASSET, LIABILITY, EQUITY, REVENUE, or EXPENSE</td>\n</tr>\n<tr>\n<td>Currency</td>\n<td>string</td>\n<td>ISO 4217 currency code for multi-currency support (e.g., &quot;USD&quot;, &quot;EUR&quot;)</td>\n</tr>\n<tr>\n<td>ParentID</td>\n<td>*string</td>\n<td>Optional reference to parent account for hierarchical organization</td>\n</tr>\n<tr>\n<td>IsActive</td>\n<td>bool</td>\n<td>Flag indicating whether the account accepts new transactions</td>\n</tr>\n<tr>\n<td>CreatedAt</td>\n<td>time.Time</td>\n<td>Timestamp when the account was initially created</td>\n</tr>\n<tr>\n<td>ModifiedAt</td>\n<td>time.Time</td>\n<td>Timestamp of the most recent account modification</td>\n</tr>\n</tbody></table>\n<p>The <code>AccountType</code> enumeration defines the five fundamental categories that determine how accounts behave in double-entry bookkeeping. Each account type has a <strong>normal balance</strong> that indicates whether increases to that account are recorded as debits or credits.</p>\n<table>\n<thead>\n<tr>\n<th>Account Type</th>\n<th>Normal Balance</th>\n<th>Increases With</th>\n<th>Common Examples</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ASSET</td>\n<td>Debit</td>\n<td>Debits</td>\n<td>Cash, Accounts Receivable, Equipment, Inventory</td>\n</tr>\n<tr>\n<td>LIABILITY</td>\n<td>Credit</td>\n<td>Credits</td>\n<td>Accounts Payable, Notes Payable, Accrued Expenses</td>\n</tr>\n<tr>\n<td>EQUITY</td>\n<td>Credit</td>\n<td>Credits</td>\n<td>Common Stock, Retained Earnings, Owner&#39;s Equity</td>\n</tr>\n<tr>\n<td>REVENUE</td>\n<td>Credit</td>\n<td>Credits</td>\n<td>Sales Revenue, Service Revenue, Interest Income</td>\n</tr>\n<tr>\n<td>EXPENSE</td>\n<td>Debit</td>\n<td>Debits</td>\n<td>Salary Expense, Rent Expense, Office Supplies</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Hierarchical Account Structure with Parent-Child Relationships</strong></p>\n<ul>\n<li><strong>Context</strong>: Organizations need to organize accounts into logical groups for reporting purposes. For example, &quot;Cash&quot; might have sub-accounts for &quot;Checking Account&quot; and &quot;Petty Cash&quot;.</li>\n<li><strong>Options Considered</strong>: Flat account structure with categories, hierarchical parent-child relationships, or tag-based classification system</li>\n<li><strong>Decision</strong>: Implement parent-child relationships with unlimited nesting depth using ParentID foreign key</li>\n<li><strong>Rationale</strong>: Hierarchical structure matches how accountants naturally think about account organization and enables drill-down reporting from summary to detail levels. Parent-child relationships are simple to implement and query efficiently.</li>\n<li><strong>Consequences</strong>: Enables sophisticated reporting at multiple levels of detail, but requires careful validation to prevent circular references and orphaned accounts.</li>\n</ul>\n</blockquote>\n<p>The account coding scheme provides a systematic way to organize and identify accounts within the chart of accounts. Most organizations use a numbering system where the first digit indicates the account type: 1xxx for Assets, 2xxx for Liabilities, 3xxx for Equity, 4xxx for Revenue, and 5xxx for Expenses. This creates an intuitive mapping between account codes and their financial statement presentation.</p>\n<p><strong>Account Hierarchy Design Principles:</strong></p>\n<ol>\n<li><strong>Consistent Numbering</strong>: All accounts at the same level should follow consistent numbering patterns to maintain logical organization</li>\n<li><strong>Room for Growth</strong>: Leave gaps in numbering sequences to accommodate future account additions without disrupting the existing structure</li>\n<li><strong>Meaningful Names</strong>: Account names should be descriptive enough to understand their purpose without requiring additional documentation</li>\n<li><strong>Type Inheritance</strong>: Child accounts must always be the same type as their parent account to maintain financial statement integrity</li>\n</ol>\n<h3 id=\"journal-entry-schema\">Journal Entry Schema</h3>\n<p>Journal entries represent the core mechanism for recording financial transactions in our double-entry system. Think of a journal entry as a complete story about a business transaction — it captures not just the monetary amounts, but the context, timing, and authorization details that make the transaction meaningful and auditable.</p>\n<p><img src=\"/api/project/ledger-system/architecture-doc/asset?path=diagrams%2Fdata-model-relationships.svg\" alt=\"Core Data Model Entity Relationships\"></p>\n<p>Each journal entry consists of a header record containing metadata about the transaction, and multiple line items that specify which accounts are affected and by how much. This separation allows us to capture both the overall transaction context and the detailed account-level impacts in a normalized, efficient structure.</p>\n<p>The <code>JournalEntry</code> entity serves as the transaction header, containing information that applies to the entire transaction regardless of how many accounts are involved.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ID</td>\n<td>string</td>\n<td>Unique identifier for this journal entry, typically a UUID</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>time.Time</td>\n<td>Business date when the transaction occurred (not necessarily when recorded)</td>\n</tr>\n<tr>\n<td>Description</td>\n<td>string</td>\n<td>Human-readable explanation of the transaction purpose</td>\n</tr>\n<tr>\n<td>Reference</td>\n<td>string</td>\n<td>External reference number (invoice, check number, etc.) for audit trail</td>\n</tr>\n<tr>\n<td>Status</td>\n<td>EntryStatus</td>\n<td>Current state of the entry (DRAFT, POSTED, REVERSED)</td>\n</tr>\n<tr>\n<td>CreatedBy</td>\n<td>string</td>\n<td>User ID of the person who created this journal entry</td>\n</tr>\n<tr>\n<td>PostedAt</td>\n<td>*time.Time</td>\n<td>Timestamp when entry was officially posted to the ledger</td>\n</tr>\n<tr>\n<td>Lines</td>\n<td>[]EntryLine</td>\n<td>Collection of account line items that comprise this transaction</td>\n</tr>\n<tr>\n<td>CreatedAt</td>\n<td>time.Time</td>\n<td>System timestamp when the entry record was created</td>\n</tr>\n</tbody></table>\n<p>The <code>EntryStatus</code> enumeration tracks the lifecycle of journal entries through their various states from creation to final posting:</p>\n<table>\n<thead>\n<tr>\n<th>Status</th>\n<th>Description</th>\n<th>Allowed Transitions</th>\n<th>Validation Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DRAFT</td>\n<td>Entry is being created/edited</td>\n<td>→ POSTED</td>\n<td>Lines may be unbalanced, all fields editable</td>\n</tr>\n<tr>\n<td>POSTED</td>\n<td>Entry is permanently recorded</td>\n<td>→ REVERSED</td>\n<td>Must be balanced, immutable except for status changes</td>\n</tr>\n<tr>\n<td>REVERSED</td>\n<td>Entry has been canceled by offsetting entry</td>\n<td>None</td>\n<td>Original entry preserved, reversal entry created separately</td>\n</tr>\n</tbody></table>\n<p>Individual line items within a journal entry are represented by the <code>EntryLine</code> entity, which creates the actual double-entry bookkeeping records by specifying which accounts are debited or credited:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ID</td>\n<td>string</td>\n<td>Unique identifier for this specific line item</td>\n</tr>\n<tr>\n<td>JournalID</td>\n<td>string</td>\n<td>Foreign key reference to the parent journal entry</td>\n</tr>\n<tr>\n<td>AccountID</td>\n<td>string</td>\n<td>Foreign key reference to the account being affected</td>\n</tr>\n<tr>\n<td>DebitAmount</td>\n<td>*Money</td>\n<td>Amount to debit to this account (null if this is a credit line)</td>\n</tr>\n<tr>\n<td>CreditAmount</td>\n<td>*Money</td>\n<td>Amount to credit to this account (null if this is a debit line)</td>\n</tr>\n<tr>\n<td>Description</td>\n<td>string</td>\n<td>Line-specific description (often same as journal entry description)</td>\n</tr>\n<tr>\n<td>LineNumber</td>\n<td>int</td>\n<td>Sequence number for maintaining line item order</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Separate Debit and Credit Amount Fields</strong></p>\n<ul>\n<li><strong>Context</strong>: Each line item needs to record either a debit or credit amount, but never both simultaneously</li>\n<li><strong>Options Considered</strong>: Single amount field with separate debit/credit indicator, separate nullable debit/credit fields, or signed amount where positive=debit and negative=credit</li>\n<li><strong>Decision</strong>: Use separate nullable <code>DebitAmount</code> and <code>CreditAmount</code> fields where exactly one is populated per line</li>\n<li><strong>Rationale</strong>: This approach makes the double-entry nature explicit in the data structure and prevents logical errors where both fields might be populated. Queries for debits vs credits become simple null checks.</li>\n<li><strong>Consequences</strong>: Slightly more complex validation logic to ensure exactly one field is populated, but much clearer semantic meaning and easier financial reporting.</li>\n</ul>\n</blockquote>\n<p><strong>Journal Entry Validation Rules:</strong></p>\n<p>The system enforces several critical validation rules that maintain the integrity of double-entry bookkeeping:</p>\n<ol>\n<li><strong>Balance Requirement</strong>: The sum of all debit amounts must exactly equal the sum of all credit amounts within a single journal entry</li>\n<li><strong>Account Existence</strong>: Every referenced AccountID must exist and be active at the time of entry creation</li>\n<li><strong>Currency Consistency</strong>: All line items within a single journal entry must use the same currency, or proper exchange rate conversion must be applied</li>\n<li><strong>Line Item Completeness</strong>: Each line item must have exactly one of DebitAmount or CreditAmount populated, never both or neither</li>\n<li><strong>Minimum Lines</strong>: Each journal entry must contain at least two line items (since every transaction affects at least two accounts)</li>\n</ol>\n<h3 id=\"monetary-amount-handling\">Monetary Amount Handling</h3>\n<p>Financial calculations demand absolute precision — a discrepancy of even one cent can cause hours of reconciliation work and regulatory compliance issues. Think of monetary amounts like precision instruments in a laboratory: you need exactly the right tools to measure accurately, and any approximation or rounding error can invalidate your entire experiment.</p>\n<p>Traditional floating-point arithmetic is fundamentally unsuitable for financial calculations because decimal fractions cannot be represented exactly in binary floating-point formats. For example, the simple calculation <code>0.1 + 0.2</code> produces <code>0.30000000000000004</code> in most programming languages, which is unacceptable when dealing with money.</p>\n<blockquote>\n<p><strong>Decision: Fixed-Point Decimal Arithmetic with Currency Awareness</strong></p>\n<ul>\n<li><strong>Context</strong>: Financial calculations require exact decimal arithmetic without floating-point rounding errors, and multi-currency support demands currency-aware operations</li>\n<li><strong>Options Considered</strong>: Store cents as integers, use floating-point with rounding, implement fixed-point decimal library, or delegate to database decimal types</li>\n<li><strong>Decision</strong>: Implement a <code>Money</code> type using fixed-point decimal arithmetic with explicit currency codes</li>\n<li><strong>Rationale</strong>: Fixed-point decimals eliminate rounding errors entirely, while currency-aware types prevent accidental cross-currency arithmetic. This approach provides both mathematical precision and logical safety.</li>\n<li><strong>Consequences</strong>: Slightly more complex arithmetic operations, but guaranteed precision and protection against currency mismatch errors that could corrupt financial data.</li>\n</ul>\n</blockquote>\n<p>The <code>Money</code> type encapsulates both a precise decimal amount and its associated currency, ensuring that all monetary calculations maintain both mathematical accuracy and logical consistency:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Amount</td>\n<td>decimal.Decimal</td>\n<td>Fixed-point decimal representing the monetary amount</td>\n</tr>\n<tr>\n<td>Currency</td>\n<td>string</td>\n<td>ISO 4217 currency code (e.g., &quot;USD&quot;, &quot;EUR&quot;, &quot;GBP&quot;)</td>\n</tr>\n</tbody></table>\n<p><strong>Key Monetary Operations:</strong></p>\n<p>The <code>Money</code> type supports essential arithmetic operations while enforcing currency compatibility:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Add</td>\n<td>other Money</td>\n<td>Money, error</td>\n<td>Adds two amounts of the same currency, returns error for currency mismatch</td>\n</tr>\n<tr>\n<td>Subtract</td>\n<td>other Money</td>\n<td>Money, error</td>\n<td>Subtracts two amounts of the same currency, returns error for currency mismatch</td>\n</tr>\n<tr>\n<td>Multiply</td>\n<td>decimal.Decimal</td>\n<td>Money</td>\n<td>Multiplies the amount by a scalar (for calculations like tax rates)</td>\n</tr>\n<tr>\n<td>Divide</td>\n<td>decimal.Decimal</td>\n<td>Money, error</td>\n<td>Divides the amount by a scalar, returns error for division by zero</td>\n</tr>\n<tr>\n<td>Negate</td>\n<td>none</td>\n<td>Money</td>\n<td>Returns the negative of this amount (useful for reversals)</td>\n</tr>\n<tr>\n<td>IsZero</td>\n<td>none</td>\n<td>bool</td>\n<td>Returns true if the amount is exactly zero</td>\n</tr>\n<tr>\n<td>Compare</td>\n<td>other Money</td>\n<td>int, error</td>\n<td>Returns -1, 0, or 1 for less than, equal, or greater than comparison</td>\n</tr>\n</tbody></table>\n<p><strong>Currency Handling Principles:</strong></p>\n<ol>\n<li><strong>Explicit Currency Assignment</strong>: Every monetary amount must have an explicitly assigned currency — no default assumptions</li>\n<li><strong>Currency Validation</strong>: All currency codes must conform to ISO 4217 standards and be validated against a known currency registry</li>\n<li><strong>Cross-Currency Prevention</strong>: Arithmetic operations between different currencies are explicitly forbidden and return errors</li>\n<li><strong>Exchange Rate Separation</strong>: Currency conversion is handled separately from basic arithmetic to maintain audit trails</li>\n<li><strong>Precision Consistency</strong>: All amounts within the same currency use consistent decimal precision (typically 2 decimal places for most currencies)</li>\n</ol>\n<p><strong>Storage Format Considerations:</strong></p>\n<p>When persisting monetary amounts to the database, we store the decimal amount as a string representation to maintain exact precision across all database systems. This avoids potential precision loss that could occur with native database decimal types that might have different precision limits or rounding behaviors.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">markdown</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">Storage Example:</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">-</span><span style=\"color:#E1E4E8\"> Amount: 123.45 USD</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">-</span><span style=\"color:#E1E4E8\"> Database storage: amount_str = \"123.45\", currency = \"USD\"</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">-</span><span style=\"color:#E1E4E8\"> Never store as: amount_float = 123.45000000000001</span></span></code></pre></div>\n\n<h3 id=\"audit-trail-schema\">Audit Trail Schema</h3>\n<p>The audit trail serves as the immutable memory of our accounting system — every change, every transaction, and every modification is permanently recorded in a way that cannot be altered or deleted. Think of the audit trail as a blockchain for accounting: each record is cryptographically linked to the previous one, creating a tamper-evident chain that provides absolute confidence in the integrity of financial data.</p>\n<p>Regulatory compliance and financial integrity require that we maintain complete records of not just what the current state of accounts is, but how that state was reached through a series of transactions and modifications. This creates accountability, enables forensic analysis, and provides the documentation necessary for external audits.</p>\n<blockquote>\n<p><strong>Decision: Immutable Append-Only Audit Log with Cryptographic Integrity</strong></p>\n<ul>\n<li><strong>Context</strong>: Regulatory requirements demand complete, unalterable records of all financial transactions and system changes for audit purposes and fraud detection</li>\n<li><strong>Options Considered</strong>: Mutable audit tables with soft deletes, immutable append-only logs, or external audit service integration</li>\n<li><strong>Decision</strong>: Implement append-only audit tables with cryptographic hash chains to detect tampering</li>\n<li><strong>Rationale</strong>: Append-only design prevents data corruption or manipulation, while hash chains provide mathematical proof of data integrity. This approach satisfies regulatory requirements while being implementable within our system.</li>\n<li><strong>Consequences</strong>: Storage grows continuously and requires archival strategy, but provides absolute confidence in audit trail integrity and regulatory compliance.</li>\n</ul>\n</blockquote>\n<p>The audit trail consists of multiple interconnected tables that capture different aspects of system activity:</p>\n<p><strong>AuditEvent Schema:</strong></p>\n<p>The <code>AuditEvent</code> table serves as the primary audit log, recording every significant action that occurs within the system:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ID</td>\n<td>string</td>\n<td>Unique identifier for this audit event</td>\n</tr>\n<tr>\n<td>Timestamp</td>\n<td>time.Time</td>\n<td>Exact time when the event occurred (stored in UTC)</td>\n</tr>\n<tr>\n<td>EventType</td>\n<td>string</td>\n<td>Classification of the event (ACCOUNT_CREATED, ENTRY_POSTED, etc.)</td>\n</tr>\n<tr>\n<td>ActorID</td>\n<td>string</td>\n<td>User ID of the person or system that triggered this event</td>\n</tr>\n<tr>\n<td>ActorType</td>\n<td>string</td>\n<td>Type of actor (USER, SYSTEM, API_CLIENT) for different authorization contexts</td>\n</tr>\n<tr>\n<td>EntityType</td>\n<td>string</td>\n<td>Type of entity being modified (ACCOUNT, JOURNAL_ENTRY, etc.)</td>\n</tr>\n<tr>\n<td>EntityID</td>\n<td>string</td>\n<td>Unique identifier of the specific entity that was modified</td>\n</tr>\n<tr>\n<td>Action</td>\n<td>string</td>\n<td>Specific action performed (CREATE, UPDATE, DELETE, POST, REVERSE)</td>\n</tr>\n<tr>\n<td>BeforeState</td>\n<td>*string</td>\n<td>JSON representation of entity state before modification</td>\n</tr>\n<tr>\n<td>AfterState</td>\n<td>*string</td>\n<td>JSON representation of entity state after modification</td>\n</tr>\n<tr>\n<td>ChangeDescription</td>\n<td>string</td>\n<td>Human-readable description of what changed</td>\n</tr>\n<tr>\n<td>SessionID</td>\n<td>string</td>\n<td>Session identifier for grouping related activities</td>\n</tr>\n<tr>\n<td>IPAddress</td>\n<td>string</td>\n<td>Source IP address for security auditing</td>\n</tr>\n<tr>\n<td>UserAgent</td>\n<td>string</td>\n<td>Browser/client information for security analysis</td>\n</tr>\n<tr>\n<td>PreviousHash</td>\n<td>*string</td>\n<td>Cryptographic hash of the previous audit event for chain integrity</td>\n</tr>\n<tr>\n<td>CurrentHash</td>\n<td>string</td>\n<td>Cryptographic hash of this audit event for tamper detection</td>\n</tr>\n</tbody></table>\n<p><strong>EntryAuditLog Schema:</strong></p>\n<p>The <code>EntryAuditLog</code> table provides specialized audit tracking for journal entries, capturing the complete lifecycle from draft creation through posting and potential reversal:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ID</td>\n<td>string</td>\n<td>Unique identifier for this entry audit record</td>\n</tr>\n<tr>\n<td>JournalEntryID</td>\n<td>string</td>\n<td>Foreign key to the journal entry being audited</td>\n</tr>\n<tr>\n<td>Timestamp</td>\n<td>time.Time</td>\n<td>When this audit event occurred</td>\n</tr>\n<tr>\n<td>Action</td>\n<td>string</td>\n<td>Specific action (CREATED, MODIFIED, POSTED, REVERSED)</td>\n</tr>\n<tr>\n<td>ActorID</td>\n<td>string</td>\n<td>User who performed this action</td>\n</tr>\n<tr>\n<td>PreviousStatus</td>\n<td>*EntryStatus</td>\n<td>Entry status before this action</td>\n</tr>\n<tr>\n<td>NewStatus</td>\n<td>EntryStatus</td>\n<td>Entry status after this action</td>\n</tr>\n<tr>\n<td>FieldsChanged</td>\n<td>[]string</td>\n<td>List of field names that were modified</td>\n</tr>\n<tr>\n<td>Reason</td>\n<td>string</td>\n<td>Business justification for the change</td>\n</tr>\n<tr>\n<td>ApprovalRequired</td>\n<td>bool</td>\n<td>Whether this action required supervisor approval</td>\n</tr>\n<tr>\n<td>ApproverID</td>\n<td>*string</td>\n<td>User ID of approving supervisor if applicable</td>\n</tr>\n<tr>\n<td>ValidatedAt</td>\n<td>*time.Time</td>\n<td>When validation checks were performed</td>\n</tr>\n<tr>\n<td>ValidationResults</td>\n<td>string</td>\n<td>JSON of validation check results</td>\n</tr>\n</tbody></table>\n<p><strong>AccountBalanceSnapshot Schema:</strong></p>\n<p>The <code>AccountBalanceSnapshot</code> table maintains point-in-time balance records that serve both performance optimization and audit verification purposes:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ID</td>\n<td>string</td>\n<td>Unique identifier for this balance snapshot</td>\n</tr>\n<tr>\n<td>AccountID</td>\n<td>string</td>\n<td>Foreign key to the account</td>\n</tr>\n<tr>\n<td>SnapshotDate</td>\n<td>time.Time</td>\n<td>The date for which this balance is calculated</td>\n</tr>\n<tr>\n<td>DebitBalance</td>\n<td>Money</td>\n<td>Total debit balance as of the snapshot date</td>\n</tr>\n<tr>\n<td>CreditBalance</td>\n<td>Money</td>\n<td>Total credit balance as of the snapshot date</td>\n</tr>\n<tr>\n<td>NetBalance</td>\n<td>Money</td>\n<td>Net balance considering account type normal balance</td>\n</tr>\n<tr>\n<td>EntryCount</td>\n<td>int</td>\n<td>Number of journal entry lines included in this balance</td>\n</tr>\n<tr>\n<td>LastEntryID</td>\n<td>string</td>\n<td>ID of the most recent journal entry included</td>\n</tr>\n<tr>\n<td>SnapshotReason</td>\n<td>string</td>\n<td>Why this snapshot was created (DAILY_CLOSE, MONTH_END, etc.)</td>\n</tr>\n<tr>\n<td>CreatedAt</td>\n<td>time.Time</td>\n<td>When this snapshot was generated</td>\n</tr>\n<tr>\n<td>VerifiedAt</td>\n<td>*time.Time</td>\n<td>When this balance was independently verified</td>\n</tr>\n<tr>\n<td>VerificationHash</td>\n<td>string</td>\n<td>Cryptographic hash of all entries contributing to this balance</td>\n</tr>\n</tbody></table>\n<p><strong>Cryptographic Integrity Implementation:</strong></p>\n<p>The audit trail implements a hash chain mechanism where each audit event includes a cryptographic hash of the previous event, creating a tamper-evident sequence. This design makes it mathematically impossible to modify historical records without detection:</p>\n<ol>\n<li><strong>Hash Calculation</strong>: Each audit event&#39;s hash is computed from its complete content plus the hash of the previous event</li>\n<li><strong>Chain Validation</strong>: The system can verify the entire audit chain by recalculating hashes and comparing them to stored values</li>\n<li><strong>Tamper Detection</strong>: Any modification to historical records will cause hash validation to fail at the point of tampering and all subsequent records</li>\n<li><strong>Integrity Reports</strong>: Regular integrity checks can be automated to detect corruption or unauthorized modifications</li>\n</ol>\n<p><strong>Audit Event Categories:</strong></p>\n<p>The system tracks several categories of events that require audit logging:</p>\n<table>\n<thead>\n<tr>\n<th>Event Category</th>\n<th>Typical Events</th>\n<th>Retention Period</th>\n<th>Regulatory Requirement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Account Management</td>\n<td>CREATE_ACCOUNT, MODIFY_ACCOUNT, DEACTIVATE_ACCOUNT</td>\n<td>Permanent</td>\n<td>Chart of accounts changes</td>\n</tr>\n<tr>\n<td>Transaction Recording</td>\n<td>CREATE_ENTRY, POST_ENTRY, REVERSE_ENTRY</td>\n<td>Permanent</td>\n<td>All financial transactions</td>\n</tr>\n<tr>\n<td>Balance Calculations</td>\n<td>BALANCE_CALCULATED, BALANCE_VERIFIED</td>\n<td>7 years</td>\n<td>Balance verification records</td>\n</tr>\n<tr>\n<td>User Actions</td>\n<td>LOGIN, LOGOUT, PERMISSION_CHANGE</td>\n<td>3 years</td>\n<td>Access control compliance</td>\n</tr>\n<tr>\n<td>System Events</td>\n<td>BACKUP_CREATED, SYSTEM_RESTART</td>\n<td>1 year</td>\n<td>Operational audit trail</td>\n</tr>\n<tr>\n<td>Data Corrections</td>\n<td>ERROR_CORRECTION, MANUAL_ADJUSTMENT</td>\n<td>Permanent</td>\n<td>Correction documentation</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Using Floating-Point Arithmetic for Monetary Calculations</strong>\nMany developers instinctively use <code>float64</code> or similar floating-point types for money, which leads to precision errors that compound over time. For example, calculating <code>0.1 + 0.2</code> in floating-point arithmetic doesn&#39;t equal <code>0.3</code> exactly. In a financial system, these tiny errors can accumulate into significant discrepancies that require manual reconciliation. Always use fixed-point decimal arithmetic with libraries like <code>decimal.Decimal</code> that store monetary amounts as integers with an implicit decimal point.</p>\n<p>⚠️ <strong>Pitfall: Allowing Modifications to Posted Journal Entries</strong>\nJunior developers often design journal entries as mutable records that can be updated after posting. This breaks the fundamental principle of accounting immutability and destroys the audit trail. Once a journal entry is posted, it must never be modified or deleted — corrections must be handled through reversing entries that create an offsetting transaction. Implement database constraints that prevent UPDATE or DELETE operations on posted entries.</p>\n<p>⚠️ <strong>Pitfall: Missing Currency Validation in Multi-Currency Systems</strong>\nWhen supporting multiple currencies, it&#39;s tempting to store monetary amounts as simple numbers without enforcing currency consistency. This leads to situations where USD amounts get added to EUR amounts, producing meaningless results. Always store currency codes alongside monetary amounts and validate that arithmetic operations only occur between amounts of the same currency. Require explicit currency conversion with documented exchange rates for cross-currency operations.</p>\n<p>⚠️ <strong>Pitfall: Inadequate Parent-Child Relationship Validation</strong>\nAccount hierarchies can become corrupted if the system allows circular references (Account A is parent of Account B, which is parent of Account A) or type mismatches (Asset account has Liability parent). Implement validation logic that checks for circular references using graph traversal algorithms and enforces that child accounts must have the same AccountType as their parent account.</p>\n<p>⚠️ <strong>Pitfall: Storing Audit Logs in Mutable Database Tables</strong>\nSome developers implement audit trails using standard database tables that support UPDATE and DELETE operations. This creates a false sense of security because audit records can be modified or removed, defeating the purpose of audit logging. Implement audit tables with database-level constraints that prevent modifications, use append-only storage mechanisms, or consider write-once storage technologies for critical audit data.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database</td>\n<td>PostgreSQL with JSONB for metadata</td>\n<td>PostgreSQL with separate audit database</td>\n</tr>\n<tr>\n<td>Decimal Library</td>\n<td>shopspring/decimal for Go</td>\n<td>Custom fixed-point implementation</td>\n</tr>\n<tr>\n<td>UUID Generation</td>\n<td>google/uuid standard library</td>\n<td>Ordered UUIDs with timestamp prefix</td>\n</tr>\n<tr>\n<td>Hash Functions</td>\n<td>crypto/sha256 from standard library</td>\n<td>BLAKE2b for faster cryptographic hashing</td>\n</tr>\n<tr>\n<td>Currency Validation</td>\n<td>Static ISO 4217 currency list</td>\n<td>Dynamic currency service with rates</td>\n</tr>\n<tr>\n<td>Schema Migration</td>\n<td>golang-migrate/migrate</td>\n<td>Custom migration framework with rollback</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  internal/model/\n    account.go                  ← Account type definitions and validation\n    journal_entry.go           ← Journal entry and line item types\n    money.go                   ← Money type with decimal arithmetic\n    audit.go                   ← Audit trail types and integrity checking\n    validation.go              ← Business rule validation functions\n    types.go                   ← Enums and constants (AccountType, EntryStatus)\n  internal/repository/\n    account_repository.go      ← Account CRUD operations\n    entry_repository.go        ← Journal entry persistence\n    audit_repository.go        ← Audit trail recording\n  migrations/\n    001_create_accounts.sql    ← Account table creation\n    002_create_entries.sql     ← Journal entry table creation\n    003_create_audit.sql       ← Audit trail table creation\n  pkg/decimal/                 ← Reusable decimal arithmetic utilities\n    decimal.go\n    money.go</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code (COMPLETE):</strong></p>\n<p>Database connection and transaction management utility:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> repository</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/lib/pq</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#6A737D\"> // PostgreSQL driver</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DatabaseConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Host     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Port     </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    User     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Password </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DBName   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SSLMode  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewConnection</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> DatabaseConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    dsn </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"host=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> port=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> user=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> password=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> dbname=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> sslmode=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config.Host, config.Port, config.User, config.Password, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config.DBName, config.SSLMode,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sql.</span><span style=\"color:#B392F0\">Open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"postgres\"</span><span style=\"color:#E1E4E8\">, dsn)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to open database: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Ping</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to ping database: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> db, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WithTransaction executes a function within a database transaction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> WithTransaction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fn</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Tx</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tx, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Begin</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to begin transaction: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> recover</span><span style=\"color:#E1E4E8\">(); p </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tx.</span><span style=\"color:#B392F0\">Rollback</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            panic</span><span style=\"color:#E1E4E8\">(p)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tx.</span><span style=\"color:#B392F0\">Rollback</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            err </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tx.</span><span style=\"color:#B392F0\">Commit</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> fn</span><span style=\"color:#E1E4E8\">(tx)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>UUID generation utility:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> model</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/google/uuid</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewID</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> uuid.</span><span style=\"color:#B392F0\">New</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> IsValidID</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> uuid.</span><span style=\"color:#B392F0\">Parse</span><span style=\"color:#E1E4E8\">(id)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code (signature + TODOs only):</strong></p>\n<p>Money type implementation skeleton:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> model</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/shopspring/decimal</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Money represents a monetary amount with currency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Amount   </span><span style=\"color:#B392F0\">decimal</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Decimal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Currency </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewMoney creates a new Money instance with validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewMoney</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">amount</span><span style=\"color:#B392F0\"> decimal</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Decimal</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">currency</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate that currency is a valid ISO 4217 code</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate that amount has appropriate precision for currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return Money instance or error for invalid inputs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Most currencies use 2 decimal places, some like JPY use 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Add combines two Money values of the same currency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">other</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check that both Money values have the same currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Add the decimal amounts using decimal.Decimal.Add()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return new Money with sum and original currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return error if currencies don't match</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Subtract subtracts two Money values of the same currency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Subtract</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">other</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check that both Money values have the same currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Subtract using decimal.Decimal.Sub() method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Return new Money with difference and original currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return error if currencies don't match</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Account type implementation skeleton:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> model</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AccountType</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeAsset</span><span style=\"color:#B392F0\">     AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ASSET\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeLiability</span><span style=\"color:#B392F0\"> AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"LIABILITY\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeEquity</span><span style=\"color:#B392F0\">    AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"EQUITY\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeRevenue</span><span style=\"color:#B392F0\">   AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"REVENUE\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeExpense</span><span style=\"color:#B392F0\">   AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"EXPENSE\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Account</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID         </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Code       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type       </span><span style=\"color:#B392F0\">AccountType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Currency   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ParentID   </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsActive   </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ModifiedAt </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NormalBalance returns whether this account type normally has a debit or credit balance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">a </span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">NormalBalance</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Return \"DEBIT\" for asset and expense account types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Return \"CREDIT\" for liability, equity, and revenue account types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Assets and Expenses increase with debits, others increase with credits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsDebitNormal returns true if this account type increases with debits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">a </span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsDebitNormal</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Return true for ASSET and EXPENSE account types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Return false for LIABILITY, EQUITY, and REVENUE account types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use the NormalBalance() method and compare to \"DEBIT\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Validate performs business rule validation on the account</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">a </span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Validate</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check that Code is not empty and follows numbering conventions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check that Name is not empty and reasonably descriptive</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check that Currency is a valid ISO 4217 code</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check that ParentID references an existing account if not nil</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check that account type matches parent account type if parent exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return specific error messages for each validation failure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>Journal entry implementation skeleton:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> model</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EntryStatus</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EntryStatusDraft</span><span style=\"color:#B392F0\">    EntryStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"DRAFT\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EntryStatusPosted</span><span style=\"color:#B392F0\">   EntryStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"POSTED\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EntryStatusReversed</span><span style=\"color:#B392F0\"> EntryStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"REVERSED\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> JournalEntry</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID          </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Date        </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Reference   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status      </span><span style=\"color:#B392F0\">EntryStatus</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedBy   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PostedAt    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Lines       []</span><span style=\"color:#B392F0\">EntryLine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt   </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EntryLine</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID           </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    JournalID    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AccountID    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DebitAmount  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreditAmount </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LineNumber   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TotalDebits calculates the sum of all debit amounts in this journal entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">je </span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TotalDebits</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize a zero Money value in the entry's base currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Iterate through all Lines in the journal entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each line where DebitAmount is not nil, add it to the total</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check that all debit amounts have the same currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return the total debits or error if currencies don't match</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: You'll need to determine the base currency from the first non-nil amount</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TotalCredits calculates the sum of all credit amounts in this journal entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">je </span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TotalCredits</span><span style=\"color:#E1E4E8\">() (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize a zero Money value in the entry's base currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Iterate through all Lines in the journal entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each line where CreditAmount is not nil, add it to the total</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check that all credit amounts have the same currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return the total credits or error if currencies don't match</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Validate ensures this journal entry follows double-entry bookkeeping rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">je </span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Validate</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check that the entry has at least 2 lines (minimum for double-entry)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check that each line has exactly one of DebitAmount or CreditAmount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate total debits and total credits using the methods above</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Verify that total debits exactly equals total credits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check that all referenced AccountIDs exist and are active</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Check that Date is not in the future</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Return specific error describing any validation failures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use decimal.Decimal.Equal() for exact monetary comparisons</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints:</strong></p>\n<ul>\n<li>Use <code>github.com/shopspring/decimal</code> for precise decimal arithmetic in Go</li>\n<li>Use <code>database/sql</code> with prepared statements to prevent SQL injection</li>\n<li>Use <code>time.UTC</code> for all stored timestamps to avoid timezone confusion</li>\n<li>Use PostgreSQL&#39;s <code>CHECK</code> constraints to enforce database-level validation</li>\n<li>Use <code>sql.NullString</code> for optional foreign key fields like ParentID</li>\n<li>Use Go&#39;s struct tags for JSON serialization: <code>json:&quot;field_name&quot;</code></li>\n<li>Use <code>SERIAL</code> or <code>BIGSERIAL</code> for auto-incrementing ID fields if not using UUIDs</li>\n<li>Use PostgreSQL&#39;s <code>NUMERIC</code> type for storing decimal amounts as strings</li>\n</ul>\n<p><strong>F. Milestone Checkpoint:</strong></p>\n<p>After implementing the core data model, you should be able to:</p>\n<ol>\n<li><p><strong>Create Account Records</strong>: Run <code>INSERT</code> statements to create accounts with proper parent-child relationships and verify the account hierarchy is maintained correctly.</p>\n</li>\n<li><p><strong>Validate Journal Entries</strong>: Create test journal entries with both balanced and unbalanced amounts, confirming that validation catches unbalanced entries and allows balanced ones.</p>\n</li>\n<li><p><strong>Test Money Arithmetic</strong>: Perform addition and subtraction operations on Money values, verifying that same-currency operations succeed and cross-currency operations fail with appropriate errors.</p>\n</li>\n<li><p><strong>Verify Audit Trail Creation</strong>: Insert records and confirm that audit events are automatically created with proper hash chains and tamper-evident properties.</p>\n</li>\n</ol>\n<p><strong>Expected Test Command</strong>: <code>go test ./internal/model/... -v</code></p>\n<p><strong>Expected Behavior Verification</strong>:</p>\n<ul>\n<li>Account hierarchy queries return proper parent-child relationships</li>\n<li>Journal entry validation rejects entries where debits ≠ credits  </li>\n<li>Money arithmetic operations maintain precision without floating-point errors</li>\n<li>Audit trail maintains cryptographic hash chain integrity</li>\n<li>Database constraints prevent deletion of posted journal entries</li>\n</ul>\n<p><strong>Signs of Problems</strong>:</p>\n<ul>\n<li>Floating-point precision errors in monetary calculations (values like 0.10000000000000001)</li>\n<li>Circular reference loops in account hierarchy causing infinite recursion</li>\n<li>Posted journal entries that can be modified or deleted</li>\n<li>Audit hash chains that don&#39;t validate properly after record insertion</li>\n<li>Cross-currency arithmetic operations that succeed instead of failing</li>\n</ul>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1 (Account &amp; Entry Model), as this section defines the chart of accounts structure, account type validation, and hierarchy management that form the foundation for all journal entries and financial reporting</p>\n</blockquote>\n<h2 id=\"account-management-component\">Account Management Component</h2>\n<p>The account management component serves as the foundation of any double-entry ledger system, much like how a filing cabinet&#39;s drawer labels and organization system determines whether you can efficiently find and categorize documents. Think of accounts as the labeled buckets where every financial transaction must be sorted - without a well-organized chart of accounts, even perfect transaction recording becomes meaningless because you cannot produce coherent financial reports or maintain proper oversight of different types of assets, obligations, and business activities.</p>\n<p>This component owns the complete lifecycle of financial accounts within the system, from initial setup of the chart of accounts through daily operations of validating transactions against account rules. The account manager acts as the gatekeeper ensuring that only valid accounts exist in the system, that the account hierarchy remains logically consistent, and that all transaction recording respects the fundamental rules of double-entry bookkeeping regarding which account types can receive debits versus credits.</p>\n<p><img src=\"/api/project/ledger-system/architecture-doc/asset?path=diagrams%2Faccount-hierarchy.svg\" alt=\"Chart of Accounts Hierarchy Structure\"></p>\n<p>The account management component enforces the fundamental accounting equation: <strong>Assets = Liabilities + Equity</strong>. This equation must hold true after every transaction, and the account type system provides the structural foundation that makes this possible. Each account type has specific rules about its normal balance (debit or credit), which accounts it can interact with in journal entries, and how it contributes to different financial statements.</p>\n<h3 id=\"account-type-system\">Account Type System</h3>\n<p>The account type system implements the five fundamental categories of accounts that comprise all possible financial activities in double-entry bookkeeping. Think of account types as the genetic code of accounting - just as DNA determines whether a cell becomes muscle, bone, or nerve tissue, the account type determines how an account behaves in transactions, which side of the accounting equation it belongs to, and how it appears in financial reports.</p>\n<p>Each account type carries with it an intrinsic <strong>normal balance</strong> - the side (debit or credit) where increases to that account type are recorded. This is not arbitrary but derives from the fundamental accounting equation and centuries of bookkeeping practice. Understanding normal balances is crucial because they determine transaction validation rules and balance sheet presentation.</p>\n<blockquote>\n<p><strong>The Double-Entry Mental Model</strong>: Imagine a medieval merchant&#39;s ledger where every transaction tells a complete story. If gold coins leave the cash drawer (credit to Cash account), they must go somewhere - perhaps to purchase inventory (debit to Inventory account) or pay a debt (debit to Accounts Payable). The account types ensure that every &quot;where it came from&quot; has a corresponding &quot;where it went&quot; that maintains the fundamental balance.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Account Type</th>\n<th>Normal Balance</th>\n<th>Accounting Equation Side</th>\n<th>Increases With</th>\n<th>Decreases With</th>\n<th>Financial Statement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ASSET</td>\n<td>Debit</td>\n<td>Left (Assets)</td>\n<td>Debit entries</td>\n<td>Credit entries</td>\n<td>Balance Sheet</td>\n</tr>\n<tr>\n<td>LIABILITY</td>\n<td>Credit</td>\n<td>Right (Liabilities)</td>\n<td>Credit entries</td>\n<td>Debit entries</td>\n<td>Balance Sheet</td>\n</tr>\n<tr>\n<td>EQUITY</td>\n<td>Credit</td>\n<td>Right (Equity)</td>\n<td>Credit entries</td>\n<td>Debit entries</td>\n<td>Balance Sheet</td>\n</tr>\n<tr>\n<td>REVENUE</td>\n<td>Credit</td>\n<td>Right (increases Equity)</td>\n<td>Credit entries</td>\n<td>Debit entries</td>\n<td>Income Statement</td>\n</tr>\n<tr>\n<td>EXPENSE</td>\n<td>Debit</td>\n<td>Left (decreases Equity)</td>\n<td>Debit entries</td>\n<td>Credit entries</td>\n<td>Income Statement</td>\n</tr>\n</tbody></table>\n<p>The account type system must enforce these rules automatically during transaction validation. When a journal entry attempts to debit a liability account, the system should not reject it outright - debiting liabilities is how you reduce them (like making a loan payment). However, the system must understand that this debit reduces the liability balance, not increases it, which affects how balances are calculated and displayed.</p>\n<p><strong>Asset accounts</strong> represent resources owned by the organization that provide future economic benefit. These include tangible items like cash, inventory, and equipment, as well as intangible assets like patents and goodwill. Asset accounts have debit normal balances because they sit on the left side of the accounting equation. When you acquire more assets, you debit the asset account to increase it. When assets are consumed or sold, you credit the asset account to decrease it.</p>\n<p><strong>Liability accounts</strong> represent obligations owed to external parties that must be settled in the future. These include accounts payable, loans, accrued expenses, and unearned revenue. Liability accounts have credit normal balances because they appear on the right side of the accounting equation. When you incur a new obligation, you credit the liability account to increase it. When you pay off debts, you debit the liability account to decrease it.</p>\n<p><strong>Equity accounts</strong> represent the owners&#39; residual interest in the organization after all liabilities are subtracted from assets. This includes contributed capital, retained earnings, and current period net income. Equity accounts have credit normal balances and increase when the organization becomes more valuable to owners. Revenue increases equity (through retained earnings), while expenses and dividends decrease equity.</p>\n<p><strong>Revenue accounts</strong> track income generated from the organization&#39;s primary business activities. Although revenue ultimately increases equity, it is tracked separately during the accounting period to enable performance analysis. Revenue accounts have credit normal balances - when you make a sale, you credit revenue to increase it. At period-end, revenue balances are closed to retained earnings.</p>\n<p><strong>Expense accounts</strong> track costs incurred to generate revenue and operate the business. Like revenue, expenses ultimately affect equity (decreasing it) but are tracked separately for analysis. Expense accounts have debit normal balances - when you incur an expense, you debit the expense account to increase it. At period-end, expense balances are closed to retained earnings.</p>\n<blockquote>\n<p><strong>Decision: Account Type Enum vs String Storage</strong></p>\n<ul>\n<li><strong>Context</strong>: Account types could be stored as enumerated constants or as flexible string values in the database</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Enum constants with validation: Type-safe, prevents invalid values, enables compile-time checking</li>\n<li>String storage with validation: Flexible, allows easy extension, simpler database queries</li>\n<li>Mixed approach: Enum in code, string in database</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Use strongly-typed enums in code that serialize to/from standard string values</li>\n<li><strong>Rationale</strong>: Account types are fundamental and stable - the five basic types have not changed in centuries. Type safety prevents bugs, while string serialization maintains database portability and human readability</li>\n<li><strong>Consequences</strong>: Compile-time safety for account type operations, but requires explicit conversion methods and careful handling of invalid database values</li>\n</ul>\n</blockquote>\n<p>The account type validation rules must be embedded deep into the transaction recording system. Every journal entry line must specify whether it is a debit or credit to a specific account, and the account manager must validate that this combination makes business sense. However, both debits and credits are valid for all account types - the difference lies in whether they increase or decrease the account balance.</p>\n<table>\n<thead>\n<tr>\n<th>Account Type</th>\n<th>Debit Effect</th>\n<th>Credit Effect</th>\n<th>Validation Rules</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ASSET</td>\n<td>Increases balance</td>\n<td>Decreases balance</td>\n<td>Must not allow negative balances unless explicitly configured</td>\n</tr>\n<tr>\n<td>LIABILITY</td>\n<td>Decreases balance</td>\n<td>Increases balance</td>\n<td>Negative balances may indicate overpayments or accounting errors</td>\n</tr>\n<tr>\n<td>EQUITY</td>\n<td>Decreases balance</td>\n<td>Increases balance</td>\n<td>Should rarely have negative balances except in specific scenarios</td>\n</tr>\n<tr>\n<td>REVENUE</td>\n<td>Decreases balance</td>\n<td>Increases balance</td>\n<td>Debits typically only for corrections or refunds</td>\n</tr>\n<tr>\n<td>EXPENSE</td>\n<td>Increases balance</td>\n<td>Decreases balance</td>\n<td>Credits typically only for corrections or reimbursements</td>\n</tr>\n</tbody></table>\n<h3 id=\"account-hierarchy-management\">Account Hierarchy Management</h3>\n<p>Account hierarchy management enables the organization of accounts into logical groups that reflect the business structure and reporting requirements. Think of the account hierarchy like a company&#39;s organizational chart - just as departments have managers and sub-departments, accounts can have parent accounts and sub-accounts that roll up into higher-level categories for reporting purposes.</p>\n<p>The hierarchy serves multiple critical functions beyond just organization. Parent accounts can aggregate the balances of their children for summary reporting, account permissions can be inherited down the hierarchy, and business rules can be applied at different levels. A well-designed hierarchy makes financial reports more readable and enables drill-down analysis from high-level summaries to detailed transactions.</p>\n<p>The most common approach uses a <strong>tree structure</strong> where each account can have zero or one parent account, but any account can have multiple child accounts. This creates a forest of account trees, typically with one tree per major account type. The root nodes are usually the five major account types (Assets, Liabilities, Equity, Revenue, Expenses), with increasingly specific categories branching downward.</p>\n<blockquote>\n<p><strong>The Organizational Chart Mental Model</strong>: Just as a VP of Sales might oversee Regional Sales Managers who oversee Individual Sales Reps, a &quot;Current Assets&quot; parent account might oversee &quot;Cash and Equivalents&quot; which oversees specific bank accounts like &quot;Checking - Wells Fargo Account 1234&quot; and &quot;Petty Cash - Office&quot;. Each level provides a different granularity of information for different audiences.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Hierarchy Level</th>\n<th>Example Account</th>\n<th>Account Code</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Type Level</td>\n<td>Assets</td>\n<td>1000-1999</td>\n<td>Top-level financial statement category</td>\n</tr>\n<tr>\n<td>Category Level</td>\n<td>Current Assets</td>\n<td>1100-1199</td>\n<td>Major grouping within type</td>\n</tr>\n<tr>\n<td>Subcategory Level</td>\n<td>Cash and Equivalents</td>\n<td>1110-1119</td>\n<td>Specific asset class</td>\n</tr>\n<tr>\n<td>Detail Level</td>\n<td>Checking - Wells Fargo</td>\n<td>1111</td>\n<td>Individual account for transactions</td>\n</tr>\n<tr>\n<td>Sub-detail Level</td>\n<td>Checking - WF Payroll</td>\n<td>1111.001</td>\n<td>Further subdivision if needed</td>\n</tr>\n</tbody></table>\n<p>The account coding scheme works hand-in-hand with the hierarchy to provide a systematic way to organize and identify accounts. Most organizations use a numerical coding system where the first digit identifies the account type, and subsequent digits provide increasing levels of detail. This enables both human recognition (accountants can immediately identify &quot;2xxx&quot; as liability accounts) and systematic processing (reports can aggregate all accounts starting with &quot;11&quot; for current assets).</p>\n<p>Account hierarchy management must handle several complex scenarios that arise in real-world accounting:</p>\n<p><strong>Hierarchy Restructuring</strong>: Business reorganizations often require moving accounts between parents or splitting large categories into smaller ones. The system must preserve historical relationships while enabling changes, ensuring that historical reports remain accurate even after restructuring.</p>\n<p><strong>Balance Aggregation</strong>: Parent account balances are typically calculated as the sum of their children&#39;s balances, but this requires careful handling of account types and normal balances. A parent asset account&#39;s balance equals the sum of its children&#39;s balances, but the calculation must respect whether each child has a debit or credit balance.</p>\n<p><strong>Circular Reference Prevention</strong>: The system must prevent accounts from becoming their own ancestors through a chain of parent relationships. This requires validation during hierarchy changes and periodic integrity checks to catch corruption.</p>\n<p><strong>Permission Inheritance</strong>: If a user has access to a parent account, they might automatically inherit access to its children, or permissions might be explicitly set at each level. The hierarchy structure must support whatever permission model the organization chooses.</p>\n<p>The account hierarchy data model requires careful consideration of how to store and query tree structures efficiently. The parent reference approach (each account stores its parent&#39;s ID) is simple but makes certain queries expensive. Alternative approaches like nested sets or closure tables optimize different query patterns but add complexity.</p>\n<table>\n<thead>\n<tr>\n<th>Hierarchy Storage Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Best For</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Parent Reference (ParentID field)</td>\n<td>Simple schema, easy updates</td>\n<td>Expensive recursive queries</td>\n<td>Small hierarchies, infrequent reporting</td>\n</tr>\n<tr>\n<td>Nested Sets (left/right values)</td>\n<td>Fast subtree queries</td>\n<td>Complex updates, hard to understand</td>\n<td>Read-heavy, stable hierarchies</td>\n</tr>\n<tr>\n<td>Closure Table (separate ancestor table)</td>\n<td>Fast queries, flexible</td>\n<td>Additional storage, complex maintenance</td>\n<td>Large hierarchies, frequent queries</td>\n</tr>\n<tr>\n<td>Path Enumeration (store full path)</td>\n<td>Simple queries, good performance</td>\n<td>Path length limits, difficult moves</td>\n<td>Medium hierarchies, stable structure</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Parent Reference with Recursive CTE Queries</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to balance query performance, update complexity, and maintainability for account hierarchies</li>\n<li><strong>Options Considered</strong>: Parent reference, nested sets, closure table, path enumeration</li>\n<li><strong>Decision</strong>: Use parent reference with Common Table Expression (CTE) recursive queries for hierarchy traversal</li>\n<li><strong>Rationale</strong>: Account hierarchies are relatively stable and not extremely deep. Most queries need specific accounts rather than full subtrees. CTE support in modern databases makes recursive queries performant enough, while parent reference keeps updates simple</li>\n<li><strong>Consequences</strong>: Straightforward schema and hierarchy maintenance, but may require query optimization for very large account trees</li>\n</ul>\n</blockquote>\n<h3 id=\"account-validation-rules\">Account Validation Rules</h3>\n<p>Account validation rules ensure data integrity and business rule compliance throughout the account lifecycle. Think of these rules as the immune system of the accounting system - they prevent malformed or logically inconsistent data from entering the system, much like white blood cells identify and neutralize threats before they can cause damage.</p>\n<p>Validation occurs at multiple levels and stages: field-level validation ensures data types and formats are correct, business rule validation ensures accounting principles are respected, and system validation ensures referential integrity and consistency. Each level serves a different purpose and catches different types of errors.</p>\n<p><strong>Field-Level Validation</strong> ensures that individual account attributes meet basic format and type requirements. This includes data type checking (strings are strings, dates are valid dates), length restrictions (account codes within specified character limits), and format validation (account codes follow the organization&#39;s numbering scheme).</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Validation Rules</th>\n<th>Error Examples</th>\n<th>Business Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Account Code</td>\n<td>Unique, follows numbering scheme, appropriate length</td>\n<td>Duplicate code &quot;1100&quot;, invalid format &quot;ABC-XYZ&quot;</td>\n<td>Prevents transaction posting errors, maintains reporting consistency</td>\n</tr>\n<tr>\n<td>Account Name</td>\n<td>Non-empty, reasonable length, unique within parent</td>\n<td>Empty string, excessively long names</td>\n<td>Ensures accounts are identifiable in reports and interfaces</td>\n</tr>\n<tr>\n<td>Account Type</td>\n<td>Must be valid enum value</td>\n<td>Invalid type &quot;FURNITURE&quot;</td>\n<td>Prevents calculation errors, ensures proper financial statement classification</td>\n</tr>\n<tr>\n<td>Currency</td>\n<td>Valid ISO 4217 currency code</td>\n<td>Invalid code &quot;DOLLAR&quot;, mixing currencies inappropriately</td>\n<td>Prevents multi-currency calculation errors, ensures accurate exchange rate handling</td>\n</tr>\n<tr>\n<td>Parent Account</td>\n<td>Must exist, must not create circular reference</td>\n<td>Non-existent parent, self-reference</td>\n<td>Maintains hierarchy integrity, prevents infinite loops in queries</td>\n</tr>\n</tbody></table>\n<p><strong>Business Rule Validation</strong> ensures that account configurations comply with accounting principles and organizational policies. These rules are more sophisticated than field validation because they require understanding the business context and relationships between different data elements.</p>\n<p>The system must validate that account type changes do not violate existing transaction history. If an account has been used in journal entries as an asset account, changing it to a liability account would invalidate historical balance calculations and financial statements. Therefore, account type changes should be either prohibited for accounts with transaction history or handled through a formal account migration process.</p>\n<p>Account activation and deactivation must follow business rules that prevent disruption to ongoing operations. Active accounts with non-zero balances cannot be simply deleted - they must either be closed through appropriate journal entries or have their balances transferred to other accounts. Inactive accounts should not appear in transaction entry interfaces but must remain accessible for historical reporting.</p>\n<p>Parent-child relationships must respect account type compatibility. While there&#39;s flexibility in how organizations structure their hierarchies, certain combinations make no business sense and could confuse users or distort reports. For example, having an expense account as a child of an asset account would violate the logical separation of balance sheet and income statement items.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Rule</th>\n<th>Business Rationale</th>\n<th>Implementation Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Account type immutability for accounts with transactions</td>\n<td>Preserves historical accuracy, prevents balance calculation errors</td>\n<td>Check for existing journal entries before allowing type changes</td>\n</tr>\n<tr>\n<td>Non-zero balance accounts cannot be deactivated</td>\n<td>Prevents &quot;disappearing&quot; amounts, ensures trial balance integrity</td>\n<td>Validate current balance is zero before allowing deactivation</td>\n</tr>\n<tr>\n<td>Parent account type compatibility</td>\n<td>Maintains logical hierarchy, prevents reporting confusion</td>\n<td>Validate parent and child types follow organizational rules</td>\n</tr>\n<tr>\n<td>Unique account codes within scope</td>\n<td>Prevents ambiguity, ensures reliable account identification</td>\n<td>Database unique constraints with appropriate scope (global or per-parent)</td>\n</tr>\n<tr>\n<td>Currency consistency within hierarchy branches</td>\n<td>Simplifies balance aggregation, prevents mixing currency calculations</td>\n<td>Validate child accounts use same currency as parent, or explicitly allow multi-currency branches</td>\n</tr>\n</tbody></table>\n<p><strong>System Integrity Validation</strong> ensures that the account data remains consistent with the broader ledger system. This includes validating that accounts referenced by journal entries exist and are active, ensuring that account hierarchies remain well-formed trees without cycles, and verifying that cached balances and derived data remain synchronized with account definitions.</p>\n<p>The validation system must handle both immediate validation (performed during API calls) and batch validation (performed during maintenance windows to catch corruption or drift). Immediate validation prevents bad data from entering the system, while batch validation identifies problems that might have slipped through or developed over time due to bugs or data corruption.</p>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Inadequate Account Code Validation</strong>\nAllowing flexible account codes without proper validation leads to chaos in the chart of accounts. Organizations often start with informal coding schemes (&quot;CASH&quot;, &quot;CHECKING&quot;, &quot;SAVINGS&quot;) that work initially but break down as the business grows. Without systematic codes, accounts cannot be grouped logically for reports, sorting becomes unreliable, and users cannot predict where to find specific accounts. The fix is implementing a formal coding scheme from the beginning, even if it seems overly structured for a small organization.</p>\n</blockquote>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Permissive Account Type Changes</strong>\nAllowing account type changes after transactions are recorded can destroy the integrity of historical financial statements. If an account that was treated as an asset in January gets changed to a liability in March, the January balance sheet becomes incorrect. The trial balance may still balance numerically, but the financial statement classifications are wrong. The fix is either prohibiting type changes entirely for accounts with transaction history, or implementing a formal migration process that creates new accounts and transfers balances through proper journal entries.</p>\n</blockquote>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Ignoring Account Normal Balance Rules</strong>\nMany implementations store account balances as simple positive/negative numbers without properly accounting for normal balance conventions. This leads to confusion when an asset account shows a negative balance (which might be correct if it represents overdrafts or adjustments) versus a liability account with a negative balance (which might indicate an error or overpayment). The fix is implementing proper normal balance calculations where account balances are always interpreted in the context of their account type.</p>\n<p>⚠️ <strong>Pitfall: Inadequate Hierarchy Validation</strong>\nFailing to prevent circular references in account hierarchies creates infinite loops that crash reporting queries. A subtle version of this problem occurs when batch updates to parent relationships temporarily create cycles that are resolved later in the same transaction. The fix is implementing comprehensive cycle detection that runs both during individual updates and as part of periodic integrity checks.</p>\n<p>⚠️ <strong>Pitfall: Mixing Currencies in Account Hierarchies</strong>\nAllowing parent accounts to aggregate child accounts with different currencies without proper conversion handling leads to meaningless totals. For example, a &quot;Cash and Equivalents&quot; parent account containing both USD and EUR accounts cannot simply sum the amounts. The fix is either restricting hierarchies to single currencies or implementing proper currency conversion at aggregation time with clear policies about which exchange rates to use.</p>\n<p>⚠️ <strong>Pitfall: Over-Permissive Account Deactivation</strong>\nAllowing accounts to be deleted or deactivated without checking for dependencies breaks referential integrity and can make historical transactions unreadable. Even worse, some systems allow deactivation of accounts with non-zero balances, which makes the trial balance appear unbalanced. The fix is implementing comprehensive dependency checks that prevent deactivation of accounts that are referenced by unposted transactions, have non-zero balances, or serve as parents to active child accounts.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The Account Management Component should be implemented as a self-contained service that provides a clean API for account operations while encapsulating all validation logic and data persistence concerns. This component will be heavily used by the Transaction Recording Engine and Financial Reporting Module, so performance and reliability are critical.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Data Storage</td>\n<td>PostgreSQL with standard tables</td>\n<td>PostgreSQL with recursive CTEs and materialized views</td>\n</tr>\n<tr>\n<td>Validation</td>\n<td>In-memory validation with database constraints</td>\n<td>Rule engine with configurable business rules</td>\n</tr>\n<tr>\n<td>Hierarchy Queries</td>\n<td>Recursive application code</td>\n<td>Database stored procedures with CTEs</td>\n</tr>\n<tr>\n<td>Caching</td>\n<td>In-memory map for frequently accessed accounts</td>\n<td>Redis cache with invalidation strategies</td>\n</tr>\n<tr>\n<td>API Layer</td>\n<td>HTTP REST with JSON</td>\n<td>gRPC with protocol buffers for type safety</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/account/\n  manager.go              ← main AccountManager interface and implementation\n  manager_test.go         ← comprehensive tests for account operations\n  types.go                ← Account, AccountType, and related types\n  validation.go           ← validation rules and business logic\n  validation_test.go      ← tests for validation scenarios\n  hierarchy.go            ← hierarchy management and queries\n  hierarchy_test.go       ← tests for hierarchy operations\n  repository.go           ← database operations interface\n  postgres_repository.go  ← PostgreSQL implementation of repository\n  errors.go               ← domain-specific error types\nmigrations/\n  001_create_accounts.sql ← database schema creation\n  002_add_indexes.sql     ← performance indexes\ncmd/account-cli/\n  main.go                 ← command-line tool for account management</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Account Types and Core Data Structures:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> account</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/shopspring/decimal</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AccountType represents the five fundamental account categories</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AccountType</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeAsset</span><span style=\"color:#B392F0\">     AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"ASSET\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeLiability</span><span style=\"color:#B392F0\"> AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"LIABILITY\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeEquity</span><span style=\"color:#B392F0\">    AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"EQUITY\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeRevenue</span><span style=\"color:#B392F0\">   AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"REVENUE\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    AccountTypeExpense</span><span style=\"color:#B392F0\">   AccountType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"EXPENSE\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NormalBalance returns the normal balance side for this account type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">at </span><span style=\"color:#B392F0\">AccountType</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">NormalBalance</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#E1E4E8\"> at {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> AccountTypeAsset, AccountTypeExpense:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"DEBIT\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#E1E4E8\"> AccountTypeLiability, AccountTypeEquity, AccountTypeRevenue:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"CREDIT\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IsDebitNormal returns true if this account type increases with debits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">at </span><span style=\"color:#B392F0\">AccountType</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">IsDebitNormal</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> at.</span><span style=\"color:#B392F0\">NormalBalance</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"DEBIT\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Account represents a single account in the chart of accounts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Account</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ID         </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"id\" db:\"id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Code       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"code\" db:\"code\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"name\" db:\"name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Type       </span><span style=\"color:#B392F0\">AccountType</span><span style=\"color:#9ECBFF\"> `json:\"type\" db:\"type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Currency   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"currency\" db:\"currency\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ParentID   </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">     `json:\"parent_id\" db:\"parent_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsActive   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">        `json:\"is_active\" db:\"is_active\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">   `json:\"created_at\" db:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ModifiedAt </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">   `json:\"modified_at\" db:\"modified_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Money represents a monetary amount with currency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Amount   </span><span style=\"color:#B392F0\">decimal</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Decimal</span><span style=\"color:#9ECBFF\"> `json:\"amount\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Currency </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"currency\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Add adds two Money values of the same currency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">other</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> m.Currency </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.Currency {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">{}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cannot add different currencies: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> + </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, m.Currency, other.Currency)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Amount:   m.Amount.</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(other.Amount),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Currency: m.Currency,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Subtract subtracts two Money values of the same currency  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Subtract</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">other</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> m.Currency </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> other.Currency {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">{}, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"cannot subtract different currencies: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> - </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, m.Currency, other.Currency)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Amount:   m.Amount.</span><span style=\"color:#B392F0\">Sub</span><span style=\"color:#E1E4E8\">(other.Amount),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Currency: m.Currency,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Database Schema (PostgreSQL):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">sql</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">-- migrations/001_create_accounts.sql</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TABLE</span><span style=\"color:#B392F0\"> accounts</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    id </span><span style=\"color:#F97583\">VARCHAR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">36</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">PRIMARY KEY</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    code </span><span style=\"color:#F97583\">VARCHAR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">UNIQUE</span><span style=\"color:#F97583\"> NOT NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    name</span><span style=\"color:#F97583\"> VARCHAR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">255</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">NOT NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    type</span><span style=\"color:#F97583\"> VARCHAR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">NOT NULL</span><span style=\"color:#F97583\"> CHECK</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">type</span><span style=\"color:#F97583\"> IN</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">'ASSET'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'LIABILITY'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'EQUITY'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'REVENUE'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'EXPENSE'</span><span style=\"color:#E1E4E8\">)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currency </span><span style=\"color:#F97583\">CHAR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">NOT NULL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parent_id </span><span style=\"color:#F97583\">VARCHAR</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">36</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">REFERENCES</span><span style=\"color:#E1E4E8\"> accounts(id),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_active </span><span style=\"color:#F97583\">BOOLEAN</span><span style=\"color:#F97583\"> DEFAULT</span><span style=\"color:#E1E4E8\"> TRUE,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_at </span><span style=\"color:#F97583\">TIMESTAMP</span><span style=\"color:#F97583\"> DEFAULT</span><span style=\"color:#E1E4E8\"> CURRENT_TIMESTAMP,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    modified_at </span><span style=\"color:#F97583\">TIMESTAMP</span><span style=\"color:#F97583\"> DEFAULT</span><span style=\"color:#E1E4E8\"> CURRENT_TIMESTAMP,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    -- Prevent circular references at database level</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    CONSTRAINT</span><span style=\"color:#E1E4E8\"> no_self_reference </span><span style=\"color:#F97583\">CHECK</span><span style=\"color:#E1E4E8\"> (id </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> parent_id)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Index for hierarchy queries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> INDEX</span><span style=\"color:#B392F0\"> idx_accounts_parent_id</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> accounts(parent_id);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> INDEX</span><span style=\"color:#B392F0\"> idx_accounts_type</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> accounts(</span><span style=\"color:#F97583\">type</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> INDEX</span><span style=\"color:#B392F0\"> idx_accounts_code</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> accounts(code);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> INDEX</span><span style=\"color:#B392F0\"> idx_accounts_active</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> accounts(is_active) </span><span style=\"color:#F97583\">WHERE</span><span style=\"color:#E1E4E8\"> is_active </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TRUE;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">-- Trigger to update modified_at</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE OR REPLACE</span><span style=\"color:#F97583\"> FUNCTION</span><span style=\"color:#B392F0\"> update_modified_at</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">RETURNS</span><span style=\"color:#E1E4E8\"> TRIGGER </span><span style=\"color:#F97583\">AS</span><span style=\"color:#E1E4E8\"> $$</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">BEGIN</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NEW</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">modified_at</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> CURRENT_TIMESTAMP;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    RETURN</span><span style=\"color:#E1E4E8\"> NEW;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">END</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">$$ </span><span style=\"color:#F97583\">LANGUAGE</span><span style=\"color:#E1E4E8\"> plpgsql;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">CREATE</span><span style=\"color:#F97583\"> TRIGGER</span><span style=\"color:#B392F0\"> accounts_update_modified_at</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    BEFORE</span><span style=\"color:#F97583\"> UPDATE</span><span style=\"color:#F97583\"> ON</span><span style=\"color:#E1E4E8\"> accounts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    FOR</span><span style=\"color:#E1E4E8\"> EACH </span><span style=\"color:#F97583\">ROW</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    EXECUTE</span><span style=\"color:#F97583\"> FUNCTION</span><span style=\"color:#E1E4E8\"> update_modified_at();</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Account Manager Interface:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Manager provides operations for managing accounts and chart of accounts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Manager</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // CreateAccount creates a new account with validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CreateAccount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">account</span><span style=\"color:#B392F0\"> Account</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // UpdateAccount updates an existing account with business rule validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    UpdateAccount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">updates</span><span style=\"color:#B392F0\"> AccountUpdates</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // GetAccount retrieves an account by ID</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetAccount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // GetAccountByCode retrieves an account by its code</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetAccountByCode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">code</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ListAccounts returns accounts matching the given criteria</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ListAccounts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">filter</span><span style=\"color:#B392F0\"> AccountFilter</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // GetAccountHierarchy returns the full hierarchy starting from the given account</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetAccountHierarchy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">rootID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AccountHierarchy</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // DeactivateAccount deactivates an account after validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    DeactivateAccount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">id</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ValidateAccount performs comprehensive business rule validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ValidateAccount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">account</span><span style=\"color:#B392F0\"> Account</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateAccount creates a new account in the chart of accounts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AccountManagerImpl</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateAccount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">account</span><span style=\"color:#B392F0\"> Account</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Account</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Generate unique ID if not provided</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate account code format and uniqueness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate account name is not empty and reasonable length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate account type is one of the five valid types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Validate currency code is valid ISO 4217</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: If parent_id provided, validate parent exists and is active</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Validate parent-child type compatibility</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Check for circular reference if parent_id provided</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Set timestamps and active status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Insert into database within transaction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use database transaction to ensure atomicity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Generate UUID for ID if empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Validate currency against ISO 4217 list</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateAccountHierarchy checks for circular references in account hierarchy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">m </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AccountManagerImpl</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateAccountHierarchy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">parentID</span><span style=\"color:#F97583\"> *</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: If parentID is nil, no validation needed (root account)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If parentID equals accountID, return circular reference error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Start from parentID and walk up the hierarchy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For each ancestor, check if it equals accountID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If we find accountID in ancestors, return circular reference error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: If we reach a root account (no parent), hierarchy is valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Handle case where hierarchy walk encounters non-existent account</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use recursive query or iterative approach with visited set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Limit maximum hierarchy depth to prevent infinite loops</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Account Validation Logic:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ValidateAccountCode ensures account codes follow organizational standards</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AccountValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateAccountCode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">code</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountType</span><span style=\"color:#B392F0\"> AccountType</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check code is not empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate code length is within acceptable range (e.g., 3-20 characters)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check code format matches organizational numbering scheme</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate first digit corresponds to account type (1=Asset, 2=Liability, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check for invalid characters (only alphanumeric and specific punctuation)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Validate code doesn't conflict with reserved ranges</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use regex pattern matching for format validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Consider organizational coding standards (numeric vs alphanumeric)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateParentChildCompatibility ensures parent-child relationships make business sense</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">v </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AccountValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateParentChildCompatibility</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">parentType</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">childType</span><span style=\"color:#B392F0\"> AccountType</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Define compatibility matrix for account type combinations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if parent type can logically contain child type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate both types are not mixing balance sheet and income statement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Allow same-type relationships (Asset parent, Asset child)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Consider organizational-specific rules (some orgs allow mixed hierarchies)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Balance sheet accounts (Asset, Liability, Equity) should not mix with income statement (Revenue, Expense)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Create lookup table or switch statement for allowed combinations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the Account Management Component, you should be able to:</p>\n<p><strong>Test Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run unit tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/account/...</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test account creation via CLI</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./bin/account-cli</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#79B8FF\"> --code</span><span style=\"color:#9ECBFF\"> \"1100\"</span><span style=\"color:#79B8FF\"> --name</span><span style=\"color:#9ECBFF\"> \"Cash\"</span><span style=\"color:#79B8FF\"> --type</span><span style=\"color:#9ECBFF\"> \"ASSET\"</span><span style=\"color:#79B8FF\"> --currency</span><span style=\"color:#9ECBFF\"> \"USD\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test hierarchy validation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./bin/account-cli</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#79B8FF\"> --code</span><span style=\"color:#9ECBFF\"> \"1110\"</span><span style=\"color:#79B8FF\"> --name</span><span style=\"color:#9ECBFF\"> \"Checking Account\"</span><span style=\"color:#79B8FF\"> --type</span><span style=\"color:#9ECBFF\"> \"ASSET\"</span><span style=\"color:#79B8FF\"> --parent</span><span style=\"color:#9ECBFF\"> \"1100\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test validation errors</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">./bin/account-cli</span><span style=\"color:#9ECBFF\"> create</span><span style=\"color:#79B8FF\"> --code</span><span style=\"color:#9ECBFF\"> \"1100\"</span><span style=\"color:#79B8FF\"> --name</span><span style=\"color:#9ECBFF\"> \"Duplicate\"</span><span style=\"color:#79B8FF\"> --type</span><span style=\"color:#9ECBFF\"> \"ASSET\"</span><span style=\"color:#6A737D\">  # Should fail</span></span></code></pre></div>\n\n<p><strong>Expected Behavior:</strong></p>\n<ul>\n<li>Account creation succeeds for valid accounts and fails with clear error messages for invalid accounts</li>\n<li>Hierarchy queries return proper parent-child relationships</li>\n<li>Account type validation prevents incompatible relationships</li>\n<li>Database constraints prevent duplicate codes and circular references</li>\n<li>All validation rules are enforced at both application and database levels</li>\n</ul>\n<p><strong>Debugging Signs:</strong></p>\n<ul>\n<li>If accounts can be created with duplicate codes, check database unique constraints</li>\n<li>If circular references are allowed, verify hierarchy validation logic</li>\n<li>If validation errors are unclear, improve error message specificity</li>\n<li>If queries are slow, check database indexes on parent_id and type columns</li>\n</ul>\n<h2 id=\"transaction-recording-engine\">Transaction Recording Engine</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 2 (Transaction Recording), 3 (Balance Calculation), 4 (Audit Trail), as this section implements the atomic journal entry creation, double-entry validation, and posting workflow that forms the core of the ledger system.</p>\n</blockquote>\n<p>The transaction recording engine is the beating heart of our double-entry ledger system. Think of it as a meticulous bank teller who never makes a mistake - every transaction must be perfectly balanced before it gets recorded, and once recorded, it becomes an immutable part of the financial history. The engine enforces the fundamental rule of double-entry bookkeeping: every transaction must have equal debits and credits, and it does this through a rigorous validation and posting workflow that ensures data integrity at every step.</p>\n<p><img src=\"/api/project/ledger-system/architecture-doc/asset?path=diagrams%2Fjournal-entry-workflow.svg\" alt=\"Journal Entry Recording Sequence\"></p>\n<p>The recording engine operates like a multi-stage security checkpoint at an airport. First, it validates that all the paperwork (journal entry) is complete and follows the rules. Then it processes the transaction atomically - either everything goes through perfectly, or nothing happens at all. Finally, it creates an immutable record that cannot be changed, only corrected through additional offsetting entries.</p>\n<p><img src=\"/api/project/ledger-system/architecture-doc/asset?path=diagrams%2Fentry-state-machine.svg\" alt=\"Journal Entry State Transitions\"></p>\n<p>This atomic, validated approach prevents the nightmare scenarios that plague poorly designed accounting systems: partially recorded transactions, unbalanced books, lost audit trails, and data corruption. By building these safeguards into the core recording engine, we ensure that the ledger maintains perfect integrity even under high load or system failures.</p>\n<h3 id=\"journal-entry-validation\">Journal Entry Validation</h3>\n<p>Journal entry validation is like having a rigorous accountant review every transaction before it gets entered into the books. The validation engine examines each journal entry to ensure it follows the immutable laws of double-entry bookkeeping: debits must equal credits, accounts must exist and be active, and the entry must make logical sense from an accounting perspective.</p>\n<p>The validation process operates in multiple stages, each catching different types of errors. Think of it as a quality control assembly line where each station checks for specific defects. The early stages catch obvious problems like missing data or formatting errors, while later stages perform complex business rule validation that requires database lookups and cross-referencing.</p>\n<blockquote>\n<p><strong>Decision: Multi-Stage Validation Pipeline</strong></p>\n<ul>\n<li><strong>Context</strong>: Journal entries need validation for data integrity, business rules, and accounting principles</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Single validation function that checks everything at once</li>\n<li>Multi-stage pipeline with early failure detection</li>\n<li>Asynchronous validation with eventual consistency</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Multi-stage validation pipeline with fail-fast semantics</li>\n<li><strong>Rationale</strong>: Early stages can reject invalid entries without expensive database operations; clear separation of concerns makes validation logic maintainable; immediate feedback provides better user experience</li>\n<li><strong>Consequences</strong>: Slightly more complex validation logic but much better performance and maintainability; clear error reporting tells users exactly what&#39;s wrong</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Validation Stage</th>\n<th>Purpose</th>\n<th>Checks Performed</th>\n<th>Database Access Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Structure Validation</td>\n<td>Data completeness</td>\n<td>Non-empty fields, valid currencies, positive amounts</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Format Validation</td>\n<td>Data format correctness</td>\n<td>Date ranges, decimal precision, string lengths</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Account Validation</td>\n<td>Account existence and status</td>\n<td>Account IDs exist, accounts are active</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Business Rule Validation</td>\n<td>Accounting logic</td>\n<td>Account type compatibility, currency matching</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Balance Validation</td>\n<td>Double-entry compliance</td>\n<td>Total debits equal total credits</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Authorization Validation</td>\n<td>User permissions</td>\n<td>User can post to specified accounts</td>\n<td>Yes</td>\n</tr>\n</tbody></table>\n<p>The validation engine maintains a comprehensive set of rules that evolve as the business requirements change. Each rule is implemented as a small, focused validator that can be tested independently. This modular approach makes it easy to add new validation rules or modify existing ones without touching the core validation pipeline.</p>\n<p><strong>Structure Validation</strong> forms the first line of defense, checking that all required fields are present and non-empty. This stage validates that the <code>JournalEntry</code> has a valid date, description, and at least two <code>EntryLine</code> records. It also ensures that each entry line has either a debit or credit amount (but not both), and that all amounts are positive decimal values. This validation requires no database access and can reject malformed entries immediately.</p>\n<p><strong>Account Validation</strong> verifies that every account referenced in the entry lines actually exists in the chart of accounts and is currently active. This stage also checks that the accounts belong to the correct company or organization context. If any referenced account is inactive or doesn&#39;t exist, the entire journal entry is rejected with a clear error message identifying the problematic account.</p>\n<p><strong>Balance Validation</strong> enforces the fundamental rule of double-entry bookkeeping by calculating the total debits and credits for the journal entry. The validation logic handles multi-currency entries by grouping amounts by currency and ensuring that debits equal credits within each currency. This prevents the common mistake of posting unbalanced entries that would corrupt the trial balance.</p>\n<p>The validation process maintains detailed error collection, accumulating all validation failures rather than stopping at the first error. This provides users with comprehensive feedback about everything that needs to be fixed, rather than forcing them through multiple rounds of fix-and-resubmit. The error collection includes specific field names, invalid values, and suggested corrections where applicable.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Error Type</th>\n<th>Error Code</th>\n<th>Example Message</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Missing Required Field</td>\n<td><code>ENTRY_001</code></td>\n<td>&quot;Description is required for all journal entries&quot;</td>\n<td>Provide entry description</td>\n</tr>\n<tr>\n<td>Invalid Account Reference</td>\n<td><code>ENTRY_002</code></td>\n<td>&quot;Account &#39;1001-CASH&#39; does not exist or is inactive&quot;</td>\n<td>Use valid, active account ID</td>\n</tr>\n<tr>\n<td>Currency Mismatch</td>\n<td><code>ENTRY_003</code></td>\n<td>&quot;All entry lines must use the same currency&quot;</td>\n<td>Convert to single currency</td>\n</tr>\n<tr>\n<td>Unbalanced Entry</td>\n<td><code>ENTRY_004</code></td>\n<td>&quot;Debits ($1,500.00) do not equal credits ($1,450.00)&quot;</td>\n<td>Adjust amounts to balance</td>\n</tr>\n<tr>\n<td>Account Type Violation</td>\n<td><code>ENTRY_005</code></td>\n<td>&quot;Cannot post credit to asset account without business justification&quot;</td>\n<td>Review account types</td>\n</tr>\n<tr>\n<td>Authorization Failure</td>\n<td><code>ENTRY_006</code></td>\n<td>&quot;User lacks permission to post to restricted account &#39;5001-SALARY&#39;&quot;</td>\n<td>Request authorization</td>\n</tr>\n</tbody></table>\n<p><strong>Account Type Compatibility</strong> validation ensures that debits and credits are posted to appropriate account types according to normal balance rules. While the system allows unusual postings (like crediting an asset account for a return), it flags these for additional review. The validation logic understands that asset and expense accounts are debit-normal, while liability, equity, and revenue accounts are credit-normal.</p>\n<p>The validation engine also performs <strong>Cross-Entry Consistency</strong> checks that look for suspicious patterns across multiple entry lines. For example, it flags entries that post to both cash and accounts receivable for the same customer, which might indicate a duplicate payment recording. These soft validations generate warnings rather than errors, alerting users to potential issues while allowing the entry to proceed if confirmed.</p>\n<h3 id=\"atomic-transaction-posting\">Atomic Transaction Posting</h3>\n<p>Atomic transaction posting ensures that journal entries are recorded as indivisible units - either all changes succeed together, or none of them happen at all. Think of it like a bank wire transfer: the money must leave one account and arrive in the other account simultaneously. There&#39;s no intermediate state where the money has left but not yet arrived, because that would create an impossible situation where money vanishes from the system.</p>\n<p>The posting engine wraps all journal entry operations within a database transaction boundary, leveraging the ACID properties of the underlying database to maintain consistency. When a journal entry is posted, the system must update multiple tables: the journal entry itself changes from <code>DRAFT</code> to <code>POSTED</code> status, entry lines are written to the ledger, account balances are updated, and audit records are created. All of these changes must succeed atomically.</p>\n<blockquote>\n<p><strong>Decision: Database Transaction Boundaries</strong></p>\n<ul>\n<li><strong>Context</strong>: Journal entries involve multiple database table updates that must remain consistent</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Update tables sequentially without transactions (unsafe)</li>\n<li>Use database transactions for atomicity (safe but might impact performance)  </li>\n<li>Use application-level compensation logic to handle partial failures</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use database transactions with proper isolation levels</li>\n<li><strong>Rationale</strong>: Database transactions provide proven ACID guarantees; performance impact is manageable for accounting workloads; much simpler than building compensation logic</li>\n<li><strong>Consequences</strong>: Simplified error handling and guaranteed consistency at the cost of holding database locks during posting operations</li>\n</ul>\n</blockquote>\n<p>The posting workflow follows a carefully orchestrated sequence that minimizes the time spent holding database locks while ensuring complete atomicity. The process begins by validating the journal entry one final time within the transaction context, ensuring that no concurrent changes have invalidated the entry since the initial validation.</p>\n<p><strong>Posting Workflow Steps:</strong></p>\n<ol>\n<li><p><strong>Begin Database Transaction</strong> - Start an explicit database transaction with <code>READ_COMMITTED</code> isolation level to prevent dirty reads while allowing maximum concurrency for other operations.</p>\n</li>\n<li><p><strong>Lock Journal Entry</strong> - Acquire a row-level lock on the journal entry record using <code>SELECT FOR UPDATE</code> to prevent concurrent modifications during posting.</p>\n</li>\n<li><p><strong>Re-validate Entry Status</strong> - Verify that the entry is still in <code>DRAFT</code> status and hasn&#39;t been posted or deleted by another process.</p>\n</li>\n<li><p><strong>Validate Account States</strong> - Re-check that all referenced accounts are still active and accessible within the transaction context.</p>\n</li>\n<li><p><strong>Calculate Running Balances</strong> - Compute the new account balances that will result from this journal entry, checking for any account limits or overdraft conditions.</p>\n</li>\n<li><p><strong>Update Journal Entry Status</strong> - Change the entry status from <code>DRAFT</code> to <code>POSTED</code> and record the posting timestamp and user information.</p>\n</li>\n<li><p><strong>Insert Entry Lines</strong> - Write all entry line records to the ledger with their final debit and credit amounts.</p>\n</li>\n<li><p><strong>Update Account Balances</strong> - Increment or decrement the running balance tables for all affected accounts.</p>\n</li>\n<li><p><strong>Create Audit Records</strong> - Generate audit trail entries documenting the posting operation and all changes made.</p>\n</li>\n<li><p><strong>Commit Transaction</strong> - If all updates succeed, commit the database transaction to make all changes permanent.</p>\n</li>\n</ol>\n<p>The posting engine maintains strict error handling throughout this workflow. If any step fails - whether due to database constraints, business rule violations, or system errors - the entire transaction is rolled back, leaving the database in exactly the same state as before the posting attempt. This rollback behavior prevents partial posts that could corrupt the ledger.</p>\n<table>\n<thead>\n<tr>\n<th>Posting Step</th>\n<th>Failure Scenario</th>\n<th>Error Detection</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Begin Transaction</td>\n<td>Database connection lost</td>\n<td>Exception thrown</td>\n<td>Retry with new connection</td>\n</tr>\n<tr>\n<td>Lock Entry</td>\n<td>Entry already locked</td>\n<td>Lock timeout</td>\n<td>Retry after delay</td>\n</tr>\n<tr>\n<td>Status Validation</td>\n<td>Entry already posted</td>\n<td>Status mismatch</td>\n<td>Return &quot;already posted&quot; error</td>\n</tr>\n<tr>\n<td>Account Validation</td>\n<td>Account deactivated</td>\n<td>Business rule violation</td>\n<td>Rollback and return validation error</td>\n</tr>\n<tr>\n<td>Balance Calculation</td>\n<td>Integer overflow</td>\n<td>Arithmetic exception</td>\n<td>Rollback and return limit exceeded error</td>\n</tr>\n<tr>\n<td>Entry Line Insert</td>\n<td>Constraint violation</td>\n<td>Database error</td>\n<td>Rollback and return data integrity error</td>\n</tr>\n<tr>\n<td>Balance Update</td>\n<td>Optimistic lock failure</td>\n<td>Concurrent modification</td>\n<td>Rollback and retry entire operation</td>\n</tr>\n<tr>\n<td>Audit Record Creation</td>\n<td>Storage full</td>\n<td>Write failure</td>\n<td>Rollback and return system error</td>\n</tr>\n<tr>\n<td>Commit</td>\n<td>Network partition</td>\n<td>Timeout exception</td>\n<td>Transaction automatically rolled back</td>\n</tr>\n</tbody></table>\n<p><strong>Concurrency Control</strong> during posting uses a combination of database locks and optimistic concurrency techniques. The system acquires minimal locks for the shortest possible time, holding row-level locks only on the specific journal entry being posted. Account balance updates use optimistic locking with version numbers to detect concurrent modifications without blocking other transactions.</p>\n<p>The posting engine also implements <strong>Retry Logic</strong> for handling transient failures like lock timeouts or temporary network issues. The retry mechanism uses exponential backoff to avoid overwhelming the database during high-load periods. However, the system never retries operations that might have side effects - if a posting operation begins but the result is uncertain due to network issues, the system flags the entry for manual review rather than risking duplicate posts.</p>\n<p><strong>Transaction Isolation</strong> is carefully configured to balance consistency with performance. The posting engine uses <code>READ_COMMITTED</code> isolation level for most operations, which prevents dirty reads while allowing maximum concurrency. For certain critical operations like balance calculations, the system temporarily escalates to <code>REPEATABLE_READ</code> to ensure consistent snapshots across multiple queries within the same transaction.</p>\n<h3 id=\"idempotency-and-duplicate-prevention\">Idempotency and Duplicate Prevention</h3>\n<p>Idempotency ensures that posting the same journal entry multiple times has the same effect as posting it once. Think of it like pressing an elevator button - whether you press it once or frantically mash it ten times, the elevator comes to your floor exactly once. This property is crucial for accounting systems because network failures, system crashes, and user impatience can all lead to duplicate submission attempts that must not result in duplicate financial records.</p>\n<p>The idempotency system operates through a combination of unique constraints, idempotency keys, and state tracking that makes it mathematically impossible to create duplicate entries. Every journal entry receives a unique identifier when first created, and this identifier becomes the definitive source of truth for determining whether an entry has already been processed.</p>\n<blockquote>\n<p><strong>Decision: Idempotency Key Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Journal entries may be submitted multiple times due to network retries, user impatience, or system failures</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Database unique constraints only (limited protection)</li>\n<li>Client-provided idempotency keys (flexible but requires client cooperation)</li>\n<li>Server-generated deterministic IDs based on entry content (automatic but complex)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Combination of server-generated UUIDs with optional client idempotency keys</li>\n<li><strong>Rationale</strong>: Server-generated UUIDs prevent accidental duplicates; client keys enable intentional retry logic; database constraints provide final safety net</li>\n<li><strong>Consequences</strong>: Robust duplicate prevention with minimal client complexity; slightly more storage overhead for tracking idempotency state</li>\n</ul>\n</blockquote>\n<p>The idempotency system maintains a three-tier defense against duplicate entries. The first tier uses <strong>Unique Identifiers</strong> generated by the server when a journal entry is first created. These UUIDs are cryptographically random and have negligible collision probability, ensuring that each entry receives a globally unique identifier that can never be accidentally reused.</p>\n<p><strong>Idempotency Key Processing:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Idempotency Mechanism</th>\n<th>Scope</th>\n<th>Detection Method</th>\n<th>Prevention Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>UUID Primary Key</td>\n<td>Single entry</td>\n<td>Database unique constraint</td>\n<td>Reject with existing entry ID</td>\n</tr>\n<tr>\n<td>Client Idempotency Key</td>\n<td>API request</td>\n<td>Lookup in idempotency table</td>\n<td>Return cached result</td>\n</tr>\n<tr>\n<td>Content Hash</td>\n<td>Entry data</td>\n<td>SHA-256 of normalized entry</td>\n<td>Flag as potential duplicate</td>\n</tr>\n<tr>\n<td>Temporal Window</td>\n<td>Time-based</td>\n<td>Recent entries within threshold</td>\n<td>Require confirmation</td>\n</tr>\n<tr>\n<td>User Session</td>\n<td>Single user</td>\n<td>Track submissions per session</td>\n<td>Rate limiting</td>\n</tr>\n<tr>\n<td>Reference Number</td>\n<td>Business document</td>\n<td>External reference uniqueness</td>\n<td>Business rule validation</td>\n</tr>\n</tbody></table>\n<p>The second tier uses <strong>Client Idempotency Keys</strong> that allow external systems to provide their own duplicate detection mechanisms. When a client submits a journal entry with an idempotency key, the system checks whether that key has been used before within a configurable time window (typically 24 hours). If the key exists, the system returns the result of the original operation rather than attempting to create a duplicate entry.</p>\n<p><strong>Content-Based Duplicate Detection</strong> forms the third tier of protection, analyzing the actual journal entry data to identify potential duplicates even when identifiers differ. The system computes a SHA-256 hash of the normalized entry content (accounts, amounts, description, and reference number) and checks whether an identical entry has been posted recently. This catches scenarios where the same business transaction gets entered multiple times through different channels.</p>\n<p>The idempotency system maintains detailed tracking of submission attempts and their outcomes. Each API request receives a unique request ID that gets logged with the journal entry, creating a complete audit trail of who submitted what when. This tracking enables investigation of duplicate submission patterns and helps identify problematic client integrations.</p>\n<p><strong>Idempotency State Management:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Entry States for Idempotency:\n- SUBMITTED: Request received, idempotency check in progress\n- VALIDATED: Entry passed validation, ready for posting\n- POSTING: Atomic posting operation in progress  \n- POSTED: Entry successfully recorded in ledger\n- FAILED: Posting failed, entry remains in draft state\n- DUPLICATE: Rejected as duplicate of existing entry</code></pre></div>\n\n<p>When a duplicate submission is detected, the system&#39;s response depends on the current state of the original entry. If the original entry was successfully posted, the system returns a success response with the existing entry details. If the original entry failed to post, the system can either retry the posting operation or return the original failure details, depending on the type of failure.</p>\n<p><strong>Rate Limiting</strong> works in conjunction with idempotency to prevent abuse and accidental denial-of-service attacks. The system tracks submission rates per user, per API client, and per IP address, applying increasingly strict limits when unusual patterns are detected. These limits prevent scenarios where a malfunctioning client overwhelms the system with duplicate requests.</p>\n<p>The idempotency system also handles <strong>Partial Failures</strong> gracefully. If a posting operation begins but fails partway through (for example, due to a network interruption), the system marks the entry with a special <code>POSTING_INTERRUPTED</code> status. Subsequent attempts to post the same entry first check whether the original posting completed successfully, using database consistency checks to determine the actual state.</p>\n<p><strong>Time Window Management</strong> ensures that idempotency data doesn&#39;t accumulate indefinitely. The system maintains idempotency keys and content hashes for a configurable period (typically 30 days) after which they are eligible for cleanup. This balances duplicate protection with storage efficiency, preventing the idempotency tables from growing without bound.</p>\n<h3 id=\"entry-reversal-mechanism\">Entry Reversal Mechanism</h3>\n<p>Entry reversal provides the mechanism for correcting mistakes in posted journal entries while preserving the complete audit trail. Think of it like writing a check to undo a previous check - you can&#39;t tear up the original check once it&#39;s been cashed, but you can write another check that perfectly cancels out its effect. This approach maintains the immutable nature of the audit trail while providing the practical ability to correct errors.</p>\n<p>The reversal system creates a new journal entry that exactly offsets the original entry, effectively bringing the account balances back to their pre-transaction state. However, both the original entry and the reversal entry remain permanently in the ledger, providing a complete historical record of what happened and when it was corrected.</p>\n<blockquote>\n<p><strong>Decision: Reversal vs Modification Approach</strong></p>\n<ul>\n<li><strong>Context</strong>: Posted journal entries contain errors that need correction while maintaining audit trail integrity</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Allow direct modification of posted entries (breaks audit trail)</li>\n<li>Create offsetting reversal entries (preserves history but increases entry volume)</li>\n<li>Mark entries as &quot;corrected&quot; with pointers to replacement entries (complex tracking)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Create offsetting reversal entries with clear linkage to original entries</li>\n<li><strong>Rationale</strong>: Preserves complete audit trail; follows standard accounting practices; simple to implement and understand; provides clear before/after balance reconciliation</li>\n<li><strong>Consequences</strong>: Higher volume of journal entries but complete audit transparency; slightly more complex balance calculations but better compliance</li>\n</ul>\n</blockquote>\n<p>The reversal mechanism operates through a carefully controlled workflow that ensures the reversal is valid, properly authorized, and correctly linked to the original entry. The system prevents common mistakes like attempting to reverse an entry that has already been reversed or creating partial reversals that don&#39;t fully offset the original amounts.</p>\n<p><strong>Reversal Entry Creation Process:</strong></p>\n<ol>\n<li><p><strong>Locate Original Entry</strong> - Verify that the specified journal entry exists and is in <code>POSTED</code> status. Entries in <code>DRAFT</code> status should be modified directly rather than reversed.</p>\n</li>\n<li><p><strong>Validate Reversal Authorization</strong> - Confirm that the requesting user has permission to reverse entries, particularly for entries posted by other users or in previous accounting periods.</p>\n</li>\n<li><p><strong>Check Previous Reversals</strong> - Ensure that the original entry hasn&#39;t already been reversed. The system maintains parent-child relationships between original entries and their reversals.</p>\n</li>\n<li><p><strong>Generate Reversal Entry</strong> - Create a new journal entry with all debit and credit amounts flipped from the original entry. Debits become credits and credits become debits, with identical amounts and account references.</p>\n</li>\n<li><p><strong>Link Entries</strong> - Establish bidirectional references between the original entry and reversal entry, enabling navigation in both directions and preventing duplicate reversals.</p>\n</li>\n<li><p><strong>Post Reversal Entry</strong> - Submit the reversal entry through the normal posting workflow, including full validation and atomic transaction processing.</p>\n</li>\n<li><p><strong>Update Entry Status</strong> - Mark the original entry with <code>REVERSED</code> status while preserving its original posting information and audit trail.</p>\n</li>\n</ol>\n<p>The reversal system maintains strict referential integrity between original entries and their reversals. Each reversal entry contains a <code>ReversalOfID</code> field that points to the original entry, while the original entry&#39;s <code>ReversedByID</code> field points to the reversal. This bidirectional linking enables efficient queries for finding related entries and prevents orphaned reversals.</p>\n<table>\n<thead>\n<tr>\n<th>Reversal Field</th>\n<th>Purpose</th>\n<th>Example Value</th>\n<th>Constraints</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ReversalOfID</code></td>\n<td>Links reversal to original entry</td>\n<td><code>&quot;entry-12345&quot;</code></td>\n<td>Must reference valid posted entry</td>\n</tr>\n<tr>\n<td><code>ReversedByID</code></td>\n<td>Links original to its reversal</td>\n<td><code>&quot;entry-12389&quot;</code></td>\n<td>Must reference valid reversal entry</td>\n</tr>\n<tr>\n<td><code>ReversalReason</code></td>\n<td>Explains why reversal was needed</td>\n<td><code>&quot;Incorrect customer allocation&quot;</code></td>\n<td>Required for audit purposes</td>\n</tr>\n<tr>\n<td><code>ReversalDate</code></td>\n<td>When reversal was created</td>\n<td><code>2024-01-15</code></td>\n<td>Cannot be before original posting date</td>\n</tr>\n<tr>\n<td><code>AuthorizedBy</code></td>\n<td>Who approved the reversal</td>\n<td><code>&quot;manager@company.com&quot;</code></td>\n<td>May require elevated permissions</td>\n</tr>\n</tbody></table>\n<p><strong>Partial Reversal Support</strong> allows reversing only specific line items from a multi-line journal entry, which is essential for correcting entries where only some of the postings were incorrect. The system creates a reversal entry that offsets only the problematic line items, leaving the correct portions of the original entry intact. This approach maintains double-entry balance while providing surgical correction capabilities.</p>\n<p>The reversal mechanism includes <strong>Time Period Controls</strong> that can restrict reversals based on accounting period rules. For example, once a month has been closed, reversals of entries from that month might require additional authorization or be prohibited entirely. These controls help maintain the integrity of financial reporting periods and comply with auditing requirements.</p>\n<p><strong>Reversal Validation Logic:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Validation Check</th>\n<th>Purpose</th>\n<th>Failure Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entry Exists</td>\n<td>Verify target entry is valid</td>\n<td>Return &quot;Entry not found&quot; error</td>\n</tr>\n<tr>\n<td>Entry Status</td>\n<td>Confirm entry is posted</td>\n<td>Return &quot;Cannot reverse draft entry&quot; error</td>\n</tr>\n<tr>\n<td>Already Reversed</td>\n<td>Prevent duplicate reversals</td>\n<td>Return &quot;Entry already reversed&quot; error</td>\n</tr>\n<tr>\n<td>Period Status</td>\n<td>Check if accounting period allows reversals</td>\n<td>Return &quot;Period closed&quot; error</td>\n</tr>\n<tr>\n<td>User Authorization</td>\n<td>Verify reversal permissions</td>\n<td>Return &quot;Insufficient privileges&quot; error</td>\n</tr>\n<tr>\n<td>Amount Limits</td>\n<td>Check if reversal exceeds user limits</td>\n<td>Require additional approval</td>\n</tr>\n<tr>\n<td>Account Status</td>\n<td>Ensure target accounts are still active</td>\n<td>Return &quot;Account inactive&quot; error</td>\n</tr>\n</tbody></table>\n<p><strong>Audit Trail Enhancement</strong> for reversals provides extra documentation beyond the standard journal entry audit trail. The system records the business reason for the reversal, the authorization chain, and any supporting documentation references. This enhanced audit trail helps explain to future auditors not just what was changed, but why it was changed and who authorized the change.</p>\n<p>The reversal system also supports <strong>Batch Reversals</strong> for scenarios where multiple related entries need to be reversed simultaneously. This is particularly useful when correcting systematic errors that affected multiple transactions. The batch reversal operation ensures that all reversals succeed or fail together, preventing partial corrections that could leave the books in an inconsistent state.</p>\n<p><strong>Error Recovery</strong> within the reversal mechanism handles edge cases like system failures during the reversal process. If a reversal operation fails partway through, the system can detect incomplete reversals and either complete them or clean up partial state. This recovery logic prevents situations where the original entry is marked as reversed but the offsetting entry was never created.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The transaction recording engine requires careful integration of validation logic, database transaction management, and state tracking. This implementation provides complete working components for the infrastructure pieces while leaving the core business logic as guided exercises for learners.</p>\n<h4 id=\"a-technology-recommendations\">A. Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database</td>\n<td>PostgreSQL with <code>database/sql</code></td>\n<td>PostgreSQL with <code>pgx</code> driver for advanced features</td>\n</tr>\n<tr>\n<td>Validation</td>\n<td>Custom validation with <code>go-playground/validator</code></td>\n<td>Rule engine with <code>casbin</code> for complex authorization</td>\n</tr>\n<tr>\n<td>UUID Generation</td>\n<td><code>google/uuid</code> package</td>\n<td><code>crypto/rand</code> with custom format for sequential ordering</td>\n</tr>\n<tr>\n<td>Decimal Math</td>\n<td><code>decimal</code> package from <code>shopspring</code></td>\n<td>Custom fixed-point arithmetic for maximum precision</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard <code>log/slog</code> package</td>\n<td>Structured logging with <code>zerolog</code> or <code>logrus</code></td>\n</tr>\n<tr>\n<td>Monitoring</td>\n<td>Basic metrics with <code>expvar</code></td>\n<td>Full observability with <code>prometheus</code> and <code>jaeger</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"b-recommended-filemodule-structure\">B. Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/engine/\n  transaction.go           ← Core TransactionEngine interface\n  transaction_test.go      ← Engine integration tests\n  validator/\n    validator.go           ← Multi-stage validation pipeline\n    rules.go               ← Business rule implementations\n    validator_test.go      ← Validation unit tests\n  posting/\n    poster.go              ← Atomic posting engine\n    idempotency.go         ← Duplicate prevention logic\n    poster_test.go         ← Posting workflow tests\n  reversal/\n    reversal.go            ← Entry reversal mechanism\n    reversal_test.go       ← Reversal logic tests\n  storage/\n    queries.go             ← Database query implementations\n    migrations/            ← Database schema migrations\n      001_journal_entries.sql\n      002_idempotency_keys.sql</code></pre></div>\n\n<h4 id=\"c-infrastructure-starter-code\">C. Infrastructure Starter Code</h4>\n<p><strong>Database Connection Wrapper</strong> (Complete implementation):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> storage</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/lib/pq</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DBManager handles database connections and transaction management</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DBManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewDBManager creates a new database manager with connection pooling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewDBManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> DatabaseConfig</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DBManager</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    connStr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"host=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> port=</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> user=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> password=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> dbname=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\"> sslmode=</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config.Host, config.Port, config.User, config.Password, config.DBName, config.SSLMode)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sql.</span><span style=\"color:#B392F0\">Open</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"postgres\"</span><span style=\"color:#E1E4E8\">, connStr)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to open database: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Configure connection pool for accounting workloads</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">SetMaxOpenConns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">25</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">SetMaxIdleConns</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db.</span><span style=\"color:#B392F0\">SetConnMaxLifetime</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Minute)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Ping</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to ping database: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">DBManager</span><span style=\"color:#E1E4E8\">{db: db}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WithTransaction executes a function within a database transaction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">dm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DBManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WithTransaction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fn</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Tx</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tx, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> dm.db.</span><span style=\"color:#B392F0\">BeginTx</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TxOptions</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Isolation: sql.LevelReadCommitted,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ReadOnly:  </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to begin transaction: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> recover</span><span style=\"color:#E1E4E8\">(); p </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tx.</span><span style=\"color:#B392F0\">Rollback</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            panic</span><span style=\"color:#E1E4E8\">(p) </span><span style=\"color:#6A737D\">// Re-panic after rollback</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> fn</span><span style=\"color:#E1E4E8\">(tx); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> rbErr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tx.</span><span style=\"color:#B392F0\">Rollback</span><span style=\"color:#E1E4E8\">(); rbErr </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"transaction error: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">, rollback error: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err, rbErr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tx.</span><span style=\"color:#B392F0\">Commit</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to commit transaction: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Close closes the database connection pool</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">dm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DBManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> dm.db.</span><span style=\"color:#B392F0\">Close</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Idempotency Key Manager</strong> (Complete implementation):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> posting</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/sha256</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/hex</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IdempotencyManager prevents duplicate journal entry submissions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IdempotencyManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IdempotencyRecord tracks submission attempts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IdempotencyRecord</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Key        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"key\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntryID    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"entry_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"status\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Result     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"result,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExpiresAt  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"expires_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewIdempotencyManager creates a new idempotency manager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewIdempotencyManager</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IdempotencyManager</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">IdempotencyManager</span><span style=\"color:#E1E4E8\">{db: db}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CheckIdempotency verifies if a request has been processed before</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">im </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IdempotencyManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CheckIdempotency</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">key</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IdempotencyRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> record </span><span style=\"color:#B392F0\">IdempotencyRecord</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    query </span><span style=\"color:#F97583\">:=</span><span style=\"color:#9ECBFF\"> `SELECT key, entry_id, status, result, created_at, expires_at </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">              FROM idempotency_keys </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">              WHERE key = $1 AND expires_at > NOW()`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    row </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> im.db.</span><span style=\"color:#B392F0\">QueryRowContext</span><span style=\"color:#E1E4E8\">(ctx, query, key)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> row.</span><span style=\"color:#B392F0\">Scan</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">record.Key, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">record.EntryID, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">record.Status, </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    &#x26;</span><span style=\"color:#E1E4E8\">record.Result, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">record.CreatedAt, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#E1E4E8\">record.ExpiresAt)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> sql.ErrNoRows {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#6A737D\"> // No existing record found</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to check idempotency: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">record, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecordRequest stores a new idempotency record</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">im </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IdempotencyManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecordRequest</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entryID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ttlHours</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    query </span><span style=\"color:#F97583\">:=</span><span style=\"color:#9ECBFF\"> `INSERT INTO idempotency_keys (key, entry_id, status, created_at, expires_at)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">              VALUES ($1, $2, 'SUBMITTED', NOW(), NOW() + INTERVAL '</span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> hours')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">              ON CONFLICT (key) DO NOTHING`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> im.db.</span><span style=\"color:#B392F0\">ExecContext</span><span style=\"color:#E1E4E8\">(ctx, fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(query, ttlHours), key, entryID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to record idempotency key: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// UpdateStatus updates the status of an idempotency record</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">im </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IdempotencyManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdateStatus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">key</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">status</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">result</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    query </span><span style=\"color:#F97583\">:=</span><span style=\"color:#9ECBFF\"> `UPDATE idempotency_keys </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">              SET status = $2, result = $3, updated_at = NOW()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">              WHERE key = $1`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> im.db.</span><span style=\"color:#B392F0\">ExecContext</span><span style=\"color:#E1E4E8\">(ctx, query, key, status, result)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to update idempotency status: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateContentHash creates a deterministic hash from journal entry content</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">im </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IdempotencyManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateContentHash</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Create normalized representation for consistent hashing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    normalized </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Date        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"date\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Description </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"description\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Lines       []</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"lines\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Date:        entry.Date.</span><span style=\"color:#B392F0\">Format</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"2006-01-02\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Description: entry.Description,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Lines:       </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(entry.Lines)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, line </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> entry.Lines {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        normalized.Lines[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"account_id\"</span><span style=\"color:#E1E4E8\">: line.AccountID,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"debit\"</span><span style=\"color:#E1E4E8\">:      line.DebitAmount,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"credit\"</span><span style=\"color:#E1E4E8\">:     line.CreditAmount,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data, _ </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> json.</span><span style=\"color:#B392F0\">Marshal</span><span style=\"color:#E1E4E8\">(normalized)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hash </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> sha256.</span><span style=\"color:#B392F0\">Sum256</span><span style=\"color:#E1E4E8\">(data)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> hex.</span><span style=\"color:#B392F0\">EncodeToString</span><span style=\"color:#E1E4E8\">(hash[:])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"d-core-logic-skeleton-code\">D. Core Logic Skeleton Code</h4>\n<p><strong>Journal Entry Validator</strong> (Signatures with detailed TODOs):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> validator</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EntryValidator implements multi-stage journal entry validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EntryValidator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    accountService </span><span style=\"color:#B392F0\">AccountService</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    authService    </span><span style=\"color:#B392F0\">AuthorizationService</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidationError represents a validation failure with context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ValidationError</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Code    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"code\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Field   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"field\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Message </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `json:\"message\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Value   </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"value,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidationResult contains all validation errors and warnings</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ValidationResult</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsValid  </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">               `json:\"is_valid\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Errors   []</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#9ECBFF\">  `json:\"errors\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Warnings []</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#9ECBFF\">  `json:\"warnings\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Validate performs comprehensive journal entry validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ev </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EntryValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Validate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ValidationResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ValidationResult</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        IsValid:  </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Errors:   </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Warnings: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate entry structure (non-empty fields, valid formats)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check entry.Date is not zero value and not in future</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify entry.Description is not empty and within length limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Ensure entry.Lines has at least 2 line items</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Validate each line has either DebitAmount OR CreditAmount (not both, not neither)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate account references and status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - For each line in entry.Lines, verify AccountID exists in database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check that all referenced accounts are in Active status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify accounts belong to correct organization/company context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Collect any missing or inactive accounts into validation errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Perform balance validation (debits must equal credits)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Group entry lines by currency (handle multi-currency entries)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Sum all debit amounts and all credit amounts within each currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify that TotalDebits() equals TotalCredits() for each currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Add ENTRY_004 error if any currency is unbalanced</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate account type compatibility</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check that debit entries to liability/equity/revenue accounts are intentional</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Flag credit entries to asset/expense accounts for review</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - These generate warnings rather than errors (unusual but sometimes valid)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify user authorization</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check if current user can post to all referenced accounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Some accounts may be restricted (payroll, executive compensation)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Add ENTRY_006 error if user lacks permission for any account</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Check business rule compliance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Validate posting date against accounting period status (not closed)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check for required approval workflows based on entry amount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify compliance with any account-specific posting rules</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateStructure performs basic structural validation without database access</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ev </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EntryValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateStructure</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) []</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> errors []</span><span style=\"color:#B392F0\">ValidationError</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate entry-level fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - entry.Date must be valid date, not zero, not more than 1 day in future</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - entry.Description must be non-empty, max 500 characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - entry.Reference should be non-empty if provided, max 100 characters</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate entry lines collection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - entry.Lines must have at least 2 items (double-entry requirement)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - LineNumber fields must be sequential starting from 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - No duplicate LineNumber values allowed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate individual entry lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Each line must have exactly one of DebitAmount or CreditAmount (not both)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Amounts must be positive (zero amounts not allowed)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Currency fields must be valid ISO currency codes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - AccountID must be valid UUID format</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateBalance ensures debits equal credits across all currencies</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ev </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EntryValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Group entry lines by currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Create map[string]Money for debit totals by currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Create map[string]Money for credit totals by currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Iterate through entry.Lines and accumulate amounts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate totals for each currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Use Money.Add() method to sum amounts safely</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Handle decimal precision correctly to avoid rounding errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Track any arithmetic errors during summation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Compare debit and credit totals</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - For each currency, verify TotalDebits.Amount.Equal(TotalCredits.Amount)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - If any currency is unbalanced, return ENTRY_004 validation error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Include actual amounts in error message for debugging</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#B392F0\"> ValidationError</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#6A737D\"> // Return error and isValid flag</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Transaction Poster</strong> (Signatures with detailed TODOs):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> posting</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TransactionPoster handles atomic journal entry posting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TransactionPoster</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db         </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    validator  </span><span style=\"color:#B392F0\">EntryValidator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    idempotency </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IdempotencyManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PostingResult contains the outcome of a posting operation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PostingResult</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntryID     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"entry_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"status\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PostedAt    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"posted_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Message     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"message,omitempty\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Duplicate   </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">      `json:\"duplicate\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PostEntry atomically posts a journal entry with full validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionPoster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PostEntry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">idempotencyKey</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PostingResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check for duplicate submission using idempotency key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Call tp.idempotency.CheckIdempotency() with provided key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - If existing record found and status is \"POSTED\", return success with existing entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - If existing record found and status is \"FAILED\", decide whether to retry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Record new idempotency key if this is first submission</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate the journal entry one final time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Call tp.validator.Validate() to ensure entry is still valid</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Account status might have changed since initial validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Return validation errors immediately without starting transaction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Begin database transaction and acquire locks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Use tp.db.BeginTx() with READ_COMMITTED isolation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Acquire row lock on journal entry with SELECT FOR UPDATE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify entry is still in DRAFT status and not concurrently modified</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Perform atomic posting operations within transaction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Update entry status from DRAFT to POSTED with posting timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Insert all entry lines into journal_entry_lines table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Update running balances for all affected accounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Create audit trail records for the posting operation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Handle transaction completion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - If all operations succeed, commit the transaction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - If any operation fails, rollback and return appropriate error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Update idempotency record with final status and result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Return PostingResult with complete operation details</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">PostingResult</span><span style=\"color:#E1E4E8\">{}, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PostEntryWithinTransaction posts an entry within an existing transaction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionPoster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PostEntryWithinTransaction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tx</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Tx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Update journal entry status to POSTED</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Execute UPDATE statement to change status from DRAFT to POSTED</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Set posted_at timestamp and posted_by user information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Use tx.ExecContext() to run within provided transaction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Insert entry lines into ledger</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Prepare INSERT statement for journal_entry_lines table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Iterate through entry.Lines and insert each line with proper amounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Ensure LineNumber fields are set correctly for sorting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Update account running balances</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - For each affected account, calculate balance change from this entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Use optimistic locking to prevent concurrent balance corruption</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Handle both debit and credit amounts according to account normal balance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create audit trail entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Record posting operation in audit_log table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Include entry ID, user, timestamp, and operation details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Store before/after values for account balances that changed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateAccountsWithinTx verifies account status within transaction context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionPoster</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateAccountsWithinTx</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tx</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Tx</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountIDs</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Query account status for all referenced accounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Use SELECT statement with WHERE account_id = ANY($1) for efficiency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check that all accounts exist and are in ACTIVE status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Verify accounts are not marked for closure or archival</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate account permissions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Check if current user has posting privileges for each account</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Some accounts may require special authorization (restricted accounts)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // - Return detailed error if any account access is denied</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"e-language-specific-hints\">E. Language-Specific Hints</h4>\n<p><strong>Go-Specific Implementation Tips:</strong></p>\n<ul>\n<li>Use <code>context.Context</code> throughout for request tracing and cancellation support</li>\n<li>Implement proper error wrapping with <code>fmt.Errorf(&quot;operation failed: %w&quot;, err)</code> for error chains</li>\n<li>Use <code>database/sql.TxOptions</code> to set appropriate isolation levels for accounting transactions</li>\n<li>Leverage <code>sync.Pool</code> for reusing validation result objects under high load</li>\n<li>Use <code>time.Time.UTC()</code> consistently for all timestamp storage to avoid timezone issues</li>\n<li>Implement <code>String()</code> methods on error types for better debugging output</li>\n<li>Use <code>atomic</code> package operations for updating in-memory statistics counters</li>\n<li>Consider using <code>errgroup</code> for parallel validation operations when validating large batches</li>\n</ul>\n<p><strong>Database-Specific Hints:</strong></p>\n<ul>\n<li>Use PostgreSQL <code>NUMERIC</code> type for monetary amounts to avoid floating-point precision issues</li>\n<li>Implement proper foreign key constraints between <code>journal_entries</code> and <code>entry_lines</code> tables</li>\n<li>Create compound indexes on <code>(account_id, posting_date)</code> for efficient balance queries</li>\n<li>Use <code>SELECT FOR UPDATE SKIP LOCKED</code> for high-concurrency posting scenarios</li>\n<li>Implement check constraints to ensure <code>debit_amount</code> and <code>credit_amount</code> are mutually exclusive</li>\n<li>Use database triggers sparingly; prefer application-level logic for better testability</li>\n</ul>\n<h4 id=\"f-milestone-checkpoints\">F. Milestone Checkpoints</h4>\n<p><strong>After implementing Journal Entry Validation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/engine/validator/...</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p>Expected output should show tests passing for:</p>\n<ul>\n<li>Structure validation catching empty descriptions and invalid dates</li>\n<li>Balance validation detecting unbalanced entries (debits ≠ credits)  </li>\n<li>Account validation rejecting references to non-existent accounts</li>\n<li>Currency validation ensuring consistent currency usage within entries</li>\n</ul>\n<p>Manual verification:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test validation API endpoint</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8080/api/validate-entry</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -d</span><span style=\"color:#9ECBFF\"> '{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"date\": \"2024-01-15\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"description\": \"Test entry\",</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"lines\": [</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">      {\"account_id\": \"1001-CASH\", \"debit_amount\": {\"amount\": \"100.00\", \"currency\": \"USD\"}},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">      {\"account_id\": \"4001-REVENUE\", \"credit_amount\": {\"amount\": \"100.00\", \"currency\": \"USD\"}}</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    ]</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  }'</span></span></code></pre></div>\n\n<p>Should return validation success. Try with unbalanced amounts to verify error detection.</p>\n<p><strong>After implementing Atomic Transaction Posting:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#9ECBFF\"> ./internal/engine/posting/...</span><span style=\"color:#79B8FF\"> -race</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p>The race detector should find no data races. Test concurrent posting:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run multiple concurrent posts to verify atomicity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#B392F0\">1..10}</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#F97583\">do</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8080/api/post-entry</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    -H</span><span style=\"color:#9ECBFF\"> \"Content-Type: application/json\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    -H</span><span style=\"color:#9ECBFF\"> \"Idempotency-Key: test-</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    -d</span><span style=\"color:#9ECBFF\"> '{\"date\":\"2024-01-15\",\"description\":\"Concurrent test '</span><span style=\"color:#E1E4E8\">$i</span><span style=\"color:#9ECBFF\">'\",\"lines\":[...]}'</span><span style=\"color:#E1E4E8\"> &#x26;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">done</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">wait</span></span></code></pre></div>\n\n<p>Verify that all entries posted successfully or failed cleanly (no partial posts).</p>\n<p><strong>After implementing Idempotency and Duplicate Prevention:</strong></p>\n<p>Test duplicate submission handling:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Submit same entry twice with same idempotency key</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">IDEMPOTENCY_KEY</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"test-duplicate-$(</span><span style=\"color:#B392F0\">date</span><span style=\"color:#9ECBFF\"> +%s)\"</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8080/api/post-entry</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -H</span><span style=\"color:#9ECBFF\"> \"Idempotency-Key: </span><span style=\"color:#E1E4E8\">$IDEMPOTENCY_KEY</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -d</span><span style=\"color:#9ECBFF\"> '{\"date\":\"2024-01-15\",\"description\":\"Duplicate test\",\"lines\":[...]}'</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#9ECBFF\"> http://localhost:8080/api/post-entry</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -H</span><span style=\"color:#9ECBFF\"> \"Idempotency-Key: </span><span style=\"color:#E1E4E8\">$IDEMPOTENCY_KEY</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\"> \\</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  -d</span><span style=\"color:#9ECBFF\"> '{\"date\":\"2024-01-15\",\"description\":\"Duplicate test\",\"lines\":[...]}'</span></span></code></pre></div>\n\n<p>Second request should return same result as first without creating duplicate entry.</p>\n<h4 id=\"g-debugging-tips\">G. Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Validation passes but posting fails</td>\n<td>Account status changed between validation and posting</td>\n<td>Check account active status in transaction log</td>\n<td>Re-validate accounts within posting transaction</td>\n</tr>\n<tr>\n<td>Unbalanced trial balance after posting</td>\n<td>Rounding errors in decimal arithmetic or incorrect account type handling</td>\n<td>Query sum of all debits and credits, check for currency inconsistencies</td>\n<td>Use proper decimal.Decimal arithmetic, verify account normal balance logic</td>\n</tr>\n<tr>\n<td>Duplicate entries despite idempotency keys</td>\n<td>Race condition in idempotency check/insert</td>\n<td>Check for duplicate idempotency records with different timestamps</td>\n<td>Use database UPSERT or proper locking for idempotency table</td>\n</tr>\n<tr>\n<td>Posting transactions hang indefinitely</td>\n<td>Database deadlock or lock timeout</td>\n<td>Check PostgreSQL logs for deadlock detection, review lock acquisition order</td>\n<td>Implement lock timeout and consistent lock ordering</td>\n</tr>\n<tr>\n<td>Validation errors not user-friendly</td>\n<td>Generic error messages without context</td>\n<td>Review ValidationError structures and field mappings</td>\n<td>Add specific error codes and human-readable descriptions</td>\n</tr>\n<tr>\n<td>Performance degradation under load</td>\n<td>Missing database indexes or inefficient queries</td>\n<td>Use EXPLAIN ANALYZE on posting queries, check for table scans</td>\n<td>Add indexes on account_id, posting_date; optimize balance update queries</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Milestone(s):</strong> 3 (Balance Calculation), as this section implements efficient account balance computation with running totals and point-in-time queries that enable fast financial reporting</p>\n</blockquote>\n<h2 id=\"balance-calculation-engine\">Balance Calculation Engine</h2>\n<p>Think of account balance calculation like maintaining the running score in a basketball game. Rather than reviewing every play from the beginning each time you want to know the score, the scoreboard continuously updates with each basket. However, unlike basketball, our accounting scoreboard must also answer historical questions like &quot;what was the score at the end of the third quarter?&quot; This dual requirement—current balance efficiency and historical accuracy—drives the core design of the balance calculation engine.</p>\n<p>The balance calculation engine serves as the computational heart of the ledger system, transforming raw journal entry data into meaningful financial information. Every time a journal entry is posted, the engine must efficiently update account balances while maintaining the ability to answer historical balance queries for any point in time. This component bridges the gap between the immutable audit trail of transactions and the dynamic reporting needs of financial users.</p>\n<p><img src=\"/api/project/ledger-system/architecture-doc/asset?path=diagrams%2Fbalance-calculation-flow.svg\" alt=\"Balance Calculation Process Flow\"></p>\n<h3 id=\"running-balance-maintenance\">Running Balance Maintenance</h3>\n<p>Think of running balance maintenance like keeping a checkbook register where you write down your running balance after each transaction. Instead of adding up all your deposits and subtracting all your checks every time you want to know your balance, you simply look at the last entry in your register. The balance calculation engine applies this same principle across thousands of accounts simultaneously.</p>\n<p>The <strong>running balance</strong> represents the continuously updated current balance for each account, computed incrementally as new journal entries are posted. This approach transforms balance queries from expensive aggregation operations that scan thousands of transaction records into simple lookups of pre-computed values. The engine maintains these running balances in a dedicated table that gets updated atomically with each journal entry posting.</p>\n<p>When a journal entry is posted, the balance engine examines each <code>EntryLine</code> and updates the corresponding account&#39;s running balance based on whether the line contains a debit or credit amount. The calculation must respect the normal balance conventions for different account types—assets and expenses increase with debits, while liabilities, equity, and revenue increase with credits.</p>\n<p>The balance update calculation follows this logic for each entry line:</p>\n<ol>\n<li>Retrieve the account&#39;s current running balance and account type from the database</li>\n<li>Determine whether this account type follows debit-normal or credit-normal conventions using the <code>IsDebitNormal()</code> method</li>\n<li>If the entry line contains a debit amount and the account is debit-normal (or contains a credit amount and the account is credit-normal), add the amount to the running balance</li>\n<li>If the entry line contains a debit amount and the account is credit-normal (or contains a credit amount and the account is debit-normal), subtract the amount from the running balance</li>\n<li>Update the running balance record with the new calculated balance and the timestamp of the posting</li>\n</ol>\n<blockquote>\n<p><strong>Design Insight</strong>: Running balances eliminate the need to scan potentially millions of historical transactions for balance queries, reducing typical balance lookup time from seconds to milliseconds. However, they introduce the complexity of maintaining consistency between the immutable transaction log and the mutable balance cache.</p>\n</blockquote>\n<p><strong>Running Balance Data Structure</strong></p>\n<p>The running balance system maintains account balances in a dedicated table that provides fast lookup while preserving historical accuracy:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AccountID</td>\n<td>string</td>\n<td>Foreign key reference to the account whose balance is tracked</td>\n</tr>\n<tr>\n<td>CurrentBalance</td>\n<td>Money</td>\n<td>The current balance computed from all posted journal entries</td>\n</tr>\n<tr>\n<td>LastUpdatedAt</td>\n<td>time.Time</td>\n<td>Timestamp when this balance was last updated by a journal entry posting</td>\n</tr>\n<tr>\n<td>LastEntryID</td>\n<td>string</td>\n<td>ID of the most recent journal entry that affected this account&#39;s balance</td>\n</tr>\n<tr>\n<td>Version</td>\n<td>int64</td>\n<td>Optimistic locking version number to prevent concurrent update conflicts</td>\n</tr>\n</tbody></table>\n<p><strong>Balance Update Workflow</strong></p>\n<p>The balance update process executes within the same database transaction as journal entry posting to ensure atomic consistency:</p>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Action</th>\n<th>Validation</th>\n<th>Error Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Lock running balance records for all affected accounts</td>\n<td>Verify accounts exist and are active</td>\n<td>Rollback transaction if any account is invalid</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Calculate balance changes for each entry line</td>\n<td>Apply normal balance rules based on account type</td>\n<td>Rollback if calculation produces invalid amount</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Update running balance records with new amounts</td>\n<td>Check for concurrent modifications using version numbers</td>\n<td>Retry with backoff if optimistic lock fails</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Record balance update audit trail</td>\n<td>Log old balance, new balance, and triggering entry ID</td>\n<td>Continue posting but log audit trail failure</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Commit transaction with journal entry and balance updates</td>\n<td>Verify database constraints are satisfied</td>\n<td>Full rollback if commit fails</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Atomic Balance Updates</strong></p>\n<ul>\n<li><strong>Context</strong>: Balance updates could happen asynchronously after journal entry posting to improve performance</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Synchronous updates within posting transaction</li>\n<li>Asynchronous updates via message queue</li>\n<li>Lazy calculation on demand</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Synchronous updates within posting transaction</li>\n<li><strong>Rationale</strong>: Ensures balance consistency and eliminates race conditions where balance queries might see stale data immediately after posting</li>\n<li><strong>Consequences</strong>: Slightly increases posting latency but guarantees that balance queries always reflect all posted entries</li>\n</ul>\n</blockquote>\n<p><strong>Concurrent Balance Updates</strong></p>\n<p>Multiple journal entries might affect the same account simultaneously, requiring careful coordination to prevent lost updates and maintain balance accuracy. The balance engine uses optimistic locking with version numbers to detect concurrent modifications and retry failed updates.</p>\n<p>When two transactions attempt to update the same account balance concurrently, the database&#39;s optimistic locking mechanism ensures that only one succeeds initially. The failed transaction detects the version mismatch, refreshes its view of the current balance, recalculates the update, and retries the operation. This approach provides better performance than pessimistic locking while maintaining data integrity.</p>\n<p>The retry logic implements exponential backoff to avoid thundering herd problems when many transactions contend for popular accounts. After three consecutive retry failures, the system logs an error and fails the journal entry posting, requiring manual intervention to resolve the conflict.</p>\n<h3 id=\"point-in-time-balance-queries\">Point-in-Time Balance Queries</h3>\n<p>Think of point-in-time balance queries like asking &quot;what was my bank account balance at the end of last month?&quot; Your bank doesn&#39;t recalculate your entire transaction history—instead, it uses your current balance and either adds back or subtracts transactions that happened after your target date. The balance engine applies similar logic but with additional complexity to handle the continuous nature of business transactions.</p>\n<p><strong>Point-in-time balance calculation</strong> determines an account&#39;s balance as of a specific date and time by considering only journal entries that were posted on or before that moment. This capability is essential for generating historical financial reports, performing account reconciliation, and supporting regulatory compliance requirements that demand balance verification as of specific dates.</p>\n<p>The engine supports two calculation strategies depending on the query date relative to the current date and the volume of intervening transactions:</p>\n<ol>\n<li><strong>Forward calculation</strong>: Start from the account&#39;s opening balance and add all posted entries up to the target date</li>\n<li><strong>Backward calculation</strong>: Start from the current running balance and subtract all entries posted after the target date</li>\n</ol>\n<p>The engine automatically selects the most efficient strategy based on the transaction volume estimates for each date range.</p>\n<p><strong>Point-in-Time Query Interface</strong></p>\n<p>The balance calculation engine exposes point-in-time queries through a standardized interface that abstracts the underlying calculation strategy:</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GetBalanceAsOf</td>\n<td>accountID string, asOfDate time.Time</td>\n<td>Money, error</td>\n<td>Returns the account balance considering only entries posted on or before the specified date</td>\n</tr>\n<tr>\n<td>GetMultipleBalancesAsOf</td>\n<td>accountIDs []string, asOfDate time.Time</td>\n<td>map[string]Money, error</td>\n<td>Efficiently calculates balances for multiple accounts as of the same date</td>\n</tr>\n<tr>\n<td>GetBalanceHistory</td>\n<td>accountID string, fromDate time.Time, toDate time.Time, interval string</td>\n<td>[]BalanceSnapshot, error</td>\n<td>Returns a series of balance snapshots at regular intervals within the date range</td>\n</tr>\n<tr>\n<td>GetTrialBalanceAsOf</td>\n<td>asOfDate time.Time</td>\n<td>TrialBalance, error</td>\n<td>Generates a complete trial balance report showing all account balances as of the specified date</td>\n</tr>\n</tbody></table>\n<p><strong>Calculation Strategy Selection</strong></p>\n<p>The balance engine automatically chooses between forward and backward calculation based on efficiency heuristics that consider the number of transactions in each direction:</p>\n<blockquote>\n<p><strong>Decision: Adaptive Calculation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Point-in-time queries might target dates very close to current time or far in the past, leading to vastly different performance characteristics</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Always calculate forward from account opening</li>\n<li>Always calculate backward from current balance  </li>\n<li>Dynamically choose based on transaction volume estimates</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Dynamic strategy selection with volume-based heuristics</li>\n<li><strong>Rationale</strong>: Forward calculation is faster for recent dates with few intervening transactions, while backward calculation is faster for historical dates</li>\n<li><strong>Consequences</strong>: Requires maintaining transaction count estimates but provides optimal performance across all query date ranges</li>\n</ul>\n</blockquote>\n<p><strong>Strategy Selection Logic</strong></p>\n<table>\n<thead>\n<tr>\n<th>Query Date Range</th>\n<th>Transaction Count After Target</th>\n<th>Transaction Count Before Target</th>\n<th>Selected Strategy</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Last 30 days</td>\n<td>&lt; 1000</td>\n<td>&gt; 10000</td>\n<td>Backward</td>\n<td>Few recent transactions to subtract</td>\n</tr>\n<tr>\n<td>Last 90 days</td>\n<td>&lt; 5000</td>\n<td>&gt; 25000</td>\n<td>Backward</td>\n<td>Moderate recent transactions</td>\n</tr>\n<tr>\n<td>6-12 months ago</td>\n<td>&gt; 10000</td>\n<td>&lt; 20000</td>\n<td>Forward</td>\n<td>More transactions after than before</td>\n</tr>\n<tr>\n<td>&gt; 1 year ago</td>\n<td>&gt; 50000</td>\n<td>&lt; 10000</td>\n<td>Forward</td>\n<td>Much longer history after target date</td>\n</tr>\n</tbody></table>\n<p><strong>Balance Snapshot Caching</strong></p>\n<p>For frequently queried historical dates (such as month-end or quarter-end), the balance engine can optionally cache calculated balances to avoid repeated computation. These cached snapshots are invalidated if any journal entries are posted with dates on or before the snapshot date, ensuring accuracy despite the immutable audit trail allowing retroactive entry corrections.</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AccountID</td>\n<td>string</td>\n<td>Account whose balance was calculated</td>\n</tr>\n<tr>\n<td>AsOfDate</td>\n<td>time.Time</td>\n<td>The point-in-time date for this balance calculation</td>\n</tr>\n<tr>\n<td>Balance</td>\n<td>Money</td>\n<td>The calculated balance as of the specified date</td>\n</tr>\n<tr>\n<td>CalculatedAt</td>\n<td>time.Time</td>\n<td>When this snapshot was computed</td>\n</tr>\n<tr>\n<td>LastEntryDate</td>\n<td>time.Time</td>\n<td>Date of the most recent entry included in this calculation</td>\n</tr>\n<tr>\n<td>IsValid</td>\n<td>bool</td>\n<td>Whether this snapshot is still valid (no entries posted for earlier dates)</td>\n</tr>\n</tbody></table>\n<h3 id=\"trial-balance-validation\">Trial Balance Validation</h3>\n<p>Think of trial balance validation like double-checking that a complex mathematical equation balances on both sides. In double-entry bookkeeping, the fundamental equation is Assets + Expenses = Liabilities + Equity + Revenue. The trial balance validation ensures this equation holds true by verifying that the sum of all debit balances equals the sum of all credit balances across all accounts.</p>\n<p>The <strong>trial balance</strong> serves as the primary integrity check for the entire ledger system, providing mathematical proof that all journal entries have been recorded correctly according to double-entry principles. This validation runs automatically after each posting session and can be triggered on demand to verify ledger integrity at any point in time.</p>\n<p>Trial balance validation examines every account&#39;s current balance (or balance as of a specific date for historical validation) and categorizes each balance as either a debit or credit based on the account&#39;s normal balance convention and the sign of the balance amount. The validation succeeds only when the total of all debit balances exactly equals the total of all credit balances.</p>\n<p><strong>Trial Balance Calculation Logic</strong></p>\n<p>The trial balance calculation process transforms account balances into debit and credit columns based on accounting conventions:</p>\n<ol>\n<li>Retrieve current balances (or point-in-time balances) for all active accounts in the chart of accounts</li>\n<li>For each account balance, determine whether it represents a debit or credit amount based on the account type&#39;s normal balance and the balance sign</li>\n<li>If the account is debit-normal (Asset or Expense) and has a positive balance, include it in the debit column</li>\n<li>If the account is debit-normal and has a negative balance, include the absolute value in the credit column</li>\n<li>If the account is credit-normal (Liability, Equity, or Revenue) and has a positive balance, include it in the credit column  </li>\n<li>If the account is credit-normal and has a negative balance, include the absolute value in the debit column</li>\n<li>Sum all amounts in the debit column and all amounts in the credit column</li>\n<li>Verify that the debit total exactly equals the credit total</li>\n</ol>\n<p><strong>Trial Balance Data Structure</strong></p>\n<p>The trial balance validation produces a comprehensive report showing all account balances organized into debit and credit columns:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AsOfDate</td>\n<td>time.Time</td>\n<td>The date for which the trial balance was calculated</td>\n</tr>\n<tr>\n<td>AccountBalances</td>\n<td>[]AccountBalance</td>\n<td>List of all accounts with their calculated balances</td>\n</tr>\n<tr>\n<td>TotalDebits</td>\n<td>Money</td>\n<td>Sum of all amounts appearing in the debit column</td>\n</tr>\n<tr>\n<td>TotalCredits</td>\n<td>Money</td>\n<td>Sum of all amounts appearing in the credit column</td>\n</tr>\n<tr>\n<td>IsBalanced</td>\n<td>bool</td>\n<td>Whether total debits equal total credits</td>\n</tr>\n<tr>\n<td>Variance</td>\n<td>Money</td>\n<td>Difference between debits and credits (should be zero)</td>\n</tr>\n<tr>\n<td>GeneratedAt</td>\n<td>time.Time</td>\n<td>When this trial balance was computed</td>\n</tr>\n</tbody></table>\n<p><strong>Individual Account Balance Entry</strong></p>\n<p>Each account&#39;s contribution to the trial balance is represented with complete detail for audit and troubleshooting purposes:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AccountID</td>\n<td>string</td>\n<td>Unique identifier for the account</td>\n</tr>\n<tr>\n<td>AccountCode</td>\n<td>string</td>\n<td>Human-readable account code (e.g., &quot;1001-Cash&quot;)</td>\n</tr>\n<tr>\n<td>AccountName</td>\n<td>string</td>\n<td>Descriptive name of the account</td>\n</tr>\n<tr>\n<td>AccountType</td>\n<td>AccountType</td>\n<td>Whether this is ASSET, LIABILITY, EQUITY, REVENUE, or EXPENSE</td>\n</tr>\n<tr>\n<td>Balance</td>\n<td>Money</td>\n<td>The raw calculated balance amount (may be positive or negative)</td>\n</tr>\n<tr>\n<td>DebitAmount</td>\n<td>*Money</td>\n<td>Amount appearing in debit column (nil if this balance contributes to credit column)</td>\n</tr>\n<tr>\n<td>CreditAmount</td>\n<td>*Money</td>\n<td>Amount appearing in credit column (nil if this balance contributes to debit column)</td>\n</tr>\n<tr>\n<td>LastEntryDate</td>\n<td>time.Time</td>\n<td>Date of the most recent journal entry affecting this account</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight</strong>: Trial balance validation provides mathematical certainty that the ledger is internally consistent. An unbalanced trial balance indicates either a software bug in the posting logic or potential data corruption, making this validation essential for maintaining confidence in financial reports.</p>\n</blockquote>\n<p><strong>Automated Trial Balance Monitoring</strong></p>\n<p>The balance engine automatically performs trial balance validation at key points in the transaction processing workflow:</p>\n<table>\n<thead>\n<tr>\n<th>Trigger Event</th>\n<th>Validation Scope</th>\n<th>Failure Action</th>\n<th>Recovery Process</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>After each journal entry posting</td>\n<td>Current balances only</td>\n<td>Log warning, continue processing</td>\n<td>Schedule full validation during maintenance window</td>\n</tr>\n<tr>\n<td>End of business day batch</td>\n<td>Current balances for all accounts</td>\n<td>Alert administrators, halt posting</td>\n<td>Investigate variance, identify and correct source</td>\n</tr>\n<tr>\n<td>Month-end closing</td>\n<td>Historical balances as of closing date</td>\n<td>Block closing process</td>\n<td>Require manual variance resolution before proceeding</td>\n</tr>\n<tr>\n<td>On-demand validation</td>\n<td>Any specified date range</td>\n<td>Report results to user</td>\n<td>Provide drill-down capabilities to identify problem accounts</td>\n</tr>\n</tbody></table>\n<p><strong>Variance Investigation Tools</strong></p>\n<p>When trial balance validation detects an imbalance, the balance engine provides investigative tools to identify the source of the discrepancy:</p>\n<p>The variance analysis tool examines recent journal entries and balance changes to identify potential causes of trial balance discrepancies. It compares expected balance changes (computed from journal entry debits and credits) against actual balance changes in the running balance table to detect inconsistencies.</p>\n<p>For each account contributing to the trial balance variance, the analysis tool reports the account&#39;s expected balance (calculated by summing all journal entry lines) versus its actual running balance, highlighting accounts where these values diverge. This comparison quickly identifies whether the problem lies in journal entry recording, balance calculation logic, or data corruption.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Small Trial Balance Variances</strong>\nMany developers assume that tiny discrepancies (like $0.01 differences) are acceptable rounding errors and can be ignored. This is dangerous because even small variances often indicate systematic problems that will compound over time. A $0.01 variance might represent a bug that affects one transaction out of every thousand, which will create increasingly large discrepancies as transaction volume grows. Always investigate and resolve trial balance variances regardless of magnitude.</p>\n<h3 id=\"balance-caching-strategy\">Balance Caching Strategy</h3>\n<p>Think of balance caching like keeping frequently referenced books on your desk instead of walking to the library every time you need them. The balance calculation engine implements a sophisticated caching strategy that keeps commonly requested balance calculations in fast-access storage while ensuring the cached values remain accurate as new transactions are posted.</p>\n<p>The <strong>balance caching system</strong> addresses the performance challenges of serving frequent balance queries, especially for high-volume accounts and popular reporting dates. Without caching, generating a balance sheet for a large organization might require thousands of individual balance calculations, each potentially scanning hundreds or thousands of journal entries. Effective caching reduces these expensive calculations to simple memory or database lookups.</p>\n<p>The caching strategy operates on multiple levels, each optimized for different access patterns and data consistency requirements. The engine maintains separate caches for current balances (updated with every transaction) and historical balances (computed on demand and cached for future reuse).</p>\n<p><strong>Multi-Level Cache Architecture</strong></p>\n<p>The balance caching system implements a hierarchical approach that balances performance, consistency, and resource utilization:</p>\n<table>\n<thead>\n<tr>\n<th>Cache Level</th>\n<th>Storage Location</th>\n<th>Update Frequency</th>\n<th>Consistency Guarantee</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>L1 - Memory Cache</td>\n<td>Application memory</td>\n<td>Real-time with journal posting</td>\n<td>Eventually consistent</td>\n<td>High-frequency current balance queries</td>\n</tr>\n<tr>\n<td>L2 - Database Cache</td>\n<td>Running balance table</td>\n<td>Synchronous with posting transaction</td>\n<td>Immediately consistent</td>\n<td>Cross-session balance queries and reporting</td>\n</tr>\n<tr>\n<td>L3 - Historical Cache</td>\n<td>Snapshot table</td>\n<td>On-demand calculation</td>\n<td>Point-in-time consistent</td>\n<td>Historical reporting and compliance queries</td>\n</tr>\n<tr>\n<td>L4 - Report Cache</td>\n<td>Materialized views</td>\n<td>Scheduled refresh</td>\n<td>Batch consistent</td>\n<td>Pre-computed financial statements</td>\n</tr>\n</tbody></table>\n<p><strong>Current Balance Caching</strong></p>\n<p>Current balance caching focuses on providing immediate access to account balances that reflect all posted transactions up to the current moment. This cache is updated synchronously with journal entry posting to ensure that balance queries always reflect the most recent account activity.</p>\n<p>The memory cache (L1) stores the most frequently accessed account balances in the application&#39;s memory space, providing sub-millisecond response times for balance queries. This cache uses an LRU (Least Recently Used) eviction policy to manage memory consumption while keeping hot accounts readily available.</p>\n<p>The database cache (L2) maintains running balances in the database itself, updated within the same transaction as journal entry posting. This ensures that balance queries from different application instances or sessions always see consistent values, even immediately after transaction posting.</p>\n<p><strong>Cache Update Workflow</strong></p>\n<p>The cache update process maintains consistency across all cache levels while minimizing the performance impact on transaction posting:</p>\n<ol>\n<li>Within the journal entry posting transaction, update the L2 database cache (running balance table) with new balance values</li>\n<li>After successful transaction commit, immediately update the L1 memory cache with the new balance values for affected accounts</li>\n<li>Invalidate any L3 historical cache entries that might be affected by the new journal entry (entries cached for dates on or after the posting date)</li>\n<li>Schedule L4 report cache refresh if the updated accounts are included in any materialized financial reports</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Synchronous L2 Updates with Asynchronous L1 Propagation</strong></p>\n<ul>\n<li><strong>Context</strong>: Cache updates could happen synchronously (blocking transaction posting) or asynchronously (allowing temporary inconsistency)</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Fully synchronous updates across all cache levels</li>\n<li>Synchronous database cache with asynchronous memory cache</li>\n<li>Fully asynchronous updates with eventual consistency</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Synchronous L2 database cache updates with asynchronous L1 memory cache propagation</li>\n<li><strong>Rationale</strong>: Database cache ensures cross-session consistency while memory cache async updates avoid blocking transaction throughput</li>\n<li><strong>Consequences</strong>: Brief windows where memory cache might be stale, but database queries always return current values</li>\n</ul>\n</blockquote>\n<p><strong>Historical Balance Caching</strong></p>\n<p>Historical balance caching optimizes the performance of point-in-time balance queries by storing previously calculated balance snapshots for popular query dates. This cache is particularly valuable for regulatory reporting and financial analysis that frequently reference month-end, quarter-end, and year-end balances.</p>\n<p>The historical cache uses a demand-driven population strategy—balance snapshots are calculated and cached only when first requested, then served from cache for subsequent identical queries. This approach avoids the storage overhead of pre-computing snapshots for every possible date while still providing performance benefits for repeated queries.</p>\n<p><strong>Cache Invalidation Strategy</strong></p>\n<p>Cache invalidation ensures that cached balance values remain accurate despite ongoing transaction activity that might affect account balances. The invalidation strategy must handle both straightforward cases (new transactions affecting cached accounts) and complex scenarios (retroactive entries posted with dates in the past).</p>\n<table>\n<thead>\n<tr>\n<th>Invalidation Trigger</th>\n<th>Affected Cache Levels</th>\n<th>Invalidation Scope</th>\n<th>Rebuild Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>New journal entry posted</td>\n<td>L1, L2, L3, L4</td>\n<td>Accounts referenced in entry</td>\n<td>Immediate L1/L2 rebuild, lazy L3/L4 rebuild</td>\n</tr>\n<tr>\n<td>Retroactive entry posted</td>\n<td>L3, L4</td>\n<td>All cached dates on or after entry date</td>\n<td>Immediate invalidation, on-demand rebuild</td>\n</tr>\n<tr>\n<td>Account reclassification</td>\n<td>All levels</td>\n<td>All cached values for affected account</td>\n<td>Full cache flush for account</td>\n</tr>\n<tr>\n<td>Batch entry processing</td>\n<td>L1, L2</td>\n<td>All accounts in batch</td>\n<td>Deferred rebuild after batch completion</td>\n</tr>\n</tbody></table>\n<p><strong>Cache Performance Monitoring</strong></p>\n<p>The balance caching system includes comprehensive monitoring to track cache effectiveness and identify opportunities for optimization:</p>\n<table>\n<thead>\n<tr>\n<th>Metric</th>\n<th>Measurement</th>\n<th>Target Range</th>\n<th>Action on Deviation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>L1 Cache Hit Rate</td>\n<td>Successful memory cache lookups / total balance queries</td>\n<td>&gt; 80%</td>\n<td>Increase cache size or improve eviction policy</td>\n</tr>\n<tr>\n<td>L2 Cache Consistency</td>\n<td>Database cache values matching transaction log</td>\n<td>100%</td>\n<td>Investigate and resolve synchronization bugs</td>\n</tr>\n<tr>\n<td>L3 Cache Utilization</td>\n<td>Historical snapshots served from cache / total historical queries</td>\n<td>&gt; 60%</td>\n<td>Adjust snapshot retention policies</td>\n</tr>\n<tr>\n<td>Cache Update Latency</td>\n<td>Time from transaction commit to L1 cache refresh</td>\n<td>&lt; 100ms</td>\n<td>Optimize cache update procedures</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Cache Stampede on Popular Accounts</strong>\nWhen a heavily-used account (like a main cash account) has its cache invalidated, multiple concurrent requests might simultaneously attempt to recalculate and update the cached balance, causing a &quot;cache stampede.&quot; This can overwhelm the database and cause significant performance degradation. Implement cache locking or single-flight mechanisms to ensure only one thread recalculates each cached value while others wait for the result.</p>\n<p><strong>Memory Management and Resource Limits</strong></p>\n<p>The in-memory cache (L1) implements sophisticated memory management to prevent excessive memory consumption while maintaining performance benefits. The cache tracks memory usage and implements both hard limits (maximum memory allocation) and soft limits (preferred memory usage with graceful degradation).</p>\n<p>When memory pressure increases, the cache employs a multi-stage eviction process: first removing least-recently-used entries, then entries for inactive accounts, and finally falling back to database-only balance queries. This graceful degradation ensures that the application continues functioning even under memory constraints, though with reduced performance.</p>\n<p>The cache also implements background maintenance processes that periodically validate cached values against authoritative database records, ensuring that any inconsistencies (potentially caused by software bugs or data corruption) are detected and corrected automatically.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Race Conditions in Balance Updates</strong>\nConcurrent journal entries affecting the same account can cause race conditions where balance updates are lost or incorrectly calculated. This happens when two transactions read the same current balance, calculate their respective updates independently, and then both attempt to write their results—the last writer wins, losing the first transaction&#39;s balance change. Always use database-level locking or optimistic concurrency control with version numbers to prevent lost updates.</p>\n<p>⚠️ <strong>Pitfall: Floating-Point Precision Errors in Balance Calculations</strong>\nUsing floating-point arithmetic for monetary calculations can introduce precision errors that accumulate over time and cause trial balance discrepancies. A balance that should be exactly $100.00 might be stored as $99.999999999998, leading to rounding errors when multiple balances are summed. Always use fixed-point decimal arithmetic or integer-based monetary representations to ensure exact calculations.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Account Type Normal Balance Rules</strong>\nIncorrectly applying debit and credit amounts without considering account type normal balance conventions will produce incorrect balance calculations. For example, a credit amount to an asset account should decrease the account balance, but naive addition logic would increase it. Always implement and test the normal balance rules: assets and expenses increase with debits and decrease with credits, while liabilities, equity, and revenue increase with credits and decrease with debits.</p>\n<p>⚠️ <strong>Pitfall: Point-in-Time Queries Missing Transaction Timestamps</strong>\nUsing only posting dates without considering transaction timestamps can cause point-in-time queries to return incorrect results when multiple transactions are posted on the same date. If a balance query asks for balances &quot;as of end of day March 31&quot; but transactions posted on March 31 have different timestamps, the query might include or exclude transactions inconsistently. Always use complete timestamp comparisons (date and time) for point-in-time calculations.</p>\n<p>⚠️ <strong>Pitfall: Cache Invalidation Gaps During High-Volume Posting</strong>\nDuring high-volume transaction posting periods, cache invalidation messages might be delayed or lost, causing cached balances to become stale. Users might see outdated balance information even after recent transactions have been posted. Implement cache validation mechanisms that periodically verify cached values against authoritative database records, especially for critical accounts and during high-activity periods.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The balance calculation engine requires careful implementation to achieve the performance and accuracy requirements of a production accounting system. This section provides complete working code for the infrastructure components and detailed guidance for implementing the core balance calculation logic.</p>\n<p><strong>Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Balance Storage</td>\n<td>PostgreSQL with standard tables</td>\n<td>PostgreSQL with materialized views and partitioning</td>\n</tr>\n<tr>\n<td>Cache Layer</td>\n<td>In-memory map with sync.RWMutex</td>\n<td>Redis cluster with consistent hashing</td>\n</tr>\n<tr>\n<td>Decimal Arithmetic</td>\n<td>shopspring/decimal package</td>\n<td>Custom fixed-point integer implementation</td>\n</tr>\n<tr>\n<td>Concurrent Updates</td>\n<td>Database row locking</td>\n<td>Optimistic locking with retry logic</td>\n</tr>\n<tr>\n<td>Performance Monitoring</td>\n<td>Simple log metrics</td>\n<td>Prometheus with custom balance calculation metrics</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/balance/\n  engine.go                 ← main balance calculation engine\n  running_balance.go        ← running balance maintenance logic  \n  point_in_time.go         ← historical balance calculation\n  trial_balance.go         ← trial balance validation\n  cache.go                 ← multi-level caching implementation\n  models.go                ← balance-related data structures\n  engine_test.go           ← comprehensive balance engine tests</code></pre></div>\n\n<p><strong>Balance Calculation Data Structures</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> balance</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/shopspring/decimal</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RunningBalance represents the current balance for an account</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RunningBalance</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AccountID      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"account_id\" db:\"account_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CurrentBalance </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#9ECBFF\">           `json:\"current_balance\" db:\"current_balance\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastUpdatedAt  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">       `json:\"last_updated_at\" db:\"last_updated_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastEntryID    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"last_entry_id\" db:\"last_entry_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Version        </span><span style=\"color:#F97583\">int64</span><span style=\"color:#9ECBFF\">           `json:\"version\" db:\"version\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BalanceSnapshot represents a point-in-time balance calculation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BalanceSnapshot</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AccountID     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"account_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AsOfDate      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"as_of_date\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Balance       </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#9ECBFF\">     `json:\"balance\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CalculatedAt  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"calculated_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastEntryDate </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"last_entry_date\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsValid       </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">      `json:\"is_valid\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TrialBalance represents a complete trial balance report</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TrialBalance</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AsOfDate        </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">        `json:\"as_of_date\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AccountBalances []</span><span style=\"color:#B392F0\">AccountBalance</span><span style=\"color:#9ECBFF\"> `json:\"account_balances\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TotalDebits     </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#9ECBFF\">            `json:\"total_debits\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TotalCredits    </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#9ECBFF\">            `json:\"total_credits\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsBalanced      </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">             `json:\"is_balanced\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Variance        </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#9ECBFF\">            `json:\"variance\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GeneratedAt     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">        `json:\"generated_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AccountBalance represents one account's contribution to trial balance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AccountBalance</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AccountID     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"account_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AccountCode   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"account_code\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AccountName   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">       `json:\"account_name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AccountType   </span><span style=\"color:#B392F0\">AccountType</span><span style=\"color:#9ECBFF\">  `json:\"account_type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Balance       </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#9ECBFF\">        `json:\"balance\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DebitAmount   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#9ECBFF\">       `json:\"debit_amount\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreditAmount  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#9ECBFF\">       `json:\"credit_amount\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastEntryDate </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">    `json:\"last_entry_date\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Balance Engine Interface</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// BalanceEngine provides account balance calculation and caching services</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BalanceEngine</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Running balance operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    UpdateRunningBalances</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetCurrentBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetCurrentBalances</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountIDs</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Point-in-time balance operations  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetBalanceAsOf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">asOfDate</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetMultipleBalancesAsOf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountIDs</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">asOfDate</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetBalanceHistory</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fromDate</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">toDate</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">interval</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">BalanceSnapshot</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Trial balance operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetTrialBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TrialBalance</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetTrialBalanceAsOf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">asOfDate</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TrialBalance</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ValidateTrialBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Cache management</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    InvalidateCache</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    RefreshCache</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Complete Balance Engine Implementation Starter</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> balance</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/shopspring/decimal</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Engine implements the BalanceEngine interface with multi-level caching</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Engine</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db           </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    memoryCache  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MemoryCache</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu           </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MemoryCache provides L1 in-memory balance caching</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MemoryCache</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    balances </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">CachedBalance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mu       </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxSize  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ttl      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CachedBalance represents a balance stored in memory cache</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CachedBalance</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Balance   </span><span style=\"color:#B392F0\">Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CachedAt  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Version   </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewEngine creates a new balance calculation engine with caching</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewEngine</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">cacheSize</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">cacheTTL</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db: db,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        memoryCache: </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">MemoryCache</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            balances: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">CachedBalance</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            maxSize:  cacheSize,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ttl:      cacheTTL,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Balance Calculation Skeleton</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// UpdateRunningBalances atomically updates account balances for a posted journal entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This method executes within the same transaction as journal entry posting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">UpdateRunningBalances</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Begin database transaction for balance updates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Lock running balance records for all accounts in entry.Lines to prevent concurrent updates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For each EntryLine in the journal entry:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Retrieve current RunningBalance record for the line's AccountID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Calculate balance change based on DebitAmount/CreditAmount and account normal balance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Apply change to current balance and increment version number</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Update RunningBalance record in database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Commit transaction and handle any constraint violations or deadlocks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update memory cache (L1) with new balance values for affected accounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Invalidate historical balance cache (L3) entries that might be affected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use optimistic locking with version numbers to detect concurrent modifications</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Implement exponential backoff retry logic for deadlock recovery</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetCurrentBalance retrieves the current balance for an account with caching</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetCurrentBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check L1 memory cache for accountID balance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If cache hit and entry is not expired, return cached balance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If cache miss or expired, query L2 database cache (running_balances table)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update L1 memory cache with retrieved balance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return balance with proper error handling for account not found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use sync.RWMutex for concurrent cache access</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Implement cache eviction when memory cache reaches maxSize</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetBalanceAsOf calculates account balance as of a specific date and time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetBalanceAsOf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">asOfDate</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check L3 historical cache for existing balance snapshot</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: If cache hit and snapshot is valid, return cached balance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Choose calculation strategy (forward vs backward) based on date range and transaction volume</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Execute chosen calculation strategy:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Forward: sum all entry lines from account opening to asOfDate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Backward: start with current balance and subtract entries after asOfDate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Cache calculated balance in L3 historical cache for future queries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return calculated balance with error handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use EXPLAIN ANALYZE to verify query performance for both strategies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Consider using database query hints for large date ranges</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetTrialBalance generates a complete trial balance report for all accounts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetTrialBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TrialBalance</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Retrieve current balances for all active accounts in chart of accounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each account balance, determine debit/credit classification:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Use account.IsDebitNormal() to determine normal balance side</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Positive balance on normal side goes to that column</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Negative balance on normal side goes to opposite column (absolute value)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Sum all debit column amounts and all credit column amounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Calculate variance (debits - credits) and set IsBalanced flag</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Populate AccountBalance entries with account details and amounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return complete TrialBalance with generation timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Zero variance indicates a balanced ledger; non-zero requires investigation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Include account hierarchy information for better report organization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateTrialBalance performs integrity check on the entire ledger</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateTrialBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Generate current trial balance using GetTrialBalance()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Check if trial balance is balanced (variance equals zero)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: If unbalanced, identify accounts contributing to variance:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Compare running balance table values to journal entry line sums</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    //   - Report accounts where calculated vs stored balances differ</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Log detailed variance analysis for debugging purposes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return error if trial balance fails validation with specific variance amount</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Small variances might indicate rounding errors; large variances suggest data corruption</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Provide drill-down capability to identify specific problematic journal entries</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Cache Management Implementation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// invalidateHistoricalCache removes cached snapshots that might be affected by new entries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">invalidateHistoricalCache</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entryDate</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountIDs</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Query L3 historical cache for snapshots with AsOfDate >= entryDate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Filter results to only include snapshots for accounts in accountIDs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Mark affected snapshots as invalid or delete them from cache</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update cache statistics and log invalidation metrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Consider using database triggers for automatic cache invalidation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Batch invalidation operations for better performance during high-volume periods</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// refreshMemoryCache updates L1 cache with current database values  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">e </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Engine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">refreshMemoryCache</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountIDs</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Query running_balances table for specified accounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update memory cache entries with fresh database values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Remove any cache entries for accounts that no longer exist</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Apply LRU eviction if cache size exceeds limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update cache hit/miss statistics for monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use bulk database queries instead of individual account lookups</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Implement cache warming strategies for frequently accessed accounts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Milestone Verification Checkpoints</strong></p>\n<p>After implementing the balance calculation engine, verify correct behavior with these checkpoints:</p>\n<ol>\n<li><p><strong>Running Balance Accuracy</strong>: Post several journal entries and verify that running balances in the database match manual calculations from journal entry lines</p>\n<ul>\n<li>Expected: <code>SELECT SUM(debit_amount - credit_amount) FROM entry_lines WHERE account_id = &#39;xxx&#39;</code> equals running balance</li>\n<li>Test command: <code>go test -run TestRunningBalanceAccuracy</code></li>\n</ul>\n</li>\n<li><p><strong>Point-in-Time Calculations</strong>: Create transactions across multiple dates and verify historical balance queries</p>\n<ul>\n<li>Expected: Balance as of mid-month should exclude transactions posted after that date</li>\n<li>Test command: <code>go test -run TestPointInTimeBalances</code></li>\n</ul>\n</li>\n<li><p><strong>Trial Balance Validation</strong>: Post balanced journal entries and verify trial balance sums to zero</p>\n<ul>\n<li>Expected: Total debits exactly equal total credits in trial balance report</li>\n<li>Test command: <code>go test -run TestTrialBalanceValidation</code></li>\n</ul>\n</li>\n<li><p><strong>Cache Consistency</strong>: Update balances and verify all cache levels reflect changes</p>\n<ul>\n<li>Expected: Memory cache, database cache, and fresh queries all return identical values</li>\n<li>Test command: <code>go test -run TestCacheConsistency</code></li>\n</ul>\n</li>\n<li><p><strong>Concurrent Update Handling</strong>: Run multiple journal entry postings simultaneously</p>\n<ul>\n<li>Expected: All entries post successfully without lost balance updates or deadlocks</li>\n<li>Test command: <code>go test -run TestConcurrentBalanceUpdates</code></li>\n</ul>\n</li>\n</ol>\n<p><strong>Performance Benchmarking</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Benchmark current balance queries</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -bench=BenchmarkCurrentBalance</span><span style=\"color:#79B8FF\"> -benchmem</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Benchmark point-in-time calculations  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -bench=BenchmarkPointInTime</span><span style=\"color:#79B8FF\"> -benchmem</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Benchmark trial balance generation</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">go</span><span style=\"color:#9ECBFF\"> test</span><span style=\"color:#79B8FF\"> -bench=BenchmarkTrialBalance</span><span style=\"color:#79B8FF\"> -benchmem</span></span></code></pre></div>\n\n<p>Expected performance targets:</p>\n<ul>\n<li>Current balance queries: &lt; 1ms for cached accounts, &lt; 10ms for uncached</li>\n<li>Point-in-time queries: &lt; 50ms for recent dates, &lt; 500ms for historical dates  </li>\n<li>Trial balance generation: &lt; 2 seconds for 10,000 accounts</li>\n<li>Cache hit rate: &gt; 80% for current balances, &gt; 60% for historical queries</li>\n</ul>\n<blockquote>\n<p><strong>Milestone(s):</strong> 4 (Audit Trail), as this section implements immutable change logging with cryptographic integrity verification that ensures complete transaction traceability for regulatory compliance</p>\n</blockquote>\n<h2 id=\"audit-trail-system\">Audit Trail System</h2>\n<p><img src=\"/api/project/ledger-system/architecture-doc/asset?path=diagrams%2Faudit-trail-structure.svg\" alt=\"Audit Trail Data Structure\"></p>\n<p>Think of an audit trail like a blockchain ledger for your accounting system — every transaction and modification creates an immutable record that&#39;s cryptographically linked to previous records, making it impossible to alter history without detection. Just as a bank vault has multiple locks and cameras recording every entry, an accounting audit trail provides multiple layers of protection to ensure financial data integrity and regulatory compliance.</p>\n<p>The audit trail system serves as the guardian of data integrity for the entire double-entry ledger. While the transaction recording engine ensures that journal entries are properly balanced and posted atomically, the audit trail system ensures that once posted, these entries become part of an immutable historical record that can never be altered or deleted. This immutability is not just a design preference — it&#39;s a legal requirement in most jurisdictions for financial record keeping.</p>\n<h3 id=\"immutable-entry-storage\">Immutable Entry Storage</h3>\n<p><strong>Immutable entry storage</strong> forms the foundation of audit trail integrity by implementing an append-only ledger design that prevents modification or deletion of posted transactions. Think of this like writing in ink rather than pencil — once a transaction is committed to the ledger, it becomes a permanent part of the historical record that can only be corrected through new offsetting entries.</p>\n<p>The core principle behind immutable storage is that <strong>posted journal entries transition to a read-only state</strong> where the database system physically prevents UPDATE and DELETE operations. This is not merely a business rule enforced by application code — it&#39;s implemented through database constraints, triggers, and permissions that make modification technically impossible even for system administrators.</p>\n<blockquote>\n<p><strong>Decision: Append-Only Transaction Storage</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to maintain regulatory compliance while allowing corrections to accounting errors</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Mutable entries with change tracking</li>\n<li>Append-only with reversal entries</li>\n<li>Hybrid approach with archive tables</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Pure append-only storage with reversal entry mechanism</li>\n<li><strong>Rationale</strong>: Regulatory requirements mandate that original entries remain unchanged; corrections must be visible as separate transactions showing the complete audit trail of what happened and when</li>\n<li><strong>Consequences</strong>: Requires reversal entry workflow for corrections; increases storage requirements; provides strongest audit guarantees</li>\n</ul>\n</blockquote>\n<p>The immutable storage system distinguishes between <strong>draft entries</strong> that can still be modified and <strong>posted entries</strong> that become immutable. This state transition is irreversible — once an entry moves from <code>DRAFT</code> to <code>POSTED</code> status, it enters the immutable portion of the ledger.</p>\n<table>\n<thead>\n<tr>\n<th>Storage State</th>\n<th>Allowed Operations</th>\n<th>Data Location</th>\n<th>Protection Level</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Draft</td>\n<td>CREATE, UPDATE, DELETE</td>\n<td>Staging tables</td>\n<td>Application-level validation</td>\n</tr>\n<tr>\n<td>Posted</td>\n<td>READ only</td>\n<td>Main ledger</td>\n<td>Database constraints + triggers</td>\n</tr>\n<tr>\n<td>Archived</td>\n<td>READ only</td>\n<td>Archive partition</td>\n<td>Immutable storage backend</td>\n</tr>\n<tr>\n<td>Purged</td>\n<td>None</td>\n<td>Compliance archive</td>\n<td>External audit system</td>\n</tr>\n</tbody></table>\n<p>The system implements <strong>database-level immutability controls</strong> to prevent accidental or malicious modification of posted entries:</p>\n<ol>\n<li><strong>Row-level security policies</strong> that deny UPDATE and DELETE permissions on posted entries</li>\n<li><strong>Database triggers</strong> that reject any attempt to modify posted records and log the attempt as a security event</li>\n<li><strong>Column-level constraints</strong> that prevent status changes from POSTED back to DRAFT</li>\n<li><strong>Audit table partitioning</strong> that physically separates posted entries into read-only table partitions</li>\n<li><strong>Backup verification</strong> that regularly checksums posted entries to detect any unauthorized changes</li>\n</ol>\n<p><strong>Entry reversal workflow</strong> provides the mechanism for correcting posted transactions without violating immutability:</p>\n<ol>\n<li>The original incorrect entry remains in the ledger with <code>POSTED</code> status, unchanged</li>\n<li>A reversal entry is created that exactly offsets the original entry with opposite debit/credit amounts</li>\n<li>A new correct entry is posted with the intended transaction details</li>\n<li>All three entries are linked through a correction reference ID for audit trail continuity</li>\n<li>Account balances reflect the net effect while preserving the complete correction history</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Correction Component</th>\n<th>Entry Type</th>\n<th>Status</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Original Entry</td>\n<td>Normal</td>\n<td>POSTED</td>\n<td>Shows what was originally recorded (remains unchanged)</td>\n</tr>\n<tr>\n<td>Reversal Entry</td>\n<td>Reversal</td>\n<td>POSTED</td>\n<td>Cancels out the original entry amounts</td>\n</tr>\n<tr>\n<td>Corrected Entry</td>\n<td>Normal</td>\n<td>POSTED</td>\n<td>Records the intended correct transaction</td>\n</tr>\n<tr>\n<td>Correction Link</td>\n<td>Metadata</td>\n<td>-</td>\n<td>Ties all three entries together for audit reporting</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The reversal entry mechanism preserves the complete story of what happened — auditors can see the original mistake, the correction process, and the final result, along with who made each change and when.</p>\n</blockquote>\n<p><strong>Write-once storage guarantees</strong> are implemented through a combination of database features and application-level controls:</p>\n<ul>\n<li><strong>Immutable table partitions</strong> where posted entries are moved to append-only partitions</li>\n<li><strong>Content hash verification</strong> where each entry&#39;s hash is calculated and stored, with periodic integrity checks</li>\n<li><strong>Temporal consistency checks</strong> that verify posting dates follow chronological order within each accounting period</li>\n<li><strong>Cross-reference validation</strong> that ensures all referenced accounts and parent entries still exist and haven&#39;t been modified</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Allowing Status Rollbacks</strong>\nMany implementations mistakenly allow entries to transition from POSTED back to DRAFT for &quot;quick fixes.&quot; This breaks audit trail integrity because it allows modification of what should be immutable records. Instead, implement a strict state machine where POSTED entries can only transition to REVERSED through the reversal entry workflow.</p>\n<p>⚠️ <strong>Pitfall: Application-Only Immutability</strong>\nRelying solely on application code to prevent modifications leaves the system vulnerable to direct database access, SQL injection, or administrative errors. Database-level constraints, triggers, and permissions provide defense-in-depth protection that works even if application controls are bypassed.</p>\n<h3 id=\"change-history-tracking\">Change History Tracking</h3>\n<p><strong>Change history tracking</strong> creates a complete audit log that captures who made what changes when, including before/after values of all modified fields. Think of this as a time-lapse video of your database — every frame shows exactly what changed, who changed it, and when the change occurred.</p>\n<p>The change tracking system operates at multiple levels to capture different types of modifications:</p>\n<table>\n<thead>\n<tr>\n<th>Tracking Level</th>\n<th>What&#39;s Captured</th>\n<th>Storage Location</th>\n<th>Retention Period</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Field-Level</td>\n<td>Individual column changes with before/after values</td>\n<td><code>audit_field_changes</code> table</td>\n<td>7 years (regulatory)</td>\n</tr>\n<tr>\n<td>Row-Level</td>\n<td>Complete record snapshots at modification time</td>\n<td><code>audit_row_history</code> table</td>\n<td>7 years (regulatory)</td>\n</tr>\n<tr>\n<td>Transaction-Level</td>\n<td>Groups of changes within database transactions</td>\n<td><code>audit_transactions</code> table</td>\n<td>7 years (regulatory)</td>\n</tr>\n<tr>\n<td>Session-Level</td>\n<td>User sessions and authentication context</td>\n<td><code>audit_sessions</code> table</td>\n<td>3 years (security)</td>\n</tr>\n<tr>\n<td>System-Level</td>\n<td>Application events and administrative actions</td>\n<td><code>audit_system_events</code> table</td>\n<td>10 years (compliance)</td>\n</tr>\n</tbody></table>\n<p><strong>Audit event structure</strong> standardizes how all changes are recorded regardless of the source system or type of modification:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>EventID</td>\n<td>string</td>\n<td>Unique identifier for this audit event</td>\n</tr>\n<tr>\n<td>EventType</td>\n<td>string</td>\n<td>Type of change: CREATE, UPDATE, DELETE, STATE_TRANSITION</td>\n</tr>\n<tr>\n<td>TableName</td>\n<td>string</td>\n<td>Database table that was modified</td>\n</tr>\n<tr>\n<td>RecordID</td>\n<td>string</td>\n<td>Primary key of the modified record</td>\n</tr>\n<tr>\n<td>FieldName</td>\n<td>string</td>\n<td>Name of the changed field (null for row-level events)</td>\n</tr>\n<tr>\n<td>OldValue</td>\n<td>string</td>\n<td>Previous value before change (JSON-encoded)</td>\n</tr>\n<tr>\n<td>NewValue</td>\n<td>string</td>\n<td>New value after change (JSON-encoded)</td>\n</tr>\n<tr>\n<td>UserID</td>\n<td>string</td>\n<td>ID of user who made the change</td>\n</tr>\n<tr>\n<td>SessionID</td>\n<td>string</td>\n<td>Session identifier for grouping related changes</td>\n</tr>\n<tr>\n<td>IPAddress</td>\n<td>string</td>\n<td>Source IP address of the change request</td>\n</tr>\n<tr>\n<td>UserAgent</td>\n<td>string</td>\n<td>Client application information</td>\n</tr>\n<tr>\n<td>Timestamp</td>\n<td>time.Time</td>\n<td>Exact time when change occurred (UTC)</td>\n</tr>\n<tr>\n<td>TransactionID</td>\n<td>string</td>\n<td>Database transaction that contained this change</td>\n</tr>\n<tr>\n<td>ChangeReason</td>\n<td>string</td>\n<td>Business reason for the change (from user input)</td>\n</tr>\n<tr>\n<td>ApprovalID</td>\n<td>*string</td>\n<td>Reference to approval workflow if required</td>\n</tr>\n<tr>\n<td>ParentEventID</td>\n<td>*string</td>\n<td>Links related events in complex operations</td>\n</tr>\n</tbody></table>\n<p><strong>Automatic change detection</strong> captures modifications through database triggers that fire on every INSERT, UPDATE, and DELETE operation:</p>\n<ol>\n<li><strong>BEFORE triggers</strong> capture the old values of all fields before modification occurs</li>\n<li><strong>AFTER triggers</strong> capture the new values and compute the actual field-level differences</li>\n<li><strong>Row comparison logic</strong> identifies which specific fields changed and generates field-level audit events</li>\n<li><strong>Session context capture</strong> retrieves user information from database session variables</li>\n<li><strong>Transaction grouping</strong> links all changes within a single database transaction</li>\n</ol>\n<p>The system implements <strong>comprehensive change tracking</strong> that goes beyond simple field modifications:</p>\n<ul>\n<li><strong>State transition tracking</strong> for journal entry status changes from DRAFT to POSTED to REVERSED</li>\n<li><strong>Relationship changes</strong> when account hierarchy modifications affect parent-child relationships  </li>\n<li><strong>Privilege escalation tracking</strong> when users perform actions requiring elevated permissions</li>\n<li><strong>Bulk operation tracking</strong> for mass updates like period closing or account reclassification</li>\n<li><strong>System configuration changes</strong> to audit trail settings, security policies, or retention rules</li>\n</ul>\n<blockquote>\n<p><strong>Decision: Trigger-Based vs Application-Based Change Tracking</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to capture all data changes regardless of how they occur (API, direct SQL, administrative tools)</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Application-level logging in business logic</li>\n<li>Database triggers on all audited tables</li>\n<li>Change data capture (CDC) technology</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Database triggers with application context enrichment</li>\n<li><strong>Rationale</strong>: Triggers capture changes from any source including direct database access; application layer adds business context like user identity and change reason</li>\n<li><strong>Consequences</strong>: Requires trigger maintenance as schema evolves; provides complete coverage; adds slight performance overhead to all modifications</li>\n</ul>\n</blockquote>\n<p><strong>User activity correlation</strong> links database changes back to specific user actions and business processes:</p>\n<table>\n<thead>\n<tr>\n<th>Activity Type</th>\n<th>Context Captured</th>\n<th>Correlation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>API Requests</td>\n<td>HTTP headers, request body, authentication token</td>\n<td>Session ID linkage</td>\n</tr>\n<tr>\n<td>Batch Jobs</td>\n<td>Job ID, schedule trigger, system account</td>\n<td>Process ID tracking</td>\n</tr>\n<tr>\n<td>Manual Corrections</td>\n<td>User login, IP address, stated reason for change</td>\n<td>User session correlation</td>\n</tr>\n<tr>\n<td>System Processes</td>\n<td>Process name, scheduled task, automation trigger</td>\n<td>System event logging</td>\n</tr>\n<tr>\n<td>Data Imports</td>\n<td>File name, upload timestamp, validation results</td>\n<td>Import batch ID tracking</td>\n</tr>\n</tbody></table>\n<p><strong>Change aggregation and reporting</strong> provides meaningful views of the raw audit data for compliance and investigation purposes:</p>\n<ol>\n<li><strong>User activity summaries</strong> showing all actions by a specific user within a date range</li>\n<li><strong>Record modification histories</strong> displaying the complete lifecycle of a journal entry or account</li>\n<li><strong>Privilege usage reports</strong> identifying when users exercised administrative or override privileges</li>\n<li><strong>Bulk change analysis</strong> detecting unusual patterns that might indicate errors or fraud</li>\n<li><strong>Compliance attestation reports</strong> providing auditor-friendly summaries for regulatory examinations</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Missing Business Context</strong>\nTechnical audit logs often capture what changed but not why it changed. Always collect business context like the reason for a correction, the approval workflow used, or the original source document that triggered the change. This context is crucial for audit investigations.</p>\n<p>⚠️ <strong>Pitfall: Performance Impact Ignorance</strong>\nChange tracking adds overhead to every database operation. Monitor the performance impact and consider asynchronous audit logging for high-volume operations. However, never sacrifice audit completeness for performance — regulatory compliance is non-negotiable.</p>\n<h3 id=\"cryptographic-integrity\">Cryptographic Integrity</h3>\n<p><strong>Cryptographic integrity</strong> provides tamper detection capabilities that can identify unauthorized modifications to historical records, even by privileged users with direct database access. Think of this like a wax seal on an envelope — any attempt to open and reseal it leaves evidence of tampering that can be detected by examining the seal.</p>\n<p>The cryptographic integrity system implements a <strong>hash chain architecture</strong> where each journal entry includes a cryptographic hash that depends on both its own content and the hash of the previous entry. This creates a chain where altering any historical entry would require recalculating all subsequent hashes, making tampering computationally infeasible and easily detectable.</p>\n<table>\n<thead>\n<tr>\n<th>Hash Chain Component</th>\n<th>Purpose</th>\n<th>Algorithm</th>\n<th>Storage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Content Hash</td>\n<td>Verifies entry content hasn&#39;t changed</td>\n<td>SHA-256</td>\n<td><code>content_hash</code> field</td>\n</tr>\n<tr>\n<td>Chain Hash</td>\n<td>Links to previous entry in sequence</td>\n<td>SHA-256(content + prev_hash)</td>\n<td><code>chain_hash</code> field</td>\n</tr>\n<tr>\n<td>Merkle Root</td>\n<td>Aggregates multiple entries for efficiency</td>\n<td>SHA-256 tree</td>\n<td><code>audit_merkle_roots</code> table</td>\n</tr>\n<tr>\n<td>Digital Signature</td>\n<td>Proves hash was created by trusted system</td>\n<td>RSA-2048 or ECDSA</td>\n<td><code>hash_signatures</code> table</td>\n</tr>\n</tbody></table>\n<p><strong>Hash calculation process</strong> creates deterministic digests that will always produce the same hash for identical content:</p>\n<ol>\n<li><strong>Content normalization</strong> converts the journal entry to a canonical JSON representation with sorted field order</li>\n<li><strong>Field selection</strong> includes only immutable fields in the hash calculation (excludes timestamps like <code>last_accessed</code>)</li>\n<li><strong>Recursive hashing</strong> for entry lines ensures that line order doesn&#39;t affect the hash</li>\n<li><strong>Chain linking</strong> incorporates the previous entry&#39;s chain hash to create the forward-linked sequence</li>\n<li><strong>Digital signing</strong> uses a system private key to sign the calculated hash, proving authenticity</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Journal Entry Field</th>\n<th>Included in Hash</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ID</td>\n<td>Yes</td>\n<td>Core identifier</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>Yes</td>\n<td>Transaction date</td>\n</tr>\n<tr>\n<td>Description</td>\n<td>Yes</td>\n<td>Business purpose</td>\n</tr>\n<tr>\n<td>Reference</td>\n<td>Yes</td>\n<td>Source document</td>\n</tr>\n<tr>\n<td>Status</td>\n<td>Yes</td>\n<td>Current state</td>\n</tr>\n<tr>\n<td>CreatedBy</td>\n<td>Yes</td>\n<td>Original author</td>\n</tr>\n<tr>\n<td>PostedAt</td>\n<td>Yes</td>\n<td>Official posting time</td>\n</tr>\n<tr>\n<td>Lines[]</td>\n<td>Yes</td>\n<td>All debit/credit details</td>\n</tr>\n<tr>\n<td>CreatedAt</td>\n<td>No</td>\n<td>System timestamp (can vary)</td>\n</tr>\n<tr>\n<td>LastModified</td>\n<td>No</td>\n<td>Changes with every access</td>\n</tr>\n<tr>\n<td>AccessCount</td>\n<td>No</td>\n<td>Not part of business data</td>\n</tr>\n</tbody></table>\n<p><strong>Hash chain verification</strong> provides multiple levels of integrity checking:</p>\n<ul>\n<li><strong>Individual entry verification</strong> recalculates each entry&#39;s content hash and compares to stored value</li>\n<li><strong>Chain sequence verification</strong> validates that each entry&#39;s chain hash correctly incorporates the previous entry</li>\n<li><strong>Merkle tree verification</strong> efficiently checks large ranges of entries using hierarchical hashes</li>\n<li><strong>Digital signature verification</strong> confirms that hashes were created by the authorized system</li>\n<li><strong>Temporal consistency verification</strong> ensures that chain sequence matches chronological posting order</li>\n</ul>\n<blockquote>\n<p><strong>Decision: SHA-256 vs Stronger Hashing Algorithms</strong></p>\n<ul>\n<li><strong>Context</strong>: Need cryptographic hashes that will remain secure for regulatory retention periods (7+ years)</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>SHA-256 (current industry standard)</li>\n<li>SHA-3 (newer standard with different construction)</li>\n<li>Blake3 (faster modern alternative)</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: SHA-256 with algorithm agility for future upgrades</li>\n<li><strong>Rationale</strong>: SHA-256 is widely supported, regulatory-approved, and has no known practical attacks; algorithm agility allows migration if weaknesses are discovered</li>\n<li><strong>Consequences</strong>: Standard libraries available; may need future migration; good performance characteristics</li>\n</ul>\n</blockquote>\n<p><strong>Integrity verification workflow</strong> runs both on-demand and scheduled checks:</p>\n<ol>\n<li><strong>Real-time verification</strong> during entry posting validates that the new entry correctly chains to the previous entry</li>\n<li><strong>Periodic full verification</strong> runs nightly to check the complete hash chain from genesis to current</li>\n<li><strong>Spot verification</strong> randomly samples entries throughout the day to detect corruption quickly</li>\n<li><strong>Cross-replica verification</strong> compares hash chains across database replicas to detect inconsistencies</li>\n<li><strong>Audit-triggered verification</strong> performs comprehensive checks when preparing for regulatory examinations</li>\n</ol>\n<p>The system maintains <strong>hash verification logs</strong> that record all integrity checks and their results:</p>\n<table>\n<thead>\n<tr>\n<th>Verification Type</th>\n<th>Frequency</th>\n<th>Scope</th>\n<th>Alert Threshold</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Real-time</td>\n<td>Every posting</td>\n<td>Single entry</td>\n<td>Immediate failure alert</td>\n</tr>\n<tr>\n<td>Incremental</td>\n<td>Hourly</td>\n<td>Recent entries</td>\n<td>1 failure per hour</td>\n</tr>\n<tr>\n<td>Full Chain</td>\n<td>Daily</td>\n<td>Complete ledger</td>\n<td>Any chain break</td>\n</tr>\n<tr>\n<td>Random Sampling</td>\n<td>Continuous</td>\n<td>1% of entries</td>\n<td>3 failures per day</td>\n</tr>\n<tr>\n<td>Scheduled Full</td>\n<td>Weekly</td>\n<td>Complete + archives</td>\n<td>Any inconsistency</td>\n</tr>\n</tbody></table>\n<p><strong>Tamper detection and response</strong> provides immediate alerting when integrity violations are discovered:</p>\n<ul>\n<li><strong>Automatic alerting</strong> sends immediate notifications to security teams when hash mismatches are detected</li>\n<li><strong>Incident logging</strong> creates detailed records of integrity violations for forensic investigation</li>\n<li><strong>System lockdown</strong> can automatically disable write operations if widespread tampering is detected</li>\n<li><strong>Backup verification</strong> cross-checks against known-good backup copies to determine the scope of tampering</li>\n<li><strong>Recovery procedures</strong> provide step-by-step processes for restoring from verified backups</li>\n</ul>\n<blockquote>\n<p>The cryptographic integrity system provides mathematical proof of data authenticity. While access controls and permissions can be bypassed, cryptographic hashes cannot be forged without detection.</p>\n</blockquote>\n<p>⚠️ <strong>Pitfall: Hash Algorithm Rigidity</strong>\nHard-coding hash algorithms makes future security upgrades difficult. Implement algorithm agility by storing the algorithm identifier with each hash, allowing gradual migration to stronger algorithms as they become available.</p>\n<p>⚠️ <strong>Pitfall: Key Management Neglect</strong>\nDigital signatures are only as secure as the private keys used to create them. Implement proper key rotation, secure key storage (HSMs for production), and key escrow procedures for long-term signature verification.</p>\n<h3 id=\"audit-report-generation\">Audit Report Generation</h3>\n<p><strong>Audit report generation</strong> transforms the raw audit trail data into compliance-ready reports that regulators and external auditors can review to verify the integrity and completeness of financial records. Think of this as creating a readable story from the detailed forensic evidence — the raw audit logs contain every detail, but reports present the information in formats that humans can efficiently review and understand.</p>\n<p>The reporting system must address multiple regulatory frameworks that each have specific requirements for audit trail documentation:</p>\n<table>\n<thead>\n<tr>\n<th>Regulatory Framework</th>\n<th>Required Reports</th>\n<th>Retention Period</th>\n<th>Format Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SOX (Sarbanes-Oxley)</td>\n<td>All journal entry changes, user access logs</td>\n<td>7 years</td>\n<td>PDF with digital signatures</td>\n</tr>\n<tr>\n<td>GAAP</td>\n<td>Account balance histories, trial balance trails</td>\n<td>7 years</td>\n<td>Standard accounting formats</td>\n</tr>\n<tr>\n<td>Basel III</td>\n<td>Risk-related transaction trails, system controls</td>\n<td>7 years</td>\n<td>XML or structured data</td>\n</tr>\n<tr>\n<td>IFRS</td>\n<td>Fair value adjustments, estimate changes</td>\n<td>5 years</td>\n<td>Human-readable with supporting docs</td>\n</tr>\n<tr>\n<td>PCI DSS</td>\n<td>Payment-related transactions, security events</td>\n<td>1 year</td>\n<td>Encrypted storage required</td>\n</tr>\n</tbody></table>\n<p><strong>Standard audit report types</strong> provide comprehensive coverage of different audit trail aspects:</p>\n<ul>\n<li><strong>Complete Transaction History</strong> shows all journal entries for a specific date range with full audit metadata</li>\n<li><strong>Account Modification Trail</strong> displays all changes to account master data including hierarchy adjustments</li>\n<li><strong>User Activity Summary</strong> lists all actions performed by specific users with timestamps and business context  </li>\n<li><strong>Exception Reports</strong> highlight unusual patterns like after-hours modifications or privilege escalations</li>\n<li><strong>Integrity Verification Status</strong> shows results of cryptographic verification checks and any detected issues</li>\n<li><strong>Period Closing Audit Trail</strong> documents all entries and approvals during the period-end closing process</li>\n</ul>\n<p><strong>Audit report data structure</strong> standardizes how information is presented across all report types:</p>\n<table>\n<thead>\n<tr>\n<th>Report Section</th>\n<th>Content</th>\n<th>Source Data</th>\n<th>Formatting</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Header</td>\n<td>Report type, date range, generation timestamp</td>\n<td>Report parameters</td>\n<td>Fixed format with metadata</td>\n</tr>\n<tr>\n<td>Summary</td>\n<td>High-level statistics, exception counts</td>\n<td>Aggregated audit data</td>\n<td>Executive summary table</td>\n</tr>\n<tr>\n<td>Detail Records</td>\n<td>Individual transactions or changes</td>\n<td>Raw audit logs</td>\n<td>Chronological with drill-down</td>\n</tr>\n<tr>\n<td>Verification</td>\n<td>Integrity check results, hash validations</td>\n<td>Cryptographic verification</td>\n<td>Pass/fail with details</td>\n</tr>\n<tr>\n<td>Signatures</td>\n<td>Digital signatures, approval chains</td>\n<td>Workflow systems</td>\n<td>Certification format</td>\n</tr>\n<tr>\n<td>Appendices</td>\n<td>Supporting documentation, methodology</td>\n<td>Various sources</td>\n<td>Referenced attachments</td>\n</tr>\n</tbody></table>\n<p><strong>Report generation workflow</strong> ensures that audit reports accurately reflect the complete audit trail:</p>\n<ol>\n<li><strong>Data extraction</strong> queries audit tables with appropriate date ranges and filtering criteria</li>\n<li><strong>Cross-reference validation</strong> verifies that all referenced entities (accounts, users, approvals) still exist</li>\n<li><strong>Integrity verification</strong> runs hash chain checks on all entries included in the report</li>\n<li><strong>Data correlation</strong> links related audit events across multiple tables to show complete transaction stories</li>\n<li><strong>Format transformation</strong> converts raw audit data into human-readable report formats</li>\n<li><strong>Digital signing</strong> applies cryptographic signatures to ensure report integrity after generation</li>\n<li><strong>Archive storage</strong> saves completed reports in immutable storage for regulatory retention</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Real-time vs Batch Report Generation</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to provide audit reports quickly for regulatory requests while maintaining system performance</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Real-time generation from live audit tables</li>\n<li>Pre-computed batch reports with periodic updates</li>\n<li>Hybrid approach with cached summaries and detailed drill-down</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Hybrid approach with daily batch processing and real-time detail queries</li>\n<li><strong>Rationale</strong>: Regulatory requests often require specific date ranges; pre-computing all possible reports is impractical; cached summaries provide fast response with detailed drill-down capability</li>\n<li><strong>Consequences</strong>: Requires cache invalidation strategy; some reports may have slight delays; optimizes for common audit patterns</li>\n</ul>\n</blockquote>\n<p><strong>Report customization capabilities</strong> allow adaptation to different regulatory requirements and audit scenarios:</p>\n<table>\n<thead>\n<tr>\n<th>Customization Type</th>\n<th>Options Available</th>\n<th>Configuration Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Date Range</td>\n<td>Custom ranges, predefined periods, rolling windows</td>\n<td>Report parameters</td>\n</tr>\n<tr>\n<td>Scope Filtering</td>\n<td>Specific accounts, users, transaction types</td>\n<td>Filter criteria</td>\n</tr>\n<tr>\n<td>Detail Level</td>\n<td>Summary only, full detail, exception focus</td>\n<td>Report template</td>\n</tr>\n<tr>\n<td>Output Format</td>\n<td>PDF, CSV, JSON, XML</td>\n<td>Format specification</td>\n</tr>\n<tr>\n<td>Grouping</td>\n<td>By user, by account, by time period</td>\n<td>Aggregation rules</td>\n</tr>\n<tr>\n<td>Sorting</td>\n<td>Chronological, by amount, by risk level</td>\n<td>Sort parameters</td>\n</tr>\n</tbody></table>\n<p><strong>Audit report quality controls</strong> ensure that generated reports accurately represent the underlying audit data:</p>\n<ul>\n<li><strong>Completeness verification</strong> confirms that all audit events within the requested scope are included</li>\n<li><strong>Consistency checks</strong> validate that report totals match underlying database aggregations  </li>\n<li><strong>Cross-period validation</strong> ensures that reports spanning multiple periods properly handle period boundaries</li>\n<li><strong>User permission verification</strong> confirms that report requestors have appropriate access to included data</li>\n<li><strong>Data masking controls</strong> automatically redact sensitive information based on user clearance levels</li>\n</ul>\n<p><strong>Report delivery and distribution</strong> provides secure mechanisms for sharing audit reports with authorized parties:</p>\n<ol>\n<li><strong>Secure download portals</strong> with authentication and access logging</li>\n<li><strong>Automated email delivery</strong> with encrypted attachments for scheduled reports</li>\n<li><strong>API access</strong> for external audit tools that need programmatic access to audit data</li>\n<li><strong>Physical delivery</strong> for highly sensitive reports requiring offline distribution</li>\n<li><strong>Escrow services</strong> for long-term storage with third-party verification capabilities</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Distribution Method</th>\n<th>Security Level</th>\n<th>Use Case</th>\n<th>Audit Trail</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Secure Portal</td>\n<td>High</td>\n<td>Internal audit reviews</td>\n<td>Download tracking</td>\n</tr>\n<tr>\n<td>Encrypted Email</td>\n<td>Medium</td>\n<td>External auditor delivery</td>\n<td>Delivery confirmation</td>\n</tr>\n<tr>\n<td>API Integration</td>\n<td>High</td>\n<td>Automated compliance tools</td>\n<td>API access logs</td>\n</tr>\n<tr>\n<td>Physical Media</td>\n<td>Highest</td>\n<td>Regulatory submissions</td>\n<td>Chain of custody</td>\n</tr>\n<tr>\n<td>Third-party Escrow</td>\n<td>Highest</td>\n<td>Long-term compliance</td>\n<td>Independent verification</td>\n</tr>\n</tbody></table>\n<p><strong>Performance optimization</strong> ensures that audit report generation doesn&#39;t impact operational system performance:</p>\n<ul>\n<li><strong>Read replica queries</strong> isolate report generation from operational database load</li>\n<li><strong>Incremental processing</strong> builds complex reports from cached intermediate results</li>\n<li><strong>Parallel processing</strong> generates different report sections concurrently for faster completion</li>\n<li><strong>Result caching</strong> stores frequently-requested reports for immediate delivery</li>\n<li><strong>Resource throttling</strong> limits report generation resource usage during peak business hours</li>\n</ul>\n<p>⚠️ <strong>Pitfall: Report Data Inconsistency</strong>\nGenerating reports from live operational databases can produce inconsistent results if transactions are occurring during report generation. Use database snapshots or read-consistent isolation levels to ensure report data represents a single point-in-time view.</p>\n<p>⚠️ <strong>Pitfall: Inadequate Report Retention</strong>\nAudit reports themselves become part of the regulatory record and must be retained according to the same requirements as the underlying data. Implement proper retention policies and don&#39;t assume that the ability to regenerate reports satisfies regulatory requirements.</p>\n<blockquote>\n<p>The audit trail system provides the foundation for regulatory compliance by ensuring that every financial transaction and modification is captured, protected, and available for examination. This system must operate with the highest reliability since audit trail gaps or corruption can result in regulatory violations and legal penalties.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Immutable Storage</td>\n<td>PostgreSQL with triggers and constraints</td>\n<td>Dedicated immutable database (FoundationDB)</td>\n</tr>\n<tr>\n<td>Cryptographic Hashing</td>\n<td>Standard library SHA-256</td>\n<td>Hardware security module (HSM)</td>\n</tr>\n<tr>\n<td>Audit Log Storage</td>\n<td>Same database with separate schema</td>\n<td>Time-series database (InfluxDB)</td>\n</tr>\n<tr>\n<td>Report Generation</td>\n<td>Template-based with Go templates</td>\n<td>Dedicated reporting engine (Jasper)</td>\n</tr>\n<tr>\n<td>Digital Signatures</td>\n<td>Software-based signing with stored keys</td>\n<td>Hardware security module with key rotation</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  internal/audit/\n    storage.go              ← immutable storage implementation\n    storage_test.go         ← storage tests\n    tracker.go              ← change history tracking\n    tracker_test.go         ← tracking tests\n    integrity.go            ← cryptographic verification\n    integrity_test.go       ← integrity tests\n    reports.go              ← audit report generation\n    reports_test.go         ← report tests\n    types.go                ← audit trail data structures\n  pkg/crypto/\n    hasher.go               ← hash calculation utilities\n    signer.go               ← digital signature functions\n  migrations/\n    008_audit_tables.sql    ← audit trail database schema\n    009_audit_triggers.sql  ← change tracking triggers</code></pre></div>\n\n<p><strong>A. Complete Audit Trail Infrastructure Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/audit/types.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> audit</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/shopspring/decimal</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AuditEvent</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EventID       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `db:\"event_id\" json:\"event_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EventType     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `db:\"event_type\" json:\"event_type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TableName     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `db:\"table_name\" json:\"table_name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RecordID      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `db:\"record_id\" json:\"record_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FieldName     </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `db:\"field_name\" json:\"field_name\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OldValue      </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `db:\"old_value\" json:\"old_value\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NewValue      </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `db:\"new_value\" json:\"new_value\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    UserID        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `db:\"user_id\" json:\"user_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SessionID     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `db:\"session_id\" json:\"session_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IPAddress     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `db:\"ip_address\" json:\"ip_address\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    UserAgent     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `db:\"user_agent\" json:\"user_agent\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `db:\"timestamp\" json:\"timestamp\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TransactionID </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `db:\"transaction_id\" json:\"transaction_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ChangeReason  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `db:\"change_reason\" json:\"change_reason\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ApprovalID    </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `db:\"approval_id\" json:\"approval_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ParentEventID </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `db:\"parent_event_id\" json:\"parent_event_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IntegrityRecord</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntryID      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `db:\"entry_id\" json:\"entry_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ContentHash  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `db:\"content_hash\" json:\"content_hash\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ChainHash    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `db:\"chain_hash\" json:\"chain_hash\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    PrevHash     </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `db:\"prev_hash\" json:\"prev_hash\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HashAlgorithm </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">   `db:\"hash_algorithm\" json:\"hash_algorithm\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DigitalSignature </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\"> `db:\"digital_signature\" json:\"digital_signature\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SignedAt     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `db:\"signed_at\" json:\"signed_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VerifiedAt   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `db:\"verified_at\" json:\"verified_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsValid      </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">      `db:\"is_valid\" json:\"is_valid\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AuditReport</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ReportID     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"report_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ReportType   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"report_type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DateFrom     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">              `json:\"date_from\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DateTo       </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">              `json:\"date_to\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GeneratedAt  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">              `json:\"generated_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GeneratedBy  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"generated_by\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TotalEvents  </span><span style=\"color:#F97583\">int</span><span style=\"color:#9ECBFF\">                    `json:\"total_events\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Summary      </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"summary\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Events       []</span><span style=\"color:#B392F0\">AuditEvent</span><span style=\"color:#9ECBFF\">           `json:\"events\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Integrity    []</span><span style=\"color:#B392F0\">IntegrityRecord</span><span style=\"color:#9ECBFF\">      `json:\"integrity\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Signatures   []</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">               `json:\"signatures\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Storage configuration for audit system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AuditConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DatabaseURL          </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"database_url\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RetentionPeriod      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"retention_period\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VerificationInterval </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#9ECBFF\"> `json:\"verification_interval\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HashAlgorithm        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"hash_algorithm\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SigningKeyPath       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"signing_key_path\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ReportOutputDir      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">        `json:\"report_output_dir\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EnableRealTimeVerify </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">          `json:\"enable_realtime_verify\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>B. Core Audit Storage Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/audit/storage.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> audit</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/google/uuid</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AuditStorage provides immutable storage operations for audit trail</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AuditStorage</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    RecordEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">event</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">AuditEvent</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetEventHistory</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">recordID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">AuditEvent</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetEventsInRange</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">from</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">to</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">filters</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) ([]</span><span style=\"color:#B392F0\">AuditEvent</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    VerifyIntegrity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entryID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IntegrityRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> Storage</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config </span><span style=\"color:#B392F0\">AuditConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewStorage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> AuditConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Storage</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">Storage</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db: db,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config: config,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecordEvent creates an immutable audit record for a data change</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Storage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RecordEvent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">event</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">AuditEvent</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Generate unique event ID using UUID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Set timestamp to current UTC time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate required fields are present (EventType, TableName, RecordID, UserID)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Insert into audit_events table with conflict detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: If this is a journal entry posting, create integrity record</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update audit statistics for monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use prepared statements to prevent SQL injection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetEventHistory retrieves complete change history for a specific record</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Storage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetEventHistory</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">recordID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">AuditEvent</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Query audit_events table filtering by record_id</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Order results chronologically by timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Include related events using parent_event_id links</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Load associated approval records if approval_id is set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return empty slice if no events found (not an error)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// VerifyIntegrity checks cryptographic hash chain for an entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Storage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">VerifyIntegrity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entryID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IntegrityRecord</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load integrity record for the specified entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Recalculate content hash from journal entry data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Verify chain hash matches previous entry's chain hash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate digital signature using public key</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update verification timestamp and status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Return detailed verification results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// createIntegrityRecord generates cryptographic proof for a journal entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">s </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Storage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">createIntegrityRecord</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entryID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load complete journal entry with all line items</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Generate canonical JSON representation for hashing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate content hash using configured algorithm (SHA-256)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Retrieve previous entry's chain hash for linking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Calculate new chain hash incorporating previous hash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Create digital signature of the chain hash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Store integrity record with all hash values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>C. Change Tracking Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/audit/tracker.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> audit</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/json</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">reflect</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ChangeTracker captures data modifications and creates audit events</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ChangeTracker</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storage </span><span style=\"color:#B392F0\">AuditStorage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    contextProvider </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#B392F0\">UserContext</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> UserContext</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    UserID    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SessionID </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IPAddress </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    UserAgent </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Reason    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewChangeTracker</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">storage</span><span style=\"color:#B392F0\"> AuditStorage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ChangeTracker</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ChangeTracker</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        storage: storage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TrackChanges compares before/after values and creates audit events</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ChangeTracker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TrackChanges</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tableName</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">recordID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">before</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">after</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get user context from session or request headers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Use reflection to compare before/after struct fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create audit event for each changed field with old/new values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Handle nested structs and slices appropriately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Batch multiple field changes into single transaction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Generate parent event ID linking all related changes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TrackStateTransition records status changes like DRAFT -> POSTED</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ChangeTracker</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TrackStateTransition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">recordID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fromState</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">toState</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reason</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Create special audit event type for state transitions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Include business reason for the state change</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Validate that state transition is allowed by business rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Link to any required approval workflows</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// compareStructFields uses reflection to find differences between two structs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> compareStructFields</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">before</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">after</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\">{}) []</span><span style=\"color:#B392F0\">FieldChange</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Use reflection to get struct field values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Compare each field recursively for nested structures  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Convert values to JSON for storage in audit log</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Skip fields marked with audit:\"-\" struct tags</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return list of FieldChange structs with old/new values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> FieldChange</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FieldName </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OldValue  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NewValue  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    FieldType </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>D. Report Generation Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// internal/audit/reports.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> audit</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">html/template</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">bytes</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReportGenerator creates compliance reports from audit trail data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ReportGenerator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    storage </span><span style=\"color:#B392F0\">AuditStorage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    templates </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">template</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Template</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    outputDir </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewReportGenerator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">storage</span><span style=\"color:#B392F0\"> AuditStorage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">outputDir</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReportGenerator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ReportGenerator</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        storage: storage,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        templates: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">template</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Template</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        outputDir: outputDir,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateTransactionHistory creates complete audit trail for date range</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReportGenerator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateTransactionHistory</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">from</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">to</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">format</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuditReport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Query all audit events within date range</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Group events by transaction ID and record ID</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate summary statistics (total events, users, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Run integrity verification on included entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Format output according to specified format (PDF, CSV, JSON)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Apply digital signature to completed report</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Store report file in configured output directory</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateUserActivityReport shows all actions by specific users</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReportGenerator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateUserActivityReport</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userIDs</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">from</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">to</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuditReport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Filter events by user ID list and date range</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Group by user and then by session for logical grouping</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Include privilege escalation and approval events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Highlight any security-relevant events (after hours, bulk changes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Cross-reference with authentication logs for session validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateIntegrityVerificationReport shows hash chain status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReportGenerator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateIntegrityVerificationReport</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuditReport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Run full integrity verification on all posted entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Identify any hash chain breaks or signature failures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Generate summary of verification coverage and results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Include recommendations for any integrity issues found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Format as compliance-ready report with executive summary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// formatReport converts audit data to requested output format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReportGenerator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">formatReport</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">report</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">AuditReport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">format</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Load appropriate template for the format type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Execute template with report data as context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: For PDF format, convert HTML to PDF using library</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: For CSV format, flatten nested data appropriately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Include metadata headers and digital signatures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>E. Milestone Checkpoints:</strong></p>\n<p>After implementing immutable storage:</p>\n<ul>\n<li>Run <code>go test ./internal/audit/...</code> - all storage tests should pass</li>\n<li>Attempt to UPDATE a posted journal entry directly in database - should fail with permission error</li>\n<li>Post a journal entry and verify it appears in audit_events table with correct metadata</li>\n<li>Check that integrity_records table has corresponding hash entry</li>\n</ul>\n<p>After implementing change tracking:</p>\n<ul>\n<li>Modify an account name through the API - verify field-level change appears in audit log</li>\n<li>Change journal entry status from DRAFT to POSTED - verify state transition is tracked</li>\n<li>Review audit_events table to confirm before/after values are captured correctly</li>\n</ul>\n<p>After implementing cryptographic integrity:</p>\n<ul>\n<li>Verify hash chain by checking that each entry&#39;s chain_hash incorporates previous entry</li>\n<li>Run integrity verification on sample entries - should return IsValid=true</li>\n<li>Manually corrupt a hash value in database and verify corruption is detected</li>\n</ul>\n<p>After implementing audit reports:</p>\n<ul>\n<li>Generate transaction history report for a date range - verify all entries included</li>\n<li>Export report in PDF format - should be readable with proper formatting</li>\n<li>Generate integrity verification report - should show all entries verified successfully</li>\n</ul>\n<blockquote>\n<p><strong>Milestone(s):</strong> 5 (Financial Reports), as this section implements the generation of standard financial statements including trial balance, balance sheet, and income statement that provide management insights into the organization&#39;s financial position</p>\n</blockquote>\n<h2 id=\"financial-reporting-module\">Financial Reporting Module</h2>\n<p>Think of the financial reporting module as the dashboard of an airplane cockpit. While the ledger system records every transaction like a flight recorder, the reporting module transforms this raw data into meaningful instruments that help managers navigate their organization. Just as pilots need altitude, speed, and fuel gauges to make informed decisions, business managers need trial balance, balance sheet, and income statements to understand their financial position and performance.</p>\n<p>The financial reporting module sits at the convergence of all other ledger components. It reads from the immutable audit trail to ensure data integrity, queries the balance calculation engine for current and historical balances, and applies accounting principles to transform raw transaction data into standardized financial statements that comply with regulatory requirements and business needs.</p>\n<p>The core challenge in financial reporting is transforming the flat structure of journal entries into the hierarchical, categorized view that financial statements require. Every journal entry affects individual accounts, but financial reports aggregate these accounts by type, apply sign conventions, and present them in standardized formats that reveal the organization&#39;s financial story.</p>\n<h3 id=\"trial-balance-report\">Trial Balance Report</h3>\n<p>The <strong>trial balance report</strong> serves as the foundation and validation checkpoint for all other financial reports. Think of it as a mathematician&#39;s proof that the double-entry system is working correctly—it lists every account with its debit and credit totals to verify that the fundamental accounting equation remains in balance.</p>\n<p>The trial balance provides both a comprehensive account listing and a system integrity check. When total debits equal total credits, we have mathematical proof that every journal entry has been recorded correctly according to double-entry principles. When they don&#39;t match, we have identified a data integrity problem that must be resolved before generating other financial statements.</p>\n<blockquote>\n<p><strong>Decision: Real-Time vs Snapshot Trial Balance Generation</strong></p>\n<ul>\n<li><strong>Context</strong>: Trial balance reports can be generated on-demand from current data or from pre-calculated snapshots</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>On-demand calculation from live ledger data</li>\n<li>Pre-calculated snapshots updated after each posting</li>\n<li>Hybrid approach with cached daily snapshots plus incremental updates</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: On-demand calculation with aggressive caching for recently accessed date ranges</li>\n<li><strong>Rationale</strong>: Provides real-time accuracy for current reporting while avoiding the complexity of maintaining snapshot consistency across concurrent transactions</li>\n<li><strong>Consequences</strong>: Slight performance cost for first access to historical dates, but eliminates snapshot synchronization complexity and guarantees accuracy</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Calculation Method</th>\n<th>Accuracy</th>\n<th>Performance</th>\n<th>Complexity</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>On-demand calculation</td>\n<td>Perfect</td>\n<td>Slow for large ledgers</td>\n<td>Low</td>\n<td>✓</td>\n</tr>\n<tr>\n<td>Pre-calculated snapshots</td>\n<td>Eventually consistent</td>\n<td>Fast</td>\n<td>High</td>\n<td>✗</td>\n</tr>\n<tr>\n<td>Hybrid cached approach</td>\n<td>Perfect with delay</td>\n<td>Medium</td>\n<td>Medium</td>\n<td>Future enhancement</td>\n</tr>\n</tbody></table>\n<p>The trial balance generation process follows a systematic approach to account aggregation and validation. The system queries all accounts with their current balances, applies proper sign conventions based on account type, and performs mathematical verification to ensure the books are in balance.</p>\n<p><strong>Trial Balance Generation Algorithm:</strong></p>\n<ol>\n<li>Query all active accounts from the chart of accounts, including their type and current balance information</li>\n<li>For each account, retrieve the current balance using the balance calculation engine&#39;s caching mechanisms</li>\n<li>Apply normal balance conventions—assets and expenses show debit balances, while liabilities, equity, and revenues show credit balances</li>\n<li>Calculate running totals for the debit and credit columns as accounts are processed</li>\n<li>Include accounts with zero balances to provide complete chart of accounts visibility</li>\n<li>Sort accounts by account code to provide consistent, logical ordering for review</li>\n<li>Calculate the variance between total debits and total credits to identify any imbalances</li>\n<li>Generate warning indicators for accounts with abnormal balances (credit balances for asset accounts, etc.)</li>\n<li>Include metadata such as the report generation timestamp and date range for audit purposes</li>\n</ol>\n<p>The <code>TrialBalance</code> structure contains comprehensive information for both validation and presentation purposes:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AsOfDate</td>\n<td>time.Time</td>\n<td>Date for which the trial balance is calculated</td>\n</tr>\n<tr>\n<td>AccountBalances</td>\n<td>[]AccountBalance</td>\n<td>Array of all account balances with detailed information</td>\n</tr>\n<tr>\n<td>TotalDebits</td>\n<td>Money</td>\n<td>Sum of all debit balances across all accounts</td>\n</tr>\n<tr>\n<td>TotalCredits</td>\n<td>Money</td>\n<td>Sum of all credit balances across all accounts</td>\n</tr>\n<tr>\n<td>IsBalanced</td>\n<td>bool</td>\n<td>True when total debits equal total credits</td>\n</tr>\n<tr>\n<td>Variance</td>\n<td>Money</td>\n<td>Difference between debits and credits (should be zero)</td>\n</tr>\n<tr>\n<td>GeneratedAt</td>\n<td>time.Time</td>\n<td>Timestamp when the report was generated</td>\n</tr>\n</tbody></table>\n<p>The <code>AccountBalance</code> structure provides detailed information for each account line in the trial balance:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AccountID</td>\n<td>string</td>\n<td>Unique identifier for the account</td>\n</tr>\n<tr>\n<td>AccountCode</td>\n<td>string</td>\n<td>Human-readable account code for sorting and reference</td>\n</tr>\n<tr>\n<td>AccountName</td>\n<td>string</td>\n<td>Descriptive account name for presentation</td>\n</tr>\n<tr>\n<td>AccountType</td>\n<td>AccountType</td>\n<td>Account category (ASSET, LIABILITY, EQUITY, REVENUE, EXPENSE)</td>\n</tr>\n<tr>\n<td>Balance</td>\n<td>Money</td>\n<td>Net balance considering normal balance conventions</td>\n</tr>\n<tr>\n<td>DebitAmount</td>\n<td>*Money</td>\n<td>Balance shown in debit column (nil if credit balance)</td>\n</tr>\n<tr>\n<td>CreditAmount</td>\n<td>*Money</td>\n<td>Balance shown in credit column (nil if debit balance)</td>\n</tr>\n<tr>\n<td>LastEntryDate</td>\n<td>time.Time</td>\n<td>Date of most recent transaction affecting this account</td>\n</tr>\n</tbody></table>\n<p><strong>Point-in-Time Trial Balance Calculation:</strong></p>\n<p>When generating historical trial balances, the system must calculate balances as they existed at a specific date, considering only journal entries posted on or before that date. This requires coordination with the balance calculation engine&#39;s point-in-time query capabilities.</p>\n<p>The historical trial balance process involves querying each account&#39;s balance as of the specified date, which may require summing journal entry lines from the beginning of the accounting period up to the target date. The balance calculation engine optimizes this through snapshot caching and incremental calculation techniques.</p>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Ignoring Account Type Sign Conventions</strong></p>\n<p>A common mistake is displaying raw balance amounts without applying proper sign conventions for the trial balance format. Asset and expense accounts should show positive balances in the debit column, while liability, equity, and revenue accounts should show positive balances in the credit column. Simply displaying the stored balance amount can result in confusing negative numbers or incorrect column placement.</p>\n<p><strong>Fix</strong>: Apply the <code>NormalBalance()</code> method to determine which column should display the balance, and use the absolute value of the balance amount to avoid negative numbers in the trial balance presentation.</p>\n</blockquote>\n<p>The trial balance serves as a critical validation checkpoint before generating other financial statements. Any variance in the trial balance indicates a fundamental problem with the ledger data that must be resolved before proceeding with balance sheet or income statement generation.</p>\n<h3 id=\"balance-sheet-generation\">Balance Sheet Generation</h3>\n<p>The <strong>balance sheet generation</strong> transforms the trial balance data into a structured financial position statement that follows the fundamental accounting equation: Assets = Liabilities + Equity. Think of the balance sheet as a snapshot photograph of the organization&#39;s financial position at a specific moment in time—it shows what the company owns (assets), what it owes (liabilities), and what belongs to the owners (equity).</p>\n<p>Unlike the trial balance which simply lists all accounts, the balance sheet requires sophisticated categorization, hierarchy management, and presentation logic to group accounts into meaningful sections and calculate subtotals that provide business insight.</p>\n<blockquote>\n<p><strong>Decision: Balance Sheet Account Grouping Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Balance sheet accounts must be organized into logical groups like Current Assets, Fixed Assets, Current Liabilities, etc.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Hard-coded account type mapping with fixed categories</li>\n<li>Configurable account hierarchy using parent-child relationships</li>\n<li>Tag-based categorization with multiple classification dimensions</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Configurable account hierarchy with standard parent account categories</li>\n<li><strong>Rationale</strong>: Provides flexibility for different organization structures while maintaining the ability to generate standardized reports</li>\n<li><strong>Consequences</strong>: Requires careful chart of accounts design but enables customized balance sheet presentations</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Grouping Strategy</th>\n<th>Flexibility</th>\n<th>Standardization</th>\n<th>Complexity</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Hard-coded mapping</td>\n<td>Low</td>\n<td>High</td>\n<td>Low</td>\n<td>✗</td>\n</tr>\n<tr>\n<td>Configurable hierarchy</td>\n<td>High</td>\n<td>Medium</td>\n<td>Medium</td>\n<td>✓</td>\n</tr>\n<tr>\n<td>Tag-based categorization</td>\n<td>Very High</td>\n<td>Low</td>\n<td>High</td>\n<td>Future enhancement</td>\n</tr>\n</tbody></table>\n<p><strong>Balance Sheet Generation Algorithm:</strong></p>\n<ol>\n<li>Generate a current trial balance to obtain all account balances and verify the books are in balance</li>\n<li>Filter trial balance to include only balance sheet accounts (ASSET, LIABILITY, EQUITY types)</li>\n<li>Group accounts by their parent account relationships to create the hierarchy structure</li>\n<li>Calculate subtotals for major categories like Current Assets, Fixed Assets, Current Liabilities, Long-term Debt</li>\n<li>Apply standard balance sheet ordering conventions with assets first, then liabilities, then equity</li>\n<li>Calculate total assets and total liabilities plus equity to verify they balance</li>\n<li>Include comparative figures from prior periods if requested for trend analysis</li>\n<li>Format monetary amounts according to presentation requirements and rounding policies</li>\n<li>Generate supplementary notes for accounts that require additional disclosure</li>\n</ol>\n<p>The <code>BalanceSheet</code> structure organizes the financial position data for presentation:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AsOfDate</td>\n<td>time.Time</td>\n<td>Date of the balance sheet snapshot</td>\n</tr>\n<tr>\n<td>Assets</td>\n<td>[]AccountSection</td>\n<td>Hierarchical listing of asset accounts and subtotals</td>\n</tr>\n<tr>\n<td>Liabilities</td>\n<td>[]AccountSection</td>\n<td>Hierarchical listing of liability accounts and subtotals</td>\n</tr>\n<tr>\n<td>Equity</td>\n<td>[]AccountSection</td>\n<td>Hierarchical listing of equity accounts and subtotals</td>\n</tr>\n<tr>\n<td>TotalAssets</td>\n<td>Money</td>\n<td>Sum of all asset account balances</td>\n</tr>\n<tr>\n<td>TotalLiabilitiesAndEquity</td>\n<td>Money</td>\n<td>Sum of all liability and equity balances</td>\n</tr>\n<tr>\n<td>IsBalanced</td>\n<td>bool</td>\n<td>True when assets equal liabilities plus equity</td>\n</tr>\n<tr>\n<td>GeneratedAt</td>\n<td>time.Time</td>\n<td>Timestamp when the report was generated</td>\n</tr>\n<tr>\n<td>PriorPeriodComparison</td>\n<td>*BalanceSheet</td>\n<td>Optional comparative figures from previous period</td>\n</tr>\n</tbody></table>\n<p>The <code>AccountSection</code> structure supports the hierarchical presentation required for readable balance sheets:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SectionTitle</td>\n<td>string</td>\n<td>Header text like &quot;Current Assets&quot; or &quot;Long-term Debt&quot;</td>\n</tr>\n<tr>\n<td>Accounts</td>\n<td>[]AccountBalance</td>\n<td>Individual accounts within this section</td>\n</tr>\n<tr>\n<td>Subsections</td>\n<td>[]AccountSection</td>\n<td>Nested sections for complex hierarchies</td>\n</tr>\n<tr>\n<td>SectionTotal</td>\n<td>Money</td>\n<td>Sum of all accounts and subsections in this section</td>\n</tr>\n<tr>\n<td>DisplayOrder</td>\n<td>int</td>\n<td>Sorting order for consistent presentation</td>\n</tr>\n</tbody></table>\n<p><strong>Asset Classification and Ordering:</strong></p>\n<p>Balance sheet assets follow standard presentation conventions with current assets (expected to be converted to cash within one year) listed before long-term assets. The system applies these classification rules automatically based on account hierarchy and account code conventions.</p>\n<p>Current assets typically include cash accounts, accounts receivable, inventory, and prepaid expenses. Fixed assets include property, plant, and equipment, often with accumulated depreciation shown as contra-asset accounts that reduce the gross asset value.</p>\n<p><strong>Liability Classification and Presentation:</strong></p>\n<p>Liabilities are classified as current (due within one year) or long-term based on the account hierarchy configuration. Current liabilities include accounts payable, accrued expenses, and current portions of long-term debt. Long-term liabilities include mortgages, bonds, and other debt with maturity beyond one year.</p>\n<p><strong>Equity Section Calculation:</strong></p>\n<p>The equity section includes contributed capital, retained earnings, and current period net income. For organizations with complex equity structures, the system supports multiple equity classes and detailed equity movement tracking.</p>\n<blockquote>\n<p><strong>Critical Insight: Balance Sheet Balancing Validation</strong></p>\n<p>The balance sheet must mathematically balance with total assets equaling total liabilities plus equity. Any imbalance indicates either a trial balance error or a classification mistake in the balance sheet generation logic. The system should validate this equality and provide detailed variance analysis when imbalances occur.</p>\n</blockquote>\n<p><strong>Comparative Balance Sheet Generation:</strong></p>\n<p>When generating comparative balance sheets, the system retrieves balance sheet data for multiple periods and presents them side-by-side for trend analysis. This requires point-in-time balance calculations for each comparison period and careful formatting to align corresponding line items.</p>\n<p>⚠️ <strong>Pitfall: Incorrect Account Type Classification</strong></p>\n<p>Misclassifying accounts between current and long-term categories can significantly distort financial ratios and analysis. For example, classifying long-term debt as current liability inflates current liabilities and makes the organization appear to have liquidity problems.</p>\n<p><strong>Fix</strong>: Implement validation rules that check account classifications against business logic and provide warnings for unusual account type assignments. Regular review of the chart of accounts hierarchy ensures classifications remain accurate as business needs evolve.</p>\n<h3 id=\"income-statement-generation\">Income Statement Generation</h3>\n<p>The <strong>income statement generation</strong> creates a period-based financial performance report that follows the fundamental profit calculation: Net Income = Total Revenues - Total Expenses. Think of the income statement as a movie showing the organization&#39;s financial performance over time, contrasted with the balance sheet which is a snapshot at a point in time.</p>\n<p>The income statement focuses exclusively on revenue and expense accounts, transforming the period&#39;s transaction activity into a structured performance narrative that shows how the organization generated revenue, what it cost to deliver products or services, and what profit or loss resulted from operations.</p>\n<blockquote>\n<p><strong>Decision: Income Statement Period Boundary Handling</strong></p>\n<ul>\n<li><strong>Context</strong>: Income statements require precise period boundaries to avoid double-counting or missing transactions</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Transaction date-based period boundaries using journal entry dates</li>\n<li>Posting date-based boundaries using when entries were recorded in the system</li>\n<li>Configurable date field selection allowing either transaction or posting date</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Transaction date-based boundaries with posting date audit trails</li>\n<li><strong>Rationale</strong>: Transaction dates represent when economic events occurred, providing more accurate period matching</li>\n<li><strong>Consequences</strong>: Requires careful handling of entries posted after period close and clear audit trails for timing differences</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Boundary Method</th>\n<th>Accuracy</th>\n<th>Auditability</th>\n<th>Complexity</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Transaction date</td>\n<td>High</td>\n<td>Medium</td>\n<td>Low</td>\n<td>✓</td>\n</tr>\n<tr>\n<td>Posting date</td>\n<td>Medium</td>\n<td>High</td>\n<td>Low</td>\n<td>✗</td>\n</tr>\n<tr>\n<td>Configurable field</td>\n<td>High</td>\n<td>High</td>\n<td>High</td>\n<td>Future consideration</td>\n</tr>\n</tbody></table>\n<p><strong>Income Statement Generation Algorithm:</strong></p>\n<ol>\n<li>Define the reporting period with precise start and end dates for transaction inclusion</li>\n<li>Query all revenue and expense accounts from the chart of accounts with their account hierarchy</li>\n<li>Calculate net activity for each account during the period using point-in-time balance differences</li>\n<li>Group accounts into logical income statement sections like Revenue, Cost of Goods Sold, Operating Expenses</li>\n<li>Calculate subtotals for major sections like Gross Profit (Revenue minus Cost of Goods Sold)</li>\n<li>Apply standard income statement ordering with revenues first, then expenses by category</li>\n<li>Calculate net income as the final bottom-line result of revenue minus all expenses</li>\n<li>Include comparative figures from prior periods for trend analysis and variance identification</li>\n<li>Generate supporting schedules for complex revenue or expense categories requiring additional detail</li>\n</ol>\n<p>The <code>IncomeStatement</code> structure organizes the period performance data:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PeriodStart</td>\n<td>time.Time</td>\n<td>Beginning date of the reporting period</td>\n</tr>\n<tr>\n<td>PeriodEnd</td>\n<td>time.Time</td>\n<td>Ending date of the reporting period</td>\n</tr>\n<tr>\n<td>Revenues</td>\n<td>[]AccountSection</td>\n<td>Hierarchical listing of revenue accounts and subtotals</td>\n</tr>\n<tr>\n<td>CostOfGoodsSold</td>\n<td>[]AccountSection</td>\n<td>Direct costs associated with revenue generation</td>\n</tr>\n<tr>\n<td>OperatingExpenses</td>\n<td>[]AccountSection</td>\n<td>Indirect costs of running the business</td>\n</tr>\n<tr>\n<td>OtherIncomeExpense</td>\n<td>[]AccountSection</td>\n<td>Non-operating income and expense items</td>\n</tr>\n<tr>\n<td>TotalRevenue</td>\n<td>Money</td>\n<td>Sum of all revenue accounts for the period</td>\n</tr>\n<tr>\n<td>GrossProfit</td>\n<td>Money</td>\n<td>Total revenue minus cost of goods sold</td>\n</tr>\n<tr>\n<td>OperatingIncome</td>\n<td>Money</td>\n<td>Gross profit minus operating expenses</td>\n</tr>\n<tr>\n<td>NetIncome</td>\n<td>Money</td>\n<td>Final profit or loss after all income and expenses</td>\n</tr>\n<tr>\n<td>GeneratedAt</td>\n<td>time.Time</td>\n<td>Timestamp when the report was generated</td>\n</tr>\n<tr>\n<td>ComparativePeriod</td>\n<td>*IncomeStatement</td>\n<td>Optional comparison to prior period</td>\n</tr>\n</tbody></table>\n<p><strong>Period Activity Calculation:</strong></p>\n<p>Income statement amounts represent the net activity in each account during the reporting period. This requires calculating the change in account balance from the beginning to the end of the period, which may involve querying point-in-time balances for period start and end dates.</p>\n<p>For revenue accounts, period activity typically represents credit entries (increases) minus any debit entries (decreases or reversals). For expense accounts, period activity represents debit entries (increases) minus any credit entries (reimbursements or reversals).</p>\n<p><strong>Revenue Recognition and Matching:</strong></p>\n<p>The income statement must properly match revenues with related expenses to provide meaningful performance measurement. This requires careful attention to when transactions are recognized in the period and ensuring that all related costs are included in the same period.</p>\n<p><strong>Multi-Period Comparative Analysis:</strong></p>\n<p>Comparative income statements show multiple periods side-by-side to reveal trends, seasonal patterns, and performance changes. The system calculates variance amounts and percentages to highlight significant changes between periods.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Year-over-Year Comparison Example:\n                    2024        2023        Variance    %Change\nTotal Revenue    $100,000     $85,000      $15,000     17.6%\nCost of Sales     $60,000     $55,000       $5,000      9.1%\nGross Profit      $40,000     $30,000      $10,000     33.3%</code></pre></div>\n\n<blockquote>\n<p>⚠️ <strong>Pitfall: Period Cut-off Errors</strong></p>\n<p>Incorrect period boundaries can significantly distort income statement results by including transactions from the wrong period or excluding transactions that should be included. This is especially problematic near period-end when transactions may be recorded in the system days after they actually occurred.</p>\n<p><strong>Fix</strong>: Implement clear period cut-off procedures that define which date field determines period inclusion, and provide audit reports showing transactions with timing differences between transaction and posting dates.</p>\n</blockquote>\n<p><strong>Quarterly and Annual Roll-up Calculation:</strong></p>\n<p>The system supports income statement generation for various periods including monthly, quarterly, and annual reports. For cumulative periods like year-to-date income statements, the calculation includes all activity from the beginning of the fiscal year through the selected end date.</p>\n<h3 id=\"multi-currency-report-translation\">Multi-Currency Report Translation</h3>\n<p><strong>Multi-currency report translation</strong> enables organizations with international operations to generate consolidated financial reports in a single presentation currency while maintaining the accuracy of transactions recorded in their original currencies. Think of this as being a financial translator that converts foreign language (currency) transactions into a common language that management can understand and analyze.</p>\n<p>The translation process must handle two distinct scenarios: transactions that occurred in foreign currencies during the reporting period, and translation of foreign subsidiary financial statements for consolidation purposes. Each scenario requires different exchange rate application methods and timing considerations.</p>\n<blockquote>\n<p><strong>Decision: Exchange Rate Application Method</strong></p>\n<ul>\n<li><strong>Context</strong>: Multi-currency translation requires choosing when and how to apply exchange rates</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Transaction date rates for all currency conversions</li>\n<li>Period-end rates for all balance sheet items and average rates for income statement</li>\n<li>Mixed approach with transaction rates for revenues/expenses and period-end rates for assets/liabilities</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Period-end rates for balance sheet items and average rates for income statement items</li>\n<li><strong>Rationale</strong>: Follows standard accounting principles (GAAP/IFRS) for foreign currency translation</li>\n<li><strong>Consequences</strong>: Requires maintaining both transaction-date and period-end exchange rate data</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Translation Method</th>\n<th>Accuracy</th>\n<th>Complexity</th>\n<th>Standards Compliance</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Transaction date rates</td>\n<td>High</td>\n<td>Low</td>\n<td>Partial</td>\n<td>✗</td>\n</tr>\n<tr>\n<td>Period-end/average rates</td>\n<td>Medium</td>\n<td>Medium</td>\n<td>High</td>\n<td>✓</td>\n</tr>\n<tr>\n<td>Mixed rate approach</td>\n<td>Very High</td>\n<td>High</td>\n<td>High</td>\n<td>Future enhancement</td>\n</tr>\n</tbody></table>\n<p><strong>Multi-Currency Translation Algorithm:</strong></p>\n<ol>\n<li>Identify all accounts with balances in currencies other than the presentation currency</li>\n<li>Retrieve appropriate exchange rates based on account type and reporting standards requirements</li>\n<li>Apply current period-end exchange rates to balance sheet accounts (assets, liabilities, equity)</li>\n<li>Apply average exchange rates for the period to income statement accounts (revenues, expenses)</li>\n<li>Calculate translation gains and losses from exchange rate fluctuations during the period</li>\n<li>Record translation adjustments in the appropriate equity account (cumulative translation adjustment)</li>\n<li>Generate translated financial statements with original and translated amounts for transparency</li>\n<li>Provide supporting schedules showing exchange rates used and translation methodology</li>\n<li>Calculate and present the impact of exchange rate changes on financial performance</li>\n</ol>\n<p>The <code>CurrencyTranslation</code> structure manages the translation process and results:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PresentationCurrency</td>\n<td>string</td>\n<td>Target currency for consolidated reporting</td>\n</tr>\n<tr>\n<td>TranslationDate</td>\n<td>time.Time</td>\n<td>Date for which translation rates are applied</td>\n</tr>\n<tr>\n<td>ExchangeRates</td>\n<td>map[string]ExchangeRate</td>\n<td>Current rates for each foreign currency</td>\n</tr>\n<tr>\n<td>AverageRates</td>\n<td>map[string]ExchangeRate</td>\n<td>Period average rates for income statement translation</td>\n</tr>\n<tr>\n<td>TranslatedAccounts</td>\n<td>[]TranslatedAccount</td>\n<td>Account balances in both original and presentation currencies</td>\n</tr>\n<tr>\n<td>TranslationAdjustment</td>\n<td>Money</td>\n<td>Net gain or loss from currency translation</td>\n</tr>\n<tr>\n<td>MethodologyNotes</td>\n<td>string</td>\n<td>Description of translation methods and rate sources</td>\n</tr>\n</tbody></table>\n<p>The <code>TranslatedAccount</code> structure preserves both original and translated values for audit trails:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AccountID</td>\n<td>string</td>\n<td>Reference to the underlying account</td>\n</tr>\n<tr>\n<td>OriginalBalance</td>\n<td>Money</td>\n<td>Balance in the account&#39;s native currency</td>\n</tr>\n<tr>\n<td>TranslatedBalance</td>\n<td>Money</td>\n<td>Balance converted to presentation currency</td>\n</tr>\n<tr>\n<td>ExchangeRateUsed</td>\n<td>ExchangeRate</td>\n<td>Rate applied for this translation</td>\n</tr>\n<tr>\n<td>TranslationMethod</td>\n<td>string</td>\n<td>Description of rate type used (period-end, average, historical)</td>\n</tr>\n<tr>\n<td>LastTranslationDate</td>\n<td>time.Time</td>\n<td>When this translation was last updated</td>\n</tr>\n</tbody></table>\n<p><strong>Exchange Rate Management:</strong></p>\n<p>The system must maintain historical exchange rates for accurate period comparisons and audit purposes. Exchange rates include not only the rate value but also the source, effective date, and rate type (spot, average, forward).</p>\n<p><strong>Balance Sheet Translation:</strong></p>\n<p>Balance sheet accounts use current exchange rates as of the balance sheet date. This creates translation gains and losses when exchange rates change between reporting periods, requiring careful tracking of these adjustments in the equity section.</p>\n<p><strong>Income Statement Translation:</strong></p>\n<p>Income statement accounts typically use average exchange rates for the reporting period to smooth out exchange rate fluctuations that would otherwise distort period performance. The system calculates weighted averages based on transaction volumes or uses published average rates from financial data providers.</p>\n<blockquote>\n<p><strong>Critical Insight: Translation Adjustment Tracking</strong></p>\n<p>Currency translation creates gains and losses that don&#39;t represent actual cash flows but result from exchange rate changes. These translation adjustments must be tracked separately from operational gains and losses to provide clear insight into underlying business performance versus currency impact.</p>\n</blockquote>\n<p><strong>Consolidation Translation Process:</strong></p>\n<p>When consolidating foreign subsidiary financial statements, the translation process follows these steps:</p>\n<ol>\n<li>Translate subsidiary trial balance using appropriate exchange rates for each account type</li>\n<li>Calculate translation adjustments resulting from exchange rate changes since the prior period</li>\n<li>Eliminate intercompany transactions and balances before consolidation</li>\n<li>Combine translated subsidiary results with parent company financial statements</li>\n<li>Present consolidated results with footnote disclosure of translation methods and exchange rate impacts</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Mixing Translation Methods Within Account Types</strong></p>\n<p>Using inconsistent exchange rate types for similar accounts can create artificial variances and make period comparisons meaningless. For example, translating some revenue accounts at transaction date rates while others use average rates creates inconsistent income statement presentation.</p>\n<p><strong>Fix</strong>: Establish clear translation policies that specify which exchange rate type to use for each account category, and implement validation rules that ensure consistent application across all accounts of the same type.</p>\n<h3 id=\"accounting-period-closing\">Accounting Period Closing</h3>\n<p><strong>Accounting period closing</strong> represents the systematic process of finalizing all transactions for a specific period and transferring temporary account balances to permanent accounts. Think of period closing as sealing a time capsule—once a period is closed, its contents become historical record that cannot be altered, only referenced for future analysis.</p>\n<p>The period closing process serves multiple critical functions: it prevents retroactive changes that would compromise audit trails, it transfers profit and loss results to retained earnings, and it resets temporary accounts for the new accounting period. This process maintains the integrity of period comparisons and ensures that each accounting period stands as a complete, immutable record.</p>\n<blockquote>\n<p><strong>Decision: Period Closing Enforcement Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Organizations need to prevent changes to closed periods while allowing necessary corrections</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Hard close preventing any changes to closed periods</li>\n<li>Soft close allowing authorized corrections with approval workflow</li>\n<li>Configurable close with organization-defined rules and override capabilities</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Soft close with approval workflow and reversal-only corrections</li>\n<li><strong>Rationale</strong>: Balances audit trail integrity with practical business needs for error correction</li>\n<li><strong>Consequences</strong>: Requires robust approval workflows and clear audit trails for all post-closing adjustments</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Closing Strategy</th>\n<th>Data Integrity</th>\n<th>Business Flexibility</th>\n<th>Audit Complexity</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Hard close</td>\n<td>Very High</td>\n<td>Low</td>\n<td>Low</td>\n<td>✗</td>\n</tr>\n<tr>\n<td>Soft close with approval</td>\n<td>High</td>\n<td>High</td>\n<td>Medium</td>\n<td>✓</td>\n</tr>\n<tr>\n<td>Configurable close</td>\n<td>Medium</td>\n<td>Very High</td>\n<td>High</td>\n<td>Future consideration</td>\n</tr>\n</tbody></table>\n<p><strong>Period Closing Algorithm:</strong></p>\n<ol>\n<li>Validate that all transactions intended for the period have been posted and none are in draft status</li>\n<li>Generate and review trial balance to ensure books are in balance before closing procedures begin</li>\n<li>Post any required period-end adjusting entries like depreciation, accruals, and reclassifications</li>\n<li>Generate all standard financial reports for the period and archive them as official period results</li>\n<li>Calculate net income for the period by summing all revenue and expense account balances</li>\n<li>Create closing entries that transfer all revenue and expense balances to retained earnings</li>\n<li>Reset all temporary accounts (revenues and expenses) to zero balances for the new period</li>\n<li>Set the period status to closed and implement restrictions on posting new entries to closed periods</li>\n<li>Archive detailed transaction data for the closed period and update period-end balance snapshots</li>\n<li>Generate period closing reports showing the closing entries and confirming successful completion</li>\n</ol>\n<p>The <code>AccountingPeriod</code> structure tracks period status and closing information:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PeriodID</td>\n<td>string</td>\n<td>Unique identifier for the accounting period</td>\n</tr>\n<tr>\n<td>StartDate</td>\n<td>time.Time</td>\n<td>Beginning date of the accounting period</td>\n</tr>\n<tr>\n<td>EndDate</td>\n<td>time.Time</td>\n<td>Ending date of the accounting period</td>\n</tr>\n<tr>\n<td>PeriodType</td>\n<td>string</td>\n<td>Type of period (monthly, quarterly, annual)</td>\n</tr>\n<tr>\n<td>Status</td>\n<td>PeriodStatus</td>\n<td>Current status (OPEN, SOFT_CLOSED, HARD_CLOSED)</td>\n</tr>\n<tr>\n<td>ClosedBy</td>\n<td>*string</td>\n<td>User who performed the closing process</td>\n</tr>\n<tr>\n<td>ClosedAt</td>\n<td>*time.Time</td>\n<td>Timestamp when the period was closed</td>\n</tr>\n<tr>\n<td>NetIncome</td>\n<td>*Money</td>\n<td>Calculated net income for the closed period</td>\n</tr>\n<tr>\n<td>ClosingEntryIDs</td>\n<td>[]string</td>\n<td>Journal entries created during closing process</td>\n</tr>\n<tr>\n<td>AdjustmentCount</td>\n<td>int</td>\n<td>Number of post-closing adjustments made</td>\n</tr>\n<tr>\n<td>FinalTrialBalanceID</td>\n<td>*string</td>\n<td>Reference to archived trial balance for the period</td>\n</tr>\n</tbody></table>\n<p>The <code>PeriodClosingEntry</code> structure documents the automatic entries created during closing:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>EntryID</td>\n<td>string</td>\n<td>Reference to the journal entry created</td>\n</tr>\n<tr>\n<td>EntryType</td>\n<td>ClosingEntryType</td>\n<td>Type of closing entry (REVENUE_CLOSE, EXPENSE_CLOSE, INCOME_SUMMARY)</td>\n</tr>\n<tr>\n<td>AccountsAffected</td>\n<td>[]string</td>\n<td>List of accounts involved in this closing entry</td>\n</tr>\n<tr>\n<td>Amount</td>\n<td>Money</td>\n<td>Total amount being transferred</td>\n</tr>\n<tr>\n<td>Description</td>\n<td>string</td>\n<td>Explanation of the closing entry purpose</td>\n</tr>\n<tr>\n<td>AutoGenerated</td>\n<td>bool</td>\n<td>True if created automatically by the closing process</td>\n</tr>\n</tbody></table>\n<p><strong>Revenue and Expense Account Closing:</strong></p>\n<p>The closing process creates journal entries that transfer all revenue account balances to an Income Summary account (or directly to Retained Earnings). Revenue accounts, which normally have credit balances, are debited for their full balance amount to reduce them to zero.</p>\n<p>Similarly, expense accounts, which normally have debit balances, are credited for their full balance amount to reduce them to zero, with the corresponding debit posted to Income Summary.</p>\n<p><strong>Income Summary Transfer:</strong></p>\n<p>After all revenue and expense accounts have been closed to Income Summary, the net balance in Income Summary represents the period&#39;s net income or net loss. This balance is then transferred to Retained Earnings with a final closing entry, leaving Income Summary with a zero balance.</p>\n<p><strong>Dividend and Distribution Closing:</strong></p>\n<p>For entities that distribute profits to owners, the closing process includes transferring dividend or distribution accounts to reduce Retained Earnings by the amount of profits distributed during the period.</p>\n<blockquote>\n<p><strong>Critical Insight: Reversible Closing Entries</strong></p>\n<p>All closing entries must be designed as reversible transactions that can be undone if period reopening becomes necessary. This requires generating closing entries with clear identification and the ability to create exact reversal entries that restore account balances to their pre-closing state.</p>\n</blockquote>\n<p><strong>Period Reopening Procedures:</strong></p>\n<p>When business requirements necessitate reopening a closed period, the system must reverse all closing entries in the exact reverse order they were created, restore temporary account balances, and change the period status back to open. This process maintains audit trail integrity while accommodating legitimate business needs.</p>\n<p><strong>Multi-Period Closing Coordination:</strong></p>\n<p>The system coordinates closing procedures across multiple periods to ensure that quarterly and annual closes properly aggregate monthly results. This requires validating that all subsidiary periods are closed before allowing parent period closing.</p>\n<p>⚠️ <strong>Pitfall: Incomplete Closing Entry Reversal</strong></p>\n<p>When reopening periods, failing to reverse all closing entries or reversing them in the wrong order can leave accounts with incorrect balances and break the audit trail. This is particularly problematic when multiple closing entries affect the same accounts.</p>\n<p><strong>Fix</strong>: Implement closing entry tracking that records the exact sequence of closing entries and provides automated reversal functionality that processes entries in reverse chronological order. Include validation checks that verify account balances match expected pre-closing values after reversal.</p>\n<p><strong>Post-Closing Audit Trail:</strong></p>\n<p>After period closing, the system maintains detailed audit trails showing what closing entries were created, when they were posted, and who authorized the closing process. This audit trail includes before-and-after account balance snapshots and references to all supporting documentation.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The financial reporting module represents the culmination of all ledger system components working together to transform raw transaction data into meaningful business insights. This implementation requires careful attention to data aggregation performance, report formatting consistency, and currency conversion accuracy.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Report Generation</td>\n<td>Direct SQL queries with Go templates</td>\n<td>Dedicated reporting engine like JasperReports or custom report builder</td>\n</tr>\n<tr>\n<td>PDF Generation</td>\n<td><code>github.com/jung-kurt/gofpdf</code> library</td>\n<td><code>github.com/SebastiaanKlippert/go-wkhtmltopdf</code> with HTML templates</td>\n</tr>\n<tr>\n<td>Currency Conversion</td>\n<td>Static exchange rate table</td>\n<td>Real-time exchange rate API integration</td>\n</tr>\n<tr>\n<td>Caching Layer</td>\n<td>In-memory map with TTL</td>\n<td>Redis with structured cache keys</td>\n</tr>\n<tr>\n<td>Report Scheduling</td>\n<td>Simple cron jobs</td>\n<td>Advanced scheduler like <code>github.com/robfig/cron</code></td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/reporting/\n    reports.go              ← main reporting engine\n    trial_balance.go        ← trial balance generation logic\n    balance_sheet.go        ← balance sheet generation and formatting\n    income_statement.go     ← income statement calculation\n    currency_translation.go ← multi-currency handling\n    period_closing.go       ← accounting period management\n    formatters.go          ← report output formatting (PDF, CSV, JSON)\n    templates/             ← report templates and styling\n        balance_sheet.html\n        income_statement.html\n        trial_balance.html\n    exports/               ← generated report files\ninternal/exchange/\n    rates.go               ← exchange rate management\n    providers.go           ← external rate data sources</code></pre></div>\n\n<p><strong>Core Report Generator Infrastructure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> reporting</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/shopspring/decimal</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReportGenerator coordinates all financial report generation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ReportGenerator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    balanceEngine </span><span style=\"color:#B392F0\">BalanceEngine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    auditTrail   </span><span style=\"color:#B392F0\">AuditStorage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db           </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache        </span><span style=\"color:#B392F0\">ReportCache</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    formatter    </span><span style=\"color:#B392F0\">ReportFormatter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TrialBalanceGenerator creates and validates trial balance reports</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TrialBalanceGenerator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    balanceEngine </span><span style=\"color:#B392F0\">BalanceEngine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    accountRepo   </span><span style=\"color:#B392F0\">AccountRepository</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache         </span><span style=\"color:#B392F0\">TrialBalanceCache</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateTrialBalance creates a trial balance report for the specified date</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns a complete trial balance with all accounts and validation status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">g </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TrialBalanceGenerator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateTrialBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">asOfDate</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TrialBalance</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Query all active accounts from chart of accounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each account, get current balance using balance engine</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Apply normal balance conventions to determine debit/credit column placement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Calculate running totals for debit and credit columns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Identify accounts with abnormal balances and generate warnings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Verify total debits equal total credits and calculate any variance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Sort accounts by account code for consistent presentation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Create TrialBalance structure with all calculated values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use BalanceEngine.GetBalanceAsOf for point-in-time calculations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Check account.NormalBalance() to determine proper column placement</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BalanceSheetGenerator creates balance sheet reports with proper categorization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BalanceSheetGenerator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    trialBalanceGen </span><span style=\"color:#B392F0\">TrialBalanceGenerator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    accountRepo     </span><span style=\"color:#B392F0\">AccountRepository</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    formatter       </span><span style=\"color:#B392F0\">BalanceSheetFormatter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateBalanceSheet creates a balance sheet from trial balance data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Groups accounts by type and calculates section totals</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">g </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BalanceSheetGenerator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateBalanceSheet</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">asOfDate</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BalanceSheet</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Generate trial balance for the specified date</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Filter trial balance to include only balance sheet accounts (ASSET, LIABILITY, EQUITY)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Group accounts by their parent account hierarchy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Calculate subtotals for major sections (Current Assets, Fixed Assets, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Apply standard balance sheet ordering conventions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Calculate total assets and total liabilities plus equity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Verify that total assets equals total liabilities plus equity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Format account sections with proper indentation and subtotals</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use account hierarchy to create nested AccountSection structures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Validate final balance using Assets = Liabilities + Equity equation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IncomeStatementGenerator creates period-based performance reports</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IncomeStatementGenerator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    balanceEngine </span><span style=\"color:#B392F0\">BalanceEngine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    accountRepo   </span><span style=\"color:#B392F0\">AccountRepository</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    periodManager </span><span style=\"color:#B392F0\">PeriodManager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateIncomeStatement calculates period performance from revenue and expense accounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Computes net income as total revenues minus total expenses for the period</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">g </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IncomeStatementGenerator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateIncomeStatement</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">periodStart</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">periodEnd</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IncomeStatement</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Query all revenue and expense accounts from chart of accounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Calculate period activity for each account (ending balance minus beginning balance)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Group accounts into income statement sections (Revenue, COGS, Operating Expenses)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Calculate subtotals for each section with proper sign conventions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Calculate gross profit (Revenue minus Cost of Goods Sold)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Calculate operating income (Gross Profit minus Operating Expenses)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Calculate net income as final bottom line result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Apply standard income statement ordering and formatting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use GetBalanceAsOf for period start and end to calculate net activity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Revenue accounts increase income, expense accounts decrease income</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Currency Translation Infrastructure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> exchange</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ExchangeRateProvider retrieves current and historical exchange rates</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ExchangeRateProvider</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetCurrentRate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fromCurrency</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">toCurrency</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ExchangeRate</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetRateAsOf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fromCurrency</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">toCurrency</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">date</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ExchangeRate</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetAverageRate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fromCurrency</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">toCurrency</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">periodStart</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">periodEnd</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ExchangeRate</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CurrencyTranslator handles multi-currency report translation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CurrencyTranslator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rateProvider </span><span style=\"color:#B392F0\">ExchangeRateProvider</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db          </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache       </span><span style=\"color:#B392F0\">ExchangeRateCache</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TranslateTrialBalance converts a trial balance to the specified presentation currency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">t </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CurrencyTranslator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">TranslateTrialBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">tb</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TrialBalance</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">presentationCurrency</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CurrencyTranslation</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Identify all accounts with balances in foreign currencies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Retrieve appropriate exchange rates for each foreign currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Apply period-end rates to balance sheet accounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Apply average rates to income statement accounts  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Calculate translation adjustments from rate changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Create translated account balances preserving original amounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update equity section with cumulative translation adjustments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Generate supporting schedules showing rates used</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use account type to determine which exchange rate method to apply</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Store both original and translated amounts for audit purposes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StaticRateProvider implements ExchangeRateProvider with database-stored rates</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> StaticRateProvider</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GetCurrentRate retrieves the most recent exchange rate from the database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">p </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">StaticRateProvider</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GetCurrentRate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fromCurrency</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">toCurrency</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ExchangeRate</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Query exchange_rates table for most recent rate between currencies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return error if no rate found or rate is older than acceptable threshold</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Apply rate direction logic (EUR/USD vs USD/EUR)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Period Closing Infrastructure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> reporting</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PeriodManager handles accounting period lifecycle</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PeriodManager</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db               </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transactionEngine </span><span style=\"color:#B392F0\">TransactionEngine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    auditTrail       </span><span style=\"color:#B392F0\">AuditStorage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ClosePeriod executes the complete period closing process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PeriodManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ClosePeriod</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">periodID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userCtx</span><span style=\"color:#B392F0\"> UserContext</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PeriodClosingResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate that all transactions for period are posted (no DRAFT entries)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Generate final trial balance and verify books are in balance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Post any required period-end adjusting entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Calculate net income by summing revenue and expense account balances</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Create closing entries to transfer revenue balances to Income Summary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Create closing entries to transfer expense balances to Income Summary  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Transfer Income Summary balance to Retained Earnings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Set period status to CLOSED and record closing metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Generate and archive official period-end reports</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Create audit trail entries for all closing activities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use database transactions to ensure closing process is atomic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Generate reversible closing entries for potential period reopening</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CreateClosingEntries generates the journal entries needed to close temporary accounts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PeriodManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CreateClosingEntries</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">periodID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Query all revenue accounts with non-zero balances for the period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create journal entries to debit revenue accounts and credit Income Summary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Query all expense accounts with non-zero balances for the period</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create journal entries to credit expense accounts and debit Income Summary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Calculate Income Summary balance and create entry to transfer to Retained Earnings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Mark all closing entries with special closing entry type for identification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Revenue accounts normally have credit balances, so debit them to close</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Expense accounts normally have debit balances, so credit them to close</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReopenPeriod reverses closing entries to allow additional transactions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pm </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PeriodManager</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ReopenPeriod</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">periodID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userCtx</span><span style=\"color:#B392F0\"> UserContext</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate user has authorization to reopen closed periods</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Retrieve all closing entries created during period close</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Create exact reversal entries in reverse chronological order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Post reversal entries and verify account balances match pre-closing state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Change period status back to OPEN</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Create audit trail entries documenting period reopening</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Invalidate any cached period-end reports that are no longer accurate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Process closing entries in reverse order to maintain referential integrity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Report Formatting and Export:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> reporting</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReportFormatter converts report data to various output formats</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ReportFormatter</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    templateEngine </span><span style=\"color:#B392F0\">TemplateEngine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    pdfGenerator  </span><span style=\"color:#B392F0\">PDFGenerator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    csvWriter     </span><span style=\"color:#B392F0\">CSVWriter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// FormatTrialBalance generates formatted trial balance in specified format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">f </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReportFormatter</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">FormatTrialBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tb</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TrialBalance</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">format</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate requested format is supported (PDF, CSV, JSON, HTML)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Apply appropriate template based on format and report type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Format monetary amounts with proper currency symbols and precision</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Apply consistent column widths and alignment for readability</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Include report headers with generation date and parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Add footers with page numbers and report validation status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Generate final formatted output as byte array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use templates for consistent formatting across different report types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoints:</strong></p>\n<p>After implementing the financial reporting module, verify the following behavior:</p>\n<ol>\n<li><p><strong>Trial Balance Validation</strong>: Run <code>go test ./internal/reporting/trial_balance_test.go</code> and verify that trial balances always show total debits equal to total credits for valid ledger data.</p>\n</li>\n<li><p><strong>Balance Sheet Equation</strong>: Generate a balance sheet and manually verify that Total Assets equals Total Liabilities plus Total Equity. Any variance indicates a categorization error.</p>\n</li>\n<li><p><strong>Income Statement Period Accuracy</strong>: Create transactions in different periods and verify that income statements only include activity from the specified date range.</p>\n</li>\n<li><p><strong>Multi-Currency Translation</strong>: Set up accounts in different currencies and verify that translated reports show both original and converted amounts with exchange rates used.</p>\n</li>\n<li><p><strong>Period Closing Completeness</strong>: Close a period and verify that all revenue and expense accounts show zero balances after closing while Retained Earnings reflects the period&#39;s net income.</p>\n</li>\n</ol>\n<p><strong>Debugging Common Issues:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Trial balance doesn&#39;t balance</td>\n<td>Unbalanced journal entries or calculation error</td>\n<td>Check individual journal entries for balance</td>\n<td>Identify and correct unbalanced entries</td>\n</tr>\n<tr>\n<td>Balance sheet doesn&#39;t balance</td>\n<td>Account type misclassification</td>\n<td>Review chart of accounts setup</td>\n<td>Reclassify accounts to proper types</td>\n</tr>\n<tr>\n<td>Income statement shows zero</td>\n<td>Wrong date range or no activity</td>\n<td>Verify period dates and transaction dates</td>\n<td>Adjust period parameters</td>\n</tr>\n<tr>\n<td>Currency translation errors</td>\n<td>Missing exchange rates</td>\n<td>Check exchange rate data completeness</td>\n<td>Add missing exchange rates for all currencies</td>\n</tr>\n<tr>\n<td>Period won&#39;t close</td>\n<td>Draft entries still exist</td>\n<td>Query for entries with DRAFT status</td>\n<td>Post or delete draft entries before closing</td>\n</tr>\n</tbody></table>\n<p><strong>Performance Considerations:</strong></p>\n<p>For large ledgers with millions of transactions, implement these optimizations:</p>\n<ul>\n<li>Cache trial balance calculations for frequently accessed dates</li>\n<li>Use materialized views for complex account hierarchy queries  </li>\n<li>Implement parallel processing for multi-currency translation calculations</li>\n<li>Pre-calculate period-end balances during closing to speed future queries</li>\n<li>Use database partitioning by period for historical data access</li>\n</ul>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 2 (Transaction Recording), 3 (Balance Calculation), 4 (Audit Trail), 5 (Financial Reports), as this section defines how components communicate and coordinate to implement atomic transaction processing, balance updates, audit logging, and report generation workflows</p>\n</blockquote>\n<p>Think of the ledger system&#39;s component interactions like a carefully choreographed financial operation in a traditional bank. When you deposit a check, multiple departments must coordinate: the teller validates the deposit slip, the accounting department records the transaction in your account, the audit department logs the activity, and the reporting system updates your balance. Each department has specific responsibilities and communicates through well-defined protocols. Similarly, our double-entry ledger system coordinates between the Account Manager, Transaction Recorder, Balance Engine, Audit System, and Report Generator through carefully designed APIs and workflows that ensure data consistency and auditability.</p>\n<p>The key architectural insight is that financial systems require <strong>strict ordering and atomicity</strong>. Unlike typical web applications where eventual consistency might be acceptable, accounting systems demand that every operation either completes entirely or fails completely, with full traceability of who did what when. This drives our interaction patterns toward synchronous, transactional workflows with comprehensive error handling and audit logging at every step.</p>\n<p><img src=\"/api/project/ledger-system/architecture-doc/asset?path=diagrams%2Fsystem-components.svg\" alt=\"High-Level System Component Architecture\"></p>\n<h3 id=\"component-api-interfaces\">Component API Interfaces</h3>\n<p>Each component in our ledger system exposes a well-defined interface that encapsulates its responsibilities while providing clear contracts for data exchange. These interfaces use <strong>dependency inversion</strong> principles, where high-level components depend on abstractions rather than concrete implementations, enabling testability and flexibility in deployment configurations.</p>\n<p>The <strong>Account Manager</strong> serves as the authoritative source for chart of accounts information and account validation. Its interface handles account lifecycle management, hierarchy validation, and type checking that other components rely on for transaction validation.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CreateAccount</code></td>\n<td><code>ctx context.Context, account Account</code></td>\n<td><code>(*Account, error)</code></td>\n<td>Creates new account with validation of code uniqueness, parent hierarchy, and account type rules</td>\n</tr>\n<tr>\n<td><code>GetAccount</code></td>\n<td><code>ctx context.Context, accountID string</code></td>\n<td><code>(*Account, error)</code></td>\n<td>Retrieves account by ID with active status check and parent resolution</td>\n</tr>\n<tr>\n<td><code>GetAccountByCode</code></td>\n<td><code>ctx context.Context, code string</code></td>\n<td><code>(*Account, error)</code></td>\n<td>Looks up account by unique code for journal entry line item validation</td>\n</tr>\n<tr>\n<td><code>GetActiveAccounts</code></td>\n<td><code>ctx context.Context, accountType AccountType</code></td>\n<td><code>([]Account, error)</code></td>\n<td>Returns all active accounts of specified type for report generation and validation</td>\n</tr>\n<tr>\n<td><code>ValidateAccountHierarchy</code></td>\n<td><code>ctx context.Context, accountID string, parentID *string</code></td>\n<td><code>error</code></td>\n<td>Checks for circular references and validates parent-child type compatibility</td>\n</tr>\n<tr>\n<td><code>UpdateAccountStatus</code></td>\n<td><code>ctx context.Context, accountID string, isActive bool, reason string</code></td>\n<td><code>error</code></td>\n<td>Activates or deactivates account with audit trail creation for the status change</td>\n</tr>\n<tr>\n<td><code>GetAccountHierarchy</code></td>\n<td><code>ctx context.Context, parentID *string, depth int</code></td>\n<td><code>([]Account, error)</code></td>\n<td>Retrieves account tree structure for report organization and chart of accounts display</td>\n</tr>\n</tbody></table>\n<p>The <strong>Transaction Recorder</strong> manages the complete lifecycle of journal entries from creation through posting, with comprehensive validation and atomic database operations. This component coordinates with other systems to ensure transaction integrity.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>CreateEntry</code></td>\n<td><code>ctx context.Context, entry *JournalEntry</code></td>\n<td><code>(*JournalEntry, error)</code></td>\n<td>Creates draft journal entry with line item validation and assigns unique ID</td>\n</tr>\n<tr>\n<td><code>ValidateEntry</code></td>\n<td><code>ctx context.Context, entry *JournalEntry</code></td>\n<td><code>(*ValidationResult, error)</code></td>\n<td>Performs comprehensive validation including balance check, account existence, and business rules</td>\n</tr>\n<tr>\n<td><code>PostEntry</code></td>\n<td><code>ctx context.Context, entryID string, userID string</code></td>\n<td><code>(*PostingResult, error)</code></td>\n<td>Atomically posts validated entry with balance updates and audit logging</td>\n</tr>\n<tr>\n<td><code>PostEntryWithIdempotency</code></td>\n<td><code>ctx context.Context, entry *JournalEntry, idempotencyKey string, userID string</code></td>\n<td><code>(*PostingResult, error)</code></td>\n<td>Posts entry with duplicate detection using idempotency key for API safety</td>\n</tr>\n<tr>\n<td><code>ReverseEntry</code></td>\n<td><code>ctx context.Context, entryID string, reason string, userID string</code></td>\n<td><code>(*JournalEntry, error)</code></td>\n<td>Creates offsetting entry to reverse previously posted transaction without deletion</td>\n</tr>\n<tr>\n<td><code>GetEntry</code></td>\n<td><code>ctx context.Context, entryID string</code></td>\n<td><code>(*JournalEntry, error)</code></td>\n<td>Retrieves complete journal entry with all line items and metadata</td>\n</tr>\n<tr>\n<td><code>GetEntriesInRange</code></td>\n<td><code>ctx context.Context, startDate time.Time, endDate time.Time, filters map[string]interface{}</code></td>\n<td><code>([]JournalEntry, error)</code></td>\n<td>Queries entries by date range with optional filtering for account, status, or reference</td>\n</tr>\n<tr>\n<td><code>BatchPostEntries</code></td>\n<td><code>ctx context.Context, entries []JournalEntry, userID string</code></td>\n<td><code>([]PostingResult, error)</code></td>\n<td>Posts multiple entries atomically within single database transaction</td>\n</tr>\n</tbody></table>\n<p>The <strong>Balance Engine</strong> provides efficient balance calculations with multiple caching layers and point-in-time queries. Its interface abstracts the complexity of running balance maintenance and historical balance reconstruction.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>GetCurrentBalance</code></td>\n<td><code>ctx context.Context, accountID string</code></td>\n<td><code>(Money, error)</code></td>\n<td>Returns current balance using cached running total with L1 memory cache optimization</td>\n</tr>\n<tr>\n<td><code>GetBalanceAsOf</code></td>\n<td><code>ctx context.Context, accountID string, asOfDate time.Time</code></td>\n<td><code>(Money, error)</code></td>\n<td>Calculates historical balance considering only entries posted on or before specified date</td>\n</tr>\n<tr>\n<td><code>GetMultipleBalances</code></td>\n<td><code>ctx context.Context, accountIDs []string</code></td>\n<td><code>(map[string]Money, error)</code></td>\n<td>Batch retrieval of current balances for multiple accounts with single database query</td>\n</tr>\n<tr>\n<td><code>GetMultipleBalancesAsOf</code></td>\n<td><code>ctx context.Context, accountIDs []string, asOfDate time.Time</code></td>\n<td><code>(map[string]Money, error)</code></td>\n<td>Batch historical balance calculation for efficient report generation</td>\n</tr>\n<tr>\n<td><code>UpdateRunningBalances</code></td>\n<td><code>ctx context.Context, entry *JournalEntry</code></td>\n<td><code>error</code></td>\n<td>Updates cached balances for all accounts affected by journal entry posting</td>\n</tr>\n<tr>\n<td><code>InvalidateBalance</code></td>\n<td><code>ctx context.Context, accountID string</code></td>\n<td><code>error</code></td>\n<td>Removes cached balance to force recalculation on next query</td>\n</tr>\n<tr>\n<td><code>RefreshBalanceCache</code></td>\n<td><code>ctx context.Context, accountIDs []string</code></td>\n<td><code>error</code></td>\n<td>Proactively recalculates and caches balances for specified accounts</td>\n</tr>\n<tr>\n<td><code>GetTrialBalance</code></td>\n<td><code>ctx context.Context, asOfDate time.Time</code></td>\n<td><code>(*TrialBalance, error)</code></td>\n<td>Generates complete trial balance report with debit/credit totals and balance verification</td>\n</tr>\n<tr>\n<td><code>ValidateTrialBalance</code></td>\n<td><code>ctx context.Context</code></td>\n<td><code>error</code></td>\n<td>Performs integrity check ensuring total debits equal total credits across entire ledger</td>\n</tr>\n</tbody></table>\n<p>The <strong>Audit System</strong> maintains immutable records of all system changes with cryptographic integrity verification. Its interface provides both real-time event recording and historical audit reporting capabilities.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>RecordEvent</code></td>\n<td><code>ctx context.Context, event *AuditEvent</code></td>\n<td><code>error</code></td>\n<td>Creates immutable audit record with automatic hash chain linking and timestamp</td>\n</tr>\n<tr>\n<td><code>TrackChanges</code></td>\n<td><code>ctx context.Context, tableName string, recordID string, oldValue interface{}, newValue interface{}</code></td>\n<td><code>error</code></td>\n<td>Compares before/after values and generates detailed field-level change events</td>\n</tr>\n<tr>\n<td><code>TrackStateTransition</code></td>\n<td><code>ctx context.Context, entityType string, entityID string, fromState string, toState string, reason string</code></td>\n<td><code>error</code></td>\n<td>Records business state changes like journal entry status transitions with business context</td>\n</tr>\n<tr>\n<td><code>GetEventHistory</code></td>\n<td><code>ctx context.Context, recordID string</code></td>\n<td><code>([]AuditEvent, error)</code></td>\n<td>Retrieves complete chronological change history for specific record</td>\n</tr>\n<tr>\n<td><code>GetEventsInRange</code></td>\n<td><code>ctx context.Context, startTime time.Time, endTime time.Time, filters map[string]interface{}</code></td>\n<td><code>([]AuditEvent, error)</code></td>\n<td>Queries audit events within date range with filtering by user, table, or event type</td>\n</tr>\n<tr>\n<td><code>VerifyIntegrity</code></td>\n<td><code>ctx context.Context, recordID string</code></td>\n<td><code>(*IntegrityRecord, error)</code></td>\n<td>Validates cryptographic hash chain and digital signatures for tamper detection</td>\n</tr>\n<tr>\n<td><code>GenerateAuditReport</code></td>\n<td><code>ctx context.Context, reportType string, startDate time.Time, endDate time.Time, parameters map[string]interface{}</code></td>\n<td><code>(*AuditReport, error)</code></td>\n<td>Creates comprehensive audit trail report for compliance and regulatory requirements</td>\n</tr>\n<tr>\n<td><code>GetUserActivityReport</code></td>\n<td><code>ctx context.Context, userIDs []string, startDate time.Time, endDate time.Time</code></td>\n<td><code>(*AuditReport, error)</code></td>\n<td>Shows all actions performed by specific users for security and compliance auditing</td>\n</tr>\n</tbody></table>\n<p>The <strong>Report Generator</strong> creates standard financial statements by coordinating with the Balance Engine and Account Manager to aggregate and format accounting data according to financial reporting standards.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>GenerateTrialBalance</code></td>\n<td><code>ctx context.Context, asOfDate time.Time, options map[string]interface{}</code></td>\n<td><code>(*TrialBalance, error)</code></td>\n<td>Creates trial balance report with all account balances and verification that debits equal credits</td>\n</tr>\n<tr>\n<td><code>GenerateBalanceSheet</code></td>\n<td><code>ctx context.Context, asOfDate time.Time, comparativePeriod *time.Time</code></td>\n<td><code>(*BalanceSheet, error)</code></td>\n<td>Generates balance sheet with assets, liabilities, and equity sections using proper account groupings</td>\n</tr>\n<tr>\n<td><code>GenerateIncomeStatement</code></td>\n<td><code>ctx context.Context, startDate time.Time, endDate time.Time, comparativePeriod *time.Time</code></td>\n<td><code>(*IncomeStatement, error)</code></td>\n<td>Creates income statement showing revenues, expenses, and net income for specified period</td>\n</tr>\n<tr>\n<td><code>TranslateReport</code></td>\n<td><code>ctx context.Context, report interface{}, targetCurrency string, exchangeRates map[string]ExchangeRate</code></td>\n<td><code>(interface{}, error)</code></td>\n<td>Converts multi-currency reports to single presentation currency using specified rates</td>\n</tr>\n<tr>\n<td><code>ExportReport</code></td>\n<td><code>ctx context.Context, report interface{}, format string, options map[string]interface{}</code></td>\n<td><code>([]byte, error)</code></td>\n<td>Exports financial reports in PDF, CSV, or JSON formats with proper formatting and headers</td>\n</tr>\n<tr>\n<td><code>ScheduleReport</code></td>\n<td><code>ctx context.Context, reportType string, schedule string, recipients []string, parameters map[string]interface{}</code></td>\n<td><code>error</code></td>\n<td>Sets up automated report generation and delivery for recurring financial reporting</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Design Insight</strong>: The interfaces use context-first parameters to enable request tracing, timeout handling, and cancellation throughout the system. Every method that modifies data requires a user context for audit trail purposes, while read operations can use anonymous contexts for performance queries.</p>\n</blockquote>\n<p><strong>Interface Composition Patterns</strong></p>\n<p>Our system uses interface composition to create flexible, testable components. Rather than large monolithic interfaces, we define focused contracts that components can implement independently.</p>\n<table>\n<thead>\n<tr>\n<th>Interface Name</th>\n<th>Purpose</th>\n<th>Implementing Components</th>\n<th>Key Methods</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>AccountProvider</code></td>\n<td>Account information access</td>\n<td>Account Manager, Cached Account Service</td>\n<td><code>GetAccount</code>, <code>ValidateAccount</code>, <code>GetActiveAccounts</code></td>\n</tr>\n<tr>\n<td><code>BalanceCalculator</code></td>\n<td>Balance computation abstraction</td>\n<td>Balance Engine, Cached Balance Service</td>\n<td><code>GetCurrentBalance</code>, <code>GetBalanceAsOf</code></td>\n</tr>\n<tr>\n<td><code>AuditTracker</code></td>\n<td>Change recording contract</td>\n<td>Audit System, File Audit Logger</td>\n<td><code>RecordEvent</code>, <code>TrackChanges</code></td>\n</tr>\n<tr>\n<td><code>TransactionPoster</code></td>\n<td>Entry posting abstraction</td>\n<td>Transaction Recorder, Batch Processor</td>\n<td><code>PostEntry</code>, <code>ValidateEntry</code></td>\n</tr>\n<tr>\n<td><code>ReportDataSource</code></td>\n<td>Report data provider</td>\n<td>Balance Engine, Account Manager</td>\n<td><code>GetTrialBalance</code>, <code>GetAccountHierarchy</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"transaction-recording-workflow\">Transaction Recording Workflow</h3>\n<p>The journal entry recording workflow represents the heart of our double-entry system, orchestrating validation, posting, balance updates, and audit logging in a carefully sequenced atomic operation. Think of this like processing a bank transaction: multiple verification steps must pass before money moves, and once committed, the transaction becomes permanent with full audit trails.</p>\n<p>The workflow implements the <strong>two-phase commit pattern</strong> where validation completes entirely before any permanent changes occur, ensuring that partial failures leave the system in a consistent state. This is critical for financial systems where incomplete transactions could lead to incorrect balances or audit discrepancies.</p>\n<p><img src=\"/api/project/ledger-system/architecture-doc/asset?path=diagrams%2Fjournal-entry-workflow.svg\" alt=\"Journal Entry Recording Sequence\"></p>\n<p><strong>Phase 1: Pre-Validation and Setup</strong></p>\n<p>The workflow begins when the API layer receives a journal entry creation request. Before any database interactions occur, the system performs preliminary validation and establishes transaction context.</p>\n<ol>\n<li><p><strong>Request Reception</strong>: The API endpoint receives the journal entry request with debit and credit line items, validates the HTTP request structure, and extracts user authentication context for audit purposes.</p>\n</li>\n<li><p><strong>Idempotency Check</strong>: The Transaction Recorder calls <code>CheckIdempotency(ctx, idempotencyKey)</code> to determine if this exact request has been processed before, preventing duplicate entries from API retries or network issues.</p>\n</li>\n<li><p><strong>Entry Structure Validation</strong>: Basic structural validation occurs including checking that the entry has at least two line items (fundamental double-entry requirement), all line items reference valid account IDs, and monetary amounts use proper decimal precision.</p>\n</li>\n<li><p><strong>Business Rule Validation</strong>: The system validates business-specific rules like ensuring journal entries are not posted to closed accounting periods, checking that referenced accounts are active and appropriate for the transaction type, and verifying that the posting date falls within acceptable ranges.</p>\n</li>\n</ol>\n<p><strong>Phase 2: Account and Balance Validation</strong></p>\n<p>This phase involves coordination with the Account Manager and Balance Engine to validate that the proposed transaction can be safely posted.</p>\n<ol start=\"5\">\n<li><p><strong>Account Existence Verification</strong>: For each line item, the system calls <code>GetAccount(ctx, accountID)</code> to verify that referenced accounts exist, are active, and have compatible types for the debit/credit operation being performed.</p>\n</li>\n<li><p><strong>Double-Entry Balance Check</strong>: The Transaction Recorder calls <code>TotalDebits()</code> and <code>TotalCredits()</code> on the journal entry and ensures these amounts are exactly equal, implementing the fundamental accounting equation that every transaction must balance.</p>\n</li>\n<li><p><strong>Account Type Compatibility</strong>: Each line item is validated against account type rules using the <code>NormalBalance()</code> method to ensure debits and credits align with standard accounting conventions (assets and expenses are debit-normal, liabilities and revenues are credit-normal).</p>\n</li>\n<li><p><strong>Sufficient Balance Check</strong> (if applicable): For accounts that require positive balances (like cash accounts), the system calls <code>GetCurrentBalance(ctx, accountID)</code> and validates that the proposed transaction won&#39;t create negative balances where prohibited.</p>\n</li>\n</ol>\n<p><strong>Phase 3: Atomic Posting Transaction</strong></p>\n<p>Once all validations pass, the system begins the atomic posting process within a single database transaction that ensures all changes succeed or fail together.</p>\n<ol start=\"9\">\n<li><p><strong>Database Transaction Initiation</strong>: The system calls <code>WithTransaction(db, postingFunction)</code> to begin a database transaction with appropriate isolation levels (typically READ COMMITTED to prevent dirty reads while allowing concurrent transactions).</p>\n</li>\n<li><p><strong>Entry Status Update</strong>: The journal entry status changes from <code>EntryStatusDraft</code> to <code>EntryStatusPosted</code> with the current timestamp recorded in the <code>PostedAt</code> field for audit trail purposes.</p>\n</li>\n<li><p><strong>Entry Persistence</strong>: The complete journal entry with all line items is persisted to the database using INSERT operations that maintain referential integrity between the entry header and line item details.</p>\n</li>\n<li><p><strong>Running Balance Updates</strong>: For each affected account, the system calls <code>UpdateRunningBalances(ctx, entry)</code> to incrementally update cached balance totals, avoiding expensive recalculation while maintaining accuracy.</p>\n</li>\n</ol>\n<p><strong>Phase 4: Audit Trail and Notification</strong></p>\n<p>After successful posting, the system creates comprehensive audit records and notifies dependent systems of the completed transaction.</p>\n<ol start=\"13\">\n<li><p><strong>Audit Event Creation</strong>: The Audit System receives a call to <code>RecordEvent(ctx, auditEvent)</code> containing details of the posted transaction including user identity, timestamp, entry details, and business reason for the transaction.</p>\n</li>\n<li><p><strong>Integrity Hash Generation</strong>: The system generates cryptographic hashes of the posted entry using <code>GenerateContentHash(entry)</code> and links it to the previous entry in the hash chain for tamper detection.</p>\n</li>\n<li><p><strong>Cache Invalidation</strong>: Historical balance caches are invalidated using <code>invalidateHistoricalCache(ctx, entryDate, affectedAccounts)</code> to ensure future point-in-time queries reflect the new transaction.</p>\n</li>\n<li><p><strong>Idempotency Record Update</strong>: The idempotency system is updated with the successful posting result using <code>UpdateStatus(ctx, idempotencyKey, &quot;COMPLETED&quot;, entryID)</code> to handle future duplicate requests.</p>\n</li>\n</ol>\n<p>The entire workflow from validation through posting typically completes in under 100 milliseconds for simple entries, with the database transaction portion taking only 10-20 milliseconds to minimize lock contention and enable high concurrency.</p>\n<blockquote>\n<p><strong>Critical Design Principle</strong>: The workflow uses <strong>pessimistic validation</strong> where every possible failure condition is checked before making any permanent changes. This &quot;validate everything first&quot; approach is essential for financial systems where consistency is more important than performance.</p>\n</blockquote>\n<p><strong>Error Handling and Rollback</strong></p>\n<p>The workflow includes comprehensive error handling at each phase with specific recovery actions:</p>\n<table>\n<thead>\n<tr>\n<th>Failure Point</th>\n<th>Detection Method</th>\n<th>Recovery Action</th>\n<th>User Notification</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Invalid account reference</td>\n<td>Account lookup returns error</td>\n<td>Immediate validation failure</td>\n<td>Return specific account ID that failed validation</td>\n</tr>\n<tr>\n<td>Unbalanced entry</td>\n<td>Debit/credit totals don&#39;t match</td>\n<td>Immediate validation failure</td>\n<td>Return calculated debit and credit totals with variance</td>\n</tr>\n<tr>\n<td>Insufficient balance</td>\n<td>Balance check fails business rules</td>\n<td>Immediate validation failure</td>\n<td>Return current balance and required balance for transaction</td>\n</tr>\n<tr>\n<td>Database constraint violation</td>\n<td>SQL error during INSERT</td>\n<td>Transaction rollback</td>\n<td>Return generic &quot;posting failed&quot; message with error ID for support</td>\n</tr>\n<tr>\n<td>Audit system failure</td>\n<td>Audit record creation fails</td>\n<td>Transaction rollback</td>\n<td>Retry with exponential backoff, escalate if persistent</td>\n</tr>\n<tr>\n<td>Cache update failure</td>\n<td>Balance cache update fails</td>\n<td>Log error but continue</td>\n<td>Background job will eventually refresh cache</td>\n</tr>\n</tbody></table>\n<h3 id=\"report-generation-workflow\">Report Generation Workflow</h3>\n<p>Financial report generation requires careful orchestration between multiple components to aggregate account data, apply accounting rules, and format output according to financial reporting standards. Think of this process like assembling a complex financial statement at a CPA firm: accountants gather trial balance data, organize accounts into statement sections, apply presentation rules, and format the final report with proper headers and calculations.</p>\n<p>The report generation workflow implements a <strong>pipeline architecture</strong> where data flows through successive transformation stages: data extraction, classification, aggregation, formatting, and export. Each stage has specific responsibilities and can be optimized independently while maintaining overall system performance.</p>\n<p><img src=\"/api/project/ledger-system/architecture-doc/asset?path=diagrams%2Freport-generation-flow.svg\" alt=\"Financial Report Generation Process\"></p>\n<p><strong>Stage 1: Report Request and Parameter Validation</strong></p>\n<p>The workflow begins when a user or automated system requests a financial report with specific parameters defining the report scope and format requirements.</p>\n<ol>\n<li><p><strong>Request Parsing</strong>: The Report Generator receives the report request containing report type (trial balance, balance sheet, income statement), date parameters (as-of date for balance sheet, period range for income statement), formatting options, and output format preferences.</p>\n</li>\n<li><p><strong>Parameter Validation</strong>: The system validates that the requested date ranges are valid, the report type is supported, any comparative periods are properly specified, and the requesting user has appropriate permissions to access the requested account data.</p>\n</li>\n<li><p><strong>Template Selection</strong>: Based on the report type and organization configuration, the system selects the appropriate report template that defines account groupings, calculation rules, and formatting standards for the requested financial statement.</p>\n</li>\n<li><p><strong>Currency and Translation Setup</strong>: For multi-currency organizations, the system determines the presentation currency and retrieves current exchange rates using <code>GetExchangeRates(ctx, currencies, asOfDate)</code> for proper currency translation.</p>\n</li>\n</ol>\n<p><strong>Stage 2: Account Data Extraction</strong></p>\n<p>This stage involves coordinating with the Account Manager and Balance Engine to retrieve all necessary account information and balance data for the report period.</p>\n<ol start=\"5\">\n<li><p><strong>Account Hierarchy Retrieval</strong>: The system calls <code>GetActiveAccounts(ctx, accountType)</code> for each relevant account type (assets, liabilities, equity, revenues, expenses) to build the complete chart of accounts structure needed for the report.</p>\n</li>\n<li><p><strong>Balance Data Collection</strong>: For balance sheet reports, the system calls <code>GetMultipleBalancesAsOf(ctx, accountIDs, asOfDate)</code> to retrieve point-in-time balances. For income statements, it uses <code>GetBalanceChanges(ctx, accountIDs, startDate, endDate)</code> to calculate period activity.</p>\n</li>\n<li><p><strong>Trial Balance Generation</strong>: As the foundation for all financial reports, the system calls <code>GetTrialBalance(ctx, asOfDate)</code> to ensure all account balances are properly balanced and to provide the base dataset for statement preparation.</p>\n</li>\n<li><p><strong>Comparative Data Retrieval</strong>: If comparative periods are requested, the system repeats the balance collection process for prior periods using the same account structure to ensure consistent presentation across periods.</p>\n</li>\n</ol>\n<p><strong>Stage 3: Account Classification and Grouping</strong></p>\n<p>Financial statements require accounts to be organized into specific sections according to accounting standards and organizational requirements.</p>\n<ol start=\"9\">\n<li><p><strong>Account Type Mapping</strong>: Each account is classified into its appropriate financial statement section using the account type hierarchy: assets are grouped into current and non-current, liabilities are separated by payment terms, and equity accounts are organized by source.</p>\n</li>\n<li><p><strong>Section Totaling</strong>: Within each statement section, account balances are aggregated using appropriate signs (normal balance conventions) where assets and expenses are positive, while liabilities, equity, and revenues may be presented with different signs depending on the statement type.</p>\n</li>\n<li><p><strong>Multi-Level Grouping</strong>: The system creates hierarchical groupings like &quot;Current Assets&quot; containing &quot;Cash and Cash Equivalents&quot; and &quot;Accounts Receivable&quot; subsections, allowing for both detailed and summary-level reporting.</p>\n</li>\n<li><p><strong>Currency Translation</strong>: For accounts denominated in foreign currencies, the system applies appropriate translation methods using period-end rates for balance sheet items and average rates for income statement items.</p>\n</li>\n</ol>\n<p><strong>Stage 4: Financial Statement Assembly</strong></p>\n<p>This stage transforms the classified account data into properly formatted financial statements with required calculations and presentation rules.</p>\n<ol start=\"13\">\n<li><p><strong>Statement Structure Creation</strong>: The system builds the financial statement structure using the appropriate template, creating sections like Assets, Liabilities and Equity for balance sheets, or Revenues and Expenses for income statements.</p>\n</li>\n<li><p><strong>Cross-Statement Validation</strong>: For balance sheets, the system verifies that total assets equal total liabilities plus equity using the fundamental accounting equation. For income statements, it ensures proper calculation of gross profit, operating income, and net income.</p>\n</li>\n<li><p><strong>Variance and Ratio Calculations</strong>: If comparative periods are included, the system calculates period-over-period changes and percentage variances to provide analytical insights alongside the basic financial data.</p>\n</li>\n<li><p><strong>Note and Disclosure Integration</strong>: The system incorporates any required footnotes, accounting policy disclosures, or supplementary information that provides context for the financial statement data.</p>\n</li>\n</ol>\n<p><strong>Stage 5: Formatting and Export</strong></p>\n<p>The final stage transforms the assembled financial statement data into the requested output format with proper presentation and layout.</p>\n<ol start=\"17\">\n<li><p><strong>Format-Specific Rendering</strong>: Based on the requested output format (PDF, CSV, JSON), the system applies appropriate formatting rules including number formatting, column alignment, and hierarchical indentation for account groupings.</p>\n</li>\n<li><p><strong>Header and Footer Generation</strong>: The system adds report headers containing organization name, report title, period covered, and generation timestamp, along with page numbers and other standard report elements.</p>\n</li>\n<li><p><strong>Quality Assurance Checks</strong>: Before output, the system performs final validation including mathematical accuracy checks, ensuring all totals foot and cross-foot correctly, and verifying that comparative data is consistently presented.</p>\n</li>\n<li><p><strong>File Generation and Delivery</strong>: The formatted report is generated in the requested format and either returned directly to the API caller or delivered via email, file system, or cloud storage depending on the delivery preferences specified in the request.</p>\n</li>\n</ol>\n<p><strong>Performance Optimization Strategies</strong></p>\n<p>Report generation can be resource-intensive for organizations with large charts of accounts or long time periods. The system employs several optimization strategies:</p>\n<table>\n<thead>\n<tr>\n<th>Optimization Technique</th>\n<th>Implementation</th>\n<th>Performance Benefit</th>\n<th>Trade-off</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Balance Pre-aggregation</td>\n<td>Maintain summary balances by account type</td>\n<td>Reduces real-time calculation</td>\n<td>Requires additional storage and maintenance</td>\n</tr>\n<tr>\n<td>Report Caching</td>\n<td>Cache generated reports for common requests</td>\n<td>Near-instant delivery for repeated requests</td>\n<td>Cache invalidation complexity</td>\n</tr>\n<tr>\n<td>Incremental Updates</td>\n<td>Track only changed accounts since last report</td>\n<td>Faster regeneration for updated data</td>\n<td>More complex change tracking logic</td>\n</tr>\n<tr>\n<td>Parallel Processing</td>\n<td>Generate statement sections concurrently</td>\n<td>Reduced total generation time</td>\n<td>Increased memory usage and complexity</td>\n</tr>\n<tr>\n<td>Template Pre-compilation</td>\n<td>Compile report templates at startup</td>\n<td>Faster report formatting</td>\n<td>Less flexible runtime customization</td>\n</tr>\n</tbody></table>\n<p>The typical performance targets for report generation are trial balance in under 2 seconds, balance sheet in under 5 seconds, and income statement in under 8 seconds for organizations with up to 10,000 accounts and 1 million transactions per year.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: The report generation workflow prioritizes <strong>accuracy over speed</strong>, performing extensive validation and cross-checking to ensure financial statement integrity. While this may result in longer generation times compared to simple queries, it prevents the far more costly errors that could result from incorrect financial reporting.</p>\n</blockquote>\n<h3 id=\"concurrent-access-patterns\">Concurrent Access Patterns</h3>\n<p>Financial systems must handle multiple simultaneous users posting transactions, generating reports, and querying balances while maintaining strict data consistency and avoiding race conditions that could lead to incorrect account balances. Think of this like multiple bank tellers processing deposits and withdrawals simultaneously while ensuring that account balances remain accurate and audit trails are preserved.</p>\n<p>The challenge in concurrent accounting systems is that financial transactions are inherently interdependent: posting a journal entry affects multiple accounts, balance calculations depend on transaction ordering, and audit trails must maintain chronological consistency. Our system uses a combination of <strong>optimistic locking</strong>, <strong>read-committed isolation</strong>, and <strong>careful transaction boundaries</strong> to achieve high concurrency while preserving financial accuracy.</p>\n<p><strong>Transaction-Level Concurrency Control</strong></p>\n<p>At the core of our concurrency model is the principle that journal entry posting must be atomic and serializable, while balance queries can operate with relaxed consistency for better performance.</p>\n<blockquote>\n<p><strong>Decision: Optimistic Locking for Balance Updates</strong></p>\n<ul>\n<li><strong>Context</strong>: Multiple transactions might simultaneously update the same account&#39;s running balance, creating race conditions</li>\n<li><strong>Options Considered</strong>: Pessimistic locking with account-level locks, optimistic locking with version numbers, event-sourced balance calculation</li>\n<li><strong>Decision</strong>: Optimistic locking using version numbers in <code>RunningBalance</code> records</li>\n<li><strong>Rationale</strong>: Provides better concurrency than pessimistic locks while detecting conflicts reliably, and most real-world accounting operations don&#39;t create high contention on individual accounts</li>\n<li><strong>Consequences</strong>: Enables high-throughput transaction posting with automatic retry logic for the rare conflicts that occur</li>\n</ul>\n</blockquote>\n<p>The <code>RunningBalance</code> table includes a <code>Version</code> field that increments with each update. When posting a journal entry, the system:</p>\n<ol>\n<li>Reads the current balance and version for each affected account</li>\n<li>Calculates the new balance based on the entry&#39;s debit/credit amounts  </li>\n<li>Attempts to update the balance using a WHERE clause that includes the original version</li>\n<li>If the update affects 0 rows (version has changed), retries the entire balance update process</li>\n<li>After 3 failed retries, escalates to a pessimistic lock to prevent starvation</li>\n</ol>\n<p><strong>Read Consistency Models</strong></p>\n<p>Different types of queries in our system have varying consistency requirements that we address through layered caching and appropriate isolation levels.</p>\n<table>\n<thead>\n<tr>\n<th>Query Type</th>\n<th>Consistency Requirement</th>\n<th>Implementation Strategy</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Current balance for transaction validation</td>\n<td>Strong consistency required</td>\n<td>Direct database read with READ_COMMITTED</td>\n<td>Moderate - each validation requires DB query</td>\n</tr>\n<tr>\n<td>Balance display in user interface</td>\n<td>Eventually consistent acceptable</td>\n<td>L1 memory cache with 30-second TTL</td>\n<td>High performance - sub-millisecond response</td>\n</tr>\n<tr>\n<td>Financial report generation</td>\n<td>Point-in-time consistency required</td>\n<td>Snapshot isolation with historical cache</td>\n<td>Low impact - uses materialized snapshots</td>\n</tr>\n<tr>\n<td>Audit trail queries</td>\n<td>Strong consistency required</td>\n<td>Direct database read, no caching</td>\n<td>Low frequency - acceptable performance impact</td>\n</tr>\n<tr>\n<td>Trial balance validation</td>\n<td>Strong consistency required</td>\n<td>Database aggregation with explicit locking</td>\n<td>Low frequency - runs during off-peak hours</td>\n</tr>\n</tbody></table>\n<p><strong>Memory Cache Coherence</strong></p>\n<p>The <code>MemoryCache</code> component maintains L1 cache coherence across multiple application instances using a <strong>cache invalidation bus</strong> pattern. When any instance posts a transaction that affects account balances, it publishes cache invalidation messages containing the affected account IDs and update timestamps.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Cache Invalidation Flow:\n1. Instance A posts journal entry affecting accounts 1001, 2001\n2. Instance A publishes invalidation message: {accounts: [1001, 2001], timestamp: T1}\n3. Instances B and C receive message and remove cached balances for accounts 1001, 2001\n4. Next balance query on any instance triggers database refresh</code></pre></div>\n\n<p>The cache uses <strong>versioned entries</strong> where each cached balance includes the timestamp of the last update. When invalidation messages arrive, the cache only removes entries that are older than the invalidation timestamp, preventing race conditions where fresh data gets invalidated by stale messages.</p>\n<p><strong>Database Connection Pooling and Transaction Management</strong></p>\n<p>To support concurrent access, the system maintains separate connection pools for different types of operations with appropriate sizing and timeout configurations.</p>\n<table>\n<thead>\n<tr>\n<th>Connection Pool</th>\n<th>Purpose</th>\n<th>Pool Size</th>\n<th>Max Idle Time</th>\n<th>Usage Pattern</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Transaction Pool</td>\n<td>Journal entry posting</td>\n<td>20 connections</td>\n<td>5 minutes</td>\n<td>Short-lived, high-frequency transactions</td>\n</tr>\n<tr>\n<td>Query Pool</td>\n<td>Balance and report queries</td>\n<td>50 connections</td>\n<td>10 minutes</td>\n<td>Medium-lived, variable frequency</td>\n</tr>\n<tr>\n<td>Batch Pool</td>\n<td>Period closing and bulk operations</td>\n<td>5 connections</td>\n<td>30 minutes</td>\n<td>Long-lived, infrequent operations</td>\n</tr>\n<tr>\n<td>Audit Pool</td>\n<td>Audit event recording</td>\n<td>10 connections</td>\n<td>5 minutes</td>\n<td>Short-lived, continuous background writes</td>\n</tr>\n</tbody></table>\n<p><strong>Concurrent Report Generation</strong></p>\n<p>Financial report generation can be resource-intensive and must handle concurrent requests without degrading transaction posting performance. The system uses <strong>read replicas</strong> for report queries and <strong>resource isolation</strong> to prevent report generation from impacting transactional operations.</p>\n<p>When multiple users request the same report simultaneously (common for month-end trial balance), the system employs <strong>request deduplication</strong> where the first request triggers report generation while subsequent identical requests wait for and receive the same result.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Concurrent Report Handling:\n1. User A requests trial balance for 2024-01-31\n2. System starts report generation, creates &quot;in-progress&quot; marker\n3. User B requests identical trial balance \n4. System detects in-progress marker, adds User B to waiting list\n5. Report completes, system delivers result to both User A and User B\n6. Subsequent requests for same report use cached result</code></pre></div>\n\n<p><strong>Deadlock Prevention and Resolution</strong></p>\n<p>Database deadlocks can occur when transactions acquire locks in different orders. Our system prevents deadlocks through <strong>consistent lock ordering</strong> and <strong>timeout-based resolution</strong>.</p>\n<p>The lock ordering follows a hierarchy: accounts are always locked in ascending ID order, journal entries are locked before their line items, and audit records are locked last. When multiple accounts are affected by a transaction, the system sorts the account IDs before acquiring locks.</p>\n<table>\n<thead>\n<tr>\n<th>Deadlock Scenario</th>\n<th>Prevention Strategy</th>\n<th>Recovery Mechanism</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Two entries updating same accounts in different order</td>\n<td>Sort account IDs before locking</td>\n<td>N/A - prevented by design</td>\n</tr>\n<tr>\n<td>Long-running report blocking transaction</td>\n<td>Separate read replica for reports</td>\n<td>N/A - prevented by isolation</td>\n</tr>\n<tr>\n<td>Audit system blocking transaction posting</td>\n<td>Asynchronous audit event queuing</td>\n<td>Retry transaction after audit queue drains</td>\n</tr>\n<tr>\n<td>Cache refresh during high transaction volume</td>\n<td>Background refresh with read-through fallback</td>\n<td>Use stale cache data with eventual consistency</td>\n</tr>\n</tbody></table>\n<p><strong>High-Availability Patterns</strong></p>\n<p>For production deployments requiring high availability, the system supports <strong>active-passive clustering</strong> where multiple application instances can process transactions but only one instance handles batch operations like period closing.</p>\n<p>The system uses <strong>leader election</strong> through database heartbeats to determine which instance is responsible for system-wide operations:</p>\n<ol>\n<li>Each instance updates a heartbeat record with its instance ID and current timestamp every 30 seconds</li>\n<li>The instance with the most recent heartbeat (within last 60 seconds) becomes the leader</li>\n<li>Only the leader instance processes scheduled batch operations and system maintenance tasks</li>\n<li>If the leader fails, another instance automatically assumes leadership within 60 seconds</li>\n<li>All instances can process user-initiated transactions and queries for horizontal scalability</li>\n</ol>\n<p><strong>Performance Monitoring and Circuit Breakers</strong></p>\n<p>To maintain system stability under high concurrency, the system implements <strong>circuit breaker patterns</strong> that temporarily reject requests when error rates exceed thresholds or response times become unacceptable.</p>\n<table>\n<thead>\n<tr>\n<th>Circuit Breaker</th>\n<th>Trigger Condition</th>\n<th>Failure Response</th>\n<th>Recovery Condition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database Connection</td>\n<td>&gt;10% connection failures in 1 minute</td>\n<td>Return HTTP 503 Service Unavailable</td>\n<td>&lt;1% failures for 30 seconds</td>\n</tr>\n<tr>\n<td>Balance Cache</td>\n<td>&gt;50% cache miss rate</td>\n<td>Direct database reads only</td>\n<td>Cache hit rate &gt;80% for 2 minutes</td>\n</tr>\n<tr>\n<td>Report Generation</td>\n<td>&gt;30 second average generation time</td>\n<td>Return cached reports only</td>\n<td>Average time &lt;10 seconds for 5 minutes</td>\n</tr>\n<tr>\n<td>Audit System</td>\n<td>&gt;5 second audit write latency</td>\n<td>Queue events for async processing</td>\n<td>Latency &lt;1 second for 30 seconds</td>\n</tr>\n</tbody></table>\n<p>The system continuously monitors key performance metrics and automatically adjusts connection pool sizes, cache TTLs, and timeout values based on observed load patterns and response times.</p>\n<blockquote>\n<p><strong>Critical Insight</strong>: Concurrent access in financial systems requires <strong>graceful degradation</strong> strategies where the system maintains core functionality (transaction posting and balance queries) even when auxiliary systems (reporting, audit) experience performance issues. This ensures that business operations can continue even during peak load periods.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The component interaction patterns described above require careful implementation to handle the complexity of coordinating multiple services while maintaining performance and reliability. The following guidance provides concrete implementation strategies and starter code for building these workflows.</p>\n<p><strong>Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Inter-service Communication</td>\n<td>HTTP REST with JSON serialization</td>\n<td>gRPC with Protocol Buffers for type safety</td>\n</tr>\n<tr>\n<td>Database Connection Management</td>\n<td><code>database/sql</code> with connection pooling</td>\n<td><code>jmoiron/sqlx</code> for enhanced query building</td>\n</tr>\n<tr>\n<td>Transaction Management</td>\n<td>Manual <code>sql.Tx</code> with rollback handling</td>\n<td><code>gorm</code> ORM with automatic transaction boundaries</td>\n</tr>\n<tr>\n<td>Caching Layer</td>\n<td>In-memory <code>sync.Map</code> with manual invalidation</td>\n<td>Redis with pub/sub for distributed invalidation</td>\n</tr>\n<tr>\n<td>Event Bus</td>\n<td>Channel-based message passing</td>\n<td>NATS or RabbitMQ for persistent messaging</td>\n</tr>\n<tr>\n<td>Circuit Breaker</td>\n<td>Manual error counting with thresholds</td>\n<td><code>sony/gobreaker</code> library with metrics integration</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  cmd/\n    ledger-server/\n      main.go                          ← HTTP server entry point\n  internal/\n    api/\n      handlers/\n        transaction_handler.go         ← REST endpoints for journal entries\n        report_handler.go             ← REST endpoints for financial reports\n        health_handler.go             ← Health check and metrics endpoints\n      middleware/\n        auth_middleware.go            ← User authentication and context\n        audit_middleware.go           ← Automatic audit event creation\n        idempotency_middleware.go     ← Request deduplication\n      models/\n        requests.go                   ← API request/response models\n        responses.go\n    orchestration/\n      transaction_workflow.go         ← Journal entry posting workflow\n      report_workflow.go             ← Financial report generation workflow\n      batch_processor.go             ← Multi-entry processing coordination\n    interfaces/\n      account_provider.go            ← Account management interface contracts\n      balance_calculator.go          ← Balance calculation interface contracts  \n      audit_tracker.go              ← Audit trail interface contracts\n    services/\n      account_manager.go             ← Account lifecycle management\n      transaction_recorder.go        ← Journal entry posting service\n      balance_engine.go              ← Balance calculation and caching\n      audit_system.go               ← Immutable change tracking\n      report_generator.go            ← Financial statement generation\n    cache/\n      memory_cache.go               ← L1 in-memory balance caching\n      invalidation_bus.go           ← Cross-instance cache coordination\n    database/\n      connection_pool.go            ← Database connection management\n      transaction_manager.go        ← Atomic transaction utilities\n      migrations/                   ← Database schema versioning\n        001_initial_schema.sql\n        002_add_audit_tables.sql\n    config/\n      config.go                     ← Configuration management\n      database_config.go            ← Database connection settings</code></pre></div>\n\n<p><strong>Transaction Workflow Infrastructure Code</strong></p>\n<p>Complete implementation of the atomic transaction workflow infrastructure that coordinates between components:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> orchestration</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/shopspring/decimal</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">your-project/internal/interfaces</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">your-project/internal/models</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WorkflowCoordinator manages the complete journal entry posting process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WorkflowCoordinator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    accountProvider  </span><span style=\"color:#B392F0\">interfaces</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AccountProvider</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    balanceCalc     </span><span style=\"color:#B392F0\">interfaces</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">BalanceCalculator</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    auditTracker    </span><span style=\"color:#B392F0\">interfaces</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AuditTracker</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db              </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache           </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">cache</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MemoryCache</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewWorkflowCoordinator creates a new workflow coordinator with all dependencies</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewWorkflowCoordinator</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    accountProvider</span><span style=\"color:#B392F0\"> interfaces</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AccountProvider</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    balanceCalc</span><span style=\"color:#B392F0\"> interfaces</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">BalanceCalculator</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    auditTracker</span><span style=\"color:#B392F0\"> interfaces</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AuditTracker</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    cache</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">cache</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">MemoryCache</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WorkflowCoordinator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">WorkflowCoordinator</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        accountProvider: accountProvider,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        balanceCalc:     balanceCalc,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        auditTracker:    auditTracker,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db:              db,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cache:           cache,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PostJournalEntry executes the complete posting workflow atomically</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">wc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WorkflowCoordinator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PostJournalEntry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">PostingResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    startTime </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate entry structure and business rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> wc.</span><span style=\"color:#B392F0\">validateEntryStructure</span><span style=\"color:#E1E4E8\">(ctx, entry); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"entry validation failed: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify all referenced accounts exist and are active</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> wc.</span><span style=\"color:#B392F0\">validateReferencedAccounts</span><span style=\"color:#E1E4E8\">(ctx, entry); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"account validation failed: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check that total debits equal total credits</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> wc.</span><span style=\"color:#B392F0\">validateDoubleEntryBalance</span><span style=\"color:#E1E4E8\">(ctx, entry); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"balance validation failed: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Execute atomic posting within database transaction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> wc.</span><span style=\"color:#B392F0\">executeAtomicPosting</span><span style=\"color:#E1E4E8\">(ctx, entry, userID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"atomic posting failed: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Update running balances for affected accounts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> wc.</span><span style=\"color:#B392F0\">updateAccountBalances</span><span style=\"color:#E1E4E8\">(ctx, entry); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Log error but don't fail - balance cache will eventually refresh</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        wc.</span><span style=\"color:#B392F0\">logError</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#9ECBFF\">\"balance update failed\"</span><span style=\"color:#E1E4E8\">, err, entry.ID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Create comprehensive audit trail</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> wc.</span><span style=\"color:#B392F0\">createAuditTrail</span><span style=\"color:#E1E4E8\">(ctx, entry, userID, startTime); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Log error but don't fail - audit is important but shouldn't block posting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        wc.</span><span style=\"color:#B392F0\">logError</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#9ECBFF\">\"audit trail creation failed\"</span><span style=\"color:#E1E4E8\">, err, entry.ID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Idempotent posting with duplicate detection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">wc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WorkflowCoordinator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PostJournalEntryIdempotent</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">idempotencyKey</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">PostingResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Check if this exact request has been processed before</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    existing, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> wc.</span><span style=\"color:#B392F0\">checkIdempotency</span><span style=\"color:#E1E4E8\">(ctx, idempotencyKey)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"idempotency check failed: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> existing </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 2: Return previous result if request already processed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">PostingResult</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            EntryID:   existing.EntryID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Status:    </span><span style=\"color:#9ECBFF\">\"COMPLETED\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            PostedAt:  existing.CreatedAt,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Message:   </span><span style=\"color:#9ECBFF\">\"Request previously processed\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Duplicate: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Record idempotency key before processing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> wc.</span><span style=\"color:#B392F0\">recordIdempotencyKey</span><span style=\"color:#E1E4E8\">(ctx, idempotencyKey, entry.ID); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"idempotency recording failed: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Process the entry using standard workflow</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> wc.</span><span style=\"color:#B392F0\">PostJournalEntry</span><span style=\"color:#E1E4E8\">(ctx, entry, userID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO 5: Update idempotency record with failure status</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        wc.</span><span style=\"color:#B392F0\">updateIdempotencyStatus</span><span style=\"color:#E1E4E8\">(ctx, idempotencyKey, </span><span style=\"color:#9ECBFF\">\"FAILED\"</span><span style=\"color:#E1E4E8\">, err.</span><span style=\"color:#B392F0\">Error</span><span style=\"color:#E1E4E8\">())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update idempotency record with success status</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    wc.</span><span style=\"color:#B392F0\">updateIdempotencyStatus</span><span style=\"color:#E1E4E8\">(ctx, idempotencyKey, </span><span style=\"color:#9ECBFF\">\"COMPLETED\"</span><span style=\"color:#E1E4E8\">, result.EntryID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// executeAtomicPosting handles the core database transaction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">wc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WorkflowCoordinator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">executeAtomicPosting</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">PostingResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tx, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> wc.db.</span><span style=\"color:#B392F0\">BeginTx</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TxOptions</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Isolation: sql.LevelReadCommitted,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to begin transaction: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> tx.</span><span style=\"color:#B392F0\">Rollback</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#6A737D\">// Will be ignored if tx.Commit() succeeds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Update entry status to POSTED with current timestamp</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entry.Status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> models.EntryStatusPosted</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entry.PostedAt </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    *</span><span style=\"color:#E1E4E8\">entry.PostedAt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Insert journal entry header record</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> wc.</span><span style=\"color:#B392F0\">insertJournalEntry</span><span style=\"color:#E1E4E8\">(ctx, tx, entry); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to insert journal entry: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Insert all line item records with proper sequencing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> wc.</span><span style=\"color:#B392F0\">insertEntryLines</span><span style=\"color:#E1E4E8\">(ctx, tx, entry); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to insert entry lines: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update running balances within the same transaction</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> wc.</span><span style=\"color:#B392F0\">updateRunningBalancesInTx</span><span style=\"color:#E1E4E8\">(ctx, tx, entry); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to update running balances: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Commit all changes atomically</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tx.</span><span style=\"color:#B392F0\">Commit</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to commit transaction: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">PostingResult</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        EntryID:   entry.ID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Status:    </span><span style=\"color:#9ECBFF\">\"POSTED\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        PostedAt:  </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">entry.PostedAt,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Message:   </span><span style=\"color:#9ECBFF\">\"Journal entry posted successfully\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Duplicate: </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Report Generation Workflow Implementation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> orchestration</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ReportWorkflow coordinates financial report generation across components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ReportWorkflow</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    balanceEngine    </span><span style=\"color:#B392F0\">interfaces</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">BalanceCalculator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    accountProvider  </span><span style=\"color:#B392F0\">interfaces</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AccountProvider</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache           </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">cache</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">ReportCache</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateTrialBalanceReport creates a complete trial balance with validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">rw </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReportWorkflow</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">GenerateTrialBalanceReport</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">asOfDate</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TrialBalance</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Get all active accounts organized by type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    accounts, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> rw.accountProvider.</span><span style=\"color:#B392F0\">GetActiveAccounts</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// nil = all types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to retrieve accounts: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Extract account IDs for batch balance retrieval</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    accountIDs </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(accounts))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, account </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> accounts {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        accountIDs[i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> account.ID</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Get balances for all accounts as of specified date</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    balances, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> rw.balanceEngine.</span><span style=\"color:#B392F0\">GetMultipleBalancesAsOf</span><span style=\"color:#E1E4E8\">(ctx, accountIDs, asOfDate)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to retrieve balances: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Build trial balance structure with account details</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    trialBalance </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TrialBalance</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        AsOfDate:        asOfDate,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        AccountBalances: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">([]</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AccountBalance</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">len</span><span style=\"color:#E1E4E8\">(accounts)),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TotalDebits:     </span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">{Amount: decimal.Zero, Currency: </span><span style=\"color:#9ECBFF\">\"USD\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        TotalCredits:    </span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">{Amount: decimal.Zero, Currency: </span><span style=\"color:#9ECBFF\">\"USD\"</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        GeneratedAt:     time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Process each account and categorize balances by normal balance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, account </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> accounts {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        balance, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> balances[account.ID]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span><span style=\"color:#6A737D\"> // Skip accounts with no activity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        accountBalance </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AccountBalance</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            AccountID:     account.ID,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            AccountCode:   account.Code,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            AccountName:   account.Name,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            AccountType:   account.Type,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Balance:       balance,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Determine if balance shows in debit or credit column</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> account.</span><span style=\"color:#B392F0\">IsDebitNormal</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> balance.Amount.</span><span style=\"color:#B392F0\">GreaterThan</span><span style=\"color:#E1E4E8\">(decimal.Zero) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                accountBalance.DebitAmount </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">balance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                trialBalance.TotalDebits </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> trialBalance.TotalDebits.</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(balance)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> balance.Amount.</span><span style=\"color:#B392F0\">LessThan</span><span style=\"color:#E1E4E8\">(decimal.Zero) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                creditAmount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">{Amount: balance.Amount.</span><span style=\"color:#B392F0\">Neg</span><span style=\"color:#E1E4E8\">(), Currency: balance.Currency}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                accountBalance.CreditAmount </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">creditAmount</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                trialBalance.TotalCredits </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> trialBalance.TotalCredits.</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(creditAmount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> balance.Amount.</span><span style=\"color:#B392F0\">GreaterThan</span><span style=\"color:#E1E4E8\">(decimal.Zero) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                accountBalance.CreditAmount </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">balance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                trialBalance.TotalCredits </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> trialBalance.TotalCredits.</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(balance)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> balance.Amount.</span><span style=\"color:#B392F0\">LessThan</span><span style=\"color:#E1E4E8\">(decimal.Zero) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                debitAmount </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">{Amount: balance.Amount.</span><span style=\"color:#B392F0\">Neg</span><span style=\"color:#E1E4E8\">(), Currency: balance.Currency}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                accountBalance.DebitAmount </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">debitAmount</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                trialBalance.TotalDebits </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> trialBalance.TotalDebits.</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(debitAmount)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        trialBalance.AccountBalances </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(trialBalance.AccountBalances, accountBalance)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Validate that total debits equal total credits</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    variance </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> trialBalance.TotalDebits.</span><span style=\"color:#B392F0\">Subtract</span><span style=\"color:#E1E4E8\">(trialBalance.TotalCredits)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    trialBalance.Variance </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> variance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    trialBalance.IsBalanced </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> variance.Amount.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(decimal.Zero)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> trialBalance, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Concurrency Implementation</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> cache</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">sync</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MemoryCache provides thread-safe L1 caching with TTL and version control</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MemoryCache</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    data    </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Map</span><span style=\"color:#6A737D\"> // map[string]*CachedBalance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mutex   </span><span style=\"color:#B392F0\">sync</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">RWMutex</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ttl     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metrics </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CacheMetrics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CachedBalance represents a cached balance entry with metadata</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> CachedBalance</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Balance   </span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CachedAt  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Version   </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExpiresAt </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get retrieves a cached balance with TTL checking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MemoryCache</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> mc.data.</span><span style=\"color:#B392F0\">Load</span><span style=\"color:#E1E4E8\">(accountID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">exists {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mc.metrics.</span><span style=\"color:#B392F0\">RecordMiss</span><span style=\"color:#E1E4E8\">(accountID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cached, ok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> value.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CachedBalance</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">ok </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">After</span><span style=\"color:#E1E4E8\">(cached.ExpiresAt) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mc.data.</span><span style=\"color:#B392F0\">Delete</span><span style=\"color:#E1E4E8\">(accountID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mc.metrics.</span><span style=\"color:#B392F0\">RecordExpiration</span><span style=\"color:#E1E4E8\">(accountID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mc.metrics.</span><span style=\"color:#B392F0\">RecordHit</span><span style=\"color:#E1E4E8\">(accountID)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#E1E4E8\">cached.Balance, </span><span style=\"color:#79B8FF\">true</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Set stores a balance in cache with automatic expiration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MemoryCache</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">balance</span><span style=\"color:#B392F0\"> models</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">version</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cached </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">CachedBalance</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Balance:   balance,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CachedAt:  time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Version:   version,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ExpiresAt: time.</span><span style=\"color:#B392F0\">Now</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">Add</span><span style=\"color:#E1E4E8\">(mc.ttl),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mc.data.</span><span style=\"color:#B392F0\">Store</span><span style=\"color:#E1E4E8\">(accountID, cached)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mc.metrics.</span><span style=\"color:#B392F0\">RecordSet</span><span style=\"color:#E1E4E8\">(accountID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// InvalidateAccounts removes specific accounts from cache</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">mc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MemoryCache</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">InvalidateAccounts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountIDs</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">timestamp</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, accountID </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> accountIDs {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> value, exists </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> mc.data.</span><span style=\"color:#B392F0\">Load</span><span style=\"color:#E1E4E8\">(accountID); exists {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> cached, ok </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> value.(</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CachedBalance</span><span style=\"color:#E1E4E8\">); ok </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> cached.CachedAt.</span><span style=\"color:#B392F0\">Before</span><span style=\"color:#E1E4E8\">(timestamp) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                mc.data.</span><span style=\"color:#B392F0\">Delete</span><span style=\"color:#E1E4E8\">(accountID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                mc.metrics.</span><span style=\"color:#B392F0\">RecordInvalidation</span><span style=\"color:#E1E4E8\">(accountID)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoint: Component Integration</strong></p>\n<p>After implementing the interaction patterns, verify the complete workflow:</p>\n<ol>\n<li><strong>Start the ledger server</strong>: <code>go run cmd/ledger-server/main.go</code></li>\n<li><strong>Create test accounts</strong>: POST to <code>/api/accounts</code> with asset, liability, and equity accounts</li>\n<li><strong>Post test journal entry</strong>: POST to <code>/api/journal-entries</code> with balanced debits and credits</li>\n<li><strong>Verify balance updates</strong>: GET <code>/api/accounts/{id}/balance</code> should show updated balances</li>\n<li><strong>Generate trial balance</strong>: GET <code>/api/reports/trial-balance</code> should show balanced report</li>\n<li><strong>Check audit trail</strong>: GET <code>/api/audit/events</code> should show all system activities</li>\n</ol>\n<p>Expected behavior:</p>\n<ul>\n<li>Journal entry posting completes in under 200ms for simple entries</li>\n<li>Balance queries return cached results in under 10ms </li>\n<li>Trial balance generation completes in under 2 seconds</li>\n<li>All audit events are recorded with proper user attribution</li>\n<li>Concurrent operations don&#39;t create incorrect balances or duplicate entries</li>\n</ul>\n<p><strong>Debugging Tips</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Journal entry posting hangs</td>\n<td>Database deadlock or long-running transaction</td>\n<td>Check <code>SHOW PROCESSLIST</code> in MySQL or <code>pg_stat_activity</code> in PostgreSQL</td>\n<td>Implement consistent lock ordering and transaction timeouts</td>\n</tr>\n<tr>\n<td>Balance queries return stale data</td>\n<td>Cache invalidation not working across instances</td>\n<td>Check cache invalidation messages and timestamps</td>\n<td>Verify message bus configuration and clock synchronization</td>\n</tr>\n<tr>\n<td>Trial balance doesn&#39;t balance</td>\n<td>Concurrent balance updates creating race conditions</td>\n<td>Compare sum of all entries to trial balance totals</td>\n<td>Implement optimistic locking with retry logic</td>\n</tr>\n<tr>\n<td>Reports generation causes timeouts</td>\n<td>Report queries blocking transaction posting</td>\n<td>Check database connection pool utilization</td>\n<td>Use read replicas for report generation</td>\n</tr>\n<tr>\n<td>High memory usage during peak load</td>\n<td>Cache growing unbounded without TTL enforcement</td>\n<td>Monitor cache size and entry expiration</td>\n<td>Implement LRU eviction and background cleanup</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1-5 (All milestones), as robust error handling and recovery mechanisms are essential throughout account modeling, transaction recording, balance calculation, audit trails, and financial reporting</p>\n</blockquote>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<p>Building a reliable double-entry ledger system requires comprehensive error handling that maintains the fundamental accounting equation under all conditions. Think of ledger error handling like the safety systems in a nuclear power plant – multiple independent layers that prevent any single failure from compromising the integrity of the entire system. Each layer catches different types of problems, from simple validation errors to catastrophic system failures, ensuring that the accounting records remain accurate and complete.</p>\n<p>The cornerstone principle is <strong>fail-safe accounting integrity</strong> – the system must never allow unbalanced entries, inconsistent balances, or lost transactions, even during partial failures or system crashes. This requires careful design of validation pipelines, atomic transaction boundaries, data corruption detection, and recovery procedures that can restore consistency after any type of failure.</p>\n<p><img src=\"/api/project/ledger-system/architecture-doc/asset?path=diagrams%2Fsystem-components.svg\" alt=\"High-Level System Component Architecture\"></p>\n<h3 id=\"validation-error-handling\">Validation Error Handling</h3>\n<p>Input validation forms the first line of defense against data corruption and accounting errors. Like a bank teller who checks every deposit slip before processing, the validation pipeline must verify business rules, data integrity constraints, and accounting principles before any data reaches the permanent ledger.</p>\n<p>The validation system operates in multiple stages, each catching different categories of errors. <strong>Structural validation</strong> ensures that required fields are present and data types are correct. <strong>Business rule validation</strong> verifies that debits equal credits, accounts exist and are active, and amounts are positive. <strong>Consistency validation</strong> checks that account types are compatible with debit/credit operations and that posting dates fall within open accounting periods.</p>\n<blockquote>\n<p><strong>Decision: Multi-Stage Validation Pipeline</strong></p>\n<ul>\n<li><strong>Context</strong>: Journal entries must be validated against numerous business rules before posting, but validation failures should provide clear guidance for correction</li>\n<li><strong>Options Considered</strong>: Single comprehensive validation function, separate validation per business rule, staged validation with early termination</li>\n<li><strong>Decision</strong>: Multi-stage pipeline that accumulates all errors before terminating</li>\n<li><strong>Rationale</strong>: Users need to see all validation problems at once to fix them efficiently, rather than discovering errors one at a time through multiple submission attempts</li>\n<li><strong>Consequences</strong>: More complex validation logic but significantly better user experience and fewer round trips for error correction</li>\n</ul>\n</blockquote>\n<p>The validation pipeline accumulates all detected errors into a structured result that provides specific guidance for correction. Rather than failing on the first error, the system examines the entire journal entry and reports all problems simultaneously, allowing users to fix multiple issues in a single correction cycle.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Stage</th>\n<th>Purpose</th>\n<th>Error Types Caught</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Schema Validation</td>\n<td>Data type and format checking</td>\n<td>Missing required fields, invalid data types, malformed currencies</td>\n<td>Return field-specific error messages with expected formats</td>\n</tr>\n<tr>\n<td>Business Rule Validation</td>\n<td>Accounting principle enforcement</td>\n<td>Unbalanced debits/credits, negative amounts, duplicate line items</td>\n<td>Return rule violation errors with current values and requirements</td>\n</tr>\n<tr>\n<td>Reference Validation</td>\n<td>Entity existence and status</td>\n<td>Non-existent accounts, inactive accounts, closed periods</td>\n<td>Return entity status with suggested alternatives</td>\n</tr>\n<tr>\n<td>Consistency Validation</td>\n<td>Cross-system integrity</td>\n<td>Account type compatibility, currency mismatches, duplicate references</td>\n<td>Return consistency errors with conflicting values highlighted</td>\n</tr>\n</tbody></table>\n<p><strong>Detailed validation error reporting</strong> provides the context needed for efficient error correction. Each <code>ValidationError</code> includes not only the error message but also the specific field name, invalid value, and suggested correction. This allows client applications to highlight problematic fields and provide inline correction guidance.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Validation Error Example:\n- Code: &quot;DEBITS_CREDITS_IMBALANCE&quot;\n- Field: &quot;Lines&quot;\n- Message: &quot;Total debits ($1,250.00) do not equal total credits ($1,200.00). Difference: $50.00&quot;\n- Value: {&quot;total_debits&quot;: 1250.00, &quot;total_credits&quot;: 1200.00, &quot;difference&quot;: 50.00}</code></pre></div>\n\n<p>The validation system maintains a <strong>validation rule registry</strong> that defines each business rule with its error code, message template, and severity level. This allows for consistent error reporting across all system components and enables configuration of validation strictness for different environments or user roles.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Rule</th>\n<th>Error Code</th>\n<th>Severity</th>\n<th>Description</th>\n<th>Suggested Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Balance Check</td>\n<td>DEBITS_CREDITS_IMBALANCE</td>\n<td>Error</td>\n<td>Total debits must equal total credits</td>\n<td>Adjust line item amounts to balance</td>\n</tr>\n<tr>\n<td>Account Existence</td>\n<td>ACCOUNT_NOT_FOUND</td>\n<td>Error</td>\n<td>Referenced account does not exist</td>\n<td>Verify account ID or create missing account</td>\n</tr>\n<tr>\n<td>Account Status</td>\n<td>ACCOUNT_INACTIVE</td>\n<td>Warning</td>\n<td>Account is marked inactive</td>\n<td>Reactivate account or use alternative</td>\n</tr>\n<tr>\n<td>Period Status</td>\n<td>PERIOD_CLOSED</td>\n<td>Error</td>\n<td>Cannot post to closed accounting period</td>\n<td>Post to current period or request period reopening</td>\n</tr>\n<tr>\n<td>Currency Consistency</td>\n<td>CURRENCY_MISMATCH</td>\n<td>Error</td>\n<td>Line item currency differs from account currency</td>\n<td>Convert currency or use correct account</td>\n</tr>\n</tbody></table>\n<p><strong>Idempotency validation</strong> prevents duplicate entry creation when clients retry failed requests. The system maintains an idempotency key registry that maps client-provided keys to processing results, allowing safe request retries without creating duplicate transactions.</p>\n<blockquote>\n<p>The critical insight is that validation errors should be treated as expected business conditions, not exceptional circumstances. A well-designed validation system prevents most data corruption scenarios by catching errors before they can affect the permanent ledger.</p>\n</blockquote>\n<h3 id=\"partial-failure-recovery\">Partial Failure Recovery</h3>\n<p>Atomic transaction boundaries ensure that complex operations either complete entirely or leave the system in an unchanged state. Think of this like a bank vault where either all the money transfers complete successfully, or none of them do – there&#39;s no middle ground where some transfers succeed and others fail, leaving the vault in an inconsistent state.</p>\n<p><strong>Database transaction management</strong> provides the foundation for atomic operations. Every journal entry posting operation executes within a database transaction that includes entry creation, balance updates, audit logging, and cache invalidation. If any step fails, the entire transaction rolls back, leaving the ledger in its original state.</p>\n<p>The transaction boundary encompasses all related operations to maintain consistency across multiple system components. When posting a journal entry, the system must update the entries table, modify running balances, create audit records, and invalidate cached balances within a single atomic operation.</p>\n<table>\n<thead>\n<tr>\n<th>Transaction Scope</th>\n<th>Operations Included</th>\n<th>Rollback Triggers</th>\n<th>Recovery Actions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Journal Entry Posting</td>\n<td>Create entry, validate balance, update balances, audit log</td>\n<td>Validation failure, database constraint violation, balance calculation error</td>\n<td>Full rollback, return validation errors, preserve idempotency record</td>\n</tr>\n<tr>\n<td>Account Creation</td>\n<td>Insert account, validate hierarchy, update parent references, audit log</td>\n<td>Circular reference detected, duplicate account code, parent account inactive</td>\n<td>Full rollback, return hierarchy errors, suggest alternative codes</td>\n</tr>\n<tr>\n<td>Balance Recalculation</td>\n<td>Lock account, recalculate from entries, update cached balance, verify consistency</td>\n<td>Concurrent modification, calculation mismatch, cache update failure</td>\n<td>Full rollback, retry with fresh data, escalate if repeated failures</td>\n</tr>\n<tr>\n<td>Period Closing</td>\n<td>Generate closing entries, post to ledger, update period status, audit trail</td>\n<td>Entry posting failure, balance verification failure, approval missing</td>\n<td>Full rollback, preserve partial work in staging tables, manual review required</td>\n</tr>\n</tbody></table>\n<p><strong>Optimistic concurrency control</strong> handles simultaneous access to the same accounts without blocking operations unnecessarily. The system uses version numbers on account balances and journal entries to detect when multiple operations attempt to modify the same data simultaneously.</p>\n<blockquote>\n<p><strong>Decision: Optimistic Locking with Version Numbers</strong></p>\n<ul>\n<li><strong>Context</strong>: Multiple users may attempt to post entries affecting the same accounts simultaneously, requiring coordination to maintain balance consistency</li>\n<li><strong>Options Considered</strong>: Pessimistic row locking, optimistic version-based locking, last-writer-wins</li>\n<li><strong>Decision</strong>: Optimistic locking using version numbers on critical entities</li>\n<li><strong>Rationale</strong>: Accounting systems typically have low contention on individual accounts, making optimistic locking more efficient than blocking approaches</li>\n<li><strong>Consequences</strong>: Better performance under normal conditions but requires retry logic when conflicts occur</li>\n</ul>\n</blockquote>\n<p>When a balance update detects that the account version has changed since the balance was read, the system retries the entire operation with fresh data. This approach maximizes concurrency while ensuring that balance calculations always use consistent input data.</p>\n<p><strong>Compensation transaction patterns</strong> handle failures in multi-step business operations that span multiple journal entries. When a complex operation like period closing fails partway through, the system creates compensating entries to reverse any changes that were successfully applied.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Example: Period Closing Failure Recovery\n1. Revenue closing entries posted successfully\n2. Expense closing entries failed due to account validation error\n3. System creates reversal entries to undo revenue closing\n4. Period remains open for correction\n5. Audit trail shows complete sequence including reversals</code></pre></div>\n\n<p><strong>Deadlock detection and retry logic</strong> handles database-level conflicts that can occur when multiple transactions access the same resources in different orders. The system implements exponential backoff retry with jitter to avoid retry storms and includes circuit breaker patterns to prevent cascading failures.</p>\n<table>\n<thead>\n<tr>\n<th>Failure Type</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n<th>Retry Policy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database Deadlock</td>\n<td>SQLException with deadlock error code</td>\n<td>Automatic retry with exponential backoff</td>\n<td>3 attempts, 100ms base delay, 2x multiplier</td>\n</tr>\n<tr>\n<td>Optimistic Lock Failure</td>\n<td>Version mismatch on balance update</td>\n<td>Reload fresh data and retry operation</td>\n<td>5 attempts, 50ms base delay, 1.5x multiplier</td>\n</tr>\n<tr>\n<td>Connection Timeout</td>\n<td>Database connection timeout exception</td>\n<td>Retry with new connection from pool</td>\n<td>2 attempts, immediate retry, then fail</td>\n</tr>\n<tr>\n<td>Constraint Violation</td>\n<td>Database constraint error</td>\n<td>Business validation failure, no retry</td>\n<td>Immediate failure, return validation error</td>\n</tr>\n</tbody></table>\n<h3 id=\"data-corruption-detection\">Data Corruption Detection</h3>\n<p>Continuous integrity monitoring ensures that the ledger remains mathematically consistent and detects any unauthorized modifications to historical records. Like a security system with motion sensors throughout a building, integrity checks operate at multiple levels to catch different types of corruption.</p>\n<p><strong>Trial balance verification</strong> provides the fundamental integrity check for double-entry accounting. The system periodically verifies that the sum of all debit balances equals the sum of all credit balances across all accounts. Any deviation indicates data corruption that requires immediate investigation.</p>\n<p>The trial balance calculation operates independently from the normal balance calculation engine, using different code paths and algorithms to detect errors in the primary balance logic. This provides defense in depth against software bugs that might corrupt balances systematically.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Trial Balance Integrity Check Process:\n1. Lock all accounts to prevent concurrent modifications\n2. Calculate raw balance from journal entry lines for each account\n3. Apply account type sign conventions (assets positive, liabilities negative)\n4. Sum all account balances ensuring zero total\n5. Compare individual account balances with cached running balances\n6. Generate discrepancy report for any differences found\n7. Trigger alert for total imbalance or individual account variances</code></pre></div>\n\n<p><strong>Cryptographic hash verification</strong> ensures that posted journal entries remain unchanged after creation. Each entry receives a content hash based on its essential fields, and these hashes form chains that detect unauthorized modifications to historical data.</p>\n<p>The hash chain creates a tamper-evident audit trail where modifying any historical entry breaks the cryptographic chain. The system periodically verifies hash chain integrity and can pinpoint exactly which entries have been modified.</p>\n<table>\n<thead>\n<tr>\n<th>Hash Type</th>\n<th>Purpose</th>\n<th>Algorithm</th>\n<th>Verification Frequency</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Content Hash</td>\n<td>Detect changes to entry data</td>\n<td>SHA-256 of entry fields</td>\n<td>On every entry access</td>\n</tr>\n<tr>\n<td>Chain Hash</td>\n<td>Link entries in chronological order</td>\n<td>SHA-256 of content + previous hash</td>\n<td>Daily batch verification</td>\n</tr>\n<tr>\n<td>Merkle Tree</td>\n<td>Efficient batch verification</td>\n<td>SHA-256 tree of entry hashes</td>\n<td>Weekly full verification</td>\n</tr>\n<tr>\n<td>Digital Signature</td>\n<td>Prove authorized creation</td>\n<td>RSA-2048 signature</td>\n<td>On-demand for audit</td>\n</tr>\n</tbody></table>\n<p><strong>Balance consistency verification</strong> compares running balance caches with recalculated balances to detect corruption in the balance calculation system. This check operates continuously in the background, selecting random accounts for verification and escalating any discrepancies found.</p>\n<blockquote>\n<p><strong>Decision: Continuous Background Verification</strong></p>\n<ul>\n<li><strong>Context</strong>: Balance calculation errors may not be immediately apparent but can compound over time, requiring ongoing monitoring</li>\n<li><strong>Options Considered</strong>: Manual periodic verification, on-demand verification only, continuous background checking</li>\n<li><strong>Decision</strong>: Continuous background verification with random sampling and scheduled full sweeps</li>\n<li><strong>Rationale</strong>: Early detection of calculation errors prevents small discrepancies from becoming large problems that are difficult to diagnose</li>\n<li><strong>Consequences</strong>: Additional CPU overhead but much faster detection and resolution of integrity issues</li>\n</ul>\n</blockquote>\n<p>The verification process maintains a queue of accounts requiring checking and processes them during low-activity periods to minimize performance impact on normal operations. High-priority accounts like cash and major revenue accounts receive more frequent verification.</p>\n<p><strong>Referential integrity monitoring</strong> ensures that all foreign key relationships remain valid and that deleted or modified accounts don&#39;t break existing journal entries. The system maintains dependency graphs showing which entries reference which accounts and validates these relationships during maintenance operations.</p>\n<table>\n<thead>\n<tr>\n<th>Integrity Check</th>\n<th>Scope</th>\n<th>Detection Method</th>\n<th>Response Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Trial Balance</td>\n<td>All accounts</td>\n<td>Sum debit/credit balances</td>\n<td>Alert and investigate if non-zero</td>\n</tr>\n<tr>\n<td>Hash Chain</td>\n<td>All journal entries</td>\n<td>Verify cryptographic links</td>\n<td>Identify modified entries and alert</td>\n</tr>\n<tr>\n<td>Balance Cache</td>\n<td>Random sample</td>\n<td>Compare cached vs calculated</td>\n<td>Refresh cache and alert on mismatch</td>\n</tr>\n<tr>\n<td>Foreign Keys</td>\n<td>All references</td>\n<td>Validate account/entry links</td>\n<td>Report orphaned references</td>\n</tr>\n<tr>\n<td>Audit Trail</td>\n<td>All modifications</td>\n<td>Verify change completeness</td>\n<td>Flag missing or inconsistent audit records</td>\n</tr>\n</tbody></table>\n<p><strong>Corruption response procedures</strong> define the steps for investigating and resolving detected integrity violations. The system automatically creates incident records that capture the current state, initiate investigation workflows, and track resolution progress.</p>\n<h3 id=\"system-failure-recovery\">System Failure Recovery</h3>\n<p>Startup integrity verification ensures that the ledger remains consistent after unexpected system shutdowns or crashes. Think of this like a pilot&#39;s preflight checklist – a systematic verification of all critical systems before resuming normal operations. The recovery process must detect any incomplete operations and restore the system to a consistent state.</p>\n<p><strong>Transaction log replay</strong> reconstructs the system state by reprocessing any operations that were committed to the database but may not have completed all related tasks like cache updates or audit logging. The system maintains operation logs that track the progress of complex multi-step procedures.</p>\n<p>During startup, the recovery process scans for incomplete operations and either completes them or rolls them back depending on their current state. This ensures that the system never starts in an inconsistent condition where the database contains partial results from failed operations.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Startup Recovery Process:\n1. Verify database connectivity and basic schema integrity\n2. Scan transaction log for incomplete operations since last clean shutdown\n3. For each incomplete operation, check completion status in database\n4. Complete any operations that were committed but not finalized\n5. Roll back any operations that were started but not committed\n6. Verify trial balance integrity across all accounts\n7. Refresh all cached balances from authoritative database values\n8. Validate hash chain integrity for recent entries\n9. Mark system as operational and enable normal request processing</code></pre></div>\n\n<p><strong>Database consistency checks</strong> verify that the fundamental relationships and constraints remain intact after a system failure. These checks go beyond standard foreign key constraints to validate accounting-specific rules like balance equation compliance and entry immutability.</p>\n<p>The consistency verification process runs automatically during startup and can be triggered manually when corruption is suspected. It operates independently from normal system functions to avoid masking problems that might be present in the regular code paths.</p>\n<table>\n<thead>\n<tr>\n<th>Consistency Check</th>\n<th>Purpose</th>\n<th>Validation Logic</th>\n<th>Recovery Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Schema Integrity</td>\n<td>Verify table structure</td>\n<td>Compare current schema with expected definitions</td>\n<td>Refuse startup if schema differs</td>\n</tr>\n<tr>\n<td>Foreign Key Validation</td>\n<td>Ensure reference validity</td>\n<td>Check all entry-to-account and parent-child relationships</td>\n<td>Report orphaned records for manual review</td>\n</tr>\n<tr>\n<td>Immutability Verification</td>\n<td>Confirm no historical changes</td>\n<td>Verify posted entries match their creation hashes</td>\n<td>Flag compromised entries and alert</td>\n</tr>\n<tr>\n<td>Balance Equation</td>\n<td>Validate accounting rules</td>\n<td>Recalculate trial balance and verify zero sum</td>\n<td>Emergency investigation if imbalanced</td>\n</tr>\n<tr>\n<td>Audit Completeness</td>\n<td>Check change tracking</td>\n<td>Verify all modifications have corresponding audit records</td>\n<td>Flag missing audit trails</td>\n</tr>\n</tbody></table>\n<p><strong>Backup validation and point-in-time recovery</strong> capabilities allow restoration to any previous consistent state when corruption is detected. The system maintains multiple backup types with different retention periods and recovery characteristics.</p>\n<blockquote>\n<p><strong>Decision: Layered Backup Strategy with Continuous WAL Shipping</strong></p>\n<ul>\n<li><strong>Context</strong>: Financial data requires multiple recovery options to handle different failure scenarios from hardware crashes to data corruption</li>\n<li><strong>Options Considered</strong>: Daily full backups only, incremental backups with weekly fulls, continuous WAL shipping with point-in-time recovery</li>\n<li><strong>Decision</strong>: Continuous WAL shipping with daily full backups and hourly incremental snapshots</li>\n<li><strong>Rationale</strong>: Financial systems require minimal data loss (RPO &lt; 1 minute) and fast recovery (RTO &lt; 30 minutes) which requires continuous replication</li>\n<li><strong>Consequences</strong>: Higher storage and network overhead but much better recovery capabilities and compliance with financial regulations</li>\n</ul>\n</blockquote>\n<p>The backup system maintains strict chain of custody for financial data, including cryptographic verification of backup integrity and secure storage with access auditing. Recovery procedures include verification steps to ensure that restored data maintains accounting consistency.</p>\n<p><strong>Automated alerting and escalation</strong> procedures ensure that system failures receive immediate attention and follow established incident response protocols. The alerting system distinguishes between routine operational issues and critical integrity violations that require emergency response.</p>\n<p>Critical alerts include trial balance imbalances, hash chain verification failures, or any condition that suggests data corruption or unauthorized access. These alerts trigger immediate notifications to accounting management and technical staff with predetermined escalation procedures if not acknowledged promptly.</p>\n<table>\n<thead>\n<tr>\n<th>Alert Type</th>\n<th>Severity</th>\n<th>Trigger Condition</th>\n<th>Response Time</th>\n<th>Escalation Path</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Trial Balance Imbalance</td>\n<td>Critical</td>\n<td>Non-zero trial balance total</td>\n<td>Immediate</td>\n<td>CFO, CTO, Compliance Officer</td>\n</tr>\n<tr>\n<td>Hash Chain Broken</td>\n<td>Critical</td>\n<td>Cryptographic verification failure</td>\n<td>Immediate</td>\n<td>Security Team, CTO, Legal</td>\n</tr>\n<tr>\n<td>System Startup Failure</td>\n<td>High</td>\n<td>Recovery process unable to complete</td>\n<td>15 minutes</td>\n<td>Operations Team, Engineering Lead</td>\n</tr>\n<tr>\n<td>Performance Degradation</td>\n<td>Medium</td>\n<td>Response time &gt; 5x baseline</td>\n<td>1 hour</td>\n<td>Operations Team, DBA</td>\n</tr>\n<tr>\n<td>Validation Error Spike</td>\n<td>Low</td>\n<td>Error rate &gt; 10% of requests</td>\n<td>4 hours</td>\n<td>Product Team, Engineering</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Incomplete Error Recovery State</strong>\nMany systems handle the primary error condition but fail to clean up secondary state that was modified during the failed operation. For example, when a journal entry posting fails, the system might successfully roll back the database transaction but forget to clear cached balance values that were calculated during the failed operation. This leaves the system in an inconsistent state where cached values don&#39;t match the database. Always include cache invalidation, cleanup of temporary state, and verification of system consistency in error recovery procedures.</p>\n<p>⚠️ <strong>Pitfall: Error Masking in Retry Logic</strong>\nAutomatic retry mechanisms can hide systematic problems by repeatedly failing and retrying operations that will never succeed. For instance, if account validation logic contains a bug that always rejects valid entries, the retry system might attempt the same operation dozens of times, generating excessive load and delayed error reporting. Implement retry limits, exponential backoff, and error pattern detection to identify when retries are not helping and should escalate to manual investigation.</p>\n<p>⚠️ <strong>Pitfall: Insufficient Error Context</strong>\nError handling code often captures the immediate failure condition but loses the business context that led to the error. When a balance calculation fails, knowing that &quot;SELECT statement failed&quot; is less useful than knowing &quot;failed while calculating balance for account 1001-Cash during posting of journal entry JE-2024-001234 for customer payment transaction.&quot; Always capture and propagate business context through error handling paths to enable efficient troubleshooting.</p>\n<p>⚠️ <strong>Pitfall: Recovery Race Conditions</strong>\nSystem recovery procedures can create race conditions when multiple instances attempt recovery simultaneously or when recovery operations conflict with incoming requests. For example, if the balance cache refresh process runs during startup while normal operations are already processing new entries, the cache might end up containing stale values. Use distributed locks, leader election, or sequential startup procedures to ensure that recovery operations complete atomically before normal request processing begins.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The error handling implementation requires careful coordination between validation logic, transaction management, integrity monitoring, and recovery procedures. This section provides the infrastructure and patterns needed to build robust error handling into the ledger system.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Transaction Management</td>\n<td>Go database/sql with manual tx handling</td>\n<td>Enterprise transaction coordinator with 2PC</td>\n</tr>\n<tr>\n<td>Validation Framework</td>\n<td>Custom validation functions with error accumulation</td>\n<td>Schema-driven validation with rule engine</td>\n</tr>\n<tr>\n<td>Integrity Monitoring</td>\n<td>Cron jobs with SQL queries</td>\n<td>Real-time stream processing with Kafka</td>\n</tr>\n<tr>\n<td>Backup Strategy</td>\n<td>pg_dump daily with WAL archiving</td>\n<td>Continuous replication with automated failover</td>\n</tr>\n<tr>\n<td>Alerting System</td>\n<td>Email notifications with basic templating</td>\n<td>PagerDuty integration with intelligent escalation</td>\n</tr>\n<tr>\n<td>Monitoring Dashboard</td>\n<td>Simple Grafana charts with key metrics</td>\n<td>Full observability stack with distributed tracing</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>internal/\n├── errors/\n│   ├── validation.go           ← validation error types and accumulation\n│   ├── business_rules.go       ← accounting-specific validation rules\n│   ├── recovery.go            ← error recovery and retry logic\n│   └── errors_test.go         ← comprehensive error scenario testing\n├── integrity/\n│   ├── trial_balance.go       ← trial balance verification\n│   ├── hash_chain.go          ← cryptographic integrity checking\n│   ├── consistency.go         ← cross-system consistency validation\n│   └── monitors.go            ← background integrity monitoring\n├── recovery/\n│   ├── startup.go             ← system startup and recovery procedures\n│   ├── backup.go              ← backup validation and restoration\n│   ├── incidents.go           ← incident tracking and escalation\n│   └── alerts.go              ← alerting and notification system\n└── transaction/\n    ├── coordinator.go         ← atomic transaction coordination\n    ├── isolation.go           ← concurrency control and deadlock handling\n    ├── retry.go               ← retry logic with exponential backoff\n    └── compensation.go        ← compensation transaction patterns</code></pre></div>\n\n<h4 id=\"infrastructure-validation-framework\">Infrastructure: Validation Framework</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> errors</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/shopspring/decimal</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidationError represents a specific business rule violation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ValidationError</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Code    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"code\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Field   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"field\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Message </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">      `json:\"message\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Value   </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"value\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidationResult accumulates all validation errors and warnings</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ValidationResult</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IsValid  </span><span style=\"color:#F97583\">bool</span><span style=\"color:#9ECBFF\">              `json:\"is_valid\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Errors   []</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#9ECBFF\"> `json:\"errors\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Warnings []</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#9ECBFF\"> `json:\"warnings\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidationRule defines a single business rule check</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ValidationRule</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Code        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Severity    </span><span style=\"color:#F97583\">string</span><span style=\"color:#6A737D\"> // \"error\" or \"warning\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CheckFunc   </span><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ValidationError</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidationRegistry maintains all validation rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ValidationRegistry</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rules </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">ValidationRule</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewValidationRegistry creates a registry with standard accounting rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewValidationRegistry</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ValidationRegistry</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    registry </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ValidationRegistry</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rules: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">ValidationRule</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Register standard accounting validation rules</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    registry.</span><span style=\"color:#B392F0\">RegisterRule</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ValidationRule</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Code:        </span><span style=\"color:#9ECBFF\">\"DEBITS_CREDITS_BALANCE\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Description: </span><span style=\"color:#9ECBFF\">\"Total debits must equal total credits\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Severity:    </span><span style=\"color:#9ECBFF\">\"error\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CheckFunc:   validateDebitCreditBalance,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    registry.</span><span style=\"color:#B392F0\">RegisterRule</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ValidationRule</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Code:        </span><span style=\"color:#9ECBFF\">\"ACCOUNT_EXISTS\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Description: </span><span style=\"color:#9ECBFF\">\"All referenced accounts must exist and be active\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Severity:    </span><span style=\"color:#9ECBFF\">\"error\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CheckFunc:   validateAccountExistence,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    registry.</span><span style=\"color:#B392F0\">RegisterRule</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ValidationRule</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Code:        </span><span style=\"color:#9ECBFF\">\"POSITIVE_AMOUNTS\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Description: </span><span style=\"color:#9ECBFF\">\"All line item amounts must be positive\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Severity:    </span><span style=\"color:#9ECBFF\">\"error\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        CheckFunc:   validatePositiveAmounts,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> registry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RegisterRule adds a new validation rule to the registry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ValidationRegistry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RegisterRule</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rule</span><span style=\"color:#B392F0\"> ValidationRule</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    r.rules[rule.Code] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> rule</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateEntry runs all validation rules against a journal entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ValidationRegistry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateEntry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ValidationResult</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ValidationResult</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        IsValid:  </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Errors:   []</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#E1E4E8\">{},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Warnings: []</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#E1E4E8\">{},</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Run all validation rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _, rule </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> range</span><span style=\"color:#E1E4E8\"> r.rules {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> rule.</span><span style=\"color:#B392F0\">CheckFunc</span><span style=\"color:#E1E4E8\">(ctx, entry); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> rule.Severity </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"error\"</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                result.Errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(result.Errors, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                result.IsValid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                result.Warnings </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> append</span><span style=\"color:#E1E4E8\">(result.Warnings, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Standard validation rule implementations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> validateDebitCreditBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    totalDebits, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> entry.</span><span style=\"color:#B392F0\">TotalDebits</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Code:    </span><span style=\"color:#9ECBFF\">\"CALCULATION_ERROR\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Field:   </span><span style=\"color:#9ECBFF\">\"Lines\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Message: fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to calculate total debits: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Value:   </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    totalCredits, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> entry.</span><span style=\"color:#B392F0\">TotalCredits</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Code:    </span><span style=\"color:#9ECBFF\">\"CALCULATION_ERROR\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Field:   </span><span style=\"color:#9ECBFF\">\"Lines\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Message: fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Failed to calculate total credits: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Value:   </span><span style=\"color:#79B8FF\">nil</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#E1E4E8\">totalDebits.Amount.</span><span style=\"color:#B392F0\">Equal</span><span style=\"color:#E1E4E8\">(totalCredits.Amount) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        difference </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> totalDebits.Amount.</span><span style=\"color:#B392F0\">Sub</span><span style=\"color:#E1E4E8\">(totalCredits.Amount)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Code:  </span><span style=\"color:#9ECBFF\">\"DEBITS_CREDITS_IMBALANCE\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Field: </span><span style=\"color:#9ECBFF\">\"Lines\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Message: fmt.</span><span style=\"color:#B392F0\">Sprintf</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"Total debits (</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#79B8FF\"> %s</span><span style=\"color:#9ECBFF\">) do not equal total credits (</span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#79B8FF\"> %s</span><span style=\"color:#9ECBFF\">). Difference: </span><span style=\"color:#79B8FF\">%s</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                totalDebits.Amount.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(), totalDebits.Currency,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                totalCredits.Amount.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(), totalCredits.Currency,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                difference.</span><span style=\"color:#B392F0\">Abs</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            Value: </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"total_debits\"</span><span style=\"color:#E1E4E8\">:  totalDebits,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"total_credits\"</span><span style=\"color:#E1E4E8\">: totalCredits,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"difference\"</span><span style=\"color:#E1E4E8\">:    difference,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> validateAccountExistence</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement account existence validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Extract unique account IDs from all entry lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Query database to verify accounts exist and are active</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Return error with list of missing/inactive accounts if any found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> validatePositiveAmounts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement positive amount validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Iterate through all entry lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Check that debit/credit amounts are positive (> 0)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Return error with line numbers of invalid amounts if any found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"infrastructure-transaction-management\">Infrastructure: Transaction Management</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> transaction</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">math/rand</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TransactionCoordinator manages atomic operations across multiple components</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TransactionCoordinator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewTransactionCoordinator creates a new transaction coordinator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewTransactionCoordinator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionCoordinator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">TransactionCoordinator</span><span style=\"color:#E1E4E8\">{db: db}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WithTransaction executes a function within a database transaction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Automatically handles rollback on error and commit on success</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionCoordinator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WithTransaction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fn</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">tx</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Tx</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tx, err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tc.db.</span><span style=\"color:#B392F0\">BeginTx</span><span style=\"color:#E1E4E8\">(ctx, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TxOptions</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        Isolation: sql.LevelSerializable,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ReadOnly:  </span><span style=\"color:#79B8FF\">false</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    })</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to begin transaction: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> p </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> recover</span><span style=\"color:#E1E4E8\">(); p </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tx.</span><span style=\"color:#B392F0\">Rollback</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">            panic</span><span style=\"color:#E1E4E8\">(p)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> fn</span><span style=\"color:#E1E4E8\">(tx); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> rbErr </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tx.</span><span style=\"color:#B392F0\">Rollback</span><span style=\"color:#E1E4E8\">(); rbErr </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"transaction failed: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">, rollback failed: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err, rbErr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> err</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> tx.</span><span style=\"color:#B392F0\">Commit</span><span style=\"color:#E1E4E8\">(); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"failed to commit transaction: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RetryConfig defines retry behavior for failed operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RetryConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxAttempts  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BaseDelay    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxDelay     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Multiplier   </span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Jitter       </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DefaultRetryConfig provides sensible defaults for most operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">var</span><span style=\"color:#E1E4E8\"> DefaultRetryConfig </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> RetryConfig</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxAttempts: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BaseDelay:   </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Millisecond,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxDelay:    </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Multiplier:  </span><span style=\"color:#79B8FF\">2.0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Jitter:      </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// WithRetry executes an operation with exponential backoff retry logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">tc </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionCoordinator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">WithRetry</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> RetryConfig</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">operation</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> lastErr </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> attempt </span><span style=\"color:#F97583\">:=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">; attempt </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> config.MaxAttempts; attempt</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lastErr </span><span style=\"color:#F97583\">=</span><span style=\"color:#B392F0\"> operation</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> lastErr </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#6A737D\"> // Success</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Check if error is retryable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> !</span><span style=\"color:#B392F0\">isRetryableError</span><span style=\"color:#E1E4E8\">(lastErr) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> lastErr</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Don't sleep on the last attempt</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> attempt </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> config.MaxAttempts {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Calculate delay with exponential backoff</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        delay </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(config.BaseDelay) </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            math.</span><span style=\"color:#B392F0\">Pow</span><span style=\"color:#E1E4E8\">(config.Multiplier, </span><span style=\"color:#F97583\">float64</span><span style=\"color:#E1E4E8\">(attempt</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> delay </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> config.MaxDelay {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            delay </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> config.MaxDelay</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // Add jitter to prevent thundering herd</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> config.Jitter {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            jitterRange </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> int64</span><span style=\"color:#E1E4E8\">(delay </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#6A737D\">// 25% jitter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            jitter </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> time.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">(rand.</span><span style=\"color:#B392F0\">Int63n</span><span style=\"color:#E1E4E8\">(jitterRange</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> jitterRange)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            delay </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> jitter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        select</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">ctx.</span><span style=\"color:#B392F0\">Done</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> ctx.</span><span style=\"color:#B392F0\">Err</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        case</span><span style=\"color:#F97583\"> &#x3C;-</span><span style=\"color:#E1E4E8\">time.</span><span style=\"color:#B392F0\">After</span><span style=\"color:#E1E4E8\">(delay):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"operation failed after </span><span style=\"color:#79B8FF\">%d</span><span style=\"color:#9ECBFF\"> attempts, last error: </span><span style=\"color:#79B8FF\">%w</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        config.MaxAttempts, lastErr)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// isRetryableError determines if an error indicates a transient condition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> isRetryableError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">err</span><span style=\"color:#F97583\"> error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement retryable error detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Check for database deadlock errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Check for connection timeout errors  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Check for optimistic lock failures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Return false for business validation errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Return true for transient infrastructure errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> false</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-integrity-monitoring\">Core Logic: Integrity Monitoring</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> integrity</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">crypto/sha256</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">encoding/hex</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IntegrityMonitor performs continuous consistency checking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IntegrityMonitor</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Dependencies injected during construction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MonitorConfig defines monitoring behavior and thresholds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MonitorConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TrialBalanceCheckInterval </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HashVerificationInterval  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RandomSampleSize         </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AlertThreshold           </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewIntegrityMonitor creates a monitor with background checking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewIntegrityMonitor</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> MonitorConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IntegrityMonitor</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Initialize monitor with configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Set up periodic goroutines for different check types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Initialize alert channels and escalation procedures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Configure sampling parameters for random verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// VerifyTrialBalance checks that all account balances sum to zero</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">im </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IntegrityMonitor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">VerifyTrialBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement comprehensive trial balance verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Lock accounts to prevent concurrent modifications</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Calculate raw balance from journal entries for each account</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Apply account type sign conventions (assets +, liabilities -)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Sum all balances ensuring total equals zero</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Compare individual balances with cached running balances</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 6. Generate detailed discrepancy report for investigation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 7. Trigger critical alert if total imbalance detected</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// VerifyHashChain validates cryptographic integrity of entries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">im </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IntegrityMonitor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">VerifyHashChain</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">startDate</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">endDate</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement hash chain verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Query entries in chronological order within date range</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Recalculate content hash for each entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Verify chain hash links between consecutive entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Check that no entries have been modified since creation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Report any broken links or modified entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 6. Update verification timestamps for successfully checked entries</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// GenerateContentHash creates a deterministic hash for journal entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> GenerateContentHash</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement deterministic content hashing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Serialize entry fields in canonical order (ID, date, description, lines)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Include line items sorted by line number</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Use consistent number formatting for amounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Calculate SHA-256 hash of serialized content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Return hex-encoded hash string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Sort fields alphabetically and use fixed-point decimal representation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// CheckBalanceConsistency compares cached vs calculated balances</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">im </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">IntegrityMonitor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">CheckBalanceConsistency</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountIDs</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement balance consistency verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. For each account, get cached running balance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Recalculate balance from all posted journal entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Compare calculated vs cached values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Report discrepancies with detailed context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Optionally refresh cache if discrepancies found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 6. Track verification history for trending analysis</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-logic-system-recovery\">Core Logic: System Recovery</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> recovery</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SystemRecovery handles startup consistency verification and failure recovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SystemRecovery</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Dependencies injected during construction</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RecoveryConfig defines recovery procedures and timeouts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> RecoveryConfig</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartupTimeout    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    VerificationDepth </span><span style=\"color:#F97583\">int</span><span style=\"color:#6A737D\"> // Days of history to verify</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AutoRepairEnabled </span><span style=\"color:#F97583\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewSystemRecovery creates recovery manager with configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewSystemRecovery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">config</span><span style=\"color:#B392F0\"> RecoveryConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SystemRecovery</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">SystemRecovery</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PerformStartupRecovery executes complete system consistency check</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sr </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SystemRecovery</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PerformStartupRecovery</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement comprehensive startup recovery</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Verify database connectivity and schema integrity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Scan for incomplete operations from previous shutdown</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Complete or rollback partial operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Verify trial balance across all accounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Refresh all cached balances from database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 6. Validate recent hash chain integrity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 7. Mark system operational only after all checks pass</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 8. Generate startup report with any issues found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DetectIncompleteOperations finds operations interrupted by system failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sr </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SystemRecovery</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DetectIncompleteOperations</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">IncompleteOperation</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement incomplete operation detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Query operation log for entries since last clean shutdown</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Check completion status in database for each operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Identify operations that started but didn't finish</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Categorize by operation type and required recovery action</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Return list of operations requiring completion or rollback</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RepairInconsistencies attempts to fix detected data problems</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sr </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SystemRecovery</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">RepairInconsistencies</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">issues</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">ConsistencyIssue</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement automatic inconsistency repair</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Analyze each consistency issue type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Determine if automatic repair is safe and possible</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Create compensating transactions for balance discrepancies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Refresh caches for stale cached values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Log all repair actions taken for audit trail</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 6. Escalate to manual review if automatic repair not possible</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateSystemState performs comprehensive consistency verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">sr </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SystemRecovery</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateSystemState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SystemStateReport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Implement complete system state validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 1. Verify trial balance integrity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 2. Check all foreign key relationships</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 3. Validate audit trail completeness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 4. Verify hash chain integrity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 5. Check balance cache consistency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 6. Generate comprehensive status report</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // 7. Include recommendations for any issues found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">nil</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IncompleteOperation represents an operation that needs recovery</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IncompleteOperation</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OperationID   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OperationType </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    StartedAt     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastActivity  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CurrentState  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RecoveryAction </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ConsistencyIssue represents a detected data integrity problem</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ConsistencyIssue</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IssueType   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Severity    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AffectedIDs []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RepairAction </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SystemStateReport summarizes system health after validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SystemStateReport</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ValidationTime    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OverallStatus     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IssuesFound       []</span><span style=\"color:#B392F0\">ConsistencyIssue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RepairActions     []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OperationalStatus </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Recommendations   []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Milestone 1: Basic Validation Framework</strong></p>\n<ul>\n<li>Run: <code>go test ./internal/errors/... -v</code></li>\n<li>Expected: All validation rules pass for valid entries, reject unbalanced entries</li>\n<li>Manual test: Submit journal entry with debits != credits, verify detailed error message</li>\n<li>Signs of problems: Generic error messages, validation bypassed, missing field context</li>\n</ul>\n<p><strong>Milestone 2: Transaction Coordination</strong></p>\n<ul>\n<li>Run: <code>go test ./internal/transaction/... -race -v</code></li>\n<li>Expected: Atomic operations with proper rollback, retry logic handles deadlocks</li>\n<li>Manual test: Simulate database failure during posting, verify clean rollback</li>\n<li>Signs of problems: Partial data persisted, deadlocks not resolved, inconsistent state</li>\n</ul>\n<p><strong>Milestone 3: Integrity Monitoring</strong></p>\n<ul>\n<li>Run: <code>go test ./internal/integrity/... -v</code></li>\n<li>Expected: Trial balance verification catches imbalances, hash verification detects changes</li>\n<li>Manual test: Manually modify posted entry, verify integrity check detects tampering</li>\n<li>Signs of problems: False positives/negatives, performance degradation, missed corruption</li>\n</ul>\n<p><strong>Milestone 4: Recovery Procedures</strong></p>\n<ul>\n<li>Run: <code>go test ./internal/recovery/... -v</code></li>\n<li>Expected: Clean startup after simulated crashes, automatic repair of minor issues</li>\n<li>Manual test: Kill system during posting, verify clean recovery on restart</li>\n<li>Signs of problems: Startup failures, undetected corruption, lost transactions</li>\n</ul>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1-5 (All milestones), as comprehensive testing strategies are essential throughout account modeling, transaction recording, balance calculation, audit trails, and financial reporting to ensure system reliability and accounting accuracy</p>\n</blockquote>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<p>Building a double-entry accounting system requires a rigorous testing approach that goes beyond traditional software testing. Think of testing an accounting system like auditing a bank&#39;s books - you need to verify not just that individual calculations are correct, but that the entire system maintains fundamental accounting principles under all conditions. Every test must validate that debits equal credits, balances remain consistent, and the audit trail provides complete traceability.</p>\n<p>The testing strategy for our ledger system follows a multi-layered approach that mirrors how real accounting firms verify financial records. Just as auditors use sampling techniques, analytical procedures, and substantive tests, our testing strategy combines unit tests for individual components, integration tests for end-to-end workflows, and property-based tests that verify accounting invariants hold under all conditions.</p>\n<p><strong>Testing Philosophy for Financial Systems</strong></p>\n<p>Testing an accounting system differs fundamentally from testing typical business applications because accounting has mathematical invariants that must always hold true. The most critical invariant is the <strong>accounting equation</strong>: Assets = Liabilities + Equity, which means the trial balance must always sum to zero. Unlike web applications where minor bugs might cause user inconvenience, accounting bugs can result in regulatory violations, financial misstatements, and legal liability.</p>\n<p>Think of our testing approach like a three-tier verification system used by accounting firms. The first tier (unit tests) is like checking individual calculations - ensuring that each component performs its mathematical operations correctly in isolation. The second tier (integration tests) is like checking complete business processes - verifying that posting journal entries updates all related systems correctly. The third tier (property-based tests) is like performing analytical procedures - using randomized data to verify that fundamental accounting relationships always hold.</p>\n<blockquote>\n<p><strong>Critical Testing Principle</strong></p>\n<p>Every test in an accounting system must verify both functional correctness (does the code work?) and accounting integrity (does the result maintain double-entry principles?). A test that passes functionally but allows unbalanced entries is considered a failure.</p>\n</blockquote>\n<h3 id=\"unit-testing-approach\">Unit Testing Approach</h3>\n<p>Unit testing for the ledger system focuses on testing individual components in isolation while verifying they maintain accounting integrity. Each component has specific mathematical and business rules that must be validated independently before testing component interactions.</p>\n<p><strong>Account Management Unit Tests</strong></p>\n<p>The Account Management component requires tests that verify account creation, hierarchy validation, and type-specific behavior. These tests ensure the chart of accounts maintains proper structure and enforces business rules.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Test Method</th>\n<th>Validation Focus</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Account Creation</td>\n<td><code>TestCreateAccount_ValidTypes</code></td>\n<td>Account type validation</td>\n<td>Successfully creates accounts for each type (ASSET, LIABILITY, EQUITY, REVENUE, EXPENSE)</td>\n</tr>\n<tr>\n<td>Account Creation</td>\n<td><code>TestCreateAccount_InvalidParent</code></td>\n<td>Hierarchy validation</td>\n<td>Rejects account creation when parent doesn&#39;t exist or would create circular reference</td>\n</tr>\n<tr>\n<td>Account Creation</td>\n<td><code>TestCreateAccount_DuplicateCode</code></td>\n<td>Uniqueness constraints</td>\n<td>Prevents creating accounts with duplicate codes within same parent</td>\n</tr>\n<tr>\n<td>Normal Balance</td>\n<td><code>TestNormalBalance_AssetAccounts</code></td>\n<td>Balance calculation rules</td>\n<td>Asset and expense accounts return DEBIT as normal balance</td>\n</tr>\n<tr>\n<td>Normal Balance</td>\n<td><code>TestNormalBalance_LiabilityAccounts</code></td>\n<td>Balance calculation rules</td>\n<td>Liability, equity, and revenue accounts return CREDIT as normal balance</td>\n</tr>\n<tr>\n<td>Hierarchy Validation</td>\n<td><code>TestValidateAccountHierarchy_CircularReference</code></td>\n<td>Structure integrity</td>\n<td>Detects and prevents circular parent-child relationships</td>\n</tr>\n<tr>\n<td>Account Deactivation</td>\n<td><code>TestDeactivateAccount_WithBalance</code></td>\n<td>Business rule enforcement</td>\n<td>Prevents deactivating accounts with non-zero balances</td>\n</tr>\n</tbody></table>\n<p><strong>Journal Entry Validation Unit Tests</strong></p>\n<p>Journal entry validation is the heart of double-entry bookkeeping enforcement. These tests verify that the validation engine catches all possible violations of accounting rules before entries reach the posting stage.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Test Method</th>\n<th>Validation Focus</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Balance Validation</td>\n<td><code>TestValidateEntry_UnbalancedEntry</code></td>\n<td>Double-entry enforcement</td>\n<td>Rejects entries where total debits ≠ total credits</td>\n</tr>\n<tr>\n<td>Balance Validation</td>\n<td><code>TestValidateEntry_BalancedEntry</code></td>\n<td>Double-entry verification</td>\n<td>Accepts entries where total debits = total credits</td>\n</tr>\n<tr>\n<td>Amount Validation</td>\n<td><code>TestValidateEntry_NegativeAmounts</code></td>\n<td>Data integrity</td>\n<td>Rejects entries with negative debit or credit amounts</td>\n</tr>\n<tr>\n<td>Amount Validation</td>\n<td><code>TestValidateEntry_ZeroAmounts</code></td>\n<td>Data integrity</td>\n<td>Rejects entries with zero amounts on debit or credit lines</td>\n</tr>\n<tr>\n<td>Account Validation</td>\n<td><code>TestValidateEntry_InactiveAccounts</code></td>\n<td>Business rule enforcement</td>\n<td>Rejects entries referencing deactivated accounts</td>\n</tr>\n<tr>\n<td>Account Validation</td>\n<td><code>TestValidateEntry_NonexistentAccounts</code></td>\n<td>Data integrity</td>\n<td>Rejects entries referencing accounts that don&#39;t exist</td>\n</tr>\n<tr>\n<td>Currency Validation</td>\n<td><code>TestValidateEntry_MixedCurrencies</code></td>\n<td>Multi-currency rules</td>\n<td>Handles entries with multiple currencies using exchange rates</td>\n</tr>\n<tr>\n<td>Line Item Validation</td>\n<td><code>TestValidateEntry_EmptyLines</code></td>\n<td>Data completeness</td>\n<td>Rejects entries with no debit or credit lines</td>\n</tr>\n</tbody></table>\n<p><strong>Balance Calculation Unit Tests</strong></p>\n<p>Balance calculation tests verify that the balance engine performs mathematical operations correctly and maintains consistency between cached and calculated values. These tests are critical because balance errors can cascade throughout the entire system.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Test Method</th>\n<th>Validation Focus</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Running Balance</td>\n<td><code>TestUpdateRunningBalance_SingleEntry</code></td>\n<td>Incremental updates</td>\n<td>Correctly updates account balance after posting single entry</td>\n</tr>\n<tr>\n<td>Running Balance</td>\n<td><code>TestUpdateRunningBalance_MultipleEntries</code></td>\n<td>Incremental updates</td>\n<td>Maintains correct balance through sequence of multiple entries</td>\n</tr>\n<tr>\n<td>Point-in-Time Balance</td>\n<td><code>TestGetBalanceAsOf_HistoricalDate</code></td>\n<td>Historical accuracy</td>\n<td>Returns correct balance considering only entries posted by specified date</td>\n</tr>\n<tr>\n<td>Point-in-Time Balance</td>\n<td><code>TestGetBalanceAsOf_FutureDate</code></td>\n<td>Edge case handling</td>\n<td>Returns current balance when querying future date</td>\n</tr>\n<tr>\n<td>Account Type Handling</td>\n<td><code>TestCalculateBalance_AssetAccount</code></td>\n<td>Sign conventions</td>\n<td>Asset account balances increase with debits, decrease with credits</td>\n</tr>\n<tr>\n<td>Account Type Handling</td>\n<td><code>TestCalculateBalance_LiabilityAccount</code></td>\n<td>Sign conventions</td>\n<td>Liability account balances increase with credits, decrease with debits</td>\n</tr>\n<tr>\n<td>Cache Consistency</td>\n<td><code>TestBalanceCache_InvalidationOnUpdate</code></td>\n<td>Cache management</td>\n<td>Cached balances are invalidated and recalculated when new entries posted</td>\n</tr>\n<tr>\n<td>Multi-Currency Balance</td>\n<td><code>TestCalculateBalance_ForeignCurrency</code></td>\n<td>Currency handling</td>\n<td>Balances calculated correctly for accounts in non-base currencies</td>\n</tr>\n</tbody></table>\n<p><strong>Monetary Amount Unit Tests</strong></p>\n<p>Monetary calculations require special attention because floating-point arithmetic can introduce rounding errors that violate accounting precision requirements. All money calculations must use fixed-point arithmetic to ensure exactness.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Test Method</th>\n<th>Validation Focus</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Basic Operations</td>\n<td><code>TestMoney_AddSameCurrency</code></td>\n<td>Arithmetic accuracy</td>\n<td>Adding two amounts in same currency produces exact result</td>\n</tr>\n<tr>\n<td>Basic Operations</td>\n<td><code>TestMoney_SubtractSameCurrency</code></td>\n<td>Arithmetic accuracy</td>\n<td>Subtracting amounts in same currency produces exact result</td>\n</tr>\n<tr>\n<td>Currency Validation</td>\n<td><code>TestMoney_AddDifferentCurrencies</code></td>\n<td>Business rule enforcement</td>\n<td>Adding amounts in different currencies returns validation error</td>\n</tr>\n<tr>\n<td>Precision Handling</td>\n<td><code>TestMoney_PrecisionPreservation</code></td>\n<td>Mathematical accuracy</td>\n<td>Operations preserve decimal precision without floating-point errors</td>\n</tr>\n<tr>\n<td>Zero Handling</td>\n<td><code>TestMoney_ZeroAmountOperations</code></td>\n<td>Edge case handling</td>\n<td>Operations with zero amounts behave correctly</td>\n</tr>\n<tr>\n<td>Negative Handling</td>\n<td><code>TestMoney_NegativeAmountOperations</code></td>\n<td>Mathematical accuracy</td>\n<td>Negative amounts handled correctly in arithmetic operations</td>\n</tr>\n<tr>\n<td>String Representation</td>\n<td><code>TestMoney_FormattingConsistency</code></td>\n<td>Display accuracy</td>\n<td>String formatting maintains precision and currency symbol</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Fixed-Point Arithmetic for Monetary Values</strong></p>\n<ul>\n<li><strong>Context</strong>: Financial calculations require exact precision to prevent rounding errors that could accumulate and cause trial balance discrepancies</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Floating-point arithmetic (float64) with rounding</li>\n<li>Fixed-point decimal arithmetic using dedicated library</li>\n<li>Integer-based arithmetic storing cents/smallest currency unit</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Use fixed-point decimal arithmetic with <code>shopspring/decimal</code> library</li>\n<li><strong>Rationale</strong>: Provides exact decimal arithmetic without floating-point precision issues, supports arbitrary precision, and handles currency formatting naturally</li>\n<li><strong>Consequences</strong>: Requires explicit decimal operations instead of native arithmetic operators, but eliminates entire class of precision-related bugs</li>\n</ul>\n</blockquote>\n<p><strong>Audit Trail Unit Tests</strong></p>\n<p>Audit trail testing verifies that all changes are captured accurately and that the immutable logging system maintains integrity. These tests ensure compliance with regulatory requirements for financial record keeping.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Test Method</th>\n<th>Validation Focus</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Change Tracking</td>\n<td><code>TestTrackChanges_FieldModification</code></td>\n<td>Audit completeness</td>\n<td>Records before/after values for all modified fields</td>\n</tr>\n<tr>\n<td>Change Tracking</td>\n<td><code>TestTrackChanges_StateTransition</code></td>\n<td>Status tracking</td>\n<td>Captures state changes with user context and business reason</td>\n</tr>\n<tr>\n<td>Immutability</td>\n<td><code>TestAuditEvent_ImmutableStorage</code></td>\n<td>Data integrity</td>\n<td>Audit records cannot be modified after creation</td>\n</tr>\n<tr>\n<td>Hash Chain</td>\n<td><code>TestIntegrityRecord_HashChainValidation</code></td>\n<td>Cryptographic integrity</td>\n<td>Each record&#39;s hash correctly links to previous record</td>\n</tr>\n<tr>\n<td>User Context</td>\n<td><code>TestAuditEvent_UserMetadataCapture</code></td>\n<td>Accountability</td>\n<td>Records user ID, session, IP address, and action reason</td>\n</tr>\n<tr>\n<td>Event Querying</td>\n<td><code>TestGetEventHistory_DateRangeFilter</code></td>\n<td>Audit reporting</td>\n<td>Retrieves complete change history for specified time periods</td>\n</tr>\n</tbody></table>\n<h3 id=\"integration-testing-strategy\">Integration Testing Strategy</h3>\n<p>Integration testing verifies that components work together correctly to maintain accounting integrity throughout complete business workflows. These tests simulate real accounting scenarios from journal entry creation through financial report generation.</p>\n<p><strong>End-to-End Transaction Posting Workflow</strong></p>\n<p>The transaction posting workflow represents the most critical integration test because it touches every component in the system. Think of this test like tracing a single invoice through an entire accounting system - from initial entry through trial balance verification.</p>\n<table>\n<thead>\n<tr>\n<th>Test Scenario</th>\n<th>Components Involved</th>\n<th>Workflow Steps</th>\n<th>Verification Points</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Simple Sale Transaction</td>\n<td>Account Manager, Transaction Recorder, Balance Engine, Audit System</td>\n<td>1. Create customer and revenue accounts<br/>2. Submit journal entry (debit A/R, credit Revenue)<br/>3. Validate entry balance<br/>4. Post entry atomically<br/>5. Update running balances<br/>6. Record audit events</td>\n<td>Trial balance remains balanced<br/>Account balances updated correctly<br/>Audit trail captured completely<br/>Entry status changed to POSTED</td>\n</tr>\n<tr>\n<td>Multi-Currency Transaction</td>\n<td>Account Manager, Transaction Recorder, Balance Engine, Currency Handler</td>\n<td>1. Create USD and EUR accounts<br/>2. Submit entry with exchange rate<br/>3. Validate currency conversion<br/>4. Post with atomic transaction<br/>5. Update balances in native currencies</td>\n<td>Exchange rate applied correctly<br/>Both currency balances updated<br/>Translation audit trail recorded</td>\n</tr>\n<tr>\n<td>Complex Multi-Account Entry</td>\n<td>All components</td>\n<td>1. Create expense allocation entry<br/>2. Split expense across 5 departments<br/>3. Validate total debits = credits<br/>4. Post atomically<br/>5. Update all affected balances</td>\n<td>All 6 accounts updated correctly<br/>Trial balance maintained<br/>Partial failure triggers rollback</td>\n</tr>\n</tbody></table>\n<p><strong>Concurrent Transaction Processing</strong></p>\n<p>Modern accounting systems must handle multiple simultaneous transactions without creating inconsistencies. These integration tests verify that concurrent operations maintain data integrity through proper transaction isolation and locking.</p>\n<table>\n<thead>\n<tr>\n<th>Test Scenario</th>\n<th>Concurrency Pattern</th>\n<th>Expected Behavior</th>\n<th>Failure Conditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Simultaneous Balance Updates</td>\n<td>Multiple threads updating same account</td>\n<td>Only one update succeeds per account per transaction</td>\n<td>No lost updates or dirty reads</td>\n</tr>\n<tr>\n<td>Competing Idempotency Keys</td>\n<td>Same idempotency key from multiple clients</td>\n<td>First request processes, subsequent requests return same result</td>\n<td>No duplicate journal entries created</td>\n</tr>\n<tr>\n<td>Period Closing Race Condition</td>\n<td>Normal entry vs period closing</td>\n<td>Period closing waits for in-flight transactions</td>\n<td>No entries posted to closed periods</td>\n</tr>\n<tr>\n<td>Audit Log Contention</td>\n<td>High-volume concurrent changes</td>\n<td>All changes logged in correct order</td>\n<td>No missing audit events</td>\n</tr>\n</tbody></table>\n<p><strong>Balance Calculation Integration Tests</strong></p>\n<p>Balance calculation integration tests verify that the balance engine maintains consistency across all caching layers and calculation methods. These tests ensure that cached balances always match recalculated balances.</p>\n<table>\n<thead>\n<tr>\n<th>Test Scenario</th>\n<th>Integration Points</th>\n<th>Test Data</th>\n<th>Verification Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache Consistency Verification</td>\n<td>Balance Engine + Database + Memory Cache</td>\n<td>Post 100 random transactions</td>\n<td>Compare cached vs calculated balances for all accounts</td>\n</tr>\n<tr>\n<td>Historical Balance Accuracy</td>\n<td>Balance Engine + Transaction Recorder</td>\n<td>Post transactions across 6-month period</td>\n<td>Verify point-in-time balances match historical calculations</td>\n</tr>\n<tr>\n<td>Trial Balance Integrity</td>\n<td>Balance Engine + All Account Types</td>\n<td>Mixed asset/liability/equity/revenue/expense transactions</td>\n<td>Trial balance sums to exactly zero</td>\n</tr>\n<tr>\n<td>Multi-Currency Trial Balance</td>\n<td>Balance Engine + Currency Handler</td>\n<td>Transactions in USD, EUR, GBP</td>\n<td>Trial balance in each currency balanced separately</td>\n</tr>\n</tbody></table>\n<p><strong>Report Generation Integration Tests</strong></p>\n<p>Financial report generation tests verify that reports accurately reflect the underlying transaction data and maintain proper accounting relationships. These tests ensure that balance sheets balance and income statements tie to trial balance changes.</p>\n<table>\n<thead>\n<tr>\n<th>Report Type</th>\n<th>Integration Dependencies</th>\n<th>Test Validation</th>\n<th>Mathematical Relationships</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Trial Balance</td>\n<td>Balance Engine + Account Manager</td>\n<td>All accounts listed with correct balances</td>\n<td>Total debits = Total credits = 0</td>\n</tr>\n<tr>\n<td>Balance Sheet</td>\n<td>Trial Balance + Report Generator + Currency Handler</td>\n<td>Assets = Liabilities + Equity</td>\n<td>Fundamental accounting equation verified</td>\n</tr>\n<tr>\n<td>Income Statement</td>\n<td>Trial Balance + Period Manager</td>\n<td>Net Income calculation</td>\n<td>Revenue - Expenses = Net Income</td>\n</tr>\n<tr>\n<td>Cash Flow Statement</td>\n<td>Income Statement + Balance Sheet + Transaction Classifier</td>\n<td>Cash flow sections balanced</td>\n<td>Operating + Investing + Financing = Net Cash Change</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Testing Insight: The Trial Balance as Integration Test Oracle</strong></p>\n<p>The trial balance serves as the ultimate integration test oracle for any accounting system. If the trial balance doesn&#39;t sum to zero after any sequence of operations, the system has a fundamental integrity problem. Every integration test should verify trial balance integrity as its final assertion.</p>\n</blockquote>\n<h3 id=\"property-based-testing\">Property-Based Testing</h3>\n<p>Property-based testing uses randomly generated test data to verify that accounting invariants hold under all possible conditions. Think of this approach like stress-testing a bridge - instead of testing with known loads, you generate thousands of random load combinations to find the breaking point.</p>\n<p><strong>Accounting Invariant Verification</strong></p>\n<p>The most important properties to test are the fundamental accounting equations and relationships that must always hold true regardless of transaction volume or complexity.</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Mathematical Expression</th>\n<th>Test Generation Strategy</th>\n<th>Violation Detection</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Trial Balance Equality</td>\n<td>Σ(Debit Balances) = Σ(Credit Balances)</td>\n<td>Generate 1000+ random transactions across all account types</td>\n<td>Assert trial balance sums to zero after each transaction batch</td>\n</tr>\n<tr>\n<td>Accounting Equation</td>\n<td>Assets = Liabilities + Equity</td>\n<td>Generate mixed transaction types affecting balance sheet accounts</td>\n<td>Verify equation holds after each transaction sequence</td>\n</tr>\n<tr>\n<td>Revenue/Expense Impact</td>\n<td>Net Income = Revenue - Expenses</td>\n<td>Generate income statement transactions over random periods</td>\n<td>Verify income statement ties to equity changes</td>\n</tr>\n<tr>\n<td>Multi-Currency Consistency</td>\n<td>Trial Balance per Currency = 0</td>\n<td>Generate transactions in multiple currencies with random exchange rates</td>\n<td>Each currency trial balance sums to zero independently</td>\n</tr>\n</tbody></table>\n<p><strong>Double-Entry Enforcement Properties</strong></p>\n<p>These properties verify that the double-entry principle is maintained under all conditions, including edge cases and boundary conditions that might not be covered by traditional unit tests.</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Description</th>\n<th>Test Data Generation</th>\n<th>Expected Invariant</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entry Balance Requirement</td>\n<td>Every journal entry debits = credits</td>\n<td>Generate entries with 1-50 lines, random amounts</td>\n<td>All valid entries have balanced debits/credits</td>\n</tr>\n<tr>\n<td>Atomic Posting Guarantee</td>\n<td>Either all lines post or none post</td>\n<td>Inject failures during posting process</td>\n<td>No partially posted entries exist</td>\n</tr>\n<tr>\n<td>Balance Conservation</td>\n<td>Total system balance unchanged by internal transfers</td>\n<td>Generate transfer entries between accounts</td>\n<td>System-wide balance unchanged</td>\n</tr>\n<tr>\n<td>Historical Immutability</td>\n<td>Posted entries cannot be modified</td>\n<td>Attempt modifications to posted entries</td>\n<td>All modification attempts fail</td>\n</tr>\n</tbody></table>\n<p><strong>Performance and Scalability Properties</strong></p>\n<p>Property-based testing can also verify performance characteristics by generating workloads of varying sizes and complexity patterns.</p>\n<table>\n<thead>\n<tr>\n<th>Performance Property</th>\n<th>Measurement Target</th>\n<th>Load Generation Pattern</th>\n<th>Acceptance Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Balance Query Performance</td>\n<td>GetCurrentBalance response time</td>\n<td>Query random accounts after posting N transactions</td>\n<td>Sub-second response for N &lt; 1M transactions</td>\n</tr>\n<tr>\n<td>Concurrent Transaction Throughput</td>\n<td>Transactions per second</td>\n<td>Multiple threads posting non-conflicting entries</td>\n<td>Linear throughput scaling with thread count</td>\n</tr>\n<tr>\n<td>Report Generation Scalability</td>\n<td>Report generation time</td>\n<td>Generate reports after posting varying transaction volumes</td>\n<td>Report time grows sub-linearly with transaction count</td>\n</tr>\n<tr>\n<td>Audit Query Performance</td>\n<td>Historical query response time</td>\n<td>Random date range queries across transaction history</td>\n<td>Historical queries complete within reasonable time bounds</td>\n</tr>\n</tbody></table>\n<p><strong>Property-Based Test Implementation Strategy</strong></p>\n<p>Property-based testing requires careful design of data generators that create realistic but varied test scenarios. The generators must create valid accounting data while exploring edge cases and boundary conditions.</p>\n<table>\n<thead>\n<tr>\n<th>Generator Type</th>\n<th>Data Generation Strategy</th>\n<th>Constraints Applied</th>\n<th>Edge Cases Covered</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Account Generator</td>\n<td>Create realistic chart of accounts structure</td>\n<td>Valid account types and hierarchy relationships</td>\n<td>Deep nesting, circular reference attempts, missing parents</td>\n</tr>\n<tr>\n<td>Transaction Generator</td>\n<td>Generate valid double-entry transactions</td>\n<td>Debits must equal credits, positive amounts only</td>\n<td>Large amounts, many lines, mixed currencies</td>\n</tr>\n<tr>\n<td>Date Generator</td>\n<td>Create realistic posting date sequences</td>\n<td>Chronological order with some variation</td>\n<td>Year boundaries, leap years, timezone transitions</td>\n</tr>\n<tr>\n<td>Currency Generator</td>\n<td>Multi-currency transaction scenarios</td>\n<td>Valid currency codes, realistic exchange rates</td>\n<td>Rate fluctuations, currency pairs, conversion precision</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Property-Based Testing for Financial Invariants</strong></p>\n<ul>\n<li><strong>Context</strong>: Traditional example-based tests might miss edge cases that violate fundamental accounting principles under unusual but valid conditions</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Manual test case creation covering known scenarios</li>\n<li>Property-based testing with generated data</li>\n<li>Hybrid approach with both manual and generated tests</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Implement comprehensive property-based tests for accounting invariants while maintaining manual tests for specific business scenarios</li>\n<li><strong>Rationale</strong>: Financial systems have mathematical properties that must hold universally, making them ideal candidates for property-based verification</li>\n<li><strong>Consequences</strong>: Requires investment in test data generators and property definition, but provides much higher confidence in system correctness</li>\n</ul>\n</blockquote>\n<h3 id=\"milestone-verification-checkpoints\">Milestone Verification Checkpoints</h3>\n<p>Each development milestone requires specific testing checkpoints that verify both functional completion and accounting integrity. These checkpoints serve as gates before proceeding to the next milestone.</p>\n<p><strong>Milestone 1: Account &amp; Entry Model Verification</strong></p>\n<p>The first milestone focuses on establishing the foundational data model and basic validation rules. Testing at this stage ensures the core structures support proper accounting principles.</p>\n<table>\n<thead>\n<tr>\n<th>Verification Area</th>\n<th>Test Command</th>\n<th>Expected Output</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Account Type Validation</td>\n<td><code>go test ./internal/account -v -run TestAccountTypes</code></td>\n<td>All account types created successfully with correct normal balances</td>\n<td>ASSET/EXPENSE return DEBIT normal balance, LIABILITY/EQUITY/REVENUE return CREDIT</td>\n</tr>\n<tr>\n<td>Account Hierarchy</td>\n<td><code>go test ./internal/account -v -run TestHierarchy</code></td>\n<td>Parent-child relationships validated, circular references rejected</td>\n<td>Account trees can be created and traversed correctly</td>\n</tr>\n<tr>\n<td>Journal Entry Structure</td>\n<td><code>go test ./internal/entry -v -run TestEntryValidation</code></td>\n<td>Entry validation rules enforce double-entry principles</td>\n<td>Unbalanced entries rejected, balanced entries accepted</td>\n</tr>\n<tr>\n<td>Multi-Currency Support</td>\n<td><code>go test ./internal/money -v -run TestCurrency</code></td>\n<td>Money operations handle multiple currencies correctly</td>\n<td>Same-currency operations succeed, cross-currency operations require explicit conversion</td>\n</tr>\n</tbody></table>\n<p><strong>Milestone 1 Manual Verification Checklist:</strong></p>\n<ol>\n<li>Create chart of accounts with all five account types (Asset, Liability, Equity, Revenue, Expense)</li>\n<li>Verify account codes are unique and hierarchy is navigable</li>\n<li>Attempt to create unbalanced journal entry - should be rejected</li>\n<li>Create balanced journal entry - should be accepted but not posted</li>\n<li>Verify currency handling prevents invalid cross-currency operations</li>\n</ol>\n<p><strong>Milestone 2: Transaction Recording Verification</strong></p>\n<p>The second milestone adds atomic transaction posting with idempotency and audit trail creation. Testing verifies that transactions post completely or not at all.</p>\n<table>\n<thead>\n<tr>\n<th>Verification Area</th>\n<th>Test Command</th>\n<th>Expected Output</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Atomic Posting</td>\n<td><code>go test ./internal/transaction -v -run TestAtomicPosting</code></td>\n<td>Complete transaction success or complete rollback on failure</td>\n<td>No partially posted entries in database</td>\n</tr>\n<tr>\n<td>Idempotency</td>\n<td><code>go test ./internal/transaction -v -run TestIdempotency</code></td>\n<td>Duplicate requests return same result without side effects</td>\n<td>Same idempotency key produces identical results</td>\n</tr>\n<tr>\n<td>Entry Reversal</td>\n<td><code>go test ./internal/transaction -v -run TestReversal</code></td>\n<td>Reversal entries created correctly, original entries unchanged</td>\n<td>Reversals zero out original entries without deletion</td>\n</tr>\n<tr>\n<td>Batch Processing</td>\n<td><code>go test ./internal/transaction -v -run TestBatch</code></td>\n<td>Multiple entries posted atomically in single transaction</td>\n<td>All-or-nothing behavior for entry batches</td>\n</tr>\n</tbody></table>\n<p><strong>Milestone 2 Manual Verification Checklist:</strong></p>\n<ol>\n<li>Post simple two-line journal entry (debit Cash, credit Revenue) - verify it appears in posted status</li>\n<li>Attempt to post duplicate entry with same idempotency key - should return original result</li>\n<li>Create reversal entry for posted transaction - verify original remains and reversal offsets it</li>\n<li>Simulate database failure during posting - verify no partial entries exist</li>\n</ol>\n<p><strong>Milestone 3: Balance Calculation Verification</strong></p>\n<p>The third milestone implements efficient balance calculation with caching and point-in-time queries. Testing verifies balance accuracy and performance.</p>\n<table>\n<thead>\n<tr>\n<th>Verification Area</th>\n<th>Test Command</th>\n<th>Expected Output</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Running Balance Updates</td>\n<td><code>go test ./internal/balance -v -run TestRunningBalance</code></td>\n<td>Account balances updated correctly after each posting</td>\n<td>Cached balances match calculated balances</td>\n</tr>\n<tr>\n<td>Historical Balance Queries</td>\n<td><code>go test ./internal/balance -v -run TestHistoricalBalance</code></td>\n<td>Point-in-time balances calculated correctly</td>\n<td>Historical balances match manual calculation</td>\n</tr>\n<tr>\n<td>Trial Balance Generation</td>\n<td><code>go test ./internal/balance -v -run TestTrialBalance</code></td>\n<td>Trial balance sums to zero across all scenarios</td>\n<td>Total debits exactly equal total credits</td>\n</tr>\n<tr>\n<td>Balance Cache Performance</td>\n<td><code>go test ./internal/balance -v -run TestCachePerformance</code></td>\n<td>Balance queries return within performance thresholds</td>\n<td>Sub-second response times for typical workloads</td>\n</tr>\n</tbody></table>\n<p><strong>Milestone 3 Manual Verification Checklist:</strong></p>\n<ol>\n<li>Post several transactions and verify account balances update correctly</li>\n<li>Query balance &quot;as of&quot; historical date - should match manual calculation</li>\n<li>Generate trial balance - total debits should equal total credits exactly</li>\n<li>Verify balance cache invalidation when new transactions posted</li>\n</ol>\n<p><strong>Milestone 4: Audit Trail Verification</strong></p>\n<p>The fourth milestone adds immutable audit logging with cryptographic integrity. Testing verifies complete change tracking and tamper detection.</p>\n<table>\n<thead>\n<tr>\n<th>Verification Area</th>\n<th>Test Command</th>\n<th>Expected Output</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Change Tracking</td>\n<td><code>go test ./internal/audit -v -run TestChangeTracking</code></td>\n<td>All modifications captured with complete metadata</td>\n<td>Every change has before/after values, user context, timestamp</td>\n</tr>\n<tr>\n<td>Immutable Storage</td>\n<td><code>go test ./internal/audit -v -run TestImmutable</code></td>\n<td>Audit records cannot be modified after creation</td>\n<td>Update/delete operations on audit records fail</td>\n</tr>\n<tr>\n<td>Hash Chain Integrity</td>\n<td><code>go test ./internal/audit -v -run TestHashChain</code></td>\n<td>Cryptographic chain links all records correctly</td>\n<td>Each record&#39;s hash validates against previous record</td>\n</tr>\n<tr>\n<td>Audit Report Generation</td>\n<td><code>go test ./internal/audit -v -run TestReporting</code></td>\n<td>Complete audit trails generated for specified periods</td>\n<td>All changes within date range included in reports</td>\n</tr>\n</tbody></table>\n<p><strong>Milestone 4 Manual Verification Checklist:</strong></p>\n<ol>\n<li>Post transaction and verify audit events captured for all changes</li>\n<li>Attempt to modify audit record directly in database - should fail or be detected</li>\n<li>Generate audit report for date range - should include all relevant changes</li>\n<li>Verify hash chain integrity across sample of records</li>\n</ol>\n<p><strong>Milestone 5: Financial Reports Verification</strong></p>\n<p>The final milestone adds standard financial statement generation. Testing verifies mathematical accuracy and proper account classification.</p>\n<table>\n<thead>\n<tr>\n<th>Verification Area</th>\n<th>Test Command</th>\n<th>Expected Output</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Trial Balance Report</td>\n<td><code>go test ./internal/reports -v -run TestTrialBalance</code></td>\n<td>Trial balance lists all accounts with correct totals</td>\n<td>Report totals tie to underlying account balances</td>\n</tr>\n<tr>\n<td>Balance Sheet Generation</td>\n<td><code>go test ./internal/reports -v -run TestBalanceSheet</code></td>\n<td>Balance sheet maintains accounting equation</td>\n<td>Assets = Liabilities + Equity exactly</td>\n</tr>\n<tr>\n<td>Income Statement Accuracy</td>\n<td><code>go test ./internal/reports -v -run TestIncomeStatement</code></td>\n<td>Income statement shows period activity correctly</td>\n<td>Revenue - Expenses = Net Income calculation verified</td>\n</tr>\n<tr>\n<td>Multi-Currency Reporting</td>\n<td><code>go test ./internal/reports -v -run TestMultiCurrency</code></td>\n<td>Foreign currency amounts translated correctly</td>\n<td>Exchange rates applied consistently across all reports</td>\n</tr>\n</tbody></table>\n<p><strong>Milestone 5 Manual Verification Checklist:</strong></p>\n<ol>\n<li>Generate trial balance and verify it includes all accounts and balances correctly</li>\n<li>Generate balance sheet and verify Assets = Liabilities + Equity</li>\n<li>Generate income statement and verify net income calculation</li>\n<li>For multi-currency setup, verify currency translation in reports</li>\n</ol>\n<blockquote>\n<p><strong>Integration Checkpoint: End-to-End Scenario</strong></p>\n<p>After completing all milestones, run this comprehensive integration test:</p>\n<ol>\n<li>Set up chart of accounts for small business (20+ accounts)</li>\n<li>Post 50+ mixed transactions (sales, purchases, payments, adjustments)</li>\n<li>Generate trial balance - must sum to zero</li>\n<li>Generate balance sheet - must balance exactly</li>\n<li>Generate income statement - net income must tie to equity changes</li>\n<li>Verify complete audit trail exists for all transactions</li>\n</ol>\n<p>This scenario validates the entire system works together correctly for realistic accounting workflows.</p>\n</blockquote>\n<h3 id=\"common-testing-pitfalls\">Common Testing Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Testing with Only Balanced Data</strong></p>\n<p>Many developers only test with perfectly balanced journal entries, missing validation of the error handling paths. In real accounting systems, users frequently submit unbalanced entries that must be caught and rejected gracefully.</p>\n<p><strong>Why this is wrong:</strong> If validation logic isn&#39;t tested with invalid data, production deployments may allow unbalanced entries to be posted, corrupting the trial balance and violating fundamental accounting principles.</p>\n<p><strong>How to fix:</strong> Always include negative test cases that verify invalid entries are rejected with appropriate error messages. Test boundary conditions like entries with zero amounts, missing lines, and amounts that don&#39;t balance.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Floating-Point Precision in Tests</strong></p>\n<p>Using floating-point arithmetic in tests can cause intermittent failures when accumulated rounding errors make trial balances appear unbalanced even when the logic is correct.</p>\n<p><strong>Why this is wrong:</strong> Financial calculations require exact precision. Tests that pass sometimes and fail other times due to rounding errors mask real precision problems that could affect production calculations.</p>\n<p><strong>How to fix:</strong> Use fixed-point decimal arithmetic in all test calculations. Assert exact equality for monetary amounts rather than approximate equality. Include specific tests for precision preservation across multiple operations.</p>\n<p>⚠️ <strong>Pitfall: Not Testing Concurrent Modifications</strong></p>\n<p>Single-threaded tests miss race conditions and data consistency problems that occur when multiple transactions modify the same accounts simultaneously.</p>\n<p><strong>Why this is wrong:</strong> Production accounting systems handle concurrent users posting transactions simultaneously. Race conditions can cause lost updates, duplicate postings, or corrupted account balances.</p>\n<p><strong>How to fix:</strong> Include concurrent test scenarios where multiple goroutines post transactions affecting the same accounts. Use proper synchronization primitives and verify that final balances are correct regardless of operation ordering.</p>\n<p>⚠️ <strong>Pitfall: Missing Audit Trail Verification</strong></p>\n<p>Functional tests that only verify the final state without checking that all changes were properly logged miss compliance requirements for financial record keeping.</p>\n<p><strong>Why this is wrong:</strong> Regulatory compliance requires complete audit trails showing who made what changes when. Missing audit events can result in compliance violations and failed audits.</p>\n<p><strong>How to fix:</strong> Every test that modifies data should verify that appropriate audit events were created. Include assertions that check audit metadata like user context, timestamps, and change descriptions.</p>\n<p>⚠️ <strong>Pitfall: Testing Only Happy Path Scenarios</strong></p>\n<p>Focusing tests on successful operations without testing failure scenarios leaves error handling and recovery logic unvalidated.</p>\n<p><strong>Why this is wrong:</strong> Accounting systems must maintain integrity even when operations fail. Untested error paths may allow partial updates that corrupt the ledger state.</p>\n<p><strong>How to fix:</strong> Include failure injection tests that simulate database errors, network failures, and application crashes during critical operations. Verify that the system recovers gracefully and maintains consistency.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The testing strategy implementation requires sophisticated test infrastructure that can generate realistic accounting data while validating complex business rules. The testing code often requires as much care as the production code because incorrect tests can mask real bugs.</p>\n<p><strong>Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Testing Type</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unit Testing</td>\n<td>Go&#39;s built-in testing package with table-driven tests</td>\n<td>Testify library with rich assertions and mocking</td>\n</tr>\n<tr>\n<td>Property-Based Testing</td>\n<td>Custom generators with Go&#39;s testing/quick</td>\n<td>Gopter library with sophisticated property testing</td>\n</tr>\n<tr>\n<td>Database Testing</td>\n<td>In-memory SQLite for fast test execution</td>\n<td>Containerized PostgreSQL with test data fixtures</td>\n</tr>\n<tr>\n<td>Concurrent Testing</td>\n<td>sync package primitives with manual coordination</td>\n<td>Go&#39;s race detector with systematic concurrency testing</td>\n</tr>\n<tr>\n<td>Mock Generation</td>\n<td>Manual mocks implementing interfaces</td>\n<td>GoMock for automatic mock generation from interfaces</td>\n</tr>\n<tr>\n<td>Test Data Management</td>\n<td>JSON fixtures loaded from files</td>\n<td>Factory functions generating realistic test data</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended Test Structure</strong></p>\n<p>The test organization follows Go conventions while providing clear separation between different types of tests and test utilities.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  internal/\n    account/\n      account.go\n      account_test.go           ← unit tests for account management\n      testdata/                 ← test fixtures and sample data\n        chart_of_accounts.json\n    transaction/\n      transaction.go\n      transaction_test.go       ← unit tests for transaction posting\n      integration_test.go       ← integration tests with database\n    balance/\n      balance.go\n      balance_test.go          ← unit tests for balance calculation\n      property_test.go         ← property-based testing for invariants\n    audit/\n      audit.go\n      audit_test.go           ← unit tests for audit trail\n    reports/\n      reports.go\n      reports_test.go         ← unit tests for report generation\n      integration_test.go     ← end-to-end report testing\n  test/\n    fixtures/                 ← shared test data across packages\n      sample_transactions.json\n      test_chart_of_accounts.sql\n    helpers/                  ← shared testing utilities\n      database_helper.go      ← database setup/teardown\n      assertion_helper.go     ← custom accounting assertions\n      generator.go           ← test data generators\n    integration/             ← system-level integration tests\n      end_to_end_test.go\n      performance_test.go\n    property/                ← property-based test suites\n      accounting_invariants_test.go\n      concurrency_properties_test.go</code></pre></div>\n\n<p><strong>Test Database Infrastructure</strong></p>\n<p>Setting up isolated test databases ensures tests don&#39;t interfere with each other and can run in parallel safely.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Database test helper provides isolated database instances for testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> testhelpers</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    _ </span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#B392F0\">github.com/lib/pq</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TestDB</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DB     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Name   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    config </span><span style=\"color:#B392F0\">DatabaseConfig</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewTestDatabase creates an isolated database instance for testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewTestDatabase</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestDB</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Generate unique database name using test name and timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create new database using template or migration scripts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return TestDB instance with established connection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Register cleanup function to drop database after test</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SetupTestData loads fixture data into the test database</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestDB</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">SetupTestData</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">fixtures</span><span style=\"color:#F97583\"> ...</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Load SQL fixtures from test/fixtures directory</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Execute fixture SQL in transaction for fast cleanup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return error if any fixture loading fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AssertTrialBalanceZero verifies the fundamental accounting equation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestDB</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AssertTrialBalanceZero</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Calculate trial balance from current database state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Assert that total debits exactly equal total credits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Provide detailed error message showing imbalance if test fails</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AssertAccountBalance verifies an account has expected balance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">db </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TestDB</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AssertAccountBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">expectedBalance</span><span style=\"color:#B392F0\"> Money</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Query current account balance from database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Compare actual vs expected using exact decimal comparison</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Provide clear error message showing actual vs expected if different</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Property-Based Test Infrastructure</strong></p>\n<p>Property-based testing requires generators that create valid but varied accounting data to explore edge cases systematically.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Property-based testing for accounting invariants</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> property</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing/quick</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AccountGenerator creates realistic account structures for testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AccountGenerator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    accountTypes []</span><span style=\"color:#B392F0\">AccountType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currencies   []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxDepth     </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Generate creates a valid account for property-based testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">g </span><span style=\"color:#B392F0\">AccountGenerator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Generate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rand</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">rand</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Rand</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">size</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">reflect</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Generate valid account with random type from accountTypes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create realistic account code and name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Randomly assign currency from supported currencies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Generate parent relationship respecting maxDepth</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return reflect.Value containing generated Account</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TransactionGenerator creates balanced journal entries for testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> TransactionGenerator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    accounts      []</span><span style=\"color:#B392F0\">Account</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    maxLines      </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    currencyRates </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">decimal</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Decimal</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Generate creates a balanced journal entry for property-based testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">g </span><span style=\"color:#B392F0\">TransactionGenerator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Generate</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">rand</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">rand</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Rand</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">size</span><span style=\"color:#F97583\"> int</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">reflect</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Value</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Generate 2-maxLines entry lines with random amounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Ensure total debits exactly equal total credits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Randomly select accounts from available accounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Handle multi-currency entries using currencyRates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Return reflect.Value containing balanced JournalEntry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TestAccountingEquationInvariant verifies Assets = Liabilities + Equity always holds</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestAccountingEquationInvariant</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    property </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">transactions</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Set up clean test database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Post all generated transactions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Calculate total assets, liabilities, and equity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Return true if Assets = Liabilities + Equity exactly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Log details if equation doesn't balance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> err </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> quick.</span><span style=\"color:#B392F0\">Check</span><span style=\"color:#E1E4E8\">(property, </span><span style=\"color:#F97583\">&#x26;</span><span style=\"color:#B392F0\">quick</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Config</span><span style=\"color:#E1E4E8\">{MaxCount: </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">}); err </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Accounting equation invariant violated: </span><span style=\"color:#79B8FF\">%v</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, err)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Milestone Verification Scripts</strong></p>\n<p>Automated verification scripts provide clear checkpoints for each development milestone.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Milestone verification helper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> milestones</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Milestone1Verification checks Account &#x26; Entry Model completion</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> Milestone1Verification</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TestDB</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create accounts of each type (Asset, Liability, Equity, Revenue, Expense)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify normal balance rules work correctly for each account type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test account hierarchy creation and circular reference prevention</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create sample journal entries and verify validation rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify multi-currency money operations work correctly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.</span><span style=\"color:#B392F0\">Log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ Milestone 1: Account &#x26; Entry Model verified\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Milestone2Verification checks Transaction Recording completion</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> Milestone2Verification</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TestDB</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Post balanced journal entry and verify atomic posting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test idempotency by submitting duplicate requests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify entry reversal creates offsetting entry without deletion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test batch posting with all-or-nothing semantics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify audit events created for all posting operations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.</span><span style=\"color:#B392F0\">Log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ Milestone 2: Transaction Recording verified\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Milestone3Verification checks Balance Calculation completion</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> Milestone3Verification</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TestDB</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ctx </span><span style=\"color:#F97583\">:=</span><span style=\"color:#E1E4E8\"> context.</span><span style=\"color:#B392F0\">Background</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Post transactions and verify running balance updates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test point-in-time balance queries with historical dates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Generate trial balance and verify it sums to zero</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify balance cache consistency and invalidation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Test balance calculation performance under load</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.</span><span style=\"color:#B392F0\">Log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ Milestone 3: Balance Calculation verified\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// RunAllMilestoneVerifications executes complete system verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> RunAllMilestoneVerifications</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> NewTestDatabase</span><span style=\"color:#E1E4E8\">(t)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Cleanup</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Milestone1Verification</span><span style=\"color:#E1E4E8\">(t, db)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Milestone2Verification</span><span style=\"color:#E1E4E8\">(t, db)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Milestone3Verification</span><span style=\"color:#E1E4E8\">(t, db)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Milestone4Verification</span><span style=\"color:#E1E4E8\">(t, db) </span><span style=\"color:#6A737D\">// Audit Trail</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    Milestone5Verification</span><span style=\"color:#E1E4E8\">(t, db) </span><span style=\"color:#6A737D\">// Financial Reports</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    t.</span><span style=\"color:#B392F0\">Log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ All milestones verified successfully\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Performance Testing Infrastructure</strong></p>\n<p>Performance tests ensure the system maintains acceptable response times under realistic load conditions.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Performance testing for accounting operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> performance</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BenchmarkBalanceCalculation measures balance query performance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> BenchmarkBalanceCalculation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">b</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">B</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> setupBenchmarkDatabase</span><span style=\"color:#E1E4E8\">(b)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Cleanup</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Pre-populate database with realistic transaction volume</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Measure GetCurrentBalance performance across b.N iterations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Report operations per second and memory allocations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify performance doesn't degrade with transaction volume</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BenchmarkConcurrentPosting measures transaction throughput</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> BenchmarkConcurrentPosting</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">b</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">B</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db </span><span style=\"color:#F97583\">:=</span><span style=\"color:#B392F0\"> setupBenchmarkDatabase</span><span style=\"color:#E1E4E8\">(b)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    defer</span><span style=\"color:#E1E4E8\"> db.</span><span style=\"color:#B392F0\">Cleanup</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Create pool of worker goroutines posting transactions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Measure transactions per second under concurrent load</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Verify no race conditions or data corruption occurs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Report throughput scaling with worker count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// TestResponseTimeRequirements verifies SLA compliance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> TestResponseTimeRequirements</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">t</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">testing</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">T</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    requirements </span><span style=\"color:#F97583\">:=</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"GetCurrentBalance\"</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#79B8FF\">500</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Millisecond,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"PostTransaction\"</span><span style=\"color:#E1E4E8\">:    </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"GenerateTrialBalance\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"GenerateBalanceSheet\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> time.Second,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Execute each operation and measure response time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Assert actual time is within required threshold</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO: Report performance margins for capacity planning</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Debugging and Troubleshooting Test Failures</strong></p>\n<p>When accounting tests fail, the debugging process must consider both functional correctness and accounting integrity.</p>\n<table>\n<thead>\n<tr>\n<th>Test Failure Symptom</th>\n<th>Likely Cause</th>\n<th>Debugging Steps</th>\n<th>Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Trial Balance Doesn&#39;t Sum to Zero</td>\n<td>Unbalanced entry posted or calculation error</td>\n<td>1. Query all account balances manually<br/>2. Verify each journal entry balances<br/>3. Check for rounding errors in calculations</td>\n<td>Fix entry validation or use exact decimal arithmetic</td>\n</tr>\n<tr>\n<td>Balance Inconsistency Between Cache and Database</td>\n<td>Cache invalidation not triggered or race condition</td>\n<td>1. Compare cached vs calculated balances<br/>2. Check cache invalidation logic<br/>3. Verify transaction isolation levels</td>\n<td>Fix cache invalidation or add proper locking</td>\n</tr>\n<tr>\n<td>Audit Events Missing</td>\n<td>Change tracking not triggered or audit system failure</td>\n<td>1. Verify audit system integration points<br/>2. Check transaction boundaries include audit logging<br/>3. Test audit system independently</td>\n<td>Fix integration or audit system configuration</td>\n</tr>\n<tr>\n<td>Property-Based Test Random Failures</td>\n<td>Edge case in generated data or insufficient constraints</td>\n<td>1. Reproduce failure with specific seed value<br/>2. Examine failing test case data<br/>3. Adjust generator constraints</td>\n<td>Improve data generators or add missing validations</td>\n</tr>\n</tbody></table>\n<p>The testing strategy provides multiple layers of verification that catch different types of problems. Unit tests catch component-level bugs, integration tests find interface problems, property-based tests discover edge cases, and milestone checkpoints ensure complete functionality. This comprehensive approach provides confidence that the accounting system maintains integrity under all operating conditions.</p>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1-5 (All milestones), as debugging skills are essential throughout account modeling, transaction recording, balance calculation, audit trails, and financial reporting implementation</p>\n</blockquote>\n<p>Debugging a double-entry ledger system requires systematic approaches that respect the fundamental accounting principle that books must always balance. Think of debugging an accounting system like being a forensic accountant - every discrepancy has a root cause that can be traced through the audit trail, and every fix must maintain the mathematical integrity of the entire ledger. Unlike typical software bugs that might affect individual features, accounting system bugs can compound over time and create cascading inconsistencies that undermine the entire system&#39;s reliability.</p>\n<p>The complexity of double-entry bookkeeping debugging stems from the interconnected nature of accounts, where a single incorrect journal entry can affect multiple account balances, trial balance validity, and financial report accuracy. Moreover, the immutable nature of posted transactions means that fixes often require compensating entries rather than direct corrections, making debugging both a technical and an accounting exercise.</p>\n<p>This guide provides systematic troubleshooting approaches for the four most critical categories of ledger system problems: balance discrepancies, unbalanced entries, performance issues, and audit trail corruption. Each category includes specific symptoms, root cause analysis techniques, and step-by-step resolution procedures that maintain accounting integrity while resolving technical issues.</p>\n<h3 id=\"balance-discrepancy-diagnosis\">Balance Discrepancy Diagnosis</h3>\n<p><strong>Balance discrepancies</strong> occur when calculated account balances don&#39;t match expected values, often manifesting as trial balance variances or account reconciliation failures. Think of balance discrepancies like finding that your bank statement doesn&#39;t match your checkbook register - there&#39;s always a specific transaction or calculation error that caused the difference, and systematic investigation can identify and resolve it.</p>\n<p>The challenge with balance discrepancies in a cached system is determining whether the problem lies in the underlying transaction data, the balance calculation logic, or the caching mechanism itself. A discrepancy could stem from a single incorrect journal entry, a bug in the running balance maintenance, cache corruption, or even timing issues in concurrent transaction processing.</p>\n<blockquote>\n<p><strong>Critical Insight:</strong> Balance discrepancies in double-entry systems often indicate deeper problems than just calculation errors. They can reveal issues with transaction atomicity, cache coherence, or even data corruption that could affect the entire ledger&#39;s integrity.</p>\n</blockquote>\n<p>The diagnostic approach follows a systematic elimination process, starting with the most fundamental checks and progressively drilling down to specific components. This methodical approach ensures that fixes address root causes rather than symptoms, preventing the same discrepancies from recurring.</p>\n<h4 id=\"systematic-balance-investigation-process\">Systematic Balance Investigation Process</h4>\n<p>The balance discrepancy investigation follows a structured approach that isolates the problem source through progressive validation checks. This process ensures comprehensive coverage while minimizing the time spent on incorrect assumptions.</p>\n<p><strong>Phase 1: Fundamental Validation</strong></p>\n<ol>\n<li><p><strong>Trial Balance Verification</strong>: Execute <code>GetTrialBalance()</code> to verify that total debits equal total credits across the entire ledger. If the trial balance doesn&#39;t sum to zero, the discrepancy affects the fundamental accounting equation and indicates a serious systematic issue.</p>\n</li>\n<li><p><strong>Account Type Consistency</strong>: Verify that all accounts involved in the discrepancy have their normal balance sides correctly configured. Asset and expense accounts should be debit-normal, while liability, equity, and revenue accounts should be credit-normal.</p>\n</li>\n<li><p><strong>Transaction Completeness</strong>: Check that all journal entries affecting the account are in <code>POSTED</code> status and none are stuck in <code>DRAFT</code> state, which would exclude them from balance calculations but might be expected in manual reconciliations.</p>\n</li>\n<li><p><strong>Date Range Validation</strong>: Confirm that balance calculations include the correct date range, especially for point-in-time queries that might exclude transactions posted after the query date.</p>\n</li>\n</ol>\n<p><strong>Phase 2: Data Integrity Verification</strong>\n5. <strong>Entry Line Validation</strong>: Query all <code>EntryLine</code> records for the affected account and verify that each line has either a <code>DebitAmount</code> or <code>CreditAmount</code> (but not both) and that all amounts are positive values.</p>\n<ol start=\"6\">\n<li><p><strong>Orphaned Record Detection</strong>: Check for <code>EntryLine</code> records that reference non-existent journal entries or accounts, which could cause balance calculation errors.</p>\n</li>\n<li><p><strong>Currency Consistency</strong>: For multi-currency environments, verify that all transactions for an account use the same currency and that exchange rate conversions are applied consistently.</p>\n</li>\n</ol>\n<p><strong>Phase 3: Calculation Logic Testing</strong>\n8. <strong>Manual Recalculation</strong>: Perform a manual balance calculation by summing all debit and credit amounts from the entry lines table and compare with the cached balance.</p>\n<ol start=\"9\">\n<li><p><strong>Running Balance Trace</strong>: Compare the <code>RunningBalance</code> table values with fresh calculations to identify when the divergence first occurred.</p>\n</li>\n<li><p><strong>Concurrent Access Impact</strong>: Check for timing issues where balance updates might have been applied out of order due to concurrent transaction processing.</p>\n</li>\n</ol>\n<h4 id=\"common-balance-discrepancy-patterns\">Common Balance Discrepancy Patterns</h4>\n<p>Different types of balance discrepancies follow predictable patterns that help identify the root cause more quickly. Understanding these patterns allows for targeted diagnostic approaches rather than exhaustive investigation.</p>\n<table>\n<thead>\n<tr>\n<th>Discrepancy Pattern</th>\n<th>Likely Root Cause</th>\n<th>Diagnostic Approach</th>\n<th>Typical Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single account off by exact transaction amount</td>\n<td>Missing or duplicate journal entry line</td>\n<td>Query entry lines for specific amount and date range</td>\n<td>Post correction entry or identify duplicate</td>\n</tr>\n<tr>\n<td>Multiple accounts off by same amount</td>\n<td>Unbalanced journal entry was posted</td>\n<td>Check recent entries for debit/credit imbalance</td>\n<td>Reverse entry and repost balanced version</td>\n</tr>\n<tr>\n<td>All account balances doubled</td>\n<td>Running balance updated twice for same entry</td>\n<td>Check audit log for duplicate balance updates</td>\n<td>Refresh all running balances from entry history</td>\n</tr>\n<tr>\n<td>Random small variances across accounts</td>\n<td>Floating-point precision errors</td>\n<td>Check for decimal vs float data types</td>\n<td>Convert to fixed-point decimal arithmetic</td>\n</tr>\n<tr>\n<td>Systematic variance in one account type</td>\n<td>Account type normal balance logic error</td>\n<td>Test balance calculation for asset vs liability accounts</td>\n<td>Fix account type handling in balance engine</td>\n</tr>\n<tr>\n<td>Discrepancy appeared after specific date</td>\n<td>Cache invalidation failure</td>\n<td>Compare cached vs calculated balances after that date</td>\n<td>Rebuild affected cache entries</td>\n</tr>\n</tbody></table>\n<h4 id=\"balance-debugging-workflow-tables\">Balance Debugging Workflow Tables</h4>\n<p>The following tables provide structured workflows for diagnosing specific balance discrepancy scenarios, ensuring comprehensive investigation while minimizing diagnostic time.</p>\n<p><strong>Cache vs Database Balance Validation</strong></p>\n<table>\n<thead>\n<tr>\n<th>Validation Step</th>\n<th>Database Query</th>\n<th>Expected Result</th>\n<th>Action if Mismatch</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Current balance cache</td>\n<td><code>SELECT CurrentBalance FROM RunningBalance WHERE AccountID = ?</code></td>\n<td>Matches expected balance</td>\n<td>Continue to next step</td>\n</tr>\n<tr>\n<td>Raw entry line sum</td>\n<td><code>SELECT SUM(DebitAmount) - SUM(CreditAmount) FROM EntryLine WHERE AccountID = ?</code></td>\n<td>Matches cache value</td>\n<td>Cache is correct, check calculation logic</td>\n</tr>\n<tr>\n<td>Posted entries only</td>\n<td>Add <code>JOIN JournalEntry ON Status = &#39;POSTED&#39;</code> to above query</td>\n<td>Matches posted balance expectation</td>\n<td>Include only posted entries in balance</td>\n</tr>\n<tr>\n<td>Date-filtered balance</td>\n<td>Add <code>WHERE PostedAt &lt;= ?</code> to entry query</td>\n<td>Matches point-in-time expectation</td>\n<td>Verify date filter logic</td>\n</tr>\n<tr>\n<td>Account type sign adjustment</td>\n<td>Apply normal balance multiplier to sum</td>\n<td>Matches business expectation</td>\n<td>Check account type configuration</td>\n</tr>\n</tbody></table>\n<p><strong>Multi-Currency Balance Validation</strong></p>\n<table>\n<thead>\n<tr>\n<th>Currency Scenario</th>\n<th>Validation Check</th>\n<th>Expected Behavior</th>\n<th>Common Issues</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single currency account</td>\n<td>All entry lines have same currency as account</td>\n<td>Currency consistency maintained</td>\n<td>Mixed currencies in single account</td>\n</tr>\n<tr>\n<td>Currency conversion</td>\n<td>Exchange rates applied at transaction date</td>\n<td>Converted amounts stored correctly</td>\n<td>Missing or incorrect exchange rates</td>\n</tr>\n<tr>\n<td>Presentation currency</td>\n<td>Foreign balances converted for reporting</td>\n<td>Consistent exchange rate methodology</td>\n<td>Rate lookup failures or inconsistencies</td>\n</tr>\n<tr>\n<td>Historical rates</td>\n<td>Point-in-time queries use period-appropriate rates</td>\n<td>Historical accuracy maintained</td>\n<td>Using current rates for historical queries</td>\n</tr>\n</tbody></table>\n<p><strong>Concurrent Transaction Impact Analysis</strong></p>\n<table>\n<thead>\n<tr>\n<th>Concurrency Issue</th>\n<th>Symptom</th>\n<th>Detection Method</th>\n<th>Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Lost balance update</td>\n<td>Balance unchanged after posting</td>\n<td>Check balance update audit trail</td>\n<td>Retry balance calculation with locking</td>\n</tr>\n<tr>\n<td>Out-of-order processing</td>\n<td>Balance reflects later entry before earlier</td>\n<td>Compare entry posting sequence with balance updates</td>\n<td>Implement sequential balance updates</td>\n</tr>\n<tr>\n<td>Deadlock recovery</td>\n<td>Some transactions rolled back</td>\n<td>Check database deadlock logs</td>\n<td>Retry failed transactions</td>\n</tr>\n<tr>\n<td>Cache race condition</td>\n<td>Cached balance inconsistent with database</td>\n<td>Compare cache and database timestamps</td>\n<td>Implement cache locking or versioning</td>\n</tr>\n</tbody></table>\n<h3 id=\"unbalanced-entry-detection\">Unbalanced Entry Detection</h3>\n<p><strong>Unbalanced entries</strong> violate the fundamental principle of double-entry bookkeeping where total debits must equal total credits. Think of unbalanced entries like a seesaw that doesn&#39;t balance - the accounting equation becomes mathematically impossible, and the error propagates through trial balances and financial reports. Unlike balance discrepancies which might be calculation errors, unbalanced entries represent data corruption that undermines the entire ledger&#39;s integrity.</p>\n<p>The challenge with unbalanced entry detection is that the system should prevent these entries from being posted in the first place, so their presence indicates either validation bypass, data corruption after posting, or systematic bugs in the transaction recording engine. Detecting and resolving unbalanced entries requires both immediate correction and investigation of how the validation was circumvented.</p>\n<blockquote>\n<p><strong>Design Principle:</strong> The ledger system must be designed with fail-safe mechanisms that make unbalanced entries mathematically impossible to post, not just unlikely. If unbalanced entries exist, they represent a critical system failure that requires immediate attention.</p>\n</blockquote>\n<p>The diagnostic approach focuses on identifying not just the unbalanced entries themselves, but the systematic failure that allowed them to be created. This investigation prevents future occurrences while correcting the immediate data integrity issues.</p>\n<h4 id=\"unbalanced-entry-detection-algorithms\">Unbalanced Entry Detection Algorithms</h4>\n<p>The detection process uses multiple validation approaches to ensure comprehensive coverage and identify subtle imbalances that might not be immediately obvious. Each detection method serves a specific purpose in the overall validation strategy.</p>\n<p><strong>Primary Detection Methods:</strong></p>\n<ol>\n<li><p><strong>Entry-Level Balance Validation</strong>: For each journal entry, verify that the sum of all debit amounts equals the sum of all credit amounts within the same currency.</p>\n</li>\n<li><p><strong>Trial Balance Variance Detection</strong>: Calculate the total debit and credit amounts across all posted entries. Any non-zero variance indicates systematic unbalanced entries.</p>\n</li>\n<li><p><strong>Account-Level Impact Analysis</strong>: For accounts showing unexpected balances, trace back to identify which specific journal entries contributed to the variance.</p>\n</li>\n<li><p><strong>Periodic Reconciliation Scans</strong>: Run comprehensive validation across all entries posted within specific date ranges to identify when imbalances first appeared.</p>\n</li>\n</ol>\n<p><strong>Advanced Detection Techniques:</strong>\n5. <strong>Cross-Currency Validation</strong>: For multi-currency entries, verify that the exchange rates and conversion amounts maintain balance when converted to a common currency.</p>\n<ol start=\"6\">\n<li><p><strong>Rounding Error Accumulation</strong>: Identify cases where multiple small rounding errors have accumulated into significant imbalances over time.</p>\n</li>\n<li><p><strong>Audit Trail Correlation</strong>: Compare the original entry amounts recorded in audit logs with current database values to detect post-posting modifications.</p>\n</li>\n</ol>\n<h4 id=\"systematic-unbalanced-entry-investigation\">Systematic Unbalanced Entry Investigation</h4>\n<p>The investigation follows a structured approach that identifies both the immediate problem entries and the systematic issues that allowed them to exist.</p>\n<p><strong>Investigation Phase 1: Immediate Detection</strong></p>\n<table>\n<thead>\n<tr>\n<th>Detection Query</th>\n<th>Purpose</th>\n<th>Expected Result</th>\n<th>Action if Failed</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SELECT EntryID, SUM(DebitAmount) - SUM(CreditAmount) AS Variance FROM EntryLine GROUP BY EntryID HAVING Variance != 0</code></td>\n<td>Find unbalanced journal entries</td>\n<td>Zero results</td>\n<td>List all unbalanced entries for correction</td>\n</tr>\n<tr>\n<td><code>SELECT SUM(DebitAmount) - SUM(CreditAmount) AS SystemVariance FROM EntryLine JOIN JournalEntry ON Status = &#39;POSTED&#39;</code></td>\n<td>Check overall system balance</td>\n<td>Zero variance</td>\n<td>Calculate total system imbalance</td>\n</tr>\n<tr>\n<td><code>SELECT AccountID, SUM(CASE WHEN DebitAmount IS NOT NULL THEN DebitAmount ELSE -CreditAmount END) AS AccountVariance FROM EntryLine GROUP BY AccountID</code></td>\n<td>Identify affected accounts</td>\n<td>All account totals reasonable</td>\n<td>Highlight accounts with unexpected balances</td>\n</tr>\n</tbody></table>\n<p><strong>Investigation Phase 2: Root Cause Analysis</strong></p>\n<table>\n<thead>\n<tr>\n<th>Root Cause Category</th>\n<th>Investigation Method</th>\n<th>Evidence to Collect</th>\n<th>Resolution Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Validation bypass</td>\n<td>Check audit logs for entries that skipped validation</td>\n<td>Entry creation without validation events</td>\n<td>Strengthen validation enforcement</td>\n</tr>\n<tr>\n<td>Concurrent processing race</td>\n<td>Analyze entry posting timestamps and sequence</td>\n<td>Overlapping posting times for related entries</td>\n<td>Implement serialized posting</td>\n</tr>\n<tr>\n<td>Data corruption</td>\n<td>Compare audit trail with current data</td>\n<td>Differences between original and current amounts</td>\n<td>Restore from audit trail or backup</td>\n</tr>\n<tr>\n<td>Currency conversion errors</td>\n<td>Check exchange rate applications</td>\n<td>Inconsistent conversion calculations</td>\n<td>Recalculate with correct rates</td>\n</tr>\n<tr>\n<td>System bug in posting logic</td>\n<td>Review recent code changes and deployment logs</td>\n<td>Correlation between deployment and unbalanced entries</td>\n<td>Rollback or hotfix deployment</td>\n</tr>\n</tbody></table>\n<p><strong>Investigation Phase 3: Impact Assessment</strong></p>\n<p>The impact assessment determines how unbalanced entries have affected downstream systems and reports, enabling comprehensive correction planning.</p>\n<table>\n<thead>\n<tr>\n<th>Impact Category</th>\n<th>Assessment Method</th>\n<th>Measurement Criteria</th>\n<th>Correction Priority</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Trial Balance Accuracy</td>\n<td>Calculate trial balance variance</td>\n<td>Total system debit/credit difference</td>\n<td>Critical - affects all reports</td>\n</tr>\n<tr>\n<td>Financial Report Reliability</td>\n<td>Regenerate key reports and compare with previous versions</td>\n<td>Variance in report totals</td>\n<td>High - affects management decisions</td>\n</tr>\n<tr>\n<td>Account Balance Integrity</td>\n<td>Recalculate all affected account balances</td>\n<td>Number of accounts with incorrect balances</td>\n<td>High - affects reconciliation</td>\n</tr>\n<tr>\n<td>Regulatory Compliance</td>\n<td>Review audit requirements for balanced entries</td>\n<td>Compliance violation severity</td>\n<td>Critical - may require disclosure</td>\n</tr>\n<tr>\n<td>User Confidence</td>\n<td>Assess user-reported discrepancies</td>\n<td>Correlation with unbalanced entries</td>\n<td>Medium - affects system adoption</td>\n</tr>\n</tbody></table>\n<h4 id=\"unbalanced-entry-correction-procedures\">Unbalanced Entry Correction Procedures</h4>\n<p>Correcting unbalanced entries requires careful consideration of audit trail preservation and regulatory compliance. The correction approach depends on the entry age, impact scope, and business context.</p>\n<p><strong>Correction Decision Matrix:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Entry Age</th>\n<th>Impact Scope</th>\n<th>Correction Method</th>\n<th>Regulatory Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Current period, not reported</td>\n<td>Single account</td>\n<td>Direct correction entry</td>\n<td>Minimal disclosure required</td>\n</tr>\n<tr>\n<td>Current period, already reported</td>\n<td>Multiple accounts</td>\n<td>Correction entry with full audit trail</td>\n<td>May require report restatement</td>\n</tr>\n<tr>\n<td>Prior period, closed</td>\n<td>System-wide impact</td>\n<td>Prior period adjustment entry</td>\n<td>Requires auditor consultation</td>\n</tr>\n<tr>\n<td>Historical, multiple periods</td>\n<td>Regulatory filings affected</td>\n<td>Formal restatement process</td>\n<td>SEC/regulatory body notification</td>\n</tr>\n</tbody></table>\n<p><strong>Step-by-Step Correction Process:</strong></p>\n<ol>\n<li><p><strong>Preserve Evidence</strong>: Create complete backup of current unbalanced entries and related audit records before any corrections.</p>\n</li>\n<li><p><strong>Calculate Correction Amount</strong>: Determine the exact debit/credit adjustment needed to balance each entry.</p>\n</li>\n<li><p><strong>Identify Correction Accounts</strong>: Choose appropriate accounts for the balancing adjustment, typically involving suspense accounts for unknown differences.</p>\n</li>\n<li><p><strong>Create Correction Entries</strong>: Post new journal entries that exactly offset the imbalances while maintaining proper audit trail.</p>\n</li>\n<li><p><strong>Verify Correction Impact</strong>: Recalculate trial balance and affected account balances to confirm correction effectiveness.</p>\n</li>\n<li><p><strong>Document Resolution</strong>: Record complete documentation of the problem, investigation, and correction for audit purposes.</p>\n</li>\n</ol>\n<h4 id=\"preventing-future-unbalanced-entries\">Preventing Future Unbalanced Entries</h4>\n<p>Prevention requires both technical controls and process improvements that make unbalanced entries mathematically impossible to create.</p>\n<p><strong>Technical Prevention Measures:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Prevention Layer</th>\n<th>Implementation Method</th>\n<th>Effectiveness Level</th>\n<th>Maintenance Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database constraints</td>\n<td>Check constraints on entry line totals</td>\n<td>High for direct database modifications</td>\n<td>Update constraints with schema changes</td>\n</tr>\n<tr>\n<td>Application validation</td>\n<td>Pre-posting balance validation in transaction engine</td>\n<td>High for normal application flow</td>\n<td>Test validation with every code change</td>\n</tr>\n<tr>\n<td>API request validation</td>\n<td>JSON schema validation for entry creation requests</td>\n<td>Medium for API-based entries</td>\n<td>Update schemas with business rule changes</td>\n</tr>\n<tr>\n<td>Concurrent access control</td>\n<td>Database transaction isolation and locking</td>\n<td>Medium for high-concurrency scenarios</td>\n<td>Monitor deadlock rates and adjust isolation levels</td>\n</tr>\n</tbody></table>\n<p><strong>Process Prevention Measures:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Process Control</th>\n<th>Implementation</th>\n<th>Monitoring Method</th>\n<th>Effectiveness Indicator</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Automated validation</td>\n<td>Run trial balance checks after every posting batch</td>\n<td>Daily automated reports</td>\n<td>Zero unbalanced entries detected</td>\n</tr>\n<tr>\n<td>Manual review workflows</td>\n<td>Require manager approval for large or unusual entries</td>\n<td>Approval audit trail</td>\n<td>Reduced error rates in approved entries</td>\n</tr>\n<tr>\n<td>Periodic reconciliation</td>\n<td>Monthly account balance reconciliation</td>\n<td>Variance reporting</td>\n<td>Early detection of systematic issues</td>\n</tr>\n<tr>\n<td>System health monitoring</td>\n<td>Real-time alerts for trial balance variance</td>\n<td>Automated alert system</td>\n<td>Immediate notification of problems</td>\n</tr>\n</tbody></table>\n<h3 id=\"performance-problem-diagnosis\">Performance Problem Diagnosis</h3>\n<p><strong>Performance problems</strong> in ledger systems typically manifest as slow balance calculations or delayed report generation, often becoming more severe as transaction volume grows. Think of performance debugging like diagnosing why a busy restaurant is serving meals slowly - the bottleneck could be in the kitchen (database), the waitstaff (application logic), or the ordering system (user interface), and systematic measurement is needed to identify the actual constraint.</p>\n<p>Ledger system performance is particularly challenging because balance calculations often require scanning historical transaction data, and the cached balance optimization introduces additional complexity around cache invalidation and consistency. Performance problems can compound over time as data volume grows, making early detection and resolution critical for long-term system viability.</p>\n<blockquote>\n<p><strong>Performance Principle:</strong> Accounting system performance must be predictable and consistent. Users cannot accept that &quot;month-end closing might be slow&quot; because financial reporting has hard deadlines that cannot be moved for technical convenience.</p>\n</blockquote>\n<p>The diagnostic approach focuses on measuring actual performance bottlenecks rather than optimizing based on assumptions, using systematic profiling to identify where time is actually being spent in the system.</p>\n<h4 id=\"performance-measurement-framework\">Performance Measurement Framework</h4>\n<p>Effective performance diagnosis requires comprehensive instrumentation that measures all significant operations and their dependencies. The measurement framework provides visibility into both user-facing performance and internal system efficiency.</p>\n<p><strong>Key Performance Indicators (KPIs):</strong></p>\n<table>\n<thead>\n<tr>\n<th>Metric Category</th>\n<th>Specific Measurements</th>\n<th>Target Performance</th>\n<th>Alert Threshold</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Balance Calculation</td>\n<td>Current balance query response time</td>\n<td>&lt; 100ms</td>\n<td>&gt; 500ms</td>\n</tr>\n<tr>\n<td>Point-in-Time Queries</td>\n<td>Historical balance calculation time</td>\n<td>&lt; 1 second</td>\n<td>&gt; 5 seconds</td>\n</tr>\n<tr>\n<td>Trial Balance Generation</td>\n<td>Complete trial balance creation time</td>\n<td>&lt; 10 seconds</td>\n<td>&gt; 30 seconds</td>\n</tr>\n<tr>\n<td>Journal Entry Posting</td>\n<td>Single entry posting time including balance updates</td>\n<td>&lt; 200ms</td>\n<td>&gt; 1 second</td>\n</tr>\n<tr>\n<td>Batch Processing</td>\n<td>Entries posted per second in batch mode</td>\n<td>&gt; 100 entries/second</td>\n<td>&lt; 50 entries/second</td>\n</tr>\n<tr>\n<td>Cache Performance</td>\n<td>Cache hit rate for balance queries</td>\n<td>&gt; 90%</td>\n<td>&lt; 75%</td>\n</tr>\n<tr>\n<td>Database Query Performance</td>\n<td>Average query execution time</td>\n<td>&lt; 50ms</td>\n<td>&gt; 200ms</td>\n</tr>\n<tr>\n<td>Report Generation</td>\n<td>Financial report creation time</td>\n<td>&lt; 30 seconds</td>\n<td>&gt; 2 minutes</td>\n</tr>\n</tbody></table>\n<p><strong>Performance Monitoring Implementation:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Monitoring Level</th>\n<th>Data Collected</th>\n<th>Collection Method</th>\n<th>Analysis Frequency</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Application metrics</td>\n<td>Response times, throughput, error rates</td>\n<td>Application performance monitoring (APM)</td>\n<td>Real-time</td>\n</tr>\n<tr>\n<td>Database performance</td>\n<td>Query execution plans, index usage, lock contention</td>\n<td>Database monitoring tools</td>\n<td>Continuous</td>\n</tr>\n<tr>\n<td>System resources</td>\n<td>CPU, memory, disk I/O, network utilization</td>\n<td>System monitoring</td>\n<td>Every minute</td>\n</tr>\n<tr>\n<td>User experience</td>\n<td>Page load times, API response times</td>\n<td>Front-end monitoring</td>\n<td>Real-time</td>\n</tr>\n<tr>\n<td>Business metrics</td>\n<td>Entries processed, reports generated, users active</td>\n<td>Business intelligence dashboards</td>\n<td>Hourly</td>\n</tr>\n</tbody></table>\n<h4 id=\"common-performance-bottlenecks\">Common Performance Bottlenecks</h4>\n<p>Ledger systems exhibit predictable performance bottleneck patterns that can be systematically identified and resolved. Understanding these patterns enables targeted optimization rather than general performance tuning.</p>\n<p><strong>Database Query Performance Issues:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Bottleneck Pattern</th>\n<th>Symptoms</th>\n<th>Root Cause</th>\n<th>Optimization Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Full table scans on entry lines</td>\n<td>Balance calculations become slower as data grows</td>\n<td>Missing indexes on AccountID, PostedAt columns</td>\n<td>Add composite indexes for common query patterns</td>\n</tr>\n<tr>\n<td>Sequential scan for date ranges</td>\n<td>Point-in-time queries timeout on large datasets</td>\n<td>No index on PostedAt column</td>\n<td>Create index on (AccountID, PostedAt) for historical queries</td>\n</tr>\n<tr>\n<td>Cache invalidation storms</td>\n<td>Sudden performance degradation after posting</td>\n<td>Too many cache entries invalidated simultaneously</td>\n<td>Implement selective cache invalidation</td>\n</tr>\n<tr>\n<td>Lock contention on running balances</td>\n<td>Concurrent postings slow down or deadlock</td>\n<td>Multiple transactions updating same account balance</td>\n<td>Use optimistic concurrency control with versioning</td>\n</tr>\n<tr>\n<td>Unoptimized trial balance queries</td>\n<td>Trial balance generation takes minutes</td>\n<td>Query joins all tables without proper indexing</td>\n<td>Create materialized view or optimize join strategy</td>\n</tr>\n</tbody></table>\n<p><strong>Application Logic Performance Issues:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Performance Problem</th>\n<th>Observable Behavior</th>\n<th>Technical Cause</th>\n<th>Solution Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>N+1 query problem</td>\n<td>Balance queries multiply with account count</td>\n<td>Separate database query for each account</td>\n<td>Batch query all accounts in single database round-trip</td>\n</tr>\n<tr>\n<td>Memory leak in balance calculations</td>\n<td>Performance degrades over time, memory usage grows</td>\n<td>Objects not properly garbage collected</td>\n<td>Profile memory usage and fix object lifecycle</td>\n</tr>\n<tr>\n<td>Inefficient currency conversion</td>\n<td>Multi-currency reports extremely slow</td>\n<td>Exchange rate lookup for every transaction</td>\n<td>Cache exchange rates and batch conversions</td>\n</tr>\n<tr>\n<td>Redundant validation</td>\n<td>Entry posting slower than expected</td>\n<td>Same validation rules executed multiple times</td>\n<td>Optimize validation pipeline to eliminate redundancy</td>\n</tr>\n<tr>\n<td>Cache thrashing</td>\n<td>Cache hit rate low despite high query volume</td>\n<td>Cache size too small or poor eviction policy</td>\n<td>Tune cache size and implement smarter eviction</td>\n</tr>\n</tbody></table>\n<h4 id=\"systematic-performance-investigation-process\">Systematic Performance Investigation Process</h4>\n<p>The performance investigation follows a structured approach that identifies actual bottlenecks through measurement rather than assumption, ensuring optimization efforts target the real performance constraints.</p>\n<p><strong>Phase 1: Performance Baseline Establishment</strong></p>\n<table>\n<thead>\n<tr>\n<th>Measurement Activity</th>\n<th>Data Collection Method</th>\n<th>Baseline Criteria</th>\n<th>Analysis Focus</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Current state profiling</td>\n<td>Run performance test suite with typical data volume</td>\n<td>Record all timing measurements</td>\n<td>Identify slowest operations</td>\n</tr>\n<tr>\n<td>Database query analysis</td>\n<td>Enable query logging and analyze execution plans</td>\n<td>Identify queries taking &gt; 100ms</td>\n<td>Find missing indexes or inefficient joins</td>\n</tr>\n<tr>\n<td>Resource utilization monitoring</td>\n<td>Collect CPU, memory, disk I/O metrics during load test</td>\n<td>Identify resource constraints</td>\n<td>Find system bottlenecks</td>\n</tr>\n<tr>\n<td>Cache effectiveness analysis</td>\n<td>Measure cache hit/miss rates for all cached data</td>\n<td>Target &gt; 90% hit rate for balance queries</td>\n<td>Optimize cache size and eviction policy</td>\n</tr>\n</tbody></table>\n<p><strong>Phase 2: Load Testing and Bottleneck Identification</strong></p>\n<table>\n<thead>\n<tr>\n<th>Load Test Scenario</th>\n<th>Simulated Workload</th>\n<th>Expected Performance</th>\n<th>Failure Indicators</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Steady-state operations</td>\n<td>Normal transaction posting and balance queries</td>\n<td>Consistent sub-second response times</td>\n<td>Response time degradation over time</td>\n</tr>\n<tr>\n<td>Peak load simulation</td>\n<td>Month-end closing with high transaction volume</td>\n<td>Graceful performance degradation</td>\n<td>System becomes unresponsive</td>\n</tr>\n<tr>\n<td>Concurrent user testing</td>\n<td>Multiple users accessing different accounts</td>\n<td>Linear performance scaling</td>\n<td>Deadlocks or lock contention</td>\n</tr>\n<tr>\n<td>Large dataset testing</td>\n<td>Historical data spanning multiple years</td>\n<td>Predictable query performance</td>\n<td>Exponential query time growth</td>\n</tr>\n<tr>\n<td>Report generation load</td>\n<td>Multiple simultaneous financial reports</td>\n<td>Reasonable resource utilization</td>\n<td>Memory exhaustion or CPU saturation</td>\n</tr>\n</tbody></table>\n<p><strong>Phase 3: Optimization Implementation and Validation</strong></p>\n<p>The optimization phase implements targeted fixes based on identified bottlenecks and validates their effectiveness through controlled testing.</p>\n<table>\n<thead>\n<tr>\n<th>Optimization Category</th>\n<th>Implementation Strategy</th>\n<th>Validation Method</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Database optimization</td>\n<td>Add indexes, optimize queries, tune database configuration</td>\n<td>Before/after performance comparison</td>\n<td>Measurable query time improvement</td>\n</tr>\n<tr>\n<td>Caching improvements</td>\n<td>Implement smarter caching strategies, tune cache sizes</td>\n<td>Cache hit rate monitoring</td>\n<td>Increased hit rate and faster response times</td>\n</tr>\n<tr>\n<td>Application logic optimization</td>\n<td>Refactor inefficient code, eliminate redundant processing</td>\n<td>Code profiling and timing analysis</td>\n<td>Reduced CPU usage and faster execution</td>\n</tr>\n<tr>\n<td>Concurrency improvements</td>\n<td>Implement optimistic locking, reduce critical sections</td>\n<td>Concurrent load testing</td>\n<td>Improved throughput under concurrent load</td>\n</tr>\n<tr>\n<td>Resource scaling</td>\n<td>Increase hardware resources or scale horizontally</td>\n<td>Load testing with increased resources</td>\n<td>Linear performance improvement with resources</td>\n</tr>\n</tbody></table>\n<h4 id=\"performance-debugging-tools-and-techniques\">Performance Debugging Tools and Techniques</h4>\n<p>Effective performance debugging requires specialized tools and techniques tailored to the specific characteristics of accounting systems.</p>\n<p><strong>Database Performance Analysis Tools:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Database System</th>\n<th>Profiling Tools</th>\n<th>Key Metrics</th>\n<th>Analysis Focus</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PostgreSQL</td>\n<td>pg_stat_statements, EXPLAIN ANALYZE</td>\n<td>Query execution time, index usage, lock waits</td>\n<td>Slow query identification and optimization</td>\n</tr>\n<tr>\n<td>MySQL</td>\n<td>Performance Schema, slow query log</td>\n<td>Query performance, connection usage</td>\n<td>Query optimization and connection pooling</td>\n</tr>\n<tr>\n<td>SQL Server</td>\n<td>SQL Profiler, Query Store</td>\n<td>Execution plans, wait statistics</td>\n<td>Index optimization and query tuning</td>\n</tr>\n<tr>\n<td>General approach</td>\n<td>Application-level query logging</td>\n<td>Query frequency, response time distribution</td>\n<td>Application-level query optimization</td>\n</tr>\n</tbody></table>\n<p><strong>Application Performance Profiling:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Language/Platform</th>\n<th>Profiling Tools</th>\n<th>Measurement Focus</th>\n<th>Optimization Targets</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Go</td>\n<td>go tool pprof, go-torch</td>\n<td>CPU usage, memory allocation, goroutine contention</td>\n<td>Algorithm efficiency, memory management</td>\n</tr>\n<tr>\n<td>Java</td>\n<td>JProfiler, YourKit, JVM built-in tools</td>\n<td>Method execution time, object allocation</td>\n<td>Garbage collection tuning, algorithmic optimization</td>\n</tr>\n<tr>\n<td>Rust</td>\n<td>perf, flamegraph, criterion benchmarks</td>\n<td>CPU cycles, memory usage patterns</td>\n<td>Zero-cost abstractions, memory efficiency</td>\n</tr>\n<tr>\n<td>General</td>\n<td>APM tools (New Relic, DataDog, AppDynamics)</td>\n<td>End-to-end transaction tracing</td>\n<td>Full-stack performance optimization</td>\n</tr>\n</tbody></table>\n<p><strong>Systematic Performance Testing Methodology:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Testing Phase</th>\n<th>Test Design</th>\n<th>Data Requirements</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unit performance tests</td>\n<td>Individual component benchmarks</td>\n<td>Synthetic test data with known characteristics</td>\n<td>Consistent performance within acceptable bounds</td>\n</tr>\n<tr>\n<td>Integration performance tests</td>\n<td>End-to-end workflow testing</td>\n<td>Realistic transaction volumes and patterns</td>\n<td>Performance scales linearly with data volume</td>\n</tr>\n<tr>\n<td>Load testing</td>\n<td>Simulated production workload</td>\n<td>Production-like dataset size</td>\n<td>System remains responsive under peak load</td>\n</tr>\n<tr>\n<td>Stress testing</td>\n<td>Beyond-normal capacity testing</td>\n<td>Dataset larger than production</td>\n<td>Graceful degradation rather than catastrophic failure</td>\n</tr>\n<tr>\n<td>Regression testing</td>\n<td>Performance comparison after changes</td>\n<td>Identical dataset before and after optimization</td>\n<td>No performance regression in unrelated areas</td>\n</tr>\n</tbody></table>\n<h3 id=\"audit-trail-troubleshooting\">Audit Trail Troubleshooting</h3>\n<p><strong>Audit trail problems</strong> represent the most critical category of ledger system issues because they affect regulatory compliance and data integrity verification. Think of audit trail troubleshooting like investigating a crime scene - every change to financial data must be traceable, and any gap in the audit trail could indicate tampering, system failure, or compliance violation. Unlike performance or balance problems that affect operations, audit trail issues can have legal and regulatory consequences.</p>\n<p>The complexity of audit trail debugging stems from the immutable nature of the audit system itself - you cannot simply &quot;fix&quot; audit records without potentially destroying evidence. Instead, diagnosis must identify the root cause while preserving all existing audit evidence, and fixes must be implemented through additional audit entries that document the correction process itself.</p>\n<blockquote>\n<p><strong>Compliance Principle:</strong> Audit trail integrity is non-negotiable in financial systems. Any modification to audit records must itself be audited, and any gap in the audit trail must be documented and explained to auditors and regulators.</p>\n</blockquote>\n<p>The diagnostic approach focuses on systematic verification of audit trail completeness and integrity, using cryptographic verification and cross-referencing techniques to identify and document any anomalies.</p>\n<h4 id=\"audit-trail-integrity-verification\">Audit Trail Integrity Verification</h4>\n<p>Audit trail integrity verification involves multiple layers of validation that ensure both completeness (no missing records) and authenticity (no unauthorized modifications). This verification must be performed regularly and especially after any system incidents.</p>\n<p><strong>Cryptographic Integrity Checking:</strong></p>\n<p>The hash chain verification process ensures that no audit records have been modified since creation. Each audit event includes a hash of the previous event, creating a cryptographic chain that reveals any tampering attempts.</p>\n<table>\n<thead>\n<tr>\n<th>Verification Step</th>\n<th>Technical Process</th>\n<th>Expected Result</th>\n<th>Action if Failed</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Individual record hashing</td>\n<td>Recalculate content hash for each audit event</td>\n<td>Hash matches stored ContentHash</td>\n<td>Record has been modified - investigate timing and source</td>\n</tr>\n<tr>\n<td>Chain hash validation</td>\n<td>Verify each ChainHash references correct previous record</td>\n<td>Sequential hash chain maintained</td>\n<td>Chain break indicates insertion or deletion</td>\n</tr>\n<tr>\n<td>Digital signature verification</td>\n<td>Validate digital signatures using public key</td>\n<td>All signatures valid</td>\n<td>Invalid signature indicates system compromise</td>\n</tr>\n<tr>\n<td>Timestamp consistency</td>\n<td>Check that timestamps increase monotonically</td>\n<td>No out-of-order timestamps</td>\n<td>System clock issues or backdated entries</td>\n</tr>\n<tr>\n<td>Hash algorithm consistency</td>\n<td>Verify all records use same hash algorithm</td>\n<td>Consistent algorithm throughout chain</td>\n<td>Algorithm change not properly implemented</td>\n</tr>\n</tbody></table>\n<p><strong>Audit Record Completeness Validation:</strong></p>\n<p>Completeness validation ensures that all required business events have corresponding audit records and that no audit records have been deleted.</p>\n<table>\n<thead>\n<tr>\n<th>Completeness Check</th>\n<th>Validation Method</th>\n<th>Coverage Scope</th>\n<th>Gap Resolution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Business event coverage</td>\n<td>Cross-reference all journal entries with audit events</td>\n<td>Every posted entry has creation audit record</td>\n<td>Identify missing audit events and investigate cause</td>\n</tr>\n<tr>\n<td>State transition tracking</td>\n<td>Verify all status changes recorded</td>\n<td>Entry lifecycle completely audited</td>\n<td>Document where audit events were not generated</td>\n</tr>\n<tr>\n<td>User action auditing</td>\n<td>Check that all user-initiated actions logged</td>\n<td>Complete user activity trail</td>\n<td>Identify system actions not properly attributed</td>\n</tr>\n<tr>\n<td>System event auditing</td>\n<td>Validate automated process auditing</td>\n<td>All scheduled and triggered processes</td>\n<td>Ensure system processes generate audit events</td>\n</tr>\n<tr>\n<td>Approval workflow auditing</td>\n<td>Verify approval process completely documented</td>\n<td>Multi-step approvals fully tracked</td>\n<td>Reconstruct approval history from other sources</td>\n</tr>\n</tbody></table>\n<h4 id=\"common-audit-trail-failure-patterns\">Common Audit Trail Failure Patterns</h4>\n<p>Audit trail failures follow predictable patterns that help identify the root cause and scope of the problem. Understanding these patterns enables targeted investigation and appropriate remediation strategies.</p>\n<p><strong>Missing Audit Events:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Failure Pattern</th>\n<th>Typical Causes</th>\n<th>Detection Method</th>\n<th>Impact Assessment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Complete event silence</td>\n<td>Audit system offline or misconfigured</td>\n<td>Large gaps in event timeline</td>\n<td>Critical - entire period unaudited</td>\n</tr>\n<tr>\n<td>Selective event gaps</td>\n<td>Code paths bypassing audit system</td>\n<td>Spot-checking reveals missing events for specific operations</td>\n<td>High - specific operations not compliant</td>\n</tr>\n<tr>\n<td>User action gaps</td>\n<td>Authentication integration issues</td>\n<td>User actions not attributed to specific users</td>\n<td>Medium - accountability compromised</td>\n</tr>\n<tr>\n<td>System process gaps</td>\n<td>Automated processes not instrumented</td>\n<td>Scheduled job results not audited</td>\n<td>Medium - system changes not tracked</td>\n</tr>\n<tr>\n<td>Error condition gaps</td>\n<td>Exception handling bypasses audit logging</td>\n<td>Failed operations not recorded</td>\n<td>High - failures not documented</td>\n</tr>\n</tbody></table>\n<p><strong>Audit Data Corruption:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Corruption Type</th>\n<th>Symptoms</th>\n<th>Root Cause Investigation</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Hash chain breaks</td>\n<td>ChainHash validation failures</td>\n<td>Find first break point and investigate timing</td>\n<td>Rebuild chain from that point forward</td>\n</tr>\n<tr>\n<td>Content tampering</td>\n<td>ContentHash mismatch for individual records</td>\n<td>Compare with backup systems or database logs</td>\n<td>Document discrepancy and investigate source</td>\n</tr>\n<tr>\n<td>Timestamp anomalies</td>\n<td>Events with impossible timestamps</td>\n<td>Check system clock synchronization</td>\n<td>Correlate with other log sources for actual timing</td>\n</tr>\n<tr>\n<td>Orphaned audit records</td>\n<td>Audit events reference non-existent business records</td>\n<td>Database referential integrity issues</td>\n<td>Cross-reference with business data to identify scope</td>\n</tr>\n<tr>\n<td>Duplicate events</td>\n<td>Same business event recorded multiple times</td>\n<td>Idempotency failure in audit system</td>\n<td>Deduplicate while preserving evidence of duplication</td>\n</tr>\n</tbody></table>\n<h4 id=\"systematic-audit-trail-investigation-process\">Systematic Audit Trail Investigation Process</h4>\n<p>The investigation process must balance thoroughness with preservation of evidence, ensuring that the diagnostic process itself doesn&#39;t compromise the audit trail integrity.</p>\n<p><strong>Phase 1: Evidence Preservation</strong></p>\n<p>Before beginning any investigation, all current audit data must be preserved in an immutable state to prevent any questions about tampering during the diagnostic process.</p>\n<table>\n<thead>\n<tr>\n<th>Preservation Activity</th>\n<th>Implementation Method</th>\n<th>Verification Process</th>\n<th>Documentation Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Complete audit trail backup</td>\n<td>Export all audit events to tamper-evident storage</td>\n<td>Calculate hash of entire export</td>\n<td>Timestamp and digitally sign backup</td>\n</tr>\n<tr>\n<td>Database transaction logs backup</td>\n<td>Preserve database WAL/transaction logs</td>\n<td>Verify log completeness</td>\n<td>Document log file names and sizes</td>\n</tr>\n<tr>\n<td>System logs preservation</td>\n<td>Collect application and system logs</td>\n<td>Cross-reference timing with audit events</td>\n<td>Maintain chain of custody documentation</td>\n</tr>\n<tr>\n<td>Configuration snapshot</td>\n<td>Document current audit system configuration</td>\n<td>Compare with known-good configuration</td>\n<td>Record any configuration changes</td>\n</tr>\n</tbody></table>\n<p><strong>Phase 2: Integrity Assessment</strong></p>\n<p>The integrity assessment systematically evaluates the audit trail for completeness, authenticity, and consistency.</p>\n<table>\n<thead>\n<tr>\n<th>Assessment Category</th>\n<th>Validation Process</th>\n<th>Tools and Queries</th>\n<th>Acceptance Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cryptographic integrity</td>\n<td>Run hash chain validation across all records</td>\n<td>Custom verification scripts</td>\n<td>No hash mismatches or chain breaks</td>\n</tr>\n<tr>\n<td>Temporal consistency</td>\n<td>Analyze timestamp patterns and sequences</td>\n<td>Time-series analysis tools</td>\n<td>Monotonically increasing timestamps within reasonable bounds</td>\n</tr>\n<tr>\n<td>Business event correlation</td>\n<td>Match audit events to business transactions</td>\n<td>Cross-reference queries between audit and business tables</td>\n<td>Every significant business event has audit trail</td>\n</tr>\n<tr>\n<td>User attribution accuracy</td>\n<td>Verify user context in audit records</td>\n<td>Authentication log correlation</td>\n<td>All user actions properly attributed</td>\n</tr>\n<tr>\n<td>System process documentation</td>\n<td>Check automated process audit coverage</td>\n<td>Process execution log analysis</td>\n<td>All automated changes documented</td>\n</tr>\n</tbody></table>\n<p><strong>Phase 3: Root Cause Analysis</strong></p>\n<p>Root cause analysis focuses on understanding how audit trail problems occurred and implementing preventive measures.</p>\n<table>\n<thead>\n<tr>\n<th>Investigation Focus</th>\n<th>Analysis Method</th>\n<th>Evidence Collection</th>\n<th>Remediation Planning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>System failure impact</td>\n<td>Timeline analysis of system outages</td>\n<td>Correlate with audit gaps</td>\n<td>Implement audit resilience improvements</td>\n</tr>\n<tr>\n<td>Code deployment correlation</td>\n<td>Match audit issues with software releases</td>\n<td>Deployment logs and timing analysis</td>\n<td>Fix audit bypass bugs in application code</td>\n</tr>\n<tr>\n<td>Configuration drift</td>\n<td>Compare current vs baseline configuration</td>\n<td>Configuration management history</td>\n<td>Implement configuration monitoring</td>\n</tr>\n<tr>\n<td>Operator error assessment</td>\n<td>Review manual administrative actions</td>\n<td>Administrator action logs</td>\n<td>Improve administrative procedures</td>\n</tr>\n<tr>\n<td>Security incident investigation</td>\n<td>Check for evidence of unauthorized access</td>\n<td>Security log analysis</td>\n<td>Implement additional security controls</td>\n</tr>\n</tbody></table>\n<h4 id=\"audit-trail-recovery-and-remediation\">Audit Trail Recovery and Remediation</h4>\n<p>Recovery from audit trail problems requires careful balance between fixing the immediate issue and maintaining regulatory compliance through proper documentation.</p>\n<p><strong>Recovery Strategy Decision Matrix:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Problem Scope</th>\n<th>Business Impact</th>\n<th>Recovery Approach</th>\n<th>Regulatory Implications</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single transaction missing audit</td>\n<td>Low - isolated incident</td>\n<td>Document gap and reason, implement monitoring</td>\n<td>Minimal - document in next audit</td>\n</tr>\n<tr>\n<td>Multiple transactions missing audit</td>\n<td>Medium - compliance gap</td>\n<td>Reconstruct audit trail from other sources</td>\n<td>Moderate - may require disclosure</td>\n</tr>\n<tr>\n<td>Hash chain corruption</td>\n<td>High - integrity compromised</td>\n<td>Investigate source, rebuild from clean point</td>\n<td>High - may question entire audit trail</td>\n</tr>\n<tr>\n<td>Systematic audit bypass</td>\n<td>Critical - widespread non-compliance</td>\n<td>Code fix, retrospective audit reconstruction</td>\n<td>Critical - regulatory reporting required</td>\n</tr>\n</tbody></table>\n<p><strong>Remediation Implementation Steps:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Remediation Phase</th>\n<th>Activities</th>\n<th>Validation Requirements</th>\n<th>Documentation Needs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Immediate containment</td>\n<td>Stop further audit trail degradation</td>\n<td>Verify audit system functioning correctly</td>\n<td>Document timeline and actions taken</td>\n</tr>\n<tr>\n<td>Gap assessment</td>\n<td>Quantify extent of missing or corrupted audit data</td>\n<td>Cross-reference with all available data sources</td>\n<td>Create comprehensive gap analysis report</td>\n</tr>\n<tr>\n<td>Recovery implementation</td>\n<td>Reconstruct missing audit events from available data</td>\n<td>Validate reconstructed events against business records</td>\n<td>Document reconstruction methodology</td>\n</tr>\n<tr>\n<td>Process improvement</td>\n<td>Implement preventive measures</td>\n<td>Test improvements under failure scenarios</td>\n<td>Update audit procedures and monitoring</td>\n</tr>\n<tr>\n<td>Compliance reporting</td>\n<td>Notify auditors and regulators as required</td>\n<td>Provide complete documentation package</td>\n<td>Maintain ongoing compliance monitoring</td>\n</tr>\n</tbody></table>\n<p><strong>Preventive Measures Implementation:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Prevention Layer</th>\n<th>Implementation Strategy</th>\n<th>Monitoring Method</th>\n<th>Effectiveness Validation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Application-level controls</td>\n<td>Mandatory audit event generation in all code paths</td>\n<td>Code review and automated testing</td>\n<td>No business operations bypass audit</td>\n</tr>\n<tr>\n<td>Infrastructure resilience</td>\n<td>Redundant audit storage and processing</td>\n<td>Real-time replication monitoring</td>\n<td>Audit system survives single points of failure</td>\n</tr>\n<tr>\n<td>Real-time validation</td>\n<td>Continuous audit trail integrity checking</td>\n<td>Automated monitoring and alerting</td>\n<td>Immediate notification of audit issues</td>\n</tr>\n<tr>\n<td>Regular compliance audits</td>\n<td>Periodic comprehensive audit trail review</td>\n<td>Scheduled validation reports</td>\n<td>Proactive identification of potential issues</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The debugging implementation requires comprehensive diagnostic tools and systematic procedures that can quickly identify and resolve the four major categories of ledger system problems. The implementation focuses on providing both automated detection and guided manual investigation procedures.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Performance Monitoring</td>\n<td>Go pprof + custom timing logs (net/http/pprof)</td>\n<td>Application Performance Monitoring with distributed tracing (OpenTelemetry + Jaeger)</td>\n</tr>\n<tr>\n<td>Database Diagnostics</td>\n<td>SQL query logging + EXPLAIN plans</td>\n<td>Database-specific monitoring (pg_stat_statements for PostgreSQL)</td>\n</tr>\n<tr>\n<td>Audit Trail Validation</td>\n<td>Custom hash verification scripts</td>\n<td>Blockchain-based immutable audit (Hyperledger Fabric or similar)</td>\n</tr>\n<tr>\n<td>Error Detection</td>\n<td>Standard Go error handling + logging</td>\n<td>Structured error classification with error codes and categories</td>\n</tr>\n<tr>\n<td>Load Testing</td>\n<td>Simple Go benchmark tests</td>\n<td>Professional load testing (k6 or Artillery)</td>\n</tr>\n<tr>\n<td>Metrics Collection</td>\n<td>Prometheus metrics + Grafana dashboards</td>\n<td>Full observability stack (Prometheus/Grafana/AlertManager)</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  internal/debug/\n    balance_debugger.go          ← Balance discrepancy diagnosis\n    balance_debugger_test.go\n    entry_validator.go           ← Unbalanced entry detection\n    entry_validator_test.go\n    performance_profiler.go      ← Performance problem diagnosis\n    performance_profiler_test.go\n    audit_verifier.go           ← Audit trail troubleshooting\n    audit_verifier_test.go\n    diagnostic_reports.go       ← Report generation for all debugging\n    diagnostic_reports_test.go\n  internal/monitoring/\n    metrics.go                  ← Performance metrics collection\n    health_checks.go           ← System health monitoring\n  cmd/debug/\n    main.go                    ← CLI tool for debugging operations\n  scripts/\n    validate_system.sh         ← Comprehensive system validation script\n    performance_baseline.sh    ← Performance baseline measurement</code></pre></div>\n\n<h4 id=\"balance-debugger-infrastructure\">Balance Debugger Infrastructure</h4>\n<p>This infrastructure provides comprehensive balance discrepancy detection and diagnosis capabilities.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> debug</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">database/sql</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/shopspring/decimal</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/your-org/ledger/internal/types</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// BalanceDebugger provides comprehensive balance discrepancy diagnosis</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BalanceDebugger</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db           </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    balanceEngine </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">BalanceEngine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    auditTrail    </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AuditStorage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DiscrepancyReport contains complete analysis of balance discrepancies</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DiscrepancyReport</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AccountID           </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ExpectedBalance     </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ActualBalance       </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CachedBalance       </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Variance           </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastRecalculatedAt </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AffectedEntries    []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RootCauseAnalysis  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RecommendedActions []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SeverityLevel      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// SystemIntegrityReport provides overall ledger health assessment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> SystemIntegrityReport</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GeneratedAt        </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TrialBalanceStatus </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TotalVariance      </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AccountsAffected   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CriticalIssues     []</span><span style=\"color:#B392F0\">DiscrepancyReport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WarningIssues      []</span><span style=\"color:#B392F0\">DiscrepancyReport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RecommendedActions []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SystemHealthScore  </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewBalanceDebugger creates a new balance debugging instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewBalanceDebugger</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">engine</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">BalanceEngine</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">audit</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AuditStorage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BalanceDebugger</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">BalanceDebugger</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db:            db,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        balanceEngine: engine,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        auditTrail:    audit,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DiagnoseAccountDiscrepancy performs comprehensive analysis of account balance issues</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bd </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BalanceDebugger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DiagnoseAccountDiscrepancy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DiscrepancyReport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Retrieve current cached balance from RunningBalance table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Recalculate balance from entry lines (sum debits minus credits)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check account type and apply normal balance logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Identify variance between cached and calculated balances</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Query recent entry lines that affected this account</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Check for concurrent transaction timing issues</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Validate currency consistency across all entry lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Generate root cause analysis based on findings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Recommend specific corrective actions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Assign severity level based on variance amount and impact</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateSystemIntegrity performs comprehensive ledger-wide validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">bd </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BalanceDebugger</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateSystemIntegrity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SystemIntegrityReport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Generate current trial balance and check for zero sum</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Identify all accounts with cached vs calculated balance variance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check for orphaned entry lines without valid journal entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Validate that all posted entries have balanced debit/credit totals</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Verify account type consistency across all entry lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Check for entries posted to inactive accounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Identify currency conversion inconsistencies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Analyze audit trail for balance update failures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Generate prioritized list of issues requiring attention</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Calculate overall system health score based on findings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"entry-validation-infrastructure\">Entry Validation Infrastructure</h4>\n<p>This component provides systematic unbalanced entry detection and validation.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// EntryValidator provides comprehensive journal entry validation and debugging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EntryValidator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db         </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    auditTrail </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AuditStorage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidationIssue represents a specific entry validation problem</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ValidationIssue</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntryID         </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IssueType       </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Severity        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DebitTotal      </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreditTotal     </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Variance        </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Money</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AffectedLines   []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DetectedAt      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RecommendedFix  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// EntryValidationReport contains comprehensive entry validation results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> EntryValidationReport</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GeneratedAt      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntriesScanned   </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IssuesFound      </span><span style=\"color:#F97583\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CriticalIssues   []</span><span style=\"color:#B392F0\">ValidationIssue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    WarningIssues    []</span><span style=\"color:#B392F0\">ValidationIssue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SystemImpact     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OverallStatus    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NextSteps        []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewEntryValidator creates a new entry validation instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewEntryValidator</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">audit</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AuditStorage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EntryValidator</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">EntryValidator</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db:         db,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        auditTrail: audit,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DetectUnbalancedEntries finds all journal entries that violate double-entry rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ev </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EntryValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DetectUnbalancedEntries</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">dateFrom</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">dateTo</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EntryValidationReport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Query all journal entries in the specified date range</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: For each entry, calculate total debit and credit amounts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Identify entries where debits do not equal credits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Check for entries with missing or invalid entry lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Validate currency consistency within each entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Analyze audit trail for evidence of post-posting modifications</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Categorize issues by severity and potential impact</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Generate specific repair recommendations for each issue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Calculate overall system impact of unbalanced entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Prioritize issues for correction based on business impact</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ValidateTrialBalance performs comprehensive trial balance validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">ev </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">EntryValidator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ValidateTrialBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">asOfDate</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Calculate trial balance for specified date</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify that total debits equal total credits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check that all account balances are reasonable for account type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Identify any accounts with unexpected zero balances</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Validate that asset and expense accounts have debit balances</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Verify that liability, equity, and revenue accounts have credit balances</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Check for any accounts with balances in wrong currency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Generate detailed variance report if trial balance doesn't balance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Provide specific account-level recommendations for correction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Update system health metrics based on validation results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"performance-profiler-infrastructure\">Performance Profiler Infrastructure</h4>\n<p>This infrastructure provides comprehensive performance monitoring and diagnosis capabilities.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// PerformanceProfiler provides systematic performance analysis and optimization guidance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PerformanceProfiler</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db      </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    metrics </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PerformanceMetric</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PerformanceMetric tracks timing and throughput for specific operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PerformanceMetric</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OperationName    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SampleCount      </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TotalDuration    </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MinDuration      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MaxDuration      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AverageDuration  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    P95Duration      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    P99Duration      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Duration</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ErrorCount       </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LastMeasurement  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PerformanceReport contains comprehensive system performance analysis</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> PerformanceReport</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GeneratedAt         </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    SystemLoad          </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DatabasePerformance </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PerformanceMetric</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CacheEfficiency     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">float64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BottleneckAnalysis  []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    OptimizationPlan    []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ResourceUtilization </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewPerformanceProfiler creates a new performance profiling instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewPerformanceProfiler</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PerformanceProfiler</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">PerformanceProfiler</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db:      db,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        metrics: </span><span style=\"color:#B392F0\">make</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PerformanceMetric</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// MeasureOperation wraps an operation with performance measurement</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PerformanceProfiler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">MeasureOperation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">operationName</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">operation</span><span style=\"color:#F97583\"> func</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Record operation start time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Execute the provided operation function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Calculate operation duration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update performance metrics for this operation type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Check if operation exceeded expected performance thresholds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Log slow operations for further analysis</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Update rolling averages and percentile calculations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Trigger alerts if performance degrades significantly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Return original operation result or error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AnalyzeSystemPerformance generates comprehensive performance analysis</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">pp </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PerformanceProfiler</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">AnalyzeSystemPerformance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">PerformanceReport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Collect current performance metrics for all tracked operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Analyze database query performance using EXPLAIN plans</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check cache hit rates and efficiency metrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Identify operations exceeding performance thresholds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Analyze resource utilization patterns (CPU, memory, I/O)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Correlate performance issues with system load patterns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Generate prioritized list of performance bottlenecks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Recommend specific optimization strategies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Estimate performance improvement potential for each recommendation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Create actionable performance improvement roadmap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"audit-trail-verifier-infrastructure\">Audit Trail Verifier Infrastructure</h4>\n<p>This component provides comprehensive audit trail integrity verification and problem diagnosis.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// AuditVerifier provides systematic audit trail integrity verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AuditVerifier</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    auditStorage </span><span style=\"color:#B392F0\">types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AuditStorage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db           </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// IntegrityViolation represents a specific audit trail integrity problem</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IntegrityViolation</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ViolationType   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EventID         </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    DetectedAt      </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Severity        </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Evidence        </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RecommendedFix  </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ComplianceImpact </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// AuditIntegrityReport contains comprehensive audit trail health assessment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AuditIntegrityReport</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    GeneratedAt        </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EventsValidated    </span><span style=\"color:#F97583\">int64</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IntegrityViolations []</span><span style=\"color:#B392F0\">IntegrityViolation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    HashChainStatus    </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CompletenessStatus </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ComplianceStatus   </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RecommendedActions []</span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    RegulatoryRisk     </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// NewAuditVerifier creates a new audit verification instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewAuditVerifier</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">audit</span><span style=\"color:#B392F0\"> types</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">AuditStorage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuditVerifier</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">AuditVerifier</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        auditStorage: audit,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db:           db,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// VerifyAuditIntegrity performs comprehensive audit trail validation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">av </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuditVerifier</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">VerifyAuditIntegrity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">dateFrom</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">dateTo</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuditIntegrityReport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate cryptographic hash chain continuity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Verify digital signatures on all audit events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check timestamp consistency and monotonic progression</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Cross-reference audit events with business transactions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Identify any gaps in the audit trail timeline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Validate that all required business events have audit records</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Check for orphaned audit records without corresponding business data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Verify user attribution accuracy for all recorded events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Analyze audit event patterns for anomalies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Generate compliance risk assessment based on findings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// DetectAuditGaps identifies missing or corrupted audit records</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">av </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">AuditVerifier</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">DetectAuditGaps</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">IntegrityViolation</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Query all business transactions and corresponding audit events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Identify business events without corresponding audit records</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check for audit events without valid business transaction references</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Analyze timing gaps in audit event sequences</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Validate that state transitions are completely audited</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Check for missing user authentication context in audit events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 7: Identify system processes that may not be generating audit events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 8: Cross-reference with system logs to identify missed events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 9: Categorize gaps by severity and compliance impact</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 10: Generate specific remediation steps for each identified gap</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> nil</span><span style=\"color:#E1E4E8\">, fmt.</span><span style=\"color:#B392F0\">Errorf</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"not implemented\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"debugging-cli-tool-implementation\">Debugging CLI Tool Implementation</h4>\n<p>A command-line interface provides easy access to all debugging functions for system administrators and developers.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// cmd/debug/main.go</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">package</span><span style=\"color:#B392F0\"> main</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">context</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">flag</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">fmt</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">log</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">os</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">time</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"</span><span style=\"color:#B392F0\">github.com/your-org/ledger/internal/debug</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">() {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    var</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        operation </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> flag.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"operation\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Debug operation: balance, entries, performance, audit\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        accountID </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> flag.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"account\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Account ID for balance debugging\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dateFrom  </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> flag.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"from\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Start date for analysis (YYYY-MM-DD)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        dateTo    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> flag.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"to\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"End date for analysis (YYYY-MM-DD)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        output    </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> flag.</span><span style=\"color:#B392F0\">String</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"output\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"console\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Output format: console, json, csv\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    flag.</span><span style=\"color:#B392F0\">Parse</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Initialize database connection from environment variables</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create appropriate debugger instance based on operation type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Parse and validate date parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Execute requested debugging operation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Format and output results according to specified format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Exit with appropriate status code based on findings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    switch</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\">operation {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"balance\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Implement balance discrepancy diagnosis</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"entries\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Implement unbalanced entry detection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"performance\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Implement performance analysis</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    case</span><span style=\"color:#9ECBFF\"> \"audit\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        // TODO: Implement audit trail verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    default</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fmt.</span><span style=\"color:#B392F0\">Fprintf</span><span style=\"color:#E1E4E8\">(os.Stderr, </span><span style=\"color:#9ECBFF\">\"Invalid operation: </span><span style=\"color:#79B8FF\">%s\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">operation)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        os.</span><span style=\"color:#B392F0\">Exit</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>Each milestone should include specific debugging capabilities that demonstrate the system&#39;s robustness and maintainability.</p>\n<p><strong>Milestone 1-2 Checkpoint: Basic Validation</strong></p>\n<ul>\n<li>Run <code>go run cmd/debug/main.go -operation=entries</code> to detect any unbalanced journal entries</li>\n<li>Expected output: &quot;No unbalanced entries detected&quot; or specific details of any violations</li>\n<li>Verify that trial balance validation passes with <code>go test ./internal/debug -v -run=TestTrialBalance</code></li>\n</ul>\n<p><strong>Milestone 3 Checkpoint: Balance Consistency</strong></p>\n<ul>\n<li>Run <code>go run cmd/debug/main.go -operation=balance -account=&lt;test-account-id&gt;</code> </li>\n<li>Expected output: Cached balance matches calculated balance within acceptable precision</li>\n<li>Performance baseline: Balance queries should complete in under 100ms for accounts with &lt;10,000 transactions</li>\n</ul>\n<p><strong>Milestone 4-5 Checkpoint: Full System Validation</strong></p>\n<ul>\n<li>Run comprehensive system validation: <code>go run cmd/debug/main.go -operation=audit -from=2024-01-01 -to=2024-12-31</code></li>\n<li>Expected output: Complete audit trail with no integrity violations</li>\n<li>All debugging tools should execute without errors and provide actionable insights</li>\n</ul>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1-5 (All milestones), as this section describes potential system enhancements that build upon the complete double-entry ledger foundation including advanced reporting capabilities, workflow automation, external integrations, and scalability improvements</p>\n</blockquote>\n<p>Building a production-ready double-entry ledger system opens numerous opportunities for enhancement and growth. Think of the current system as a solid financial foundation—like a well-built house with strong bones that can support room additions, upgraded utilities, and modern amenities. The architectural decisions made throughout the core system design enable these extensions while maintaining the fundamental principles of accounting integrity and audit trail immutability.</p>\n<p>The key insight is that all future extensions must preserve the <strong>accounting invariants</strong> that make the system trustworthy. Just as a structural engineer never compromises load-bearing walls when renovating a house, our extensions must never violate the double-entry principle, compromise transaction atomicity, or break the immutable audit trail. This section explores four major categories of enhancements that represent natural growth paths for the ledger system.</p>\n<h3 id=\"advanced-reporting-features\">Advanced Reporting Features</h3>\n<p>Think of advanced reporting as transforming raw accounting data into business intelligence—like having a skilled financial analyst who can spot patterns, trends, and insights that aren&#39;t immediately obvious from basic trial balances and income statements. While the current system provides fundamental reports required for regulatory compliance, businesses need sophisticated analytical tools to make strategic decisions.</p>\n<p>The <strong>cash flow statement</strong> represents the most critical missing piece from the standard financial reporting suite. Unlike the income statement, which shows profitability using accrual accounting, the cash flow statement tracks actual money movement through the business. This requires classifying journal entries into operating, investing, and financing activities—a complex analytical process that goes beyond simple account type categorization.</p>\n<blockquote>\n<p><strong>Decision: Cash Flow Statement Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Businesses need to track actual cash movements separately from accrual accounting profits, requiring classification of transactions into operating, investing, and financing activities</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Direct method (track actual cash receipts/payments)</li>\n<li>Indirect method (reconcile net income to cash flow)</li>\n<li>Hybrid approach with configurable methodology</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Implement indirect method with optional direct method support</li>\n<li><strong>Rationale</strong>: Indirect method integrates naturally with existing journal entry data, while direct method requires additional cash transaction tracking that may not exist in all implementations</li>\n<li><strong>Consequences</strong>: Enables standard cash flow reporting with reasonable implementation complexity, but requires business rules engine for activity classification</li>\n</ul>\n</blockquote>\n<p>The <strong>variance analysis</strong> capability transforms the ledger into a management accounting tool by comparing actual results against budgets, forecasts, and prior periods. This requires extending the data model to store budget data and implementing sophisticated comparison algorithms that handle different time periods, currencies, and organizational structures.</p>\n<p><strong>Custom report builders</strong> represent the most complex enhancement, essentially creating a domain-specific language for financial reporting. Think of this as building a specialized SQL query interface that understands accounting semantics—users can define their own reports without writing complex database queries or understanding the underlying schema relationships.</p>\n<table>\n<thead>\n<tr>\n<th>Enhancement</th>\n<th>Data Requirements</th>\n<th>Processing Complexity</th>\n<th>Business Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cash Flow Statement</td>\n<td>Transaction activity classification rules</td>\n<td>Medium - requires reconciliation logic</td>\n<td>High - critical for cash management</td>\n</tr>\n<tr>\n<td>Variance Analysis</td>\n<td>Budget/forecast data storage</td>\n<td>Low - mostly comparison operations</td>\n<td>High - enables management decisions</td>\n</tr>\n<tr>\n<td>Custom Report Builder</td>\n<td>Report template metadata schema</td>\n<td>High - requires query language parser</td>\n<td>Medium - reduces IT dependency</td>\n</tr>\n<tr>\n<td>Consolidated Reporting</td>\n<td>Inter-company elimination rules</td>\n<td>Very High - complex entity relationships</td>\n<td>High - required for corporate groups</td>\n</tr>\n<tr>\n<td>Real-time Analytics</td>\n<td>Streaming data processing</td>\n<td>Very High - requires event-driven architecture</td>\n<td>Medium - nice-to-have for most businesses</td>\n</tr>\n</tbody></table>\n<p>The architecture naturally accommodates these reporting enhancements through the existing <code>Financial Reporting Module</code>. The <code>ReportGenerator</code> interface can be extended with new implementations that leverage the same underlying data access patterns while providing sophisticated analytical capabilities.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> AdvancedReportGenerator</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GenerateCashFlowStatement</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">periodStart</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">periodEnd</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">method</span><span style=\"color:#B392F0\"> CashFlowMethod</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CashFlowStatement</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GenerateVarianceAnalysis</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">actual</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">TrialBalance</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">budget</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BudgetData</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">analysisType</span><span style=\"color:#B392F0\"> VarianceType</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">VarianceReport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ExecuteCustomReport</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">template</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ReportTemplate</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">parameters</span><span style=\"color:#F97583\"> map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{}) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">CustomReport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h3 id=\"workflow-and-approval-systems\">Workflow and Approval Systems</h3>\n<p>Imagine transforming the current direct journal entry posting into a sophisticated approval pipeline—like upgrading from a simple email system to a modern document workflow platform where different types of transactions require different levels of authorization based on amount, risk, and organizational policies.</p>\n<p>The current system posts journal entries immediately upon validation, which works well for automated transactions and trusted users. However, production accounting systems often require <strong>multi-level approval processes</strong> where transactions above certain thresholds, or entries affecting sensitive accounts, must be reviewed and approved by managers before posting to the ledger.</p>\n<blockquote>\n<p><strong>Decision: Approval Workflow Architecture</strong>  </p>\n<ul>\n<li><strong>Context</strong>: Production accounting requires human oversight for high-risk transactions, with approval requirements varying by amount, account type, and organizational hierarchy</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Simple binary approval (pending/approved)</li>\n<li>Multi-stage workflow with configurable approval chains</li>\n<li>Rule-based automatic approval with exception handling</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Implement configurable multi-stage workflow with rule engine</li>\n<li><strong>Rationale</strong>: Different organizations have vastly different approval requirements, and flexibility is more valuable than simplicity for production deployment</li>\n<li><strong>Consequences</strong>: Enables sophisticated approval processes but requires workflow engine and notification infrastructure</li>\n</ul>\n</blockquote>\n<p><strong>Automated posting rules</strong> represent the opposite end of the spectrum—intelligent automation that can recognize transaction patterns and create journal entries without human intervention. Think of this as teaching the system to recognize common business events (like receiving an invoice or completing a sale) and automatically generate the corresponding accounting entries.</p>\n<p>The workflow system extends the <code>EntryStatus</code> enumeration to include intermediate states like <code>PENDING_APPROVAL</code>, <code>REJECTED</code>, and <code>APPROVED_PENDING_POST</code>. This requires fundamental changes to the transaction recording workflow while preserving the atomic posting guarantees of the core system.</p>\n<table>\n<thead>\n<tr>\n<th>Workflow Component</th>\n<th>Responsibility</th>\n<th>Integration Point</th>\n<th>Technical Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Approval Engine</td>\n<td>Route entries through approval chains</td>\n<td>Transaction Recording Engine</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Rule Engine</td>\n<td>Evaluate approval and automation rules</td>\n<td>Account Management Component</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Notification System</td>\n<td>Alert approvers and requesters</td>\n<td>External email/messaging service</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Workflow History</td>\n<td>Track approval decisions and timing</td>\n<td>Audit Trail System</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Delegation Manager</td>\n<td>Handle temporary approval delegation</td>\n<td>User management system (external)</td>\n<td>Medium</td>\n</tr>\n</tbody></table>\n<p>The <strong>automated posting rules</strong> require a sophisticated <strong>rule engine</strong> that can evaluate complex business conditions. For example: &quot;If transaction amount &gt; $10,000 AND affects cash accounts AND is created by non-manager user, then require CFO approval.&quot; This rule engine must integrate with the validation pipeline while maintaining the same error handling and rollback capabilities.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WorkflowRule</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    EvaluateCondition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userContext</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">UserContext</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GetRequiredApprovers</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#B392F0\">ApproverID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CanAutoApprove</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userContext</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">UserContext</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ApprovalWorkflow</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Rules []</span><span style=\"color:#B392F0\">WorkflowRule</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    NotificationService </span><span style=\"color:#B392F0\">NotificationService</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ApprovalStorage </span><span style=\"color:#B392F0\">ApprovalStorage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The most sophisticated enhancement is <strong>delegation management</strong>, allowing temporary transfer of approval authority when managers are unavailable. This requires time-limited delegation records, automated expiration, and notification systems—essentially building a mini-workflow management system within the accounting system.</p>\n<h3 id=\"external-system-integration\">External System Integration</h3>\n<p>Think of external integrations as building bridges between the ledger system and the broader business ecosystem—like connecting individual buildings with sky bridges so people and information can flow seamlessly between them. The current ledger operates as a standalone system, but production deployments must integrate with ERP systems, banks, payment processors, and third-party accounting software.</p>\n<p><strong>ERP integration</strong> represents the most complex integration challenge because ERPs often have their own accounting modules. The integration must handle bidirectional synchronization while maintaining the ledger as the authoritative source of financial truth. This requires sophisticated <strong>data mapping</strong> between different chart of accounts structures and <strong>conflict resolution</strong> when the same transaction appears in both systems.</p>\n<blockquote>\n<p><strong>Decision: ERP Integration Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Enterprise customers use comprehensive ERP systems (SAP, Oracle, NetSuite) with built-in accounting modules, requiring integration without creating dual sources of financial truth</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Replace ERP accounting module entirely</li>\n<li>Bidirectional synchronization with conflict resolution</li>\n<li>ERP as source with ledger as analytical layer</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Implement unidirectional integration with ERP as source and ledger as analytical layer</li>\n<li><strong>Rationale</strong>: Replacing ERP accounting disrupts established business processes, while bidirectional sync creates complex conflict scenarios that risk data integrity</li>\n<li><strong>Consequences</strong>: Enables advanced analytics and audit capabilities while preserving existing ERP workflows, but requires robust ETL pipeline and data validation</li>\n</ul>\n</blockquote>\n<p><strong>Bank feed integration</strong> automates transaction recording by importing bank statements and matching them against expected transactions. This is like having a smart assistant that can read bank statements and automatically create the corresponding journal entries, with sophisticated matching algorithms that can handle timing differences, transaction fees, and currency conversions.</p>\n<p>The technical challenge lies in <strong>transaction matching</strong>—determining which bank transactions correspond to which journal entries. Banks provide different levels of transaction detail, and timing differences between when transactions are recorded in the ledger versus when they clear the bank create matching complexity.</p>\n<table>\n<thead>\n<tr>\n<th>Integration Type</th>\n<th>Data Flow Direction</th>\n<th>Synchronization Frequency</th>\n<th>Complexity Level</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ERP Systems</td>\n<td>Bidirectional</td>\n<td>Real-time or batch</td>\n<td>Very High</td>\n</tr>\n<tr>\n<td>Bank Feeds</td>\n<td>Inbound only</td>\n<td>Daily batch import</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Payment Processors</td>\n<td>Bidirectional</td>\n<td>Real-time via webhooks</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Tax Software</td>\n<td>Outbound only</td>\n<td>Monthly/quarterly</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Business Intelligence</td>\n<td>Outbound only</td>\n<td>Real-time or batch</td>\n<td>Medium</td>\n</tr>\n</tbody></table>\n<p><strong>API design for integrations</strong> requires careful consideration of data formats, authentication, rate limiting, and error handling. The APIs must expose ledger functionality while protecting the integrity constraints that make the system trustworthy. This often means providing higher-level business operations rather than direct database access.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> IntegrationAPI</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // ERP Integration</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ImportChartOfAccounts</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accounts</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">ExternalAccount</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ImportResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    SynchronizeTransactions</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">transactions</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">ExternalTransaction</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">SyncResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Bank Feed Integration</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ImportBankStatement</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">statement</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BankStatement</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReconciliationResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    MatchTransactions</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">bankTx</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">BankTransaction</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">ledgerTx</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">MatchResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Generic Export</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ExportTrialBalance</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">format</span><span style=\"color:#B392F0\"> ExportFormat</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">asOfDate</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) ([]</span><span style=\"color:#F97583\">byte</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    ExportJournalEntries</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">criteria</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">ExportCriteria</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ExportPackage</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The most sophisticated integration capability is <strong>real-time event streaming</strong>, where the ledger publishes events about transaction posting, account balance changes, and period closing to external subscribers. This enables building event-driven architectures where other business systems can react immediately to financial events.</p>\n<h3 id=\"scalability-and-distribution\">Scalability and Distribution</h3>\n<p>Scaling a double-entry ledger presents unique challenges because the <strong>fundamental accounting constraints</strong> cannot be compromised. Think of it like scaling a bank vault—you can build more vaults and hire more guards, but every vault must maintain the same level of security, and the total money across all vaults must still reconcile perfectly.</p>\n<p>The core challenge is that double-entry bookkeeping has inherent dependencies that resist typical horizontal scaling approaches. Every transaction must maintain the invariant that debits equal credits, and trial balances must sum to zero across the entire system. These global consistency requirements seem to demand centralized processing.</p>\n<blockquote>\n<p><strong>Decision: Distributed Ledger Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: High-volume financial systems need horizontal scalability, but accounting integrity requires global consistency that traditionally demands centralized processing</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Centralized ledger with read replicas</li>\n<li>Sharded ledger by account or entity</li>\n<li>Event-sourced architecture with eventual consistency</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Implement hybrid approach with centralized posting and distributed read processing</li>\n<li><strong>Rationale</strong>: Accounting integrity is non-negotiable, so all posting must maintain ACID properties, but read operations (balance queries, report generation) can be distributed without compromising integrity</li>\n<li><strong>Consequences</strong>: Enables read scalability while preserving accounting accuracy, but write scalability remains limited by consensus requirements</li>\n</ul>\n</blockquote>\n<p><strong>Read replica distribution</strong> represents the safest scaling approach. The master ledger handles all write operations (journal entry posting, account creation, period closing), while read replicas serve balance queries, report generation, and analytical workloads. The replication must handle <strong>temporal consistency</strong>—ensuring that balance queries see all journal entries posted before a given timestamp.</p>\n<p><strong>Horizontal partitioning</strong> by entity or subsidiary enables scaling for organizations with natural business boundaries. Each partition maintains its own complete trial balance, and a <strong>consolidation layer</strong> handles inter-entity transactions and consolidated reporting. This is like having separate accounting books for each division, with a corporate accounting team that combines them for overall financial statements.</p>\n<p>The most advanced approach is <strong>distributed consensus</strong> for transaction posting, using algorithms like Raft or Byzantine Fault Tolerance to ensure that all nodes agree on transaction ordering and posting. This enables <strong>active-active</strong> deployments where multiple nodes can accept transactions, but requires sophisticated <strong>conflict resolution</strong> when simultaneous transactions affect the same accounts.</p>\n<table>\n<thead>\n<tr>\n<th>Scaling Approach</th>\n<th>Write Scalability</th>\n<th>Read Scalability</th>\n<th>Consistency Model</th>\n<th>Implementation Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Master-Slave Replication</td>\n<td>None</td>\n<td>High</td>\n<td>Strong eventual</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Horizontal Partitioning</td>\n<td>Medium</td>\n<td>High</td>\n<td>Strong per partition</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Distributed Consensus</td>\n<td>Medium</td>\n<td>High</td>\n<td>Strong global</td>\n<td>Very High</td>\n</tr>\n<tr>\n<td>Event Sourcing</td>\n<td>High</td>\n<td>High</td>\n<td>Eventually consistent</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Blockchain/DLT</td>\n<td>Low</td>\n<td>Medium</td>\n<td>Strong global</td>\n<td>Very High</td>\n</tr>\n</tbody></table>\n<p><strong>Performance optimization</strong> for distributed systems requires sophisticated <strong>caching strategies</strong> that respect accounting semantics. Balance caches must be invalidated correctly across multiple nodes, and <strong>cache coherence protocols</strong> must ensure that no node serves stale financial data that could lead to incorrect business decisions.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> DistributedLedger</span><span style=\"color:#F97583\"> interface</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Distributed Write Operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    PostEntryWithConsensus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConsensusResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Partition Management</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    CreatePartition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">partitionID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">config</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">PartitionConfig</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    TransferAccount</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">accountID</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">fromPartition</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">toPartition</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Cross-Partition Operations</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    PostInterEntityTransaction</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">partitions</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">DistributedPostingResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    GenerateConsolidatedReport</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">reportType</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">partitions</span><span style=\"color:#E1E4E8\"> []</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConsolidatedReport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Consistency and Recovery</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    VerifyGlobalConsistency</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConsistencyReport</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    RecoverPartition</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">partitionID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">recoveryPoint</span><span style=\"color:#B392F0\"> time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p>The ultimate scaling challenge is <strong>global distribution</strong> across multiple geographic regions while maintaining <strong>regulatory compliance</strong> in each jurisdiction. This requires <strong>data residency</strong> controls, <strong>regional audit trails</strong>, and <strong>cross-border transaction</strong> handling that complies with international financial regulations.</p>\n<p><strong>Common Pitfalls in Future Extensions:</strong></p>\n<p>⚠️ <strong>Pitfall: Breaking Accounting Integrity for Performance</strong>\nMany scalability solutions compromise the fundamental accounting invariants in pursuit of performance gains. For example, implementing eventual consistency where trial balances might temporarily not sum to zero violates the core principle that makes double-entry bookkeeping trustworthy. Always prioritize accounting accuracy over performance—a fast but incorrect accounting system is worse than useless.</p>\n<p>⚠️ <strong>Pitfall: Insufficient Integration Testing</strong>\nComplex integrations often work perfectly in isolation but fail when multiple systems interact simultaneously. For example, an ERP integration might work fine until someone uses the bank feed integration at the same time, creating duplicate transactions. Implement comprehensive integration test suites that exercise all combinations of external systems.</p>\n<p>⚠️ <strong>Pitfall: Neglecting Audit Trail in Extensions</strong>\nNew features often bypass the audit trail system, creating blind spots in the financial record. Every extension must maintain the same level of auditability as the core system—workflow approvals, automated posting rules, and external integrations all generate events that must be tracked for regulatory compliance.</p>\n<p>⚠️ <strong>Pitfall: Underestimating Configuration Complexity</strong>\nAdvanced features require sophisticated configuration management. Approval workflows, automated posting rules, and integration mappings create complex configuration dependencies that can be difficult to test and troubleshoot. Design configuration systems with validation, versioning, and rollback capabilities.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Workflow Engine</td>\n<td>Database-based state machine</td>\n<td>Temporal or Zeebe workflow service</td>\n</tr>\n<tr>\n<td>Report Builder</td>\n<td>Template-based generator</td>\n<td>Apache Superset or custom DSL</td>\n</tr>\n<tr>\n<td>Message Queue</td>\n<td>Redis Streams</td>\n<td>Apache Kafka or AWS SQS</td>\n</tr>\n<tr>\n<td>External APIs</td>\n<td>HTTP REST with OpenAPI</td>\n<td>GraphQL with federation</td>\n</tr>\n<tr>\n<td>Caching Layer</td>\n<td>Redis with manual invalidation</td>\n<td>Hazelcast with event-based invalidation</td>\n</tr>\n<tr>\n<td>Distributed Consensus</td>\n<td>Single leader with failover</td>\n<td>Raft consensus (hashicorp/raft)</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-extension-structure\">Recommended Extension Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  internal/extensions/\n    reporting/\n      cashflow/\n        statement.go              ← cash flow statement generator\n        classification.go         ← activity classification rules\n      variance/\n        analysis.go              ← budget vs actual comparison\n      builder/\n        custom_reports.go        ← report template engine\n    workflow/\n      approval/\n        engine.go                ← approval workflow coordinator\n        rules.go                 ← approval rule evaluation\n      automation/\n        posting_rules.go         ← automated entry generation\n    integration/\n      erp/\n        sap_connector.go         ← SAP integration\n        netsuite_connector.go    ← NetSuite integration\n      banking/\n        bank_feed.go             ← bank statement import\n        reconciliation.go        ← transaction matching\n    scaling/\n      partition/\n        manager.go               ← horizontal partitioning\n      consensus/\n        raft_coordinator.go      ← distributed consensus\n      cache/\n        distributed_cache.go     ← multi-node cache coherence</code></pre></div>\n\n<h4 id=\"workflow-engine-infrastructure\">Workflow Engine Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Complete workflow infrastructure for approval processes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WorkflowState</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    EntryID       </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"entry_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CurrentStep   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">                 `json:\"current_step\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Status        </span><span style=\"color:#B392F0\">WorkflowStatus</span><span style=\"color:#9ECBFF\">         `json:\"status\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Approvers     []</span><span style=\"color:#B392F0\">ApprovalRecord</span><span style=\"color:#9ECBFF\">       `json:\"approvers\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Variables     </span><span style=\"color:#F97583\">map</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#F97583\">string</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#9ECBFF\">`json:\"variables\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    CreatedAt     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">             `json:\"created_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    UpdatedAt     </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">             `json:\"updated_at\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WorkflowStatus</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WorkflowStatusPending</span><span style=\"color:#B392F0\">   WorkflowStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"PENDING\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WorkflowStatusApproved</span><span style=\"color:#B392F0\">  WorkflowStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"APPROVED\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WorkflowStatusRejected</span><span style=\"color:#B392F0\">  WorkflowStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"REJECTED\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WorkflowStatusExpired</span><span style=\"color:#B392F0\">   WorkflowStatus</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"EXPIRED\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ApprovalRecord</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ApproverID </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"approver_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Action     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"action\"`</span><span style=\"color:#6A737D\"> // APPROVE, REJECT, DELEGATE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Comment    </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"comment\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Timestamp  </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\"> `json:\"timestamp\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    IPAddress  </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">    `json:\"ip_address\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> WorkflowEngine</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db           </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ruleEngine   </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">RuleEngine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    notification </span><span style=\"color:#B392F0\">NotificationService</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    audit        </span><span style=\"color:#B392F0\">AuditStorage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#B392F0\"> NewWorkflowEngine</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">db</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">audit</span><span style=\"color:#B392F0\"> AuditStorage</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WorkflowEngine</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#F97583\"> &#x26;</span><span style=\"color:#B392F0\">WorkflowEngine</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        db:           db,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ruleEngine:   </span><span style=\"color:#B392F0\">NewRuleEngine</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        notification: </span><span style=\"color:#B392F0\">NewEmailNotificationService</span><span style=\"color:#E1E4E8\">(),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        audit:        audit,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// StartApprovalWorkflow initiates workflow for journal entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WorkflowEngine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">StartApprovalWorkflow</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">userContext</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">UserContext</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WorkflowState</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Evaluate rules to determine required approvers for this entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Create workflow state record in database</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Send notifications to required approvers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Create audit event for workflow initiation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return workflow state with pending status</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ProcessApproval handles approver decision on pending entry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">w </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">WorkflowEngine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ProcessApproval</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entryID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">approverID</span><span style=\"color:#F97583\"> string</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">decision</span><span style=\"color:#B392F0\"> ApprovalDecision</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate approver has authority for this entry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Update workflow state with approval decision</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Check if all required approvals are complete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: If approved, post entry to ledger atomically</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Send notifications to requestor and other stakeholders</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Create audit trail for approval decision</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"bank-feed-integration-starter\">Bank Feed Integration Starter</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Complete bank feed integration for automated reconciliation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BankFeedProcessor</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    db              </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">sql</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">DB</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ledger          </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionRecorder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    matcher         </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionMatcher</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    reconciliation  </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReconciliationEngine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> BankTransaction</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BankTxID      </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"bank_tx_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Date          </span><span style=\"color:#B392F0\">time</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Time</span><span style=\"color:#9ECBFF\">       `json:\"date\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Amount        </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#9ECBFF\">           `json:\"amount\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Description   </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"description\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Reference     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"reference\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    AccountNumber </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"account_number\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    TxType        </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"tx_type\"`</span><span style=\"color:#6A737D\"> // DEBIT, CREDIT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Balance       </span><span style=\"color:#B392F0\">Money</span><span style=\"color:#9ECBFF\">           `json:\"balance\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MatchResult</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    BankTxID     </span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">          `json:\"bank_tx_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LedgerTxID   </span><span style=\"color:#F97583\">*</span><span style=\"color:#F97583\">string</span><span style=\"color:#9ECBFF\">         `json:\"ledger_tx_id\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    MatchType    </span><span style=\"color:#B392F0\">MatchType</span><span style=\"color:#9ECBFF\">       `json:\"match_type\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Confidence   </span><span style=\"color:#F97583\">float64</span><span style=\"color:#9ECBFF\">         `json:\"confidence\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Variance     </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">Money</span><span style=\"color:#9ECBFF\">          `json:\"variance\"`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> MatchType</span><span style=\"color:#F97583\"> string</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MatchTypeExact</span><span style=\"color:#B392F0\">      MatchType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"EXACT\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MatchTypePartial</span><span style=\"color:#B392F0\">    MatchType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"PARTIAL\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MatchTypeUnmatched</span><span style=\"color:#B392F0\">  MatchType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"UNMATCHED\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MatchTypeDuplicate</span><span style=\"color:#B392F0\">  MatchType</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"DUPLICATE\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ProcessBankStatement imports and matches bank transactions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">b </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">BankFeedProcessor</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">ProcessBankStatement</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">statement</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">BankStatement</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ReconciliationResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Validate bank statement format and completeness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Import bank transactions to temporary staging table</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Run matching algorithm against posted journal entries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Auto-create entries for matched transactions if configured</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Generate reconciliation report with unmatched items</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 6: Update account reconciliation status</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Use fuzzy string matching for transaction descriptions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Consider date ranges (±3 days) for timing differences</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"distributed-consensus-core-logic\">Distributed Consensus Core Logic</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">go</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Core distributed consensus for scalable transaction posting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> ConsensusCoordinator</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    nodeID      </span><span style=\"color:#F97583\">string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    raftNode    </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">raft</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Raft</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fsm         </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LedgerStateMachine</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    transport   </span><span style=\"color:#B392F0\">raft</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Transport</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logStore    </span><span style=\"color:#B392F0\">raft</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">LogStore</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stableStore </span><span style=\"color:#B392F0\">raft</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">StableStore</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">type</span><span style=\"color:#B392F0\"> LedgerStateMachine</span><span style=\"color:#F97583\"> struct</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ledger </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">TransactionRecorder</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    audit  </span><span style=\"color:#B392F0\">AuditStorage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Apply implements raft.FSM for ledger operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">l </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">LedgerStateMachine</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">Apply</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">log</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">raft</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Log</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">interface</span><span style=\"color:#E1E4E8\">{} {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Deserialize log entry to determine operation type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Validate operation maintains accounting integrity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Apply operation to local ledger state atomically</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Update running balances if transaction posted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Return operation result for client response</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: All nodes must apply operations in identical order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Operations must be deterministic across all nodes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// PostEntryWithConsensus coordinates distributed transaction posting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">func</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">c </span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConsensusCoordinator</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">PostEntryWithConsensus</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">ctx</span><span style=\"color:#B392F0\"> context</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">Context</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">entry</span><span style=\"color:#F97583\"> *</span><span style=\"color:#B392F0\">JournalEntry</span><span style=\"color:#E1E4E8\">) (</span><span style=\"color:#F97583\">*</span><span style=\"color:#B392F0\">ConsensusResult</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">error</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 1: Serialize journal entry for consensus log</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 2: Submit operation to Raft cluster for agreement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 3: Wait for operation to be committed by majority</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 4: Return success when operation applied to state machine</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // TODO 5: Handle leader election and network partition scenarios</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // Hint: Only leader can accept writes, followers redirect to leader</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"extension-milestone-checkpoints\">Extension Milestone Checkpoints</h4>\n<p><strong>Advanced Reporting Milestone:</strong></p>\n<ul>\n<li>Run <code>go test ./internal/extensions/reporting/...</code> - all tests should pass</li>\n<li>Generate cash flow statement: <code>curl http://localhost:8080/reports/cashflow?period=2023Q4</code></li>\n<li>Verify statement shows Operating, Investing, and Financing sections with proper totals</li>\n<li>Create custom report template and verify it executes without errors</li>\n</ul>\n<p><strong>Workflow Engine Milestone:</strong></p>\n<ul>\n<li>Start approval workflow: POST entry with approval required, verify it enters PENDING status</li>\n<li>Test approval process: approve entry via API, verify it posts to ledger automatically</li>\n<li>Check notification delivery: verify emails sent to approvers and requestors</li>\n<li>Validate audit trail: confirm all workflow actions recorded with user attribution</li>\n</ul>\n<p><strong>Integration API Milestone:</strong></p>\n<ul>\n<li>Import bank statement: POST CSV file, verify transactions imported correctly</li>\n<li>Test ERP sync: push chart of accounts to external system and verify mapping</li>\n<li>Validate error handling: send malformed data, confirm graceful error responses</li>\n<li>Check rate limiting: make rapid API calls, verify throttling works correctly</li>\n</ul>\n<p><strong>Distributed Scaling Milestone:</strong></p>\n<ul>\n<li>Deploy multiple ledger nodes with consensus enabled</li>\n<li>Post transactions through different nodes, verify consistent ordering</li>\n<li>Test failover: stop leader node, verify new leader elected and operations continue</li>\n<li>Validate global consistency: run trial balance across all partitions, confirm zero variance</li>\n</ul>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> 1-5 (All milestones), as this section provides definitions of accounting and technical terms used throughout the double-entry ledger system design</p>\n</blockquote>\n<p>This glossary provides comprehensive definitions of accounting principles, technical concepts, and system terminology used throughout the double-entry ledger system design document. The terms are organized to build understanding from fundamental accounting concepts through advanced implementation details.</p>\n<p>Think of this glossary as your financial engineering dictionary - just as software engineers need precise definitions for technical terms like &quot;idempotency&quot; and &quot;atomic transactions,&quot; accounting systems require equally precise definitions for financial concepts like &quot;normal balance&quot; and &quot;trial balance.&quot; Each term builds upon others to create a coherent understanding of both accounting principles and their technical implementation.</p>\n<h3 id=\"core-accounting-concepts\">Core Accounting Concepts</h3>\n<p>The foundation of any accounting system rests on time-tested principles that have governed financial record-keeping for centuries. These concepts form the mathematical and logical framework that ensures financial integrity.</p>\n<p><strong>Double-Entry Bookkeeping</strong> is the fundamental accounting method where every financial transaction affects at least two accounts, and the total debits must always equal the total credits. This creates a self-balancing system that provides built-in error detection - if debits don&#39;t equal credits, you know something is wrong. The system acts like a mathematical proof where the accounting equation (Assets = Liabilities + Equity) must always balance.</p>\n<p><strong>Trial Balance</strong> serves as the primary verification report showing all account balances to confirm that total debits equal total credits across the entire ledger. Think of it as a mathematical checkpoint that proves the fundamental accounting equation holds true. The trial balance acts as both a validation tool and the foundation for generating financial statements.</p>\n<p><strong>Chart of Accounts</strong> represents the organized catalog of all accounts used by an organization, structured hierarchically to support both detailed transaction recording and summarized financial reporting. Each account has a unique code, descriptive name, and defined type that determines its normal balance and financial statement presentation.</p>\n<p><strong>Journal Entry</strong> constitutes the complete transaction record containing balanced debits and credits that document a specific business event. Each entry includes a description, reference information, posting date, and multiple line items that reference specific accounts with corresponding amounts.</p>\n<p><strong>Normal Balance</strong> defines whether an account type typically carries a debit or credit balance based on the fundamental accounting equation. Asset and expense accounts are debit-normal (increases recorded as debits), while liability, equity, and revenue accounts are credit-normal (increases recorded as credits).</p>\n<h3 id=\"account-type-system\">Account Type System</h3>\n<p>The account type system provides the structural foundation for organizing financial data according to established accounting principles and financial statement presentation requirements.</p>\n<table>\n<thead>\n<tr>\n<th>Account Type</th>\n<th>Normal Balance</th>\n<th>Financial Statement</th>\n<th>Examples</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ASSET</td>\n<td>Debit</td>\n<td>Balance Sheet</td>\n<td>Cash, Accounts Receivable, Equipment</td>\n</tr>\n<tr>\n<td>LIABILITY</td>\n<td>Credit</td>\n<td>Balance Sheet</td>\n<td>Accounts Payable, Loans, Accrued Expenses</td>\n</tr>\n<tr>\n<td>EQUITY</td>\n<td>Credit</td>\n<td>Balance Sheet</td>\n<td>Common Stock, Retained Earnings, Paid-in Capital</td>\n</tr>\n<tr>\n<td>REVENUE</td>\n<td>Credit</td>\n<td>Income Statement</td>\n<td>Sales Revenue, Service Income, Interest Income</td>\n</tr>\n<tr>\n<td>EXPENSE</td>\n<td>Debit</td>\n<td>Income Statement</td>\n<td>Salaries, Rent, Depreciation, Cost of Goods Sold</td>\n</tr>\n</tbody></table>\n<h3 id=\"transaction-processing-terminology\">Transaction Processing Terminology</h3>\n<p>Transaction processing concepts define how business events are recorded, validated, and posted to maintain ledger integrity and provide audit trails.</p>\n<p><strong>Posting</strong> represents the process of officially recording a journal entry in the ledger system, transitioning it from draft status to a permanent, immutable record. Once posted, entries cannot be modified - only reversed through offsetting entries.</p>\n<p><strong>Idempotency</strong> ensures that operations can be safely repeated without changing the result, preventing duplicate transactions when API calls are retried due to network timeouts or system failures. The system uses unique request keys to detect and prevent duplicate processing.</p>\n<p><strong>Atomic Transaction</strong> guarantees that database operations either complete entirely or fail entirely, preventing partial updates that could leave the ledger in an inconsistent state. This is crucial for maintaining the double-entry principle across multiple database tables.</p>\n<p><strong>Reversal Entry</strong> provides the mechanism for correcting posted transactions by creating an offsetting journal entry that cancels out the original entry without deleting historical records. This maintains the complete audit trail while fixing errors.</p>\n<p><strong>Validation Pipeline</strong> implements the multi-stage process for checking entry correctness before posting, including debit-credit balance verification, account existence validation, and business rule compliance checks.</p>\n<h3 id=\"balance-calculation-concepts\">Balance Calculation Concepts</h3>\n<p>Balance calculation terminology describes the methods and mechanisms used to efficiently compute and maintain account balances while supporting both current and historical reporting requirements.</p>\n<p><strong>Running Balance</strong> maintains continuously updated current balances for performance optimization, avoiding the need to sum all historical transactions for every balance inquiry. The system updates running balances automatically when new entries are posted.</p>\n<p><strong>Point-in-Time Balance</strong> calculates historical account balances for specific dates by considering only transactions posted on or before that date. This supports historical financial statement generation and audit requirements.</p>\n<p><strong>Balance Caching</strong> implements performance optimization through materialized balance tables and in-memory caches, reducing query response times for frequently accessed account balances while maintaining data consistency.</p>\n<p><strong>Cache Invalidation</strong> removes stale cached values when underlying transaction data changes, ensuring that cached balances remain consistent with the source ledger data. The system uses event-driven invalidation triggered by journal entry posting.</p>\n<p><strong>Balance Engine</strong> serves as the component responsible for efficient balance calculations, managing both current and historical balance queries while coordinating cache updates and invalidation.</p>\n<h3 id=\"audit-and-compliance-framework\">Audit and Compliance Framework</h3>\n<p>Audit and compliance terminology encompasses the mechanisms that ensure complete transaction traceability, data integrity, and regulatory compliance throughout the system lifecycle.</p>\n<p><strong>Immutable Audit Trail</strong> provides an unchangeable record of all transactions and system modifications, supporting regulatory compliance and forensic analysis. Once created, audit records cannot be modified or deleted.</p>\n<p><strong>Append-Only Ledger</strong> implements a storage system that only allows adding new records while preventing modification or deletion of existing entries. This design ensures that historical financial data remains intact and verifiable.</p>\n<p><strong>Hash Chain</strong> creates cryptographic linking where each audit record includes the hash of the previous record, enabling tamper detection and integrity verification. Breaking the chain indicates potential data corruption or unauthorized modification.</p>\n<p><strong>Change History Tracking</strong> maintains complete audit logs documenting who made what changes when, including before and after values for all modifications. This supports compliance requirements and forensic investigation.</p>\n<p><strong>Cryptographic Integrity</strong> provides tamper detection capabilities using hash chains and digital signatures to verify that audit records haven&#39;t been altered since creation. The system can detect any unauthorized changes to historical data.</p>\n<p><strong>Content Hash</strong> generates a fixed-size digest that uniquely identifies the content of a journal entry or audit record, enabling efficient integrity verification and duplicate detection.</p>\n<p><strong>Digital Signature</strong> offers cryptographic proof that data was created by an authorized system component, providing non-repudiation and authenticity verification for audit records.</p>\n<h3 id=\"financial-reporting-terminology\">Financial Reporting Terminology</h3>\n<p>Financial reporting concepts define the generation and presentation of standard financial statements and management reports from the underlying ledger data.</p>\n<p><strong>Balance Sheet</strong> presents point-in-time financial position showing that assets equal liabilities plus equity at a specific date. The report validates the fundamental accounting equation and provides stakeholders with a snapshot of organizational financial health.</p>\n<p><strong>Income Statement</strong> calculates period-based profit and loss from revenue and expense accounts over a specified time range. The report shows operational performance and determines net income that flows to the balance sheet.</p>\n<p><strong>Multi-Currency Translation</strong> converts foreign currency account balances using appropriate exchange rates for consolidated financial reporting in a single presentation currency. The system handles both transaction-date and period-end translation methods.</p>\n<p><strong>Accounting Period Closing</strong> executes the process of finalizing transactions for a reporting period and transferring temporary account balances (revenues and expenses) to permanent accounts (retained earnings). This creates a clean starting point for the next reporting period.</p>\n<p><strong>Period Activity</strong> measures the net change in account balances during a reporting period, calculated by comparing opening and closing balances while accounting for all transactions posted within the period.</p>\n<p><strong>Closing Entries</strong> are journal entries that transfer revenue and expense account balances to retained earnings at period end, resetting temporary accounts to zero for the next reporting period.</p>\n<h3 id=\"technical-architecture-concepts\">Technical Architecture Concepts</h3>\n<p>Technical architecture terminology describes the system design patterns, data structures, and algorithms that implement the accounting business rules with appropriate performance and reliability characteristics.</p>\n<p><strong>Optimistic Locking</strong> implements concurrency control using version numbers to detect conflicts when multiple processes attempt to modify the same data simultaneously. This prevents lost updates while allowing high concurrency for read operations.</p>\n<p><strong>Circuit Breaker</strong> protects against cascading failures by temporarily rejecting requests to failing downstream services, allowing systems to recover before resuming normal operations.</p>\n<p><strong>Two-Phase Commit</strong> ensures atomic transactions across multiple database resources by coordinating a voting phase followed by a commit phase, guaranteeing that either all participants commit or all abort.</p>\n<p><strong>Read Replica</strong> provides read-only database copies for distributing query load and improving read performance while maintaining a single authoritative source for writes.</p>\n<p><strong>Leader Election</strong> selects a single system instance for coordinating distributed operations, ensuring consistent decision-making across multiple nodes in a distributed deployment.</p>\n<p><strong>Exponential Backoff</strong> implements a retry strategy with increasing delays between attempts, preventing overwhelming of failing systems while allowing eventual recovery.</p>\n<p><strong>Point-in-Time Recovery</strong> enables restoration of the system to any previous consistent state, supporting disaster recovery and data correction scenarios.</p>\n<h3 id=\"performance-and-scalability-terms\">Performance and Scalability Terms</h3>\n<p>Performance terminology describes the mechanisms used to achieve efficient operations while maintaining correctness under varying load conditions.</p>\n<p><strong>Compensation Transaction Patterns</strong> implement reversal entries to undo partial multi-step operations when distributed transactions fail partway through execution.</p>\n<p><strong>Balance Consistency Verification</strong> compares cached balance values against freshly calculated values to detect and correct any inconsistencies that might arise from system failures or bugs.</p>\n<p><strong>Startup Integrity Verification</strong> performs systematic checking of critical system invariants before resuming normal operations after a restart or failure.</p>\n<p><strong>Fail-Safe Accounting Integrity</strong> ensures that the system never allows unbalanced entries or inconsistent state, even under failure conditions. The design prioritizes correctness over availability.</p>\n<h3 id=\"data-quality-and-validation\">Data Quality and Validation</h3>\n<p>Data quality terminology encompasses the mechanisms that ensure financial data accuracy, completeness, and compliance with accounting principles throughout the system lifecycle.</p>\n<p><strong>Accounting Equation</strong> represents the fundamental mathematical relationship (Assets = Liabilities + Equity) that must always remain balanced in a correctly functioning accounting system.</p>\n<p><strong>Accounting Invariant</strong> defines mathematical relationships or business rules that must always hold true regardless of the specific transactions processed or system operations performed.</p>\n<p><strong>Fixed-Point Arithmetic</strong> provides exact decimal calculations without floating-point precision errors, ensuring that monetary amounts maintain perfect accuracy through all calculations and aggregations.</p>\n<p><strong>Trial Balance Variance</strong> measures any difference between total debits and credits in the trial balance, which should always be zero in a correctly balanced ledger system.</p>\n<p><strong>Balance Discrepancy</strong> occurs when calculated account balances don&#39;t match expected values, indicating potential data corruption, calculation errors, or system bugs requiring investigation.</p>\n<p><strong>Unbalanced Entry</strong> represents a journal entry that violates the double-entry principle where total debits don&#39;t equal total credits, which the system must prevent from being posted.</p>\n<h3 id=\"testing-and-quality-assurance\">Testing and Quality Assurance</h3>\n<p>Testing terminology describes the comprehensive verification approaches used to ensure system correctness, performance, and reliability across all accounting operations.</p>\n<p><strong>Property-Based Testing</strong> uses automatically generated test data to verify that system invariants (like the accounting equation) hold true across a wide range of input scenarios and edge cases.</p>\n<p><strong>Test Oracle</strong> provides the mechanism for determining whether test results are correct, often by comparing against known mathematical relationships or business rules.</p>\n<p><strong>Integration Test</strong> verifies that multiple system components work together correctly to complete end-to-end workflows like journal entry posting and financial statement generation.</p>\n<p><strong>Unit Test</strong> focuses on individual components in isolation, verifying that each module correctly implements its specific responsibilities without dependencies on other system parts.</p>\n<h3 id=\"system-operations-and-maintenance\">System Operations and Maintenance</h3>\n<p>Operations terminology covers the ongoing management, monitoring, and maintenance activities required to keep the accounting system running reliably in production environments.</p>\n<p><strong>Cache Coherence</strong> ensures consistency between cached balance values and authoritative database values, preventing stale data from causing incorrect financial reports or decisions.</p>\n<p><strong>Concurrent Access Control</strong> implements mechanisms that prevent data corruption when multiple users or processes attempt to modify accounting data simultaneously.</p>\n<p><strong>Performance Profiling</strong> systematically measures system operation timing and resource usage to identify bottlenecks and optimization opportunities.</p>\n<p><strong>Root Cause Analysis</strong> provides investigation techniques for identifying the underlying source of system problems, data discrepancies, or performance issues.</p>\n<p><strong>Hash Chain Verification</strong> validates the cryptographic integrity of the complete audit record sequence to detect any unauthorized modifications to historical data.</p>\n<p><strong>Forensic Accounting</strong> applies specialized investigation techniques for analyzing financial data anomalies, potentially fraudulent transactions, or system integrity violations.</p>\n<p><strong>Compensating Entry</strong> creates a journal entry that corrects a previous error while maintaining the complete audit trail, providing transparency into the correction process.</p>\n<h3 id=\"advanced-features-and-extensions\">Advanced Features and Extensions</h3>\n<p>Advanced terminology describes sophisticated capabilities that extend beyond basic double-entry bookkeeping to support complex organizational requirements and modern business processes.</p>\n<p><strong>Cash Flow Statement</strong> tracks actual money movements through operating, investing, and financing activities, providing insight into organizational liquidity and cash management effectiveness.</p>\n<p><strong>Variance Analysis</strong> compares actual financial results against budgets, forecasts, or prior periods to identify performance differences and support management decision-making.</p>\n<p><strong>Custom Report Builder</strong> provides user interface capabilities allowing non-technical users to create tailored financial reports without requiring programming knowledge or IT support.</p>\n<p><strong>Multi-Level Approval Processes</strong> implement workflow systems requiring multiple authorization steps based on transaction amount, risk level, or organizational hierarchy before journal entries are posted.</p>\n<p><strong>Automated Posting Rules</strong> contain business logic that automatically generates journal entries from recognized transaction patterns, reducing manual data entry and improving consistency.</p>\n<p><strong>ERP Integration</strong> establishes connections between the ledger system and enterprise resource planning systems for seamless data synchronization and unified business process management.</p>\n<p><strong>Bank Feed Integration</strong> automates the import and matching of bank statement transactions with ledger entries, streamlining the reconciliation process and reducing manual effort.</p>\n<p><strong>Transaction Matching</strong> implements algorithmic processes for correlating bank transactions with corresponding journal entries based on amounts, dates, and reference information.</p>\n<p><strong>Workflow Engine</strong> manages multi-step approval processes with configurable business rules, delegation capabilities, and audit trails for complex organizational authorization requirements.</p>\n<p><strong>Rule Engine</strong> evaluates complex business conditions to determine approval requirements, posting rules, and validation criteria based on organizational policies and regulatory requirements.</p>\n<p><strong>Data Mapping</strong> translates between different chart of accounts structures when integrating with external systems that use different account coding schemes or organizational structures.</p>\n<p><strong>Conflict Resolution</strong> handles situations where simultaneous updates to the same data occur across multiple systems or users, ensuring data consistency and preventing lost updates.</p>\n<p><strong>Transaction Reconciliation</strong> matches and verifies transactions between different systems to ensure completeness and accuracy of financial data across integrated applications.</p>\n<p><strong>Event-Driven Architecture</strong> enables systems to communicate through published events, supporting loose coupling and scalable integration patterns for complex enterprise environments.</p>\n<p><strong>Horizontal Partitioning</strong> distributes ledger data across multiple databases or systems based on entity, business unit, or other criteria to support large-scale operations while maintaining data locality.</p>\n<p><strong>Distributed Consensus</strong> ensures that multiple nodes in a distributed system agree on transaction ordering and posting decisions, maintaining consistency across geographically distributed deployments.</p>\n<p><strong>Configuration Management</strong> provides systematic approaches for managing complex system settings, business rules, and organizational policies that govern ledger operations and reporting requirements.</p>\n<p><strong>Temporal Consistency</strong> guarantees that related data changes are visible together at any point in time, ensuring that financial statements reflect a consistent view of the organization&#39;s financial position.</p>\n<p><strong>Data Residency Controls</strong> ensure that financial data remains within required geographic boundaries to comply with local regulations and organizational data governance policies.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Understanding these terms is essential for implementing a robust double-entry ledger system. The terminology provides the shared vocabulary needed for clear communication between business stakeholders, system architects, and implementation teams.</p>\n<p>When implementing the system, developers should reference these definitions to ensure consistent interpretation of business requirements and technical specifications. The terms form a hierarchy where fundamental accounting concepts support advanced technical implementations, and each component builds upon the foundational principles established by double-entry bookkeeping.</p>\n<p>The glossary serves as both a learning resource for new team members and a reference guide for experienced developers working on system enhancements or integrations. Understanding the precise meaning of each term enables more effective system design decisions and clearer documentation of business rules and technical requirements.</p>\n<p>Regular review of these definitions helps maintain consistency across development teams and ensures that the implemented system accurately reflects the intended accounting principles and business requirements. The terms also provide the vocabulary needed for effective communication with accounting professionals, auditors, and regulatory compliance teams.</p>\n","toc":[{"level":1,"text":"Double-Entry Ledger System: Design Document","id":"double-entry-ledger-system-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Double-Entry Accounting Mental Model","id":"double-entry-accounting-mental-model"},{"level":3,"text":"Existing Accounting System Approaches","id":"existing-accounting-system-approaches"},{"level":3,"text":"Core Technical Challenges","id":"core-technical-challenges"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Functional Requirements","id":"functional-requirements"},{"level":4,"text":"Core Double-Entry Bookkeeping Operations","id":"core-double-entry-bookkeeping-operations"},{"level":4,"text":"Balance Calculation and Inquiry System","id":"balance-calculation-and-inquiry-system"},{"level":4,"text":"Financial Reporting Capabilities","id":"financial-reporting-capabilities"},{"level":3,"text":"Non-Functional Requirements","id":"non-functional-requirements"},{"level":4,"text":"Performance and Scalability Requirements","id":"performance-and-scalability-requirements"},{"level":4,"text":"Reliability and Data Integrity Requirements","id":"reliability-and-data-integrity-requirements"},{"level":4,"text":"Security and Compliance Requirements","id":"security-and-compliance-requirements"},{"level":3,"text":"Explicit Non-Goals","id":"explicit-non-goals"},{"level":4,"text":"Business Process Automation (Explicitly Excluded)","id":"business-process-automation-explicitly-excluded"},{"level":4,"text":"Tax Calculation and Compliance (Explicitly Excluded)","id":"tax-calculation-and-compliance-explicitly-excluded"},{"level":4,"text":"User Interface and Experience Features (Explicitly Excluded)","id":"user-interface-and-experience-features-explicitly-excluded"},{"level":4,"text":"Advanced Financial Analytics (Explicitly Excluded)","id":"advanced-financial-analytics-explicitly-excluded"},{"level":3,"text":"Requirements Validation and Success Criteria","id":"requirements-validation-and-success-criteria"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Core Requirements Implementation Structure","id":"core-requirements-implementation-structure"},{"level":4,"text":"Requirements-Driven Type Definitions","id":"requirements-driven-type-definitions"},{"level":4,"text":"Requirements Validation Implementation","id":"requirements-validation-implementation"},{"level":4,"text":"Performance Requirements Implementation","id":"performance-requirements-implementation"},{"level":4,"text":"Milestone Verification Checkpoints","id":"milestone-verification-checkpoints"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Component Responsibilities","id":"component-responsibilities"},{"level":4,"text":"Account Management Component","id":"account-management-component"},{"level":4,"text":"Transaction Recording Engine","id":"transaction-recording-engine"},{"level":4,"text":"Balance Calculation Engine","id":"balance-calculation-engine"},{"level":4,"text":"Audit Trail System","id":"audit-trail-system"},{"level":4,"text":"Financial Reporting Module","id":"financial-reporting-module"},{"level":3,"text":"Recommended Module Structure","id":"recommended-module-structure"},{"level":3,"text":"Component Dependencies","id":"component-dependencies"},{"level":4,"text":"Core Dependency Flow","id":"core-dependency-flow"},{"level":4,"text":"Interface-Based Communication","id":"interface-based-communication"},{"level":4,"text":"Event-Driven Updates","id":"event-driven-updates"},{"level":4,"text":"Data Flow Patterns","id":"data-flow-patterns"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":4,"text":"⚠️ Pitfall: Circular Dependencies Between Components","id":"-pitfall-circular-dependencies-between-components"},{"level":4,"text":"⚠️ Pitfall: Mixing Component Responsibilities","id":"-pitfall-mixing-component-responsibilities"},{"level":4,"text":"⚠️ Pitfall: Synchronous Cross-Component Operations","id":"-pitfall-synchronous-cross-component-operations"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure Implementation","id":"recommended-file-structure-implementation"},{"level":4,"text":"Core Component Interface Skeletons","id":"core-component-interface-skeletons"},{"level":4,"text":"Language-Specific Implementation Hints","id":"language-specific-implementation-hints"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Chart of Accounts Structure","id":"chart-of-accounts-structure"},{"level":3,"text":"Journal Entry Schema","id":"journal-entry-schema"},{"level":3,"text":"Monetary Amount Handling","id":"monetary-amount-handling"},{"level":3,"text":"Audit Trail Schema","id":"audit-trail-schema"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Account Management Component","id":"account-management-component"},{"level":3,"text":"Account Type System","id":"account-type-system"},{"level":3,"text":"Account Hierarchy Management","id":"account-hierarchy-management"},{"level":3,"text":"Account Validation Rules","id":"account-validation-rules"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Transaction Recording Engine","id":"transaction-recording-engine"},{"level":3,"text":"Journal Entry Validation","id":"journal-entry-validation"},{"level":3,"text":"Atomic Transaction Posting","id":"atomic-transaction-posting"},{"level":3,"text":"Idempotency and Duplicate Prevention","id":"idempotency-and-duplicate-prevention"},{"level":3,"text":"Entry Reversal Mechanism","id":"entry-reversal-mechanism"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"A. Technology Recommendations","id":"a-technology-recommendations"},{"level":4,"text":"B. Recommended File/Module Structure","id":"b-recommended-filemodule-structure"},{"level":4,"text":"C. Infrastructure Starter Code","id":"c-infrastructure-starter-code"},{"level":4,"text":"D. Core Logic Skeleton Code","id":"d-core-logic-skeleton-code"},{"level":4,"text":"E. Language-Specific Hints","id":"e-language-specific-hints"},{"level":4,"text":"F. Milestone Checkpoints","id":"f-milestone-checkpoints"},{"level":4,"text":"G. Debugging Tips","id":"g-debugging-tips"},{"level":2,"text":"Balance Calculation Engine","id":"balance-calculation-engine"},{"level":3,"text":"Running Balance Maintenance","id":"running-balance-maintenance"},{"level":3,"text":"Point-in-Time Balance Queries","id":"point-in-time-balance-queries"},{"level":3,"text":"Trial Balance Validation","id":"trial-balance-validation"},{"level":3,"text":"Balance Caching Strategy","id":"balance-caching-strategy"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Audit Trail System","id":"audit-trail-system"},{"level":3,"text":"Immutable Entry Storage","id":"immutable-entry-storage"},{"level":3,"text":"Change History Tracking","id":"change-history-tracking"},{"level":3,"text":"Cryptographic Integrity","id":"cryptographic-integrity"},{"level":3,"text":"Audit Report Generation","id":"audit-report-generation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Financial Reporting Module","id":"financial-reporting-module"},{"level":3,"text":"Trial Balance Report","id":"trial-balance-report"},{"level":3,"text":"Balance Sheet Generation","id":"balance-sheet-generation"},{"level":3,"text":"Income Statement Generation","id":"income-statement-generation"},{"level":3,"text":"Multi-Currency Report Translation","id":"multi-currency-report-translation"},{"level":3,"text":"Accounting Period Closing","id":"accounting-period-closing"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Component API Interfaces","id":"component-api-interfaces"},{"level":3,"text":"Transaction Recording Workflow","id":"transaction-recording-workflow"},{"level":3,"text":"Report Generation Workflow","id":"report-generation-workflow"},{"level":3,"text":"Concurrent Access Patterns","id":"concurrent-access-patterns"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Validation Error Handling","id":"validation-error-handling"},{"level":3,"text":"Partial Failure Recovery","id":"partial-failure-recovery"},{"level":3,"text":"Data Corruption Detection","id":"data-corruption-detection"},{"level":3,"text":"System Failure Recovery","id":"system-failure-recovery"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure: Validation Framework","id":"infrastructure-validation-framework"},{"level":4,"text":"Infrastructure: Transaction Management","id":"infrastructure-transaction-management"},{"level":4,"text":"Core Logic: Integrity Monitoring","id":"core-logic-integrity-monitoring"},{"level":4,"text":"Core Logic: System Recovery","id":"core-logic-system-recovery"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Unit Testing Approach","id":"unit-testing-approach"},{"level":3,"text":"Integration Testing Strategy","id":"integration-testing-strategy"},{"level":3,"text":"Property-Based Testing","id":"property-based-testing"},{"level":3,"text":"Milestone Verification Checkpoints","id":"milestone-verification-checkpoints"},{"level":3,"text":"Common Testing Pitfalls","id":"common-testing-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Balance Discrepancy Diagnosis","id":"balance-discrepancy-diagnosis"},{"level":4,"text":"Systematic Balance Investigation Process","id":"systematic-balance-investigation-process"},{"level":4,"text":"Common Balance Discrepancy Patterns","id":"common-balance-discrepancy-patterns"},{"level":4,"text":"Balance Debugging Workflow Tables","id":"balance-debugging-workflow-tables"},{"level":3,"text":"Unbalanced Entry Detection","id":"unbalanced-entry-detection"},{"level":4,"text":"Unbalanced Entry Detection Algorithms","id":"unbalanced-entry-detection-algorithms"},{"level":4,"text":"Systematic Unbalanced Entry Investigation","id":"systematic-unbalanced-entry-investigation"},{"level":4,"text":"Unbalanced Entry Correction Procedures","id":"unbalanced-entry-correction-procedures"},{"level":4,"text":"Preventing Future Unbalanced Entries","id":"preventing-future-unbalanced-entries"},{"level":3,"text":"Performance Problem Diagnosis","id":"performance-problem-diagnosis"},{"level":4,"text":"Performance Measurement Framework","id":"performance-measurement-framework"},{"level":4,"text":"Common Performance Bottlenecks","id":"common-performance-bottlenecks"},{"level":4,"text":"Systematic Performance Investigation Process","id":"systematic-performance-investigation-process"},{"level":4,"text":"Performance Debugging Tools and Techniques","id":"performance-debugging-tools-and-techniques"},{"level":3,"text":"Audit Trail Troubleshooting","id":"audit-trail-troubleshooting"},{"level":4,"text":"Audit Trail Integrity Verification","id":"audit-trail-integrity-verification"},{"level":4,"text":"Common Audit Trail Failure Patterns","id":"common-audit-trail-failure-patterns"},{"level":4,"text":"Systematic Audit Trail Investigation Process","id":"systematic-audit-trail-investigation-process"},{"level":4,"text":"Audit Trail Recovery and Remediation","id":"audit-trail-recovery-and-remediation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Balance Debugger Infrastructure","id":"balance-debugger-infrastructure"},{"level":4,"text":"Entry Validation Infrastructure","id":"entry-validation-infrastructure"},{"level":4,"text":"Performance Profiler Infrastructure","id":"performance-profiler-infrastructure"},{"level":4,"text":"Audit Trail Verifier Infrastructure","id":"audit-trail-verifier-infrastructure"},{"level":4,"text":"Debugging CLI Tool Implementation","id":"debugging-cli-tool-implementation"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Advanced Reporting Features","id":"advanced-reporting-features"},{"level":3,"text":"Workflow and Approval Systems","id":"workflow-and-approval-systems"},{"level":3,"text":"External System Integration","id":"external-system-integration"},{"level":3,"text":"Scalability and Distribution","id":"scalability-and-distribution"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Extension Structure","id":"recommended-extension-structure"},{"level":4,"text":"Workflow Engine Infrastructure","id":"workflow-engine-infrastructure"},{"level":4,"text":"Bank Feed Integration Starter","id":"bank-feed-integration-starter"},{"level":4,"text":"Distributed Consensus Core Logic","id":"distributed-consensus-core-logic"},{"level":4,"text":"Extension Milestone Checkpoints","id":"extension-milestone-checkpoints"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Core Accounting Concepts","id":"core-accounting-concepts"},{"level":3,"text":"Account Type System","id":"account-type-system"},{"level":3,"text":"Transaction Processing Terminology","id":"transaction-processing-terminology"},{"level":3,"text":"Balance Calculation Concepts","id":"balance-calculation-concepts"},{"level":3,"text":"Audit and Compliance Framework","id":"audit-and-compliance-framework"},{"level":3,"text":"Financial Reporting Terminology","id":"financial-reporting-terminology"},{"level":3,"text":"Technical Architecture Concepts","id":"technical-architecture-concepts"},{"level":3,"text":"Performance and Scalability Terms","id":"performance-and-scalability-terms"},{"level":3,"text":"Data Quality and Validation","id":"data-quality-and-validation"},{"level":3,"text":"Testing and Quality Assurance","id":"testing-and-quality-assurance"},{"level":3,"text":"System Operations and Maintenance","id":"system-operations-and-maintenance"},{"level":3,"text":"Advanced Features and Extensions","id":"advanced-features-and-extensions"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"}],"title":"Double-Entry Ledger System: Design Document","markdown":"# Double-Entry Ledger System: Design Document\n\n\n## Overview\n\nA double-entry accounting system that ensures financial transaction integrity through balanced journal entries where every debit equals total credits. The key architectural challenge is maintaining immutable audit trails while providing efficient balance calculations and real-time financial reporting across multiple currencies.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n> **Milestone(s):** All milestones, as this section provides foundational understanding for the entire system\n\n## Context and Problem Statement\n\nBuilding a reliable accounting system requires understanding not just the technical implementation, but the fundamental principles that make financial systems trustworthy. Double-entry bookkeeping, invented over 500 years ago, remains the backbone of modern financial systems because it provides built-in error detection and mathematical proof that transactions are recorded correctly. However, implementing these time-tested accounting principles in modern software systems introduces unique technical challenges around data consistency, immutability, performance, and regulatory compliance.\n\n### Double-Entry Accounting Mental Model\n\nThink of double-entry accounting like a **perfectly balanced scale** where every financial transaction must affect at least two sides, and the total weight on both sides must always remain equal. When you record a business transaction, you're not just noting that money moved—you're documenting the complete story of value exchange by showing exactly where value came from and where it went.\n\nConsider a simple analogy: when you buy coffee with cash, three things happen simultaneously in the business's accounting system. First, the business gains an asset (your cash payment). Second, the business loses an asset (the coffee beans, milk, and other inventory). Third, the business recognizes revenue (the profit from the sale). Each of these effects must be recorded as separate accounting entries, and the mathematical relationship between them provides automatic error checking—if the entries don't balance, something was recorded incorrectly.\n\nThe **fundamental equation** that governs all double-entry systems is: **Assets = Liabilities + Equity**. This equation must hold true after every transaction, providing a built-in consistency check. Every business transaction can be viewed as an exchange that maintains this equilibrium. When a company borrows money from a bank, assets increase (cash received) and liabilities increase (debt owed) by exactly the same amount. When the company later repays the loan, both sides decrease equally.\n\n**Debits and credits** are the mechanism for recording these balanced exchanges, but they're often misunderstood because their meaning differs from everyday language. In accounting, \"debit\" simply means \"left side of the ledger\" and \"credit\" means \"right side of the ledger.\" Different account types have different relationships to debits and credits based on their **normal balance**:\n\n| Account Type | Normal Balance | Increases With | Decreases With | Examples |\n|--------------|----------------|----------------|----------------|----------|\n| Assets | Debit | Debits | Credits | Cash, Equipment, Inventory |\n| Liabilities | Credit | Credits | Debits | Loans, Accounts Payable |\n| Equity | Credit | Credits | Debits | Owner Investment, Retained Earnings |\n| Revenue | Credit | Credits | Debits | Sales, Service Income |\n| Expenses | Debit | Debits | Credits | Rent, Salaries, Utilities |\n\nThe power of this system becomes clear when you realize that **every transaction tells a complete story**. A journal entry recording the coffee shop sale might look like:\n\n| Account | Debit | Credit | Explanation |\n|---------|-------|--------|-------------|\n| Cash | $5.00 | | Asset increases (customer payment) |\n| Inventory | | $1.50 | Asset decreases (coffee beans used) |\n| Revenue | | $3.50 | Revenue recognized (profit earned) |\n| **Totals** | **$5.00** | **$5.00** | **Balanced** |\n\nThis transaction maintains the fundamental equation: assets increased by $3.50 net ($5.00 cash in, $1.50 inventory out), and equity increased by $3.50 (revenue). The business is $3.50 better off, and the accounting entries prove it mathematically.\n\n**Multi-currency transactions** extend this model by requiring additional metadata about exchange rates and base currency conversions, but the fundamental balancing principle remains unchanged. If a U.S. company purchases inventory from a European supplier for €1,000 when the exchange rate is 1.10 USD/EUR, the transaction records $1,100 in inventory (debit) and $1,100 in accounts payable (credit), along with the original currency amounts for future reference.\n\nThe **immutability principle** in double-entry accounting means that once a transaction is posted (officially recorded), it cannot be modified or deleted. Mistakes are corrected by creating **reversing entries** that exactly offset the original error, followed by new entries recording the correct transaction. This creates an audit trail showing what was originally recorded, what was wrong, and how it was fixed—crucial for regulatory compliance and fraud detection.\n\n### Existing Accounting System Approaches\n\nModern accounting systems fall into several architectural categories, each with distinct trade-offs for reliability, performance, and complexity. Understanding these approaches helps inform design decisions for building a new ledger system.\n\n**Single-Entry vs Double-Entry Systems**\n\nSingle-entry accounting systems record each transaction once, typically in a chronological list similar to a checkbook register. While simpler to implement and understand, single-entry systems lack the built-in error detection and completeness validation that make double-entry systems suitable for business accounting.\n\n| Aspect | Single-Entry | Double-Entry |\n|--------|--------------|--------------|\n| Error Detection | Manual reconciliation required | Automatic through trial balance |\n| Completeness | Cannot verify all effects captured | Mathematical proof of completeness |\n| Financial Reports | Limited to cash flow | Full financial statements possible |\n| Audit Trail | Transaction sequence only | Complete value flow documentation |\n| Regulatory Compliance | Insufficient for most jurisdictions | Meets accounting standards |\n| Implementation Complexity | Low | Higher but manageable |\n\n> **Decision: Double-Entry Architecture**\n> - **Context**: Need to build a production-ready accounting system that meets business and regulatory requirements\n> - **Options Considered**: Single-entry for simplicity, double-entry for completeness, hybrid approach\n> - **Decision**: Full double-entry system with trial balance validation\n> - **Rationale**: Built-in error detection and regulatory compliance requirements outweigh implementation complexity. Single-entry systems cannot provide the financial reporting capabilities needed for business use.\n> - **Consequences**: Higher implementation complexity but significantly better data integrity and audit capabilities\n\n**Traditional vs Modern Ledger Architectures**\n\nTraditional accounting systems were designed for batch processing with end-of-day posting cycles and periodic reconciliation. Modern systems increasingly require real-time balance updates and immediate consistency checking, leading to different architectural approaches.\n\n**Batch-Processing Architecture** follows the traditional accounting model where transactions are collected throughout the day and posted in batches during off-peak hours. This approach simplifies consistency management and allows for human review before posting, but delays balance updates and financial reporting.\n\n**Real-Time Processing Architecture** posts transactions immediately as they occur, providing up-to-date balances and enabling real-time financial reporting. However, this requires more sophisticated concurrency control and consistency management.\n\n**Event Sourcing Architecture** stores all changes as a sequence of immutable events rather than updating records in place. This provides perfect audit trails and enables time-travel queries, but can have performance implications for balance calculations.\n\n| Architecture | Consistency Model | Balance Updates | Audit Trail | Performance | Best For |\n|--------------|------------------|-----------------|-------------|-------------|----------|\n| Batch Processing | Eventually consistent | Delayed | Good | High throughput | Traditional businesses |\n| Real-Time | Strong consistency | Immediate | Good | Variable | Modern applications |\n| Event Sourcing | Immutable events | Calculated | Perfect | Read-heavy | High compliance needs |\n| Hybrid | Configurable | Configurable | Excellent | Balanced | Most production systems |\n\n> **Decision: Real-Time with Event Sourcing Elements**\n> - **Context**: Modern applications require immediate balance updates while maintaining audit compliance\n> - **Options Considered**: Pure batch processing, pure real-time, event sourcing, hybrid approach\n> - **Decision**: Real-time posting with immutable journal entries and comprehensive audit logging\n> - **Rationale**: Immediate consistency meets user expectations while immutable entries satisfy audit requirements. Event sourcing for transactions combined with materialized balance views provides both auditability and performance.\n> - **Consequences**: More complex concurrency control but better user experience and audit compliance\n\n**Database Architecture Choices**\n\nThe choice of database architecture significantly impacts the accounting system's consistency guarantees, performance characteristics, and operational complexity.\n\n**Relational Database Architecture** uses traditional ACID transactions to maintain consistency across normalized tables. This approach provides strong consistency guarantees and is well-understood by developers, but can have performance limitations under high transaction volumes.\n\n**NoSQL with Application-Level Consistency** moves consistency logic into the application layer, potentially improving performance but requiring careful design to maintain accounting accuracy.\n\n**Distributed Ledger Architecture** replicates the ledger across multiple nodes with consensus protocols ensuring all nodes agree on transaction ordering. This provides high availability and audit transparency but introduces significant complexity.\n\n| Architecture | Consistency | Performance | Complexity | Audit Trail | Recovery |\n|--------------|-------------|-------------|------------|-------------|-----------|\n| Single RDBMS | ACID guaranteed | Limited by single node | Low | Database logs | Backup/restore |\n| Replicated RDBMS | ACID with lag | Better read performance | Medium | Multiple copies | Failover supported |\n| Sharded RDBMS | Eventual consistency | High performance | High | Complex aggregation | Complex recovery |\n| NoSQL Document | Application-managed | Very high | Medium-High | Application-dependent | Variable |\n| Distributed Ledger | Consensus-based | Variable | Very high | Cryptographically secure | Byzantine fault tolerant |\n\n> **Decision: Single RDBMS with Read Replicas**\n> - **Context**: Need strong consistency for financial data while supporting read-heavy reporting workloads\n> - **Options Considered**: Single database, master-slave replication, sharding, NoSQL, blockchain\n> - **Decision**: PostgreSQL primary with read replicas for reporting\n> - **Rationale**: ACID transactions essential for financial accuracy. Read replicas handle reporting load without compromising primary database performance. Proven technology with excellent consistency guarantees.\n> - **Consequences**: Single point of failure for writes, but high availability solutions available. Strong consistency guaranteed but write scalability limited.\n\n### Core Technical Challenges\n\nBuilding a reliable accounting system involves solving several interconnected technical challenges that go beyond typical application development. Each challenge has specific implications for system architecture and implementation approach.\n\n**Data Consistency and Integrity**\n\nFinancial data consistency requirements exceed those of most applications because mathematical errors in accounting can have serious legal and business consequences. The system must maintain multiple levels of consistency simultaneously.\n\n**Transaction-Level Consistency** ensures that individual journal entries balance (total debits equal total credits) and cannot be recorded in an incomplete state. This requires atomic database transactions that either record all line items or none of them.\n\n**Account-Level Consistency** maintains accurate running balances for each account as transactions are posted. Balance updates must be synchronized with transaction posting to prevent temporary inconsistencies that could affect financial reports.\n\n**Cross-Account Consistency** ensures that the fundamental accounting equation (Assets = Liabilities + Equity) holds across all accounts at all times. This requires validation that spans multiple database tables and accounts.\n\n**Multi-Currency Consistency** adds complexity when dealing with foreign exchange transactions. The system must maintain consistency in both the original transaction currency and the reporting currency, requiring careful handling of exchange rate conversions and rounding differences.\n\n| Consistency Level | Validation Points | Failure Recovery | Performance Impact |\n|------------------|------------------|------------------|-------------------|\n| Transaction | Before posting each entry | Rollback incomplete entry | Low |\n| Account Balance | After each transaction | Recalculate from journal | Medium |\n| Trial Balance | Periodic validation | Identify and correct errors | High |\n| Multi-Currency | Currency conversion points | Re-apply exchange rates | Variable |\n\n**Immutable Audit Requirements**\n\nRegulatory compliance and fraud prevention require that posted accounting transactions cannot be modified or deleted. This immutability requirement conflicts with typical application development practices where data can be updated freely.\n\n**Append-Only Transaction Storage** means that journal entries, once posted, can only be corrected through additional reversing entries. The database schema must prevent UPDATE and DELETE operations on posted transactions while allowing normal CRUD operations on draft entries.\n\n**Change History Tracking** requires comprehensive logging of who made what changes when, including attempts to modify posted entries. Every field change must be recorded with timestamps, user identification, and before/after values.\n\n**Cryptographic Integrity** may be required for high-security environments, using hash chains or digital signatures to detect tampering with historical records. This adds computational overhead but provides mathematical proof of data integrity.\n\n**Retention and Archival** policies must balance regulatory requirements (often 7+ years) with database performance. Old transactions cannot be deleted but may need to be moved to archival storage to maintain query performance.\n\n| Audit Requirement | Implementation Approach | Storage Overhead | Query Impact |\n|-------------------|------------------------|------------------|--------------|\n| Immutable Entries | Database constraints | None | None |\n| Change History | Audit log tables | 2-3x storage | Minimal |\n| Cryptographic Proof | Hash chains | 10-20% | Low |\n| Long-term Retention | Tiered storage | Variable | Read latency |\n\n**Performance at Scale**\n\nAccounting systems must handle increasing transaction volumes while maintaining consistent response times for balance queries and report generation. Performance challenges compound as data volume grows over time.\n\n**Balance Calculation Performance** becomes critical as accounts accumulate thousands or millions of transactions. Recalculating balances from scratch for each query becomes prohibitively expensive, requiring caching strategies that maintain consistency with new transactions.\n\n**Concurrent Access Patterns** in accounting systems typically involve many read operations (balance queries, reports) and fewer write operations (transaction posting). However, write operations must maintain strong consistency while not blocking read operations unnecessarily.\n\n**Report Generation Scalability** challenges arise when financial reports must aggregate data across thousands of accounts and millions of transactions. These operations can be memory-intensive and time-consuming without proper indexing and query optimization.\n\n**Historical Data Growth** means that database size grows continuously without natural pruning points. Query performance must remain acceptable even as tables contain years of historical data.\n\n| Performance Challenge | Typical Scale | Mitigation Strategy | Trade-offs |\n|----------------------|---------------|-------------------|------------|\n| Balance Queries | Sub-second response | Materialized balance tables | Storage overhead |\n| Concurrent Transactions | 100s per second | Optimistic locking | Retry complexity |\n| Report Generation | Minutes acceptable | Indexed aggregation queries | Index maintenance cost |\n| Data Retention | Years of history | Partitioning by date | Query complexity |\n\n**Regulatory Compliance and Standards**\n\nAccounting systems must comply with various financial reporting standards and regulatory requirements that constrain technical design choices.\n\n**Generally Accepted Accounting Principles (GAAP)** and **International Financial Reporting Standards (IFRS)** define how financial transactions must be recorded and reported. These standards influence database schema design, validation rules, and report generation logic.\n\n**Sarbanes-Oxley (SOX) Compliance** in the United States requires specific internal controls and audit trails for public companies. Technical systems must support segregation of duties, approval workflows, and comprehensive change logging.\n\n**Data Privacy Regulations** like GDPR create tension with accounting immutability requirements. The system must maintain transaction integrity while potentially supporting data anonymization or deletion requests.\n\n**Industry-Specific Requirements** may impose additional constraints. Banking systems must comply with Basel III capital requirements, while healthcare organizations must meet HIPAA privacy standards alongside accounting accuracy.\n\n| Compliance Area | Technical Requirements | Implementation Complexity | Ongoing Burden |\n|-----------------|----------------------|---------------------------|----------------|\n| GAAP/IFRS | Standard chart of accounts | Medium | Periodic updates |\n| SOX Controls | Approval workflows, audit logs | High | Continuous monitoring |\n| Data Privacy | Anonymization capabilities | High | Request processing |\n| Industry Specific | Custom validations | Variable | Regulatory changes |\n\n**Error Handling and Recovery**\n\nFinancial systems require sophisticated error handling because accounting mistakes can have serious business and legal consequences. The system must detect, prevent, and recover from various failure modes.\n\n**Data Corruption Detection** must identify when database integrity has been compromised, either through hardware failures, software bugs, or malicious activity. This requires checksum validation, consistency checking, and anomaly detection.\n\n**Partial Failure Recovery** handles situations where multi-step operations fail partway through completion. For example, if posting a journal entry succeeds but updating account balances fails, the system must either complete the operation or roll back completely.\n\n**Concurrency Conflict Resolution** manages situations where multiple users attempt to modify related data simultaneously. The system must either prevent conflicts through locking or resolve them through retry mechanisms.\n\n**Business Rule Violation Handling** deals with attempts to create invalid transactions, such as posting to closed accounting periods or creating unbalanced journal entries. The system must validate business rules consistently and provide clear error messages.\n\n| Error Category | Detection Method | Recovery Strategy | Prevention Approach |\n|----------------|------------------|-------------------|-------------------|\n| Data Corruption | Checksums, constraints | Restore from backup | Redundancy, validation |\n| Partial Failures | Transaction logs | Rollback or complete | Atomic operations |\n| Concurrency Conflicts | Version numbers | Optimistic retry | Lock ordering |\n| Business Rule Violations | Validation rules | User correction | Input validation |\n\n> The fundamental insight is that accounting systems must be designed as **correctness-first systems** where data integrity takes precedence over performance optimization. Every technical decision must consider its impact on financial accuracy and audit compliance.\n\n### Implementation Guidance\n\nBuilding a double-entry ledger system requires careful selection of technologies and architectural patterns that support the unique requirements of financial systems. This guidance provides concrete recommendations for implementing the concepts described above.\n\n**A. Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Database | PostgreSQL with ACID transactions | PostgreSQL with streaming replication |\n| Web Framework | Go standard library net/http | Gin or Echo web framework |\n| JSON Processing | Go standard library encoding/json | Custom JSON schema validation |\n| Decimal Arithmetic | shopspring/decimal package | Custom fixed-point arithmetic |\n| Logging | Go standard library log | Structured logging with logrus or zap |\n| Testing | Go standard library testing | Property-based testing with gopter |\n| Configuration | Environment variables | Viper configuration management |\n| Database Migration | golang-migrate/migrate | Custom migration framework |\n\n**B. Recommended File/Module Structure**\n\n```\nledger-system/\n├── cmd/\n│   ├── ledger-server/\n│   │   └── main.go                 # Application entry point\n│   └── ledger-cli/\n│       └── main.go                 # CLI tools for administration\n├── internal/\n│   ├── accounts/\n│   │   ├── account.go              # Account domain model\n│   │   ├── manager.go              # Account management business logic\n│   │   ├── repository.go           # Account data access interface\n│   │   └── postgres_repository.go  # PostgreSQL account storage\n│   ├── transactions/\n│   │   ├── journal_entry.go        # Journal entry domain model\n│   │   ├── recorder.go             # Transaction recording business logic\n│   │   ├── validator.go            # Double-entry validation logic\n│   │   └── repository.go           # Transaction data access interface\n│   ├── balances/\n│   │   ├── calculator.go           # Balance calculation engine\n│   │   ├── cache.go                # Balance caching strategies\n│   │   └── repository.go           # Balance storage interface\n│   ├── audit/\n│   │   ├── trail.go                # Audit trail recording\n│   │   ├── integrity.go            # Hash chain validation\n│   │   └── repository.go           # Audit log storage\n│   ├── reports/\n│   │   ├── generator.go            # Financial report generation\n│   │   ├── trial_balance.go        # Trial balance calculation\n│   │   └── financial_statements.go # Balance sheet and income statement\n│   ├── currency/\n│   │   ├── money.go                # Multi-currency money type\n│   │   ├── exchange_rates.go       # Exchange rate management\n│   │   └── converter.go            # Currency conversion logic\n│   └── common/\n│       ├── decimal.go              # Decimal arithmetic utilities\n│       ├── database.go             # Database connection management\n│       └── errors.go               # Custom error types\n├── pkg/\n│   └── api/\n│       ├── handlers.go             # HTTP API handlers\n│       ├── middleware.go           # Authentication and logging middleware\n│       └── types.go                # API request/response types\n├── migrations/\n│   ├── 001_create_accounts.up.sql\n│   ├── 002_create_journal_entries.up.sql\n│   └── 003_create_audit_trail.up.sql\n├── scripts/\n│   ├── setup-db.sh                 # Database initialization script\n│   └── run-tests.sh                # Test execution script\n└── docker/\n    ├── Dockerfile\n    └── docker-compose.yml          # Development environment\n```\n\n**C. Infrastructure Starter Code**\n\nHere's complete infrastructure code for decimal arithmetic handling, which is critical for financial accuracy:\n\n```go\n// internal/common/decimal.go\npackage common\n\nimport (\n    \"database/sql/driver\"\n    \"fmt\"\n    \"github.com/shopspring/decimal\"\n    \"strconv\"\n)\n\n// Money represents a monetary amount with fixed-point precision\ntype Money struct {\n    Amount   decimal.Decimal `json:\"amount\"`\n    Currency string          `json:\"currency\"`\n}\n\n// NewMoney creates a new Money value from a float64 amount and currency code\nfunc NewMoney(amount float64, currency string) Money {\n    return Money{\n        Amount:   decimal.NewFromFloat(amount),\n        Currency: currency,\n    }\n}\n\n// NewMoneyFromString creates Money from a string representation\nfunc NewMoneyFromString(amount, currency string) (Money, error) {\n    amt, err := decimal.NewFromString(amount)\n    if err != nil {\n        return Money{}, fmt.Errorf(\"invalid amount %s: %w\", amount, err)\n    }\n    return Money{Amount: amt, Currency: currency}, nil\n}\n\n// Add returns the sum of two Money values (must be same currency)\nfunc (m Money) Add(other Money) (Money, error) {\n    if m.Currency != other.Currency {\n        return Money{}, fmt.Errorf(\"currency mismatch: %s != %s\", m.Currency, other.Currency)\n    }\n    return Money{\n        Amount:   m.Amount.Add(other.Amount),\n        Currency: m.Currency,\n    }, nil\n}\n\n// Subtract returns the difference of two Money values (must be same currency)\nfunc (m Money) Subtract(other Money) (Money, error) {\n    if m.Currency != other.Currency {\n        return Money{}, fmt.Errorf(\"currency mismatch: %s != %s\", m.Currency, other.Currency)\n    }\n    return Money{\n        Amount:   m.Amount.Sub(other.Amount),\n        Currency: m.Currency,\n    }, nil\n}\n\n// IsZero returns true if the amount is zero\nfunc (m Money) IsZero() bool {\n    return m.Amount.IsZero()\n}\n\n// IsPositive returns true if the amount is greater than zero\nfunc (m Money) IsPositive() bool {\n    return m.Amount.IsPositive()\n}\n\n// String returns a formatted string representation\nfunc (m Money) String() string {\n    return fmt.Sprintf(\"%s %s\", m.Amount.StringFixed(2), m.Currency)\n}\n\n// Database storage support\nfunc (m Money) Value() (driver.Value, error) {\n    return fmt.Sprintf(\"%s|%s\", m.Amount.String(), m.Currency), nil\n}\n\nfunc (m *Money) Scan(value interface{}) error {\n    if value == nil {\n        return nil\n    }\n    \n    s, ok := value.(string)\n    if !ok {\n        return fmt.Errorf(\"cannot scan %T into Money\", value)\n    }\n    \n    // Parse format \"amount|currency\"\n    parts := strings.Split(s, \"|\")\n    if len(parts) != 2 {\n        return fmt.Errorf(\"invalid money format: %s\", s)\n    }\n    \n    amount, err := decimal.NewFromString(parts[0])\n    if err != nil {\n        return fmt.Errorf(\"invalid amount in money: %s\", parts[0])\n    }\n    \n    m.Amount = amount\n    m.Currency = parts[1]\n    return nil\n}\n```\n\nComplete database connection management:\n\n```go\n// internal/common/database.go\npackage common\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"time\"\n    \n    _ \"github.com/lib/pq\"\n)\n\ntype DatabaseConfig struct {\n    Host     string\n    Port     int\n    User     string\n    Password string\n    DBName   string\n    SSLMode  string\n}\n\nfunc NewDatabase(config DatabaseConfig) (*sql.DB, error) {\n    dsn := fmt.Sprintf(\n        \"host=%s port=%d user=%s password=%s dbname=%s sslmode=%s\",\n        config.Host, config.Port, config.User, \n        config.Password, config.DBName, config.SSLMode,\n    )\n    \n    db, err := sql.Open(\"postgres\", dsn)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to open database: %w\", err)\n    }\n    \n    // Configure connection pool for financial system requirements\n    db.SetMaxOpenConns(25)                 // Limit concurrent connections\n    db.SetMaxIdleConns(5)                  // Keep some connections ready\n    db.SetConnMaxLifetime(5 * time.Minute) // Rotate connections periodically\n    \n    // Test the connection\n    if err := db.Ping(); err != nil {\n        return nil, fmt.Errorf(\"failed to ping database: %w\", err)\n    }\n    \n    return db, nil\n}\n\n// WithTransaction executes a function within a database transaction\n// This is critical for maintaining accounting integrity\nfunc WithTransaction(db *sql.DB, fn func(*sql.Tx) error) error {\n    tx, err := db.Begin()\n    if err != nil {\n        return fmt.Errorf(\"failed to begin transaction: %w\", err)\n    }\n    \n    defer func() {\n        if p := recover(); p != nil {\n            tx.Rollback()\n            panic(p) // Re-throw panic after rollback\n        }\n    }()\n    \n    if err := fn(tx); err != nil {\n        if rbErr := tx.Rollback(); rbErr != nil {\n            return fmt.Errorf(\"transaction error: %v, rollback error: %v\", err, rbErr)\n        }\n        return err\n    }\n    \n    if err := tx.Commit(); err != nil {\n        return fmt.Errorf(\"failed to commit transaction: %w\", err)\n    }\n    \n    return nil\n}\n```\n\n**D. Core Logic Skeleton Code**\n\nHere are the key interfaces and method signatures that learners should implement:\n\n```go\n// internal/accounts/account.go\npackage accounts\n\nimport (\n    \"time\"\n    \"ledger-system/internal/common\"\n)\n\n// AccountType represents the five fundamental account categories\ntype AccountType string\n\nconst (\n    AccountTypeAsset     AccountType = \"ASSET\"\n    AccountTypeLiability AccountType = \"LIABILITY\"\n    AccountTypeEquity    AccountType = \"EQUITY\"\n    AccountTypeRevenue   AccountType = \"REVENUE\"\n    AccountTypeExpense   AccountType = \"EXPENSE\"\n)\n\n// Account represents a single account in the chart of accounts\ntype Account struct {\n    ID           string      `json:\"id\"`\n    Code         string      `json:\"code\"`         // Account number/code\n    Name         string      `json:\"name\"`         // Human-readable name\n    Type         AccountType `json:\"type\"`         // Asset, Liability, etc.\n    Currency     string      `json:\"currency\"`     // ISO currency code\n    ParentID     *string     `json:\"parent_id\"`    // For account hierarchy\n    IsActive     bool        `json:\"is_active\"`    // Can be used in transactions\n    CreatedAt    time.Time   `json:\"created_at\"`\n    ModifiedAt   time.Time   `json:\"modified_at\"`\n}\n\n// NormalBalance returns whether this account type increases with debits or credits\nfunc (a Account) NormalBalance() string {\n    // TODO: Return \"DEBIT\" for assets and expenses, \"CREDIT\" for liabilities, equity, and revenue\n    // This determines how the account balance is calculated from debit/credit amounts\n}\n\n// IsDebitNormal returns true if this account increases with debit entries\nfunc (a Account) IsDebitNormal() bool {\n    // TODO: Return true for ASSET and EXPENSE accounts, false for LIABILITY, EQUITY, and REVENUE\n}\n```\n\n```go\n// internal/transactions/journal_entry.go  \npackage transactions\n\nimport (\n    \"time\"\n    \"ledger-system/internal/common\"\n)\n\n// EntryStatus represents the lifecycle state of a journal entry\ntype EntryStatus string\n\nconst (\n    EntryStatusDraft    EntryStatus = \"DRAFT\"    // Being composed\n    EntryStatusPosted   EntryStatus = \"POSTED\"   // Officially recorded\n    EntryStatusReversed EntryStatus = \"REVERSED\" // Canceled by reversal\n)\n\n// JournalEntry represents a complete double-entry transaction\ntype JournalEntry struct {\n    ID          string        `json:\"id\"`\n    Date        time.Time     `json:\"date\"`        // Transaction date\n    Description string        `json:\"description\"` // Transaction description\n    Reference   string        `json:\"reference\"`   // External reference (invoice #, etc.)\n    Status      EntryStatus   `json:\"status\"`\n    CreatedBy   string        `json:\"created_by\"`  // User who created entry\n    PostedAt    *time.Time    `json:\"posted_at\"`   // When entry was posted\n    Lines       []EntryLine   `json:\"lines\"`       // Debit and credit lines\n    CreatedAt   time.Time     `json:\"created_at\"`\n}\n\n// EntryLine represents a single debit or credit within a journal entry\ntype EntryLine struct {\n    ID            string      `json:\"id\"`\n    JournalID     string      `json:\"journal_id\"`   // Parent journal entry\n    AccountID     string      `json:\"account_id\"`   // Account being debited/credited\n    DebitAmount   *common.Money `json:\"debit_amount\"`  // Amount if this is a debit\n    CreditAmount  *common.Money `json:\"credit_amount\"` // Amount if this is a credit\n    Description   string      `json:\"description\"`   // Line item description\n    LineNumber    int         `json:\"line_number\"`   // Order within entry\n}\n\n// Validate checks if this journal entry follows double-entry rules\nfunc (je *JournalEntry) Validate() error {\n    // TODO 1: Verify entry has at least 2 lines (minimum for double-entry)\n    // TODO 2: Calculate total debits from all lines with DebitAmount != nil\n    // TODO 3: Calculate total credits from all lines with CreditAmount != nil  \n    // TODO 4: Verify total debits equals total credits exactly\n    // TODO 5: Verify each line has exactly one of DebitAmount or CreditAmount (not both, not neither)\n    // TODO 6: Verify all amounts are positive (negative amounts not allowed)\n    // TODO 7: Verify all lines reference valid, active accounts\n    // TODO 8: Check that entry date is not in a closed accounting period\n    return nil\n}\n\n// TotalDebits calculates the sum of all debit amounts in this entry\nfunc (je *JournalEntry) TotalDebits() (common.Money, error) {\n    // TODO: Iterate through Lines, sum up all DebitAmount values\n    // Handle currency conversion if needed - all amounts should be same currency\n}\n\n// TotalCredits calculates the sum of all credit amounts in this entry\nfunc (je *JournalEntry) TotalCredits() (common.Money, error) {\n    // TODO: Iterate through Lines, sum up all CreditAmount values\n    // Handle currency conversion if needed - all amounts should be same currency\n}\n```\n\n**E. Language-Specific Hints**\n\n**Go-Specific Implementation Tips:**\n- Use `database/sql` with prepared statements for all database operations to prevent SQL injection\n- Implement proper error handling with wrapped errors using `fmt.Errorf(\"context: %w\", err)`\n- Use `sql.NullString` and `sql.NullTime` for optional database fields\n- Implement database transactions using `db.Begin()`, `tx.Commit()`, and `tx.Rollback()`\n- Use struct tags for JSON serialization: `json:\"field_name\"`\n- Implement the `Stringer` interface for custom string representations\n- Use Go modules for dependency management with `go.mod`\n- Implement proper database connection pooling with connection limits\n\n**PostgreSQL Integration:**\n- Use NUMERIC(19,4) column type for monetary amounts to avoid floating-point errors\n- Create partial indexes on status columns: `CREATE INDEX idx_active_accounts ON accounts (id) WHERE is_active = true`\n- Use foreign key constraints to ensure referential integrity between tables\n- Implement check constraints for business rules: `CONSTRAINT chk_positive_amount CHECK (amount >= 0)`\n- Use database transactions for multi-table operations to maintain consistency\n- Consider using PostgreSQL's `SERIAL` or `UUID` types for primary keys\n\n**F. Milestone Checkpoints**\n\nAfter implementing the foundation concepts in this section, verify the following behavior:\n\n**Milestone 1 Checkpoint - Account & Entry Model:**\n```bash\n# Run unit tests for account and entry models\ngo test ./internal/accounts/... -v\ngo test ./internal/transactions/... -v\n\n# Expected output should show:\n# - Account type validation tests passing\n# - Normal balance calculation tests passing  \n# - Journal entry validation tests passing\n# - Double-entry balance validation tests passing\n```\n\n**Manual Verification Steps:**\n1. Create sample accounts of each type (Asset, Liability, Equity, Revenue, Expense)\n2. Attempt to create an unbalanced journal entry - should be rejected\n3. Create a balanced journal entry with multiple debit and credit lines - should be accepted\n4. Verify that account normal balance calculation matches expected debit/credit behavior\n\n**Expected Behavior:**\n- Account creation succeeds with valid account types and fails with invalid types\n- Journal entry validation rejects entries where total debits ≠ total credits\n- Multi-currency money arithmetic works correctly without floating-point errors\n- Database constraints prevent invalid data entry\n\n**G. Debugging Tips**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| \"Unbalanced entry\" errors on valid transactions | Rounding errors in decimal arithmetic | Check decimal precision settings | Use fixed-point arithmetic with sufficient precision |\n| Database constraint violations | Missing foreign key references | Check account IDs exist before creating entries | Add validation to verify account existence |\n| Slow balance calculations | Missing database indexes | Run EXPLAIN on balance queries | Add indexes on account_id and posting_date columns |\n| Transaction rollback failures | Nested transaction attempts | Review transaction boundary code | Use single transaction per journal entry operation |\n| JSON serialization errors | Pointer fields with nil values | Check for nil pointer dereference | Use proper null handling in struct tags |\n| Currency mismatch errors | Mixed currencies in single entry | Validate currency consistency | Add business rule validation for currency matching |\n\nThe foundation established in this section provides the conceptual framework and basic infrastructure needed to implement a production-quality double-entry ledger system. The key insight is that financial systems require different architectural trade-offs than typical applications, prioritizing correctness and auditability over raw performance.\n\n\n> **Milestone(s):** All milestones, as this section establishes the scope and requirements that drive the design of each system component\n\n## Goals and Non-Goals\n\nBuilding a robust double-entry ledger system requires careful scoping to focus on core accounting principles while avoiding feature creep. Think of this system as the foundation of a skyscraper—it must be rock-solid in its fundamental capabilities before any additional features can be safely built on top. A ledger system that tries to do everything often ends up doing nothing well, particularly when it comes to the non-negotiable requirements of financial accuracy and auditability.\n\nThis section establishes clear boundaries around what our ledger system will and will not accomplish. The distinction between goals and non-goals is critical because accounting systems sit at the intersection of complex business requirements, regulatory compliance, and technical performance demands. Every feature we include increases complexity and potential failure points, while every feature we exclude allows us to focus engineering effort on getting the core functionality absolutely right.\n\n### Functional Requirements\n\nThe functional requirements define the core accounting capabilities that our ledger system must provide. These requirements are derived from fundamental double-entry bookkeeping principles and represent the minimum viable feature set for a production-ready accounting system.\n\n#### Core Double-Entry Bookkeeping Operations\n\nThe system must implement complete double-entry bookkeeping functionality with mathematical precision and business rule enforcement. Think of this as the \"physics\" of our accounting universe—these rules cannot be bent or broken without compromising the entire system's integrity.\n\n**Chart of Accounts Management**\n\nThe system must provide comprehensive account management capabilities that support the five fundamental account types used in double-entry bookkeeping. Each account type has specific behavioral rules that the system must enforce automatically.\n\n| Account Type | Normal Balance | Examples | Debit Effect | Credit Effect |\n|-------------|----------------|----------|--------------|---------------|\n| Asset | Debit | Cash, Inventory, Equipment | Increases | Decreases |\n| Liability | Credit | Accounts Payable, Loans | Decreases | Increases |\n| Equity | Credit | Owner's Capital, Retained Earnings | Decreases | Increases |\n| Revenue | Credit | Sales, Service Income | Decreases | Increases |\n| Expense | Debit | Rent, Salaries, Utilities | Increases | Decreases |\n\nThe account management system must support hierarchical organization through parent-child relationships, enabling users to create detailed sub-accounts while maintaining logical groupings. For example, a \"Cash\" parent account might have children like \"Checking Account - Bank A\" and \"Petty Cash\". The system must validate that child accounts maintain the same normal balance orientation as their parents and prevent circular references in the hierarchy.\n\n**Journal Entry Recording and Validation**\n\nEvery financial transaction must be recorded through journal entries that strictly enforce the fundamental accounting equation: Assets = Liabilities + Equity. The system must validate that every journal entry maintains perfect mathematical balance where total debits equal total credits.\n\n| Validation Rule | Description | Failure Action |\n|----------------|-------------|----------------|\n| Balance Requirement | Total debits must equal total credits | Reject entry with specific error message |\n| Account Existence | All referenced accounts must exist and be active | Reject entry with invalid account details |\n| Account Type Compatibility | Debits/credits must respect account normal balances | Allow but warn for unusual entries |\n| Date Validity | Entry date must be reasonable (not future, not too old) | Reject with date validation error |\n| Amount Precision | Monetary amounts must have appropriate decimal precision | Round or reject based on currency rules |\n\nThe journal entry workflow must support both single-currency and multi-currency transactions. For multi-currency entries, the system must store exchange rates at the time of transaction and validate that converted amounts still balance in the reporting currency.\n\n**Transaction Templates and Common Patterns**\n\nTo reduce errors and improve efficiency, the system must provide predefined transaction templates for common business operations. These templates encode best practices for recording standard transactions while allowing customization for specific business needs.\n\n| Transaction Type | Accounts Affected | Template Structure |\n|-----------------|-------------------|-------------------|\n| Cash Sale | Cash (Debit), Sales Revenue (Credit) | Simple two-line entry |\n| Credit Sale | Accounts Receivable (Debit), Sales Revenue (Credit) | Two-line entry with customer reference |\n| Cash Purchase | Expense Account (Debit), Cash (Credit) | Two-line entry with vendor reference |\n| Loan Payment | Loan Principal (Debit), Interest Expense (Debit), Cash (Credit) | Three-line entry with payment allocation |\n| Depreciation | Depreciation Expense (Debit), Accumulated Depreciation (Credit) | Two-line entry with asset reference |\n\n#### Balance Calculation and Inquiry System\n\nThe system must provide real-time access to accurate account balances while maintaining performance under high transaction volumes. Think of balance calculation as the \"pulse\" of the accounting system—it must be both immediate and absolutely reliable.\n\n**Current Balance Computation**\n\nCurrent balances must reflect all posted transactions and be available instantly for any account query. The system must handle the mathematical complexity of different account types having different normal balances.\n\n| Balance Calculation Method | Use Case | Performance Characteristics |\n|---------------------------|----------|----------------------------|\n| Running Balance Cache | High-frequency balance queries | O(1) lookup, requires cache maintenance |\n| Real-time Aggregation | Infrequent queries, maximum accuracy | O(n) calculation, always current |\n| Hybrid Approach | Most production scenarios | Cached with incremental updates |\n\n**Point-in-Time Balance Queries**\n\nThe system must support historical balance calculations that show account balances as of any specific date and time. This capability is essential for financial reporting, auditing, and understanding how balances evolved over time.\n\n**Trial Balance Generation and Validation**\n\nThe system must automatically generate trial balance reports that prove the books are mathematically correct. A trial balance lists all accounts with their debit and credit balances, and the totals must always be equal. This is the primary mathematical proof that the double-entry system is working correctly.\n\n| Trial Balance Component | Description | Validation Rule |\n|------------------------|-------------|-----------------|\n| Account Listing | All active accounts with non-zero balances | Must include all accounts with activity |\n| Debit Column | Accounts with debit normal balances | Asset and Expense accounts |\n| Credit Column | Accounts with credit normal balances | Liability, Equity, and Revenue accounts |\n| Column Totals | Sum of debit and credit columns | Must be equal or system is invalid |\n\n#### Financial Reporting Capabilities\n\nThe system must generate the three primary financial statements that businesses use to understand their financial position and performance. These reports form the foundation of business decision-making and regulatory compliance.\n\n**Balance Sheet Generation**\n\nThe balance sheet provides a snapshot of financial position at a specific point in time, showing that assets equal liabilities plus equity. The system must automatically categorize accounts into the correct balance sheet sections and validate that the fundamental equation balances.\n\n| Balance Sheet Section | Account Types Included | Reporting Requirements |\n|----------------------|----------------------|----------------------|\n| Current Assets | Short-term assets (Cash, Receivables, Inventory) | Listed in order of liquidity |\n| Fixed Assets | Long-term assets (Equipment, Buildings, Land) | Shown at cost minus accumulated depreciation |\n| Current Liabilities | Short-term obligations (Payables, Accrued expenses) | Listed by payment due date |\n| Long-term Liabilities | Long-term debt and obligations | Shown with maturity information |\n| Equity | Owner's equity and retained earnings | Shows cumulative ownership and profits |\n\n**Income Statement Generation**\n\nThe income statement shows profitability over a period by comparing revenues to expenses. The system must accurately filter transactions by date range and categorize them into revenue and expense sections.\n\n**Cash Flow Statement Foundation**\n\nWhile full cash flow statements require complex analysis, the system must provide the underlying data categorization that enables cash flow reporting. This includes identifying operating, investing, and financing activities through account classification and transaction metadata.\n\n> **Design Insight: Separation of Core from Convenience**\n>\n> The functional requirements focus deliberately on core accounting operations rather than user convenience features. This separation allows us to build a mathematically sound foundation that can support various user interfaces and workflow tools without coupling the accounting logic to presentation concerns.\n\n### Non-Functional Requirements\n\nNon-functional requirements define how well the system must perform its functional capabilities. For a financial system, these requirements often matter more than additional features because they determine whether the system can be trusted with an organization's financial data.\n\n#### Performance and Scalability Requirements\n\nThe system must handle realistic business transaction volumes without degrading user experience or system reliability. Performance requirements are not just about speed—they're about predictable behavior under load.\n\n**Transaction Processing Performance**\n\n| Performance Metric | Requirement | Measurement Method |\n|-------------------|-------------|-------------------|\n| Journal Entry Posting | < 100ms per entry (95th percentile) | End-to-end API response time |\n| Balance Query Response | < 50ms per query (99th percentile) | Database query to API response |\n| Trial Balance Generation | < 2 seconds for 10,000 accounts | Report generation completion time |\n| Concurrent Users | Support 50 simultaneous users | Load testing with realistic workloads |\n| Transaction Volume | 10,000 journal entries per day | Sustained throughput over 8-hour period |\n\n**Database Performance Characteristics**\n\nThe system must maintain performance as data volume grows. Financial data never gets deleted, so the system must handle ever-increasing transaction history without slowdown.\n\n| Data Volume Scenario | Expected Performance Impact | Mitigation Strategy |\n|---------------------|---------------------------|-------------------|\n| 1 million transactions | Baseline performance | Proper indexing and query optimization |\n| 10 million transactions | < 20% performance degradation | Partitioning and archive strategies |\n| 100 million transactions | May require infrastructure scaling | Horizontal scaling or data tiering |\n\n#### Reliability and Data Integrity Requirements\n\nFinancial systems must be absolutely reliable because errors in accounting data can have serious legal and business consequences. The system must be designed with multiple layers of protection against data corruption, loss, or inconsistency.\n\n**Data Consistency Guarantees**\n\nThe system must maintain ACID properties for all financial transactions, with particular emphasis on consistency and durability. Think of this as the \"insurance policy\" for financial data—every transaction must be all-or-nothing with permanent recording.\n\n| Consistency Requirement | Implementation Need | Failure Consequence |\n|------------------------|-------------------|-------------------|\n| Atomic Journal Entries | Database transactions wrapping all entry lines | Partial entries could unbalance books |\n| Double-Entry Balance | Real-time validation before posting | Unbalanced entries violate accounting principles |\n| Referential Integrity | Foreign key constraints and application validation | Orphaned data could corrupt reports |\n| Temporal Consistency | Proper transaction ordering and timestamps | Incorrect financial statement calculations |\n\n**Backup and Recovery Capabilities**\n\nThe system must support comprehensive backup strategies that ensure financial data can be recovered completely and accurately after any type of failure.\n\n| Recovery Scenario | Recovery Time Objective | Recovery Point Objective | Implementation Approach |\n|------------------|------------------------|-------------------------|-------------------------|\n| Application Crash | < 5 minutes | 0 data loss | Automatic restart with transaction log replay |\n| Database Corruption | < 30 minutes | < 1 minute data loss | Point-in-time recovery from backups |\n| Hardware Failure | < 2 hours | < 5 minutes data loss | Failover to backup infrastructure |\n| Site Disaster | < 24 hours | < 15 minutes data loss | Geographic backup restoration |\n\n#### Security and Compliance Requirements\n\nFinancial systems must implement robust security controls and maintain compliance with accounting standards and regulations. Security is not just about preventing unauthorized access—it's about maintaining the integrity and trustworthiness of financial records.\n\n**Access Control and Authentication**\n\n| Security Control | Requirement | Implementation Notes |\n|-----------------|-------------|---------------------|\n| User Authentication | Strong password policies or multi-factor authentication | Integration with enterprise identity systems |\n| Role-Based Access | Granular permissions for different accounting functions | Separation of duties for financial controls |\n| Session Management | Automatic logout and session encryption | Protection against unauthorized access |\n| API Security | Authentication tokens and rate limiting | Secure integration with other systems |\n\n**Audit and Compliance Capabilities**\n\nThe system must maintain complete audit trails that satisfy regulatory requirements and support forensic investigation when needed.\n\n| Audit Requirement | Retention Period | Information Captured |\n|-------------------|-----------------|-------------------|\n| Transaction History | 7 years minimum | All journal entries with timestamps and user information |\n| System Access Logs | 2 years minimum | Login attempts, permission changes, system administration |\n| Data Modifications | Permanent retention | Before/after values for any data changes |\n| Report Generation | 1 year minimum | What reports were generated when and by whom |\n\n> **Critical Insight: Auditability as a Feature**\n>\n> Many developers treat audit logging as an afterthought, but in financial systems, auditability must be designed into every component from the beginning. The audit trail is not just for compliance—it's often the primary tool for diagnosing and fixing accounting discrepancies.\n\n### Explicit Non-Goals\n\nClearly defining what the system will NOT do is as important as defining what it will do. These non-goals prevent scope creep and ensure engineering resources focus on core accounting functionality rather than peripheral business applications.\n\n#### Business Process Automation (Explicitly Excluded)\n\nWhile many accounting systems include workflow and business process features, our ledger system deliberately excludes these capabilities to maintain focus on core accounting accuracy and reliability.\n\n**Excluded Business Processes**\n\n| Excluded Feature | Rationale for Exclusion | Alternative Approach |\n|-----------------|------------------------|-------------------|\n| Invoice Generation | Not core to double-entry bookkeeping | External invoicing system posts to ledger |\n| Purchase Order Management | Business process, not accounting transaction | PO system creates journal entries when appropriate |\n| Payroll Processing | Complex domain with specialized requirements | Payroll system posts summary entries to ledger |\n| Inventory Management | Operational system with different data models | Inventory system posts value changes to ledger |\n| Customer Relationship Management | Sales process, not financial recording | CRM integrates with ledger for financial data |\n\n**Approval Workflow Exclusions**\n\nWhile some businesses require approval workflows for journal entries, implementing this capability would significantly complicate the core accounting engine. The system will provide hooks for external workflow systems rather than implementing approval logic directly.\n\n#### Tax Calculation and Compliance (Explicitly Excluded)\n\nTax calculation involves complex, jurisdiction-specific rules that change frequently and require specialized expertise. Including tax features would compromise the system's focus on fundamental accounting principles.\n\n**Tax-Related Exclusions**\n\n| Tax Feature | Why Excluded | Integration Approach |\n|-------------|--------------|-------------------|\n| Sales Tax Calculation | Jurisdiction-specific rules too complex | Tax service calculates, posts results to ledger |\n| Income Tax Preparation | Requires specialized tax accounting knowledge | Tax software reads ledger data for preparation |\n| Regulatory Tax Reporting | Different formats for each jurisdiction | Reporting tools extract data from standardized ledger |\n| Tax Code Maintenance | Requires legal and tax expertise | External tax reference data integrated as needed |\n\n#### User Interface and Experience Features (Explicitly Excluded)\n\nThe ledger system will provide robust APIs but will not include user interface components. This separation allows for specialized UI development while keeping the accounting engine focused on data integrity and performance.\n\n**UI/UX Exclusions**\n\n| Interface Feature | Rationale for Exclusion | API-First Alternative |\n|------------------|------------------------|-------------------|\n| Web Dashboard | UI frameworks change frequently | REST/GraphQL APIs for any UI framework |\n| Mobile Applications | Device-specific development requirements | APIs support mobile app development |\n| Report Formatting | Presentation layer separate from data layer | Raw data APIs for custom report formatting |\n| User Preference Management | Not related to accounting functionality | External user management system integration |\n\n**Integration and Middleware Exclusions**\n\nWhile the system will provide integration capabilities, it will not include middleware or ETL functionality that goes beyond basic accounting data exchange.\n\n| Integration Feature | Why Excluded | Recommended Approach |\n|-------------------|--------------|-------------------|\n| Data Transformation Tools | Not core to accounting logic | External ETL tools work with ledger APIs |\n| Message Queue Management | Infrastructure concern, not accounting | Standard messaging systems integrate via APIs |\n| File Format Conversion | Presentation layer responsibility | Import/export APIs with standard formats |\n| Third-Party API Orchestration | Business logic outside accounting scope | Integration platform calls ledger APIs |\n\n#### Advanced Financial Analytics (Explicitly Excluded)\n\nWhile the ledger provides foundation data for financial analysis, advanced analytics capabilities are deliberately excluded to maintain system focus and performance.\n\n**Analytics Exclusions**\n\n| Analytics Feature | Rationale for Exclusion | Data Access Method |\n|------------------|------------------------|-------------------|\n| Predictive Financial Modeling | Requires specialized algorithms and expertise | Raw ledger data exported for analysis tools |\n| Business Intelligence Dashboards | Presentation and analysis layer separate from ledger | APIs provide data for BI tools |\n| Performance KPI Calculations | Business-specific metrics beyond accounting scope | Calculated by business intelligence systems |\n| Variance Analysis | Requires budgeting data and business rules | External planning systems analyze ledger actuals |\n\n> **Decision: API-First Architecture for Non-Core Features**\n> - **Context**: Many accounting features could be built into the ledger system, but would significantly increase complexity and maintenance burden\n> - **Options Considered**: \n>   1. Monolithic system including all business features\n>   2. Modular system with optional feature modules  \n>   3. Pure ledger with comprehensive APIs for external integration\n> - **Decision**: Pure ledger with comprehensive APIs\n> - **Rationale**: Allows specialized teams to build best-in-class solutions for each business domain while maintaining ledger system focus on accounting accuracy and performance\n> - **Consequences**: Requires more integration work but results in better overall system architecture and allows independent scaling of different functional areas\n\n### Requirements Validation and Success Criteria\n\nTo ensure the system meets its goals, we must establish measurable success criteria for each category of requirements. These criteria will guide development priorities and provide objective measures of system completion.\n\n**Functional Requirements Validation**\n\n| Requirement Category | Success Criteria | Validation Method |\n|---------------------|------------------|-------------------|\n| Double-Entry Compliance | 100% of journal entries balance mathematically | Automated testing with property-based test generation |\n| Account Management | Support for all 5 account types with proper normal balance behavior | Unit tests covering all account type scenarios |\n| Balance Calculation | Current and historical balances always match transaction sum | Reconciliation tests comparing calculated vs. aggregated balances |\n| Financial Reporting | Trial balance always sums to zero, balance sheet always balances | End-to-end reporting tests with known datasets |\n\n**Non-Functional Requirements Validation**\n\n| Performance Metric | Target | Validation Method |\n|-------------------|--------|-------------------|\n| Transaction Throughput | 10,000 entries per day sustained | Load testing with realistic transaction patterns |\n| Response Time | 95% of operations under specified time limits | Automated performance testing in CI/CD pipeline |\n| Data Integrity | Zero tolerance for data corruption | Continuous integrity checks and audit trail validation |\n| System Availability | 99.9% uptime during business hours | Infrastructure monitoring and incident tracking |\n\n### Implementation Guidance\n\nThe requirements established in this section directly influence technology choices and implementation priorities. Understanding how to translate these requirements into working code requires careful consideration of architecture patterns and technology stack decisions.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Database | PostgreSQL with ACID transactions | PostgreSQL with read replicas and connection pooling |\n| API Framework | Go standard library net/http | Gin or Echo web framework with middleware |\n| Validation | Manual validation functions | Validator library with struct tags |\n| Testing | Standard Go testing package | Testify for assertions plus property-based testing |\n| Documentation | Inline code comments | OpenAPI/Swagger specification generation |\n| Monitoring | Basic logging to stdout | Structured logging with metrics collection |\n\n#### Core Requirements Implementation Structure\n\nThe requirements drive a specific code organization that separates concerns cleanly and supports testing at multiple levels:\n\n```\nledger-system/\n  cmd/\n    server/main.go              ← HTTP API server entry point\n    cli/main.go                 ← Command-line tools for administration\n  internal/\n    accounts/                   ← Chart of accounts management\n      types.go                  ← Account type definitions and validation\n      repository.go             ← Account persistence layer\n      service.go                ← Account business logic\n    entries/                    ← Journal entry recording\n      types.go                  ← Entry and line item structures\n      validator.go              ← Double-entry validation logic\n      repository.go             ← Entry persistence layer\n      service.go                ← Entry recording business logic\n    balances/                   ← Balance calculation engine\n      calculator.go             ← Current and historical balance computation\n      cache.go                  ← Running balance cache management\n      service.go                ← Balance query business logic\n    reports/                    ← Financial reporting\n      trial_balance.go          ← Trial balance generation\n      balance_sheet.go          ← Balance sheet generation\n      income_statement.go       ← Income statement generation\n    audit/                      ← Audit trail system\n      logger.go                 ← Change tracking and audit logging\n      trail.go                  ← Immutable audit trail management\n    api/                        ← HTTP API handlers\n      accounts.go               ← Account management endpoints\n      entries.go                ← Journal entry endpoints\n      balances.go               ← Balance query endpoints\n      reports.go                ← Financial report endpoints\n  pkg/\n    money/                      ← Monetary amount handling\n      money.go                  ← Fixed-point decimal arithmetic\n      currency.go               ← Multi-currency support\n    database/                   ← Database utilities\n      connection.go             ← Database connection management\n      migrations/               ← Database schema versioning\n  test/\n    integration/                ← End-to-end testing\n    fixtures/                   ← Test data for consistent testing\n```\n\n#### Requirements-Driven Type Definitions\n\nThe functional requirements directly translate into core type definitions that enforce business rules at the type level:\n\n```go\n// Core account types that enforce double-entry principles\ntype AccountType int\n\nconst (\n    AccountTypeAsset AccountType = iota\n    AccountTypeLiability\n    AccountTypeEquity\n    AccountTypeRevenue\n    AccountTypeExpense\n)\n\n// Account structure that supports hierarchical organization\ntype Account struct {\n    ID          string     `json:\"id\" db:\"id\"`\n    Code        string     `json:\"code\" db:\"code\"`\n    Name        string     `json:\"name\" db:\"name\"`\n    Type        AccountType `json:\"type\" db:\"type\"`\n    Currency    string     `json:\"currency\" db:\"currency\"`\n    ParentID    *string    `json:\"parent_id,omitempty\" db:\"parent_id\"`\n    IsActive    bool       `json:\"is_active\" db:\"is_active\"`\n    CreatedAt   time.Time  `json:\"created_at\" db:\"created_at\"`\n    ModifiedAt  time.Time  `json:\"modified_at\" db:\"modified_at\"`\n}\n\n// Money type that prevents floating-point errors\ntype Money struct {\n    Amount   decimal.Decimal `json:\"amount\" db:\"amount\"`\n    Currency string         `json:\"currency\" db:\"currency\"`\n}\n\n// Journal entry that enforces double-entry balance requirements\ntype JournalEntry struct {\n    ID          string        `json:\"id\" db:\"id\"`\n    Date        time.Time     `json:\"date\" db:\"date\"`\n    Description string        `json:\"description\" db:\"description\"`\n    Reference   string        `json:\"reference\" db:\"reference\"`\n    Status      EntryStatus   `json:\"status\" db:\"status\"`\n    CreatedBy   string        `json:\"created_by\" db:\"created_by\"`\n    PostedAt    *time.Time    `json:\"posted_at,omitempty\" db:\"posted_at\"`\n    Lines       []EntryLine   `json:\"lines\" db:\"-\"`\n    CreatedAt   time.Time     `json:\"created_at\" db:\"created_at\"`\n}\n```\n\n#### Requirements Validation Implementation\n\nEach requirement category needs specific validation code that can be tested independently:\n\n```go\n// Double-entry validation that enforces fundamental accounting rules\nfunc (je *JournalEntry) Validate() error {\n    // TODO 1: Verify entry has at least 2 lines (minimum for double-entry)\n    // TODO 2: Calculate total debits and total credits\n    // TODO 3: Verify debits equal credits within currency precision tolerance\n    // TODO 4: Validate all referenced accounts exist and are active\n    // TODO 5: Check that entry date is reasonable (not future, not too old)\n    // TODO 6: Ensure description and reference fields are not empty\n    // TODO 7: Validate each line item has either debit or credit (not both)\n}\n\n// Balance calculation that supports both current and point-in-time queries\nfunc (bs *BalanceService) CalculateBalance(accountID string, asOfDate *time.Time) (Money, error) {\n    // TODO 1: Determine if this is current balance or point-in-time query\n    // TODO 2: For current balance, check if cached balance is available\n    // TODO 3: For point-in-time, filter transactions by date\n    // TODO 4: Sum debits and credits according to account normal balance\n    // TODO 5: Apply account type sign conventions (asset/expense debit normal)\n    // TODO 6: Return balance in account's native currency\n}\n\n// Trial balance generation that proves mathematical correctness\nfunc (rs *ReportService) GenerateTrialBalance(asOfDate time.Time) (TrialBalance, error) {\n    // TODO 1: Get all active accounts with non-zero balances\n    // TODO 2: Calculate balance for each account as of the specified date\n    // TODO 3: Separate accounts into debit and credit columns based on normal balance\n    // TODO 4: Sum debit and credit columns\n    // TODO 5: Verify total debits equal total credits\n    // TODO 6: Return structured trial balance report\n}\n```\n\n#### Performance Requirements Implementation\n\nPerformance requirements drive specific implementation choices for data storage and query patterns:\n\n```go\n// Running balance cache that provides O(1) balance lookups\ntype BalanceCache struct {\n    // TODO: Implement balance caching strategy\n    // - Cache current balances for frequently queried accounts\n    // - Invalidate cache when new entries are posted\n    // - Handle cache warming for report generation\n}\n\n// Database configuration that supports performance requirements\ntype DatabaseConfig struct {\n    Host            string `json:\"host\"`\n    Port            int    `json:\"port\"`\n    User            string `json:\"user\"`\n    Password        string `json:\"password\"`\n    DBName          string `json:\"database\"`\n    SSLMode         string `json:\"ssl_mode\"`\n    MaxConnections  int    `json:\"max_connections\"`\n    ConnMaxLifetime time.Duration `json:\"connection_max_lifetime\"`\n    // TODO: Add connection pooling and performance tuning parameters\n}\n```\n\n#### Milestone Verification Checkpoints\n\nAfter implementing the requirements analysis, verify that the foundation is properly established:\n\n**Functional Requirements Verification:**\n- Run `go test ./internal/accounts/...` - all account type validation tests should pass\n- Run `go test ./internal/entries/...` - double-entry balance validation should work\n- Create a simple journal entry via API and verify it enforces balance requirements\n- Generate a trial balance and confirm it sums to zero\n\n**Non-Functional Requirements Verification:**\n- Load test with 100 concurrent journal entry creations - should maintain response times\n- Create 1000 accounts and verify balance queries remain fast\n- Simulate database connection loss and verify proper error handling\n\n**Non-Goals Verification:**\n- Confirm no UI code exists in the ledger core modules\n- Verify no tax calculation logic is included in transaction processing\n- Ensure no business workflow logic exists in the accounting engine\n\n**Signs of Implementation Problems:**\n- Trial balance doesn't sum to zero → Check double-entry validation logic\n- Balance queries are slow → Verify database indexes and caching strategy\n- Journal entries can be modified after posting → Check immutability enforcement\n- Floating-point rounding errors in money calculations → Verify decimal arithmetic usage\n\n\n> **Milestone(s):** 1-5 (All milestones), as this section establishes the foundational architecture that supports account modeling, transaction recording, balance calculation, audit trails, and financial reporting\n\n## High-Level Architecture\n\nThe double-entry ledger system architecture follows a **layered service pattern** where each component has a single, well-defined responsibility that aligns with core accounting principles. Think of this architecture like a traditional accounting firm's organization: the Chart of Accounts department manages account structure, the Bookkeeping department records transactions, the Reconciliation department maintains balances, the Compliance department tracks all changes, and the Reporting department generates financial statements. Each department has specialized expertise and clear boundaries, but they all work together through established procedures to maintain the integrity of the financial records.\n\nThe system's architecture prioritizes **data consistency and auditability** over raw performance, reflecting the fundamental requirement that accounting systems must be trustworthy above all else. Every component is designed with the understanding that financial data, once recorded, becomes part of a permanent record that may be subject to regulatory scrutiny years later. This drives architectural decisions toward immutable data structures, comprehensive audit trails, and fail-safe validation mechanisms.\n\n![High-Level System Component Architecture](./diagrams/system-components.svg)\n\n### Component Responsibilities\n\nThe ledger system consists of five core components, each responsible for a specific aspect of double-entry bookkeeping. These components communicate through well-defined interfaces and share a common understanding of the fundamental accounting data model.\n\n#### Account Management Component\n\nThe **Account Management Component** serves as the foundation of the entire system, managing the chart of accounts that defines the structure for all financial recording. Think of this component as the architect of a building's blueprint - it establishes the framework that all other operations depend upon. This component owns the complete lifecycle of account definitions, from initial creation through hierarchical organization to eventual deactivation.\n\nThe component maintains the **chart of accounts hierarchy**, ensuring that accounts are properly categorized according to standard accounting principles. It enforces business rules around account creation, such as preventing duplicate account codes and validating that parent-child relationships make logical sense within the accounting framework. The component also manages account metadata including currencies, normal balance rules, and activation status.\n\n**Account Management Component Responsibilities:**\n\n| Responsibility | Description | Data Owned | Business Rules Enforced |\n|---|---|---|---|\n| Account Creation | Creates new accounts with proper type classification | Account master records | Account code uniqueness, valid account types |\n| Hierarchy Management | Maintains parent-child account relationships | Account hierarchy mappings | Logical parent-child type relationships |\n| Account Validation | Validates account configurations and relationships | Account metadata | Currency consistency, normal balance rules |\n| Account Lifecycle | Manages account activation, deactivation, and archival | Account status records | Prevents deletion of accounts with transactions |\n\nThe component exposes a clean interface for other system components to query account information, validate account references, and retrieve account hierarchies. It acts as the authoritative source for all account-related data and ensures that the chart of accounts remains consistent and compliant with accounting standards.\n\n#### Transaction Recording Engine\n\nThe **Transaction Recording Engine** handles the core business logic of double-entry bookkeeping - creating and posting journal entries that maintain the fundamental accounting equation. Think of this engine as a meticulous bookkeeper who never allows an unbalanced entry to be recorded and maintains perfect documentation of every transaction.\n\nThis component orchestrates the complex process of journal entry creation, from initial validation through final posting. It ensures that every journal entry satisfies the double-entry principle where total debits equal total credits before any data is permanently recorded. The engine also manages the posting workflow, transitioning entries from draft status through validation to final posting with appropriate audit trails.\n\n**Transaction Recording Engine Responsibilities:**\n\n| Responsibility | Description | Data Owned | Validation Rules |\n|---|---|---|---|\n| Entry Creation | Creates journal entries with multiple line items | Journal entry headers | All required fields present, valid references |\n| Double-Entry Validation | Ensures debits equal credits before posting | Entry line items | Mathematical balance, account compatibility |\n| Atomic Posting | Posts entries atomically with database transactions | Posted transaction records | All-or-nothing posting, referential integrity |\n| Entry Reversal | Creates offsetting entries to correct posted transactions | Reversal entries | Original entry exists and is posted |\n| Idempotency Management | Prevents duplicate entries from repeated operations | Idempotency keys | Unique operation identification |\n\nThe engine maintains strict boundaries around data modification, ensuring that posted entries become immutable and can only be corrected through explicit reversal entries. It provides comprehensive error reporting when validation failures occur, helping users understand exactly what prevented an entry from being posted.\n\n#### Balance Calculation Engine\n\nThe **Balance Calculation Engine** maintains real-time account balances and provides efficient balance queries across different time periods. Think of this engine as a financial calculator that instantly knows the balance of every account at any point in time, without having to manually add up all the individual transactions each time someone asks.\n\nThis component solves the fundamental performance challenge in accounting systems: how to quickly answer \"what is the balance of account X as of date Y\" when there might be millions of transactions to consider. The engine maintains running balances that are incrementally updated as new transactions are posted, while also providing point-in-time balance calculations for historical reporting needs.\n\n**Balance Calculation Engine Responsibilities:**\n\n| Responsibility | Description | Data Maintained | Performance Characteristics |\n|---|---|---|---|\n| Running Balance Maintenance | Updates account balances as transactions post | Current balance cache | Sub-second balance updates |\n| Point-in-Time Calculations | Computes historical balances for any date | Balance history snapshots | Optimized date range queries |\n| Trial Balance Generation | Validates that all account balances sum to zero | Cross-account balance summaries | Complete ledger validation |\n| Balance Cache Management | Invalidates and refreshes cached balances | Balance cache metadata | Consistency with posted transactions |\n\nThe engine handles the complexity of account type sign conventions, ensuring that debit balances are positive for asset and expense accounts while credit balances are positive for liability, equity, and revenue accounts. It provides both current balance queries for operational use and historical balance queries for financial reporting and audit purposes.\n\n#### Audit Trail System\n\nThe **Audit Trail System** creates an immutable record of all changes to the ledger, ensuring complete traceability and regulatory compliance. Think of this system as a security camera that records everything happening in the accounting department - not just what transactions were recorded, but who recorded them, when, and what approvals were obtained.\n\nThis component addresses the critical requirement that accounting systems must provide complete audit trails for regulatory compliance and internal controls. It maintains detailed logs of every action taken within the system, from account creation through transaction posting to balance inquiries. The audit system ensures that once information is recorded, it cannot be modified or deleted without leaving a clear trail.\n\n**Audit Trail System Responsibilities:**\n\n| Responsibility | Description | Audit Data Captured | Integrity Mechanisms |\n|---|---|---|---|\n| Change Logging | Records all modifications to ledger data | Before/after values, timestamps, actors | Cryptographic hash chains |\n| User Action Tracking | Logs all user interactions with the system | User identity, action type, affected records | Non-repudiation controls |\n| Immutable Storage | Prevents modification of historical audit records | Complete change history | Write-once storage guarantees |\n| Compliance Reporting | Generates audit reports for regulatory requirements | Audit trails for specified periods | Tamper-evident export formats |\n\nThe system implements cryptographic hash chains to detect any tampering with historical records, ensuring that audit trails can be trusted even in environments where database administrators have broad access privileges. It provides comprehensive audit reports that can be exported for external auditors and regulatory authorities.\n\n#### Financial Reporting Module\n\nThe **Financial Reporting Module** generates standard financial statements and reports that summarize the ledger data for business and regulatory purposes. Think of this module as the publishing department that takes all the detailed transaction records and presents them in standardized formats that business managers, investors, and regulators expect to see.\n\nThis component transforms the detailed transaction-level data maintained by other system components into the summary reports that drive business decision-making. It understands the relationships between different account types and how they should be presented in various financial statements, ensuring that reports comply with standard accounting presentation requirements.\n\n**Financial Reporting Module Responsibilities:**\n\n| Responsibility | Description | Report Types Generated | Data Sources |\n|---|---|---|---|\n| Trial Balance Reporting | Lists all account balances to verify ledger balance | Trial balance with debit/credit columns | Account balances from Balance Engine |\n| Balance Sheet Generation | Shows financial position at a specific date | Assets, liabilities, equity statement | Account balances by type |\n| Income Statement Generation | Shows profit/loss over a specific period | Revenue, expenses, net income statement | Period-based account activity |\n| Period Closing | Transfers income/expense balances to retained earnings | Closing entries and period summaries | Period-end account balances |\n\nThe module handles complex accounting requirements such as multi-currency translation, where foreign currency balances must be converted to the reporting currency using appropriate exchange rates. It also manages the period closing process, which locks completed accounting periods and transfers temporary account balances to permanent accounts.\n\n### Recommended Module Structure\n\nThe Go implementation organizes code into logical packages that reflect the component responsibilities while maintaining clean separation of concerns. This structure supports independent development and testing of each component while providing clear interfaces for component integration.\n\n```\nledger-system/\n├── cmd/\n│   └── ledger-server/\n│       └── main.go                    ← Application entry point\n├── internal/\n│   ├── accounts/\n│   │   ├── manager.go                 ← Account Management Component\n│   │   ├── hierarchy.go               ← Account hierarchy logic\n│   │   ├── validation.go              ← Account validation rules\n│   │   └── types.go                   ← Account type definitions\n│   ├── transactions/\n│   │   ├── engine.go                  ← Transaction Recording Engine\n│   │   ├── validation.go              ← Entry validation logic\n│   │   ├── posting.go                 ← Entry posting workflow\n│   │   └── reversal.go                ← Entry reversal mechanism\n│   ├── balances/\n│   │   ├── calculator.go              ← Balance Calculation Engine\n│   │   ├── cache.go                   ← Balance caching logic\n│   │   └── trial_balance.go           ← Trial balance generation\n│   ├── audit/\n│   │   ├── trail.go                   ← Audit Trail System\n│   │   ├── integrity.go               ← Cryptographic integrity\n│   │   └── reporting.go               ← Audit report generation\n│   ├── reporting/\n│   │   ├── generator.go               ← Financial Reporting Module\n│   │   ├── balance_sheet.go           ← Balance sheet logic\n│   │   ├── income_statement.go        ← Income statement logic\n│   │   └── period_closing.go          ← Period closing process\n│   ├── storage/\n│   │   ├── database.go                ← Database connection management\n│   │   ├── transactions.go            ← Database transaction helpers\n│   │   └── migrations/                ← Database schema migrations\n│   └── common/\n│       ├── types.go                   ← Shared type definitions\n│       ├── money.go                   ← Money arithmetic implementation\n│       └── errors.go                  ← Common error definitions\n├── pkg/\n│   └── ledgerapi/\n│       ├── client.go                  ← Public API client\n│       └── types.go                   ← Public API types\n├── api/\n│   ├── handlers/\n│   │   ├── accounts.go                ← Account management endpoints\n│   │   ├── transactions.go            ← Transaction recording endpoints\n│   │   └── reports.go                 ← Report generation endpoints\n│   └── middleware/\n│       ├── auth.go                    ← Authentication middleware\n│       └── audit.go                   ← Request audit logging\n└── docs/\n    ├── api/\n    │   └── openapi.yaml               ← API specification\n    └── accounting/\n        └── chart_of_accounts.md       ← Account structure documentation\n```\n\nThis structure follows Go best practices by keeping implementation details in the `internal/` directory while exposing public APIs through the `pkg/` directory. Each component lives in its own package with clear boundaries and minimal cross-package dependencies.\n\n> **Design Insight**: The package structure mirrors the component architecture, making it easy for developers to understand where specific functionality should be implemented. Each package focuses on a single concern and exposes interfaces that other packages can depend on without tight coupling.\n\n### Component Dependencies\n\nThe component dependency structure is carefully designed to prevent circular dependencies while allowing each component to fulfill its responsibilities. The dependencies flow in a clear hierarchy that reflects the natural order of operations in an accounting system.\n\n#### Core Dependency Flow\n\nThe components have a natural dependency hierarchy that reflects the order in which accounting operations must occur. Account definitions must exist before transactions can reference them, transactions must be recorded before balances can be calculated, and all operations must be audited as they occur.\n\n**Component Dependency Hierarchy:**\n\n| Component | Direct Dependencies | Indirect Dependencies | Dependency Rationale |\n|---|---|---|---|\n| Account Management | Storage layer only | None | Foundation component, no business dependencies |\n| Transaction Recording | Account Management, Storage, Audit | Balance Calculation (async) | Must validate accounts exist, needs audit trail |\n| Balance Calculation | Account Management, Storage | Transaction Recording (event-driven) | Needs account definitions, triggered by transactions |\n| Audit Trail | Storage layer only | All other components (observes) | Infrastructure component, observes all operations |\n| Financial Reporting | All other components | Storage (read-only) | Consumer component, aggregates all system data |\n\n#### Interface-Based Communication\n\nComponents communicate through well-defined interfaces rather than direct package dependencies, enabling loose coupling and supporting independent testing and development. Each component exposes its functionality through interfaces that other components can depend on without creating tight coupling to implementation details.\n\n**Account Management Interface:**\n\n| Method | Parameters | Returns | Description |\n|---|---|---|---|\n| `CreateAccount` | `Account` | `error` | Creates new account with validation |\n| `GetAccount` | `accountID string` | `Account, error` | Retrieves account by ID |\n| `GetAccountsByType` | `accountType AccountType` | `[]Account, error` | Lists accounts of specified type |\n| `ValidateAccountReference` | `accountID string` | `bool, error` | Validates account exists and is active |\n| `GetAccountHierarchy` | `rootAccountID string` | `[]Account, error` | Returns account hierarchy tree |\n\n**Transaction Recording Interface:**\n\n| Method | Parameters | Returns | Description |\n|---|---|---|---|\n| `CreateJournalEntry` | `entry JournalEntry` | `string, error` | Creates and validates entry, returns ID |\n| `PostJournalEntry` | `entryID string` | `error` | Posts validated entry atomically |\n| `ReverseJournalEntry` | `entryID, reason string` | `string, error` | Creates reversal entry |\n| `GetJournalEntry` | `entryID string` | `JournalEntry, error` | Retrieves entry with all line items |\n| `ValidateEntry` | `entry JournalEntry` | `error` | Validates entry without creating |\n\n**Balance Calculation Interface:**\n\n| Method | Parameters | Returns | Description |\n|---|---|---|---|\n| `GetCurrentBalance` | `accountID string` | `Money, error` | Current account balance |\n| `GetBalanceAsOfDate` | `accountID string, date time.Time` | `Money, error` | Historical balance query |\n| `GenerateTrialBalance` | `date time.Time` | `TrialBalance, error` | All account balances |\n| `RefreshAccountBalance` | `accountID string` | `error` | Recalculates cached balance |\n| `ValidateTrialBalance` | `date time.Time` | `bool, error` | Verifies debits equal credits |\n\n#### Event-Driven Updates\n\nSeveral components use an event-driven pattern to maintain consistency without creating tight coupling. When transactions are posted, the Transaction Recording Engine publishes events that trigger updates in the Balance Calculation Engine and Audit Trail System.\n\n> **Decision: Event-Driven Balance Updates**\n> - **Context**: Balance calculations need to stay synchronized with posted transactions, but we want to avoid tight coupling between the transaction engine and balance calculator\n> - **Options Considered**: \n>   1. Synchronous balance updates within transaction posting\n>   2. Event-driven asynchronous balance updates\n>   3. Periodic batch balance recalculation\n> - **Decision**: Event-driven asynchronous balance updates with eventual consistency\n> - **Rationale**: Provides loose coupling between components while maintaining reasonable consistency. Failed balance updates can be retried without affecting transaction posting success\n> - **Consequences**: Enables independent scaling and testing of components, but introduces eventual consistency where balances might be briefly stale after transaction posting\n\n**Transaction Events Published:**\n\n| Event Type | Event Data | Triggered By | Consumed By |\n|---|---|---|---|\n| `EntryPosted` | `JournalEntry` with line items | Transaction Recording | Balance Calculation, Audit Trail |\n| `EntryReversed` | `originalEntryID, reversalEntryID` | Transaction Recording | Balance Calculation, Audit Trail |\n| `BalanceUpdated` | `accountID, newBalance, updateTime` | Balance Calculation | Financial Reporting |\n| `AccountCreated` | `Account` details | Account Management | Balance Calculation (cache initialization) |\n\n#### Data Flow Patterns\n\nThe system implements several data flow patterns that ensure consistency while maintaining component independence. These patterns handle the reality that accounting operations often require coordination across multiple components.\n\n**Transaction Posting Flow:**\n\n1. **Validation Phase**: Transaction Recording Engine validates entry format and calls Account Management to verify all referenced accounts exist and are active\n2. **Audit Preparation**: Audit Trail System prepares to log the transaction posting operation with full context\n3. **Atomic Posting**: Transaction Recording Engine posts the journal entry within a database transaction, ensuring either complete success or complete rollback\n4. **Event Publication**: After successful posting, events are published to trigger balance updates and audit logging\n5. **Balance Update**: Balance Calculation Engine processes the posted transaction and updates affected account balances\n6. **Audit Completion**: Audit Trail System records the completed transaction with all metadata\n\n**Report Generation Flow:**\n\n1. **Data Collection**: Financial Reporting Module queries Account Management for chart of accounts structure\n2. **Balance Aggregation**: Module requests current or point-in-time balances from Balance Calculation Engine\n3. **Account Classification**: Module groups accounts by type (asset, liability, etc.) according to financial statement requirements\n4. **Report Formatting**: Module formats the aggregated data according to standard financial statement layouts\n5. **Audit Logging**: Audit Trail System logs the report generation request and completion\n\n### Common Pitfalls\n\n#### ⚠️ **Pitfall: Circular Dependencies Between Components**\n\nA common mistake is creating circular dependencies where Component A depends on Component B, which in turn depends on Component A. This often happens when developers try to make the Balance Calculation Engine directly call the Transaction Recording Engine to get transaction details, while the Transaction Recording Engine calls the Balance Calculation Engine to update balances.\n\n**Why it's wrong**: Circular dependencies make the system impossible to test in isolation and create brittle coupling where changes to one component require changes to multiple other components.\n\n**How to fix**: Use event-driven patterns and interface-based communication. The Transaction Recording Engine publishes events that the Balance Calculation Engine subscribes to, eliminating the circular dependency.\n\n#### ⚠️ **Pitfall: Mixing Component Responsibilities**\n\nDevelopers often put balance calculation logic directly in the Transaction Recording Engine or account validation logic in the Financial Reporting Module, violating the single responsibility principle.\n\n**Why it's wrong**: Mixed responsibilities make components harder to test, maintain, and scale independently. They also create unexpected dependencies that make the system fragile.\n\n**How to fix**: Clearly define each component's responsibility and move functionality to the appropriate component. Use dependency injection to provide components with the interfaces they need from other components.\n\n#### ⚠️ **Pitfall: Synchronous Cross-Component Operations**\n\nImplementing all cross-component operations synchronously creates tight coupling and makes the system fragile to failures in any single component.\n\n**Why it's wrong**: If balance calculation fails, it shouldn't prevent transaction posting from succeeding. Synchronous operations create cascading failures and make the system harder to scale.\n\n**How to fix**: Use asynchronous event-driven patterns for operations that don't require immediate consistency. Only use synchronous calls for operations that must complete together, such as account validation during transaction creation.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|---|---|---|\n| Database | PostgreSQL with pgx driver | PostgreSQL with connection pooling and read replicas |\n| HTTP Framework | Standard library net/http with gorilla/mux | gin-gonic/gin with middleware ecosystem |\n| Configuration | YAML files with gopkg.in/yaml.v2 | Viper with environment variable override |\n| Logging | Standard library log with structured output | logrus or zap with structured logging |\n| Testing | Standard library testing with testify | ginkgo/gomega for BDD-style tests |\n| Database Migrations | Custom migration runner | golang-migrate/migrate |\n| Validation | Custom validation functions | go-playground/validator |\n| Documentation | Godoc with markdown README | Swagger/OpenAPI with automated generation |\n\n#### Recommended File Structure Implementation\n\n```go\n// internal/common/types.go\npackage common\n\nimport (\n    \"time\"\n    \"github.com/shopspring/decimal\"\n)\n\n// Core accounting types used across all components\ntype AccountType string\n\nconst (\n    AccountTypeAsset    AccountType = \"ASSET\"\n    AccountTypeLiability AccountType = \"LIABILITY\"\n    AccountTypeEquity   AccountType = \"EQUITY\"\n    AccountTypeRevenue  AccountType = \"REVENUE\"\n    AccountTypeExpense  AccountType = \"EXPENSE\"\n)\n\ntype EntryStatus string\n\nconst (\n    EntryStatusDraft    EntryStatus = \"DRAFT\"\n    EntryStatusPosted   EntryStatus = \"POSTED\"\n    EntryStatusReversed EntryStatus = \"REVERSED\"\n)\n\ntype Account struct {\n    ID         string      `json:\"id\" db:\"id\"`\n    Code       string      `json:\"code\" db:\"code\"`\n    Name       string      `json:\"name\" db:\"name\"`\n    Type       AccountType `json:\"type\" db:\"type\"`\n    Currency   string      `json:\"currency\" db:\"currency\"`\n    ParentID   *string     `json:\"parent_id\" db:\"parent_id\"`\n    IsActive   bool        `json:\"is_active\" db:\"is_active\"`\n    CreatedAt  time.Time   `json:\"created_at\" db:\"created_at\"`\n    ModifiedAt time.Time   `json:\"modified_at\" db:\"modified_at\"`\n}\n\ntype Money struct {\n    Amount   decimal.Decimal `json:\"amount\" db:\"amount\"`\n    Currency string          `json:\"currency\" db:\"currency\"`\n}\n\ntype JournalEntry struct {\n    ID          string      `json:\"id\" db:\"id\"`\n    Date        time.Time   `json:\"date\" db:\"date\"`\n    Description string      `json:\"description\" db:\"description\"`\n    Reference   string      `json:\"reference\" db:\"reference\"`\n    Status      EntryStatus `json:\"status\" db:\"status\"`\n    CreatedBy   string      `json:\"created_by\" db:\"created_by\"`\n    PostedAt    *time.Time  `json:\"posted_at\" db:\"posted_at\"`\n    Lines       []EntryLine `json:\"lines\"`\n    CreatedAt   time.Time   `json:\"created_at\" db:\"created_at\"`\n}\n\ntype EntryLine struct {\n    ID           string  `json:\"id\" db:\"id\"`\n    JournalID    string  `json:\"journal_id\" db:\"journal_id\"`\n    AccountID    string  `json:\"account_id\" db:\"account_id\"`\n    DebitAmount  *Money  `json:\"debit_amount,omitempty\"`\n    CreditAmount *Money  `json:\"credit_amount,omitempty\"`\n    Description  string  `json:\"description\" db:\"description\"`\n    LineNumber   int     `json:\"line_number\" db:\"line_number\"`\n}\n```\n\n```go\n// internal/common/money.go\npackage common\n\nimport (\n    \"fmt\"\n    \"github.com/shopspring/decimal\"\n)\n\n// Add combines two Money values of the same currency\nfunc (m Money) Add(other Money) (Money, error) {\n    if m.Currency != other.Currency {\n        return Money{}, fmt.Errorf(\"cannot add different currencies: %s and %s\", \n            m.Currency, other.Currency)\n    }\n    \n    return Money{\n        Amount:   m.Amount.Add(other.Amount),\n        Currency: m.Currency,\n    }, nil\n}\n\n// Subtract subtracts other Money value from this one\nfunc (m Money) Subtract(other Money) (Money, error) {\n    if m.Currency != other.Currency {\n        return Money{}, fmt.Errorf(\"cannot subtract different currencies: %s and %s\", \n            m.Currency, other.Currency)\n    }\n    \n    return Money{\n        Amount:   m.Amount.Sub(other.Amount),\n        Currency: m.Currency,\n    }, nil\n}\n\n// IsZero returns true if the amount is zero\nfunc (m Money) IsZero() bool {\n    return m.Amount.IsZero()\n}\n\n// IsPositive returns true if the amount is greater than zero\nfunc (m Money) IsPositive() bool {\n    return m.Amount.IsPositive()\n}\n\n// IsNegative returns true if the amount is less than zero\nfunc (m Money) IsNegative() bool {\n    return m.Amount.IsNegative()\n}\n```\n\n```go\n// internal/storage/database.go\npackage storage\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    _ \"github.com/lib/pq\"\n)\n\ntype DatabaseConfig struct {\n    Host     string `yaml:\"host\"`\n    Port     int    `yaml:\"port\"`\n    User     string `yaml:\"user\"`\n    Password string `yaml:\"password\"`\n    DBName   string `yaml:\"dbname\"`\n    SSLMode  string `yaml:\"sslmode\"`\n}\n\ntype DB struct {\n    conn *sql.DB\n}\n\n// NewDB creates a new database connection with the provided configuration\nfunc NewDB(config DatabaseConfig) (*DB, error) {\n    dsn := fmt.Sprintf(\"host=%s port=%d user=%s password=%s dbname=%s sslmode=%s\",\n        config.Host, config.Port, config.User, config.Password, config.DBName, config.SSLMode)\n    \n    conn, err := sql.Open(\"postgres\", dsn)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to open database: %w\", err)\n    }\n    \n    if err := conn.Ping(); err != nil {\n        return nil, fmt.Errorf(\"failed to ping database: %w\", err)\n    }\n    \n    return &DB{conn: conn}, nil\n}\n\n// WithTransaction executes the provided function within a database transaction\nfunc (db *DB) WithTransaction(fn func(*sql.Tx) error) error {\n    tx, err := db.conn.Begin()\n    if err != nil {\n        return fmt.Errorf(\"failed to begin transaction: %w\", err)\n    }\n    \n    defer func() {\n        if r := recover(); r != nil {\n            tx.Rollback()\n            panic(r)\n        }\n    }()\n    \n    if err := fn(tx); err != nil {\n        if rollbackErr := tx.Rollback(); rollbackErr != nil {\n            return fmt.Errorf(\"transaction error: %w, rollback error: %v\", err, rollbackErr)\n        }\n        return err\n    }\n    \n    if err := tx.Commit(); err != nil {\n        return fmt.Errorf(\"failed to commit transaction: %w\", err)\n    }\n    \n    return nil\n}\n\n// Close closes the database connection\nfunc (db *DB) Close() error {\n    return db.conn.Close()\n}\n```\n\n#### Core Component Interface Skeletons\n\n```go\n// internal/accounts/manager.go\npackage accounts\n\nimport (\n    \"context\"\n    \"ledger-system/internal/common\"\n)\n\n// Manager handles all account-related operations\ntype Manager struct {\n    db Storage\n}\n\ntype Storage interface {\n    CreateAccount(ctx context.Context, account common.Account) error\n    GetAccount(ctx context.Context, accountID string) (common.Account, error)\n    GetAccountsByType(ctx context.Context, accountType common.AccountType) ([]common.Account, error)\n    UpdateAccount(ctx context.Context, account common.Account) error\n    // TODO: Add other storage methods needed for account management\n}\n\n// CreateAccount creates a new account with validation\nfunc (m *Manager) CreateAccount(ctx context.Context, account common.Account) (string, error) {\n    // TODO 1: Generate unique account ID if not provided\n    // TODO 2: Validate account code is unique within the organization\n    // TODO 3: Validate account type is one of the valid AccountType constants\n    // TODO 4: Validate currency code is valid (e.g., ISO 4217)\n    // TODO 5: If ParentID is provided, validate parent account exists and is compatible type\n    // TODO 6: Set creation timestamps\n    // TODO 7: Store account in database\n    // TODO 8: Return generated account ID\n    return \"\", nil\n}\n\n// NormalBalance returns the normal balance type for the account\nfunc (a common.Account) NormalBalance() string {\n    // TODO 1: Return \"DEBIT\" for AccountTypeAsset and AccountTypeExpense\n    // TODO 2: Return \"CREDIT\" for AccountTypeLiability, AccountTypeEquity, and AccountTypeRevenue\n    return \"\"\n}\n\n// IsDebitNormal returns true if this account type normally has debit balances\nfunc (a common.Account) IsDebitNormal() bool {\n    // TODO 1: Return true for asset and expense accounts\n    // TODO 2: Return false for liability, equity, and revenue accounts\n    return false\n}\n```\n\n```go\n// internal/transactions/engine.go\npackage transactions\n\nimport (\n    \"context\"\n    \"ledger-system/internal/common\"\n)\n\n// Engine handles journal entry creation and posting\ntype Engine struct {\n    db           Storage\n    accountMgr   AccountManager\n    eventPub     EventPublisher\n}\n\ntype AccountManager interface {\n    ValidateAccountReference(ctx context.Context, accountID string) (bool, error)\n    GetAccount(ctx context.Context, accountID string) (common.Account, error)\n}\n\ntype EventPublisher interface {\n    PublishEntryPosted(ctx context.Context, entry common.JournalEntry) error\n    PublishEntryReversed(ctx context.Context, originalID, reversalID string) error\n}\n\n// CreateJournalEntry creates and validates a new journal entry\nfunc (e *Engine) CreateJournalEntry(ctx context.Context, entry common.JournalEntry) (string, error) {\n    // TODO 1: Generate unique entry ID if not provided\n    // TODO 2: Validate all referenced accounts exist and are active\n    // TODO 3: Validate that entry has at least 2 line items\n    // TODO 4: Call Validate() method to ensure debits equal credits\n    // TODO 5: Set entry status to EntryStatusDraft\n    // TODO 6: Store entry and all line items in database transaction\n    // TODO 7: Return generated entry ID\n    return \"\", nil\n}\n\n// Validate ensures the journal entry follows double-entry rules\nfunc (e common.JournalEntry) Validate() error {\n    // TODO 1: Check that entry has at least 2 line items\n    // TODO 2: Verify that each line has either DebitAmount OR CreditAmount (not both, not neither)\n    // TODO 3: Calculate total debits using TotalDebits() method\n    // TODO 4: Calculate total credits using TotalCredits() method\n    // TODO 5: Verify total debits equals total credits\n    // TODO 6: Check all amounts are positive\n    // TODO 7: Validate all line items have same currency or handle multi-currency rules\n    return nil\n}\n\n// TotalDebits sums all debit amounts in the journal entry\nfunc (e common.JournalEntry) TotalDebits() (common.Money, error) {\n    // TODO 1: Initialize total Money with zero amount and first currency found\n    // TODO 2: Iterate through all Lines in the journal entry\n    // TODO 3: For each line with DebitAmount, add to running total using Money.Add()\n    // TODO 4: Handle currency conversion if multiple currencies present\n    // TODO 5: Return final total\n    return common.Money{}, nil\n}\n\n// TotalCredits sums all credit amounts in the journal entry\nfunc (e common.JournalEntry) TotalCredits() (common.Money, error) {\n    // TODO 1: Initialize total Money with zero amount and first currency found\n    // TODO 2: Iterate through all Lines in the journal entry\n    // TODO 3: For each line with CreditAmount, add to running total using Money.Add()\n    // TODO 4: Handle currency conversion if multiple currencies present\n    // TODO 5: Return final total\n    return common.Money{}, nil\n}\n```\n\n#### Language-Specific Implementation Hints\n\n**Database Transactions in Go:**\n- Use `sql.Tx` for database transactions with proper rollback handling\n- Always defer rollback with panic recovery to handle unexpected errors\n- Use context.Context for cancellation and timeout handling\n- Implement retry logic for transient database errors\n\n**Decimal Arithmetic:**\n- Use `github.com/shopspring/decimal` package to avoid floating-point precision errors\n- Store decimal values as strings in the database with proper precision\n- Always validate decimal input before performing calculations\n- Use decimal.NewFromString() for parsing user input safely\n\n**Error Handling Patterns:**\n- Wrap errors with context using `fmt.Errorf(\"operation failed: %w\", err)`\n- Create custom error types for business rule violations\n- Use sentinel errors for expected error conditions\n- Log errors at the boundary where they're handled, not where they're generated\n\n**Concurrency Considerations:**\n- Use database transactions for atomic operations across multiple tables\n- Implement optimistic locking for concurrent balance updates\n- Use channels for event publishing to avoid blocking transaction posting\n- Consider using sync.RWMutex for read-heavy cached data\n\n#### Milestone Checkpoints\n\n**After implementing basic component structure:**\n- Run `go build ./...` - should compile without errors\n- Run `go test ./...` - should pass basic interface tests\n- Verify that each component can be imported independently\n- Check that circular dependencies are avoided using `go mod graph`\n\n**After implementing core interfaces:**\n- Create simple test that instantiates each component\n- Verify that components can communicate through interfaces\n- Test that dependency injection works correctly\n- Run integration test creating an account and validating it\n\n**Integration verification:**\n- Post a simple journal entry through the Transaction Recording Engine\n- Verify that Account Management validates the referenced accounts\n- Check that Balance Calculation Engine receives the posting event\n- Confirm that Audit Trail System logs the complete operation\n\n**Performance baseline:**\n- Measure time to post 1000 journal entries sequentially\n- Test balance calculation performance with 10,000 transactions\n- Verify that trial balance generation completes in under 5 seconds\n- Check memory usage doesn't grow unbounded during batch operations\n\n\n## Data Model\n\n> **Milestone(s):** 1 (Account & Entry Model), 2 (Transaction Recording), 4 (Audit Trail), as this section establishes the core database schema and data structures that support account hierarchies, double-entry transactions, monetary handling, and immutable audit logging\n\nThe data model forms the foundation of our double-entry ledger system, defining how financial information is stored, related, and maintained. Think of the data model as the blueprint for a bank vault — it must be precisely engineered to ensure every dollar is accounted for, every transaction is traceable, and the integrity of financial records is absolutely guaranteed.\n\n### Chart of Accounts Structure\n\nThe chart of accounts serves as the organizational backbone of any accounting system, much like how a library's cataloging system organizes books into categories that make them easy to find and understand. Each account represents a specific financial classification where monetary amounts can be recorded, whether that's cash in a checking account, amounts owed to suppliers, or revenue from customer sales.\n\nOur account structure follows the fundamental accounting equation: **Assets = Liabilities + Equity**, with the addition of Revenue and Expense accounts that ultimately flow into Equity through the closing process. This creates five primary account types that serve different purposes in tracking an organization's financial position and performance.\n\n![Chart of Accounts Hierarchy Structure](./diagrams/account-hierarchy.svg)\n\nThe `Account` entity serves as the fundamental building block of our chart of accounts. Each account contains identification information, categorization details, and hierarchical relationships that enable sophisticated financial reporting and analysis.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| ID | string | Universally unique identifier for the account, typically a UUID |\n| Code | string | Human-readable account code following organizational numbering scheme |\n| Name | string | Descriptive name for the account (e.g., \"Accounts Receivable\", \"Office Supplies\") |\n| Type | AccountType | Classification as ASSET, LIABILITY, EQUITY, REVENUE, or EXPENSE |\n| Currency | string | ISO 4217 currency code for multi-currency support (e.g., \"USD\", \"EUR\") |\n| ParentID | *string | Optional reference to parent account for hierarchical organization |\n| IsActive | bool | Flag indicating whether the account accepts new transactions |\n| CreatedAt | time.Time | Timestamp when the account was initially created |\n| ModifiedAt | time.Time | Timestamp of the most recent account modification |\n\nThe `AccountType` enumeration defines the five fundamental categories that determine how accounts behave in double-entry bookkeeping. Each account type has a **normal balance** that indicates whether increases to that account are recorded as debits or credits.\n\n| Account Type | Normal Balance | Increases With | Common Examples |\n|--------------|----------------|----------------|-----------------|\n| ASSET | Debit | Debits | Cash, Accounts Receivable, Equipment, Inventory |\n| LIABILITY | Credit | Credits | Accounts Payable, Notes Payable, Accrued Expenses |\n| EQUITY | Credit | Credits | Common Stock, Retained Earnings, Owner's Equity |\n| REVENUE | Credit | Credits | Sales Revenue, Service Revenue, Interest Income |\n| EXPENSE | Debit | Debits | Salary Expense, Rent Expense, Office Supplies |\n\n> **Decision: Hierarchical Account Structure with Parent-Child Relationships**\n> - **Context**: Organizations need to organize accounts into logical groups for reporting purposes. For example, \"Cash\" might have sub-accounts for \"Checking Account\" and \"Petty Cash\".\n> - **Options Considered**: Flat account structure with categories, hierarchical parent-child relationships, or tag-based classification system\n> - **Decision**: Implement parent-child relationships with unlimited nesting depth using ParentID foreign key\n> - **Rationale**: Hierarchical structure matches how accountants naturally think about account organization and enables drill-down reporting from summary to detail levels. Parent-child relationships are simple to implement and query efficiently.\n> - **Consequences**: Enables sophisticated reporting at multiple levels of detail, but requires careful validation to prevent circular references and orphaned accounts.\n\nThe account coding scheme provides a systematic way to organize and identify accounts within the chart of accounts. Most organizations use a numbering system where the first digit indicates the account type: 1xxx for Assets, 2xxx for Liabilities, 3xxx for Equity, 4xxx for Revenue, and 5xxx for Expenses. This creates an intuitive mapping between account codes and their financial statement presentation.\n\n**Account Hierarchy Design Principles:**\n\n1. **Consistent Numbering**: All accounts at the same level should follow consistent numbering patterns to maintain logical organization\n2. **Room for Growth**: Leave gaps in numbering sequences to accommodate future account additions without disrupting the existing structure\n3. **Meaningful Names**: Account names should be descriptive enough to understand their purpose without requiring additional documentation\n4. **Type Inheritance**: Child accounts must always be the same type as their parent account to maintain financial statement integrity\n\n### Journal Entry Schema\n\nJournal entries represent the core mechanism for recording financial transactions in our double-entry system. Think of a journal entry as a complete story about a business transaction — it captures not just the monetary amounts, but the context, timing, and authorization details that make the transaction meaningful and auditable.\n\n![Core Data Model Entity Relationships](./diagrams/data-model-relationships.svg)\n\nEach journal entry consists of a header record containing metadata about the transaction, and multiple line items that specify which accounts are affected and by how much. This separation allows us to capture both the overall transaction context and the detailed account-level impacts in a normalized, efficient structure.\n\nThe `JournalEntry` entity serves as the transaction header, containing information that applies to the entire transaction regardless of how many accounts are involved.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| ID | string | Unique identifier for this journal entry, typically a UUID |\n| Date | time.Time | Business date when the transaction occurred (not necessarily when recorded) |\n| Description | string | Human-readable explanation of the transaction purpose |\n| Reference | string | External reference number (invoice, check number, etc.) for audit trail |\n| Status | EntryStatus | Current state of the entry (DRAFT, POSTED, REVERSED) |\n| CreatedBy | string | User ID of the person who created this journal entry |\n| PostedAt | *time.Time | Timestamp when entry was officially posted to the ledger |\n| Lines | []EntryLine | Collection of account line items that comprise this transaction |\n| CreatedAt | time.Time | System timestamp when the entry record was created |\n\nThe `EntryStatus` enumeration tracks the lifecycle of journal entries through their various states from creation to final posting:\n\n| Status | Description | Allowed Transitions | Validation Requirements |\n|--------|-------------|-------------------|------------------------|\n| DRAFT | Entry is being created/edited | → POSTED | Lines may be unbalanced, all fields editable |\n| POSTED | Entry is permanently recorded | → REVERSED | Must be balanced, immutable except for status changes |\n| REVERSED | Entry has been canceled by offsetting entry | None | Original entry preserved, reversal entry created separately |\n\nIndividual line items within a journal entry are represented by the `EntryLine` entity, which creates the actual double-entry bookkeeping records by specifying which accounts are debited or credited:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| ID | string | Unique identifier for this specific line item |\n| JournalID | string | Foreign key reference to the parent journal entry |\n| AccountID | string | Foreign key reference to the account being affected |\n| DebitAmount | *Money | Amount to debit to this account (null if this is a credit line) |\n| CreditAmount | *Money | Amount to credit to this account (null if this is a debit line) |\n| Description | string | Line-specific description (often same as journal entry description) |\n| LineNumber | int | Sequence number for maintaining line item order |\n\n> **Decision: Separate Debit and Credit Amount Fields**\n> - **Context**: Each line item needs to record either a debit or credit amount, but never both simultaneously\n> - **Options Considered**: Single amount field with separate debit/credit indicator, separate nullable debit/credit fields, or signed amount where positive=debit and negative=credit\n> - **Decision**: Use separate nullable `DebitAmount` and `CreditAmount` fields where exactly one is populated per line\n> - **Rationale**: This approach makes the double-entry nature explicit in the data structure and prevents logical errors where both fields might be populated. Queries for debits vs credits become simple null checks.\n> - **Consequences**: Slightly more complex validation logic to ensure exactly one field is populated, but much clearer semantic meaning and easier financial reporting.\n\n**Journal Entry Validation Rules:**\n\nThe system enforces several critical validation rules that maintain the integrity of double-entry bookkeeping:\n\n1. **Balance Requirement**: The sum of all debit amounts must exactly equal the sum of all credit amounts within a single journal entry\n2. **Account Existence**: Every referenced AccountID must exist and be active at the time of entry creation\n3. **Currency Consistency**: All line items within a single journal entry must use the same currency, or proper exchange rate conversion must be applied\n4. **Line Item Completeness**: Each line item must have exactly one of DebitAmount or CreditAmount populated, never both or neither\n5. **Minimum Lines**: Each journal entry must contain at least two line items (since every transaction affects at least two accounts)\n\n### Monetary Amount Handling\n\nFinancial calculations demand absolute precision — a discrepancy of even one cent can cause hours of reconciliation work and regulatory compliance issues. Think of monetary amounts like precision instruments in a laboratory: you need exactly the right tools to measure accurately, and any approximation or rounding error can invalidate your entire experiment.\n\nTraditional floating-point arithmetic is fundamentally unsuitable for financial calculations because decimal fractions cannot be represented exactly in binary floating-point formats. For example, the simple calculation `0.1 + 0.2` produces `0.30000000000000004` in most programming languages, which is unacceptable when dealing with money.\n\n> **Decision: Fixed-Point Decimal Arithmetic with Currency Awareness**\n> - **Context**: Financial calculations require exact decimal arithmetic without floating-point rounding errors, and multi-currency support demands currency-aware operations\n> - **Options Considered**: Store cents as integers, use floating-point with rounding, implement fixed-point decimal library, or delegate to database decimal types\n> - **Decision**: Implement a `Money` type using fixed-point decimal arithmetic with explicit currency codes\n> - **Rationale**: Fixed-point decimals eliminate rounding errors entirely, while currency-aware types prevent accidental cross-currency arithmetic. This approach provides both mathematical precision and logical safety.\n> - **Consequences**: Slightly more complex arithmetic operations, but guaranteed precision and protection against currency mismatch errors that could corrupt financial data.\n\nThe `Money` type encapsulates both a precise decimal amount and its associated currency, ensuring that all monetary calculations maintain both mathematical accuracy and logical consistency:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| Amount | decimal.Decimal | Fixed-point decimal representing the monetary amount |\n| Currency | string | ISO 4217 currency code (e.g., \"USD\", \"EUR\", \"GBP\") |\n\n**Key Monetary Operations:**\n\nThe `Money` type supports essential arithmetic operations while enforcing currency compatibility:\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| Add | other Money | Money, error | Adds two amounts of the same currency, returns error for currency mismatch |\n| Subtract | other Money | Money, error | Subtracts two amounts of the same currency, returns error for currency mismatch |\n| Multiply | decimal.Decimal | Money | Multiplies the amount by a scalar (for calculations like tax rates) |\n| Divide | decimal.Decimal | Money, error | Divides the amount by a scalar, returns error for division by zero |\n| Negate | none | Money | Returns the negative of this amount (useful for reversals) |\n| IsZero | none | bool | Returns true if the amount is exactly zero |\n| Compare | other Money | int, error | Returns -1, 0, or 1 for less than, equal, or greater than comparison |\n\n**Currency Handling Principles:**\n\n1. **Explicit Currency Assignment**: Every monetary amount must have an explicitly assigned currency — no default assumptions\n2. **Currency Validation**: All currency codes must conform to ISO 4217 standards and be validated against a known currency registry\n3. **Cross-Currency Prevention**: Arithmetic operations between different currencies are explicitly forbidden and return errors\n4. **Exchange Rate Separation**: Currency conversion is handled separately from basic arithmetic to maintain audit trails\n5. **Precision Consistency**: All amounts within the same currency use consistent decimal precision (typically 2 decimal places for most currencies)\n\n**Storage Format Considerations:**\n\nWhen persisting monetary amounts to the database, we store the decimal amount as a string representation to maintain exact precision across all database systems. This avoids potential precision loss that could occur with native database decimal types that might have different precision limits or rounding behaviors.\n\n```markdown\nStorage Example:\n- Amount: 123.45 USD\n- Database storage: amount_str = \"123.45\", currency = \"USD\"\n- Never store as: amount_float = 123.45000000000001\n```\n\n### Audit Trail Schema\n\nThe audit trail serves as the immutable memory of our accounting system — every change, every transaction, and every modification is permanently recorded in a way that cannot be altered or deleted. Think of the audit trail as a blockchain for accounting: each record is cryptographically linked to the previous one, creating a tamper-evident chain that provides absolute confidence in the integrity of financial data.\n\nRegulatory compliance and financial integrity require that we maintain complete records of not just what the current state of accounts is, but how that state was reached through a series of transactions and modifications. This creates accountability, enables forensic analysis, and provides the documentation necessary for external audits.\n\n> **Decision: Immutable Append-Only Audit Log with Cryptographic Integrity**\n> - **Context**: Regulatory requirements demand complete, unalterable records of all financial transactions and system changes for audit purposes and fraud detection\n> - **Options Considered**: Mutable audit tables with soft deletes, immutable append-only logs, or external audit service integration\n> - **Decision**: Implement append-only audit tables with cryptographic hash chains to detect tampering\n> - **Rationale**: Append-only design prevents data corruption or manipulation, while hash chains provide mathematical proof of data integrity. This approach satisfies regulatory requirements while being implementable within our system.\n> - **Consequences**: Storage grows continuously and requires archival strategy, but provides absolute confidence in audit trail integrity and regulatory compliance.\n\nThe audit trail consists of multiple interconnected tables that capture different aspects of system activity:\n\n**AuditEvent Schema:**\n\nThe `AuditEvent` table serves as the primary audit log, recording every significant action that occurs within the system:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| ID | string | Unique identifier for this audit event |\n| Timestamp | time.Time | Exact time when the event occurred (stored in UTC) |\n| EventType | string | Classification of the event (ACCOUNT_CREATED, ENTRY_POSTED, etc.) |\n| ActorID | string | User ID of the person or system that triggered this event |\n| ActorType | string | Type of actor (USER, SYSTEM, API_CLIENT) for different authorization contexts |\n| EntityType | string | Type of entity being modified (ACCOUNT, JOURNAL_ENTRY, etc.) |\n| EntityID | string | Unique identifier of the specific entity that was modified |\n| Action | string | Specific action performed (CREATE, UPDATE, DELETE, POST, REVERSE) |\n| BeforeState | *string | JSON representation of entity state before modification |\n| AfterState | *string | JSON representation of entity state after modification |\n| ChangeDescription | string | Human-readable description of what changed |\n| SessionID | string | Session identifier for grouping related activities |\n| IPAddress | string | Source IP address for security auditing |\n| UserAgent | string | Browser/client information for security analysis |\n| PreviousHash | *string | Cryptographic hash of the previous audit event for chain integrity |\n| CurrentHash | string | Cryptographic hash of this audit event for tamper detection |\n\n**EntryAuditLog Schema:**\n\nThe `EntryAuditLog` table provides specialized audit tracking for journal entries, capturing the complete lifecycle from draft creation through posting and potential reversal:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| ID | string | Unique identifier for this entry audit record |\n| JournalEntryID | string | Foreign key to the journal entry being audited |\n| Timestamp | time.Time | When this audit event occurred |\n| Action | string | Specific action (CREATED, MODIFIED, POSTED, REVERSED) |\n| ActorID | string | User who performed this action |\n| PreviousStatus | *EntryStatus | Entry status before this action |\n| NewStatus | EntryStatus | Entry status after this action |\n| FieldsChanged | []string | List of field names that were modified |\n| Reason | string | Business justification for the change |\n| ApprovalRequired | bool | Whether this action required supervisor approval |\n| ApproverID | *string | User ID of approving supervisor if applicable |\n| ValidatedAt | *time.Time | When validation checks were performed |\n| ValidationResults | string | JSON of validation check results |\n\n**AccountBalanceSnapshot Schema:**\n\nThe `AccountBalanceSnapshot` table maintains point-in-time balance records that serve both performance optimization and audit verification purposes:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| ID | string | Unique identifier for this balance snapshot |\n| AccountID | string | Foreign key to the account |\n| SnapshotDate | time.Time | The date for which this balance is calculated |\n| DebitBalance | Money | Total debit balance as of the snapshot date |\n| CreditBalance | Money | Total credit balance as of the snapshot date |\n| NetBalance | Money | Net balance considering account type normal balance |\n| EntryCount | int | Number of journal entry lines included in this balance |\n| LastEntryID | string | ID of the most recent journal entry included |\n| SnapshotReason | string | Why this snapshot was created (DAILY_CLOSE, MONTH_END, etc.) |\n| CreatedAt | time.Time | When this snapshot was generated |\n| VerifiedAt | *time.Time | When this balance was independently verified |\n| VerificationHash | string | Cryptographic hash of all entries contributing to this balance |\n\n**Cryptographic Integrity Implementation:**\n\nThe audit trail implements a hash chain mechanism where each audit event includes a cryptographic hash of the previous event, creating a tamper-evident sequence. This design makes it mathematically impossible to modify historical records without detection:\n\n1. **Hash Calculation**: Each audit event's hash is computed from its complete content plus the hash of the previous event\n2. **Chain Validation**: The system can verify the entire audit chain by recalculating hashes and comparing them to stored values\n3. **Tamper Detection**: Any modification to historical records will cause hash validation to fail at the point of tampering and all subsequent records\n4. **Integrity Reports**: Regular integrity checks can be automated to detect corruption or unauthorized modifications\n\n**Audit Event Categories:**\n\nThe system tracks several categories of events that require audit logging:\n\n| Event Category | Typical Events | Retention Period | Regulatory Requirement |\n|----------------|----------------|------------------|----------------------|\n| Account Management | CREATE_ACCOUNT, MODIFY_ACCOUNT, DEACTIVATE_ACCOUNT | Permanent | Chart of accounts changes |\n| Transaction Recording | CREATE_ENTRY, POST_ENTRY, REVERSE_ENTRY | Permanent | All financial transactions |\n| Balance Calculations | BALANCE_CALCULATED, BALANCE_VERIFIED | 7 years | Balance verification records |\n| User Actions | LOGIN, LOGOUT, PERMISSION_CHANGE | 3 years | Access control compliance |\n| System Events | BACKUP_CREATED, SYSTEM_RESTART | 1 year | Operational audit trail |\n| Data Corrections | ERROR_CORRECTION, MANUAL_ADJUSTMENT | Permanent | Correction documentation |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Using Floating-Point Arithmetic for Monetary Calculations**\nMany developers instinctively use `float64` or similar floating-point types for money, which leads to precision errors that compound over time. For example, calculating `0.1 + 0.2` in floating-point arithmetic doesn't equal `0.3` exactly. In a financial system, these tiny errors can accumulate into significant discrepancies that require manual reconciliation. Always use fixed-point decimal arithmetic with libraries like `decimal.Decimal` that store monetary amounts as integers with an implicit decimal point.\n\n⚠️ **Pitfall: Allowing Modifications to Posted Journal Entries**\nJunior developers often design journal entries as mutable records that can be updated after posting. This breaks the fundamental principle of accounting immutability and destroys the audit trail. Once a journal entry is posted, it must never be modified or deleted — corrections must be handled through reversing entries that create an offsetting transaction. Implement database constraints that prevent UPDATE or DELETE operations on posted entries.\n\n⚠️ **Pitfall: Missing Currency Validation in Multi-Currency Systems**\nWhen supporting multiple currencies, it's tempting to store monetary amounts as simple numbers without enforcing currency consistency. This leads to situations where USD amounts get added to EUR amounts, producing meaningless results. Always store currency codes alongside monetary amounts and validate that arithmetic operations only occur between amounts of the same currency. Require explicit currency conversion with documented exchange rates for cross-currency operations.\n\n⚠️ **Pitfall: Inadequate Parent-Child Relationship Validation**\nAccount hierarchies can become corrupted if the system allows circular references (Account A is parent of Account B, which is parent of Account A) or type mismatches (Asset account has Liability parent). Implement validation logic that checks for circular references using graph traversal algorithms and enforces that child accounts must have the same AccountType as their parent account.\n\n⚠️ **Pitfall: Storing Audit Logs in Mutable Database Tables**\nSome developers implement audit trails using standard database tables that support UPDATE and DELETE operations. This creates a false sense of security because audit records can be modified or removed, defeating the purpose of audit logging. Implement audit tables with database-level constraints that prevent modifications, use append-only storage mechanisms, or consider write-once storage technologies for critical audit data.\n\n### Implementation Guidance\n\n**A. Technology Recommendations Table:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Database | PostgreSQL with JSONB for metadata | PostgreSQL with separate audit database |\n| Decimal Library | shopspring/decimal for Go | Custom fixed-point implementation |\n| UUID Generation | google/uuid standard library | Ordered UUIDs with timestamp prefix |\n| Hash Functions | crypto/sha256 from standard library | BLAKE2b for faster cryptographic hashing |\n| Currency Validation | Static ISO 4217 currency list | Dynamic currency service with rates |\n| Schema Migration | golang-migrate/migrate | Custom migration framework with rollback |\n\n**B. Recommended File/Module Structure:**\n\n```\nproject-root/\n  internal/model/\n    account.go                  ← Account type definitions and validation\n    journal_entry.go           ← Journal entry and line item types\n    money.go                   ← Money type with decimal arithmetic\n    audit.go                   ← Audit trail types and integrity checking\n    validation.go              ← Business rule validation functions\n    types.go                   ← Enums and constants (AccountType, EntryStatus)\n  internal/repository/\n    account_repository.go      ← Account CRUD operations\n    entry_repository.go        ← Journal entry persistence\n    audit_repository.go        ← Audit trail recording\n  migrations/\n    001_create_accounts.sql    ← Account table creation\n    002_create_entries.sql     ← Journal entry table creation\n    003_create_audit.sql       ← Audit trail table creation\n  pkg/decimal/                 ← Reusable decimal arithmetic utilities\n    decimal.go\n    money.go\n```\n\n**C. Infrastructure Starter Code (COMPLETE):**\n\nDatabase connection and transaction management utility:\n\n```go\npackage repository\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    _ \"github.com/lib/pq\" // PostgreSQL driver\n)\n\ntype DatabaseConfig struct {\n    Host     string\n    Port     int\n    User     string\n    Password string\n    DBName   string\n    SSLMode  string\n}\n\nfunc NewConnection(config DatabaseConfig) (*sql.DB, error) {\n    dsn := fmt.Sprintf(\n        \"host=%s port=%d user=%s password=%s dbname=%s sslmode=%s\",\n        config.Host, config.Port, config.User, config.Password, \n        config.DBName, config.SSLMode,\n    )\n    \n    db, err := sql.Open(\"postgres\", dsn)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to open database: %w\", err)\n    }\n    \n    if err := db.Ping(); err != nil {\n        return nil, fmt.Errorf(\"failed to ping database: %w\", err)\n    }\n    \n    return db, nil\n}\n\n// WithTransaction executes a function within a database transaction\nfunc WithTransaction(db *sql.DB, fn func(*sql.Tx) error) error {\n    tx, err := db.Begin()\n    if err != nil {\n        return fmt.Errorf(\"failed to begin transaction: %w\", err)\n    }\n    \n    defer func() {\n        if p := recover(); p != nil {\n            tx.Rollback()\n            panic(p)\n        } else if err != nil {\n            tx.Rollback()\n        } else {\n            err = tx.Commit()\n        }\n    }()\n    \n    err = fn(tx)\n    return err\n}\n```\n\nUUID generation utility:\n\n```go\npackage model\n\nimport (\n    \"github.com/google/uuid\"\n)\n\nfunc NewID() string {\n    return uuid.New().String()\n}\n\nfunc IsValidID(id string) bool {\n    _, err := uuid.Parse(id)\n    return err == nil\n}\n```\n\n**D. Core Logic Skeleton Code (signature + TODOs only):**\n\nMoney type implementation skeleton:\n\n```go\npackage model\n\nimport (\n    \"github.com/shopspring/decimal\"\n    \"fmt\"\n)\n\n// Money represents a monetary amount with currency\ntype Money struct {\n    Amount   decimal.Decimal\n    Currency string\n}\n\n// NewMoney creates a new Money instance with validation\nfunc NewMoney(amount decimal.Decimal, currency string) (Money, error) {\n    // TODO 1: Validate that currency is a valid ISO 4217 code\n    // TODO 2: Validate that amount has appropriate precision for currency\n    // TODO 3: Return Money instance or error for invalid inputs\n    // Hint: Most currencies use 2 decimal places, some like JPY use 0\n}\n\n// Add combines two Money values of the same currency\nfunc (m Money) Add(other Money) (Money, error) {\n    // TODO 1: Check that both Money values have the same currency\n    // TODO 2: Add the decimal amounts using decimal.Decimal.Add()\n    // TODO 3: Return new Money with sum and original currency\n    // TODO 4: Return error if currencies don't match\n}\n\n// Subtract subtracts two Money values of the same currency\nfunc (m Money) Subtract(other Money) (Money, error) {\n    // TODO 1: Check that both Money values have the same currency\n    // TODO 2: Subtract using decimal.Decimal.Sub() method\n    // TODO 3: Return new Money with difference and original currency\n    // TODO 4: Return error if currencies don't match\n}\n```\n\nAccount type implementation skeleton:\n\n```go\npackage model\n\nimport (\n    \"time\"\n)\n\ntype AccountType string\n\nconst (\n    AccountTypeAsset     AccountType = \"ASSET\"\n    AccountTypeLiability AccountType = \"LIABILITY\"\n    AccountTypeEquity    AccountType = \"EQUITY\"\n    AccountTypeRevenue   AccountType = \"REVENUE\"\n    AccountTypeExpense   AccountType = \"EXPENSE\"\n)\n\ntype Account struct {\n    ID         string\n    Code       string\n    Name       string\n    Type       AccountType\n    Currency   string\n    ParentID   *string\n    IsActive   bool\n    CreatedAt  time.Time\n    ModifiedAt time.Time\n}\n\n// NormalBalance returns whether this account type normally has a debit or credit balance\nfunc (a Account) NormalBalance() string {\n    // TODO 1: Return \"DEBIT\" for asset and expense account types\n    // TODO 2: Return \"CREDIT\" for liability, equity, and revenue account types\n    // Hint: Assets and Expenses increase with debits, others increase with credits\n}\n\n// IsDebitNormal returns true if this account type increases with debits\nfunc (a Account) IsDebitNormal() bool {\n    // TODO 1: Return true for ASSET and EXPENSE account types\n    // TODO 2: Return false for LIABILITY, EQUITY, and REVENUE account types\n    // Hint: Use the NormalBalance() method and compare to \"DEBIT\"\n}\n\n// Validate performs business rule validation on the account\nfunc (a Account) Validate() error {\n    // TODO 1: Check that Code is not empty and follows numbering conventions\n    // TODO 2: Check that Name is not empty and reasonably descriptive\n    // TODO 3: Check that Currency is a valid ISO 4217 code\n    // TODO 4: Check that ParentID references an existing account if not nil\n    // TODO 5: Check that account type matches parent account type if parent exists\n    // TODO 6: Return specific error messages for each validation failure\n}\n```\n\nJournal entry implementation skeleton:\n\n```go\npackage model\n\nimport (\n    \"time\"\n)\n\ntype EntryStatus string\n\nconst (\n    EntryStatusDraft    EntryStatus = \"DRAFT\"\n    EntryStatusPosted   EntryStatus = \"POSTED\"\n    EntryStatusReversed EntryStatus = \"REVERSED\"\n)\n\ntype JournalEntry struct {\n    ID          string\n    Date        time.Time\n    Description string\n    Reference   string\n    Status      EntryStatus\n    CreatedBy   string\n    PostedAt    *time.Time\n    Lines       []EntryLine\n    CreatedAt   time.Time\n}\n\ntype EntryLine struct {\n    ID           string\n    JournalID    string\n    AccountID    string\n    DebitAmount  *Money\n    CreditAmount *Money\n    Description  string\n    LineNumber   int\n}\n\n// TotalDebits calculates the sum of all debit amounts in this journal entry\nfunc (je JournalEntry) TotalDebits() (Money, error) {\n    // TODO 1: Initialize a zero Money value in the entry's base currency\n    // TODO 2: Iterate through all Lines in the journal entry\n    // TODO 3: For each line where DebitAmount is not nil, add it to the total\n    // TODO 4: Check that all debit amounts have the same currency\n    // TODO 5: Return the total debits or error if currencies don't match\n    // Hint: You'll need to determine the base currency from the first non-nil amount\n}\n\n// TotalCredits calculates the sum of all credit amounts in this journal entry\nfunc (je JournalEntry) TotalCredits() (Money, error) {\n    // TODO 1: Initialize a zero Money value in the entry's base currency\n    // TODO 2: Iterate through all Lines in the journal entry\n    // TODO 3: For each line where CreditAmount is not nil, add it to the total\n    // TODO 4: Check that all credit amounts have the same currency\n    // TODO 5: Return the total credits or error if currencies don't match\n}\n\n// Validate ensures this journal entry follows double-entry bookkeeping rules\nfunc (je JournalEntry) Validate() error {\n    // TODO 1: Check that the entry has at least 2 lines (minimum for double-entry)\n    // TODO 2: Check that each line has exactly one of DebitAmount or CreditAmount\n    // TODO 3: Calculate total debits and total credits using the methods above\n    // TODO 4: Verify that total debits exactly equals total credits\n    // TODO 5: Check that all referenced AccountIDs exist and are active\n    // TODO 6: Check that Date is not in the future\n    // TODO 7: Return specific error describing any validation failures\n    // Hint: Use decimal.Decimal.Equal() for exact monetary comparisons\n}\n```\n\n**E. Language-Specific Hints:**\n\n- Use `github.com/shopspring/decimal` for precise decimal arithmetic in Go\n- Use `database/sql` with prepared statements to prevent SQL injection\n- Use `time.UTC` for all stored timestamps to avoid timezone confusion\n- Use PostgreSQL's `CHECK` constraints to enforce database-level validation\n- Use `sql.NullString` for optional foreign key fields like ParentID\n- Use Go's struct tags for JSON serialization: `json:\"field_name\"`\n- Use `SERIAL` or `BIGSERIAL` for auto-incrementing ID fields if not using UUIDs\n- Use PostgreSQL's `NUMERIC` type for storing decimal amounts as strings\n\n**F. Milestone Checkpoint:**\n\nAfter implementing the core data model, you should be able to:\n\n1. **Create Account Records**: Run `INSERT` statements to create accounts with proper parent-child relationships and verify the account hierarchy is maintained correctly.\n\n2. **Validate Journal Entries**: Create test journal entries with both balanced and unbalanced amounts, confirming that validation catches unbalanced entries and allows balanced ones.\n\n3. **Test Money Arithmetic**: Perform addition and subtraction operations on Money values, verifying that same-currency operations succeed and cross-currency operations fail with appropriate errors.\n\n4. **Verify Audit Trail Creation**: Insert records and confirm that audit events are automatically created with proper hash chains and tamper-evident properties.\n\n**Expected Test Command**: `go test ./internal/model/... -v`\n\n**Expected Behavior Verification**:\n- Account hierarchy queries return proper parent-child relationships\n- Journal entry validation rejects entries where debits ≠ credits  \n- Money arithmetic operations maintain precision without floating-point errors\n- Audit trail maintains cryptographic hash chain integrity\n- Database constraints prevent deletion of posted journal entries\n\n**Signs of Problems**:\n- Floating-point precision errors in monetary calculations (values like 0.10000000000000001)\n- Circular reference loops in account hierarchy causing infinite recursion\n- Posted journal entries that can be modified or deleted\n- Audit hash chains that don't validate properly after record insertion\n- Cross-currency arithmetic operations that succeed instead of failing\n\n\n> **Milestone(s):** 1 (Account & Entry Model), as this section defines the chart of accounts structure, account type validation, and hierarchy management that form the foundation for all journal entries and financial reporting\n\n## Account Management Component\n\nThe account management component serves as the foundation of any double-entry ledger system, much like how a filing cabinet's drawer labels and organization system determines whether you can efficiently find and categorize documents. Think of accounts as the labeled buckets where every financial transaction must be sorted - without a well-organized chart of accounts, even perfect transaction recording becomes meaningless because you cannot produce coherent financial reports or maintain proper oversight of different types of assets, obligations, and business activities.\n\nThis component owns the complete lifecycle of financial accounts within the system, from initial setup of the chart of accounts through daily operations of validating transactions against account rules. The account manager acts as the gatekeeper ensuring that only valid accounts exist in the system, that the account hierarchy remains logically consistent, and that all transaction recording respects the fundamental rules of double-entry bookkeeping regarding which account types can receive debits versus credits.\n\n![Chart of Accounts Hierarchy Structure](./diagrams/account-hierarchy.svg)\n\nThe account management component enforces the fundamental accounting equation: **Assets = Liabilities + Equity**. This equation must hold true after every transaction, and the account type system provides the structural foundation that makes this possible. Each account type has specific rules about its normal balance (debit or credit), which accounts it can interact with in journal entries, and how it contributes to different financial statements.\n\n### Account Type System\n\nThe account type system implements the five fundamental categories of accounts that comprise all possible financial activities in double-entry bookkeeping. Think of account types as the genetic code of accounting - just as DNA determines whether a cell becomes muscle, bone, or nerve tissue, the account type determines how an account behaves in transactions, which side of the accounting equation it belongs to, and how it appears in financial reports.\n\nEach account type carries with it an intrinsic **normal balance** - the side (debit or credit) where increases to that account type are recorded. This is not arbitrary but derives from the fundamental accounting equation and centuries of bookkeeping practice. Understanding normal balances is crucial because they determine transaction validation rules and balance sheet presentation.\n\n> **The Double-Entry Mental Model**: Imagine a medieval merchant's ledger where every transaction tells a complete story. If gold coins leave the cash drawer (credit to Cash account), they must go somewhere - perhaps to purchase inventory (debit to Inventory account) or pay a debt (debit to Accounts Payable). The account types ensure that every \"where it came from\" has a corresponding \"where it went\" that maintains the fundamental balance.\n\n| Account Type | Normal Balance | Accounting Equation Side | Increases With | Decreases With | Financial Statement |\n|--------------|----------------|-------------------------|----------------|----------------|-------------------|\n| ASSET | Debit | Left (Assets) | Debit entries | Credit entries | Balance Sheet |\n| LIABILITY | Credit | Right (Liabilities) | Credit entries | Debit entries | Balance Sheet |\n| EQUITY | Credit | Right (Equity) | Credit entries | Debit entries | Balance Sheet |\n| REVENUE | Credit | Right (increases Equity) | Credit entries | Debit entries | Income Statement |\n| EXPENSE | Debit | Left (decreases Equity) | Debit entries | Credit entries | Income Statement |\n\nThe account type system must enforce these rules automatically during transaction validation. When a journal entry attempts to debit a liability account, the system should not reject it outright - debiting liabilities is how you reduce them (like making a loan payment). However, the system must understand that this debit reduces the liability balance, not increases it, which affects how balances are calculated and displayed.\n\n**Asset accounts** represent resources owned by the organization that provide future economic benefit. These include tangible items like cash, inventory, and equipment, as well as intangible assets like patents and goodwill. Asset accounts have debit normal balances because they sit on the left side of the accounting equation. When you acquire more assets, you debit the asset account to increase it. When assets are consumed or sold, you credit the asset account to decrease it.\n\n**Liability accounts** represent obligations owed to external parties that must be settled in the future. These include accounts payable, loans, accrued expenses, and unearned revenue. Liability accounts have credit normal balances because they appear on the right side of the accounting equation. When you incur a new obligation, you credit the liability account to increase it. When you pay off debts, you debit the liability account to decrease it.\n\n**Equity accounts** represent the owners' residual interest in the organization after all liabilities are subtracted from assets. This includes contributed capital, retained earnings, and current period net income. Equity accounts have credit normal balances and increase when the organization becomes more valuable to owners. Revenue increases equity (through retained earnings), while expenses and dividends decrease equity.\n\n**Revenue accounts** track income generated from the organization's primary business activities. Although revenue ultimately increases equity, it is tracked separately during the accounting period to enable performance analysis. Revenue accounts have credit normal balances - when you make a sale, you credit revenue to increase it. At period-end, revenue balances are closed to retained earnings.\n\n**Expense accounts** track costs incurred to generate revenue and operate the business. Like revenue, expenses ultimately affect equity (decreasing it) but are tracked separately for analysis. Expense accounts have debit normal balances - when you incur an expense, you debit the expense account to increase it. At period-end, expense balances are closed to retained earnings.\n\n> **Decision: Account Type Enum vs String Storage**\n> - **Context**: Account types could be stored as enumerated constants or as flexible string values in the database\n> - **Options Considered**: \n>   - Enum constants with validation: Type-safe, prevents invalid values, enables compile-time checking\n>   - String storage with validation: Flexible, allows easy extension, simpler database queries\n>   - Mixed approach: Enum in code, string in database\n> - **Decision**: Use strongly-typed enums in code that serialize to/from standard string values\n> - **Rationale**: Account types are fundamental and stable - the five basic types have not changed in centuries. Type safety prevents bugs, while string serialization maintains database portability and human readability\n> - **Consequences**: Compile-time safety for account type operations, but requires explicit conversion methods and careful handling of invalid database values\n\nThe account type validation rules must be embedded deep into the transaction recording system. Every journal entry line must specify whether it is a debit or credit to a specific account, and the account manager must validate that this combination makes business sense. However, both debits and credits are valid for all account types - the difference lies in whether they increase or decrease the account balance.\n\n| Account Type | Debit Effect | Credit Effect | Validation Rules |\n|--------------|-------------|---------------|------------------|\n| ASSET | Increases balance | Decreases balance | Must not allow negative balances unless explicitly configured |\n| LIABILITY | Decreases balance | Increases balance | Negative balances may indicate overpayments or accounting errors |\n| EQUITY | Decreases balance | Increases balance | Should rarely have negative balances except in specific scenarios |\n| REVENUE | Decreases balance | Increases balance | Debits typically only for corrections or refunds |\n| EXPENSE | Increases balance | Decreases balance | Credits typically only for corrections or reimbursements |\n\n### Account Hierarchy Management\n\nAccount hierarchy management enables the organization of accounts into logical groups that reflect the business structure and reporting requirements. Think of the account hierarchy like a company's organizational chart - just as departments have managers and sub-departments, accounts can have parent accounts and sub-accounts that roll up into higher-level categories for reporting purposes.\n\nThe hierarchy serves multiple critical functions beyond just organization. Parent accounts can aggregate the balances of their children for summary reporting, account permissions can be inherited down the hierarchy, and business rules can be applied at different levels. A well-designed hierarchy makes financial reports more readable and enables drill-down analysis from high-level summaries to detailed transactions.\n\nThe most common approach uses a **tree structure** where each account can have zero or one parent account, but any account can have multiple child accounts. This creates a forest of account trees, typically with one tree per major account type. The root nodes are usually the five major account types (Assets, Liabilities, Equity, Revenue, Expenses), with increasingly specific categories branching downward.\n\n> **The Organizational Chart Mental Model**: Just as a VP of Sales might oversee Regional Sales Managers who oversee Individual Sales Reps, a \"Current Assets\" parent account might oversee \"Cash and Equivalents\" which oversees specific bank accounts like \"Checking - Wells Fargo Account 1234\" and \"Petty Cash - Office\". Each level provides a different granularity of information for different audiences.\n\n| Hierarchy Level | Example Account | Account Code | Purpose |\n|-----------------|----------------|--------------|---------|\n| Type Level | Assets | 1000-1999 | Top-level financial statement category |\n| Category Level | Current Assets | 1100-1199 | Major grouping within type |\n| Subcategory Level | Cash and Equivalents | 1110-1119 | Specific asset class |\n| Detail Level | Checking - Wells Fargo | 1111 | Individual account for transactions |\n| Sub-detail Level | Checking - WF Payroll | 1111.001 | Further subdivision if needed |\n\nThe account coding scheme works hand-in-hand with the hierarchy to provide a systematic way to organize and identify accounts. Most organizations use a numerical coding system where the first digit identifies the account type, and subsequent digits provide increasing levels of detail. This enables both human recognition (accountants can immediately identify \"2xxx\" as liability accounts) and systematic processing (reports can aggregate all accounts starting with \"11\" for current assets).\n\nAccount hierarchy management must handle several complex scenarios that arise in real-world accounting:\n\n**Hierarchy Restructuring**: Business reorganizations often require moving accounts between parents or splitting large categories into smaller ones. The system must preserve historical relationships while enabling changes, ensuring that historical reports remain accurate even after restructuring.\n\n**Balance Aggregation**: Parent account balances are typically calculated as the sum of their children's balances, but this requires careful handling of account types and normal balances. A parent asset account's balance equals the sum of its children's balances, but the calculation must respect whether each child has a debit or credit balance.\n\n**Circular Reference Prevention**: The system must prevent accounts from becoming their own ancestors through a chain of parent relationships. This requires validation during hierarchy changes and periodic integrity checks to catch corruption.\n\n**Permission Inheritance**: If a user has access to a parent account, they might automatically inherit access to its children, or permissions might be explicitly set at each level. The hierarchy structure must support whatever permission model the organization chooses.\n\nThe account hierarchy data model requires careful consideration of how to store and query tree structures efficiently. The parent reference approach (each account stores its parent's ID) is simple but makes certain queries expensive. Alternative approaches like nested sets or closure tables optimize different query patterns but add complexity.\n\n| Hierarchy Storage Approach | Pros | Cons | Best For |\n|----------------------------|------|------|----------|\n| Parent Reference (ParentID field) | Simple schema, easy updates | Expensive recursive queries | Small hierarchies, infrequent reporting |\n| Nested Sets (left/right values) | Fast subtree queries | Complex updates, hard to understand | Read-heavy, stable hierarchies |\n| Closure Table (separate ancestor table) | Fast queries, flexible | Additional storage, complex maintenance | Large hierarchies, frequent queries |\n| Path Enumeration (store full path) | Simple queries, good performance | Path length limits, difficult moves | Medium hierarchies, stable structure |\n\n> **Decision: Parent Reference with Recursive CTE Queries**\n> - **Context**: Need to balance query performance, update complexity, and maintainability for account hierarchies\n> - **Options Considered**: Parent reference, nested sets, closure table, path enumeration\n> - **Decision**: Use parent reference with Common Table Expression (CTE) recursive queries for hierarchy traversal\n> - **Rationale**: Account hierarchies are relatively stable and not extremely deep. Most queries need specific accounts rather than full subtrees. CTE support in modern databases makes recursive queries performant enough, while parent reference keeps updates simple\n> - **Consequences**: Straightforward schema and hierarchy maintenance, but may require query optimization for very large account trees\n\n### Account Validation Rules\n\nAccount validation rules ensure data integrity and business rule compliance throughout the account lifecycle. Think of these rules as the immune system of the accounting system - they prevent malformed or logically inconsistent data from entering the system, much like white blood cells identify and neutralize threats before they can cause damage.\n\nValidation occurs at multiple levels and stages: field-level validation ensures data types and formats are correct, business rule validation ensures accounting principles are respected, and system validation ensures referential integrity and consistency. Each level serves a different purpose and catches different types of errors.\n\n**Field-Level Validation** ensures that individual account attributes meet basic format and type requirements. This includes data type checking (strings are strings, dates are valid dates), length restrictions (account codes within specified character limits), and format validation (account codes follow the organization's numbering scheme).\n\n| Field | Validation Rules | Error Examples | Business Impact |\n|-------|-----------------|----------------|-----------------|\n| Account Code | Unique, follows numbering scheme, appropriate length | Duplicate code \"1100\", invalid format \"ABC-XYZ\" | Prevents transaction posting errors, maintains reporting consistency |\n| Account Name | Non-empty, reasonable length, unique within parent | Empty string, excessively long names | Ensures accounts are identifiable in reports and interfaces |\n| Account Type | Must be valid enum value | Invalid type \"FURNITURE\" | Prevents calculation errors, ensures proper financial statement classification |\n| Currency | Valid ISO 4217 currency code | Invalid code \"DOLLAR\", mixing currencies inappropriately | Prevents multi-currency calculation errors, ensures accurate exchange rate handling |\n| Parent Account | Must exist, must not create circular reference | Non-existent parent, self-reference | Maintains hierarchy integrity, prevents infinite loops in queries |\n\n**Business Rule Validation** ensures that account configurations comply with accounting principles and organizational policies. These rules are more sophisticated than field validation because they require understanding the business context and relationships between different data elements.\n\nThe system must validate that account type changes do not violate existing transaction history. If an account has been used in journal entries as an asset account, changing it to a liability account would invalidate historical balance calculations and financial statements. Therefore, account type changes should be either prohibited for accounts with transaction history or handled through a formal account migration process.\n\nAccount activation and deactivation must follow business rules that prevent disruption to ongoing operations. Active accounts with non-zero balances cannot be simply deleted - they must either be closed through appropriate journal entries or have their balances transferred to other accounts. Inactive accounts should not appear in transaction entry interfaces but must remain accessible for historical reporting.\n\nParent-child relationships must respect account type compatibility. While there's flexibility in how organizations structure their hierarchies, certain combinations make no business sense and could confuse users or distort reports. For example, having an expense account as a child of an asset account would violate the logical separation of balance sheet and income statement items.\n\n| Validation Rule | Business Rationale | Implementation Approach |\n|----------------|-------------------|------------------------|\n| Account type immutability for accounts with transactions | Preserves historical accuracy, prevents balance calculation errors | Check for existing journal entries before allowing type changes |\n| Non-zero balance accounts cannot be deactivated | Prevents \"disappearing\" amounts, ensures trial balance integrity | Validate current balance is zero before allowing deactivation |\n| Parent account type compatibility | Maintains logical hierarchy, prevents reporting confusion | Validate parent and child types follow organizational rules |\n| Unique account codes within scope | Prevents ambiguity, ensures reliable account identification | Database unique constraints with appropriate scope (global or per-parent) |\n| Currency consistency within hierarchy branches | Simplifies balance aggregation, prevents mixing currency calculations | Validate child accounts use same currency as parent, or explicitly allow multi-currency branches |\n\n**System Integrity Validation** ensures that the account data remains consistent with the broader ledger system. This includes validating that accounts referenced by journal entries exist and are active, ensuring that account hierarchies remain well-formed trees without cycles, and verifying that cached balances and derived data remain synchronized with account definitions.\n\nThe validation system must handle both immediate validation (performed during API calls) and batch validation (performed during maintenance windows to catch corruption or drift). Immediate validation prevents bad data from entering the system, while batch validation identifies problems that might have slipped through or developed over time due to bugs or data corruption.\n\n> ⚠️ **Pitfall: Inadequate Account Code Validation**\n> Allowing flexible account codes without proper validation leads to chaos in the chart of accounts. Organizations often start with informal coding schemes (\"CASH\", \"CHECKING\", \"SAVINGS\") that work initially but break down as the business grows. Without systematic codes, accounts cannot be grouped logically for reports, sorting becomes unreliable, and users cannot predict where to find specific accounts. The fix is implementing a formal coding scheme from the beginning, even if it seems overly structured for a small organization.\n\n> ⚠️ **Pitfall: Permissive Account Type Changes**\n> Allowing account type changes after transactions are recorded can destroy the integrity of historical financial statements. If an account that was treated as an asset in January gets changed to a liability in March, the January balance sheet becomes incorrect. The trial balance may still balance numerically, but the financial statement classifications are wrong. The fix is either prohibiting type changes entirely for accounts with transaction history, or implementing a formal migration process that creates new accounts and transfers balances through proper journal entries.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Ignoring Account Normal Balance Rules**\nMany implementations store account balances as simple positive/negative numbers without properly accounting for normal balance conventions. This leads to confusion when an asset account shows a negative balance (which might be correct if it represents overdrafts or adjustments) versus a liability account with a negative balance (which might indicate an error or overpayment). The fix is implementing proper normal balance calculations where account balances are always interpreted in the context of their account type.\n\n⚠️ **Pitfall: Inadequate Hierarchy Validation**\nFailing to prevent circular references in account hierarchies creates infinite loops that crash reporting queries. A subtle version of this problem occurs when batch updates to parent relationships temporarily create cycles that are resolved later in the same transaction. The fix is implementing comprehensive cycle detection that runs both during individual updates and as part of periodic integrity checks.\n\n⚠️ **Pitfall: Mixing Currencies in Account Hierarchies**\nAllowing parent accounts to aggregate child accounts with different currencies without proper conversion handling leads to meaningless totals. For example, a \"Cash and Equivalents\" parent account containing both USD and EUR accounts cannot simply sum the amounts. The fix is either restricting hierarchies to single currencies or implementing proper currency conversion at aggregation time with clear policies about which exchange rates to use.\n\n⚠️ **Pitfall: Over-Permissive Account Deactivation**\nAllowing accounts to be deleted or deactivated without checking for dependencies breaks referential integrity and can make historical transactions unreadable. Even worse, some systems allow deactivation of accounts with non-zero balances, which makes the trial balance appear unbalanced. The fix is implementing comprehensive dependency checks that prevent deactivation of accounts that are referenced by unposted transactions, have non-zero balances, or serve as parents to active child accounts.\n\n### Implementation Guidance\n\nThe Account Management Component should be implemented as a self-contained service that provides a clean API for account operations while encapsulating all validation logic and data persistence concerns. This component will be heavily used by the Transaction Recording Engine and Financial Reporting Module, so performance and reliability are critical.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Data Storage | PostgreSQL with standard tables | PostgreSQL with recursive CTEs and materialized views |\n| Validation | In-memory validation with database constraints | Rule engine with configurable business rules |\n| Hierarchy Queries | Recursive application code | Database stored procedures with CTEs |\n| Caching | In-memory map for frequently accessed accounts | Redis cache with invalidation strategies |\n| API Layer | HTTP REST with JSON | gRPC with protocol buffers for type safety |\n\n#### Recommended File Structure\n\n```\ninternal/account/\n  manager.go              ← main AccountManager interface and implementation\n  manager_test.go         ← comprehensive tests for account operations\n  types.go                ← Account, AccountType, and related types\n  validation.go           ← validation rules and business logic\n  validation_test.go      ← tests for validation scenarios\n  hierarchy.go            ← hierarchy management and queries\n  hierarchy_test.go       ← tests for hierarchy operations\n  repository.go           ← database operations interface\n  postgres_repository.go  ← PostgreSQL implementation of repository\n  errors.go               ← domain-specific error types\nmigrations/\n  001_create_accounts.sql ← database schema creation\n  002_add_indexes.sql     ← performance indexes\ncmd/account-cli/\n  main.go                 ← command-line tool for account management\n```\n\n#### Infrastructure Starter Code\n\n**Account Types and Core Data Structures:**\n\n```go\npackage account\n\nimport (\n    \"time\"\n    \"github.com/shopspring/decimal\"\n)\n\n// AccountType represents the five fundamental account categories\ntype AccountType string\n\nconst (\n    AccountTypeAsset     AccountType = \"ASSET\"\n    AccountTypeLiability AccountType = \"LIABILITY\" \n    AccountTypeEquity    AccountType = \"EQUITY\"\n    AccountTypeRevenue   AccountType = \"REVENUE\"\n    AccountTypeExpense   AccountType = \"EXPENSE\"\n)\n\n// NormalBalance returns the normal balance side for this account type\nfunc (at AccountType) NormalBalance() string {\n    switch at {\n    case AccountTypeAsset, AccountTypeExpense:\n        return \"DEBIT\"\n    case AccountTypeLiability, AccountTypeEquity, AccountTypeRevenue:\n        return \"CREDIT\"\n    default:\n        return \"\"\n    }\n}\n\n// IsDebitNormal returns true if this account type increases with debits\nfunc (at AccountType) IsDebitNormal() bool {\n    return at.NormalBalance() == \"DEBIT\"\n}\n\n// Account represents a single account in the chart of accounts\ntype Account struct {\n    ID         string      `json:\"id\" db:\"id\"`\n    Code       string      `json:\"code\" db:\"code\"`\n    Name       string      `json:\"name\" db:\"name\"`\n    Type       AccountType `json:\"type\" db:\"type\"`\n    Currency   string      `json:\"currency\" db:\"currency\"`\n    ParentID   *string     `json:\"parent_id\" db:\"parent_id\"`\n    IsActive   bool        `json:\"is_active\" db:\"is_active\"`\n    CreatedAt  time.Time   `json:\"created_at\" db:\"created_at\"`\n    ModifiedAt time.Time   `json:\"modified_at\" db:\"modified_at\"`\n}\n\n// Money represents a monetary amount with currency\ntype Money struct {\n    Amount   decimal.Decimal `json:\"amount\"`\n    Currency string          `json:\"currency\"`\n}\n\n// Add adds two Money values of the same currency\nfunc (m Money) Add(other Money) (Money, error) {\n    if m.Currency != other.Currency {\n        return Money{}, fmt.Errorf(\"cannot add different currencies: %s + %s\", m.Currency, other.Currency)\n    }\n    return Money{\n        Amount:   m.Amount.Add(other.Amount),\n        Currency: m.Currency,\n    }, nil\n}\n\n// Subtract subtracts two Money values of the same currency  \nfunc (m Money) Subtract(other Money) (Money, error) {\n    if m.Currency != other.Currency {\n        return Money{}, fmt.Errorf(\"cannot subtract different currencies: %s - %s\", m.Currency, other.Currency)\n    }\n    return Money{\n        Amount:   m.Amount.Sub(other.Amount),\n        Currency: m.Currency,\n    }, nil\n}\n```\n\n**Database Schema (PostgreSQL):**\n\n```sql\n-- migrations/001_create_accounts.sql\nCREATE TABLE accounts (\n    id VARCHAR(36) PRIMARY KEY,\n    code VARCHAR(50) UNIQUE NOT NULL,\n    name VARCHAR(255) NOT NULL,\n    type VARCHAR(20) NOT NULL CHECK (type IN ('ASSET', 'LIABILITY', 'EQUITY', 'REVENUE', 'EXPENSE')),\n    currency CHAR(3) NOT NULL,\n    parent_id VARCHAR(36) REFERENCES accounts(id),\n    is_active BOOLEAN DEFAULT TRUE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    modified_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    \n    -- Prevent circular references at database level\n    CONSTRAINT no_self_reference CHECK (id != parent_id)\n);\n\n-- Index for hierarchy queries\nCREATE INDEX idx_accounts_parent_id ON accounts(parent_id);\nCREATE INDEX idx_accounts_type ON accounts(type);\nCREATE INDEX idx_accounts_code ON accounts(code);\nCREATE INDEX idx_accounts_active ON accounts(is_active) WHERE is_active = TRUE;\n\n-- Trigger to update modified_at\nCREATE OR REPLACE FUNCTION update_modified_at()\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.modified_at = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER accounts_update_modified_at\n    BEFORE UPDATE ON accounts\n    FOR EACH ROW\n    EXECUTE FUNCTION update_modified_at();\n```\n\n#### Core Logic Skeleton Code\n\n**Account Manager Interface:**\n\n```go\n// Manager provides operations for managing accounts and chart of accounts\ntype Manager interface {\n    // CreateAccount creates a new account with validation\n    CreateAccount(ctx context.Context, account Account) (*Account, error)\n    \n    // UpdateAccount updates an existing account with business rule validation\n    UpdateAccount(ctx context.Context, id string, updates AccountUpdates) (*Account, error)\n    \n    // GetAccount retrieves an account by ID\n    GetAccount(ctx context.Context, id string) (*Account, error)\n    \n    // GetAccountByCode retrieves an account by its code\n    GetAccountByCode(ctx context.Context, code string) (*Account, error)\n    \n    // ListAccounts returns accounts matching the given criteria\n    ListAccounts(ctx context.Context, filter AccountFilter) ([]Account, error)\n    \n    // GetAccountHierarchy returns the full hierarchy starting from the given account\n    GetAccountHierarchy(ctx context.Context, rootID string) (*AccountHierarchy, error)\n    \n    // DeactivateAccount deactivates an account after validation\n    DeactivateAccount(ctx context.Context, id string) error\n    \n    // ValidateAccount performs comprehensive business rule validation\n    ValidateAccount(ctx context.Context, account Account) error\n}\n\n// CreateAccount creates a new account in the chart of accounts\nfunc (m *AccountManagerImpl) CreateAccount(ctx context.Context, account Account) (*Account, error) {\n    // TODO 1: Generate unique ID if not provided\n    // TODO 2: Validate account code format and uniqueness\n    // TODO 3: Validate account name is not empty and reasonable length\n    // TODO 4: Validate account type is one of the five valid types\n    // TODO 5: Validate currency code is valid ISO 4217\n    // TODO 6: If parent_id provided, validate parent exists and is active\n    // TODO 7: Validate parent-child type compatibility\n    // TODO 8: Check for circular reference if parent_id provided\n    // TODO 9: Set timestamps and active status\n    // TODO 10: Insert into database within transaction\n    // Hint: Use database transaction to ensure atomicity\n    // Hint: Generate UUID for ID if empty\n    // Hint: Validate currency against ISO 4217 list\n}\n\n// ValidateAccountHierarchy checks for circular references in account hierarchy\nfunc (m *AccountManagerImpl) ValidateAccountHierarchy(ctx context.Context, accountID string, parentID *string) error {\n    // TODO 1: If parentID is nil, no validation needed (root account)\n    // TODO 2: If parentID equals accountID, return circular reference error\n    // TODO 3: Start from parentID and walk up the hierarchy\n    // TODO 4: For each ancestor, check if it equals accountID\n    // TODO 5: If we find accountID in ancestors, return circular reference error\n    // TODO 6: If we reach a root account (no parent), hierarchy is valid\n    // TODO 7: Handle case where hierarchy walk encounters non-existent account\n    // Hint: Use recursive query or iterative approach with visited set\n    // Hint: Limit maximum hierarchy depth to prevent infinite loops\n}\n```\n\n**Account Validation Logic:**\n\n```go\n// ValidateAccountCode ensures account codes follow organizational standards\nfunc (v *AccountValidator) ValidateAccountCode(code string, accountType AccountType) error {\n    // TODO 1: Check code is not empty\n    // TODO 2: Validate code length is within acceptable range (e.g., 3-20 characters)\n    // TODO 3: Check code format matches organizational numbering scheme\n    // TODO 4: Validate first digit corresponds to account type (1=Asset, 2=Liability, etc.)\n    // TODO 5: Check for invalid characters (only alphanumeric and specific punctuation)\n    // TODO 6: Validate code doesn't conflict with reserved ranges\n    // Hint: Use regex pattern matching for format validation\n    // Hint: Consider organizational coding standards (numeric vs alphanumeric)\n}\n\n// ValidateParentChildCompatibility ensures parent-child relationships make business sense\nfunc (v *AccountValidator) ValidateParentChildCompatibility(parentType, childType AccountType) error {\n    // TODO 1: Define compatibility matrix for account type combinations\n    // TODO 2: Check if parent type can logically contain child type\n    // TODO 3: Validate both types are not mixing balance sheet and income statement\n    // TODO 4: Allow same-type relationships (Asset parent, Asset child)\n    // TODO 5: Consider organizational-specific rules (some orgs allow mixed hierarchies)\n    // Hint: Balance sheet accounts (Asset, Liability, Equity) should not mix with income statement (Revenue, Expense)\n    // Hint: Create lookup table or switch statement for allowed combinations\n}\n```\n\n#### Milestone Checkpoint\n\nAfter implementing the Account Management Component, you should be able to:\n\n**Test Commands:**\n```bash\n# Run unit tests\ngo test ./internal/account/... -v\n\n# Test account creation via CLI\n./bin/account-cli create --code \"1100\" --name \"Cash\" --type \"ASSET\" --currency \"USD\"\n\n# Test hierarchy validation\n./bin/account-cli create --code \"1110\" --name \"Checking Account\" --type \"ASSET\" --parent \"1100\"\n\n# Test validation errors\n./bin/account-cli create --code \"1100\" --name \"Duplicate\" --type \"ASSET\"  # Should fail\n```\n\n**Expected Behavior:**\n- Account creation succeeds for valid accounts and fails with clear error messages for invalid accounts\n- Hierarchy queries return proper parent-child relationships\n- Account type validation prevents incompatible relationships\n- Database constraints prevent duplicate codes and circular references\n- All validation rules are enforced at both application and database levels\n\n**Debugging Signs:**\n- If accounts can be created with duplicate codes, check database unique constraints\n- If circular references are allowed, verify hierarchy validation logic\n- If validation errors are unclear, improve error message specificity\n- If queries are slow, check database indexes on parent_id and type columns\n\n\n## Transaction Recording Engine\n\n> **Milestone(s):** 2 (Transaction Recording), 3 (Balance Calculation), 4 (Audit Trail), as this section implements the atomic journal entry creation, double-entry validation, and posting workflow that forms the core of the ledger system.\n\nThe transaction recording engine is the beating heart of our double-entry ledger system. Think of it as a meticulous bank teller who never makes a mistake - every transaction must be perfectly balanced before it gets recorded, and once recorded, it becomes an immutable part of the financial history. The engine enforces the fundamental rule of double-entry bookkeeping: every transaction must have equal debits and credits, and it does this through a rigorous validation and posting workflow that ensures data integrity at every step.\n\n![Journal Entry Recording Sequence](./diagrams/journal-entry-workflow.svg)\n\nThe recording engine operates like a multi-stage security checkpoint at an airport. First, it validates that all the paperwork (journal entry) is complete and follows the rules. Then it processes the transaction atomically - either everything goes through perfectly, or nothing happens at all. Finally, it creates an immutable record that cannot be changed, only corrected through additional offsetting entries.\n\n![Journal Entry State Transitions](./diagrams/entry-state-machine.svg)\n\nThis atomic, validated approach prevents the nightmare scenarios that plague poorly designed accounting systems: partially recorded transactions, unbalanced books, lost audit trails, and data corruption. By building these safeguards into the core recording engine, we ensure that the ledger maintains perfect integrity even under high load or system failures.\n\n### Journal Entry Validation\n\nJournal entry validation is like having a rigorous accountant review every transaction before it gets entered into the books. The validation engine examines each journal entry to ensure it follows the immutable laws of double-entry bookkeeping: debits must equal credits, accounts must exist and be active, and the entry must make logical sense from an accounting perspective.\n\nThe validation process operates in multiple stages, each catching different types of errors. Think of it as a quality control assembly line where each station checks for specific defects. The early stages catch obvious problems like missing data or formatting errors, while later stages perform complex business rule validation that requires database lookups and cross-referencing.\n\n> **Decision: Multi-Stage Validation Pipeline**\n> - **Context**: Journal entries need validation for data integrity, business rules, and accounting principles\n> - **Options Considered**: \n>   1. Single validation function that checks everything at once\n>   2. Multi-stage pipeline with early failure detection\n>   3. Asynchronous validation with eventual consistency\n> - **Decision**: Multi-stage validation pipeline with fail-fast semantics\n> - **Rationale**: Early stages can reject invalid entries without expensive database operations; clear separation of concerns makes validation logic maintainable; immediate feedback provides better user experience\n> - **Consequences**: Slightly more complex validation logic but much better performance and maintainability; clear error reporting tells users exactly what's wrong\n\n| Validation Stage | Purpose | Checks Performed | Database Access Required |\n|------------------|---------|------------------|-------------------------|\n| Structure Validation | Data completeness | Non-empty fields, valid currencies, positive amounts | No |\n| Format Validation | Data format correctness | Date ranges, decimal precision, string lengths | No |\n| Account Validation | Account existence and status | Account IDs exist, accounts are active | Yes |\n| Business Rule Validation | Accounting logic | Account type compatibility, currency matching | Yes |\n| Balance Validation | Double-entry compliance | Total debits equal total credits | No |\n| Authorization Validation | User permissions | User can post to specified accounts | Yes |\n\nThe validation engine maintains a comprehensive set of rules that evolve as the business requirements change. Each rule is implemented as a small, focused validator that can be tested independently. This modular approach makes it easy to add new validation rules or modify existing ones without touching the core validation pipeline.\n\n**Structure Validation** forms the first line of defense, checking that all required fields are present and non-empty. This stage validates that the `JournalEntry` has a valid date, description, and at least two `EntryLine` records. It also ensures that each entry line has either a debit or credit amount (but not both), and that all amounts are positive decimal values. This validation requires no database access and can reject malformed entries immediately.\n\n**Account Validation** verifies that every account referenced in the entry lines actually exists in the chart of accounts and is currently active. This stage also checks that the accounts belong to the correct company or organization context. If any referenced account is inactive or doesn't exist, the entire journal entry is rejected with a clear error message identifying the problematic account.\n\n**Balance Validation** enforces the fundamental rule of double-entry bookkeeping by calculating the total debits and credits for the journal entry. The validation logic handles multi-currency entries by grouping amounts by currency and ensuring that debits equal credits within each currency. This prevents the common mistake of posting unbalanced entries that would corrupt the trial balance.\n\nThe validation process maintains detailed error collection, accumulating all validation failures rather than stopping at the first error. This provides users with comprehensive feedback about everything that needs to be fixed, rather than forcing them through multiple rounds of fix-and-resubmit. The error collection includes specific field names, invalid values, and suggested corrections where applicable.\n\n| Validation Error Type | Error Code | Example Message | Recovery Action |\n|----------------------|------------|-----------------|-----------------|\n| Missing Required Field | `ENTRY_001` | \"Description is required for all journal entries\" | Provide entry description |\n| Invalid Account Reference | `ENTRY_002` | \"Account '1001-CASH' does not exist or is inactive\" | Use valid, active account ID |\n| Currency Mismatch | `ENTRY_003` | \"All entry lines must use the same currency\" | Convert to single currency |\n| Unbalanced Entry | `ENTRY_004` | \"Debits ($1,500.00) do not equal credits ($1,450.00)\" | Adjust amounts to balance |\n| Account Type Violation | `ENTRY_005` | \"Cannot post credit to asset account without business justification\" | Review account types |\n| Authorization Failure | `ENTRY_006` | \"User lacks permission to post to restricted account '5001-SALARY'\" | Request authorization |\n\n**Account Type Compatibility** validation ensures that debits and credits are posted to appropriate account types according to normal balance rules. While the system allows unusual postings (like crediting an asset account for a return), it flags these for additional review. The validation logic understands that asset and expense accounts are debit-normal, while liability, equity, and revenue accounts are credit-normal.\n\nThe validation engine also performs **Cross-Entry Consistency** checks that look for suspicious patterns across multiple entry lines. For example, it flags entries that post to both cash and accounts receivable for the same customer, which might indicate a duplicate payment recording. These soft validations generate warnings rather than errors, alerting users to potential issues while allowing the entry to proceed if confirmed.\n\n### Atomic Transaction Posting\n\nAtomic transaction posting ensures that journal entries are recorded as indivisible units - either all changes succeed together, or none of them happen at all. Think of it like a bank wire transfer: the money must leave one account and arrive in the other account simultaneously. There's no intermediate state where the money has left but not yet arrived, because that would create an impossible situation where money vanishes from the system.\n\nThe posting engine wraps all journal entry operations within a database transaction boundary, leveraging the ACID properties of the underlying database to maintain consistency. When a journal entry is posted, the system must update multiple tables: the journal entry itself changes from `DRAFT` to `POSTED` status, entry lines are written to the ledger, account balances are updated, and audit records are created. All of these changes must succeed atomically.\n\n> **Decision: Database Transaction Boundaries**\n> - **Context**: Journal entries involve multiple database table updates that must remain consistent\n> - **Options Considered**:\n>   1. Update tables sequentially without transactions (unsafe)\n>   2. Use database transactions for atomicity (safe but might impact performance)  \n>   3. Use application-level compensation logic to handle partial failures\n> - **Decision**: Use database transactions with proper isolation levels\n> - **Rationale**: Database transactions provide proven ACID guarantees; performance impact is manageable for accounting workloads; much simpler than building compensation logic\n> - **Consequences**: Simplified error handling and guaranteed consistency at the cost of holding database locks during posting operations\n\nThe posting workflow follows a carefully orchestrated sequence that minimizes the time spent holding database locks while ensuring complete atomicity. The process begins by validating the journal entry one final time within the transaction context, ensuring that no concurrent changes have invalidated the entry since the initial validation.\n\n**Posting Workflow Steps:**\n\n1. **Begin Database Transaction** - Start an explicit database transaction with `READ_COMMITTED` isolation level to prevent dirty reads while allowing maximum concurrency for other operations.\n\n2. **Lock Journal Entry** - Acquire a row-level lock on the journal entry record using `SELECT FOR UPDATE` to prevent concurrent modifications during posting.\n\n3. **Re-validate Entry Status** - Verify that the entry is still in `DRAFT` status and hasn't been posted or deleted by another process.\n\n4. **Validate Account States** - Re-check that all referenced accounts are still active and accessible within the transaction context.\n\n5. **Calculate Running Balances** - Compute the new account balances that will result from this journal entry, checking for any account limits or overdraft conditions.\n\n6. **Update Journal Entry Status** - Change the entry status from `DRAFT` to `POSTED` and record the posting timestamp and user information.\n\n7. **Insert Entry Lines** - Write all entry line records to the ledger with their final debit and credit amounts.\n\n8. **Update Account Balances** - Increment or decrement the running balance tables for all affected accounts.\n\n9. **Create Audit Records** - Generate audit trail entries documenting the posting operation and all changes made.\n\n10. **Commit Transaction** - If all updates succeed, commit the database transaction to make all changes permanent.\n\nThe posting engine maintains strict error handling throughout this workflow. If any step fails - whether due to database constraints, business rule violations, or system errors - the entire transaction is rolled back, leaving the database in exactly the same state as before the posting attempt. This rollback behavior prevents partial posts that could corrupt the ledger.\n\n| Posting Step | Failure Scenario | Error Detection | Recovery Action |\n|--------------|------------------|-----------------|-----------------|\n| Begin Transaction | Database connection lost | Exception thrown | Retry with new connection |\n| Lock Entry | Entry already locked | Lock timeout | Retry after delay |\n| Status Validation | Entry already posted | Status mismatch | Return \"already posted\" error |\n| Account Validation | Account deactivated | Business rule violation | Rollback and return validation error |\n| Balance Calculation | Integer overflow | Arithmetic exception | Rollback and return limit exceeded error |\n| Entry Line Insert | Constraint violation | Database error | Rollback and return data integrity error |\n| Balance Update | Optimistic lock failure | Concurrent modification | Rollback and retry entire operation |\n| Audit Record Creation | Storage full | Write failure | Rollback and return system error |\n| Commit | Network partition | Timeout exception | Transaction automatically rolled back |\n\n**Concurrency Control** during posting uses a combination of database locks and optimistic concurrency techniques. The system acquires minimal locks for the shortest possible time, holding row-level locks only on the specific journal entry being posted. Account balance updates use optimistic locking with version numbers to detect concurrent modifications without blocking other transactions.\n\nThe posting engine also implements **Retry Logic** for handling transient failures like lock timeouts or temporary network issues. The retry mechanism uses exponential backoff to avoid overwhelming the database during high-load periods. However, the system never retries operations that might have side effects - if a posting operation begins but the result is uncertain due to network issues, the system flags the entry for manual review rather than risking duplicate posts.\n\n**Transaction Isolation** is carefully configured to balance consistency with performance. The posting engine uses `READ_COMMITTED` isolation level for most operations, which prevents dirty reads while allowing maximum concurrency. For certain critical operations like balance calculations, the system temporarily escalates to `REPEATABLE_READ` to ensure consistent snapshots across multiple queries within the same transaction.\n\n### Idempotency and Duplicate Prevention\n\nIdempotency ensures that posting the same journal entry multiple times has the same effect as posting it once. Think of it like pressing an elevator button - whether you press it once or frantically mash it ten times, the elevator comes to your floor exactly once. This property is crucial for accounting systems because network failures, system crashes, and user impatience can all lead to duplicate submission attempts that must not result in duplicate financial records.\n\nThe idempotency system operates through a combination of unique constraints, idempotency keys, and state tracking that makes it mathematically impossible to create duplicate entries. Every journal entry receives a unique identifier when first created, and this identifier becomes the definitive source of truth for determining whether an entry has already been processed.\n\n> **Decision: Idempotency Key Strategy**\n> - **Context**: Journal entries may be submitted multiple times due to network retries, user impatience, or system failures\n> - **Options Considered**:\n>   1. Database unique constraints only (limited protection)\n>   2. Client-provided idempotency keys (flexible but requires client cooperation)\n>   3. Server-generated deterministic IDs based on entry content (automatic but complex)\n> - **Decision**: Combination of server-generated UUIDs with optional client idempotency keys\n> - **Rationale**: Server-generated UUIDs prevent accidental duplicates; client keys enable intentional retry logic; database constraints provide final safety net\n> - **Consequences**: Robust duplicate prevention with minimal client complexity; slightly more storage overhead for tracking idempotency state\n\nThe idempotency system maintains a three-tier defense against duplicate entries. The first tier uses **Unique Identifiers** generated by the server when a journal entry is first created. These UUIDs are cryptographically random and have negligible collision probability, ensuring that each entry receives a globally unique identifier that can never be accidentally reused.\n\n**Idempotency Key Processing:**\n\n| Idempotency Mechanism | Scope | Detection Method | Prevention Action |\n|----------------------|--------|------------------|-------------------|\n| UUID Primary Key | Single entry | Database unique constraint | Reject with existing entry ID |\n| Client Idempotency Key | API request | Lookup in idempotency table | Return cached result |\n| Content Hash | Entry data | SHA-256 of normalized entry | Flag as potential duplicate |\n| Temporal Window | Time-based | Recent entries within threshold | Require confirmation |\n| User Session | Single user | Track submissions per session | Rate limiting |\n| Reference Number | Business document | External reference uniqueness | Business rule validation |\n\nThe second tier uses **Client Idempotency Keys** that allow external systems to provide their own duplicate detection mechanisms. When a client submits a journal entry with an idempotency key, the system checks whether that key has been used before within a configurable time window (typically 24 hours). If the key exists, the system returns the result of the original operation rather than attempting to create a duplicate entry.\n\n**Content-Based Duplicate Detection** forms the third tier of protection, analyzing the actual journal entry data to identify potential duplicates even when identifiers differ. The system computes a SHA-256 hash of the normalized entry content (accounts, amounts, description, and reference number) and checks whether an identical entry has been posted recently. This catches scenarios where the same business transaction gets entered multiple times through different channels.\n\nThe idempotency system maintains detailed tracking of submission attempts and their outcomes. Each API request receives a unique request ID that gets logged with the journal entry, creating a complete audit trail of who submitted what when. This tracking enables investigation of duplicate submission patterns and helps identify problematic client integrations.\n\n**Idempotency State Management:**\n\n```\nEntry States for Idempotency:\n- SUBMITTED: Request received, idempotency check in progress\n- VALIDATED: Entry passed validation, ready for posting\n- POSTING: Atomic posting operation in progress  \n- POSTED: Entry successfully recorded in ledger\n- FAILED: Posting failed, entry remains in draft state\n- DUPLICATE: Rejected as duplicate of existing entry\n```\n\nWhen a duplicate submission is detected, the system's response depends on the current state of the original entry. If the original entry was successfully posted, the system returns a success response with the existing entry details. If the original entry failed to post, the system can either retry the posting operation or return the original failure details, depending on the type of failure.\n\n**Rate Limiting** works in conjunction with idempotency to prevent abuse and accidental denial-of-service attacks. The system tracks submission rates per user, per API client, and per IP address, applying increasingly strict limits when unusual patterns are detected. These limits prevent scenarios where a malfunctioning client overwhelms the system with duplicate requests.\n\nThe idempotency system also handles **Partial Failures** gracefully. If a posting operation begins but fails partway through (for example, due to a network interruption), the system marks the entry with a special `POSTING_INTERRUPTED` status. Subsequent attempts to post the same entry first check whether the original posting completed successfully, using database consistency checks to determine the actual state.\n\n**Time Window Management** ensures that idempotency data doesn't accumulate indefinitely. The system maintains idempotency keys and content hashes for a configurable period (typically 30 days) after which they are eligible for cleanup. This balances duplicate protection with storage efficiency, preventing the idempotency tables from growing without bound.\n\n### Entry Reversal Mechanism\n\nEntry reversal provides the mechanism for correcting mistakes in posted journal entries while preserving the complete audit trail. Think of it like writing a check to undo a previous check - you can't tear up the original check once it's been cashed, but you can write another check that perfectly cancels out its effect. This approach maintains the immutable nature of the audit trail while providing the practical ability to correct errors.\n\nThe reversal system creates a new journal entry that exactly offsets the original entry, effectively bringing the account balances back to their pre-transaction state. However, both the original entry and the reversal entry remain permanently in the ledger, providing a complete historical record of what happened and when it was corrected.\n\n> **Decision: Reversal vs Modification Approach**\n> - **Context**: Posted journal entries contain errors that need correction while maintaining audit trail integrity\n> - **Options Considered**:\n>   1. Allow direct modification of posted entries (breaks audit trail)\n>   2. Create offsetting reversal entries (preserves history but increases entry volume)\n>   3. Mark entries as \"corrected\" with pointers to replacement entries (complex tracking)\n> - **Decision**: Create offsetting reversal entries with clear linkage to original entries\n> - **Rationale**: Preserves complete audit trail; follows standard accounting practices; simple to implement and understand; provides clear before/after balance reconciliation\n> - **Consequences**: Higher volume of journal entries but complete audit transparency; slightly more complex balance calculations but better compliance\n\nThe reversal mechanism operates through a carefully controlled workflow that ensures the reversal is valid, properly authorized, and correctly linked to the original entry. The system prevents common mistakes like attempting to reverse an entry that has already been reversed or creating partial reversals that don't fully offset the original amounts.\n\n**Reversal Entry Creation Process:**\n\n1. **Locate Original Entry** - Verify that the specified journal entry exists and is in `POSTED` status. Entries in `DRAFT` status should be modified directly rather than reversed.\n\n2. **Validate Reversal Authorization** - Confirm that the requesting user has permission to reverse entries, particularly for entries posted by other users or in previous accounting periods.\n\n3. **Check Previous Reversals** - Ensure that the original entry hasn't already been reversed. The system maintains parent-child relationships between original entries and their reversals.\n\n4. **Generate Reversal Entry** - Create a new journal entry with all debit and credit amounts flipped from the original entry. Debits become credits and credits become debits, with identical amounts and account references.\n\n5. **Link Entries** - Establish bidirectional references between the original entry and reversal entry, enabling navigation in both directions and preventing duplicate reversals.\n\n6. **Post Reversal Entry** - Submit the reversal entry through the normal posting workflow, including full validation and atomic transaction processing.\n\n7. **Update Entry Status** - Mark the original entry with `REVERSED` status while preserving its original posting information and audit trail.\n\nThe reversal system maintains strict referential integrity between original entries and their reversals. Each reversal entry contains a `ReversalOfID` field that points to the original entry, while the original entry's `ReversedByID` field points to the reversal. This bidirectional linking enables efficient queries for finding related entries and prevents orphaned reversals.\n\n| Reversal Field | Purpose | Example Value | Constraints |\n|----------------|---------|---------------|-------------|\n| `ReversalOfID` | Links reversal to original entry | `\"entry-12345\"` | Must reference valid posted entry |\n| `ReversedByID` | Links original to its reversal | `\"entry-12389\"` | Must reference valid reversal entry |\n| `ReversalReason` | Explains why reversal was needed | `\"Incorrect customer allocation\"` | Required for audit purposes |\n| `ReversalDate` | When reversal was created | `2024-01-15` | Cannot be before original posting date |\n| `AuthorizedBy` | Who approved the reversal | `\"manager@company.com\"` | May require elevated permissions |\n\n**Partial Reversal Support** allows reversing only specific line items from a multi-line journal entry, which is essential for correcting entries where only some of the postings were incorrect. The system creates a reversal entry that offsets only the problematic line items, leaving the correct portions of the original entry intact. This approach maintains double-entry balance while providing surgical correction capabilities.\n\nThe reversal mechanism includes **Time Period Controls** that can restrict reversals based on accounting period rules. For example, once a month has been closed, reversals of entries from that month might require additional authorization or be prohibited entirely. These controls help maintain the integrity of financial reporting periods and comply with auditing requirements.\n\n**Reversal Validation Logic:**\n\n| Validation Check | Purpose | Failure Action |\n|------------------|---------|----------------|\n| Entry Exists | Verify target entry is valid | Return \"Entry not found\" error |\n| Entry Status | Confirm entry is posted | Return \"Cannot reverse draft entry\" error |\n| Already Reversed | Prevent duplicate reversals | Return \"Entry already reversed\" error |\n| Period Status | Check if accounting period allows reversals | Return \"Period closed\" error |\n| User Authorization | Verify reversal permissions | Return \"Insufficient privileges\" error |\n| Amount Limits | Check if reversal exceeds user limits | Require additional approval |\n| Account Status | Ensure target accounts are still active | Return \"Account inactive\" error |\n\n**Audit Trail Enhancement** for reversals provides extra documentation beyond the standard journal entry audit trail. The system records the business reason for the reversal, the authorization chain, and any supporting documentation references. This enhanced audit trail helps explain to future auditors not just what was changed, but why it was changed and who authorized the change.\n\nThe reversal system also supports **Batch Reversals** for scenarios where multiple related entries need to be reversed simultaneously. This is particularly useful when correcting systematic errors that affected multiple transactions. The batch reversal operation ensures that all reversals succeed or fail together, preventing partial corrections that could leave the books in an inconsistent state.\n\n**Error Recovery** within the reversal mechanism handles edge cases like system failures during the reversal process. If a reversal operation fails partway through, the system can detect incomplete reversals and either complete them or clean up partial state. This recovery logic prevents situations where the original entry is marked as reversed but the offsetting entry was never created.\n\n### Implementation Guidance\n\nThe transaction recording engine requires careful integration of validation logic, database transaction management, and state tracking. This implementation provides complete working components for the infrastructure pieces while leaving the core business logic as guided exercises for learners.\n\n#### A. Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Database | PostgreSQL with `database/sql` | PostgreSQL with `pgx` driver for advanced features |\n| Validation | Custom validation with `go-playground/validator` | Rule engine with `casbin` for complex authorization |\n| UUID Generation | `google/uuid` package | `crypto/rand` with custom format for sequential ordering |\n| Decimal Math | `decimal` package from `shopspring` | Custom fixed-point arithmetic for maximum precision |\n| Logging | Standard `log/slog` package | Structured logging with `zerolog` or `logrus` |\n| Monitoring | Basic metrics with `expvar` | Full observability with `prometheus` and `jaeger` |\n\n#### B. Recommended File/Module Structure\n\n```\ninternal/engine/\n  transaction.go           ← Core TransactionEngine interface\n  transaction_test.go      ← Engine integration tests\n  validator/\n    validator.go           ← Multi-stage validation pipeline\n    rules.go               ← Business rule implementations\n    validator_test.go      ← Validation unit tests\n  posting/\n    poster.go              ← Atomic posting engine\n    idempotency.go         ← Duplicate prevention logic\n    poster_test.go         ← Posting workflow tests\n  reversal/\n    reversal.go            ← Entry reversal mechanism\n    reversal_test.go       ← Reversal logic tests\n  storage/\n    queries.go             ← Database query implementations\n    migrations/            ← Database schema migrations\n      001_journal_entries.sql\n      002_idempotency_keys.sql\n```\n\n#### C. Infrastructure Starter Code\n\n**Database Connection Wrapper** (Complete implementation):\n\n```go\npackage storage\n\nimport (\n    \"context\"\n    \"database/sql\"\n    \"fmt\"\n    \"time\"\n    _ \"github.com/lib/pq\"\n)\n\n// DBManager handles database connections and transaction management\ntype DBManager struct {\n    db *sql.DB\n}\n\n// NewDBManager creates a new database manager with connection pooling\nfunc NewDBManager(config DatabaseConfig) (*DBManager, error) {\n    connStr := fmt.Sprintf(\"host=%s port=%d user=%s password=%s dbname=%s sslmode=%s\",\n        config.Host, config.Port, config.User, config.Password, config.DBName, config.SSLMode)\n    \n    db, err := sql.Open(\"postgres\", connStr)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to open database: %w\", err)\n    }\n    \n    // Configure connection pool for accounting workloads\n    db.SetMaxOpenConns(25)\n    db.SetMaxIdleConns(5)\n    db.SetConnMaxLifetime(5 * time.Minute)\n    \n    if err := db.Ping(); err != nil {\n        return nil, fmt.Errorf(\"failed to ping database: %w\", err)\n    }\n    \n    return &DBManager{db: db}, nil\n}\n\n// WithTransaction executes a function within a database transaction\nfunc (dm *DBManager) WithTransaction(ctx context.Context, fn func(*sql.Tx) error) error {\n    tx, err := dm.db.BeginTx(ctx, &sql.TxOptions{\n        Isolation: sql.LevelReadCommitted,\n        ReadOnly:  false,\n    })\n    if err != nil {\n        return fmt.Errorf(\"failed to begin transaction: %w\", err)\n    }\n    \n    defer func() {\n        if p := recover(); p != nil {\n            tx.Rollback()\n            panic(p) // Re-panic after rollback\n        }\n    }()\n    \n    if err := fn(tx); err != nil {\n        if rbErr := tx.Rollback(); rbErr != nil {\n            return fmt.Errorf(\"transaction error: %v, rollback error: %v\", err, rbErr)\n        }\n        return err\n    }\n    \n    if err := tx.Commit(); err != nil {\n        return fmt.Errorf(\"failed to commit transaction: %w\", err)\n    }\n    \n    return nil\n}\n\n// Close closes the database connection pool\nfunc (dm *DBManager) Close() error {\n    return dm.db.Close()\n}\n```\n\n**Idempotency Key Manager** (Complete implementation):\n\n```go\npackage posting\n\nimport (\n    \"crypto/sha256\"\n    \"database/sql\"\n    \"fmt\"\n    \"time\"\n    \"context\"\n    \"encoding/hex\"\n    \"encoding/json\"\n)\n\n// IdempotencyManager prevents duplicate journal entry submissions\ntype IdempotencyManager struct {\n    db *sql.DB\n}\n\n// IdempotencyRecord tracks submission attempts\ntype IdempotencyRecord struct {\n    Key        string    `json:\"key\"`\n    EntryID    string    `json:\"entry_id\"`\n    Status     string    `json:\"status\"`\n    Result     string    `json:\"result,omitempty\"`\n    CreatedAt  time.Time `json:\"created_at\"`\n    ExpiresAt  time.Time `json:\"expires_at\"`\n}\n\n// NewIdempotencyManager creates a new idempotency manager\nfunc NewIdempotencyManager(db *sql.DB) *IdempotencyManager {\n    return &IdempotencyManager{db: db}\n}\n\n// CheckIdempotency verifies if a request has been processed before\nfunc (im *IdempotencyManager) CheckIdempotency(ctx context.Context, key string) (*IdempotencyRecord, error) {\n    var record IdempotencyRecord\n    \n    query := `SELECT key, entry_id, status, result, created_at, expires_at \n              FROM idempotency_keys \n              WHERE key = $1 AND expires_at > NOW()`\n    \n    row := im.db.QueryRowContext(ctx, query, key)\n    err := row.Scan(&record.Key, &record.EntryID, &record.Status, \n                    &record.Result, &record.CreatedAt, &record.ExpiresAt)\n    \n    if err == sql.ErrNoRows {\n        return nil, nil // No existing record found\n    }\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to check idempotency: %w\", err)\n    }\n    \n    return &record, nil\n}\n\n// RecordRequest stores a new idempotency record\nfunc (im *IdempotencyManager) RecordRequest(ctx context.Context, key, entryID string, ttlHours int) error {\n    query := `INSERT INTO idempotency_keys (key, entry_id, status, created_at, expires_at)\n              VALUES ($1, $2, 'SUBMITTED', NOW(), NOW() + INTERVAL '%d hours')\n              ON CONFLICT (key) DO NOTHING`\n    \n    _, err := im.db.ExecContext(ctx, fmt.Sprintf(query, ttlHours), key, entryID)\n    if err != nil {\n        return fmt.Errorf(\"failed to record idempotency key: %w\", err)\n    }\n    \n    return nil\n}\n\n// UpdateStatus updates the status of an idempotency record\nfunc (im *IdempotencyManager) UpdateStatus(ctx context.Context, key, status, result string) error {\n    query := `UPDATE idempotency_keys \n              SET status = $2, result = $3, updated_at = NOW()\n              WHERE key = $1`\n    \n    _, err := im.db.ExecContext(ctx, query, key, status, result)\n    if err != nil {\n        return fmt.Errorf(\"failed to update idempotency status: %w\", err)\n    }\n    \n    return nil\n}\n\n// GenerateContentHash creates a deterministic hash from journal entry content\nfunc (im *IdempotencyManager) GenerateContentHash(entry *JournalEntry) string {\n    // Create normalized representation for consistent hashing\n    normalized := struct {\n        Date        string                 `json:\"date\"`\n        Description string                 `json:\"description\"`\n        Lines       []map[string]interface{} `json:\"lines\"`\n    }{\n        Date:        entry.Date.Format(\"2006-01-02\"),\n        Description: entry.Description,\n        Lines:       make([]map[string]interface{}, len(entry.Lines)),\n    }\n    \n    for i, line := range entry.Lines {\n        normalized.Lines[i] = map[string]interface{}{\n            \"account_id\": line.AccountID,\n            \"debit\":      line.DebitAmount,\n            \"credit\":     line.CreditAmount,\n        }\n    }\n    \n    data, _ := json.Marshal(normalized)\n    hash := sha256.Sum256(data)\n    return hex.EncodeToString(hash[:])\n}\n```\n\n#### D. Core Logic Skeleton Code\n\n**Journal Entry Validator** (Signatures with detailed TODOs):\n\n```go\npackage validator\n\nimport (\n    \"context\"\n    \"fmt\"\n)\n\n// EntryValidator implements multi-stage journal entry validation\ntype EntryValidator struct {\n    accountService AccountService\n    authService    AuthorizationService\n}\n\n// ValidationError represents a validation failure with context\ntype ValidationError struct {\n    Code    string `json:\"code\"`\n    Field   string `json:\"field\"`\n    Message string `json:\"message\"`\n    Value   interface{} `json:\"value,omitempty\"`\n}\n\n// ValidationResult contains all validation errors and warnings\ntype ValidationResult struct {\n    IsValid  bool               `json:\"is_valid\"`\n    Errors   []ValidationError  `json:\"errors\"`\n    Warnings []ValidationError  `json:\"warnings\"`\n}\n\n// Validate performs comprehensive journal entry validation\nfunc (ev *EntryValidator) Validate(ctx context.Context, entry *JournalEntry) (*ValidationResult, error) {\n    result := &ValidationResult{\n        IsValid:  true,\n        Errors:   make([]ValidationError, 0),\n        Warnings: make([]ValidationError, 0),\n    }\n    \n    // TODO 1: Validate entry structure (non-empty fields, valid formats)\n    // - Check entry.Date is not zero value and not in future\n    // - Verify entry.Description is not empty and within length limits\n    // - Ensure entry.Lines has at least 2 line items\n    // - Validate each line has either DebitAmount OR CreditAmount (not both, not neither)\n    \n    // TODO 2: Validate account references and status\n    // - For each line in entry.Lines, verify AccountID exists in database\n    // - Check that all referenced accounts are in Active status\n    // - Verify accounts belong to correct organization/company context\n    // - Collect any missing or inactive accounts into validation errors\n    \n    // TODO 3: Perform balance validation (debits must equal credits)\n    // - Group entry lines by currency (handle multi-currency entries)\n    // - Sum all debit amounts and all credit amounts within each currency\n    // - Verify that TotalDebits() equals TotalCredits() for each currency\n    // - Add ENTRY_004 error if any currency is unbalanced\n    \n    // TODO 4: Validate account type compatibility\n    // - Check that debit entries to liability/equity/revenue accounts are intentional\n    // - Flag credit entries to asset/expense accounts for review\n    // - These generate warnings rather than errors (unusual but sometimes valid)\n    \n    // TODO 5: Verify user authorization\n    // - Check if current user can post to all referenced accounts\n    // - Some accounts may be restricted (payroll, executive compensation)\n    // - Add ENTRY_006 error if user lacks permission for any account\n    \n    // TODO 6: Check business rule compliance\n    // - Validate posting date against accounting period status (not closed)\n    // - Check for required approval workflows based on entry amount\n    // - Verify compliance with any account-specific posting rules\n    \n    return result, nil\n}\n\n// ValidateStructure performs basic structural validation without database access\nfunc (ev *EntryValidator) ValidateStructure(entry *JournalEntry) []ValidationError {\n    var errors []ValidationError\n    \n    // TODO 1: Validate entry-level fields\n    // - entry.Date must be valid date, not zero, not more than 1 day in future\n    // - entry.Description must be non-empty, max 500 characters\n    // - entry.Reference should be non-empty if provided, max 100 characters\n    \n    // TODO 2: Validate entry lines collection\n    // - entry.Lines must have at least 2 items (double-entry requirement)\n    // - LineNumber fields must be sequential starting from 1\n    // - No duplicate LineNumber values allowed\n    \n    // TODO 3: Validate individual entry lines\n    // - Each line must have exactly one of DebitAmount or CreditAmount (not both)\n    // - Amounts must be positive (zero amounts not allowed)\n    // - Currency fields must be valid ISO currency codes\n    // - AccountID must be valid UUID format\n    \n    return errors\n}\n\n// ValidateBalance ensures debits equal credits across all currencies\nfunc (ev *EntryValidator) ValidateBalance(entry *JournalEntry) (ValidationError, bool) {\n    // TODO 1: Group entry lines by currency\n    // - Create map[string]Money for debit totals by currency\n    // - Create map[string]Money for credit totals by currency\n    // - Iterate through entry.Lines and accumulate amounts\n    \n    // TODO 2: Calculate totals for each currency\n    // - Use Money.Add() method to sum amounts safely\n    // - Handle decimal precision correctly to avoid rounding errors\n    // - Track any arithmetic errors during summation\n    \n    // TODO 3: Compare debit and credit totals\n    // - For each currency, verify TotalDebits.Amount.Equal(TotalCredits.Amount)\n    // - If any currency is unbalanced, return ENTRY_004 validation error\n    // - Include actual amounts in error message for debugging\n    \n    return ValidationError{}, true // Return error and isValid flag\n}\n```\n\n**Transaction Poster** (Signatures with detailed TODOs):\n\n```go\npackage posting\n\nimport (\n    \"context\"\n    \"database/sql\"\n)\n\n// TransactionPoster handles atomic journal entry posting\ntype TransactionPoster struct {\n    db         *sql.DB\n    validator  EntryValidator\n    idempotency *IdempotencyManager\n}\n\n// PostingResult contains the outcome of a posting operation\ntype PostingResult struct {\n    EntryID     string    `json:\"entry_id\"`\n    Status      string    `json:\"status\"`\n    PostedAt    time.Time `json:\"posted_at\"`\n    Message     string    `json:\"message,omitempty\"`\n    Duplicate   bool      `json:\"duplicate\"`\n}\n\n// PostEntry atomically posts a journal entry with full validation\nfunc (tp *TransactionPoster) PostEntry(ctx context.Context, entry *JournalEntry, idempotencyKey string) (*PostingResult, error) {\n    // TODO 1: Check for duplicate submission using idempotency key\n    // - Call tp.idempotency.CheckIdempotency() with provided key\n    // - If existing record found and status is \"POSTED\", return success with existing entry\n    // - If existing record found and status is \"FAILED\", decide whether to retry\n    // - Record new idempotency key if this is first submission\n    \n    // TODO 2: Validate the journal entry one final time\n    // - Call tp.validator.Validate() to ensure entry is still valid\n    // - Account status might have changed since initial validation\n    // - Return validation errors immediately without starting transaction\n    \n    // TODO 3: Begin database transaction and acquire locks\n    // - Use tp.db.BeginTx() with READ_COMMITTED isolation\n    // - Acquire row lock on journal entry with SELECT FOR UPDATE\n    // - Verify entry is still in DRAFT status and not concurrently modified\n    \n    // TODO 4: Perform atomic posting operations within transaction\n    // - Update entry status from DRAFT to POSTED with posting timestamp\n    // - Insert all entry lines into journal_entry_lines table\n    // - Update running balances for all affected accounts\n    // - Create audit trail records for the posting operation\n    \n    // TODO 5: Handle transaction completion\n    // - If all operations succeed, commit the transaction\n    // - If any operation fails, rollback and return appropriate error\n    // - Update idempotency record with final status and result\n    // - Return PostingResult with complete operation details\n    \n    return &PostingResult{}, nil\n}\n\n// PostEntryWithinTransaction posts an entry within an existing transaction\nfunc (tp *TransactionPoster) PostEntryWithinTransaction(ctx context.Context, tx *sql.Tx, entry *JournalEntry) error {\n    // TODO 1: Update journal entry status to POSTED\n    // - Execute UPDATE statement to change status from DRAFT to POSTED\n    // - Set posted_at timestamp and posted_by user information\n    // - Use tx.ExecContext() to run within provided transaction\n    \n    // TODO 2: Insert entry lines into ledger\n    // - Prepare INSERT statement for journal_entry_lines table\n    // - Iterate through entry.Lines and insert each line with proper amounts\n    // - Ensure LineNumber fields are set correctly for sorting\n    \n    // TODO 3: Update account running balances\n    // - For each affected account, calculate balance change from this entry\n    // - Use optimistic locking to prevent concurrent balance corruption\n    // - Handle both debit and credit amounts according to account normal balance\n    \n    // TODO 4: Create audit trail entries\n    // - Record posting operation in audit_log table\n    // - Include entry ID, user, timestamp, and operation details\n    // - Store before/after values for account balances that changed\n    \n    return nil\n}\n\n// ValidateAccountsWithinTx verifies account status within transaction context\nfunc (tp *TransactionPoster) ValidateAccountsWithinTx(ctx context.Context, tx *sql.Tx, accountIDs []string) error {\n    // TODO 1: Query account status for all referenced accounts\n    // - Use SELECT statement with WHERE account_id = ANY($1) for efficiency\n    // - Check that all accounts exist and are in ACTIVE status\n    // - Verify accounts are not marked for closure or archival\n    \n    // TODO 2: Validate account permissions\n    // - Check if current user has posting privileges for each account\n    // - Some accounts may require special authorization (restricted accounts)\n    // - Return detailed error if any account access is denied\n    \n    return nil\n}\n```\n\n#### E. Language-Specific Hints\n\n**Go-Specific Implementation Tips:**\n\n- Use `context.Context` throughout for request tracing and cancellation support\n- Implement proper error wrapping with `fmt.Errorf(\"operation failed: %w\", err)` for error chains\n- Use `database/sql.TxOptions` to set appropriate isolation levels for accounting transactions\n- Leverage `sync.Pool` for reusing validation result objects under high load\n- Use `time.Time.UTC()` consistently for all timestamp storage to avoid timezone issues\n- Implement `String()` methods on error types for better debugging output\n- Use `atomic` package operations for updating in-memory statistics counters\n- Consider using `errgroup` for parallel validation operations when validating large batches\n\n**Database-Specific Hints:**\n\n- Use PostgreSQL `NUMERIC` type for monetary amounts to avoid floating-point precision issues\n- Implement proper foreign key constraints between `journal_entries` and `entry_lines` tables\n- Create compound indexes on `(account_id, posting_date)` for efficient balance queries\n- Use `SELECT FOR UPDATE SKIP LOCKED` for high-concurrency posting scenarios\n- Implement check constraints to ensure `debit_amount` and `credit_amount` are mutually exclusive\n- Use database triggers sparingly; prefer application-level logic for better testability\n\n#### F. Milestone Checkpoints\n\n**After implementing Journal Entry Validation:**\n```bash\ngo test ./internal/engine/validator/... -v\n```\n\nExpected output should show tests passing for:\n- Structure validation catching empty descriptions and invalid dates\n- Balance validation detecting unbalanced entries (debits ≠ credits)  \n- Account validation rejecting references to non-existent accounts\n- Currency validation ensuring consistent currency usage within entries\n\nManual verification:\n```bash\n# Test validation API endpoint\ncurl -X POST http://localhost:8080/api/validate-entry \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"date\": \"2024-01-15\",\n    \"description\": \"Test entry\",\n    \"lines\": [\n      {\"account_id\": \"1001-CASH\", \"debit_amount\": {\"amount\": \"100.00\", \"currency\": \"USD\"}},\n      {\"account_id\": \"4001-REVENUE\", \"credit_amount\": {\"amount\": \"100.00\", \"currency\": \"USD\"}}\n    ]\n  }'\n```\n\nShould return validation success. Try with unbalanced amounts to verify error detection.\n\n**After implementing Atomic Transaction Posting:**\n```bash\ngo test ./internal/engine/posting/... -race -v\n```\n\nThe race detector should find no data races. Test concurrent posting:\n```bash\n# Run multiple concurrent posts to verify atomicity\nfor i in {1..10}; do\n  curl -X POST http://localhost:8080/api/post-entry \\\n    -H \"Content-Type: application/json\" \\\n    -H \"Idempotency-Key: test-$i\" \\\n    -d '{\"date\":\"2024-01-15\",\"description\":\"Concurrent test '$i'\",\"lines\":[...]}' &\ndone\nwait\n```\n\nVerify that all entries posted successfully or failed cleanly (no partial posts).\n\n**After implementing Idempotency and Duplicate Prevention:**\n\nTest duplicate submission handling:\n```bash\n# Submit same entry twice with same idempotency key\nIDEMPOTENCY_KEY=\"test-duplicate-$(date +%s)\"\ncurl -X POST http://localhost:8080/api/post-entry \\\n  -H \"Idempotency-Key: $IDEMPOTENCY_KEY\" \\\n  -d '{\"date\":\"2024-01-15\",\"description\":\"Duplicate test\",\"lines\":[...]}' \n\ncurl -X POST http://localhost:8080/api/post-entry \\\n  -H \"Idempotency-Key: $IDEMPOTENCY_KEY\" \\\n  -d '{\"date\":\"2024-01-15\",\"description\":\"Duplicate test\",\"lines\":[...]}'\n```\n\nSecond request should return same result as first without creating duplicate entry.\n\n#### G. Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Validation passes but posting fails | Account status changed between validation and posting | Check account active status in transaction log | Re-validate accounts within posting transaction |\n| Unbalanced trial balance after posting | Rounding errors in decimal arithmetic or incorrect account type handling | Query sum of all debits and credits, check for currency inconsistencies | Use proper decimal.Decimal arithmetic, verify account normal balance logic |\n| Duplicate entries despite idempotency keys | Race condition in idempotency check/insert | Check for duplicate idempotency records with different timestamps | Use database UPSERT or proper locking for idempotency table |\n| Posting transactions hang indefinitely | Database deadlock or lock timeout | Check PostgreSQL logs for deadlock detection, review lock acquisition order | Implement lock timeout and consistent lock ordering |\n| Validation errors not user-friendly | Generic error messages without context | Review ValidationError structures and field mappings | Add specific error codes and human-readable descriptions |\n| Performance degradation under load | Missing database indexes or inefficient queries | Use EXPLAIN ANALYZE on posting queries, check for table scans | Add indexes on account_id, posting_date; optimize balance update queries |\n\n\n> **Milestone(s):** 3 (Balance Calculation), as this section implements efficient account balance computation with running totals and point-in-time queries that enable fast financial reporting\n\n## Balance Calculation Engine\n\nThink of account balance calculation like maintaining the running score in a basketball game. Rather than reviewing every play from the beginning each time you want to know the score, the scoreboard continuously updates with each basket. However, unlike basketball, our accounting scoreboard must also answer historical questions like \"what was the score at the end of the third quarter?\" This dual requirement—current balance efficiency and historical accuracy—drives the core design of the balance calculation engine.\n\nThe balance calculation engine serves as the computational heart of the ledger system, transforming raw journal entry data into meaningful financial information. Every time a journal entry is posted, the engine must efficiently update account balances while maintaining the ability to answer historical balance queries for any point in time. This component bridges the gap between the immutable audit trail of transactions and the dynamic reporting needs of financial users.\n\n![Balance Calculation Process Flow](./diagrams/balance-calculation-flow.svg)\n\n### Running Balance Maintenance\n\nThink of running balance maintenance like keeping a checkbook register where you write down your running balance after each transaction. Instead of adding up all your deposits and subtracting all your checks every time you want to know your balance, you simply look at the last entry in your register. The balance calculation engine applies this same principle across thousands of accounts simultaneously.\n\nThe **running balance** represents the continuously updated current balance for each account, computed incrementally as new journal entries are posted. This approach transforms balance queries from expensive aggregation operations that scan thousands of transaction records into simple lookups of pre-computed values. The engine maintains these running balances in a dedicated table that gets updated atomically with each journal entry posting.\n\nWhen a journal entry is posted, the balance engine examines each `EntryLine` and updates the corresponding account's running balance based on whether the line contains a debit or credit amount. The calculation must respect the normal balance conventions for different account types—assets and expenses increase with debits, while liabilities, equity, and revenue increase with credits.\n\nThe balance update calculation follows this logic for each entry line:\n\n1. Retrieve the account's current running balance and account type from the database\n2. Determine whether this account type follows debit-normal or credit-normal conventions using the `IsDebitNormal()` method\n3. If the entry line contains a debit amount and the account is debit-normal (or contains a credit amount and the account is credit-normal), add the amount to the running balance\n4. If the entry line contains a debit amount and the account is credit-normal (or contains a credit amount and the account is debit-normal), subtract the amount from the running balance\n5. Update the running balance record with the new calculated balance and the timestamp of the posting\n\n> **Design Insight**: Running balances eliminate the need to scan potentially millions of historical transactions for balance queries, reducing typical balance lookup time from seconds to milliseconds. However, they introduce the complexity of maintaining consistency between the immutable transaction log and the mutable balance cache.\n\n**Running Balance Data Structure**\n\nThe running balance system maintains account balances in a dedicated table that provides fast lookup while preserving historical accuracy:\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| AccountID | string | Foreign key reference to the account whose balance is tracked |\n| CurrentBalance | Money | The current balance computed from all posted journal entries |\n| LastUpdatedAt | time.Time | Timestamp when this balance was last updated by a journal entry posting |\n| LastEntryID | string | ID of the most recent journal entry that affected this account's balance |\n| Version | int64 | Optimistic locking version number to prevent concurrent update conflicts |\n\n**Balance Update Workflow**\n\nThe balance update process executes within the same database transaction as journal entry posting to ensure atomic consistency:\n\n| Step | Action | Validation | Error Handling |\n|------|--------|------------|----------------|\n| 1 | Lock running balance records for all affected accounts | Verify accounts exist and are active | Rollback transaction if any account is invalid |\n| 2 | Calculate balance changes for each entry line | Apply normal balance rules based on account type | Rollback if calculation produces invalid amount |\n| 3 | Update running balance records with new amounts | Check for concurrent modifications using version numbers | Retry with backoff if optimistic lock fails |\n| 4 | Record balance update audit trail | Log old balance, new balance, and triggering entry ID | Continue posting but log audit trail failure |\n| 5 | Commit transaction with journal entry and balance updates | Verify database constraints are satisfied | Full rollback if commit fails |\n\n> **Decision: Atomic Balance Updates**\n> - **Context**: Balance updates could happen asynchronously after journal entry posting to improve performance\n> - **Options Considered**: \n>   1. Synchronous updates within posting transaction\n>   2. Asynchronous updates via message queue\n>   3. Lazy calculation on demand\n> - **Decision**: Synchronous updates within posting transaction\n> - **Rationale**: Ensures balance consistency and eliminates race conditions where balance queries might see stale data immediately after posting\n> - **Consequences**: Slightly increases posting latency but guarantees that balance queries always reflect all posted entries\n\n**Concurrent Balance Updates**\n\nMultiple journal entries might affect the same account simultaneously, requiring careful coordination to prevent lost updates and maintain balance accuracy. The balance engine uses optimistic locking with version numbers to detect concurrent modifications and retry failed updates.\n\nWhen two transactions attempt to update the same account balance concurrently, the database's optimistic locking mechanism ensures that only one succeeds initially. The failed transaction detects the version mismatch, refreshes its view of the current balance, recalculates the update, and retries the operation. This approach provides better performance than pessimistic locking while maintaining data integrity.\n\nThe retry logic implements exponential backoff to avoid thundering herd problems when many transactions contend for popular accounts. After three consecutive retry failures, the system logs an error and fails the journal entry posting, requiring manual intervention to resolve the conflict.\n\n### Point-in-Time Balance Queries\n\nThink of point-in-time balance queries like asking \"what was my bank account balance at the end of last month?\" Your bank doesn't recalculate your entire transaction history—instead, it uses your current balance and either adds back or subtracts transactions that happened after your target date. The balance engine applies similar logic but with additional complexity to handle the continuous nature of business transactions.\n\n**Point-in-time balance calculation** determines an account's balance as of a specific date and time by considering only journal entries that were posted on or before that moment. This capability is essential for generating historical financial reports, performing account reconciliation, and supporting regulatory compliance requirements that demand balance verification as of specific dates.\n\nThe engine supports two calculation strategies depending on the query date relative to the current date and the volume of intervening transactions:\n\n1. **Forward calculation**: Start from the account's opening balance and add all posted entries up to the target date\n2. **Backward calculation**: Start from the current running balance and subtract all entries posted after the target date\n\nThe engine automatically selects the most efficient strategy based on the transaction volume estimates for each date range.\n\n**Point-in-Time Query Interface**\n\nThe balance calculation engine exposes point-in-time queries through a standardized interface that abstracts the underlying calculation strategy:\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| GetBalanceAsOf | accountID string, asOfDate time.Time | Money, error | Returns the account balance considering only entries posted on or before the specified date |\n| GetMultipleBalancesAsOf | accountIDs []string, asOfDate time.Time | map[string]Money, error | Efficiently calculates balances for multiple accounts as of the same date |\n| GetBalanceHistory | accountID string, fromDate time.Time, toDate time.Time, interval string | []BalanceSnapshot, error | Returns a series of balance snapshots at regular intervals within the date range |\n| GetTrialBalanceAsOf | asOfDate time.Time | TrialBalance, error | Generates a complete trial balance report showing all account balances as of the specified date |\n\n**Calculation Strategy Selection**\n\nThe balance engine automatically chooses between forward and backward calculation based on efficiency heuristics that consider the number of transactions in each direction:\n\n> **Decision: Adaptive Calculation Strategy**\n> - **Context**: Point-in-time queries might target dates very close to current time or far in the past, leading to vastly different performance characteristics\n> - **Options Considered**:\n>   1. Always calculate forward from account opening\n>   2. Always calculate backward from current balance  \n>   3. Dynamically choose based on transaction volume estimates\n> - **Decision**: Dynamic strategy selection with volume-based heuristics\n> - **Rationale**: Forward calculation is faster for recent dates with few intervening transactions, while backward calculation is faster for historical dates\n> - **Consequences**: Requires maintaining transaction count estimates but provides optimal performance across all query date ranges\n\n**Strategy Selection Logic**\n\n| Query Date Range | Transaction Count After Target | Transaction Count Before Target | Selected Strategy | Rationale |\n|------------------|--------------------------------|--------------------------------|-------------------|-----------|\n| Last 30 days | < 1000 | > 10000 | Backward | Few recent transactions to subtract |\n| Last 90 days | < 5000 | > 25000 | Backward | Moderate recent transactions |\n| 6-12 months ago | > 10000 | < 20000 | Forward | More transactions after than before |\n| > 1 year ago | > 50000 | < 10000 | Forward | Much longer history after target date |\n\n**Balance Snapshot Caching**\n\nFor frequently queried historical dates (such as month-end or quarter-end), the balance engine can optionally cache calculated balances to avoid repeated computation. These cached snapshots are invalidated if any journal entries are posted with dates on or before the snapshot date, ensuring accuracy despite the immutable audit trail allowing retroactive entry corrections.\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| AccountID | string | Account whose balance was calculated |\n| AsOfDate | time.Time | The point-in-time date for this balance calculation |\n| Balance | Money | The calculated balance as of the specified date |\n| CalculatedAt | time.Time | When this snapshot was computed |\n| LastEntryDate | time.Time | Date of the most recent entry included in this calculation |\n| IsValid | bool | Whether this snapshot is still valid (no entries posted for earlier dates) |\n\n### Trial Balance Validation\n\nThink of trial balance validation like double-checking that a complex mathematical equation balances on both sides. In double-entry bookkeeping, the fundamental equation is Assets + Expenses = Liabilities + Equity + Revenue. The trial balance validation ensures this equation holds true by verifying that the sum of all debit balances equals the sum of all credit balances across all accounts.\n\nThe **trial balance** serves as the primary integrity check for the entire ledger system, providing mathematical proof that all journal entries have been recorded correctly according to double-entry principles. This validation runs automatically after each posting session and can be triggered on demand to verify ledger integrity at any point in time.\n\nTrial balance validation examines every account's current balance (or balance as of a specific date for historical validation) and categorizes each balance as either a debit or credit based on the account's normal balance convention and the sign of the balance amount. The validation succeeds only when the total of all debit balances exactly equals the total of all credit balances.\n\n**Trial Balance Calculation Logic**\n\nThe trial balance calculation process transforms account balances into debit and credit columns based on accounting conventions:\n\n1. Retrieve current balances (or point-in-time balances) for all active accounts in the chart of accounts\n2. For each account balance, determine whether it represents a debit or credit amount based on the account type's normal balance and the balance sign\n3. If the account is debit-normal (Asset or Expense) and has a positive balance, include it in the debit column\n4. If the account is debit-normal and has a negative balance, include the absolute value in the credit column\n5. If the account is credit-normal (Liability, Equity, or Revenue) and has a positive balance, include it in the credit column  \n6. If the account is credit-normal and has a negative balance, include the absolute value in the debit column\n7. Sum all amounts in the debit column and all amounts in the credit column\n8. Verify that the debit total exactly equals the credit total\n\n**Trial Balance Data Structure**\n\nThe trial balance validation produces a comprehensive report showing all account balances organized into debit and credit columns:\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| AsOfDate | time.Time | The date for which the trial balance was calculated |\n| AccountBalances | []AccountBalance | List of all accounts with their calculated balances |\n| TotalDebits | Money | Sum of all amounts appearing in the debit column |\n| TotalCredits | Money | Sum of all amounts appearing in the credit column |\n| IsBalanced | bool | Whether total debits equal total credits |\n| Variance | Money | Difference between debits and credits (should be zero) |\n| GeneratedAt | time.Time | When this trial balance was computed |\n\n**Individual Account Balance Entry**\n\nEach account's contribution to the trial balance is represented with complete detail for audit and troubleshooting purposes:\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| AccountID | string | Unique identifier for the account |\n| AccountCode | string | Human-readable account code (e.g., \"1001-Cash\") |\n| AccountName | string | Descriptive name of the account |\n| AccountType | AccountType | Whether this is ASSET, LIABILITY, EQUITY, REVENUE, or EXPENSE |\n| Balance | Money | The raw calculated balance amount (may be positive or negative) |\n| DebitAmount | *Money | Amount appearing in debit column (nil if this balance contributes to credit column) |\n| CreditAmount | *Money | Amount appearing in credit column (nil if this balance contributes to debit column) |\n| LastEntryDate | time.Time | Date of the most recent journal entry affecting this account |\n\n> **Design Insight**: Trial balance validation provides mathematical certainty that the ledger is internally consistent. An unbalanced trial balance indicates either a software bug in the posting logic or potential data corruption, making this validation essential for maintaining confidence in financial reports.\n\n**Automated Trial Balance Monitoring**\n\nThe balance engine automatically performs trial balance validation at key points in the transaction processing workflow:\n\n| Trigger Event | Validation Scope | Failure Action | Recovery Process |\n|---------------|------------------|----------------|------------------|\n| After each journal entry posting | Current balances only | Log warning, continue processing | Schedule full validation during maintenance window |\n| End of business day batch | Current balances for all accounts | Alert administrators, halt posting | Investigate variance, identify and correct source |\n| Month-end closing | Historical balances as of closing date | Block closing process | Require manual variance resolution before proceeding |\n| On-demand validation | Any specified date range | Report results to user | Provide drill-down capabilities to identify problem accounts |\n\n**Variance Investigation Tools**\n\nWhen trial balance validation detects an imbalance, the balance engine provides investigative tools to identify the source of the discrepancy:\n\nThe variance analysis tool examines recent journal entries and balance changes to identify potential causes of trial balance discrepancies. It compares expected balance changes (computed from journal entry debits and credits) against actual balance changes in the running balance table to detect inconsistencies.\n\nFor each account contributing to the trial balance variance, the analysis tool reports the account's expected balance (calculated by summing all journal entry lines) versus its actual running balance, highlighting accounts where these values diverge. This comparison quickly identifies whether the problem lies in journal entry recording, balance calculation logic, or data corruption.\n\n⚠️ **Pitfall: Ignoring Small Trial Balance Variances**\nMany developers assume that tiny discrepancies (like $0.01 differences) are acceptable rounding errors and can be ignored. This is dangerous because even small variances often indicate systematic problems that will compound over time. A $0.01 variance might represent a bug that affects one transaction out of every thousand, which will create increasingly large discrepancies as transaction volume grows. Always investigate and resolve trial balance variances regardless of magnitude.\n\n### Balance Caching Strategy\n\nThink of balance caching like keeping frequently referenced books on your desk instead of walking to the library every time you need them. The balance calculation engine implements a sophisticated caching strategy that keeps commonly requested balance calculations in fast-access storage while ensuring the cached values remain accurate as new transactions are posted.\n\nThe **balance caching system** addresses the performance challenges of serving frequent balance queries, especially for high-volume accounts and popular reporting dates. Without caching, generating a balance sheet for a large organization might require thousands of individual balance calculations, each potentially scanning hundreds or thousands of journal entries. Effective caching reduces these expensive calculations to simple memory or database lookups.\n\nThe caching strategy operates on multiple levels, each optimized for different access patterns and data consistency requirements. The engine maintains separate caches for current balances (updated with every transaction) and historical balances (computed on demand and cached for future reuse).\n\n**Multi-Level Cache Architecture**\n\nThe balance caching system implements a hierarchical approach that balances performance, consistency, and resource utilization:\n\n| Cache Level | Storage Location | Update Frequency | Consistency Guarantee | Use Case |\n|-------------|------------------|------------------|----------------------|----------|\n| L1 - Memory Cache | Application memory | Real-time with journal posting | Eventually consistent | High-frequency current balance queries |\n| L2 - Database Cache | Running balance table | Synchronous with posting transaction | Immediately consistent | Cross-session balance queries and reporting |\n| L3 - Historical Cache | Snapshot table | On-demand calculation | Point-in-time consistent | Historical reporting and compliance queries |\n| L4 - Report Cache | Materialized views | Scheduled refresh | Batch consistent | Pre-computed financial statements |\n\n**Current Balance Caching**\n\nCurrent balance caching focuses on providing immediate access to account balances that reflect all posted transactions up to the current moment. This cache is updated synchronously with journal entry posting to ensure that balance queries always reflect the most recent account activity.\n\nThe memory cache (L1) stores the most frequently accessed account balances in the application's memory space, providing sub-millisecond response times for balance queries. This cache uses an LRU (Least Recently Used) eviction policy to manage memory consumption while keeping hot accounts readily available.\n\nThe database cache (L2) maintains running balances in the database itself, updated within the same transaction as journal entry posting. This ensures that balance queries from different application instances or sessions always see consistent values, even immediately after transaction posting.\n\n**Cache Update Workflow**\n\nThe cache update process maintains consistency across all cache levels while minimizing the performance impact on transaction posting:\n\n1. Within the journal entry posting transaction, update the L2 database cache (running balance table) with new balance values\n2. After successful transaction commit, immediately update the L1 memory cache with the new balance values for affected accounts\n3. Invalidate any L3 historical cache entries that might be affected by the new journal entry (entries cached for dates on or after the posting date)\n4. Schedule L4 report cache refresh if the updated accounts are included in any materialized financial reports\n\n> **Decision: Synchronous L2 Updates with Asynchronous L1 Propagation**\n> - **Context**: Cache updates could happen synchronously (blocking transaction posting) or asynchronously (allowing temporary inconsistency)\n> - **Options Considered**:\n>   1. Fully synchronous updates across all cache levels\n>   2. Synchronous database cache with asynchronous memory cache\n>   3. Fully asynchronous updates with eventual consistency\n> - **Decision**: Synchronous L2 database cache updates with asynchronous L1 memory cache propagation\n> - **Rationale**: Database cache ensures cross-session consistency while memory cache async updates avoid blocking transaction throughput\n> - **Consequences**: Brief windows where memory cache might be stale, but database queries always return current values\n\n**Historical Balance Caching**\n\nHistorical balance caching optimizes the performance of point-in-time balance queries by storing previously calculated balance snapshots for popular query dates. This cache is particularly valuable for regulatory reporting and financial analysis that frequently reference month-end, quarter-end, and year-end balances.\n\nThe historical cache uses a demand-driven population strategy—balance snapshots are calculated and cached only when first requested, then served from cache for subsequent identical queries. This approach avoids the storage overhead of pre-computing snapshots for every possible date while still providing performance benefits for repeated queries.\n\n**Cache Invalidation Strategy**\n\nCache invalidation ensures that cached balance values remain accurate despite ongoing transaction activity that might affect account balances. The invalidation strategy must handle both straightforward cases (new transactions affecting cached accounts) and complex scenarios (retroactive entries posted with dates in the past).\n\n| Invalidation Trigger | Affected Cache Levels | Invalidation Scope | Rebuild Strategy |\n|---------------------|----------------------|--------------------|------------------|\n| New journal entry posted | L1, L2, L3, L4 | Accounts referenced in entry | Immediate L1/L2 rebuild, lazy L3/L4 rebuild |\n| Retroactive entry posted | L3, L4 | All cached dates on or after entry date | Immediate invalidation, on-demand rebuild |\n| Account reclassification | All levels | All cached values for affected account | Full cache flush for account |\n| Batch entry processing | L1, L2 | All accounts in batch | Deferred rebuild after batch completion |\n\n**Cache Performance Monitoring**\n\nThe balance caching system includes comprehensive monitoring to track cache effectiveness and identify opportunities for optimization:\n\n| Metric | Measurement | Target Range | Action on Deviation |\n|--------|-------------|--------------|-------------------|\n| L1 Cache Hit Rate | Successful memory cache lookups / total balance queries | > 80% | Increase cache size or improve eviction policy |\n| L2 Cache Consistency | Database cache values matching transaction log | 100% | Investigate and resolve synchronization bugs |\n| L3 Cache Utilization | Historical snapshots served from cache / total historical queries | > 60% | Adjust snapshot retention policies |\n| Cache Update Latency | Time from transaction commit to L1 cache refresh | < 100ms | Optimize cache update procedures |\n\n⚠️ **Pitfall: Cache Stampede on Popular Accounts**\nWhen a heavily-used account (like a main cash account) has its cache invalidated, multiple concurrent requests might simultaneously attempt to recalculate and update the cached balance, causing a \"cache stampede.\" This can overwhelm the database and cause significant performance degradation. Implement cache locking or single-flight mechanisms to ensure only one thread recalculates each cached value while others wait for the result.\n\n**Memory Management and Resource Limits**\n\nThe in-memory cache (L1) implements sophisticated memory management to prevent excessive memory consumption while maintaining performance benefits. The cache tracks memory usage and implements both hard limits (maximum memory allocation) and soft limits (preferred memory usage with graceful degradation).\n\nWhen memory pressure increases, the cache employs a multi-stage eviction process: first removing least-recently-used entries, then entries for inactive accounts, and finally falling back to database-only balance queries. This graceful degradation ensures that the application continues functioning even under memory constraints, though with reduced performance.\n\nThe cache also implements background maintenance processes that periodically validate cached values against authoritative database records, ensuring that any inconsistencies (potentially caused by software bugs or data corruption) are detected and corrected automatically.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Race Conditions in Balance Updates**\nConcurrent journal entries affecting the same account can cause race conditions where balance updates are lost or incorrectly calculated. This happens when two transactions read the same current balance, calculate their respective updates independently, and then both attempt to write their results—the last writer wins, losing the first transaction's balance change. Always use database-level locking or optimistic concurrency control with version numbers to prevent lost updates.\n\n⚠️ **Pitfall: Floating-Point Precision Errors in Balance Calculations**\nUsing floating-point arithmetic for monetary calculations can introduce precision errors that accumulate over time and cause trial balance discrepancies. A balance that should be exactly $100.00 might be stored as $99.999999999998, leading to rounding errors when multiple balances are summed. Always use fixed-point decimal arithmetic or integer-based monetary representations to ensure exact calculations.\n\n⚠️ **Pitfall: Ignoring Account Type Normal Balance Rules**\nIncorrectly applying debit and credit amounts without considering account type normal balance conventions will produce incorrect balance calculations. For example, a credit amount to an asset account should decrease the account balance, but naive addition logic would increase it. Always implement and test the normal balance rules: assets and expenses increase with debits and decrease with credits, while liabilities, equity, and revenue increase with credits and decrease with debits.\n\n⚠️ **Pitfall: Point-in-Time Queries Missing Transaction Timestamps**\nUsing only posting dates without considering transaction timestamps can cause point-in-time queries to return incorrect results when multiple transactions are posted on the same date. If a balance query asks for balances \"as of end of day March 31\" but transactions posted on March 31 have different timestamps, the query might include or exclude transactions inconsistently. Always use complete timestamp comparisons (date and time) for point-in-time calculations.\n\n⚠️ **Pitfall: Cache Invalidation Gaps During High-Volume Posting**\nDuring high-volume transaction posting periods, cache invalidation messages might be delayed or lost, causing cached balances to become stale. Users might see outdated balance information even after recent transactions have been posted. Implement cache validation mechanisms that periodically verify cached values against authoritative database records, especially for critical accounts and during high-activity periods.\n\n### Implementation Guidance\n\nThe balance calculation engine requires careful implementation to achieve the performance and accuracy requirements of a production accounting system. This section provides complete working code for the infrastructure components and detailed guidance for implementing the core balance calculation logic.\n\n**Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Balance Storage | PostgreSQL with standard tables | PostgreSQL with materialized views and partitioning |\n| Cache Layer | In-memory map with sync.RWMutex | Redis cluster with consistent hashing |\n| Decimal Arithmetic | shopspring/decimal package | Custom fixed-point integer implementation |\n| Concurrent Updates | Database row locking | Optimistic locking with retry logic |\n| Performance Monitoring | Simple log metrics | Prometheus with custom balance calculation metrics |\n\n**Recommended File Structure**\n\n```\ninternal/balance/\n  engine.go                 ← main balance calculation engine\n  running_balance.go        ← running balance maintenance logic  \n  point_in_time.go         ← historical balance calculation\n  trial_balance.go         ← trial balance validation\n  cache.go                 ← multi-level caching implementation\n  models.go                ← balance-related data structures\n  engine_test.go           ← comprehensive balance engine tests\n```\n\n**Balance Calculation Data Structures**\n\n```go\npackage balance\n\nimport (\n    \"time\"\n    \"github.com/shopspring/decimal\"\n    \"sync\"\n)\n\n// RunningBalance represents the current balance for an account\ntype RunningBalance struct {\n    AccountID      string          `json:\"account_id\" db:\"account_id\"`\n    CurrentBalance Money           `json:\"current_balance\" db:\"current_balance\"`\n    LastUpdatedAt  time.Time       `json:\"last_updated_at\" db:\"last_updated_at\"`\n    LastEntryID    string          `json:\"last_entry_id\" db:\"last_entry_id\"`\n    Version        int64           `json:\"version\" db:\"version\"`\n}\n\n// BalanceSnapshot represents a point-in-time balance calculation\ntype BalanceSnapshot struct {\n    AccountID     string    `json:\"account_id\"`\n    AsOfDate      time.Time `json:\"as_of_date\"`\n    Balance       Money     `json:\"balance\"`\n    CalculatedAt  time.Time `json:\"calculated_at\"`\n    LastEntryDate time.Time `json:\"last_entry_date\"`\n    IsValid       bool      `json:\"is_valid\"`\n}\n\n// TrialBalance represents a complete trial balance report\ntype TrialBalance struct {\n    AsOfDate        time.Time        `json:\"as_of_date\"`\n    AccountBalances []AccountBalance `json:\"account_balances\"`\n    TotalDebits     Money            `json:\"total_debits\"`\n    TotalCredits    Money            `json:\"total_credits\"`\n    IsBalanced      bool             `json:\"is_balanced\"`\n    Variance        Money            `json:\"variance\"`\n    GeneratedAt     time.Time        `json:\"generated_at\"`\n}\n\n// AccountBalance represents one account's contribution to trial balance\ntype AccountBalance struct {\n    AccountID     string       `json:\"account_id\"`\n    AccountCode   string       `json:\"account_code\"`\n    AccountName   string       `json:\"account_name\"`\n    AccountType   AccountType  `json:\"account_type\"`\n    Balance       Money        `json:\"balance\"`\n    DebitAmount   *Money       `json:\"debit_amount\"`\n    CreditAmount  *Money       `json:\"credit_amount\"`\n    LastEntryDate time.Time    `json:\"last_entry_date\"`\n}\n```\n\n**Balance Engine Interface**\n\n```go\n// BalanceEngine provides account balance calculation and caching services\ntype BalanceEngine interface {\n    // Running balance operations\n    UpdateRunningBalances(ctx context.Context, entry *JournalEntry) error\n    GetCurrentBalance(ctx context.Context, accountID string) (Money, error)\n    GetCurrentBalances(ctx context.Context, accountIDs []string) (map[string]Money, error)\n    \n    // Point-in-time balance operations  \n    GetBalanceAsOf(ctx context.Context, accountID string, asOfDate time.Time) (Money, error)\n    GetMultipleBalancesAsOf(ctx context.Context, accountIDs []string, asOfDate time.Time) (map[string]Money, error)\n    GetBalanceHistory(ctx context.Context, accountID string, fromDate time.Time, toDate time.Time, interval string) ([]BalanceSnapshot, error)\n    \n    // Trial balance operations\n    GetTrialBalance(ctx context.Context) (*TrialBalance, error)\n    GetTrialBalanceAsOf(ctx context.Context, asOfDate time.Time) (*TrialBalance, error)\n    ValidateTrialBalance(ctx context.Context) error\n    \n    // Cache management\n    InvalidateCache(ctx context.Context, accountID string) error\n    RefreshCache(ctx context.Context) error\n}\n```\n\n**Complete Balance Engine Implementation Starter**\n\n```go\npackage balance\n\nimport (\n    \"context\"\n    \"database/sql\"\n    \"fmt\"\n    \"sync\"\n    \"time\"\n    \"github.com/shopspring/decimal\"\n)\n\n// Engine implements the BalanceEngine interface with multi-level caching\ntype Engine struct {\n    db           *sql.DB\n    memoryCache  *MemoryCache\n    mu           sync.RWMutex\n}\n\n// MemoryCache provides L1 in-memory balance caching\ntype MemoryCache struct {\n    balances map[string]CachedBalance\n    mu       sync.RWMutex\n    maxSize  int\n    ttl      time.Duration\n}\n\n// CachedBalance represents a balance stored in memory cache\ntype CachedBalance struct {\n    Balance   Money\n    CachedAt  time.Time\n    Version   int64\n}\n\n// NewEngine creates a new balance calculation engine with caching\nfunc NewEngine(db *sql.DB, cacheSize int, cacheTTL time.Duration) *Engine {\n    return &Engine{\n        db: db,\n        memoryCache: &MemoryCache{\n            balances: make(map[string]CachedBalance),\n            maxSize:  cacheSize,\n            ttl:      cacheTTL,\n        },\n    }\n}\n```\n\n**Core Balance Calculation Skeleton**\n\n```go\n// UpdateRunningBalances atomically updates account balances for a posted journal entry\n// This method executes within the same transaction as journal entry posting\nfunc (e *Engine) UpdateRunningBalances(ctx context.Context, entry *JournalEntry) error {\n    // TODO 1: Begin database transaction for balance updates\n    // TODO 2: Lock running balance records for all accounts in entry.Lines to prevent concurrent updates\n    // TODO 3: For each EntryLine in the journal entry:\n    //   - Retrieve current RunningBalance record for the line's AccountID\n    //   - Calculate balance change based on DebitAmount/CreditAmount and account normal balance\n    //   - Apply change to current balance and increment version number\n    //   - Update RunningBalance record in database\n    // TODO 4: Commit transaction and handle any constraint violations or deadlocks\n    // TODO 5: Update memory cache (L1) with new balance values for affected accounts\n    // TODO 6: Invalidate historical balance cache (L3) entries that might be affected\n    // Hint: Use optimistic locking with version numbers to detect concurrent modifications\n    // Hint: Implement exponential backoff retry logic for deadlock recovery\n}\n\n// GetCurrentBalance retrieves the current balance for an account with caching\nfunc (e *Engine) GetCurrentBalance(ctx context.Context, accountID string) (Money, error) {\n    // TODO 1: Check L1 memory cache for accountID balance\n    // TODO 2: If cache hit and entry is not expired, return cached balance\n    // TODO 3: If cache miss or expired, query L2 database cache (running_balances table)\n    // TODO 4: Update L1 memory cache with retrieved balance\n    // TODO 5: Return balance with proper error handling for account not found\n    // Hint: Use sync.RWMutex for concurrent cache access\n    // Hint: Implement cache eviction when memory cache reaches maxSize\n}\n\n// GetBalanceAsOf calculates account balance as of a specific date and time\nfunc (e *Engine) GetBalanceAsOf(ctx context.Context, accountID string, asOfDate time.Time) (Money, error) {\n    // TODO 1: Check L3 historical cache for existing balance snapshot\n    // TODO 2: If cache hit and snapshot is valid, return cached balance\n    // TODO 3: Choose calculation strategy (forward vs backward) based on date range and transaction volume\n    // TODO 4: Execute chosen calculation strategy:\n    //   - Forward: sum all entry lines from account opening to asOfDate\n    //   - Backward: start with current balance and subtract entries after asOfDate\n    // TODO 5: Cache calculated balance in L3 historical cache for future queries\n    // TODO 6: Return calculated balance with error handling\n    // Hint: Use EXPLAIN ANALYZE to verify query performance for both strategies\n    // Hint: Consider using database query hints for large date ranges\n}\n\n// GetTrialBalance generates a complete trial balance report for all accounts\nfunc (e *Engine) GetTrialBalance(ctx context.Context) (*TrialBalance, error) {\n    // TODO 1: Retrieve current balances for all active accounts in chart of accounts\n    // TODO 2: For each account balance, determine debit/credit classification:\n    //   - Use account.IsDebitNormal() to determine normal balance side\n    //   - Positive balance on normal side goes to that column\n    //   - Negative balance on normal side goes to opposite column (absolute value)\n    // TODO 3: Sum all debit column amounts and all credit column amounts\n    // TODO 4: Calculate variance (debits - credits) and set IsBalanced flag\n    // TODO 5: Populate AccountBalance entries with account details and amounts\n    // TODO 6: Return complete TrialBalance with generation timestamp\n    // Hint: Zero variance indicates a balanced ledger; non-zero requires investigation\n    // Hint: Include account hierarchy information for better report organization\n}\n\n// ValidateTrialBalance performs integrity check on the entire ledger\nfunc (e *Engine) ValidateTrialBalance(ctx context.Context) error {\n    // TODO 1: Generate current trial balance using GetTrialBalance()\n    // TODO 2: Check if trial balance is balanced (variance equals zero)\n    // TODO 3: If unbalanced, identify accounts contributing to variance:\n    //   - Compare running balance table values to journal entry line sums\n    //   - Report accounts where calculated vs stored balances differ\n    // TODO 4: Log detailed variance analysis for debugging purposes\n    // TODO 5: Return error if trial balance fails validation with specific variance amount\n    // Hint: Small variances might indicate rounding errors; large variances suggest data corruption\n    // Hint: Provide drill-down capability to identify specific problematic journal entries\n}\n```\n\n**Cache Management Implementation**\n\n```go\n// invalidateHistoricalCache removes cached snapshots that might be affected by new entries\nfunc (e *Engine) invalidateHistoricalCache(ctx context.Context, entryDate time.Time, accountIDs []string) error {\n    // TODO 1: Query L3 historical cache for snapshots with AsOfDate >= entryDate\n    // TODO 2: Filter results to only include snapshots for accounts in accountIDs\n    // TODO 3: Mark affected snapshots as invalid or delete them from cache\n    // TODO 4: Update cache statistics and log invalidation metrics\n    // Hint: Consider using database triggers for automatic cache invalidation\n    // Hint: Batch invalidation operations for better performance during high-volume periods\n}\n\n// refreshMemoryCache updates L1 cache with current database values  \nfunc (e *Engine) refreshMemoryCache(ctx context.Context, accountIDs []string) error {\n    // TODO 1: Query running_balances table for specified accounts\n    // TODO 2: Update memory cache entries with fresh database values\n    // TODO 3: Remove any cache entries for accounts that no longer exist\n    // TODO 4: Apply LRU eviction if cache size exceeds limits\n    // TODO 5: Update cache hit/miss statistics for monitoring\n    // Hint: Use bulk database queries instead of individual account lookups\n    // Hint: Implement cache warming strategies for frequently accessed accounts\n}\n```\n\n**Milestone Verification Checkpoints**\n\nAfter implementing the balance calculation engine, verify correct behavior with these checkpoints:\n\n1. **Running Balance Accuracy**: Post several journal entries and verify that running balances in the database match manual calculations from journal entry lines\n   - Expected: `SELECT SUM(debit_amount - credit_amount) FROM entry_lines WHERE account_id = 'xxx'` equals running balance\n   - Test command: `go test -run TestRunningBalanceAccuracy`\n\n2. **Point-in-Time Calculations**: Create transactions across multiple dates and verify historical balance queries\n   - Expected: Balance as of mid-month should exclude transactions posted after that date\n   - Test command: `go test -run TestPointInTimeBalances`\n\n3. **Trial Balance Validation**: Post balanced journal entries and verify trial balance sums to zero\n   - Expected: Total debits exactly equal total credits in trial balance report\n   - Test command: `go test -run TestTrialBalanceValidation`\n\n4. **Cache Consistency**: Update balances and verify all cache levels reflect changes\n   - Expected: Memory cache, database cache, and fresh queries all return identical values\n   - Test command: `go test -run TestCacheConsistency`\n\n5. **Concurrent Update Handling**: Run multiple journal entry postings simultaneously\n   - Expected: All entries post successfully without lost balance updates or deadlocks\n   - Test command: `go test -run TestConcurrentBalanceUpdates`\n\n**Performance Benchmarking**\n\n```bash\n# Benchmark current balance queries\ngo test -bench=BenchmarkCurrentBalance -benchmem\n\n# Benchmark point-in-time calculations  \ngo test -bench=BenchmarkPointInTime -benchmem\n\n# Benchmark trial balance generation\ngo test -bench=BenchmarkTrialBalance -benchmem\n```\n\nExpected performance targets:\n- Current balance queries: < 1ms for cached accounts, < 10ms for uncached\n- Point-in-time queries: < 50ms for recent dates, < 500ms for historical dates  \n- Trial balance generation: < 2 seconds for 10,000 accounts\n- Cache hit rate: > 80% for current balances, > 60% for historical queries\n\n\n> **Milestone(s):** 4 (Audit Trail), as this section implements immutable change logging with cryptographic integrity verification that ensures complete transaction traceability for regulatory compliance\n\n## Audit Trail System\n\n![Audit Trail Data Structure](./diagrams/audit-trail-structure.svg)\n\nThink of an audit trail like a blockchain ledger for your accounting system — every transaction and modification creates an immutable record that's cryptographically linked to previous records, making it impossible to alter history without detection. Just as a bank vault has multiple locks and cameras recording every entry, an accounting audit trail provides multiple layers of protection to ensure financial data integrity and regulatory compliance.\n\nThe audit trail system serves as the guardian of data integrity for the entire double-entry ledger. While the transaction recording engine ensures that journal entries are properly balanced and posted atomically, the audit trail system ensures that once posted, these entries become part of an immutable historical record that can never be altered or deleted. This immutability is not just a design preference — it's a legal requirement in most jurisdictions for financial record keeping.\n\n### Immutable Entry Storage\n\n**Immutable entry storage** forms the foundation of audit trail integrity by implementing an append-only ledger design that prevents modification or deletion of posted transactions. Think of this like writing in ink rather than pencil — once a transaction is committed to the ledger, it becomes a permanent part of the historical record that can only be corrected through new offsetting entries.\n\nThe core principle behind immutable storage is that **posted journal entries transition to a read-only state** where the database system physically prevents UPDATE and DELETE operations. This is not merely a business rule enforced by application code — it's implemented through database constraints, triggers, and permissions that make modification technically impossible even for system administrators.\n\n> **Decision: Append-Only Transaction Storage**\n> - **Context**: Need to maintain regulatory compliance while allowing corrections to accounting errors\n> - **Options Considered**: \n>   - Mutable entries with change tracking\n>   - Append-only with reversal entries\n>   - Hybrid approach with archive tables\n> - **Decision**: Pure append-only storage with reversal entry mechanism\n> - **Rationale**: Regulatory requirements mandate that original entries remain unchanged; corrections must be visible as separate transactions showing the complete audit trail of what happened and when\n> - **Consequences**: Requires reversal entry workflow for corrections; increases storage requirements; provides strongest audit guarantees\n\nThe immutable storage system distinguishes between **draft entries** that can still be modified and **posted entries** that become immutable. This state transition is irreversible — once an entry moves from `DRAFT` to `POSTED` status, it enters the immutable portion of the ledger.\n\n| Storage State | Allowed Operations | Data Location | Protection Level |\n|---------------|-------------------|---------------|------------------|\n| Draft | CREATE, UPDATE, DELETE | Staging tables | Application-level validation |\n| Posted | READ only | Main ledger | Database constraints + triggers |\n| Archived | READ only | Archive partition | Immutable storage backend |\n| Purged | None | Compliance archive | External audit system |\n\nThe system implements **database-level immutability controls** to prevent accidental or malicious modification of posted entries:\n\n1. **Row-level security policies** that deny UPDATE and DELETE permissions on posted entries\n2. **Database triggers** that reject any attempt to modify posted records and log the attempt as a security event\n3. **Column-level constraints** that prevent status changes from POSTED back to DRAFT\n4. **Audit table partitioning** that physically separates posted entries into read-only table partitions\n5. **Backup verification** that regularly checksums posted entries to detect any unauthorized changes\n\n**Entry reversal workflow** provides the mechanism for correcting posted transactions without violating immutability:\n\n1. The original incorrect entry remains in the ledger with `POSTED` status, unchanged\n2. A reversal entry is created that exactly offsets the original entry with opposite debit/credit amounts\n3. A new correct entry is posted with the intended transaction details\n4. All three entries are linked through a correction reference ID for audit trail continuity\n5. Account balances reflect the net effect while preserving the complete correction history\n\n| Correction Component | Entry Type | Status | Purpose |\n|---------------------|-----------|---------|---------|\n| Original Entry | Normal | POSTED | Shows what was originally recorded (remains unchanged) |\n| Reversal Entry | Reversal | POSTED | Cancels out the original entry amounts |\n| Corrected Entry | Normal | POSTED | Records the intended correct transaction |\n| Correction Link | Metadata | - | Ties all three entries together for audit reporting |\n\n> The reversal entry mechanism preserves the complete story of what happened — auditors can see the original mistake, the correction process, and the final result, along with who made each change and when.\n\n**Write-once storage guarantees** are implemented through a combination of database features and application-level controls:\n\n- **Immutable table partitions** where posted entries are moved to append-only partitions\n- **Content hash verification** where each entry's hash is calculated and stored, with periodic integrity checks\n- **Temporal consistency checks** that verify posting dates follow chronological order within each accounting period\n- **Cross-reference validation** that ensures all referenced accounts and parent entries still exist and haven't been modified\n\n⚠️ **Pitfall: Allowing Status Rollbacks**\nMany implementations mistakenly allow entries to transition from POSTED back to DRAFT for \"quick fixes.\" This breaks audit trail integrity because it allows modification of what should be immutable records. Instead, implement a strict state machine where POSTED entries can only transition to REVERSED through the reversal entry workflow.\n\n⚠️ **Pitfall: Application-Only Immutability**\nRelying solely on application code to prevent modifications leaves the system vulnerable to direct database access, SQL injection, or administrative errors. Database-level constraints, triggers, and permissions provide defense-in-depth protection that works even if application controls are bypassed.\n\n### Change History Tracking\n\n**Change history tracking** creates a complete audit log that captures who made what changes when, including before/after values of all modified fields. Think of this as a time-lapse video of your database — every frame shows exactly what changed, who changed it, and when the change occurred.\n\nThe change tracking system operates at multiple levels to capture different types of modifications:\n\n| Tracking Level | What's Captured | Storage Location | Retention Period |\n|---------------|-----------------|------------------|------------------|\n| Field-Level | Individual column changes with before/after values | `audit_field_changes` table | 7 years (regulatory) |\n| Row-Level | Complete record snapshots at modification time | `audit_row_history` table | 7 years (regulatory) |\n| Transaction-Level | Groups of changes within database transactions | `audit_transactions` table | 7 years (regulatory) |\n| Session-Level | User sessions and authentication context | `audit_sessions` table | 3 years (security) |\n| System-Level | Application events and administrative actions | `audit_system_events` table | 10 years (compliance) |\n\n**Audit event structure** standardizes how all changes are recorded regardless of the source system or type of modification:\n\n| Field Name | Type | Description |\n|-----------|------|-------------|\n| EventID | string | Unique identifier for this audit event |\n| EventType | string | Type of change: CREATE, UPDATE, DELETE, STATE_TRANSITION |\n| TableName | string | Database table that was modified |\n| RecordID | string | Primary key of the modified record |\n| FieldName | string | Name of the changed field (null for row-level events) |\n| OldValue | string | Previous value before change (JSON-encoded) |\n| NewValue | string | New value after change (JSON-encoded) |\n| UserID | string | ID of user who made the change |\n| SessionID | string | Session identifier for grouping related changes |\n| IPAddress | string | Source IP address of the change request |\n| UserAgent | string | Client application information |\n| Timestamp | time.Time | Exact time when change occurred (UTC) |\n| TransactionID | string | Database transaction that contained this change |\n| ChangeReason | string | Business reason for the change (from user input) |\n| ApprovalID | *string | Reference to approval workflow if required |\n| ParentEventID | *string | Links related events in complex operations |\n\n**Automatic change detection** captures modifications through database triggers that fire on every INSERT, UPDATE, and DELETE operation:\n\n1. **BEFORE triggers** capture the old values of all fields before modification occurs\n2. **AFTER triggers** capture the new values and compute the actual field-level differences\n3. **Row comparison logic** identifies which specific fields changed and generates field-level audit events\n4. **Session context capture** retrieves user information from database session variables\n5. **Transaction grouping** links all changes within a single database transaction\n\nThe system implements **comprehensive change tracking** that goes beyond simple field modifications:\n\n- **State transition tracking** for journal entry status changes from DRAFT to POSTED to REVERSED\n- **Relationship changes** when account hierarchy modifications affect parent-child relationships  \n- **Privilege escalation tracking** when users perform actions requiring elevated permissions\n- **Bulk operation tracking** for mass updates like period closing or account reclassification\n- **System configuration changes** to audit trail settings, security policies, or retention rules\n\n> **Decision: Trigger-Based vs Application-Based Change Tracking**\n> - **Context**: Need to capture all data changes regardless of how they occur (API, direct SQL, administrative tools)\n> - **Options Considered**:\n>   - Application-level logging in business logic\n>   - Database triggers on all audited tables\n>   - Change data capture (CDC) technology\n> - **Decision**: Database triggers with application context enrichment\n> - **Rationale**: Triggers capture changes from any source including direct database access; application layer adds business context like user identity and change reason\n> - **Consequences**: Requires trigger maintenance as schema evolves; provides complete coverage; adds slight performance overhead to all modifications\n\n**User activity correlation** links database changes back to specific user actions and business processes:\n\n| Activity Type | Context Captured | Correlation Method |\n|---------------|------------------|-------------------|\n| API Requests | HTTP headers, request body, authentication token | Session ID linkage |\n| Batch Jobs | Job ID, schedule trigger, system account | Process ID tracking |\n| Manual Corrections | User login, IP address, stated reason for change | User session correlation |\n| System Processes | Process name, scheduled task, automation trigger | System event logging |\n| Data Imports | File name, upload timestamp, validation results | Import batch ID tracking |\n\n**Change aggregation and reporting** provides meaningful views of the raw audit data for compliance and investigation purposes:\n\n1. **User activity summaries** showing all actions by a specific user within a date range\n2. **Record modification histories** displaying the complete lifecycle of a journal entry or account\n3. **Privilege usage reports** identifying when users exercised administrative or override privileges\n4. **Bulk change analysis** detecting unusual patterns that might indicate errors or fraud\n5. **Compliance attestation reports** providing auditor-friendly summaries for regulatory examinations\n\n⚠️ **Pitfall: Missing Business Context**\nTechnical audit logs often capture what changed but not why it changed. Always collect business context like the reason for a correction, the approval workflow used, or the original source document that triggered the change. This context is crucial for audit investigations.\n\n⚠️ **Pitfall: Performance Impact Ignorance**\nChange tracking adds overhead to every database operation. Monitor the performance impact and consider asynchronous audit logging for high-volume operations. However, never sacrifice audit completeness for performance — regulatory compliance is non-negotiable.\n\n### Cryptographic Integrity\n\n**Cryptographic integrity** provides tamper detection capabilities that can identify unauthorized modifications to historical records, even by privileged users with direct database access. Think of this like a wax seal on an envelope — any attempt to open and reseal it leaves evidence of tampering that can be detected by examining the seal.\n\nThe cryptographic integrity system implements a **hash chain architecture** where each journal entry includes a cryptographic hash that depends on both its own content and the hash of the previous entry. This creates a chain where altering any historical entry would require recalculating all subsequent hashes, making tampering computationally infeasible and easily detectable.\n\n| Hash Chain Component | Purpose | Algorithm | Storage |\n|---------------------|---------|-----------|---------|\n| Content Hash | Verifies entry content hasn't changed | SHA-256 | `content_hash` field |\n| Chain Hash | Links to previous entry in sequence | SHA-256(content + prev_hash) | `chain_hash` field |\n| Merkle Root | Aggregates multiple entries for efficiency | SHA-256 tree | `audit_merkle_roots` table |\n| Digital Signature | Proves hash was created by trusted system | RSA-2048 or ECDSA | `hash_signatures` table |\n\n**Hash calculation process** creates deterministic digests that will always produce the same hash for identical content:\n\n1. **Content normalization** converts the journal entry to a canonical JSON representation with sorted field order\n2. **Field selection** includes only immutable fields in the hash calculation (excludes timestamps like `last_accessed`)\n3. **Recursive hashing** for entry lines ensures that line order doesn't affect the hash\n4. **Chain linking** incorporates the previous entry's chain hash to create the forward-linked sequence\n5. **Digital signing** uses a system private key to sign the calculated hash, proving authenticity\n\n| Journal Entry Field | Included in Hash | Reason |\n|-------------------|------------------|---------|\n| ID | Yes | Core identifier |\n| Date | Yes | Transaction date |\n| Description | Yes | Business purpose |\n| Reference | Yes | Source document |\n| Status | Yes | Current state |\n| CreatedBy | Yes | Original author |\n| PostedAt | Yes | Official posting time |\n| Lines[] | Yes | All debit/credit details |\n| CreatedAt | No | System timestamp (can vary) |\n| LastModified | No | Changes with every access |\n| AccessCount | No | Not part of business data |\n\n**Hash chain verification** provides multiple levels of integrity checking:\n\n- **Individual entry verification** recalculates each entry's content hash and compares to stored value\n- **Chain sequence verification** validates that each entry's chain hash correctly incorporates the previous entry\n- **Merkle tree verification** efficiently checks large ranges of entries using hierarchical hashes\n- **Digital signature verification** confirms that hashes were created by the authorized system\n- **Temporal consistency verification** ensures that chain sequence matches chronological posting order\n\n> **Decision: SHA-256 vs Stronger Hashing Algorithms**\n> - **Context**: Need cryptographic hashes that will remain secure for regulatory retention periods (7+ years)\n> - **Options Considered**:\n>   - SHA-256 (current industry standard)\n>   - SHA-3 (newer standard with different construction)\n>   - Blake3 (faster modern alternative)\n> - **Decision**: SHA-256 with algorithm agility for future upgrades\n> - **Rationale**: SHA-256 is widely supported, regulatory-approved, and has no known practical attacks; algorithm agility allows migration if weaknesses are discovered\n> - **Consequences**: Standard libraries available; may need future migration; good performance characteristics\n\n**Integrity verification workflow** runs both on-demand and scheduled checks:\n\n1. **Real-time verification** during entry posting validates that the new entry correctly chains to the previous entry\n2. **Periodic full verification** runs nightly to check the complete hash chain from genesis to current\n3. **Spot verification** randomly samples entries throughout the day to detect corruption quickly\n4. **Cross-replica verification** compares hash chains across database replicas to detect inconsistencies\n5. **Audit-triggered verification** performs comprehensive checks when preparing for regulatory examinations\n\nThe system maintains **hash verification logs** that record all integrity checks and their results:\n\n| Verification Type | Frequency | Scope | Alert Threshold |\n|------------------|-----------|-------|-----------------|\n| Real-time | Every posting | Single entry | Immediate failure alert |\n| Incremental | Hourly | Recent entries | 1 failure per hour |\n| Full Chain | Daily | Complete ledger | Any chain break |\n| Random Sampling | Continuous | 1% of entries | 3 failures per day |\n| Scheduled Full | Weekly | Complete + archives | Any inconsistency |\n\n**Tamper detection and response** provides immediate alerting when integrity violations are discovered:\n\n- **Automatic alerting** sends immediate notifications to security teams when hash mismatches are detected\n- **Incident logging** creates detailed records of integrity violations for forensic investigation\n- **System lockdown** can automatically disable write operations if widespread tampering is detected\n- **Backup verification** cross-checks against known-good backup copies to determine the scope of tampering\n- **Recovery procedures** provide step-by-step processes for restoring from verified backups\n\n> The cryptographic integrity system provides mathematical proof of data authenticity. While access controls and permissions can be bypassed, cryptographic hashes cannot be forged without detection.\n\n⚠️ **Pitfall: Hash Algorithm Rigidity**\nHard-coding hash algorithms makes future security upgrades difficult. Implement algorithm agility by storing the algorithm identifier with each hash, allowing gradual migration to stronger algorithms as they become available.\n\n⚠️ **Pitfall: Key Management Neglect**\nDigital signatures are only as secure as the private keys used to create them. Implement proper key rotation, secure key storage (HSMs for production), and key escrow procedures for long-term signature verification.\n\n### Audit Report Generation\n\n**Audit report generation** transforms the raw audit trail data into compliance-ready reports that regulators and external auditors can review to verify the integrity and completeness of financial records. Think of this as creating a readable story from the detailed forensic evidence — the raw audit logs contain every detail, but reports present the information in formats that humans can efficiently review and understand.\n\nThe reporting system must address multiple regulatory frameworks that each have specific requirements for audit trail documentation:\n\n| Regulatory Framework | Required Reports | Retention Period | Format Requirements |\n|---------------------|------------------|------------------|-------------------|\n| SOX (Sarbanes-Oxley) | All journal entry changes, user access logs | 7 years | PDF with digital signatures |\n| GAAP | Account balance histories, trial balance trails | 7 years | Standard accounting formats |\n| Basel III | Risk-related transaction trails, system controls | 7 years | XML or structured data |\n| IFRS | Fair value adjustments, estimate changes | 5 years | Human-readable with supporting docs |\n| PCI DSS | Payment-related transactions, security events | 1 year | Encrypted storage required |\n\n**Standard audit report types** provide comprehensive coverage of different audit trail aspects:\n\n- **Complete Transaction History** shows all journal entries for a specific date range with full audit metadata\n- **Account Modification Trail** displays all changes to account master data including hierarchy adjustments\n- **User Activity Summary** lists all actions performed by specific users with timestamps and business context  \n- **Exception Reports** highlight unusual patterns like after-hours modifications or privilege escalations\n- **Integrity Verification Status** shows results of cryptographic verification checks and any detected issues\n- **Period Closing Audit Trail** documents all entries and approvals during the period-end closing process\n\n**Audit report data structure** standardizes how information is presented across all report types:\n\n| Report Section | Content | Source Data | Formatting |\n|---------------|---------|-------------|------------|\n| Header | Report type, date range, generation timestamp | Report parameters | Fixed format with metadata |\n| Summary | High-level statistics, exception counts | Aggregated audit data | Executive summary table |\n| Detail Records | Individual transactions or changes | Raw audit logs | Chronological with drill-down |\n| Verification | Integrity check results, hash validations | Cryptographic verification | Pass/fail with details |\n| Signatures | Digital signatures, approval chains | Workflow systems | Certification format |\n| Appendices | Supporting documentation, methodology | Various sources | Referenced attachments |\n\n**Report generation workflow** ensures that audit reports accurately reflect the complete audit trail:\n\n1. **Data extraction** queries audit tables with appropriate date ranges and filtering criteria\n2. **Cross-reference validation** verifies that all referenced entities (accounts, users, approvals) still exist\n3. **Integrity verification** runs hash chain checks on all entries included in the report\n4. **Data correlation** links related audit events across multiple tables to show complete transaction stories\n5. **Format transformation** converts raw audit data into human-readable report formats\n6. **Digital signing** applies cryptographic signatures to ensure report integrity after generation\n7. **Archive storage** saves completed reports in immutable storage for regulatory retention\n\n> **Decision: Real-time vs Batch Report Generation**\n> - **Context**: Need to provide audit reports quickly for regulatory requests while maintaining system performance\n> - **Options Considered**:\n>   - Real-time generation from live audit tables\n>   - Pre-computed batch reports with periodic updates\n>   - Hybrid approach with cached summaries and detailed drill-down\n> - **Decision**: Hybrid approach with daily batch processing and real-time detail queries\n> - **Rationale**: Regulatory requests often require specific date ranges; pre-computing all possible reports is impractical; cached summaries provide fast response with detailed drill-down capability\n> - **Consequences**: Requires cache invalidation strategy; some reports may have slight delays; optimizes for common audit patterns\n\n**Report customization capabilities** allow adaptation to different regulatory requirements and audit scenarios:\n\n| Customization Type | Options Available | Configuration Method |\n|-------------------|------------------|---------------------|\n| Date Range | Custom ranges, predefined periods, rolling windows | Report parameters |\n| Scope Filtering | Specific accounts, users, transaction types | Filter criteria |\n| Detail Level | Summary only, full detail, exception focus | Report template |\n| Output Format | PDF, CSV, JSON, XML | Format specification |\n| Grouping | By user, by account, by time period | Aggregation rules |\n| Sorting | Chronological, by amount, by risk level | Sort parameters |\n\n**Audit report quality controls** ensure that generated reports accurately represent the underlying audit data:\n\n- **Completeness verification** confirms that all audit events within the requested scope are included\n- **Consistency checks** validate that report totals match underlying database aggregations  \n- **Cross-period validation** ensures that reports spanning multiple periods properly handle period boundaries\n- **User permission verification** confirms that report requestors have appropriate access to included data\n- **Data masking controls** automatically redact sensitive information based on user clearance levels\n\n**Report delivery and distribution** provides secure mechanisms for sharing audit reports with authorized parties:\n\n1. **Secure download portals** with authentication and access logging\n2. **Automated email delivery** with encrypted attachments for scheduled reports\n3. **API access** for external audit tools that need programmatic access to audit data\n4. **Physical delivery** for highly sensitive reports requiring offline distribution\n5. **Escrow services** for long-term storage with third-party verification capabilities\n\n| Distribution Method | Security Level | Use Case | Audit Trail |\n|--------------------|---------------|----------|-------------|\n| Secure Portal | High | Internal audit reviews | Download tracking |\n| Encrypted Email | Medium | External auditor delivery | Delivery confirmation |\n| API Integration | High | Automated compliance tools | API access logs |\n| Physical Media | Highest | Regulatory submissions | Chain of custody |\n| Third-party Escrow | Highest | Long-term compliance | Independent verification |\n\n**Performance optimization** ensures that audit report generation doesn't impact operational system performance:\n\n- **Read replica queries** isolate report generation from operational database load\n- **Incremental processing** builds complex reports from cached intermediate results\n- **Parallel processing** generates different report sections concurrently for faster completion\n- **Result caching** stores frequently-requested reports for immediate delivery\n- **Resource throttling** limits report generation resource usage during peak business hours\n\n⚠️ **Pitfall: Report Data Inconsistency**\nGenerating reports from live operational databases can produce inconsistent results if transactions are occurring during report generation. Use database snapshots or read-consistent isolation levels to ensure report data represents a single point-in-time view.\n\n⚠️ **Pitfall: Inadequate Report Retention**\nAudit reports themselves become part of the regulatory record and must be retained according to the same requirements as the underlying data. Implement proper retention policies and don't assume that the ability to regenerate reports satisfies regulatory requirements.\n\n> The audit trail system provides the foundation for regulatory compliance by ensuring that every financial transaction and modification is captured, protected, and available for examination. This system must operate with the highest reliability since audit trail gaps or corruption can result in regulatory violations and legal penalties.\n\n### Implementation Guidance\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Immutable Storage | PostgreSQL with triggers and constraints | Dedicated immutable database (FoundationDB) |\n| Cryptographic Hashing | Standard library SHA-256 | Hardware security module (HSM) |\n| Audit Log Storage | Same database with separate schema | Time-series database (InfluxDB) |\n| Report Generation | Template-based with Go templates | Dedicated reporting engine (Jasper) |\n| Digital Signatures | Software-based signing with stored keys | Hardware security module with key rotation |\n\n**Recommended File/Module Structure:**\n```\nproject-root/\n  internal/audit/\n    storage.go              ← immutable storage implementation\n    storage_test.go         ← storage tests\n    tracker.go              ← change history tracking\n    tracker_test.go         ← tracking tests\n    integrity.go            ← cryptographic verification\n    integrity_test.go       ← integrity tests\n    reports.go              ← audit report generation\n    reports_test.go         ← report tests\n    types.go                ← audit trail data structures\n  pkg/crypto/\n    hasher.go               ← hash calculation utilities\n    signer.go               ← digital signature functions\n  migrations/\n    008_audit_tables.sql    ← audit trail database schema\n    009_audit_triggers.sql  ← change tracking triggers\n```\n\n**A. Complete Audit Trail Infrastructure Code:**\n\n```go\n// internal/audit/types.go\npackage audit\n\nimport (\n    \"time\"\n    \"github.com/shopspring/decimal\"\n)\n\ntype AuditEvent struct {\n    EventID       string    `db:\"event_id\" json:\"event_id\"`\n    EventType     string    `db:\"event_type\" json:\"event_type\"`\n    TableName     string    `db:\"table_name\" json:\"table_name\"`\n    RecordID      string    `db:\"record_id\" json:\"record_id\"`\n    FieldName     *string   `db:\"field_name\" json:\"field_name\"`\n    OldValue      *string   `db:\"old_value\" json:\"old_value\"`\n    NewValue      *string   `db:\"new_value\" json:\"new_value\"`\n    UserID        string    `db:\"user_id\" json:\"user_id\"`\n    SessionID     string    `db:\"session_id\" json:\"session_id\"`\n    IPAddress     string    `db:\"ip_address\" json:\"ip_address\"`\n    UserAgent     string    `db:\"user_agent\" json:\"user_agent\"`\n    Timestamp     time.Time `db:\"timestamp\" json:\"timestamp\"`\n    TransactionID string    `db:\"transaction_id\" json:\"transaction_id\"`\n    ChangeReason  string    `db:\"change_reason\" json:\"change_reason\"`\n    ApprovalID    *string   `db:\"approval_id\" json:\"approval_id\"`\n    ParentEventID *string   `db:\"parent_event_id\" json:\"parent_event_id\"`\n}\n\ntype IntegrityRecord struct {\n    EntryID      string    `db:\"entry_id\" json:\"entry_id\"`\n    ContentHash  string    `db:\"content_hash\" json:\"content_hash\"`\n    ChainHash    string    `db:\"chain_hash\" json:\"chain_hash\"`\n    PrevHash     *string   `db:\"prev_hash\" json:\"prev_hash\"`\n    HashAlgorithm string   `db:\"hash_algorithm\" json:\"hash_algorithm\"`\n    DigitalSignature string `db:\"digital_signature\" json:\"digital_signature\"`\n    SignedAt     time.Time `db:\"signed_at\" json:\"signed_at\"`\n    VerifiedAt   *time.Time `db:\"verified_at\" json:\"verified_at\"`\n    IsValid      bool      `db:\"is_valid\" json:\"is_valid\"`\n}\n\ntype AuditReport struct {\n    ReportID     string                 `json:\"report_id\"`\n    ReportType   string                 `json:\"report_type\"`\n    DateFrom     time.Time              `json:\"date_from\"`\n    DateTo       time.Time              `json:\"date_to\"`\n    GeneratedAt  time.Time              `json:\"generated_at\"`\n    GeneratedBy  string                 `json:\"generated_by\"`\n    TotalEvents  int                    `json:\"total_events\"`\n    Summary      map[string]interface{} `json:\"summary\"`\n    Events       []AuditEvent           `json:\"events\"`\n    Integrity    []IntegrityRecord      `json:\"integrity\"`\n    Signatures   []string               `json:\"signatures\"`\n}\n\n// Storage configuration for audit system\ntype AuditConfig struct {\n    DatabaseURL          string        `json:\"database_url\"`\n    RetentionPeriod      time.Duration `json:\"retention_period\"`\n    VerificationInterval time.Duration `json:\"verification_interval\"`\n    HashAlgorithm        string        `json:\"hash_algorithm\"`\n    SigningKeyPath       string        `json:\"signing_key_path\"`\n    ReportOutputDir      string        `json:\"report_output_dir\"`\n    EnableRealTimeVerify bool          `json:\"enable_realtime_verify\"`\n}\n```\n\n**B. Core Audit Storage Skeleton:**\n\n```go\n// internal/audit/storage.go\npackage audit\n\nimport (\n    \"context\"\n    \"database/sql\"\n    \"time\"\n    \"github.com/google/uuid\"\n)\n\n// AuditStorage provides immutable storage operations for audit trail\ntype AuditStorage interface {\n    RecordEvent(ctx context.Context, event *AuditEvent) error\n    GetEventHistory(ctx context.Context, recordID string) ([]AuditEvent, error)\n    GetEventsInRange(ctx context.Context, from, to time.Time, filters map[string]interface{}) ([]AuditEvent, error)\n    VerifyIntegrity(ctx context.Context, entryID string) (*IntegrityRecord, error)\n}\n\ntype Storage struct {\n    db *sql.DB\n    config AuditConfig\n}\n\nfunc NewStorage(db *sql.DB, config AuditConfig) *Storage {\n    return &Storage{\n        db: db,\n        config: config,\n    }\n}\n\n// RecordEvent creates an immutable audit record for a data change\nfunc (s *Storage) RecordEvent(ctx context.Context, event *AuditEvent) error {\n    // TODO 1: Generate unique event ID using UUID\n    // TODO 2: Set timestamp to current UTC time\n    // TODO 3: Validate required fields are present (EventType, TableName, RecordID, UserID)\n    // TODO 4: Insert into audit_events table with conflict detection\n    // TODO 5: If this is a journal entry posting, create integrity record\n    // TODO 6: Update audit statistics for monitoring\n    // Hint: Use prepared statements to prevent SQL injection\n    return nil\n}\n\n// GetEventHistory retrieves complete change history for a specific record\nfunc (s *Storage) GetEventHistory(ctx context.Context, recordID string) ([]AuditEvent, error) {\n    // TODO 1: Query audit_events table filtering by record_id\n    // TODO 2: Order results chronologically by timestamp\n    // TODO 3: Include related events using parent_event_id links\n    // TODO 4: Load associated approval records if approval_id is set\n    // TODO 5: Return empty slice if no events found (not an error)\n    return nil, nil\n}\n\n// VerifyIntegrity checks cryptographic hash chain for an entry\nfunc (s *Storage) VerifyIntegrity(ctx context.Context, entryID string) (*IntegrityRecord, error) {\n    // TODO 1: Load integrity record for the specified entry\n    // TODO 2: Recalculate content hash from journal entry data\n    // TODO 3: Verify chain hash matches previous entry's chain hash\n    // TODO 4: Validate digital signature using public key\n    // TODO 5: Update verification timestamp and status\n    // TODO 6: Return detailed verification results\n    return nil, nil\n}\n\n// createIntegrityRecord generates cryptographic proof for a journal entry\nfunc (s *Storage) createIntegrityRecord(ctx context.Context, entryID string) error {\n    // TODO 1: Load complete journal entry with all line items\n    // TODO 2: Generate canonical JSON representation for hashing\n    // TODO 3: Calculate content hash using configured algorithm (SHA-256)\n    // TODO 4: Retrieve previous entry's chain hash for linking\n    // TODO 5: Calculate new chain hash incorporating previous hash\n    // TODO 6: Create digital signature of the chain hash\n    // TODO 7: Store integrity record with all hash values\n    return nil\n}\n```\n\n**C. Change Tracking Implementation:**\n\n```go\n// internal/audit/tracker.go\npackage audit\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"fmt\"\n    \"reflect\"\n)\n\n// ChangeTracker captures data modifications and creates audit events\ntype ChangeTracker struct {\n    storage AuditStorage\n    contextProvider func(ctx context.Context) (UserContext, error)\n}\n\ntype UserContext struct {\n    UserID    string\n    SessionID string\n    IPAddress string\n    UserAgent string\n    Reason    string\n}\n\nfunc NewChangeTracker(storage AuditStorage) *ChangeTracker {\n    return &ChangeTracker{\n        storage: storage,\n    }\n}\n\n// TrackChanges compares before/after values and creates audit events\nfunc (t *ChangeTracker) TrackChanges(ctx context.Context, tableName, recordID string, before, after interface{}) error {\n    // TODO 1: Get user context from session or request headers\n    // TODO 2: Use reflection to compare before/after struct fields\n    // TODO 3: Create audit event for each changed field with old/new values\n    // TODO 4: Handle nested structs and slices appropriately\n    // TODO 5: Batch multiple field changes into single transaction\n    // TODO 6: Generate parent event ID linking all related changes\n    return nil\n}\n\n// TrackStateTransition records status changes like DRAFT -> POSTED\nfunc (t *ChangeTracker) TrackStateTransition(ctx context.Context, recordID, fromState, toState, reason string) error {\n    // TODO 1: Create special audit event type for state transitions\n    // TODO 2: Include business reason for the state change\n    // TODO 3: Validate that state transition is allowed by business rules\n    // TODO 4: Link to any required approval workflows\n    return nil\n}\n\n// compareStructFields uses reflection to find differences between two structs\nfunc compareStructFields(before, after interface{}) []FieldChange {\n    // TODO 1: Use reflection to get struct field values\n    // TODO 2: Compare each field recursively for nested structures  \n    // TODO 3: Convert values to JSON for storage in audit log\n    // TODO 4: Skip fields marked with audit:\"-\" struct tags\n    // TODO 5: Return list of FieldChange structs with old/new values\n    return nil\n}\n\ntype FieldChange struct {\n    FieldName string\n    OldValue  string\n    NewValue  string\n    FieldType string\n}\n```\n\n**D. Report Generation Skeleton:**\n\n```go\n// internal/audit/reports.go\npackage audit\n\nimport (\n    \"context\"\n    \"time\"\n    \"html/template\"\n    \"bytes\"\n)\n\n// ReportGenerator creates compliance reports from audit trail data\ntype ReportGenerator struct {\n    storage AuditStorage\n    templates map[string]*template.Template\n    outputDir string\n}\n\nfunc NewReportGenerator(storage AuditStorage, outputDir string) *ReportGenerator {\n    return &ReportGenerator{\n        storage: storage,\n        templates: make(map[string]*template.Template),\n        outputDir: outputDir,\n    }\n}\n\n// GenerateTransactionHistory creates complete audit trail for date range\nfunc (r *ReportGenerator) GenerateTransactionHistory(ctx context.Context, from, to time.Time, format string) (*AuditReport, error) {\n    // TODO 1: Query all audit events within date range\n    // TODO 2: Group events by transaction ID and record ID\n    // TODO 3: Calculate summary statistics (total events, users, etc.)\n    // TODO 4: Run integrity verification on included entries\n    // TODO 5: Format output according to specified format (PDF, CSV, JSON)\n    // TODO 6: Apply digital signature to completed report\n    // TODO 7: Store report file in configured output directory\n    return nil, nil\n}\n\n// GenerateUserActivityReport shows all actions by specific users\nfunc (r *ReportGenerator) GenerateUserActivityReport(ctx context.Context, userIDs []string, from, to time.Time) (*AuditReport, error) {\n    // TODO 1: Filter events by user ID list and date range\n    // TODO 2: Group by user and then by session for logical grouping\n    // TODO 3: Include privilege escalation and approval events\n    // TODO 4: Highlight any security-relevant events (after hours, bulk changes)\n    // TODO 5: Cross-reference with authentication logs for session validation\n    return nil, nil\n}\n\n// GenerateIntegrityVerificationReport shows hash chain status\nfunc (r *ReportGenerator) GenerateIntegrityVerificationReport(ctx context.Context) (*AuditReport, error) {\n    // TODO 1: Run full integrity verification on all posted entries\n    // TODO 2: Identify any hash chain breaks or signature failures\n    // TODO 3: Generate summary of verification coverage and results\n    // TODO 4: Include recommendations for any integrity issues found\n    // TODO 5: Format as compliance-ready report with executive summary\n    return nil, nil\n}\n\n// formatReport converts audit data to requested output format\nfunc (r *ReportGenerator) formatReport(report *AuditReport, format string) ([]byte, error) {\n    // TODO 1: Load appropriate template for the format type\n    // TODO 2: Execute template with report data as context\n    // TODO 3: For PDF format, convert HTML to PDF using library\n    // TODO 4: For CSV format, flatten nested data appropriately\n    // TODO 5: Include metadata headers and digital signatures\n    return nil, nil\n}\n```\n\n**E. Milestone Checkpoints:**\n\nAfter implementing immutable storage:\n- Run `go test ./internal/audit/...` - all storage tests should pass\n- Attempt to UPDATE a posted journal entry directly in database - should fail with permission error\n- Post a journal entry and verify it appears in audit_events table with correct metadata\n- Check that integrity_records table has corresponding hash entry\n\nAfter implementing change tracking:\n- Modify an account name through the API - verify field-level change appears in audit log\n- Change journal entry status from DRAFT to POSTED - verify state transition is tracked\n- Review audit_events table to confirm before/after values are captured correctly\n\nAfter implementing cryptographic integrity:\n- Verify hash chain by checking that each entry's chain_hash incorporates previous entry\n- Run integrity verification on sample entries - should return IsValid=true\n- Manually corrupt a hash value in database and verify corruption is detected\n\nAfter implementing audit reports:\n- Generate transaction history report for a date range - verify all entries included\n- Export report in PDF format - should be readable with proper formatting\n- Generate integrity verification report - should show all entries verified successfully\n\n\n> **Milestone(s):** 5 (Financial Reports), as this section implements the generation of standard financial statements including trial balance, balance sheet, and income statement that provide management insights into the organization's financial position\n\n## Financial Reporting Module\n\nThink of the financial reporting module as the dashboard of an airplane cockpit. While the ledger system records every transaction like a flight recorder, the reporting module transforms this raw data into meaningful instruments that help managers navigate their organization. Just as pilots need altitude, speed, and fuel gauges to make informed decisions, business managers need trial balance, balance sheet, and income statements to understand their financial position and performance.\n\nThe financial reporting module sits at the convergence of all other ledger components. It reads from the immutable audit trail to ensure data integrity, queries the balance calculation engine for current and historical balances, and applies accounting principles to transform raw transaction data into standardized financial statements that comply with regulatory requirements and business needs.\n\nThe core challenge in financial reporting is transforming the flat structure of journal entries into the hierarchical, categorized view that financial statements require. Every journal entry affects individual accounts, but financial reports aggregate these accounts by type, apply sign conventions, and present them in standardized formats that reveal the organization's financial story.\n\n### Trial Balance Report\n\nThe **trial balance report** serves as the foundation and validation checkpoint for all other financial reports. Think of it as a mathematician's proof that the double-entry system is working correctly—it lists every account with its debit and credit totals to verify that the fundamental accounting equation remains in balance.\n\nThe trial balance provides both a comprehensive account listing and a system integrity check. When total debits equal total credits, we have mathematical proof that every journal entry has been recorded correctly according to double-entry principles. When they don't match, we have identified a data integrity problem that must be resolved before generating other financial statements.\n\n> **Decision: Real-Time vs Snapshot Trial Balance Generation**\n> - **Context**: Trial balance reports can be generated on-demand from current data or from pre-calculated snapshots\n> - **Options Considered**: \n>   1. On-demand calculation from live ledger data\n>   2. Pre-calculated snapshots updated after each posting\n>   3. Hybrid approach with cached daily snapshots plus incremental updates\n> - **Decision**: On-demand calculation with aggressive caching for recently accessed date ranges\n> - **Rationale**: Provides real-time accuracy for current reporting while avoiding the complexity of maintaining snapshot consistency across concurrent transactions\n> - **Consequences**: Slight performance cost for first access to historical dates, but eliminates snapshot synchronization complexity and guarantees accuracy\n\n| Calculation Method | Accuracy | Performance | Complexity | Chosen? |\n|-------------------|----------|-------------|------------|---------|\n| On-demand calculation | Perfect | Slow for large ledgers | Low | ✓ |\n| Pre-calculated snapshots | Eventually consistent | Fast | High | ✗ |\n| Hybrid cached approach | Perfect with delay | Medium | Medium | Future enhancement |\n\nThe trial balance generation process follows a systematic approach to account aggregation and validation. The system queries all accounts with their current balances, applies proper sign conventions based on account type, and performs mathematical verification to ensure the books are in balance.\n\n**Trial Balance Generation Algorithm:**\n\n1. Query all active accounts from the chart of accounts, including their type and current balance information\n2. For each account, retrieve the current balance using the balance calculation engine's caching mechanisms\n3. Apply normal balance conventions—assets and expenses show debit balances, while liabilities, equity, and revenues show credit balances\n4. Calculate running totals for the debit and credit columns as accounts are processed\n5. Include accounts with zero balances to provide complete chart of accounts visibility\n6. Sort accounts by account code to provide consistent, logical ordering for review\n7. Calculate the variance between total debits and total credits to identify any imbalances\n8. Generate warning indicators for accounts with abnormal balances (credit balances for asset accounts, etc.)\n9. Include metadata such as the report generation timestamp and date range for audit purposes\n\nThe `TrialBalance` structure contains comprehensive information for both validation and presentation purposes:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| AsOfDate | time.Time | Date for which the trial balance is calculated |\n| AccountBalances | []AccountBalance | Array of all account balances with detailed information |\n| TotalDebits | Money | Sum of all debit balances across all accounts |\n| TotalCredits | Money | Sum of all credit balances across all accounts |\n| IsBalanced | bool | True when total debits equal total credits |\n| Variance | Money | Difference between debits and credits (should be zero) |\n| GeneratedAt | time.Time | Timestamp when the report was generated |\n\nThe `AccountBalance` structure provides detailed information for each account line in the trial balance:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| AccountID | string | Unique identifier for the account |\n| AccountCode | string | Human-readable account code for sorting and reference |\n| AccountName | string | Descriptive account name for presentation |\n| AccountType | AccountType | Account category (ASSET, LIABILITY, EQUITY, REVENUE, EXPENSE) |\n| Balance | Money | Net balance considering normal balance conventions |\n| DebitAmount | *Money | Balance shown in debit column (nil if credit balance) |\n| CreditAmount | *Money | Balance shown in credit column (nil if debit balance) |\n| LastEntryDate | time.Time | Date of most recent transaction affecting this account |\n\n**Point-in-Time Trial Balance Calculation:**\n\nWhen generating historical trial balances, the system must calculate balances as they existed at a specific date, considering only journal entries posted on or before that date. This requires coordination with the balance calculation engine's point-in-time query capabilities.\n\nThe historical trial balance process involves querying each account's balance as of the specified date, which may require summing journal entry lines from the beginning of the accounting period up to the target date. The balance calculation engine optimizes this through snapshot caching and incremental calculation techniques.\n\n> ⚠️ **Pitfall: Ignoring Account Type Sign Conventions**\n> \n> A common mistake is displaying raw balance amounts without applying proper sign conventions for the trial balance format. Asset and expense accounts should show positive balances in the debit column, while liability, equity, and revenue accounts should show positive balances in the credit column. Simply displaying the stored balance amount can result in confusing negative numbers or incorrect column placement.\n> \n> **Fix**: Apply the `NormalBalance()` method to determine which column should display the balance, and use the absolute value of the balance amount to avoid negative numbers in the trial balance presentation.\n\nThe trial balance serves as a critical validation checkpoint before generating other financial statements. Any variance in the trial balance indicates a fundamental problem with the ledger data that must be resolved before proceeding with balance sheet or income statement generation.\n\n### Balance Sheet Generation\n\nThe **balance sheet generation** transforms the trial balance data into a structured financial position statement that follows the fundamental accounting equation: Assets = Liabilities + Equity. Think of the balance sheet as a snapshot photograph of the organization's financial position at a specific moment in time—it shows what the company owns (assets), what it owes (liabilities), and what belongs to the owners (equity).\n\nUnlike the trial balance which simply lists all accounts, the balance sheet requires sophisticated categorization, hierarchy management, and presentation logic to group accounts into meaningful sections and calculate subtotals that provide business insight.\n\n> **Decision: Balance Sheet Account Grouping Strategy**\n> - **Context**: Balance sheet accounts must be organized into logical groups like Current Assets, Fixed Assets, Current Liabilities, etc.\n> - **Options Considered**:\n>   1. Hard-coded account type mapping with fixed categories\n>   2. Configurable account hierarchy using parent-child relationships\n>   3. Tag-based categorization with multiple classification dimensions\n> - **Decision**: Configurable account hierarchy with standard parent account categories\n> - **Rationale**: Provides flexibility for different organization structures while maintaining the ability to generate standardized reports\n> - **Consequences**: Requires careful chart of accounts design but enables customized balance sheet presentations\n\n| Grouping Strategy | Flexibility | Standardization | Complexity | Chosen? |\n|------------------|------------|----------------|------------|---------|\n| Hard-coded mapping | Low | High | Low | ✗ |\n| Configurable hierarchy | High | Medium | Medium | ✓ |\n| Tag-based categorization | Very High | Low | High | Future enhancement |\n\n**Balance Sheet Generation Algorithm:**\n\n1. Generate a current trial balance to obtain all account balances and verify the books are in balance\n2. Filter trial balance to include only balance sheet accounts (ASSET, LIABILITY, EQUITY types)\n3. Group accounts by their parent account relationships to create the hierarchy structure\n4. Calculate subtotals for major categories like Current Assets, Fixed Assets, Current Liabilities, Long-term Debt\n5. Apply standard balance sheet ordering conventions with assets first, then liabilities, then equity\n6. Calculate total assets and total liabilities plus equity to verify they balance\n7. Include comparative figures from prior periods if requested for trend analysis\n8. Format monetary amounts according to presentation requirements and rounding policies\n9. Generate supplementary notes for accounts that require additional disclosure\n\nThe `BalanceSheet` structure organizes the financial position data for presentation:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| AsOfDate | time.Time | Date of the balance sheet snapshot |\n| Assets | []AccountSection | Hierarchical listing of asset accounts and subtotals |\n| Liabilities | []AccountSection | Hierarchical listing of liability accounts and subtotals |\n| Equity | []AccountSection | Hierarchical listing of equity accounts and subtotals |\n| TotalAssets | Money | Sum of all asset account balances |\n| TotalLiabilitiesAndEquity | Money | Sum of all liability and equity balances |\n| IsBalanced | bool | True when assets equal liabilities plus equity |\n| GeneratedAt | time.Time | Timestamp when the report was generated |\n| PriorPeriodComparison | *BalanceSheet | Optional comparative figures from previous period |\n\nThe `AccountSection` structure supports the hierarchical presentation required for readable balance sheets:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| SectionTitle | string | Header text like \"Current Assets\" or \"Long-term Debt\" |\n| Accounts | []AccountBalance | Individual accounts within this section |\n| Subsections | []AccountSection | Nested sections for complex hierarchies |\n| SectionTotal | Money | Sum of all accounts and subsections in this section |\n| DisplayOrder | int | Sorting order for consistent presentation |\n\n**Asset Classification and Ordering:**\n\nBalance sheet assets follow standard presentation conventions with current assets (expected to be converted to cash within one year) listed before long-term assets. The system applies these classification rules automatically based on account hierarchy and account code conventions.\n\nCurrent assets typically include cash accounts, accounts receivable, inventory, and prepaid expenses. Fixed assets include property, plant, and equipment, often with accumulated depreciation shown as contra-asset accounts that reduce the gross asset value.\n\n**Liability Classification and Presentation:**\n\nLiabilities are classified as current (due within one year) or long-term based on the account hierarchy configuration. Current liabilities include accounts payable, accrued expenses, and current portions of long-term debt. Long-term liabilities include mortgages, bonds, and other debt with maturity beyond one year.\n\n**Equity Section Calculation:**\n\nThe equity section includes contributed capital, retained earnings, and current period net income. For organizations with complex equity structures, the system supports multiple equity classes and detailed equity movement tracking.\n\n> **Critical Insight: Balance Sheet Balancing Validation**\n> \n> The balance sheet must mathematically balance with total assets equaling total liabilities plus equity. Any imbalance indicates either a trial balance error or a classification mistake in the balance sheet generation logic. The system should validate this equality and provide detailed variance analysis when imbalances occur.\n\n**Comparative Balance Sheet Generation:**\n\nWhen generating comparative balance sheets, the system retrieves balance sheet data for multiple periods and presents them side-by-side for trend analysis. This requires point-in-time balance calculations for each comparison period and careful formatting to align corresponding line items.\n\n⚠️ **Pitfall: Incorrect Account Type Classification**\n\nMisclassifying accounts between current and long-term categories can significantly distort financial ratios and analysis. For example, classifying long-term debt as current liability inflates current liabilities and makes the organization appear to have liquidity problems.\n\n**Fix**: Implement validation rules that check account classifications against business logic and provide warnings for unusual account type assignments. Regular review of the chart of accounts hierarchy ensures classifications remain accurate as business needs evolve.\n\n### Income Statement Generation\n\nThe **income statement generation** creates a period-based financial performance report that follows the fundamental profit calculation: Net Income = Total Revenues - Total Expenses. Think of the income statement as a movie showing the organization's financial performance over time, contrasted with the balance sheet which is a snapshot at a point in time.\n\nThe income statement focuses exclusively on revenue and expense accounts, transforming the period's transaction activity into a structured performance narrative that shows how the organization generated revenue, what it cost to deliver products or services, and what profit or loss resulted from operations.\n\n> **Decision: Income Statement Period Boundary Handling**\n> - **Context**: Income statements require precise period boundaries to avoid double-counting or missing transactions\n> - **Options Considered**:\n>   1. Transaction date-based period boundaries using journal entry dates\n>   2. Posting date-based boundaries using when entries were recorded in the system\n>   3. Configurable date field selection allowing either transaction or posting date\n> - **Decision**: Transaction date-based boundaries with posting date audit trails\n> - **Rationale**: Transaction dates represent when economic events occurred, providing more accurate period matching\n> - **Consequences**: Requires careful handling of entries posted after period close and clear audit trails for timing differences\n\n| Boundary Method | Accuracy | Auditability | Complexity | Chosen? |\n|----------------|----------|--------------|------------|---------|\n| Transaction date | High | Medium | Low | ✓ |\n| Posting date | Medium | High | Low | ✗ |\n| Configurable field | High | High | High | Future consideration |\n\n**Income Statement Generation Algorithm:**\n\n1. Define the reporting period with precise start and end dates for transaction inclusion\n2. Query all revenue and expense accounts from the chart of accounts with their account hierarchy\n3. Calculate net activity for each account during the period using point-in-time balance differences\n4. Group accounts into logical income statement sections like Revenue, Cost of Goods Sold, Operating Expenses\n5. Calculate subtotals for major sections like Gross Profit (Revenue minus Cost of Goods Sold)\n6. Apply standard income statement ordering with revenues first, then expenses by category\n7. Calculate net income as the final bottom-line result of revenue minus all expenses\n8. Include comparative figures from prior periods for trend analysis and variance identification\n9. Generate supporting schedules for complex revenue or expense categories requiring additional detail\n\nThe `IncomeStatement` structure organizes the period performance data:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| PeriodStart | time.Time | Beginning date of the reporting period |\n| PeriodEnd | time.Time | Ending date of the reporting period |\n| Revenues | []AccountSection | Hierarchical listing of revenue accounts and subtotals |\n| CostOfGoodsSold | []AccountSection | Direct costs associated with revenue generation |\n| OperatingExpenses | []AccountSection | Indirect costs of running the business |\n| OtherIncomeExpense | []AccountSection | Non-operating income and expense items |\n| TotalRevenue | Money | Sum of all revenue accounts for the period |\n| GrossProfit | Money | Total revenue minus cost of goods sold |\n| OperatingIncome | Money | Gross profit minus operating expenses |\n| NetIncome | Money | Final profit or loss after all income and expenses |\n| GeneratedAt | time.Time | Timestamp when the report was generated |\n| ComparativePeriod | *IncomeStatement | Optional comparison to prior period |\n\n**Period Activity Calculation:**\n\nIncome statement amounts represent the net activity in each account during the reporting period. This requires calculating the change in account balance from the beginning to the end of the period, which may involve querying point-in-time balances for period start and end dates.\n\nFor revenue accounts, period activity typically represents credit entries (increases) minus any debit entries (decreases or reversals). For expense accounts, period activity represents debit entries (increases) minus any credit entries (reimbursements or reversals).\n\n**Revenue Recognition and Matching:**\n\nThe income statement must properly match revenues with related expenses to provide meaningful performance measurement. This requires careful attention to when transactions are recognized in the period and ensuring that all related costs are included in the same period.\n\n**Multi-Period Comparative Analysis:**\n\nComparative income statements show multiple periods side-by-side to reveal trends, seasonal patterns, and performance changes. The system calculates variance amounts and percentages to highlight significant changes between periods.\n\n```\nYear-over-Year Comparison Example:\n                    2024        2023        Variance    %Change\nTotal Revenue    $100,000     $85,000      $15,000     17.6%\nCost of Sales     $60,000     $55,000       $5,000      9.1%\nGross Profit      $40,000     $30,000      $10,000     33.3%\n```\n\n> ⚠️ **Pitfall: Period Cut-off Errors**\n> \n> Incorrect period boundaries can significantly distort income statement results by including transactions from the wrong period or excluding transactions that should be included. This is especially problematic near period-end when transactions may be recorded in the system days after they actually occurred.\n> \n> **Fix**: Implement clear period cut-off procedures that define which date field determines period inclusion, and provide audit reports showing transactions with timing differences between transaction and posting dates.\n\n**Quarterly and Annual Roll-up Calculation:**\n\nThe system supports income statement generation for various periods including monthly, quarterly, and annual reports. For cumulative periods like year-to-date income statements, the calculation includes all activity from the beginning of the fiscal year through the selected end date.\n\n### Multi-Currency Report Translation\n\n**Multi-currency report translation** enables organizations with international operations to generate consolidated financial reports in a single presentation currency while maintaining the accuracy of transactions recorded in their original currencies. Think of this as being a financial translator that converts foreign language (currency) transactions into a common language that management can understand and analyze.\n\nThe translation process must handle two distinct scenarios: transactions that occurred in foreign currencies during the reporting period, and translation of foreign subsidiary financial statements for consolidation purposes. Each scenario requires different exchange rate application methods and timing considerations.\n\n> **Decision: Exchange Rate Application Method**\n> - **Context**: Multi-currency translation requires choosing when and how to apply exchange rates\n> - **Options Considered**:\n>   1. Transaction date rates for all currency conversions\n>   2. Period-end rates for all balance sheet items and average rates for income statement\n>   3. Mixed approach with transaction rates for revenues/expenses and period-end rates for assets/liabilities\n> - **Decision**: Period-end rates for balance sheet items and average rates for income statement items\n> - **Rationale**: Follows standard accounting principles (GAAP/IFRS) for foreign currency translation\n> - **Consequences**: Requires maintaining both transaction-date and period-end exchange rate data\n\n| Translation Method | Accuracy | Complexity | Standards Compliance | Chosen? |\n|-------------------|----------|------------|---------------------|---------|\n| Transaction date rates | High | Low | Partial | ✗ |\n| Period-end/average rates | Medium | Medium | High | ✓ |\n| Mixed rate approach | Very High | High | High | Future enhancement |\n\n**Multi-Currency Translation Algorithm:**\n\n1. Identify all accounts with balances in currencies other than the presentation currency\n2. Retrieve appropriate exchange rates based on account type and reporting standards requirements\n3. Apply current period-end exchange rates to balance sheet accounts (assets, liabilities, equity)\n4. Apply average exchange rates for the period to income statement accounts (revenues, expenses)\n5. Calculate translation gains and losses from exchange rate fluctuations during the period\n6. Record translation adjustments in the appropriate equity account (cumulative translation adjustment)\n7. Generate translated financial statements with original and translated amounts for transparency\n8. Provide supporting schedules showing exchange rates used and translation methodology\n9. Calculate and present the impact of exchange rate changes on financial performance\n\nThe `CurrencyTranslation` structure manages the translation process and results:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| PresentationCurrency | string | Target currency for consolidated reporting |\n| TranslationDate | time.Time | Date for which translation rates are applied |\n| ExchangeRates | map[string]ExchangeRate | Current rates for each foreign currency |\n| AverageRates | map[string]ExchangeRate | Period average rates for income statement translation |\n| TranslatedAccounts | []TranslatedAccount | Account balances in both original and presentation currencies |\n| TranslationAdjustment | Money | Net gain or loss from currency translation |\n| MethodologyNotes | string | Description of translation methods and rate sources |\n\nThe `TranslatedAccount` structure preserves both original and translated values for audit trails:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| AccountID | string | Reference to the underlying account |\n| OriginalBalance | Money | Balance in the account's native currency |\n| TranslatedBalance | Money | Balance converted to presentation currency |\n| ExchangeRateUsed | ExchangeRate | Rate applied for this translation |\n| TranslationMethod | string | Description of rate type used (period-end, average, historical) |\n| LastTranslationDate | time.Time | When this translation was last updated |\n\n**Exchange Rate Management:**\n\nThe system must maintain historical exchange rates for accurate period comparisons and audit purposes. Exchange rates include not only the rate value but also the source, effective date, and rate type (spot, average, forward).\n\n**Balance Sheet Translation:**\n\nBalance sheet accounts use current exchange rates as of the balance sheet date. This creates translation gains and losses when exchange rates change between reporting periods, requiring careful tracking of these adjustments in the equity section.\n\n**Income Statement Translation:**\n\nIncome statement accounts typically use average exchange rates for the reporting period to smooth out exchange rate fluctuations that would otherwise distort period performance. The system calculates weighted averages based on transaction volumes or uses published average rates from financial data providers.\n\n> **Critical Insight: Translation Adjustment Tracking**\n> \n> Currency translation creates gains and losses that don't represent actual cash flows but result from exchange rate changes. These translation adjustments must be tracked separately from operational gains and losses to provide clear insight into underlying business performance versus currency impact.\n\n**Consolidation Translation Process:**\n\nWhen consolidating foreign subsidiary financial statements, the translation process follows these steps:\n\n1. Translate subsidiary trial balance using appropriate exchange rates for each account type\n2. Calculate translation adjustments resulting from exchange rate changes since the prior period\n3. Eliminate intercompany transactions and balances before consolidation\n4. Combine translated subsidiary results with parent company financial statements\n5. Present consolidated results with footnote disclosure of translation methods and exchange rate impacts\n\n⚠️ **Pitfall: Mixing Translation Methods Within Account Types**\n\nUsing inconsistent exchange rate types for similar accounts can create artificial variances and make period comparisons meaningless. For example, translating some revenue accounts at transaction date rates while others use average rates creates inconsistent income statement presentation.\n\n**Fix**: Establish clear translation policies that specify which exchange rate type to use for each account category, and implement validation rules that ensure consistent application across all accounts of the same type.\n\n### Accounting Period Closing\n\n**Accounting period closing** represents the systematic process of finalizing all transactions for a specific period and transferring temporary account balances to permanent accounts. Think of period closing as sealing a time capsule—once a period is closed, its contents become historical record that cannot be altered, only referenced for future analysis.\n\nThe period closing process serves multiple critical functions: it prevents retroactive changes that would compromise audit trails, it transfers profit and loss results to retained earnings, and it resets temporary accounts for the new accounting period. This process maintains the integrity of period comparisons and ensures that each accounting period stands as a complete, immutable record.\n\n> **Decision: Period Closing Enforcement Strategy**\n> - **Context**: Organizations need to prevent changes to closed periods while allowing necessary corrections\n> - **Options Considered**:\n>   1. Hard close preventing any changes to closed periods\n>   2. Soft close allowing authorized corrections with approval workflow\n>   3. Configurable close with organization-defined rules and override capabilities\n> - **Decision**: Soft close with approval workflow and reversal-only corrections\n> - **Rationale**: Balances audit trail integrity with practical business needs for error correction\n> - **Consequences**: Requires robust approval workflows and clear audit trails for all post-closing adjustments\n\n| Closing Strategy | Data Integrity | Business Flexibility | Audit Complexity | Chosen? |\n|-----------------|----------------|---------------------|------------------|---------|\n| Hard close | Very High | Low | Low | ✗ |\n| Soft close with approval | High | High | Medium | ✓ |\n| Configurable close | Medium | Very High | High | Future consideration |\n\n**Period Closing Algorithm:**\n\n1. Validate that all transactions intended for the period have been posted and none are in draft status\n2. Generate and review trial balance to ensure books are in balance before closing procedures begin\n3. Post any required period-end adjusting entries like depreciation, accruals, and reclassifications\n4. Generate all standard financial reports for the period and archive them as official period results\n5. Calculate net income for the period by summing all revenue and expense account balances\n6. Create closing entries that transfer all revenue and expense balances to retained earnings\n7. Reset all temporary accounts (revenues and expenses) to zero balances for the new period\n8. Set the period status to closed and implement restrictions on posting new entries to closed periods\n9. Archive detailed transaction data for the closed period and update period-end balance snapshots\n10. Generate period closing reports showing the closing entries and confirming successful completion\n\nThe `AccountingPeriod` structure tracks period status and closing information:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| PeriodID | string | Unique identifier for the accounting period |\n| StartDate | time.Time | Beginning date of the accounting period |\n| EndDate | time.Time | Ending date of the accounting period |\n| PeriodType | string | Type of period (monthly, quarterly, annual) |\n| Status | PeriodStatus | Current status (OPEN, SOFT_CLOSED, HARD_CLOSED) |\n| ClosedBy | *string | User who performed the closing process |\n| ClosedAt | *time.Time | Timestamp when the period was closed |\n| NetIncome | *Money | Calculated net income for the closed period |\n| ClosingEntryIDs | []string | Journal entries created during closing process |\n| AdjustmentCount | int | Number of post-closing adjustments made |\n| FinalTrialBalanceID | *string | Reference to archived trial balance for the period |\n\nThe `PeriodClosingEntry` structure documents the automatic entries created during closing:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| EntryID | string | Reference to the journal entry created |\n| EntryType | ClosingEntryType | Type of closing entry (REVENUE_CLOSE, EXPENSE_CLOSE, INCOME_SUMMARY) |\n| AccountsAffected | []string | List of accounts involved in this closing entry |\n| Amount | Money | Total amount being transferred |\n| Description | string | Explanation of the closing entry purpose |\n| AutoGenerated | bool | True if created automatically by the closing process |\n\n**Revenue and Expense Account Closing:**\n\nThe closing process creates journal entries that transfer all revenue account balances to an Income Summary account (or directly to Retained Earnings). Revenue accounts, which normally have credit balances, are debited for their full balance amount to reduce them to zero.\n\nSimilarly, expense accounts, which normally have debit balances, are credited for their full balance amount to reduce them to zero, with the corresponding debit posted to Income Summary.\n\n**Income Summary Transfer:**\n\nAfter all revenue and expense accounts have been closed to Income Summary, the net balance in Income Summary represents the period's net income or net loss. This balance is then transferred to Retained Earnings with a final closing entry, leaving Income Summary with a zero balance.\n\n**Dividend and Distribution Closing:**\n\nFor entities that distribute profits to owners, the closing process includes transferring dividend or distribution accounts to reduce Retained Earnings by the amount of profits distributed during the period.\n\n> **Critical Insight: Reversible Closing Entries**\n> \n> All closing entries must be designed as reversible transactions that can be undone if period reopening becomes necessary. This requires generating closing entries with clear identification and the ability to create exact reversal entries that restore account balances to their pre-closing state.\n\n**Period Reopening Procedures:**\n\nWhen business requirements necessitate reopening a closed period, the system must reverse all closing entries in the exact reverse order they were created, restore temporary account balances, and change the period status back to open. This process maintains audit trail integrity while accommodating legitimate business needs.\n\n**Multi-Period Closing Coordination:**\n\nThe system coordinates closing procedures across multiple periods to ensure that quarterly and annual closes properly aggregate monthly results. This requires validating that all subsidiary periods are closed before allowing parent period closing.\n\n⚠️ **Pitfall: Incomplete Closing Entry Reversal**\n\nWhen reopening periods, failing to reverse all closing entries or reversing them in the wrong order can leave accounts with incorrect balances and break the audit trail. This is particularly problematic when multiple closing entries affect the same accounts.\n\n**Fix**: Implement closing entry tracking that records the exact sequence of closing entries and provides automated reversal functionality that processes entries in reverse chronological order. Include validation checks that verify account balances match expected pre-closing values after reversal.\n\n**Post-Closing Audit Trail:**\n\nAfter period closing, the system maintains detailed audit trails showing what closing entries were created, when they were posted, and who authorized the closing process. This audit trail includes before-and-after account balance snapshots and references to all supporting documentation.\n\n### Implementation Guidance\n\nThe financial reporting module represents the culmination of all ledger system components working together to transform raw transaction data into meaningful business insights. This implementation requires careful attention to data aggregation performance, report formatting consistency, and currency conversion accuracy.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Report Generation | Direct SQL queries with Go templates | Dedicated reporting engine like JasperReports or custom report builder |\n| PDF Generation | `github.com/jung-kurt/gofpdf` library | `github.com/SebastiaanKlippert/go-wkhtmltopdf` with HTML templates |\n| Currency Conversion | Static exchange rate table | Real-time exchange rate API integration |\n| Caching Layer | In-memory map with TTL | Redis with structured cache keys |\n| Report Scheduling | Simple cron jobs | Advanced scheduler like `github.com/robfig/cron` |\n\n**Recommended File Structure:**\n```\ninternal/reporting/\n    reports.go              ← main reporting engine\n    trial_balance.go        ← trial balance generation logic\n    balance_sheet.go        ← balance sheet generation and formatting\n    income_statement.go     ← income statement calculation\n    currency_translation.go ← multi-currency handling\n    period_closing.go       ← accounting period management\n    formatters.go          ← report output formatting (PDF, CSV, JSON)\n    templates/             ← report templates and styling\n        balance_sheet.html\n        income_statement.html\n        trial_balance.html\n    exports/               ← generated report files\ninternal/exchange/\n    rates.go               ← exchange rate management\n    providers.go           ← external rate data sources\n```\n\n**Core Report Generator Infrastructure:**\n\n```go\npackage reporting\n\nimport (\n    \"context\"\n    \"database/sql\"\n    \"time\"\n    \n    \"github.com/shopspring/decimal\"\n)\n\n// ReportGenerator coordinates all financial report generation\ntype ReportGenerator struct {\n    balanceEngine BalanceEngine\n    auditTrail   AuditStorage\n    db           *sql.DB\n    cache        ReportCache\n    formatter    ReportFormatter\n}\n\n// TrialBalanceGenerator creates and validates trial balance reports\ntype TrialBalanceGenerator struct {\n    balanceEngine BalanceEngine\n    accountRepo   AccountRepository\n    cache         TrialBalanceCache\n}\n\n// GenerateTrialBalance creates a trial balance report for the specified date\n// Returns a complete trial balance with all accounts and validation status\nfunc (g *TrialBalanceGenerator) GenerateTrialBalance(ctx context.Context, asOfDate time.Time) (*TrialBalance, error) {\n    // TODO 1: Query all active accounts from chart of accounts\n    // TODO 2: For each account, get current balance using balance engine\n    // TODO 3: Apply normal balance conventions to determine debit/credit column placement\n    // TODO 4: Calculate running totals for debit and credit columns\n    // TODO 5: Identify accounts with abnormal balances and generate warnings\n    // TODO 6: Verify total debits equal total credits and calculate any variance\n    // TODO 7: Sort accounts by account code for consistent presentation\n    // TODO 8: Create TrialBalance structure with all calculated values\n    // Hint: Use BalanceEngine.GetBalanceAsOf for point-in-time calculations\n    // Hint: Check account.NormalBalance() to determine proper column placement\n}\n\n// BalanceSheetGenerator creates balance sheet reports with proper categorization\ntype BalanceSheetGenerator struct {\n    trialBalanceGen TrialBalanceGenerator\n    accountRepo     AccountRepository\n    formatter       BalanceSheetFormatter\n}\n\n// GenerateBalanceSheet creates a balance sheet from trial balance data\n// Groups accounts by type and calculates section totals\nfunc (g *BalanceSheetGenerator) GenerateBalanceSheet(ctx context.Context, asOfDate time.Time) (*BalanceSheet, error) {\n    // TODO 1: Generate trial balance for the specified date\n    // TODO 2: Filter trial balance to include only balance sheet accounts (ASSET, LIABILITY, EQUITY)\n    // TODO 3: Group accounts by their parent account hierarchy\n    // TODO 4: Calculate subtotals for major sections (Current Assets, Fixed Assets, etc.)\n    // TODO 5: Apply standard balance sheet ordering conventions\n    // TODO 6: Calculate total assets and total liabilities plus equity\n    // TODO 7: Verify that total assets equals total liabilities plus equity\n    // TODO 8: Format account sections with proper indentation and subtotals\n    // Hint: Use account hierarchy to create nested AccountSection structures\n    // Hint: Validate final balance using Assets = Liabilities + Equity equation\n}\n\n// IncomeStatementGenerator creates period-based performance reports\ntype IncomeStatementGenerator struct {\n    balanceEngine BalanceEngine\n    accountRepo   AccountRepository\n    periodManager PeriodManager\n}\n\n// GenerateIncomeStatement calculates period performance from revenue and expense accounts\n// Computes net income as total revenues minus total expenses for the period\nfunc (g *IncomeStatementGenerator) GenerateIncomeStatement(ctx context.Context, periodStart, periodEnd time.Time) (*IncomeStatement, error) {\n    // TODO 1: Query all revenue and expense accounts from chart of accounts\n    // TODO 2: Calculate period activity for each account (ending balance minus beginning balance)\n    // TODO 3: Group accounts into income statement sections (Revenue, COGS, Operating Expenses)\n    // TODO 4: Calculate subtotals for each section with proper sign conventions\n    // TODO 5: Calculate gross profit (Revenue minus Cost of Goods Sold)\n    // TODO 6: Calculate operating income (Gross Profit minus Operating Expenses)\n    // TODO 7: Calculate net income as final bottom line result\n    // TODO 8: Apply standard income statement ordering and formatting\n    // Hint: Use GetBalanceAsOf for period start and end to calculate net activity\n    // Hint: Revenue accounts increase income, expense accounts decrease income\n}\n```\n\n**Currency Translation Infrastructure:**\n\n```go\npackage exchange\n\nimport (\n    \"context\"\n    \"time\"\n    \"database/sql\"\n)\n\n// ExchangeRateProvider retrieves current and historical exchange rates\ntype ExchangeRateProvider interface {\n    GetCurrentRate(ctx context.Context, fromCurrency, toCurrency string) (*ExchangeRate, error)\n    GetRateAsOf(ctx context.Context, fromCurrency, toCurrency string, date time.Time) (*ExchangeRate, error)\n    GetAverageRate(ctx context.Context, fromCurrency, toCurrency string, periodStart, periodEnd time.Time) (*ExchangeRate, error)\n}\n\n// CurrencyTranslator handles multi-currency report translation\ntype CurrencyTranslator struct {\n    rateProvider ExchangeRateProvider\n    db          *sql.DB\n    cache       ExchangeRateCache\n}\n\n// TranslateTrialBalance converts a trial balance to the specified presentation currency\nfunc (t *CurrencyTranslator) TranslateTrialBalance(ctx context.Context, tb *TrialBalance, presentationCurrency string) (*CurrencyTranslation, error) {\n    // TODO 1: Identify all accounts with balances in foreign currencies\n    // TODO 2: Retrieve appropriate exchange rates for each foreign currency\n    // TODO 3: Apply period-end rates to balance sheet accounts\n    // TODO 4: Apply average rates to income statement accounts  \n    // TODO 5: Calculate translation adjustments from rate changes\n    // TODO 6: Create translated account balances preserving original amounts\n    // TODO 7: Update equity section with cumulative translation adjustments\n    // TODO 8: Generate supporting schedules showing rates used\n    // Hint: Use account type to determine which exchange rate method to apply\n    // Hint: Store both original and translated amounts for audit purposes\n}\n\n// StaticRateProvider implements ExchangeRateProvider with database-stored rates\ntype StaticRateProvider struct {\n    db *sql.DB\n}\n\n// GetCurrentRate retrieves the most recent exchange rate from the database\nfunc (p *StaticRateProvider) GetCurrentRate(ctx context.Context, fromCurrency, toCurrency string) (*ExchangeRate, error) {\n    // TODO: Query exchange_rates table for most recent rate between currencies\n    // TODO: Return error if no rate found or rate is older than acceptable threshold\n    // TODO: Apply rate direction logic (EUR/USD vs USD/EUR)\n}\n```\n\n**Period Closing Infrastructure:**\n\n```go\npackage reporting\n\n// PeriodManager handles accounting period lifecycle\ntype PeriodManager struct {\n    db               *sql.DB\n    transactionEngine TransactionEngine\n    auditTrail       AuditStorage\n}\n\n// ClosePeriod executes the complete period closing process\nfunc (pm *PeriodManager) ClosePeriod(ctx context.Context, periodID string, userCtx UserContext) (*PeriodClosingResult, error) {\n    // TODO 1: Validate that all transactions for period are posted (no DRAFT entries)\n    // TODO 2: Generate final trial balance and verify books are in balance\n    // TODO 3: Post any required period-end adjusting entries\n    // TODO 4: Calculate net income by summing revenue and expense account balances\n    // TODO 5: Create closing entries to transfer revenue balances to Income Summary\n    // TODO 6: Create closing entries to transfer expense balances to Income Summary  \n    // TODO 7: Transfer Income Summary balance to Retained Earnings\n    // TODO 8: Set period status to CLOSED and record closing metadata\n    // TODO 9: Generate and archive official period-end reports\n    // TODO 10: Create audit trail entries for all closing activities\n    // Hint: Use database transactions to ensure closing process is atomic\n    // Hint: Generate reversible closing entries for potential period reopening\n}\n\n// CreateClosingEntries generates the journal entries needed to close temporary accounts\nfunc (pm *PeriodManager) CreateClosingEntries(ctx context.Context, periodID string) ([]JournalEntry, error) {\n    // TODO 1: Query all revenue accounts with non-zero balances for the period\n    // TODO 2: Create journal entries to debit revenue accounts and credit Income Summary\n    // TODO 3: Query all expense accounts with non-zero balances for the period\n    // TODO 4: Create journal entries to credit expense accounts and debit Income Summary\n    // TODO 5: Calculate Income Summary balance and create entry to transfer to Retained Earnings\n    // TODO 6: Mark all closing entries with special closing entry type for identification\n    // Hint: Revenue accounts normally have credit balances, so debit them to close\n    // Hint: Expense accounts normally have debit balances, so credit them to close\n}\n\n// ReopenPeriod reverses closing entries to allow additional transactions\nfunc (pm *PeriodManager) ReopenPeriod(ctx context.Context, periodID string, userCtx UserContext) error {\n    // TODO 1: Validate user has authorization to reopen closed periods\n    // TODO 2: Retrieve all closing entries created during period close\n    // TODO 3: Create exact reversal entries in reverse chronological order\n    // TODO 4: Post reversal entries and verify account balances match pre-closing state\n    // TODO 5: Change period status back to OPEN\n    // TODO 6: Create audit trail entries documenting period reopening\n    // TODO 7: Invalidate any cached period-end reports that are no longer accurate\n    // Hint: Process closing entries in reverse order to maintain referential integrity\n}\n```\n\n**Report Formatting and Export:**\n\n```go\npackage reporting\n\n// ReportFormatter converts report data to various output formats\ntype ReportFormatter struct {\n    templateEngine TemplateEngine\n    pdfGenerator  PDFGenerator\n    csvWriter     CSVWriter\n}\n\n// FormatTrialBalance generates formatted trial balance in specified format\nfunc (f *ReportFormatter) FormatTrialBalance(tb *TrialBalance, format string) ([]byte, error) {\n    // TODO 1: Validate requested format is supported (PDF, CSV, JSON, HTML)\n    // TODO 2: Apply appropriate template based on format and report type\n    // TODO 3: Format monetary amounts with proper currency symbols and precision\n    // TODO 4: Apply consistent column widths and alignment for readability\n    // TODO 5: Include report headers with generation date and parameters\n    // TODO 6: Add footers with page numbers and report validation status\n    // TODO 7: Generate final formatted output as byte array\n    // Hint: Use templates for consistent formatting across different report types\n}\n```\n\n**Milestone Checkpoints:**\n\nAfter implementing the financial reporting module, verify the following behavior:\n\n1. **Trial Balance Validation**: Run `go test ./internal/reporting/trial_balance_test.go` and verify that trial balances always show total debits equal to total credits for valid ledger data.\n\n2. **Balance Sheet Equation**: Generate a balance sheet and manually verify that Total Assets equals Total Liabilities plus Total Equity. Any variance indicates a categorization error.\n\n3. **Income Statement Period Accuracy**: Create transactions in different periods and verify that income statements only include activity from the specified date range.\n\n4. **Multi-Currency Translation**: Set up accounts in different currencies and verify that translated reports show both original and converted amounts with exchange rates used.\n\n5. **Period Closing Completeness**: Close a period and verify that all revenue and expense accounts show zero balances after closing while Retained Earnings reflects the period's net income.\n\n**Debugging Common Issues:**\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---------|-------------|-----------|-----|\n| Trial balance doesn't balance | Unbalanced journal entries or calculation error | Check individual journal entries for balance | Identify and correct unbalanced entries |\n| Balance sheet doesn't balance | Account type misclassification | Review chart of accounts setup | Reclassify accounts to proper types |\n| Income statement shows zero | Wrong date range or no activity | Verify period dates and transaction dates | Adjust period parameters |\n| Currency translation errors | Missing exchange rates | Check exchange rate data completeness | Add missing exchange rates for all currencies |\n| Period won't close | Draft entries still exist | Query for entries with DRAFT status | Post or delete draft entries before closing |\n\n**Performance Considerations:**\n\nFor large ledgers with millions of transactions, implement these optimizations:\n\n- Cache trial balance calculations for frequently accessed dates\n- Use materialized views for complex account hierarchy queries  \n- Implement parallel processing for multi-currency translation calculations\n- Pre-calculate period-end balances during closing to speed future queries\n- Use database partitioning by period for historical data access\n\n\n## Interactions and Data Flow\n\n> **Milestone(s):** 2 (Transaction Recording), 3 (Balance Calculation), 4 (Audit Trail), 5 (Financial Reports), as this section defines how components communicate and coordinate to implement atomic transaction processing, balance updates, audit logging, and report generation workflows\n\nThink of the ledger system's component interactions like a carefully choreographed financial operation in a traditional bank. When you deposit a check, multiple departments must coordinate: the teller validates the deposit slip, the accounting department records the transaction in your account, the audit department logs the activity, and the reporting system updates your balance. Each department has specific responsibilities and communicates through well-defined protocols. Similarly, our double-entry ledger system coordinates between the Account Manager, Transaction Recorder, Balance Engine, Audit System, and Report Generator through carefully designed APIs and workflows that ensure data consistency and auditability.\n\nThe key architectural insight is that financial systems require **strict ordering and atomicity**. Unlike typical web applications where eventual consistency might be acceptable, accounting systems demand that every operation either completes entirely or fails completely, with full traceability of who did what when. This drives our interaction patterns toward synchronous, transactional workflows with comprehensive error handling and audit logging at every step.\n\n![High-Level System Component Architecture](./diagrams/system-components.svg)\n\n### Component API Interfaces\n\nEach component in our ledger system exposes a well-defined interface that encapsulates its responsibilities while providing clear contracts for data exchange. These interfaces use **dependency inversion** principles, where high-level components depend on abstractions rather than concrete implementations, enabling testability and flexibility in deployment configurations.\n\nThe **Account Manager** serves as the authoritative source for chart of accounts information and account validation. Its interface handles account lifecycle management, hierarchy validation, and type checking that other components rely on for transaction validation.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `CreateAccount` | `ctx context.Context, account Account` | `(*Account, error)` | Creates new account with validation of code uniqueness, parent hierarchy, and account type rules |\n| `GetAccount` | `ctx context.Context, accountID string` | `(*Account, error)` | Retrieves account by ID with active status check and parent resolution |\n| `GetAccountByCode` | `ctx context.Context, code string` | `(*Account, error)` | Looks up account by unique code for journal entry line item validation |\n| `GetActiveAccounts` | `ctx context.Context, accountType AccountType` | `([]Account, error)` | Returns all active accounts of specified type for report generation and validation |\n| `ValidateAccountHierarchy` | `ctx context.Context, accountID string, parentID *string` | `error` | Checks for circular references and validates parent-child type compatibility |\n| `UpdateAccountStatus` | `ctx context.Context, accountID string, isActive bool, reason string` | `error` | Activates or deactivates account with audit trail creation for the status change |\n| `GetAccountHierarchy` | `ctx context.Context, parentID *string, depth int` | `([]Account, error)` | Retrieves account tree structure for report organization and chart of accounts display |\n\nThe **Transaction Recorder** manages the complete lifecycle of journal entries from creation through posting, with comprehensive validation and atomic database operations. This component coordinates with other systems to ensure transaction integrity.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `CreateEntry` | `ctx context.Context, entry *JournalEntry` | `(*JournalEntry, error)` | Creates draft journal entry with line item validation and assigns unique ID |\n| `ValidateEntry` | `ctx context.Context, entry *JournalEntry` | `(*ValidationResult, error)` | Performs comprehensive validation including balance check, account existence, and business rules |\n| `PostEntry` | `ctx context.Context, entryID string, userID string` | `(*PostingResult, error)` | Atomically posts validated entry with balance updates and audit logging |\n| `PostEntryWithIdempotency` | `ctx context.Context, entry *JournalEntry, idempotencyKey string, userID string` | `(*PostingResult, error)` | Posts entry with duplicate detection using idempotency key for API safety |\n| `ReverseEntry` | `ctx context.Context, entryID string, reason string, userID string` | `(*JournalEntry, error)` | Creates offsetting entry to reverse previously posted transaction without deletion |\n| `GetEntry` | `ctx context.Context, entryID string` | `(*JournalEntry, error)` | Retrieves complete journal entry with all line items and metadata |\n| `GetEntriesInRange` | `ctx context.Context, startDate time.Time, endDate time.Time, filters map[string]interface{}` | `([]JournalEntry, error)` | Queries entries by date range with optional filtering for account, status, or reference |\n| `BatchPostEntries` | `ctx context.Context, entries []JournalEntry, userID string` | `([]PostingResult, error)` | Posts multiple entries atomically within single database transaction |\n\nThe **Balance Engine** provides efficient balance calculations with multiple caching layers and point-in-time queries. Its interface abstracts the complexity of running balance maintenance and historical balance reconstruction.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `GetCurrentBalance` | `ctx context.Context, accountID string` | `(Money, error)` | Returns current balance using cached running total with L1 memory cache optimization |\n| `GetBalanceAsOf` | `ctx context.Context, accountID string, asOfDate time.Time` | `(Money, error)` | Calculates historical balance considering only entries posted on or before specified date |\n| `GetMultipleBalances` | `ctx context.Context, accountIDs []string` | `(map[string]Money, error)` | Batch retrieval of current balances for multiple accounts with single database query |\n| `GetMultipleBalancesAsOf` | `ctx context.Context, accountIDs []string, asOfDate time.Time` | `(map[string]Money, error)` | Batch historical balance calculation for efficient report generation |\n| `UpdateRunningBalances` | `ctx context.Context, entry *JournalEntry` | `error` | Updates cached balances for all accounts affected by journal entry posting |\n| `InvalidateBalance` | `ctx context.Context, accountID string` | `error` | Removes cached balance to force recalculation on next query |\n| `RefreshBalanceCache` | `ctx context.Context, accountIDs []string` | `error` | Proactively recalculates and caches balances for specified accounts |\n| `GetTrialBalance` | `ctx context.Context, asOfDate time.Time` | `(*TrialBalance, error)` | Generates complete trial balance report with debit/credit totals and balance verification |\n| `ValidateTrialBalance` | `ctx context.Context` | `error` | Performs integrity check ensuring total debits equal total credits across entire ledger |\n\nThe **Audit System** maintains immutable records of all system changes with cryptographic integrity verification. Its interface provides both real-time event recording and historical audit reporting capabilities.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `RecordEvent` | `ctx context.Context, event *AuditEvent` | `error` | Creates immutable audit record with automatic hash chain linking and timestamp |\n| `TrackChanges` | `ctx context.Context, tableName string, recordID string, oldValue interface{}, newValue interface{}` | `error` | Compares before/after values and generates detailed field-level change events |\n| `TrackStateTransition` | `ctx context.Context, entityType string, entityID string, fromState string, toState string, reason string` | `error` | Records business state changes like journal entry status transitions with business context |\n| `GetEventHistory` | `ctx context.Context, recordID string` | `([]AuditEvent, error)` | Retrieves complete chronological change history for specific record |\n| `GetEventsInRange` | `ctx context.Context, startTime time.Time, endTime time.Time, filters map[string]interface{}` | `([]AuditEvent, error)` | Queries audit events within date range with filtering by user, table, or event type |\n| `VerifyIntegrity` | `ctx context.Context, recordID string` | `(*IntegrityRecord, error)` | Validates cryptographic hash chain and digital signatures for tamper detection |\n| `GenerateAuditReport` | `ctx context.Context, reportType string, startDate time.Time, endDate time.Time, parameters map[string]interface{}` | `(*AuditReport, error)` | Creates comprehensive audit trail report for compliance and regulatory requirements |\n| `GetUserActivityReport` | `ctx context.Context, userIDs []string, startDate time.Time, endDate time.Time` | `(*AuditReport, error)` | Shows all actions performed by specific users for security and compliance auditing |\n\nThe **Report Generator** creates standard financial statements by coordinating with the Balance Engine and Account Manager to aggregate and format accounting data according to financial reporting standards.\n\n| Method Name | Parameters | Returns | Description |\n|-------------|------------|---------|-------------|\n| `GenerateTrialBalance` | `ctx context.Context, asOfDate time.Time, options map[string]interface{}` | `(*TrialBalance, error)` | Creates trial balance report with all account balances and verification that debits equal credits |\n| `GenerateBalanceSheet` | `ctx context.Context, asOfDate time.Time, comparativePeriod *time.Time` | `(*BalanceSheet, error)` | Generates balance sheet with assets, liabilities, and equity sections using proper account groupings |\n| `GenerateIncomeStatement` | `ctx context.Context, startDate time.Time, endDate time.Time, comparativePeriod *time.Time` | `(*IncomeStatement, error)` | Creates income statement showing revenues, expenses, and net income for specified period |\n| `TranslateReport` | `ctx context.Context, report interface{}, targetCurrency string, exchangeRates map[string]ExchangeRate` | `(interface{}, error)` | Converts multi-currency reports to single presentation currency using specified rates |\n| `ExportReport` | `ctx context.Context, report interface{}, format string, options map[string]interface{}` | `([]byte, error)` | Exports financial reports in PDF, CSV, or JSON formats with proper formatting and headers |\n| `ScheduleReport` | `ctx context.Context, reportType string, schedule string, recipients []string, parameters map[string]interface{}` | `error` | Sets up automated report generation and delivery for recurring financial reporting |\n\n> **Design Insight**: The interfaces use context-first parameters to enable request tracing, timeout handling, and cancellation throughout the system. Every method that modifies data requires a user context for audit trail purposes, while read operations can use anonymous contexts for performance queries.\n\n**Interface Composition Patterns**\n\nOur system uses interface composition to create flexible, testable components. Rather than large monolithic interfaces, we define focused contracts that components can implement independently.\n\n| Interface Name | Purpose | Implementing Components | Key Methods |\n|----------------|---------|-------------------------|-------------|\n| `AccountProvider` | Account information access | Account Manager, Cached Account Service | `GetAccount`, `ValidateAccount`, `GetActiveAccounts` |\n| `BalanceCalculator` | Balance computation abstraction | Balance Engine, Cached Balance Service | `GetCurrentBalance`, `GetBalanceAsOf` |\n| `AuditTracker` | Change recording contract | Audit System, File Audit Logger | `RecordEvent`, `TrackChanges` |\n| `TransactionPoster` | Entry posting abstraction | Transaction Recorder, Batch Processor | `PostEntry`, `ValidateEntry` |\n| `ReportDataSource` | Report data provider | Balance Engine, Account Manager | `GetTrialBalance`, `GetAccountHierarchy` |\n\n### Transaction Recording Workflow\n\nThe journal entry recording workflow represents the heart of our double-entry system, orchestrating validation, posting, balance updates, and audit logging in a carefully sequenced atomic operation. Think of this like processing a bank transaction: multiple verification steps must pass before money moves, and once committed, the transaction becomes permanent with full audit trails.\n\nThe workflow implements the **two-phase commit pattern** where validation completes entirely before any permanent changes occur, ensuring that partial failures leave the system in a consistent state. This is critical for financial systems where incomplete transactions could lead to incorrect balances or audit discrepancies.\n\n![Journal Entry Recording Sequence](./diagrams/journal-entry-workflow.svg)\n\n**Phase 1: Pre-Validation and Setup**\n\nThe workflow begins when the API layer receives a journal entry creation request. Before any database interactions occur, the system performs preliminary validation and establishes transaction context.\n\n1. **Request Reception**: The API endpoint receives the journal entry request with debit and credit line items, validates the HTTP request structure, and extracts user authentication context for audit purposes.\n\n2. **Idempotency Check**: The Transaction Recorder calls `CheckIdempotency(ctx, idempotencyKey)` to determine if this exact request has been processed before, preventing duplicate entries from API retries or network issues.\n\n3. **Entry Structure Validation**: Basic structural validation occurs including checking that the entry has at least two line items (fundamental double-entry requirement), all line items reference valid account IDs, and monetary amounts use proper decimal precision.\n\n4. **Business Rule Validation**: The system validates business-specific rules like ensuring journal entries are not posted to closed accounting periods, checking that referenced accounts are active and appropriate for the transaction type, and verifying that the posting date falls within acceptable ranges.\n\n**Phase 2: Account and Balance Validation**\n\nThis phase involves coordination with the Account Manager and Balance Engine to validate that the proposed transaction can be safely posted.\n\n5. **Account Existence Verification**: For each line item, the system calls `GetAccount(ctx, accountID)` to verify that referenced accounts exist, are active, and have compatible types for the debit/credit operation being performed.\n\n6. **Double-Entry Balance Check**: The Transaction Recorder calls `TotalDebits()` and `TotalCredits()` on the journal entry and ensures these amounts are exactly equal, implementing the fundamental accounting equation that every transaction must balance.\n\n7. **Account Type Compatibility**: Each line item is validated against account type rules using the `NormalBalance()` method to ensure debits and credits align with standard accounting conventions (assets and expenses are debit-normal, liabilities and revenues are credit-normal).\n\n8. **Sufficient Balance Check** (if applicable): For accounts that require positive balances (like cash accounts), the system calls `GetCurrentBalance(ctx, accountID)` and validates that the proposed transaction won't create negative balances where prohibited.\n\n**Phase 3: Atomic Posting Transaction**\n\nOnce all validations pass, the system begins the atomic posting process within a single database transaction that ensures all changes succeed or fail together.\n\n9. **Database Transaction Initiation**: The system calls `WithTransaction(db, postingFunction)` to begin a database transaction with appropriate isolation levels (typically READ COMMITTED to prevent dirty reads while allowing concurrent transactions).\n\n10. **Entry Status Update**: The journal entry status changes from `EntryStatusDraft` to `EntryStatusPosted` with the current timestamp recorded in the `PostedAt` field for audit trail purposes.\n\n11. **Entry Persistence**: The complete journal entry with all line items is persisted to the database using INSERT operations that maintain referential integrity between the entry header and line item details.\n\n12. **Running Balance Updates**: For each affected account, the system calls `UpdateRunningBalances(ctx, entry)` to incrementally update cached balance totals, avoiding expensive recalculation while maintaining accuracy.\n\n**Phase 4: Audit Trail and Notification**\n\nAfter successful posting, the system creates comprehensive audit records and notifies dependent systems of the completed transaction.\n\n13. **Audit Event Creation**: The Audit System receives a call to `RecordEvent(ctx, auditEvent)` containing details of the posted transaction including user identity, timestamp, entry details, and business reason for the transaction.\n\n14. **Integrity Hash Generation**: The system generates cryptographic hashes of the posted entry using `GenerateContentHash(entry)` and links it to the previous entry in the hash chain for tamper detection.\n\n15. **Cache Invalidation**: Historical balance caches are invalidated using `invalidateHistoricalCache(ctx, entryDate, affectedAccounts)` to ensure future point-in-time queries reflect the new transaction.\n\n16. **Idempotency Record Update**: The idempotency system is updated with the successful posting result using `UpdateStatus(ctx, idempotencyKey, \"COMPLETED\", entryID)` to handle future duplicate requests.\n\nThe entire workflow from validation through posting typically completes in under 100 milliseconds for simple entries, with the database transaction portion taking only 10-20 milliseconds to minimize lock contention and enable high concurrency.\n\n> **Critical Design Principle**: The workflow uses **pessimistic validation** where every possible failure condition is checked before making any permanent changes. This \"validate everything first\" approach is essential for financial systems where consistency is more important than performance.\n\n**Error Handling and Rollback**\n\nThe workflow includes comprehensive error handling at each phase with specific recovery actions:\n\n| Failure Point | Detection Method | Recovery Action | User Notification |\n|---------------|------------------|-----------------|-------------------|\n| Invalid account reference | Account lookup returns error | Immediate validation failure | Return specific account ID that failed validation |\n| Unbalanced entry | Debit/credit totals don't match | Immediate validation failure | Return calculated debit and credit totals with variance |\n| Insufficient balance | Balance check fails business rules | Immediate validation failure | Return current balance and required balance for transaction |\n| Database constraint violation | SQL error during INSERT | Transaction rollback | Return generic \"posting failed\" message with error ID for support |\n| Audit system failure | Audit record creation fails | Transaction rollback | Retry with exponential backoff, escalate if persistent |\n| Cache update failure | Balance cache update fails | Log error but continue | Background job will eventually refresh cache |\n\n### Report Generation Workflow\n\nFinancial report generation requires careful orchestration between multiple components to aggregate account data, apply accounting rules, and format output according to financial reporting standards. Think of this process like assembling a complex financial statement at a CPA firm: accountants gather trial balance data, organize accounts into statement sections, apply presentation rules, and format the final report with proper headers and calculations.\n\nThe report generation workflow implements a **pipeline architecture** where data flows through successive transformation stages: data extraction, classification, aggregation, formatting, and export. Each stage has specific responsibilities and can be optimized independently while maintaining overall system performance.\n\n![Financial Report Generation Process](./diagrams/report-generation-flow.svg)\n\n**Stage 1: Report Request and Parameter Validation**\n\nThe workflow begins when a user or automated system requests a financial report with specific parameters defining the report scope and format requirements.\n\n1. **Request Parsing**: The Report Generator receives the report request containing report type (trial balance, balance sheet, income statement), date parameters (as-of date for balance sheet, period range for income statement), formatting options, and output format preferences.\n\n2. **Parameter Validation**: The system validates that the requested date ranges are valid, the report type is supported, any comparative periods are properly specified, and the requesting user has appropriate permissions to access the requested account data.\n\n3. **Template Selection**: Based on the report type and organization configuration, the system selects the appropriate report template that defines account groupings, calculation rules, and formatting standards for the requested financial statement.\n\n4. **Currency and Translation Setup**: For multi-currency organizations, the system determines the presentation currency and retrieves current exchange rates using `GetExchangeRates(ctx, currencies, asOfDate)` for proper currency translation.\n\n**Stage 2: Account Data Extraction**\n\nThis stage involves coordinating with the Account Manager and Balance Engine to retrieve all necessary account information and balance data for the report period.\n\n5. **Account Hierarchy Retrieval**: The system calls `GetActiveAccounts(ctx, accountType)` for each relevant account type (assets, liabilities, equity, revenues, expenses) to build the complete chart of accounts structure needed for the report.\n\n6. **Balance Data Collection**: For balance sheet reports, the system calls `GetMultipleBalancesAsOf(ctx, accountIDs, asOfDate)` to retrieve point-in-time balances. For income statements, it uses `GetBalanceChanges(ctx, accountIDs, startDate, endDate)` to calculate period activity.\n\n7. **Trial Balance Generation**: As the foundation for all financial reports, the system calls `GetTrialBalance(ctx, asOfDate)` to ensure all account balances are properly balanced and to provide the base dataset for statement preparation.\n\n8. **Comparative Data Retrieval**: If comparative periods are requested, the system repeats the balance collection process for prior periods using the same account structure to ensure consistent presentation across periods.\n\n**Stage 3: Account Classification and Grouping**\n\nFinancial statements require accounts to be organized into specific sections according to accounting standards and organizational requirements.\n\n9. **Account Type Mapping**: Each account is classified into its appropriate financial statement section using the account type hierarchy: assets are grouped into current and non-current, liabilities are separated by payment terms, and equity accounts are organized by source.\n\n10. **Section Totaling**: Within each statement section, account balances are aggregated using appropriate signs (normal balance conventions) where assets and expenses are positive, while liabilities, equity, and revenues may be presented with different signs depending on the statement type.\n\n11. **Multi-Level Grouping**: The system creates hierarchical groupings like \"Current Assets\" containing \"Cash and Cash Equivalents\" and \"Accounts Receivable\" subsections, allowing for both detailed and summary-level reporting.\n\n12. **Currency Translation**: For accounts denominated in foreign currencies, the system applies appropriate translation methods using period-end rates for balance sheet items and average rates for income statement items.\n\n**Stage 4: Financial Statement Assembly**\n\nThis stage transforms the classified account data into properly formatted financial statements with required calculations and presentation rules.\n\n13. **Statement Structure Creation**: The system builds the financial statement structure using the appropriate template, creating sections like Assets, Liabilities and Equity for balance sheets, or Revenues and Expenses for income statements.\n\n14. **Cross-Statement Validation**: For balance sheets, the system verifies that total assets equal total liabilities plus equity using the fundamental accounting equation. For income statements, it ensures proper calculation of gross profit, operating income, and net income.\n\n15. **Variance and Ratio Calculations**: If comparative periods are included, the system calculates period-over-period changes and percentage variances to provide analytical insights alongside the basic financial data.\n\n16. **Note and Disclosure Integration**: The system incorporates any required footnotes, accounting policy disclosures, or supplementary information that provides context for the financial statement data.\n\n**Stage 5: Formatting and Export**\n\nThe final stage transforms the assembled financial statement data into the requested output format with proper presentation and layout.\n\n17. **Format-Specific Rendering**: Based on the requested output format (PDF, CSV, JSON), the system applies appropriate formatting rules including number formatting, column alignment, and hierarchical indentation for account groupings.\n\n18. **Header and Footer Generation**: The system adds report headers containing organization name, report title, period covered, and generation timestamp, along with page numbers and other standard report elements.\n\n19. **Quality Assurance Checks**: Before output, the system performs final validation including mathematical accuracy checks, ensuring all totals foot and cross-foot correctly, and verifying that comparative data is consistently presented.\n\n20. **File Generation and Delivery**: The formatted report is generated in the requested format and either returned directly to the API caller or delivered via email, file system, or cloud storage depending on the delivery preferences specified in the request.\n\n**Performance Optimization Strategies**\n\nReport generation can be resource-intensive for organizations with large charts of accounts or long time periods. The system employs several optimization strategies:\n\n| Optimization Technique | Implementation | Performance Benefit | Trade-off |\n|------------------------|----------------|--------------------|-----------| \n| Balance Pre-aggregation | Maintain summary balances by account type | Reduces real-time calculation | Requires additional storage and maintenance |\n| Report Caching | Cache generated reports for common requests | Near-instant delivery for repeated requests | Cache invalidation complexity |\n| Incremental Updates | Track only changed accounts since last report | Faster regeneration for updated data | More complex change tracking logic |\n| Parallel Processing | Generate statement sections concurrently | Reduced total generation time | Increased memory usage and complexity |\n| Template Pre-compilation | Compile report templates at startup | Faster report formatting | Less flexible runtime customization |\n\nThe typical performance targets for report generation are trial balance in under 2 seconds, balance sheet in under 5 seconds, and income statement in under 8 seconds for organizations with up to 10,000 accounts and 1 million transactions per year.\n\n> **Design Insight**: The report generation workflow prioritizes **accuracy over speed**, performing extensive validation and cross-checking to ensure financial statement integrity. While this may result in longer generation times compared to simple queries, it prevents the far more costly errors that could result from incorrect financial reporting.\n\n### Concurrent Access Patterns\n\nFinancial systems must handle multiple simultaneous users posting transactions, generating reports, and querying balances while maintaining strict data consistency and avoiding race conditions that could lead to incorrect account balances. Think of this like multiple bank tellers processing deposits and withdrawals simultaneously while ensuring that account balances remain accurate and audit trails are preserved.\n\nThe challenge in concurrent accounting systems is that financial transactions are inherently interdependent: posting a journal entry affects multiple accounts, balance calculations depend on transaction ordering, and audit trails must maintain chronological consistency. Our system uses a combination of **optimistic locking**, **read-committed isolation**, and **careful transaction boundaries** to achieve high concurrency while preserving financial accuracy.\n\n**Transaction-Level Concurrency Control**\n\nAt the core of our concurrency model is the principle that journal entry posting must be atomic and serializable, while balance queries can operate with relaxed consistency for better performance.\n\n> **Decision: Optimistic Locking for Balance Updates**\n> - **Context**: Multiple transactions might simultaneously update the same account's running balance, creating race conditions\n> - **Options Considered**: Pessimistic locking with account-level locks, optimistic locking with version numbers, event-sourced balance calculation\n> - **Decision**: Optimistic locking using version numbers in `RunningBalance` records\n> - **Rationale**: Provides better concurrency than pessimistic locks while detecting conflicts reliably, and most real-world accounting operations don't create high contention on individual accounts\n> - **Consequences**: Enables high-throughput transaction posting with automatic retry logic for the rare conflicts that occur\n\nThe `RunningBalance` table includes a `Version` field that increments with each update. When posting a journal entry, the system:\n\n1. Reads the current balance and version for each affected account\n2. Calculates the new balance based on the entry's debit/credit amounts  \n3. Attempts to update the balance using a WHERE clause that includes the original version\n4. If the update affects 0 rows (version has changed), retries the entire balance update process\n5. After 3 failed retries, escalates to a pessimistic lock to prevent starvation\n\n**Read Consistency Models**\n\nDifferent types of queries in our system have varying consistency requirements that we address through layered caching and appropriate isolation levels.\n\n| Query Type | Consistency Requirement | Implementation Strategy | Performance Impact |\n|------------|------------------------|------------------------|-------------------|\n| Current balance for transaction validation | Strong consistency required | Direct database read with READ_COMMITTED | Moderate - each validation requires DB query |\n| Balance display in user interface | Eventually consistent acceptable | L1 memory cache with 30-second TTL | High performance - sub-millisecond response |\n| Financial report generation | Point-in-time consistency required | Snapshot isolation with historical cache | Low impact - uses materialized snapshots |\n| Audit trail queries | Strong consistency required | Direct database read, no caching | Low frequency - acceptable performance impact |\n| Trial balance validation | Strong consistency required | Database aggregation with explicit locking | Low frequency - runs during off-peak hours |\n\n**Memory Cache Coherence**\n\nThe `MemoryCache` component maintains L1 cache coherence across multiple application instances using a **cache invalidation bus** pattern. When any instance posts a transaction that affects account balances, it publishes cache invalidation messages containing the affected account IDs and update timestamps.\n\n```\nCache Invalidation Flow:\n1. Instance A posts journal entry affecting accounts 1001, 2001\n2. Instance A publishes invalidation message: {accounts: [1001, 2001], timestamp: T1}\n3. Instances B and C receive message and remove cached balances for accounts 1001, 2001\n4. Next balance query on any instance triggers database refresh\n```\n\nThe cache uses **versioned entries** where each cached balance includes the timestamp of the last update. When invalidation messages arrive, the cache only removes entries that are older than the invalidation timestamp, preventing race conditions where fresh data gets invalidated by stale messages.\n\n**Database Connection Pooling and Transaction Management**\n\nTo support concurrent access, the system maintains separate connection pools for different types of operations with appropriate sizing and timeout configurations.\n\n| Connection Pool | Purpose | Pool Size | Max Idle Time | Usage Pattern |\n|-----------------|---------|-----------|---------------|---------------|\n| Transaction Pool | Journal entry posting | 20 connections | 5 minutes | Short-lived, high-frequency transactions |\n| Query Pool | Balance and report queries | 50 connections | 10 minutes | Medium-lived, variable frequency |\n| Batch Pool | Period closing and bulk operations | 5 connections | 30 minutes | Long-lived, infrequent operations |\n| Audit Pool | Audit event recording | 10 connections | 5 minutes | Short-lived, continuous background writes |\n\n**Concurrent Report Generation**\n\nFinancial report generation can be resource-intensive and must handle concurrent requests without degrading transaction posting performance. The system uses **read replicas** for report queries and **resource isolation** to prevent report generation from impacting transactional operations.\n\nWhen multiple users request the same report simultaneously (common for month-end trial balance), the system employs **request deduplication** where the first request triggers report generation while subsequent identical requests wait for and receive the same result.\n\n```\nConcurrent Report Handling:\n1. User A requests trial balance for 2024-01-31\n2. System starts report generation, creates \"in-progress\" marker\n3. User B requests identical trial balance \n4. System detects in-progress marker, adds User B to waiting list\n5. Report completes, system delivers result to both User A and User B\n6. Subsequent requests for same report use cached result\n```\n\n**Deadlock Prevention and Resolution**\n\nDatabase deadlocks can occur when transactions acquire locks in different orders. Our system prevents deadlocks through **consistent lock ordering** and **timeout-based resolution**.\n\nThe lock ordering follows a hierarchy: accounts are always locked in ascending ID order, journal entries are locked before their line items, and audit records are locked last. When multiple accounts are affected by a transaction, the system sorts the account IDs before acquiring locks.\n\n| Deadlock Scenario | Prevention Strategy | Recovery Mechanism |\n|------------------|--------------------|--------------------|\n| Two entries updating same accounts in different order | Sort account IDs before locking | N/A - prevented by design |\n| Long-running report blocking transaction | Separate read replica for reports | N/A - prevented by isolation |\n| Audit system blocking transaction posting | Asynchronous audit event queuing | Retry transaction after audit queue drains |\n| Cache refresh during high transaction volume | Background refresh with read-through fallback | Use stale cache data with eventual consistency |\n\n**High-Availability Patterns**\n\nFor production deployments requiring high availability, the system supports **active-passive clustering** where multiple application instances can process transactions but only one instance handles batch operations like period closing.\n\nThe system uses **leader election** through database heartbeats to determine which instance is responsible for system-wide operations:\n\n1. Each instance updates a heartbeat record with its instance ID and current timestamp every 30 seconds\n2. The instance with the most recent heartbeat (within last 60 seconds) becomes the leader\n3. Only the leader instance processes scheduled batch operations and system maintenance tasks\n4. If the leader fails, another instance automatically assumes leadership within 60 seconds\n5. All instances can process user-initiated transactions and queries for horizontal scalability\n\n**Performance Monitoring and Circuit Breakers**\n\nTo maintain system stability under high concurrency, the system implements **circuit breaker patterns** that temporarily reject requests when error rates exceed thresholds or response times become unacceptable.\n\n| Circuit Breaker | Trigger Condition | Failure Response | Recovery Condition |\n|-----------------|-------------------|------------------|--------------------|\n| Database Connection | >10% connection failures in 1 minute | Return HTTP 503 Service Unavailable | <1% failures for 30 seconds |\n| Balance Cache | >50% cache miss rate | Direct database reads only | Cache hit rate >80% for 2 minutes |\n| Report Generation | >30 second average generation time | Return cached reports only | Average time <10 seconds for 5 minutes |\n| Audit System | >5 second audit write latency | Queue events for async processing | Latency <1 second for 30 seconds |\n\nThe system continuously monitors key performance metrics and automatically adjusts connection pool sizes, cache TTLs, and timeout values based on observed load patterns and response times.\n\n> **Critical Insight**: Concurrent access in financial systems requires **graceful degradation** strategies where the system maintains core functionality (transaction posting and balance queries) even when auxiliary systems (reporting, audit) experience performance issues. This ensures that business operations can continue even during peak load periods.\n\n### Implementation Guidance\n\nThe component interaction patterns described above require careful implementation to handle the complexity of coordinating multiple services while maintaining performance and reliability. The following guidance provides concrete implementation strategies and starter code for building these workflows.\n\n**Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Inter-service Communication | HTTP REST with JSON serialization | gRPC with Protocol Buffers for type safety |\n| Database Connection Management | `database/sql` with connection pooling | `jmoiron/sqlx` for enhanced query building |\n| Transaction Management | Manual `sql.Tx` with rollback handling | `gorm` ORM with automatic transaction boundaries |\n| Caching Layer | In-memory `sync.Map` with manual invalidation | Redis with pub/sub for distributed invalidation |\n| Event Bus | Channel-based message passing | NATS or RabbitMQ for persistent messaging |\n| Circuit Breaker | Manual error counting with thresholds | `sony/gobreaker` library with metrics integration |\n\n**Recommended File Structure**\n\n```\nproject-root/\n  cmd/\n    ledger-server/\n      main.go                          ← HTTP server entry point\n  internal/\n    api/\n      handlers/\n        transaction_handler.go         ← REST endpoints for journal entries\n        report_handler.go             ← REST endpoints for financial reports\n        health_handler.go             ← Health check and metrics endpoints\n      middleware/\n        auth_middleware.go            ← User authentication and context\n        audit_middleware.go           ← Automatic audit event creation\n        idempotency_middleware.go     ← Request deduplication\n      models/\n        requests.go                   ← API request/response models\n        responses.go\n    orchestration/\n      transaction_workflow.go         ← Journal entry posting workflow\n      report_workflow.go             ← Financial report generation workflow\n      batch_processor.go             ← Multi-entry processing coordination\n    interfaces/\n      account_provider.go            ← Account management interface contracts\n      balance_calculator.go          ← Balance calculation interface contracts  \n      audit_tracker.go              ← Audit trail interface contracts\n    services/\n      account_manager.go             ← Account lifecycle management\n      transaction_recorder.go        ← Journal entry posting service\n      balance_engine.go              ← Balance calculation and caching\n      audit_system.go               ← Immutable change tracking\n      report_generator.go            ← Financial statement generation\n    cache/\n      memory_cache.go               ← L1 in-memory balance caching\n      invalidation_bus.go           ← Cross-instance cache coordination\n    database/\n      connection_pool.go            ← Database connection management\n      transaction_manager.go        ← Atomic transaction utilities\n      migrations/                   ← Database schema versioning\n        001_initial_schema.sql\n        002_add_audit_tables.sql\n    config/\n      config.go                     ← Configuration management\n      database_config.go            ← Database connection settings\n```\n\n**Transaction Workflow Infrastructure Code**\n\nComplete implementation of the atomic transaction workflow infrastructure that coordinates between components:\n\n```go\npackage orchestration\n\nimport (\n    \"context\"\n    \"database/sql\"\n    \"fmt\"\n    \"time\"\n    \n    \"github.com/shopspring/decimal\"\n    \n    \"your-project/internal/interfaces\"\n    \"your-project/internal/models\"\n)\n\n// WorkflowCoordinator manages the complete journal entry posting process\ntype WorkflowCoordinator struct {\n    accountProvider  interfaces.AccountProvider\n    balanceCalc     interfaces.BalanceCalculator  \n    auditTracker    interfaces.AuditTracker\n    db              *sql.DB\n    cache           *cache.MemoryCache\n}\n\n// NewWorkflowCoordinator creates a new workflow coordinator with all dependencies\nfunc NewWorkflowCoordinator(\n    accountProvider interfaces.AccountProvider,\n    balanceCalc interfaces.BalanceCalculator,\n    auditTracker interfaces.AuditTracker,\n    db *sql.DB,\n    cache *cache.MemoryCache,\n) *WorkflowCoordinator {\n    return &WorkflowCoordinator{\n        accountProvider: accountProvider,\n        balanceCalc:     balanceCalc,\n        auditTracker:    auditTracker,\n        db:              db,\n        cache:           cache,\n    }\n}\n\n// PostJournalEntry executes the complete posting workflow atomically\nfunc (wc *WorkflowCoordinator) PostJournalEntry(ctx context.Context, entry *models.JournalEntry, userID string) (*models.PostingResult, error) {\n    startTime := time.Now()\n    \n    // TODO 1: Validate entry structure and business rules\n    if err := wc.validateEntryStructure(ctx, entry); err != nil {\n        return nil, fmt.Errorf(\"entry validation failed: %w\", err)\n    }\n    \n    // TODO 2: Verify all referenced accounts exist and are active\n    if err := wc.validateReferencedAccounts(ctx, entry); err != nil {\n        return nil, fmt.Errorf(\"account validation failed: %w\", err)\n    }\n    \n    // TODO 3: Check that total debits equal total credits\n    if err := wc.validateDoubleEntryBalance(ctx, entry); err != nil {\n        return nil, fmt.Errorf(\"balance validation failed: %w\", err)\n    }\n    \n    // TODO 4: Execute atomic posting within database transaction\n    result, err := wc.executeAtomicPosting(ctx, entry, userID)\n    if err != nil {\n        return nil, fmt.Errorf(\"atomic posting failed: %w\", err)\n    }\n    \n    // TODO 5: Update running balances for affected accounts\n    if err := wc.updateAccountBalances(ctx, entry); err != nil {\n        // Log error but don't fail - balance cache will eventually refresh\n        wc.logError(ctx, \"balance update failed\", err, entry.ID)\n    }\n    \n    // TODO 6: Create comprehensive audit trail\n    if err := wc.createAuditTrail(ctx, entry, userID, startTime); err != nil {\n        // Log error but don't fail - audit is important but shouldn't block posting\n        wc.logError(ctx, \"audit trail creation failed\", err, entry.ID)\n    }\n    \n    return result, nil\n}\n\n// Idempotent posting with duplicate detection\nfunc (wc *WorkflowCoordinator) PostJournalEntryIdempotent(ctx context.Context, entry *models.JournalEntry, idempotencyKey string, userID string) (*models.PostingResult, error) {\n    // TODO 1: Check if this exact request has been processed before\n    existing, err := wc.checkIdempotency(ctx, idempotencyKey)\n    if err != nil {\n        return nil, fmt.Errorf(\"idempotency check failed: %w\", err)\n    }\n    \n    if existing != nil {\n        // TODO 2: Return previous result if request already processed\n        return &models.PostingResult{\n            EntryID:   existing.EntryID,\n            Status:    \"COMPLETED\",\n            PostedAt:  existing.CreatedAt,\n            Message:   \"Request previously processed\",\n            Duplicate: true,\n        }, nil\n    }\n    \n    // TODO 3: Record idempotency key before processing\n    if err := wc.recordIdempotencyKey(ctx, idempotencyKey, entry.ID); err != nil {\n        return nil, fmt.Errorf(\"idempotency recording failed: %w\", err)\n    }\n    \n    // TODO 4: Process the entry using standard workflow\n    result, err := wc.PostJournalEntry(ctx, entry, userID)\n    if err != nil {\n        // TODO 5: Update idempotency record with failure status\n        wc.updateIdempotencyStatus(ctx, idempotencyKey, \"FAILED\", err.Error())\n        return nil, err\n    }\n    \n    // TODO 6: Update idempotency record with success status\n    wc.updateIdempotencyStatus(ctx, idempotencyKey, \"COMPLETED\", result.EntryID)\n    \n    return result, nil\n}\n\n// executeAtomicPosting handles the core database transaction\nfunc (wc *WorkflowCoordinator) executeAtomicPosting(ctx context.Context, entry *models.JournalEntry, userID string) (*models.PostingResult, error) {\n    tx, err := wc.db.BeginTx(ctx, &sql.TxOptions{\n        Isolation: sql.LevelReadCommitted,\n    })\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to begin transaction: %w\", err)\n    }\n    defer tx.Rollback() // Will be ignored if tx.Commit() succeeds\n    \n    // TODO 1: Update entry status to POSTED with current timestamp\n    entry.Status = models.EntryStatusPosted\n    entry.PostedAt = &time.Time{}\n    *entry.PostedAt = time.Now()\n    \n    // TODO 2: Insert journal entry header record\n    if err := wc.insertJournalEntry(ctx, tx, entry); err != nil {\n        return nil, fmt.Errorf(\"failed to insert journal entry: %w\", err)\n    }\n    \n    // TODO 3: Insert all line item records with proper sequencing\n    if err := wc.insertEntryLines(ctx, tx, entry); err != nil {\n        return nil, fmt.Errorf(\"failed to insert entry lines: %w\", err)\n    }\n    \n    // TODO 4: Update running balances within the same transaction\n    if err := wc.updateRunningBalancesInTx(ctx, tx, entry); err != nil {\n        return nil, fmt.Errorf(\"failed to update running balances: %w\", err)\n    }\n    \n    // TODO 5: Commit all changes atomically\n    if err := tx.Commit(); err != nil {\n        return nil, fmt.Errorf(\"failed to commit transaction: %w\", err)\n    }\n    \n    return &models.PostingResult{\n        EntryID:   entry.ID,\n        Status:    \"POSTED\",\n        PostedAt:  *entry.PostedAt,\n        Message:   \"Journal entry posted successfully\",\n        Duplicate: false,\n    }, nil\n}\n```\n\n**Report Generation Workflow Implementation**\n\n```go\npackage orchestration\n\n// ReportWorkflow coordinates financial report generation across components\ntype ReportWorkflow struct {\n    balanceEngine    interfaces.BalanceCalculator\n    accountProvider  interfaces.AccountProvider\n    cache           *cache.ReportCache\n}\n\n// GenerateTrialBalanceReport creates a complete trial balance with validation\nfunc (rw *ReportWorkflow) GenerateTrialBalanceReport(ctx context.Context, asOfDate time.Time) (*models.TrialBalance, error) {\n    // TODO 1: Get all active accounts organized by type\n    accounts, err := rw.accountProvider.GetActiveAccounts(ctx, nil) // nil = all types\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to retrieve accounts: %w\", err)\n    }\n    \n    // TODO 2: Extract account IDs for batch balance retrieval\n    accountIDs := make([]string, len(accounts))\n    for i, account := range accounts {\n        accountIDs[i] = account.ID\n    }\n    \n    // TODO 3: Get balances for all accounts as of specified date\n    balances, err := rw.balanceEngine.GetMultipleBalancesAsOf(ctx, accountIDs, asOfDate)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to retrieve balances: %w\", err)\n    }\n    \n    // TODO 4: Build trial balance structure with account details\n    trialBalance := &models.TrialBalance{\n        AsOfDate:        asOfDate,\n        AccountBalances: make([]models.AccountBalance, 0, len(accounts)),\n        TotalDebits:     models.Money{Amount: decimal.Zero, Currency: \"USD\"},\n        TotalCredits:    models.Money{Amount: decimal.Zero, Currency: \"USD\"},\n        GeneratedAt:     time.Now(),\n    }\n    \n    // TODO 5: Process each account and categorize balances by normal balance\n    for _, account := range accounts {\n        balance, exists := balances[account.ID]\n        if !exists {\n            continue // Skip accounts with no activity\n        }\n        \n        accountBalance := models.AccountBalance{\n            AccountID:     account.ID,\n            AccountCode:   account.Code,\n            AccountName:   account.Name,\n            AccountType:   account.Type,\n            Balance:       balance,\n        }\n        \n        // Determine if balance shows in debit or credit column\n        if account.IsDebitNormal() {\n            if balance.Amount.GreaterThan(decimal.Zero) {\n                accountBalance.DebitAmount = &balance\n                trialBalance.TotalDebits = trialBalance.TotalDebits.Add(balance)\n            } else if balance.Amount.LessThan(decimal.Zero) {\n                creditAmount := models.Money{Amount: balance.Amount.Neg(), Currency: balance.Currency}\n                accountBalance.CreditAmount = &creditAmount\n                trialBalance.TotalCredits = trialBalance.TotalCredits.Add(creditAmount)\n            }\n        } else {\n            if balance.Amount.GreaterThan(decimal.Zero) {\n                accountBalance.CreditAmount = &balance\n                trialBalance.TotalCredits = trialBalance.TotalCredits.Add(balance)\n            } else if balance.Amount.LessThan(decimal.Zero) {\n                debitAmount := models.Money{Amount: balance.Amount.Neg(), Currency: balance.Currency}\n                accountBalance.DebitAmount = &debitAmount\n                trialBalance.TotalDebits = trialBalance.TotalDebits.Add(debitAmount)\n            }\n        }\n        \n        trialBalance.AccountBalances = append(trialBalance.AccountBalances, accountBalance)\n    }\n    \n    // TODO 6: Validate that total debits equal total credits\n    variance := trialBalance.TotalDebits.Subtract(trialBalance.TotalCredits)\n    trialBalance.Variance = variance\n    trialBalance.IsBalanced = variance.Amount.Equal(decimal.Zero)\n    \n    return trialBalance, nil\n}\n```\n\n**Language-Specific Concurrency Implementation**\n\n```go\npackage cache\n\nimport (\n    \"context\"\n    \"sync\"\n    \"time\"\n)\n\n// MemoryCache provides thread-safe L1 caching with TTL and version control\ntype MemoryCache struct {\n    data    sync.Map // map[string]*CachedBalance\n    mutex   sync.RWMutex\n    ttl     time.Duration\n    metrics *CacheMetrics\n}\n\n// CachedBalance represents a cached balance entry with metadata\ntype CachedBalance struct {\n    Balance   models.Money\n    CachedAt  time.Time\n    Version   int64\n    ExpiresAt time.Time\n}\n\n// Get retrieves a cached balance with TTL checking\nfunc (mc *MemoryCache) Get(ctx context.Context, accountID string) (*models.Money, bool) {\n    value, exists := mc.data.Load(accountID)\n    if !exists {\n        mc.metrics.RecordMiss(accountID)\n        return nil, false\n    }\n    \n    cached, ok := value.(*CachedBalance)\n    if !ok || time.Now().After(cached.ExpiresAt) {\n        mc.data.Delete(accountID)\n        mc.metrics.RecordExpiration(accountID)\n        return nil, false\n    }\n    \n    mc.metrics.RecordHit(accountID)\n    return &cached.Balance, true\n}\n\n// Set stores a balance in cache with automatic expiration\nfunc (mc *MemoryCache) Set(ctx context.Context, accountID string, balance models.Money, version int64) {\n    cached := &CachedBalance{\n        Balance:   balance,\n        CachedAt:  time.Now(),\n        Version:   version,\n        ExpiresAt: time.Now().Add(mc.ttl),\n    }\n    \n    mc.data.Store(accountID, cached)\n    mc.metrics.RecordSet(accountID)\n}\n\n// InvalidateAccounts removes specific accounts from cache\nfunc (mc *MemoryCache) InvalidateAccounts(ctx context.Context, accountIDs []string, timestamp time.Time) {\n    for _, accountID := range accountIDs {\n        if value, exists := mc.data.Load(accountID); exists {\n            if cached, ok := value.(*CachedBalance); ok && cached.CachedAt.Before(timestamp) {\n                mc.data.Delete(accountID)\n                mc.metrics.RecordInvalidation(accountID)\n            }\n        }\n    }\n}\n```\n\n**Milestone Checkpoint: Component Integration**\n\nAfter implementing the interaction patterns, verify the complete workflow:\n\n1. **Start the ledger server**: `go run cmd/ledger-server/main.go`\n2. **Create test accounts**: POST to `/api/accounts` with asset, liability, and equity accounts\n3. **Post test journal entry**: POST to `/api/journal-entries` with balanced debits and credits\n4. **Verify balance updates**: GET `/api/accounts/{id}/balance` should show updated balances\n5. **Generate trial balance**: GET `/api/reports/trial-balance` should show balanced report\n6. **Check audit trail**: GET `/api/audit/events` should show all system activities\n\nExpected behavior:\n- Journal entry posting completes in under 200ms for simple entries\n- Balance queries return cached results in under 10ms \n- Trial balance generation completes in under 2 seconds\n- All audit events are recorded with proper user attribution\n- Concurrent operations don't create incorrect balances or duplicate entries\n\n**Debugging Tips**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Journal entry posting hangs | Database deadlock or long-running transaction | Check `SHOW PROCESSLIST` in MySQL or `pg_stat_activity` in PostgreSQL | Implement consistent lock ordering and transaction timeouts |\n| Balance queries return stale data | Cache invalidation not working across instances | Check cache invalidation messages and timestamps | Verify message bus configuration and clock synchronization |\n| Trial balance doesn't balance | Concurrent balance updates creating race conditions | Compare sum of all entries to trial balance totals | Implement optimistic locking with retry logic |\n| Reports generation causes timeouts | Report queries blocking transaction posting | Check database connection pool utilization | Use read replicas for report generation |\n| High memory usage during peak load | Cache growing unbounded without TTL enforcement | Monitor cache size and entry expiration | Implement LRU eviction and background cleanup |\n\n\n> **Milestone(s):** 1-5 (All milestones), as robust error handling and recovery mechanisms are essential throughout account modeling, transaction recording, balance calculation, audit trails, and financial reporting\n\n## Error Handling and Edge Cases\n\nBuilding a reliable double-entry ledger system requires comprehensive error handling that maintains the fundamental accounting equation under all conditions. Think of ledger error handling like the safety systems in a nuclear power plant – multiple independent layers that prevent any single failure from compromising the integrity of the entire system. Each layer catches different types of problems, from simple validation errors to catastrophic system failures, ensuring that the accounting records remain accurate and complete.\n\nThe cornerstone principle is **fail-safe accounting integrity** – the system must never allow unbalanced entries, inconsistent balances, or lost transactions, even during partial failures or system crashes. This requires careful design of validation pipelines, atomic transaction boundaries, data corruption detection, and recovery procedures that can restore consistency after any type of failure.\n\n![High-Level System Component Architecture](./diagrams/system-components.svg)\n\n### Validation Error Handling\n\nInput validation forms the first line of defense against data corruption and accounting errors. Like a bank teller who checks every deposit slip before processing, the validation pipeline must verify business rules, data integrity constraints, and accounting principles before any data reaches the permanent ledger.\n\nThe validation system operates in multiple stages, each catching different categories of errors. **Structural validation** ensures that required fields are present and data types are correct. **Business rule validation** verifies that debits equal credits, accounts exist and are active, and amounts are positive. **Consistency validation** checks that account types are compatible with debit/credit operations and that posting dates fall within open accounting periods.\n\n> **Decision: Multi-Stage Validation Pipeline**\n> - **Context**: Journal entries must be validated against numerous business rules before posting, but validation failures should provide clear guidance for correction\n> - **Options Considered**: Single comprehensive validation function, separate validation per business rule, staged validation with early termination\n> - **Decision**: Multi-stage pipeline that accumulates all errors before terminating\n> - **Rationale**: Users need to see all validation problems at once to fix them efficiently, rather than discovering errors one at a time through multiple submission attempts\n> - **Consequences**: More complex validation logic but significantly better user experience and fewer round trips for error correction\n\nThe validation pipeline accumulates all detected errors into a structured result that provides specific guidance for correction. Rather than failing on the first error, the system examines the entire journal entry and reports all problems simultaneously, allowing users to fix multiple issues in a single correction cycle.\n\n| Validation Stage | Purpose | Error Types Caught | Recovery Action |\n|------------------|---------|-------------------|----------------|\n| Schema Validation | Data type and format checking | Missing required fields, invalid data types, malformed currencies | Return field-specific error messages with expected formats |\n| Business Rule Validation | Accounting principle enforcement | Unbalanced debits/credits, negative amounts, duplicate line items | Return rule violation errors with current values and requirements |\n| Reference Validation | Entity existence and status | Non-existent accounts, inactive accounts, closed periods | Return entity status with suggested alternatives |\n| Consistency Validation | Cross-system integrity | Account type compatibility, currency mismatches, duplicate references | Return consistency errors with conflicting values highlighted |\n\n**Detailed validation error reporting** provides the context needed for efficient error correction. Each `ValidationError` includes not only the error message but also the specific field name, invalid value, and suggested correction. This allows client applications to highlight problematic fields and provide inline correction guidance.\n\n```\nValidation Error Example:\n- Code: \"DEBITS_CREDITS_IMBALANCE\"\n- Field: \"Lines\"\n- Message: \"Total debits ($1,250.00) do not equal total credits ($1,200.00). Difference: $50.00\"\n- Value: {\"total_debits\": 1250.00, \"total_credits\": 1200.00, \"difference\": 50.00}\n```\n\nThe validation system maintains a **validation rule registry** that defines each business rule with its error code, message template, and severity level. This allows for consistent error reporting across all system components and enables configuration of validation strictness for different environments or user roles.\n\n| Validation Rule | Error Code | Severity | Description | Suggested Action |\n|----------------|------------|----------|-------------|-----------------|\n| Balance Check | DEBITS_CREDITS_IMBALANCE | Error | Total debits must equal total credits | Adjust line item amounts to balance |\n| Account Existence | ACCOUNT_NOT_FOUND | Error | Referenced account does not exist | Verify account ID or create missing account |\n| Account Status | ACCOUNT_INACTIVE | Warning | Account is marked inactive | Reactivate account or use alternative |\n| Period Status | PERIOD_CLOSED | Error | Cannot post to closed accounting period | Post to current period or request period reopening |\n| Currency Consistency | CURRENCY_MISMATCH | Error | Line item currency differs from account currency | Convert currency or use correct account |\n\n**Idempotency validation** prevents duplicate entry creation when clients retry failed requests. The system maintains an idempotency key registry that maps client-provided keys to processing results, allowing safe request retries without creating duplicate transactions.\n\n> The critical insight is that validation errors should be treated as expected business conditions, not exceptional circumstances. A well-designed validation system prevents most data corruption scenarios by catching errors before they can affect the permanent ledger.\n\n### Partial Failure Recovery\n\nAtomic transaction boundaries ensure that complex operations either complete entirely or leave the system in an unchanged state. Think of this like a bank vault where either all the money transfers complete successfully, or none of them do – there's no middle ground where some transfers succeed and others fail, leaving the vault in an inconsistent state.\n\n**Database transaction management** provides the foundation for atomic operations. Every journal entry posting operation executes within a database transaction that includes entry creation, balance updates, audit logging, and cache invalidation. If any step fails, the entire transaction rolls back, leaving the ledger in its original state.\n\nThe transaction boundary encompasses all related operations to maintain consistency across multiple system components. When posting a journal entry, the system must update the entries table, modify running balances, create audit records, and invalidate cached balances within a single atomic operation.\n\n| Transaction Scope | Operations Included | Rollback Triggers | Recovery Actions |\n|------------------|-------------------|------------------|------------------|\n| Journal Entry Posting | Create entry, validate balance, update balances, audit log | Validation failure, database constraint violation, balance calculation error | Full rollback, return validation errors, preserve idempotency record |\n| Account Creation | Insert account, validate hierarchy, update parent references, audit log | Circular reference detected, duplicate account code, parent account inactive | Full rollback, return hierarchy errors, suggest alternative codes |\n| Balance Recalculation | Lock account, recalculate from entries, update cached balance, verify consistency | Concurrent modification, calculation mismatch, cache update failure | Full rollback, retry with fresh data, escalate if repeated failures |\n| Period Closing | Generate closing entries, post to ledger, update period status, audit trail | Entry posting failure, balance verification failure, approval missing | Full rollback, preserve partial work in staging tables, manual review required |\n\n**Optimistic concurrency control** handles simultaneous access to the same accounts without blocking operations unnecessarily. The system uses version numbers on account balances and journal entries to detect when multiple operations attempt to modify the same data simultaneously.\n\n> **Decision: Optimistic Locking with Version Numbers**\n> - **Context**: Multiple users may attempt to post entries affecting the same accounts simultaneously, requiring coordination to maintain balance consistency\n> - **Options Considered**: Pessimistic row locking, optimistic version-based locking, last-writer-wins\n> - **Decision**: Optimistic locking using version numbers on critical entities\n> - **Rationale**: Accounting systems typically have low contention on individual accounts, making optimistic locking more efficient than blocking approaches\n> - **Consequences**: Better performance under normal conditions but requires retry logic when conflicts occur\n\nWhen a balance update detects that the account version has changed since the balance was read, the system retries the entire operation with fresh data. This approach maximizes concurrency while ensuring that balance calculations always use consistent input data.\n\n**Compensation transaction patterns** handle failures in multi-step business operations that span multiple journal entries. When a complex operation like period closing fails partway through, the system creates compensating entries to reverse any changes that were successfully applied.\n\n```\nExample: Period Closing Failure Recovery\n1. Revenue closing entries posted successfully\n2. Expense closing entries failed due to account validation error\n3. System creates reversal entries to undo revenue closing\n4. Period remains open for correction\n5. Audit trail shows complete sequence including reversals\n```\n\n**Deadlock detection and retry logic** handles database-level conflicts that can occur when multiple transactions access the same resources in different orders. The system implements exponential backoff retry with jitter to avoid retry storms and includes circuit breaker patterns to prevent cascading failures.\n\n| Failure Type | Detection Method | Recovery Strategy | Retry Policy |\n|--------------|-----------------|------------------|--------------|\n| Database Deadlock | SQLException with deadlock error code | Automatic retry with exponential backoff | 3 attempts, 100ms base delay, 2x multiplier |\n| Optimistic Lock Failure | Version mismatch on balance update | Reload fresh data and retry operation | 5 attempts, 50ms base delay, 1.5x multiplier |\n| Connection Timeout | Database connection timeout exception | Retry with new connection from pool | 2 attempts, immediate retry, then fail |\n| Constraint Violation | Database constraint error | Business validation failure, no retry | Immediate failure, return validation error |\n\n### Data Corruption Detection\n\nContinuous integrity monitoring ensures that the ledger remains mathematically consistent and detects any unauthorized modifications to historical records. Like a security system with motion sensors throughout a building, integrity checks operate at multiple levels to catch different types of corruption.\n\n**Trial balance verification** provides the fundamental integrity check for double-entry accounting. The system periodically verifies that the sum of all debit balances equals the sum of all credit balances across all accounts. Any deviation indicates data corruption that requires immediate investigation.\n\nThe trial balance calculation operates independently from the normal balance calculation engine, using different code paths and algorithms to detect errors in the primary balance logic. This provides defense in depth against software bugs that might corrupt balances systematically.\n\n```\nTrial Balance Integrity Check Process:\n1. Lock all accounts to prevent concurrent modifications\n2. Calculate raw balance from journal entry lines for each account\n3. Apply account type sign conventions (assets positive, liabilities negative)\n4. Sum all account balances ensuring zero total\n5. Compare individual account balances with cached running balances\n6. Generate discrepancy report for any differences found\n7. Trigger alert for total imbalance or individual account variances\n```\n\n**Cryptographic hash verification** ensures that posted journal entries remain unchanged after creation. Each entry receives a content hash based on its essential fields, and these hashes form chains that detect unauthorized modifications to historical data.\n\nThe hash chain creates a tamper-evident audit trail where modifying any historical entry breaks the cryptographic chain. The system periodically verifies hash chain integrity and can pinpoint exactly which entries have been modified.\n\n| Hash Type | Purpose | Algorithm | Verification Frequency |\n|-----------|---------|-----------|----------------------|\n| Content Hash | Detect changes to entry data | SHA-256 of entry fields | On every entry access |\n| Chain Hash | Link entries in chronological order | SHA-256 of content + previous hash | Daily batch verification |\n| Merkle Tree | Efficient batch verification | SHA-256 tree of entry hashes | Weekly full verification |\n| Digital Signature | Prove authorized creation | RSA-2048 signature | On-demand for audit |\n\n**Balance consistency verification** compares running balance caches with recalculated balances to detect corruption in the balance calculation system. This check operates continuously in the background, selecting random accounts for verification and escalating any discrepancies found.\n\n> **Decision: Continuous Background Verification**\n> - **Context**: Balance calculation errors may not be immediately apparent but can compound over time, requiring ongoing monitoring\n> - **Options Considered**: Manual periodic verification, on-demand verification only, continuous background checking\n> - **Decision**: Continuous background verification with random sampling and scheduled full sweeps\n> - **Rationale**: Early detection of calculation errors prevents small discrepancies from becoming large problems that are difficult to diagnose\n> - **Consequences**: Additional CPU overhead but much faster detection and resolution of integrity issues\n\nThe verification process maintains a queue of accounts requiring checking and processes them during low-activity periods to minimize performance impact on normal operations. High-priority accounts like cash and major revenue accounts receive more frequent verification.\n\n**Referential integrity monitoring** ensures that all foreign key relationships remain valid and that deleted or modified accounts don't break existing journal entries. The system maintains dependency graphs showing which entries reference which accounts and validates these relationships during maintenance operations.\n\n| Integrity Check | Scope | Detection Method | Response Action |\n|----------------|-------|------------------|----------------|\n| Trial Balance | All accounts | Sum debit/credit balances | Alert and investigate if non-zero |\n| Hash Chain | All journal entries | Verify cryptographic links | Identify modified entries and alert |\n| Balance Cache | Random sample | Compare cached vs calculated | Refresh cache and alert on mismatch |\n| Foreign Keys | All references | Validate account/entry links | Report orphaned references |\n| Audit Trail | All modifications | Verify change completeness | Flag missing or inconsistent audit records |\n\n**Corruption response procedures** define the steps for investigating and resolving detected integrity violations. The system automatically creates incident records that capture the current state, initiate investigation workflows, and track resolution progress.\n\n### System Failure Recovery\n\nStartup integrity verification ensures that the ledger remains consistent after unexpected system shutdowns or crashes. Think of this like a pilot's preflight checklist – a systematic verification of all critical systems before resuming normal operations. The recovery process must detect any incomplete operations and restore the system to a consistent state.\n\n**Transaction log replay** reconstructs the system state by reprocessing any operations that were committed to the database but may not have completed all related tasks like cache updates or audit logging. The system maintains operation logs that track the progress of complex multi-step procedures.\n\nDuring startup, the recovery process scans for incomplete operations and either completes them or rolls them back depending on their current state. This ensures that the system never starts in an inconsistent condition where the database contains partial results from failed operations.\n\n```\nStartup Recovery Process:\n1. Verify database connectivity and basic schema integrity\n2. Scan transaction log for incomplete operations since last clean shutdown\n3. For each incomplete operation, check completion status in database\n4. Complete any operations that were committed but not finalized\n5. Roll back any operations that were started but not committed\n6. Verify trial balance integrity across all accounts\n7. Refresh all cached balances from authoritative database values\n8. Validate hash chain integrity for recent entries\n9. Mark system as operational and enable normal request processing\n```\n\n**Database consistency checks** verify that the fundamental relationships and constraints remain intact after a system failure. These checks go beyond standard foreign key constraints to validate accounting-specific rules like balance equation compliance and entry immutability.\n\nThe consistency verification process runs automatically during startup and can be triggered manually when corruption is suspected. It operates independently from normal system functions to avoid masking problems that might be present in the regular code paths.\n\n| Consistency Check | Purpose | Validation Logic | Recovery Action |\n|------------------|---------|------------------|----------------|\n| Schema Integrity | Verify table structure | Compare current schema with expected definitions | Refuse startup if schema differs |\n| Foreign Key Validation | Ensure reference validity | Check all entry-to-account and parent-child relationships | Report orphaned records for manual review |\n| Immutability Verification | Confirm no historical changes | Verify posted entries match their creation hashes | Flag compromised entries and alert |\n| Balance Equation | Validate accounting rules | Recalculate trial balance and verify zero sum | Emergency investigation if imbalanced |\n| Audit Completeness | Check change tracking | Verify all modifications have corresponding audit records | Flag missing audit trails |\n\n**Backup validation and point-in-time recovery** capabilities allow restoration to any previous consistent state when corruption is detected. The system maintains multiple backup types with different retention periods and recovery characteristics.\n\n> **Decision: Layered Backup Strategy with Continuous WAL Shipping**\n> - **Context**: Financial data requires multiple recovery options to handle different failure scenarios from hardware crashes to data corruption\n> - **Options Considered**: Daily full backups only, incremental backups with weekly fulls, continuous WAL shipping with point-in-time recovery\n> - **Decision**: Continuous WAL shipping with daily full backups and hourly incremental snapshots\n> - **Rationale**: Financial systems require minimal data loss (RPO < 1 minute) and fast recovery (RTO < 30 minutes) which requires continuous replication\n> - **Consequences**: Higher storage and network overhead but much better recovery capabilities and compliance with financial regulations\n\nThe backup system maintains strict chain of custody for financial data, including cryptographic verification of backup integrity and secure storage with access auditing. Recovery procedures include verification steps to ensure that restored data maintains accounting consistency.\n\n**Automated alerting and escalation** procedures ensure that system failures receive immediate attention and follow established incident response protocols. The alerting system distinguishes between routine operational issues and critical integrity violations that require emergency response.\n\nCritical alerts include trial balance imbalances, hash chain verification failures, or any condition that suggests data corruption or unauthorized access. These alerts trigger immediate notifications to accounting management and technical staff with predetermined escalation procedures if not acknowledged promptly.\n\n| Alert Type | Severity | Trigger Condition | Response Time | Escalation Path |\n|------------|----------|------------------|---------------|----------------|\n| Trial Balance Imbalance | Critical | Non-zero trial balance total | Immediate | CFO, CTO, Compliance Officer |\n| Hash Chain Broken | Critical | Cryptographic verification failure | Immediate | Security Team, CTO, Legal |\n| System Startup Failure | High | Recovery process unable to complete | 15 minutes | Operations Team, Engineering Lead |\n| Performance Degradation | Medium | Response time > 5x baseline | 1 hour | Operations Team, DBA |\n| Validation Error Spike | Low | Error rate > 10% of requests | 4 hours | Product Team, Engineering |\n\n⚠️ **Pitfall: Incomplete Error Recovery State**\nMany systems handle the primary error condition but fail to clean up secondary state that was modified during the failed operation. For example, when a journal entry posting fails, the system might successfully roll back the database transaction but forget to clear cached balance values that were calculated during the failed operation. This leaves the system in an inconsistent state where cached values don't match the database. Always include cache invalidation, cleanup of temporary state, and verification of system consistency in error recovery procedures.\n\n⚠️ **Pitfall: Error Masking in Retry Logic**\nAutomatic retry mechanisms can hide systematic problems by repeatedly failing and retrying operations that will never succeed. For instance, if account validation logic contains a bug that always rejects valid entries, the retry system might attempt the same operation dozens of times, generating excessive load and delayed error reporting. Implement retry limits, exponential backoff, and error pattern detection to identify when retries are not helping and should escalate to manual investigation.\n\n⚠️ **Pitfall: Insufficient Error Context**\nError handling code often captures the immediate failure condition but loses the business context that led to the error. When a balance calculation fails, knowing that \"SELECT statement failed\" is less useful than knowing \"failed while calculating balance for account 1001-Cash during posting of journal entry JE-2024-001234 for customer payment transaction.\" Always capture and propagate business context through error handling paths to enable efficient troubleshooting.\n\n⚠️ **Pitfall: Recovery Race Conditions**\nSystem recovery procedures can create race conditions when multiple instances attempt recovery simultaneously or when recovery operations conflict with incoming requests. For example, if the balance cache refresh process runs during startup while normal operations are already processing new entries, the cache might end up containing stale values. Use distributed locks, leader election, or sequential startup procedures to ensure that recovery operations complete atomically before normal request processing begins.\n\n### Implementation Guidance\n\nThe error handling implementation requires careful coordination between validation logic, transaction management, integrity monitoring, and recovery procedures. This section provides the infrastructure and patterns needed to build robust error handling into the ledger system.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|--------------|-----------------|\n| Transaction Management | Go database/sql with manual tx handling | Enterprise transaction coordinator with 2PC |\n| Validation Framework | Custom validation functions with error accumulation | Schema-driven validation with rule engine |\n| Integrity Monitoring | Cron jobs with SQL queries | Real-time stream processing with Kafka |\n| Backup Strategy | pg_dump daily with WAL archiving | Continuous replication with automated failover |\n| Alerting System | Email notifications with basic templating | PagerDuty integration with intelligent escalation |\n| Monitoring Dashboard | Simple Grafana charts with key metrics | Full observability stack with distributed tracing |\n\n#### Recommended File Structure\n\n```\ninternal/\n├── errors/\n│   ├── validation.go           ← validation error types and accumulation\n│   ├── business_rules.go       ← accounting-specific validation rules\n│   ├── recovery.go            ← error recovery and retry logic\n│   └── errors_test.go         ← comprehensive error scenario testing\n├── integrity/\n│   ├── trial_balance.go       ← trial balance verification\n│   ├── hash_chain.go          ← cryptographic integrity checking\n│   ├── consistency.go         ← cross-system consistency validation\n│   └── monitors.go            ← background integrity monitoring\n├── recovery/\n│   ├── startup.go             ← system startup and recovery procedures\n│   ├── backup.go              ← backup validation and restoration\n│   ├── incidents.go           ← incident tracking and escalation\n│   └── alerts.go              ← alerting and notification system\n└── transaction/\n    ├── coordinator.go         ← atomic transaction coordination\n    ├── isolation.go           ← concurrency control and deadlock handling\n    ├── retry.go               ← retry logic with exponential backoff\n    └── compensation.go        ← compensation transaction patterns\n```\n\n#### Infrastructure: Validation Framework\n\n```go\npackage errors\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n    \"github.com/shopspring/decimal\"\n)\n\n// ValidationError represents a specific business rule violation\ntype ValidationError struct {\n    Code    string      `json:\"code\"`\n    Field   string      `json:\"field\"`\n    Message string      `json:\"message\"`\n    Value   interface{} `json:\"value\"`\n}\n\n// ValidationResult accumulates all validation errors and warnings\ntype ValidationResult struct {\n    IsValid  bool              `json:\"is_valid\"`\n    Errors   []ValidationError `json:\"errors\"`\n    Warnings []ValidationError `json:\"warnings\"`\n}\n\n// ValidationRule defines a single business rule check\ntype ValidationRule struct {\n    Code        string\n    Description string\n    Severity    string // \"error\" or \"warning\"\n    CheckFunc   func(ctx context.Context, entry *JournalEntry) *ValidationError\n}\n\n// ValidationRegistry maintains all validation rules\ntype ValidationRegistry struct {\n    rules map[string]ValidationRule\n}\n\n// NewValidationRegistry creates a registry with standard accounting rules\nfunc NewValidationRegistry() *ValidationRegistry {\n    registry := &ValidationRegistry{\n        rules: make(map[string]ValidationRule),\n    }\n    \n    // Register standard accounting validation rules\n    registry.RegisterRule(ValidationRule{\n        Code:        \"DEBITS_CREDITS_BALANCE\",\n        Description: \"Total debits must equal total credits\",\n        Severity:    \"error\",\n        CheckFunc:   validateDebitCreditBalance,\n    })\n    \n    registry.RegisterRule(ValidationRule{\n        Code:        \"ACCOUNT_EXISTS\",\n        Description: \"All referenced accounts must exist and be active\",\n        Severity:    \"error\", \n        CheckFunc:   validateAccountExistence,\n    })\n    \n    registry.RegisterRule(ValidationRule{\n        Code:        \"POSITIVE_AMOUNTS\",\n        Description: \"All line item amounts must be positive\",\n        Severity:    \"error\",\n        CheckFunc:   validatePositiveAmounts,\n    })\n    \n    return registry\n}\n\n// RegisterRule adds a new validation rule to the registry\nfunc (r *ValidationRegistry) RegisterRule(rule ValidationRule) {\n    r.rules[rule.Code] = rule\n}\n\n// ValidateEntry runs all validation rules against a journal entry\nfunc (r *ValidationRegistry) ValidateEntry(ctx context.Context, entry *JournalEntry) *ValidationResult {\n    result := &ValidationResult{\n        IsValid:  true,\n        Errors:   []ValidationError{},\n        Warnings: []ValidationError{},\n    }\n    \n    // Run all validation rules\n    for _, rule := range r.rules {\n        if err := rule.CheckFunc(ctx, entry); err != nil {\n            if rule.Severity == \"error\" {\n                result.Errors = append(result.Errors, *err)\n                result.IsValid = false\n            } else {\n                result.Warnings = append(result.Warnings, *err)\n            }\n        }\n    }\n    \n    return result\n}\n\n// Standard validation rule implementations\nfunc validateDebitCreditBalance(ctx context.Context, entry *JournalEntry) *ValidationError {\n    totalDebits, err := entry.TotalDebits()\n    if err != nil {\n        return &ValidationError{\n            Code:    \"CALCULATION_ERROR\",\n            Field:   \"Lines\",\n            Message: fmt.Sprintf(\"Failed to calculate total debits: %v\", err),\n            Value:   nil,\n        }\n    }\n    \n    totalCredits, err := entry.TotalCredits()\n    if err != nil {\n        return &ValidationError{\n            Code:    \"CALCULATION_ERROR\", \n            Field:   \"Lines\",\n            Message: fmt.Sprintf(\"Failed to calculate total credits: %v\", err),\n            Value:   nil,\n        }\n    }\n    \n    if !totalDebits.Amount.Equal(totalCredits.Amount) {\n        difference := totalDebits.Amount.Sub(totalCredits.Amount)\n        return &ValidationError{\n            Code:  \"DEBITS_CREDITS_IMBALANCE\",\n            Field: \"Lines\",\n            Message: fmt.Sprintf(\n                \"Total debits (%s %s) do not equal total credits (%s %s). Difference: %s\",\n                totalDebits.Amount.String(), totalDebits.Currency,\n                totalCredits.Amount.String(), totalCredits.Currency,\n                difference.Abs().String(),\n            ),\n            Value: map[string]interface{}{\n                \"total_debits\":  totalDebits,\n                \"total_credits\": totalCredits,\n                \"difference\":    difference,\n            },\n        }\n    }\n    \n    return nil\n}\n\nfunc validateAccountExistence(ctx context.Context, entry *JournalEntry) *ValidationError {\n    // TODO: Implement account existence validation\n    // 1. Extract unique account IDs from all entry lines\n    // 2. Query database to verify accounts exist and are active\n    // 3. Return error with list of missing/inactive accounts if any found\n    return nil\n}\n\nfunc validatePositiveAmounts(ctx context.Context, entry *JournalEntry) *ValidationError {\n    // TODO: Implement positive amount validation\n    // 1. Iterate through all entry lines\n    // 2. Check that debit/credit amounts are positive (> 0)\n    // 3. Return error with line numbers of invalid amounts if any found\n    return nil\n}\n```\n\n#### Infrastructure: Transaction Management\n\n```go\npackage transaction\n\nimport (\n    \"context\"\n    \"database/sql\"\n    \"fmt\"\n    \"time\"\n    \"math/rand\"\n)\n\n// TransactionCoordinator manages atomic operations across multiple components\ntype TransactionCoordinator struct {\n    db *sql.DB\n}\n\n// NewTransactionCoordinator creates a new transaction coordinator\nfunc NewTransactionCoordinator(db *sql.DB) *TransactionCoordinator {\n    return &TransactionCoordinator{db: db}\n}\n\n// WithTransaction executes a function within a database transaction\n// Automatically handles rollback on error and commit on success\nfunc (tc *TransactionCoordinator) WithTransaction(ctx context.Context, fn func(tx *sql.Tx) error) error {\n    tx, err := tc.db.BeginTx(ctx, &sql.TxOptions{\n        Isolation: sql.LevelSerializable,\n        ReadOnly:  false,\n    })\n    if err != nil {\n        return fmt.Errorf(\"failed to begin transaction: %w\", err)\n    }\n    \n    defer func() {\n        if p := recover(); p != nil {\n            tx.Rollback()\n            panic(p)\n        }\n    }()\n    \n    if err := fn(tx); err != nil {\n        if rbErr := tx.Rollback(); rbErr != nil {\n            return fmt.Errorf(\"transaction failed: %w, rollback failed: %v\", err, rbErr)\n        }\n        return err\n    }\n    \n    if err := tx.Commit(); err != nil {\n        return fmt.Errorf(\"failed to commit transaction: %w\", err)\n    }\n    \n    return nil\n}\n\n// RetryConfig defines retry behavior for failed operations\ntype RetryConfig struct {\n    MaxAttempts  int\n    BaseDelay    time.Duration\n    MaxDelay     time.Duration\n    Multiplier   float64\n    Jitter       bool\n}\n\n// DefaultRetryConfig provides sensible defaults for most operations\nvar DefaultRetryConfig = RetryConfig{\n    MaxAttempts: 3,\n    BaseDelay:   100 * time.Millisecond,\n    MaxDelay:    5 * time.Second,\n    Multiplier:  2.0,\n    Jitter:      true,\n}\n\n// WithRetry executes an operation with exponential backoff retry logic\nfunc (tc *TransactionCoordinator) WithRetry(ctx context.Context, config RetryConfig, operation func() error) error {\n    var lastErr error\n    \n    for attempt := 1; attempt <= config.MaxAttempts; attempt++ {\n        lastErr = operation()\n        if lastErr == nil {\n            return nil // Success\n        }\n        \n        // Check if error is retryable\n        if !isRetryableError(lastErr) {\n            return lastErr\n        }\n        \n        // Don't sleep on the last attempt\n        if attempt == config.MaxAttempts {\n            break\n        }\n        \n        // Calculate delay with exponential backoff\n        delay := time.Duration(float64(config.BaseDelay) * \n            math.Pow(config.Multiplier, float64(attempt-1)))\n        if delay > config.MaxDelay {\n            delay = config.MaxDelay\n        }\n        \n        // Add jitter to prevent thundering herd\n        if config.Jitter {\n            jitterRange := int64(delay / 4) // 25% jitter\n            jitter := time.Duration(rand.Int63n(jitterRange*2) - jitterRange)\n            delay += jitter\n        }\n        \n        select {\n        case <-ctx.Done():\n            return ctx.Err()\n        case <-time.After(delay):\n            continue\n        }\n    }\n    \n    return fmt.Errorf(\"operation failed after %d attempts, last error: %w\", \n        config.MaxAttempts, lastErr)\n}\n\n// isRetryableError determines if an error indicates a transient condition\nfunc isRetryableError(err error) bool {\n    // TODO: Implement retryable error detection\n    // 1. Check for database deadlock errors\n    // 2. Check for connection timeout errors  \n    // 3. Check for optimistic lock failures\n    // 4. Return false for business validation errors\n    // 5. Return true for transient infrastructure errors\n    return false\n}\n```\n\n#### Core Logic: Integrity Monitoring\n\n```go\npackage integrity\n\nimport (\n    \"context\"\n    \"crypto/sha256\"\n    \"encoding/hex\"\n    \"fmt\"\n    \"time\"\n)\n\n// IntegrityMonitor performs continuous consistency checking\ntype IntegrityMonitor struct {\n    // Dependencies injected during construction\n}\n\n// MonitorConfig defines monitoring behavior and thresholds\ntype MonitorConfig struct {\n    TrialBalanceCheckInterval time.Duration\n    HashVerificationInterval  time.Duration\n    RandomSampleSize         int\n    AlertThreshold           time.Duration\n}\n\n// NewIntegrityMonitor creates a monitor with background checking\nfunc NewIntegrityMonitor(config MonitorConfig) *IntegrityMonitor {\n    // TODO: Initialize monitor with configuration\n    // 1. Set up periodic goroutines for different check types\n    // 2. Initialize alert channels and escalation procedures\n    // 3. Configure sampling parameters for random verification\n    return nil\n}\n\n// VerifyTrialBalance checks that all account balances sum to zero\nfunc (im *IntegrityMonitor) VerifyTrialBalance(ctx context.Context) error {\n    // TODO: Implement comprehensive trial balance verification\n    // 1. Lock accounts to prevent concurrent modifications\n    // 2. Calculate raw balance from journal entries for each account\n    // 3. Apply account type sign conventions (assets +, liabilities -)\n    // 4. Sum all balances ensuring total equals zero\n    // 5. Compare individual balances with cached running balances\n    // 6. Generate detailed discrepancy report for investigation\n    // 7. Trigger critical alert if total imbalance detected\n    return nil\n}\n\n// VerifyHashChain validates cryptographic integrity of entries\nfunc (im *IntegrityMonitor) VerifyHashChain(ctx context.Context, startDate time.Time, endDate time.Time) error {\n    // TODO: Implement hash chain verification\n    // 1. Query entries in chronological order within date range\n    // 2. Recalculate content hash for each entry\n    // 3. Verify chain hash links between consecutive entries\n    // 4. Check that no entries have been modified since creation\n    // 5. Report any broken links or modified entries\n    // 6. Update verification timestamps for successfully checked entries\n    return nil\n}\n\n// GenerateContentHash creates a deterministic hash for journal entry\nfunc GenerateContentHash(entry *JournalEntry) string {\n    // TODO: Implement deterministic content hashing\n    // 1. Serialize entry fields in canonical order (ID, date, description, lines)\n    // 2. Include line items sorted by line number\n    // 3. Use consistent number formatting for amounts\n    // 4. Calculate SHA-256 hash of serialized content\n    // 5. Return hex-encoded hash string\n    // Hint: Sort fields alphabetically and use fixed-point decimal representation\n    return \"\"\n}\n\n// CheckBalanceConsistency compares cached vs calculated balances\nfunc (im *IntegrityMonitor) CheckBalanceConsistency(ctx context.Context, accountIDs []string) error {\n    // TODO: Implement balance consistency verification\n    // 1. For each account, get cached running balance\n    // 2. Recalculate balance from all posted journal entries\n    // 3. Compare calculated vs cached values\n    // 4. Report discrepancies with detailed context\n    // 5. Optionally refresh cache if discrepancies found\n    // 6. Track verification history for trending analysis\n    return nil\n}\n```\n\n#### Core Logic: System Recovery\n\n```go\npackage recovery\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\n// SystemRecovery handles startup consistency verification and failure recovery\ntype SystemRecovery struct {\n    // Dependencies injected during construction\n}\n\n// RecoveryConfig defines recovery procedures and timeouts\ntype RecoveryConfig struct {\n    StartupTimeout    time.Duration\n    VerificationDepth int // Days of history to verify\n    AutoRepairEnabled bool\n}\n\n// NewSystemRecovery creates recovery manager with configuration\nfunc NewSystemRecovery(config RecoveryConfig) *SystemRecovery {\n    return &SystemRecovery{}\n}\n\n// PerformStartupRecovery executes complete system consistency check\nfunc (sr *SystemRecovery) PerformStartupRecovery(ctx context.Context) error {\n    // TODO: Implement comprehensive startup recovery\n    // 1. Verify database connectivity and schema integrity\n    // 2. Scan for incomplete operations from previous shutdown\n    // 3. Complete or rollback partial operations\n    // 4. Verify trial balance across all accounts\n    // 5. Refresh all cached balances from database\n    // 6. Validate recent hash chain integrity\n    // 7. Mark system operational only after all checks pass\n    // 8. Generate startup report with any issues found\n    return nil\n}\n\n// DetectIncompleteOperations finds operations interrupted by system failure\nfunc (sr *SystemRecovery) DetectIncompleteOperations(ctx context.Context) ([]IncompleteOperation, error) {\n    // TODO: Implement incomplete operation detection\n    // 1. Query operation log for entries since last clean shutdown\n    // 2. Check completion status in database for each operation\n    // 3. Identify operations that started but didn't finish\n    // 4. Categorize by operation type and required recovery action\n    // 5. Return list of operations requiring completion or rollback\n    return nil, nil\n}\n\n// RepairInconsistencies attempts to fix detected data problems\nfunc (sr *SystemRecovery) RepairInconsistencies(ctx context.Context, issues []ConsistencyIssue) error {\n    // TODO: Implement automatic inconsistency repair\n    // 1. Analyze each consistency issue type\n    // 2. Determine if automatic repair is safe and possible\n    // 3. Create compensating transactions for balance discrepancies\n    // 4. Refresh caches for stale cached values\n    // 5. Log all repair actions taken for audit trail\n    // 6. Escalate to manual review if automatic repair not possible\n    return nil\n}\n\n// ValidateSystemState performs comprehensive consistency verification\nfunc (sr *SystemRecovery) ValidateSystemState(ctx context.Context) (*SystemStateReport, error) {\n    // TODO: Implement complete system state validation\n    // 1. Verify trial balance integrity\n    // 2. Check all foreign key relationships\n    // 3. Validate audit trail completeness\n    // 4. Verify hash chain integrity\n    // 5. Check balance cache consistency\n    // 6. Generate comprehensive status report\n    // 7. Include recommendations for any issues found\n    return nil, nil\n}\n\n// IncompleteOperation represents an operation that needs recovery\ntype IncompleteOperation struct {\n    OperationID   string\n    OperationType string\n    StartedAt     time.Time\n    LastActivity  time.Time\n    CurrentState  string\n    RecoveryAction string\n}\n\n// ConsistencyIssue represents a detected data integrity problem\ntype ConsistencyIssue struct {\n    IssueType   string\n    Severity    string\n    Description string\n    AffectedIDs []string\n    RepairAction string\n}\n\n// SystemStateReport summarizes system health after validation\ntype SystemStateReport struct {\n    ValidationTime    time.Time\n    OverallStatus     string\n    IssuesFound       []ConsistencyIssue\n    RepairActions     []string\n    OperationalStatus string\n    Recommendations   []string\n}\n```\n\n#### Milestone Checkpoints\n\n**Milestone 1: Basic Validation Framework**\n- Run: `go test ./internal/errors/... -v`\n- Expected: All validation rules pass for valid entries, reject unbalanced entries\n- Manual test: Submit journal entry with debits != credits, verify detailed error message\n- Signs of problems: Generic error messages, validation bypassed, missing field context\n\n**Milestone 2: Transaction Coordination**\n- Run: `go test ./internal/transaction/... -race -v`\n- Expected: Atomic operations with proper rollback, retry logic handles deadlocks\n- Manual test: Simulate database failure during posting, verify clean rollback\n- Signs of problems: Partial data persisted, deadlocks not resolved, inconsistent state\n\n**Milestone 3: Integrity Monitoring**\n- Run: `go test ./internal/integrity/... -v`\n- Expected: Trial balance verification catches imbalances, hash verification detects changes\n- Manual test: Manually modify posted entry, verify integrity check detects tampering\n- Signs of problems: False positives/negatives, performance degradation, missed corruption\n\n**Milestone 4: Recovery Procedures**\n- Run: `go test ./internal/recovery/... -v`\n- Expected: Clean startup after simulated crashes, automatic repair of minor issues\n- Manual test: Kill system during posting, verify clean recovery on restart\n- Signs of problems: Startup failures, undetected corruption, lost transactions\n\n\n> **Milestone(s):** 1-5 (All milestones), as comprehensive testing strategies are essential throughout account modeling, transaction recording, balance calculation, audit trails, and financial reporting to ensure system reliability and accounting accuracy\n\n## Testing Strategy\n\nBuilding a double-entry accounting system requires a rigorous testing approach that goes beyond traditional software testing. Think of testing an accounting system like auditing a bank's books - you need to verify not just that individual calculations are correct, but that the entire system maintains fundamental accounting principles under all conditions. Every test must validate that debits equal credits, balances remain consistent, and the audit trail provides complete traceability.\n\nThe testing strategy for our ledger system follows a multi-layered approach that mirrors how real accounting firms verify financial records. Just as auditors use sampling techniques, analytical procedures, and substantive tests, our testing strategy combines unit tests for individual components, integration tests for end-to-end workflows, and property-based tests that verify accounting invariants hold under all conditions.\n\n**Testing Philosophy for Financial Systems**\n\nTesting an accounting system differs fundamentally from testing typical business applications because accounting has mathematical invariants that must always hold true. The most critical invariant is the **accounting equation**: Assets = Liabilities + Equity, which means the trial balance must always sum to zero. Unlike web applications where minor bugs might cause user inconvenience, accounting bugs can result in regulatory violations, financial misstatements, and legal liability.\n\nThink of our testing approach like a three-tier verification system used by accounting firms. The first tier (unit tests) is like checking individual calculations - ensuring that each component performs its mathematical operations correctly in isolation. The second tier (integration tests) is like checking complete business processes - verifying that posting journal entries updates all related systems correctly. The third tier (property-based tests) is like performing analytical procedures - using randomized data to verify that fundamental accounting relationships always hold.\n\n> **Critical Testing Principle**\n> \n> Every test in an accounting system must verify both functional correctness (does the code work?) and accounting integrity (does the result maintain double-entry principles?). A test that passes functionally but allows unbalanced entries is considered a failure.\n\n### Unit Testing Approach\n\nUnit testing for the ledger system focuses on testing individual components in isolation while verifying they maintain accounting integrity. Each component has specific mathematical and business rules that must be validated independently before testing component interactions.\n\n**Account Management Unit Tests**\n\nThe Account Management component requires tests that verify account creation, hierarchy validation, and type-specific behavior. These tests ensure the chart of accounts maintains proper structure and enforces business rules.\n\n| Test Category | Test Method | Validation Focus | Expected Behavior |\n|---------------|-------------|------------------|-------------------|\n| Account Creation | `TestCreateAccount_ValidTypes` | Account type validation | Successfully creates accounts for each type (ASSET, LIABILITY, EQUITY, REVENUE, EXPENSE) |\n| Account Creation | `TestCreateAccount_InvalidParent` | Hierarchy validation | Rejects account creation when parent doesn't exist or would create circular reference |\n| Account Creation | `TestCreateAccount_DuplicateCode` | Uniqueness constraints | Prevents creating accounts with duplicate codes within same parent |\n| Normal Balance | `TestNormalBalance_AssetAccounts` | Balance calculation rules | Asset and expense accounts return DEBIT as normal balance |\n| Normal Balance | `TestNormalBalance_LiabilityAccounts` | Balance calculation rules | Liability, equity, and revenue accounts return CREDIT as normal balance |\n| Hierarchy Validation | `TestValidateAccountHierarchy_CircularReference` | Structure integrity | Detects and prevents circular parent-child relationships |\n| Account Deactivation | `TestDeactivateAccount_WithBalance` | Business rule enforcement | Prevents deactivating accounts with non-zero balances |\n\n**Journal Entry Validation Unit Tests**\n\nJournal entry validation is the heart of double-entry bookkeeping enforcement. These tests verify that the validation engine catches all possible violations of accounting rules before entries reach the posting stage.\n\n| Test Category | Test Method | Validation Focus | Expected Behavior |\n|---------------|-------------|------------------|-------------------|\n| Balance Validation | `TestValidateEntry_UnbalancedEntry` | Double-entry enforcement | Rejects entries where total debits ≠ total credits |\n| Balance Validation | `TestValidateEntry_BalancedEntry` | Double-entry verification | Accepts entries where total debits = total credits |\n| Amount Validation | `TestValidateEntry_NegativeAmounts` | Data integrity | Rejects entries with negative debit or credit amounts |\n| Amount Validation | `TestValidateEntry_ZeroAmounts` | Data integrity | Rejects entries with zero amounts on debit or credit lines |\n| Account Validation | `TestValidateEntry_InactiveAccounts` | Business rule enforcement | Rejects entries referencing deactivated accounts |\n| Account Validation | `TestValidateEntry_NonexistentAccounts` | Data integrity | Rejects entries referencing accounts that don't exist |\n| Currency Validation | `TestValidateEntry_MixedCurrencies` | Multi-currency rules | Handles entries with multiple currencies using exchange rates |\n| Line Item Validation | `TestValidateEntry_EmptyLines` | Data completeness | Rejects entries with no debit or credit lines |\n\n**Balance Calculation Unit Tests**\n\nBalance calculation tests verify that the balance engine performs mathematical operations correctly and maintains consistency between cached and calculated values. These tests are critical because balance errors can cascade throughout the entire system.\n\n| Test Category | Test Method | Validation Focus | Expected Behavior |\n|---------------|-------------|------------------|-------------------|\n| Running Balance | `TestUpdateRunningBalance_SingleEntry` | Incremental updates | Correctly updates account balance after posting single entry |\n| Running Balance | `TestUpdateRunningBalance_MultipleEntries` | Incremental updates | Maintains correct balance through sequence of multiple entries |\n| Point-in-Time Balance | `TestGetBalanceAsOf_HistoricalDate` | Historical accuracy | Returns correct balance considering only entries posted by specified date |\n| Point-in-Time Balance | `TestGetBalanceAsOf_FutureDate` | Edge case handling | Returns current balance when querying future date |\n| Account Type Handling | `TestCalculateBalance_AssetAccount` | Sign conventions | Asset account balances increase with debits, decrease with credits |\n| Account Type Handling | `TestCalculateBalance_LiabilityAccount` | Sign conventions | Liability account balances increase with credits, decrease with debits |\n| Cache Consistency | `TestBalanceCache_InvalidationOnUpdate` | Cache management | Cached balances are invalidated and recalculated when new entries posted |\n| Multi-Currency Balance | `TestCalculateBalance_ForeignCurrency` | Currency handling | Balances calculated correctly for accounts in non-base currencies |\n\n**Monetary Amount Unit Tests**\n\nMonetary calculations require special attention because floating-point arithmetic can introduce rounding errors that violate accounting precision requirements. All money calculations must use fixed-point arithmetic to ensure exactness.\n\n| Test Category | Test Method | Validation Focus | Expected Behavior |\n|---------------|-------------|------------------|-------------------|\n| Basic Operations | `TestMoney_AddSameCurrency` | Arithmetic accuracy | Adding two amounts in same currency produces exact result |\n| Basic Operations | `TestMoney_SubtractSameCurrency` | Arithmetic accuracy | Subtracting amounts in same currency produces exact result |\n| Currency Validation | `TestMoney_AddDifferentCurrencies` | Business rule enforcement | Adding amounts in different currencies returns validation error |\n| Precision Handling | `TestMoney_PrecisionPreservation` | Mathematical accuracy | Operations preserve decimal precision without floating-point errors |\n| Zero Handling | `TestMoney_ZeroAmountOperations` | Edge case handling | Operations with zero amounts behave correctly |\n| Negative Handling | `TestMoney_NegativeAmountOperations` | Mathematical accuracy | Negative amounts handled correctly in arithmetic operations |\n| String Representation | `TestMoney_FormattingConsistency` | Display accuracy | String formatting maintains precision and currency symbol |\n\n> **Decision: Fixed-Point Arithmetic for Monetary Values**\n> - **Context**: Financial calculations require exact precision to prevent rounding errors that could accumulate and cause trial balance discrepancies\n> - **Options Considered**: \n>   - Floating-point arithmetic (float64) with rounding\n>   - Fixed-point decimal arithmetic using dedicated library\n>   - Integer-based arithmetic storing cents/smallest currency unit\n> - **Decision**: Use fixed-point decimal arithmetic with `shopspring/decimal` library\n> - **Rationale**: Provides exact decimal arithmetic without floating-point precision issues, supports arbitrary precision, and handles currency formatting naturally\n> - **Consequences**: Requires explicit decimal operations instead of native arithmetic operators, but eliminates entire class of precision-related bugs\n\n**Audit Trail Unit Tests**\n\nAudit trail testing verifies that all changes are captured accurately and that the immutable logging system maintains integrity. These tests ensure compliance with regulatory requirements for financial record keeping.\n\n| Test Category | Test Method | Validation Focus | Expected Behavior |\n|---------------|-------------|------------------|-------------------|\n| Change Tracking | `TestTrackChanges_FieldModification` | Audit completeness | Records before/after values for all modified fields |\n| Change Tracking | `TestTrackChanges_StateTransition` | Status tracking | Captures state changes with user context and business reason |\n| Immutability | `TestAuditEvent_ImmutableStorage` | Data integrity | Audit records cannot be modified after creation |\n| Hash Chain | `TestIntegrityRecord_HashChainValidation` | Cryptographic integrity | Each record's hash correctly links to previous record |\n| User Context | `TestAuditEvent_UserMetadataCapture` | Accountability | Records user ID, session, IP address, and action reason |\n| Event Querying | `TestGetEventHistory_DateRangeFilter` | Audit reporting | Retrieves complete change history for specified time periods |\n\n### Integration Testing Strategy\n\nIntegration testing verifies that components work together correctly to maintain accounting integrity throughout complete business workflows. These tests simulate real accounting scenarios from journal entry creation through financial report generation.\n\n**End-to-End Transaction Posting Workflow**\n\nThe transaction posting workflow represents the most critical integration test because it touches every component in the system. Think of this test like tracing a single invoice through an entire accounting system - from initial entry through trial balance verification.\n\n| Test Scenario | Components Involved | Workflow Steps | Verification Points |\n|---------------|-------------------|----------------|-------------------|\n| Simple Sale Transaction | Account Manager, Transaction Recorder, Balance Engine, Audit System | 1. Create customer and revenue accounts<br/>2. Submit journal entry (debit A/R, credit Revenue)<br/>3. Validate entry balance<br/>4. Post entry atomically<br/>5. Update running balances<br/>6. Record audit events | Trial balance remains balanced<br/>Account balances updated correctly<br/>Audit trail captured completely<br/>Entry status changed to POSTED |\n| Multi-Currency Transaction | Account Manager, Transaction Recorder, Balance Engine, Currency Handler | 1. Create USD and EUR accounts<br/>2. Submit entry with exchange rate<br/>3. Validate currency conversion<br/>4. Post with atomic transaction<br/>5. Update balances in native currencies | Exchange rate applied correctly<br/>Both currency balances updated<br/>Translation audit trail recorded |\n| Complex Multi-Account Entry | All components | 1. Create expense allocation entry<br/>2. Split expense across 5 departments<br/>3. Validate total debits = credits<br/>4. Post atomically<br/>5. Update all affected balances | All 6 accounts updated correctly<br/>Trial balance maintained<br/>Partial failure triggers rollback |\n\n**Concurrent Transaction Processing**\n\nModern accounting systems must handle multiple simultaneous transactions without creating inconsistencies. These integration tests verify that concurrent operations maintain data integrity through proper transaction isolation and locking.\n\n| Test Scenario | Concurrency Pattern | Expected Behavior | Failure Conditions |\n|---------------|-------------------|-------------------|-------------------|\n| Simultaneous Balance Updates | Multiple threads updating same account | Only one update succeeds per account per transaction | No lost updates or dirty reads |\n| Competing Idempotency Keys | Same idempotency key from multiple clients | First request processes, subsequent requests return same result | No duplicate journal entries created |\n| Period Closing Race Condition | Normal entry vs period closing | Period closing waits for in-flight transactions | No entries posted to closed periods |\n| Audit Log Contention | High-volume concurrent changes | All changes logged in correct order | No missing audit events |\n\n**Balance Calculation Integration Tests**\n\nBalance calculation integration tests verify that the balance engine maintains consistency across all caching layers and calculation methods. These tests ensure that cached balances always match recalculated balances.\n\n| Test Scenario | Integration Points | Test Data | Verification Method |\n|---------------|------------------|-----------|-------------------|\n| Cache Consistency Verification | Balance Engine + Database + Memory Cache | Post 100 random transactions | Compare cached vs calculated balances for all accounts |\n| Historical Balance Accuracy | Balance Engine + Transaction Recorder | Post transactions across 6-month period | Verify point-in-time balances match historical calculations |\n| Trial Balance Integrity | Balance Engine + All Account Types | Mixed asset/liability/equity/revenue/expense transactions | Trial balance sums to exactly zero |\n| Multi-Currency Trial Balance | Balance Engine + Currency Handler | Transactions in USD, EUR, GBP | Trial balance in each currency balanced separately |\n\n**Report Generation Integration Tests**\n\nFinancial report generation tests verify that reports accurately reflect the underlying transaction data and maintain proper accounting relationships. These tests ensure that balance sheets balance and income statements tie to trial balance changes.\n\n| Report Type | Integration Dependencies | Test Validation | Mathematical Relationships |\n|-------------|------------------------|-----------------|--------------------------|\n| Trial Balance | Balance Engine + Account Manager | All accounts listed with correct balances | Total debits = Total credits = 0 |\n| Balance Sheet | Trial Balance + Report Generator + Currency Handler | Assets = Liabilities + Equity | Fundamental accounting equation verified |\n| Income Statement | Trial Balance + Period Manager | Net Income calculation | Revenue - Expenses = Net Income |\n| Cash Flow Statement | Income Statement + Balance Sheet + Transaction Classifier | Cash flow sections balanced | Operating + Investing + Financing = Net Cash Change |\n\n> **Testing Insight: The Trial Balance as Integration Test Oracle**\n> \n> The trial balance serves as the ultimate integration test oracle for any accounting system. If the trial balance doesn't sum to zero after any sequence of operations, the system has a fundamental integrity problem. Every integration test should verify trial balance integrity as its final assertion.\n\n### Property-Based Testing\n\nProperty-based testing uses randomly generated test data to verify that accounting invariants hold under all possible conditions. Think of this approach like stress-testing a bridge - instead of testing with known loads, you generate thousands of random load combinations to find the breaking point.\n\n**Accounting Invariant Verification**\n\nThe most important properties to test are the fundamental accounting equations and relationships that must always hold true regardless of transaction volume or complexity.\n\n| Property | Mathematical Expression | Test Generation Strategy | Violation Detection |\n|----------|------------------------|-------------------------|-------------------|\n| Trial Balance Equality | Σ(Debit Balances) = Σ(Credit Balances) | Generate 1000+ random transactions across all account types | Assert trial balance sums to zero after each transaction batch |\n| Accounting Equation | Assets = Liabilities + Equity | Generate mixed transaction types affecting balance sheet accounts | Verify equation holds after each transaction sequence |\n| Revenue/Expense Impact | Net Income = Revenue - Expenses | Generate income statement transactions over random periods | Verify income statement ties to equity changes |\n| Multi-Currency Consistency | Trial Balance per Currency = 0 | Generate transactions in multiple currencies with random exchange rates | Each currency trial balance sums to zero independently |\n\n**Double-Entry Enforcement Properties**\n\nThese properties verify that the double-entry principle is maintained under all conditions, including edge cases and boundary conditions that might not be covered by traditional unit tests.\n\n| Property | Description | Test Data Generation | Expected Invariant |\n|----------|-------------|---------------------|-------------------|\n| Entry Balance Requirement | Every journal entry debits = credits | Generate entries with 1-50 lines, random amounts | All valid entries have balanced debits/credits |\n| Atomic Posting Guarantee | Either all lines post or none post | Inject failures during posting process | No partially posted entries exist |\n| Balance Conservation | Total system balance unchanged by internal transfers | Generate transfer entries between accounts | System-wide balance unchanged |\n| Historical Immutability | Posted entries cannot be modified | Attempt modifications to posted entries | All modification attempts fail |\n\n**Performance and Scalability Properties**\n\nProperty-based testing can also verify performance characteristics by generating workloads of varying sizes and complexity patterns.\n\n| Performance Property | Measurement Target | Load Generation Pattern | Acceptance Criteria |\n|---------------------|-------------------|------------------------|-------------------|\n| Balance Query Performance | GetCurrentBalance response time | Query random accounts after posting N transactions | Sub-second response for N < 1M transactions |\n| Concurrent Transaction Throughput | Transactions per second | Multiple threads posting non-conflicting entries | Linear throughput scaling with thread count |\n| Report Generation Scalability | Report generation time | Generate reports after posting varying transaction volumes | Report time grows sub-linearly with transaction count |\n| Audit Query Performance | Historical query response time | Random date range queries across transaction history | Historical queries complete within reasonable time bounds |\n\n**Property-Based Test Implementation Strategy**\n\nProperty-based testing requires careful design of data generators that create realistic but varied test scenarios. The generators must create valid accounting data while exploring edge cases and boundary conditions.\n\n| Generator Type | Data Generation Strategy | Constraints Applied | Edge Cases Covered |\n|----------------|-------------------------|-------------------|-------------------|\n| Account Generator | Create realistic chart of accounts structure | Valid account types and hierarchy relationships | Deep nesting, circular reference attempts, missing parents |\n| Transaction Generator | Generate valid double-entry transactions | Debits must equal credits, positive amounts only | Large amounts, many lines, mixed currencies |\n| Date Generator | Create realistic posting date sequences | Chronological order with some variation | Year boundaries, leap years, timezone transitions |\n| Currency Generator | Multi-currency transaction scenarios | Valid currency codes, realistic exchange rates | Rate fluctuations, currency pairs, conversion precision |\n\n> **Decision: Property-Based Testing for Financial Invariants**\n> - **Context**: Traditional example-based tests might miss edge cases that violate fundamental accounting principles under unusual but valid conditions\n> - **Options Considered**:\n>   - Manual test case creation covering known scenarios\n>   - Property-based testing with generated data\n>   - Hybrid approach with both manual and generated tests\n> - **Decision**: Implement comprehensive property-based tests for accounting invariants while maintaining manual tests for specific business scenarios\n> - **Rationale**: Financial systems have mathematical properties that must hold universally, making them ideal candidates for property-based verification\n> - **Consequences**: Requires investment in test data generators and property definition, but provides much higher confidence in system correctness\n\n### Milestone Verification Checkpoints\n\nEach development milestone requires specific testing checkpoints that verify both functional completion and accounting integrity. These checkpoints serve as gates before proceeding to the next milestone.\n\n**Milestone 1: Account & Entry Model Verification**\n\nThe first milestone focuses on establishing the foundational data model and basic validation rules. Testing at this stage ensures the core structures support proper accounting principles.\n\n| Verification Area | Test Command | Expected Output | Success Criteria |\n|------------------|-------------|-----------------|------------------|\n| Account Type Validation | `go test ./internal/account -v -run TestAccountTypes` | All account types created successfully with correct normal balances | ASSET/EXPENSE return DEBIT normal balance, LIABILITY/EQUITY/REVENUE return CREDIT |\n| Account Hierarchy | `go test ./internal/account -v -run TestHierarchy` | Parent-child relationships validated, circular references rejected | Account trees can be created and traversed correctly |\n| Journal Entry Structure | `go test ./internal/entry -v -run TestEntryValidation` | Entry validation rules enforce double-entry principles | Unbalanced entries rejected, balanced entries accepted |\n| Multi-Currency Support | `go test ./internal/money -v -run TestCurrency` | Money operations handle multiple currencies correctly | Same-currency operations succeed, cross-currency operations require explicit conversion |\n\n**Milestone 1 Manual Verification Checklist:**\n\n1. Create chart of accounts with all five account types (Asset, Liability, Equity, Revenue, Expense)\n2. Verify account codes are unique and hierarchy is navigable\n3. Attempt to create unbalanced journal entry - should be rejected\n4. Create balanced journal entry - should be accepted but not posted\n5. Verify currency handling prevents invalid cross-currency operations\n\n**Milestone 2: Transaction Recording Verification**\n\nThe second milestone adds atomic transaction posting with idempotency and audit trail creation. Testing verifies that transactions post completely or not at all.\n\n| Verification Area | Test Command | Expected Output | Success Criteria |\n|------------------|-------------|-----------------|------------------|\n| Atomic Posting | `go test ./internal/transaction -v -run TestAtomicPosting` | Complete transaction success or complete rollback on failure | No partially posted entries in database |\n| Idempotency | `go test ./internal/transaction -v -run TestIdempotency` | Duplicate requests return same result without side effects | Same idempotency key produces identical results |\n| Entry Reversal | `go test ./internal/transaction -v -run TestReversal` | Reversal entries created correctly, original entries unchanged | Reversals zero out original entries without deletion |\n| Batch Processing | `go test ./internal/transaction -v -run TestBatch` | Multiple entries posted atomically in single transaction | All-or-nothing behavior for entry batches |\n\n**Milestone 2 Manual Verification Checklist:**\n\n1. Post simple two-line journal entry (debit Cash, credit Revenue) - verify it appears in posted status\n2. Attempt to post duplicate entry with same idempotency key - should return original result\n3. Create reversal entry for posted transaction - verify original remains and reversal offsets it\n4. Simulate database failure during posting - verify no partial entries exist\n\n**Milestone 3: Balance Calculation Verification**\n\nThe third milestone implements efficient balance calculation with caching and point-in-time queries. Testing verifies balance accuracy and performance.\n\n| Verification Area | Test Command | Expected Output | Success Criteria |\n|------------------|-------------|-----------------|------------------|\n| Running Balance Updates | `go test ./internal/balance -v -run TestRunningBalance` | Account balances updated correctly after each posting | Cached balances match calculated balances |\n| Historical Balance Queries | `go test ./internal/balance -v -run TestHistoricalBalance` | Point-in-time balances calculated correctly | Historical balances match manual calculation |\n| Trial Balance Generation | `go test ./internal/balance -v -run TestTrialBalance` | Trial balance sums to zero across all scenarios | Total debits exactly equal total credits |\n| Balance Cache Performance | `go test ./internal/balance -v -run TestCachePerformance` | Balance queries return within performance thresholds | Sub-second response times for typical workloads |\n\n**Milestone 3 Manual Verification Checklist:**\n\n1. Post several transactions and verify account balances update correctly\n2. Query balance \"as of\" historical date - should match manual calculation\n3. Generate trial balance - total debits should equal total credits exactly\n4. Verify balance cache invalidation when new transactions posted\n\n**Milestone 4: Audit Trail Verification**\n\nThe fourth milestone adds immutable audit logging with cryptographic integrity. Testing verifies complete change tracking and tamper detection.\n\n| Verification Area | Test Command | Expected Output | Success Criteria |\n|------------------|-------------|-----------------|------------------|\n| Change Tracking | `go test ./internal/audit -v -run TestChangeTracking` | All modifications captured with complete metadata | Every change has before/after values, user context, timestamp |\n| Immutable Storage | `go test ./internal/audit -v -run TestImmutable` | Audit records cannot be modified after creation | Update/delete operations on audit records fail |\n| Hash Chain Integrity | `go test ./internal/audit -v -run TestHashChain` | Cryptographic chain links all records correctly | Each record's hash validates against previous record |\n| Audit Report Generation | `go test ./internal/audit -v -run TestReporting` | Complete audit trails generated for specified periods | All changes within date range included in reports |\n\n**Milestone 4 Manual Verification Checklist:**\n\n1. Post transaction and verify audit events captured for all changes\n2. Attempt to modify audit record directly in database - should fail or be detected\n3. Generate audit report for date range - should include all relevant changes\n4. Verify hash chain integrity across sample of records\n\n**Milestone 5: Financial Reports Verification**\n\nThe final milestone adds standard financial statement generation. Testing verifies mathematical accuracy and proper account classification.\n\n| Verification Area | Test Command | Expected Output | Success Criteria |\n|------------------|-------------|-----------------|------------------|\n| Trial Balance Report | `go test ./internal/reports -v -run TestTrialBalance` | Trial balance lists all accounts with correct totals | Report totals tie to underlying account balances |\n| Balance Sheet Generation | `go test ./internal/reports -v -run TestBalanceSheet` | Balance sheet maintains accounting equation | Assets = Liabilities + Equity exactly |\n| Income Statement Accuracy | `go test ./internal/reports -v -run TestIncomeStatement` | Income statement shows period activity correctly | Revenue - Expenses = Net Income calculation verified |\n| Multi-Currency Reporting | `go test ./internal/reports -v -run TestMultiCurrency` | Foreign currency amounts translated correctly | Exchange rates applied consistently across all reports |\n\n**Milestone 5 Manual Verification Checklist:**\n\n1. Generate trial balance and verify it includes all accounts and balances correctly\n2. Generate balance sheet and verify Assets = Liabilities + Equity\n3. Generate income statement and verify net income calculation\n4. For multi-currency setup, verify currency translation in reports\n\n> **Integration Checkpoint: End-to-End Scenario**\n> \n> After completing all milestones, run this comprehensive integration test:\n> 1. Set up chart of accounts for small business (20+ accounts)\n> 2. Post 50+ mixed transactions (sales, purchases, payments, adjustments)\n> 3. Generate trial balance - must sum to zero\n> 4. Generate balance sheet - must balance exactly\n> 5. Generate income statement - net income must tie to equity changes\n> 6. Verify complete audit trail exists for all transactions\n> \n> This scenario validates the entire system works together correctly for realistic accounting workflows.\n\n### Common Testing Pitfalls\n\n⚠️ **Pitfall: Testing with Only Balanced Data**\n\nMany developers only test with perfectly balanced journal entries, missing validation of the error handling paths. In real accounting systems, users frequently submit unbalanced entries that must be caught and rejected gracefully.\n\n**Why this is wrong:** If validation logic isn't tested with invalid data, production deployments may allow unbalanced entries to be posted, corrupting the trial balance and violating fundamental accounting principles.\n\n**How to fix:** Always include negative test cases that verify invalid entries are rejected with appropriate error messages. Test boundary conditions like entries with zero amounts, missing lines, and amounts that don't balance.\n\n⚠️ **Pitfall: Ignoring Floating-Point Precision in Tests**\n\nUsing floating-point arithmetic in tests can cause intermittent failures when accumulated rounding errors make trial balances appear unbalanced even when the logic is correct.\n\n**Why this is wrong:** Financial calculations require exact precision. Tests that pass sometimes and fail other times due to rounding errors mask real precision problems that could affect production calculations.\n\n**How to fix:** Use fixed-point decimal arithmetic in all test calculations. Assert exact equality for monetary amounts rather than approximate equality. Include specific tests for precision preservation across multiple operations.\n\n⚠️ **Pitfall: Not Testing Concurrent Modifications**\n\nSingle-threaded tests miss race conditions and data consistency problems that occur when multiple transactions modify the same accounts simultaneously.\n\n**Why this is wrong:** Production accounting systems handle concurrent users posting transactions simultaneously. Race conditions can cause lost updates, duplicate postings, or corrupted account balances.\n\n**How to fix:** Include concurrent test scenarios where multiple goroutines post transactions affecting the same accounts. Use proper synchronization primitives and verify that final balances are correct regardless of operation ordering.\n\n⚠️ **Pitfall: Missing Audit Trail Verification**\n\nFunctional tests that only verify the final state without checking that all changes were properly logged miss compliance requirements for financial record keeping.\n\n**Why this is wrong:** Regulatory compliance requires complete audit trails showing who made what changes when. Missing audit events can result in compliance violations and failed audits.\n\n**How to fix:** Every test that modifies data should verify that appropriate audit events were created. Include assertions that check audit metadata like user context, timestamps, and change descriptions.\n\n⚠️ **Pitfall: Testing Only Happy Path Scenarios**\n\nFocusing tests on successful operations without testing failure scenarios leaves error handling and recovery logic unvalidated.\n\n**Why this is wrong:** Accounting systems must maintain integrity even when operations fail. Untested error paths may allow partial updates that corrupt the ledger state.\n\n**How to fix:** Include failure injection tests that simulate database errors, network failures, and application crashes during critical operations. Verify that the system recovers gracefully and maintains consistency.\n\n### Implementation Guidance\n\nThe testing strategy implementation requires sophisticated test infrastructure that can generate realistic accounting data while validating complex business rules. The testing code often requires as much care as the production code because incorrect tests can mask real bugs.\n\n**Technology Recommendations**\n\n| Testing Type | Simple Option | Advanced Option |\n|--------------|---------------|-----------------|\n| Unit Testing | Go's built-in testing package with table-driven tests | Testify library with rich assertions and mocking |\n| Property-Based Testing | Custom generators with Go's testing/quick | Gopter library with sophisticated property testing |\n| Database Testing | In-memory SQLite for fast test execution | Containerized PostgreSQL with test data fixtures |\n| Concurrent Testing | sync package primitives with manual coordination | Go's race detector with systematic concurrency testing |\n| Mock Generation | Manual mocks implementing interfaces | GoMock for automatic mock generation from interfaces |\n| Test Data Management | JSON fixtures loaded from files | Factory functions generating realistic test data |\n\n**Recommended Test Structure**\n\nThe test organization follows Go conventions while providing clear separation between different types of tests and test utilities.\n\n```\nproject-root/\n  internal/\n    account/\n      account.go\n      account_test.go           ← unit tests for account management\n      testdata/                 ← test fixtures and sample data\n        chart_of_accounts.json\n    transaction/\n      transaction.go\n      transaction_test.go       ← unit tests for transaction posting\n      integration_test.go       ← integration tests with database\n    balance/\n      balance.go\n      balance_test.go          ← unit tests for balance calculation\n      property_test.go         ← property-based testing for invariants\n    audit/\n      audit.go\n      audit_test.go           ← unit tests for audit trail\n    reports/\n      reports.go\n      reports_test.go         ← unit tests for report generation\n      integration_test.go     ← end-to-end report testing\n  test/\n    fixtures/                 ← shared test data across packages\n      sample_transactions.json\n      test_chart_of_accounts.sql\n    helpers/                  ← shared testing utilities\n      database_helper.go      ← database setup/teardown\n      assertion_helper.go     ← custom accounting assertions\n      generator.go           ← test data generators\n    integration/             ← system-level integration tests\n      end_to_end_test.go\n      performance_test.go\n    property/                ← property-based test suites\n      accounting_invariants_test.go\n      concurrency_properties_test.go\n```\n\n**Test Database Infrastructure**\n\nSetting up isolated test databases ensures tests don't interfere with each other and can run in parallel safely.\n\n```go\n// Database test helper provides isolated database instances for testing\npackage testhelpers\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"testing\"\n    _ \"github.com/lib/pq\"\n)\n\ntype TestDB struct {\n    DB     *sql.DB\n    Name   string\n    config DatabaseConfig\n}\n\n// NewTestDatabase creates an isolated database instance for testing\nfunc NewTestDatabase(t *testing.T) *TestDB {\n    // TODO: Generate unique database name using test name and timestamp\n    // TODO: Create new database using template or migration scripts\n    // TODO: Return TestDB instance with established connection\n    // TODO: Register cleanup function to drop database after test\n}\n\n// SetupTestData loads fixture data into the test database\nfunc (db *TestDB) SetupTestData(fixtures ...string) error {\n    // TODO: Load SQL fixtures from test/fixtures directory\n    // TODO: Execute fixture SQL in transaction for fast cleanup\n    // TODO: Return error if any fixture loading fails\n}\n\n// AssertTrialBalanceZero verifies the fundamental accounting equation\nfunc (db *TestDB) AssertTrialBalanceZero(t *testing.T) {\n    // TODO: Calculate trial balance from current database state\n    // TODO: Assert that total debits exactly equal total credits\n    // TODO: Provide detailed error message showing imbalance if test fails\n}\n\n// AssertAccountBalance verifies an account has expected balance\nfunc (db *TestDB) AssertAccountBalance(t *testing.T, accountID string, expectedBalance Money) {\n    // TODO: Query current account balance from database\n    // TODO: Compare actual vs expected using exact decimal comparison\n    // TODO: Provide clear error message showing actual vs expected if different\n}\n```\n\n**Property-Based Test Infrastructure**\n\nProperty-based testing requires generators that create valid but varied accounting data to explore edge cases systematically.\n\n```go\n// Property-based testing for accounting invariants\npackage property\n\nimport (\n    \"testing\"\n    \"testing/quick\"\n)\n\n// AccountGenerator creates realistic account structures for testing\ntype AccountGenerator struct {\n    accountTypes []AccountType\n    currencies   []string\n    maxDepth     int\n}\n\n// Generate creates a valid account for property-based testing\nfunc (g AccountGenerator) Generate(rand *rand.Rand, size int) reflect.Value {\n    // TODO: Generate valid account with random type from accountTypes\n    // TODO: Create realistic account code and name\n    // TODO: Randomly assign currency from supported currencies\n    // TODO: Generate parent relationship respecting maxDepth\n    // TODO: Return reflect.Value containing generated Account\n}\n\n// TransactionGenerator creates balanced journal entries for testing\ntype TransactionGenerator struct {\n    accounts      []Account\n    maxLines      int\n    currencyRates map[string]decimal.Decimal\n}\n\n// Generate creates a balanced journal entry for property-based testing\nfunc (g TransactionGenerator) Generate(rand *rand.Rand, size int) reflect.Value {\n    // TODO: Generate 2-maxLines entry lines with random amounts\n    // TODO: Ensure total debits exactly equal total credits\n    // TODO: Randomly select accounts from available accounts\n    // TODO: Handle multi-currency entries using currencyRates\n    // TODO: Return reflect.Value containing balanced JournalEntry\n}\n\n// TestAccountingEquationInvariant verifies Assets = Liabilities + Equity always holds\nfunc TestAccountingEquationInvariant(t *testing.T) {\n    property := func(transactions []JournalEntry) bool {\n        // TODO: Set up clean test database\n        // TODO: Post all generated transactions\n        // TODO: Calculate total assets, liabilities, and equity\n        // TODO: Return true if Assets = Liabilities + Equity exactly\n        // TODO: Log details if equation doesn't balance\n    }\n    \n    if err := quick.Check(property, &quick.Config{MaxCount: 100}); err != nil {\n        t.Errorf(\"Accounting equation invariant violated: %v\", err)\n    }\n}\n```\n\n**Milestone Verification Scripts**\n\nAutomated verification scripts provide clear checkpoints for each development milestone.\n\n```go\n// Milestone verification helper\npackage milestones\n\nimport (\n    \"context\"\n    \"testing\"\n)\n\n// Milestone1Verification checks Account & Entry Model completion\nfunc Milestone1Verification(t *testing.T, db *TestDB) {\n    ctx := context.Background()\n    \n    // TODO: Create accounts of each type (Asset, Liability, Equity, Revenue, Expense)\n    // TODO: Verify normal balance rules work correctly for each account type\n    // TODO: Test account hierarchy creation and circular reference prevention\n    // TODO: Create sample journal entries and verify validation rules\n    // TODO: Verify multi-currency money operations work correctly\n    \n    t.Log(\"✓ Milestone 1: Account & Entry Model verified\")\n}\n\n// Milestone2Verification checks Transaction Recording completion\nfunc Milestone2Verification(t *testing.T, db *TestDB) {\n    ctx := context.Background()\n    \n    // TODO: Post balanced journal entry and verify atomic posting\n    // TODO: Test idempotency by submitting duplicate requests\n    // TODO: Verify entry reversal creates offsetting entry without deletion\n    // TODO: Test batch posting with all-or-nothing semantics\n    // TODO: Verify audit events created for all posting operations\n    \n    t.Log(\"✓ Milestone 2: Transaction Recording verified\")\n}\n\n// Milestone3Verification checks Balance Calculation completion\nfunc Milestone3Verification(t *testing.T, db *TestDB) {\n    ctx := context.Background()\n    \n    // TODO: Post transactions and verify running balance updates\n    // TODO: Test point-in-time balance queries with historical dates\n    // TODO: Generate trial balance and verify it sums to zero\n    // TODO: Verify balance cache consistency and invalidation\n    // TODO: Test balance calculation performance under load\n    \n    t.Log(\"✓ Milestone 3: Balance Calculation verified\")\n}\n\n// RunAllMilestoneVerifications executes complete system verification\nfunc RunAllMilestoneVerifications(t *testing.T) {\n    db := NewTestDatabase(t)\n    defer db.Cleanup()\n    \n    Milestone1Verification(t, db)\n    Milestone2Verification(t, db)\n    Milestone3Verification(t, db)\n    Milestone4Verification(t, db) // Audit Trail\n    Milestone5Verification(t, db) // Financial Reports\n    \n    t.Log(\"✓ All milestones verified successfully\")\n}\n```\n\n**Performance Testing Infrastructure**\n\nPerformance tests ensure the system maintains acceptable response times under realistic load conditions.\n\n```go\n// Performance testing for accounting operations\npackage performance\n\nimport (\n    \"testing\"\n    \"time\"\n)\n\n// BenchmarkBalanceCalculation measures balance query performance\nfunc BenchmarkBalanceCalculation(b *testing.B) {\n    db := setupBenchmarkDatabase(b)\n    defer db.Cleanup()\n    \n    // TODO: Pre-populate database with realistic transaction volume\n    // TODO: Measure GetCurrentBalance performance across b.N iterations\n    // TODO: Report operations per second and memory allocations\n    // TODO: Verify performance doesn't degrade with transaction volume\n}\n\n// BenchmarkConcurrentPosting measures transaction throughput\nfunc BenchmarkConcurrentPosting(b *testing.B) {\n    db := setupBenchmarkDatabase(b)\n    defer db.Cleanup()\n    \n    // TODO: Create pool of worker goroutines posting transactions\n    // TODO: Measure transactions per second under concurrent load\n    // TODO: Verify no race conditions or data corruption occurs\n    // TODO: Report throughput scaling with worker count\n}\n\n// TestResponseTimeRequirements verifies SLA compliance\nfunc TestResponseTimeRequirements(t *testing.T) {\n    requirements := map[string]time.Duration{\n        \"GetCurrentBalance\":  500 * time.Millisecond,\n        \"PostTransaction\":    1 * time.Second,\n        \"GenerateTrialBalance\": 5 * time.Second,\n        \"GenerateBalanceSheet\": 10 * time.Second,\n    }\n    \n    // TODO: Execute each operation and measure response time\n    // TODO: Assert actual time is within required threshold\n    // TODO: Report performance margins for capacity planning\n}\n```\n\n**Debugging and Troubleshooting Test Failures**\n\nWhen accounting tests fail, the debugging process must consider both functional correctness and accounting integrity.\n\n| Test Failure Symptom | Likely Cause | Debugging Steps | Resolution |\n|----------------------|--------------|----------------|------------|\n| Trial Balance Doesn't Sum to Zero | Unbalanced entry posted or calculation error | 1. Query all account balances manually<br/>2. Verify each journal entry balances<br/>3. Check for rounding errors in calculations | Fix entry validation or use exact decimal arithmetic |\n| Balance Inconsistency Between Cache and Database | Cache invalidation not triggered or race condition | 1. Compare cached vs calculated balances<br/>2. Check cache invalidation logic<br/>3. Verify transaction isolation levels | Fix cache invalidation or add proper locking |\n| Audit Events Missing | Change tracking not triggered or audit system failure | 1. Verify audit system integration points<br/>2. Check transaction boundaries include audit logging<br/>3. Test audit system independently | Fix integration or audit system configuration |\n| Property-Based Test Random Failures | Edge case in generated data or insufficient constraints | 1. Reproduce failure with specific seed value<br/>2. Examine failing test case data<br/>3. Adjust generator constraints | Improve data generators or add missing validations |\n\nThe testing strategy provides multiple layers of verification that catch different types of problems. Unit tests catch component-level bugs, integration tests find interface problems, property-based tests discover edge cases, and milestone checkpoints ensure complete functionality. This comprehensive approach provides confidence that the accounting system maintains integrity under all operating conditions.\n\n\n## Debugging Guide\n\n> **Milestone(s):** 1-5 (All milestones), as debugging skills are essential throughout account modeling, transaction recording, balance calculation, audit trails, and financial reporting implementation\n\nDebugging a double-entry ledger system requires systematic approaches that respect the fundamental accounting principle that books must always balance. Think of debugging an accounting system like being a forensic accountant - every discrepancy has a root cause that can be traced through the audit trail, and every fix must maintain the mathematical integrity of the entire ledger. Unlike typical software bugs that might affect individual features, accounting system bugs can compound over time and create cascading inconsistencies that undermine the entire system's reliability.\n\nThe complexity of double-entry bookkeeping debugging stems from the interconnected nature of accounts, where a single incorrect journal entry can affect multiple account balances, trial balance validity, and financial report accuracy. Moreover, the immutable nature of posted transactions means that fixes often require compensating entries rather than direct corrections, making debugging both a technical and an accounting exercise.\n\nThis guide provides systematic troubleshooting approaches for the four most critical categories of ledger system problems: balance discrepancies, unbalanced entries, performance issues, and audit trail corruption. Each category includes specific symptoms, root cause analysis techniques, and step-by-step resolution procedures that maintain accounting integrity while resolving technical issues.\n\n### Balance Discrepancy Diagnosis\n\n**Balance discrepancies** occur when calculated account balances don't match expected values, often manifesting as trial balance variances or account reconciliation failures. Think of balance discrepancies like finding that your bank statement doesn't match your checkbook register - there's always a specific transaction or calculation error that caused the difference, and systematic investigation can identify and resolve it.\n\nThe challenge with balance discrepancies in a cached system is determining whether the problem lies in the underlying transaction data, the balance calculation logic, or the caching mechanism itself. A discrepancy could stem from a single incorrect journal entry, a bug in the running balance maintenance, cache corruption, or even timing issues in concurrent transaction processing.\n\n> **Critical Insight:** Balance discrepancies in double-entry systems often indicate deeper problems than just calculation errors. They can reveal issues with transaction atomicity, cache coherence, or even data corruption that could affect the entire ledger's integrity.\n\nThe diagnostic approach follows a systematic elimination process, starting with the most fundamental checks and progressively drilling down to specific components. This methodical approach ensures that fixes address root causes rather than symptoms, preventing the same discrepancies from recurring.\n\n#### Systematic Balance Investigation Process\n\nThe balance discrepancy investigation follows a structured approach that isolates the problem source through progressive validation checks. This process ensures comprehensive coverage while minimizing the time spent on incorrect assumptions.\n\n**Phase 1: Fundamental Validation**\n1. **Trial Balance Verification**: Execute `GetTrialBalance()` to verify that total debits equal total credits across the entire ledger. If the trial balance doesn't sum to zero, the discrepancy affects the fundamental accounting equation and indicates a serious systematic issue.\n\n2. **Account Type Consistency**: Verify that all accounts involved in the discrepancy have their normal balance sides correctly configured. Asset and expense accounts should be debit-normal, while liability, equity, and revenue accounts should be credit-normal.\n\n3. **Transaction Completeness**: Check that all journal entries affecting the account are in `POSTED` status and none are stuck in `DRAFT` state, which would exclude them from balance calculations but might be expected in manual reconciliations.\n\n4. **Date Range Validation**: Confirm that balance calculations include the correct date range, especially for point-in-time queries that might exclude transactions posted after the query date.\n\n**Phase 2: Data Integrity Verification**\n5. **Entry Line Validation**: Query all `EntryLine` records for the affected account and verify that each line has either a `DebitAmount` or `CreditAmount` (but not both) and that all amounts are positive values.\n\n6. **Orphaned Record Detection**: Check for `EntryLine` records that reference non-existent journal entries or accounts, which could cause balance calculation errors.\n\n7. **Currency Consistency**: For multi-currency environments, verify that all transactions for an account use the same currency and that exchange rate conversions are applied consistently.\n\n**Phase 3: Calculation Logic Testing**\n8. **Manual Recalculation**: Perform a manual balance calculation by summing all debit and credit amounts from the entry lines table and compare with the cached balance.\n\n9. **Running Balance Trace**: Compare the `RunningBalance` table values with fresh calculations to identify when the divergence first occurred.\n\n10. **Concurrent Access Impact**: Check for timing issues where balance updates might have been applied out of order due to concurrent transaction processing.\n\n#### Common Balance Discrepancy Patterns\n\nDifferent types of balance discrepancies follow predictable patterns that help identify the root cause more quickly. Understanding these patterns allows for targeted diagnostic approaches rather than exhaustive investigation.\n\n| Discrepancy Pattern | Likely Root Cause | Diagnostic Approach | Typical Resolution |\n|---------------------|-------------------|-------------------|-------------------|\n| Single account off by exact transaction amount | Missing or duplicate journal entry line | Query entry lines for specific amount and date range | Post correction entry or identify duplicate |\n| Multiple accounts off by same amount | Unbalanced journal entry was posted | Check recent entries for debit/credit imbalance | Reverse entry and repost balanced version |\n| All account balances doubled | Running balance updated twice for same entry | Check audit log for duplicate balance updates | Refresh all running balances from entry history |\n| Random small variances across accounts | Floating-point precision errors | Check for decimal vs float data types | Convert to fixed-point decimal arithmetic |\n| Systematic variance in one account type | Account type normal balance logic error | Test balance calculation for asset vs liability accounts | Fix account type handling in balance engine |\n| Discrepancy appeared after specific date | Cache invalidation failure | Compare cached vs calculated balances after that date | Rebuild affected cache entries |\n\n#### Balance Debugging Workflow Tables\n\nThe following tables provide structured workflows for diagnosing specific balance discrepancy scenarios, ensuring comprehensive investigation while minimizing diagnostic time.\n\n**Cache vs Database Balance Validation**\n\n| Validation Step | Database Query | Expected Result | Action if Mismatch |\n|----------------|----------------|-----------------|-------------------|\n| Current balance cache | `SELECT CurrentBalance FROM RunningBalance WHERE AccountID = ?` | Matches expected balance | Continue to next step |\n| Raw entry line sum | `SELECT SUM(DebitAmount) - SUM(CreditAmount) FROM EntryLine WHERE AccountID = ?` | Matches cache value | Cache is correct, check calculation logic |\n| Posted entries only | Add `JOIN JournalEntry ON Status = 'POSTED'` to above query | Matches posted balance expectation | Include only posted entries in balance |\n| Date-filtered balance | Add `WHERE PostedAt <= ?` to entry query | Matches point-in-time expectation | Verify date filter logic |\n| Account type sign adjustment | Apply normal balance multiplier to sum | Matches business expectation | Check account type configuration |\n\n**Multi-Currency Balance Validation**\n\n| Currency Scenario | Validation Check | Expected Behavior | Common Issues |\n|-------------------|------------------|-------------------|---------------|\n| Single currency account | All entry lines have same currency as account | Currency consistency maintained | Mixed currencies in single account |\n| Currency conversion | Exchange rates applied at transaction date | Converted amounts stored correctly | Missing or incorrect exchange rates |\n| Presentation currency | Foreign balances converted for reporting | Consistent exchange rate methodology | Rate lookup failures or inconsistencies |\n| Historical rates | Point-in-time queries use period-appropriate rates | Historical accuracy maintained | Using current rates for historical queries |\n\n**Concurrent Transaction Impact Analysis**\n\n| Concurrency Issue | Symptom | Detection Method | Resolution |\n|-------------------|---------|------------------|------------|\n| Lost balance update | Balance unchanged after posting | Check balance update audit trail | Retry balance calculation with locking |\n| Out-of-order processing | Balance reflects later entry before earlier | Compare entry posting sequence with balance updates | Implement sequential balance updates |\n| Deadlock recovery | Some transactions rolled back | Check database deadlock logs | Retry failed transactions |\n| Cache race condition | Cached balance inconsistent with database | Compare cache and database timestamps | Implement cache locking or versioning |\n\n### Unbalanced Entry Detection\n\n**Unbalanced entries** violate the fundamental principle of double-entry bookkeeping where total debits must equal total credits. Think of unbalanced entries like a seesaw that doesn't balance - the accounting equation becomes mathematically impossible, and the error propagates through trial balances and financial reports. Unlike balance discrepancies which might be calculation errors, unbalanced entries represent data corruption that undermines the entire ledger's integrity.\n\nThe challenge with unbalanced entry detection is that the system should prevent these entries from being posted in the first place, so their presence indicates either validation bypass, data corruption after posting, or systematic bugs in the transaction recording engine. Detecting and resolving unbalanced entries requires both immediate correction and investigation of how the validation was circumvented.\n\n> **Design Principle:** The ledger system must be designed with fail-safe mechanisms that make unbalanced entries mathematically impossible to post, not just unlikely. If unbalanced entries exist, they represent a critical system failure that requires immediate attention.\n\nThe diagnostic approach focuses on identifying not just the unbalanced entries themselves, but the systematic failure that allowed them to be created. This investigation prevents future occurrences while correcting the immediate data integrity issues.\n\n#### Unbalanced Entry Detection Algorithms\n\nThe detection process uses multiple validation approaches to ensure comprehensive coverage and identify subtle imbalances that might not be immediately obvious. Each detection method serves a specific purpose in the overall validation strategy.\n\n**Primary Detection Methods:**\n1. **Entry-Level Balance Validation**: For each journal entry, verify that the sum of all debit amounts equals the sum of all credit amounts within the same currency.\n\n2. **Trial Balance Variance Detection**: Calculate the total debit and credit amounts across all posted entries. Any non-zero variance indicates systematic unbalanced entries.\n\n3. **Account-Level Impact Analysis**: For accounts showing unexpected balances, trace back to identify which specific journal entries contributed to the variance.\n\n4. **Periodic Reconciliation Scans**: Run comprehensive validation across all entries posted within specific date ranges to identify when imbalances first appeared.\n\n**Advanced Detection Techniques:**\n5. **Cross-Currency Validation**: For multi-currency entries, verify that the exchange rates and conversion amounts maintain balance when converted to a common currency.\n\n6. **Rounding Error Accumulation**: Identify cases where multiple small rounding errors have accumulated into significant imbalances over time.\n\n7. **Audit Trail Correlation**: Compare the original entry amounts recorded in audit logs with current database values to detect post-posting modifications.\n\n#### Systematic Unbalanced Entry Investigation\n\nThe investigation follows a structured approach that identifies both the immediate problem entries and the systematic issues that allowed them to exist.\n\n**Investigation Phase 1: Immediate Detection**\n\n| Detection Query | Purpose | Expected Result | Action if Failed |\n|----------------|---------|-----------------|------------------|\n| `SELECT EntryID, SUM(DebitAmount) - SUM(CreditAmount) AS Variance FROM EntryLine GROUP BY EntryID HAVING Variance != 0` | Find unbalanced journal entries | Zero results | List all unbalanced entries for correction |\n| `SELECT SUM(DebitAmount) - SUM(CreditAmount) AS SystemVariance FROM EntryLine JOIN JournalEntry ON Status = 'POSTED'` | Check overall system balance | Zero variance | Calculate total system imbalance |\n| `SELECT AccountID, SUM(CASE WHEN DebitAmount IS NOT NULL THEN DebitAmount ELSE -CreditAmount END) AS AccountVariance FROM EntryLine GROUP BY AccountID` | Identify affected accounts | All account totals reasonable | Highlight accounts with unexpected balances |\n\n**Investigation Phase 2: Root Cause Analysis**\n\n| Root Cause Category | Investigation Method | Evidence to Collect | Resolution Strategy |\n|--------------------|---------------------|-------------------|-------------------|\n| Validation bypass | Check audit logs for entries that skipped validation | Entry creation without validation events | Strengthen validation enforcement |\n| Concurrent processing race | Analyze entry posting timestamps and sequence | Overlapping posting times for related entries | Implement serialized posting |\n| Data corruption | Compare audit trail with current data | Differences between original and current amounts | Restore from audit trail or backup |\n| Currency conversion errors | Check exchange rate applications | Inconsistent conversion calculations | Recalculate with correct rates |\n| System bug in posting logic | Review recent code changes and deployment logs | Correlation between deployment and unbalanced entries | Rollback or hotfix deployment |\n\n**Investigation Phase 3: Impact Assessment**\n\nThe impact assessment determines how unbalanced entries have affected downstream systems and reports, enabling comprehensive correction planning.\n\n| Impact Category | Assessment Method | Measurement Criteria | Correction Priority |\n|-----------------|-------------------|-------------------|-------------------|\n| Trial Balance Accuracy | Calculate trial balance variance | Total system debit/credit difference | Critical - affects all reports |\n| Financial Report Reliability | Regenerate key reports and compare with previous versions | Variance in report totals | High - affects management decisions |\n| Account Balance Integrity | Recalculate all affected account balances | Number of accounts with incorrect balances | High - affects reconciliation |\n| Regulatory Compliance | Review audit requirements for balanced entries | Compliance violation severity | Critical - may require disclosure |\n| User Confidence | Assess user-reported discrepancies | Correlation with unbalanced entries | Medium - affects system adoption |\n\n#### Unbalanced Entry Correction Procedures\n\nCorrecting unbalanced entries requires careful consideration of audit trail preservation and regulatory compliance. The correction approach depends on the entry age, impact scope, and business context.\n\n**Correction Decision Matrix:**\n\n| Entry Age | Impact Scope | Correction Method | Regulatory Considerations |\n|-----------|-------------|------------------|--------------------------|\n| Current period, not reported | Single account | Direct correction entry | Minimal disclosure required |\n| Current period, already reported | Multiple accounts | Correction entry with full audit trail | May require report restatement |\n| Prior period, closed | System-wide impact | Prior period adjustment entry | Requires auditor consultation |\n| Historical, multiple periods | Regulatory filings affected | Formal restatement process | SEC/regulatory body notification |\n\n**Step-by-Step Correction Process:**\n1. **Preserve Evidence**: Create complete backup of current unbalanced entries and related audit records before any corrections.\n\n2. **Calculate Correction Amount**: Determine the exact debit/credit adjustment needed to balance each entry.\n\n3. **Identify Correction Accounts**: Choose appropriate accounts for the balancing adjustment, typically involving suspense accounts for unknown differences.\n\n4. **Create Correction Entries**: Post new journal entries that exactly offset the imbalances while maintaining proper audit trail.\n\n5. **Verify Correction Impact**: Recalculate trial balance and affected account balances to confirm correction effectiveness.\n\n6. **Document Resolution**: Record complete documentation of the problem, investigation, and correction for audit purposes.\n\n#### Preventing Future Unbalanced Entries\n\nPrevention requires both technical controls and process improvements that make unbalanced entries mathematically impossible to create.\n\n**Technical Prevention Measures:**\n\n| Prevention Layer | Implementation Method | Effectiveness Level | Maintenance Requirements |\n|------------------|----------------------|-------------------|------------------------|\n| Database constraints | Check constraints on entry line totals | High for direct database modifications | Update constraints with schema changes |\n| Application validation | Pre-posting balance validation in transaction engine | High for normal application flow | Test validation with every code change |\n| API request validation | JSON schema validation for entry creation requests | Medium for API-based entries | Update schemas with business rule changes |\n| Concurrent access control | Database transaction isolation and locking | Medium for high-concurrency scenarios | Monitor deadlock rates and adjust isolation levels |\n\n**Process Prevention Measures:**\n\n| Process Control | Implementation | Monitoring Method | Effectiveness Indicator |\n|----------------|----------------|-------------------|----------------------|\n| Automated validation | Run trial balance checks after every posting batch | Daily automated reports | Zero unbalanced entries detected |\n| Manual review workflows | Require manager approval for large or unusual entries | Approval audit trail | Reduced error rates in approved entries |\n| Periodic reconciliation | Monthly account balance reconciliation | Variance reporting | Early detection of systematic issues |\n| System health monitoring | Real-time alerts for trial balance variance | Automated alert system | Immediate notification of problems |\n\n### Performance Problem Diagnosis\n\n**Performance problems** in ledger systems typically manifest as slow balance calculations or delayed report generation, often becoming more severe as transaction volume grows. Think of performance debugging like diagnosing why a busy restaurant is serving meals slowly - the bottleneck could be in the kitchen (database), the waitstaff (application logic), or the ordering system (user interface), and systematic measurement is needed to identify the actual constraint.\n\nLedger system performance is particularly challenging because balance calculations often require scanning historical transaction data, and the cached balance optimization introduces additional complexity around cache invalidation and consistency. Performance problems can compound over time as data volume grows, making early detection and resolution critical for long-term system viability.\n\n> **Performance Principle:** Accounting system performance must be predictable and consistent. Users cannot accept that \"month-end closing might be slow\" because financial reporting has hard deadlines that cannot be moved for technical convenience.\n\nThe diagnostic approach focuses on measuring actual performance bottlenecks rather than optimizing based on assumptions, using systematic profiling to identify where time is actually being spent in the system.\n\n#### Performance Measurement Framework\n\nEffective performance diagnosis requires comprehensive instrumentation that measures all significant operations and their dependencies. The measurement framework provides visibility into both user-facing performance and internal system efficiency.\n\n**Key Performance Indicators (KPIs):**\n\n| Metric Category | Specific Measurements | Target Performance | Alert Threshold |\n|----------------|----------------------|-------------------|-----------------|\n| Balance Calculation | Current balance query response time | < 100ms | > 500ms |\n| Point-in-Time Queries | Historical balance calculation time | < 1 second | > 5 seconds |\n| Trial Balance Generation | Complete trial balance creation time | < 10 seconds | > 30 seconds |\n| Journal Entry Posting | Single entry posting time including balance updates | < 200ms | > 1 second |\n| Batch Processing | Entries posted per second in batch mode | > 100 entries/second | < 50 entries/second |\n| Cache Performance | Cache hit rate for balance queries | > 90% | < 75% |\n| Database Query Performance | Average query execution time | < 50ms | > 200ms |\n| Report Generation | Financial report creation time | < 30 seconds | > 2 minutes |\n\n**Performance Monitoring Implementation:**\n\n| Monitoring Level | Data Collected | Collection Method | Analysis Frequency |\n|-----------------|----------------|-------------------|-------------------|\n| Application metrics | Response times, throughput, error rates | Application performance monitoring (APM) | Real-time |\n| Database performance | Query execution plans, index usage, lock contention | Database monitoring tools | Continuous |\n| System resources | CPU, memory, disk I/O, network utilization | System monitoring | Every minute |\n| User experience | Page load times, API response times | Front-end monitoring | Real-time |\n| Business metrics | Entries processed, reports generated, users active | Business intelligence dashboards | Hourly |\n\n#### Common Performance Bottlenecks\n\nLedger systems exhibit predictable performance bottleneck patterns that can be systematically identified and resolved. Understanding these patterns enables targeted optimization rather than general performance tuning.\n\n**Database Query Performance Issues:**\n\n| Bottleneck Pattern | Symptoms | Root Cause | Optimization Strategy |\n|-------------------|----------|------------|---------------------|\n| Full table scans on entry lines | Balance calculations become slower as data grows | Missing indexes on AccountID, PostedAt columns | Add composite indexes for common query patterns |\n| Sequential scan for date ranges | Point-in-time queries timeout on large datasets | No index on PostedAt column | Create index on (AccountID, PostedAt) for historical queries |\n| Cache invalidation storms | Sudden performance degradation after posting | Too many cache entries invalidated simultaneously | Implement selective cache invalidation |\n| Lock contention on running balances | Concurrent postings slow down or deadlock | Multiple transactions updating same account balance | Use optimistic concurrency control with versioning |\n| Unoptimized trial balance queries | Trial balance generation takes minutes | Query joins all tables without proper indexing | Create materialized view or optimize join strategy |\n\n**Application Logic Performance Issues:**\n\n| Performance Problem | Observable Behavior | Technical Cause | Solution Approach |\n|--------------------|-------------------|-----------------|-------------------|\n| N+1 query problem | Balance queries multiply with account count | Separate database query for each account | Batch query all accounts in single database round-trip |\n| Memory leak in balance calculations | Performance degrades over time, memory usage grows | Objects not properly garbage collected | Profile memory usage and fix object lifecycle |\n| Inefficient currency conversion | Multi-currency reports extremely slow | Exchange rate lookup for every transaction | Cache exchange rates and batch conversions |\n| Redundant validation | Entry posting slower than expected | Same validation rules executed multiple times | Optimize validation pipeline to eliminate redundancy |\n| Cache thrashing | Cache hit rate low despite high query volume | Cache size too small or poor eviction policy | Tune cache size and implement smarter eviction |\n\n#### Systematic Performance Investigation Process\n\nThe performance investigation follows a structured approach that identifies actual bottlenecks through measurement rather than assumption, ensuring optimization efforts target the real performance constraints.\n\n**Phase 1: Performance Baseline Establishment**\n\n| Measurement Activity | Data Collection Method | Baseline Criteria | Analysis Focus |\n|---------------------|----------------------|-------------------|----------------|\n| Current state profiling | Run performance test suite with typical data volume | Record all timing measurements | Identify slowest operations |\n| Database query analysis | Enable query logging and analyze execution plans | Identify queries taking > 100ms | Find missing indexes or inefficient joins |\n| Resource utilization monitoring | Collect CPU, memory, disk I/O metrics during load test | Identify resource constraints | Find system bottlenecks |\n| Cache effectiveness analysis | Measure cache hit/miss rates for all cached data | Target > 90% hit rate for balance queries | Optimize cache size and eviction policy |\n\n**Phase 2: Load Testing and Bottleneck Identification**\n\n| Load Test Scenario | Simulated Workload | Expected Performance | Failure Indicators |\n|-------------------|-------------------|-------------------|-------------------|\n| Steady-state operations | Normal transaction posting and balance queries | Consistent sub-second response times | Response time degradation over time |\n| Peak load simulation | Month-end closing with high transaction volume | Graceful performance degradation | System becomes unresponsive |\n| Concurrent user testing | Multiple users accessing different accounts | Linear performance scaling | Deadlocks or lock contention |\n| Large dataset testing | Historical data spanning multiple years | Predictable query performance | Exponential query time growth |\n| Report generation load | Multiple simultaneous financial reports | Reasonable resource utilization | Memory exhaustion or CPU saturation |\n\n**Phase 3: Optimization Implementation and Validation**\n\nThe optimization phase implements targeted fixes based on identified bottlenecks and validates their effectiveness through controlled testing.\n\n| Optimization Category | Implementation Strategy | Validation Method | Success Criteria |\n|---------------------|----------------------|-------------------|------------------|\n| Database optimization | Add indexes, optimize queries, tune database configuration | Before/after performance comparison | Measurable query time improvement |\n| Caching improvements | Implement smarter caching strategies, tune cache sizes | Cache hit rate monitoring | Increased hit rate and faster response times |\n| Application logic optimization | Refactor inefficient code, eliminate redundant processing | Code profiling and timing analysis | Reduced CPU usage and faster execution |\n| Concurrency improvements | Implement optimistic locking, reduce critical sections | Concurrent load testing | Improved throughput under concurrent load |\n| Resource scaling | Increase hardware resources or scale horizontally | Load testing with increased resources | Linear performance improvement with resources |\n\n#### Performance Debugging Tools and Techniques\n\nEffective performance debugging requires specialized tools and techniques tailored to the specific characteristics of accounting systems.\n\n**Database Performance Analysis Tools:**\n\n| Database System | Profiling Tools | Key Metrics | Analysis Focus |\n|----------------|----------------|-------------|----------------|\n| PostgreSQL | pg_stat_statements, EXPLAIN ANALYZE | Query execution time, index usage, lock waits | Slow query identification and optimization |\n| MySQL | Performance Schema, slow query log | Query performance, connection usage | Query optimization and connection pooling |\n| SQL Server | SQL Profiler, Query Store | Execution plans, wait statistics | Index optimization and query tuning |\n| General approach | Application-level query logging | Query frequency, response time distribution | Application-level query optimization |\n\n**Application Performance Profiling:**\n\n| Language/Platform | Profiling Tools | Measurement Focus | Optimization Targets |\n|------------------|----------------|-------------------|---------------------|\n| Go | go tool pprof, go-torch | CPU usage, memory allocation, goroutine contention | Algorithm efficiency, memory management |\n| Java | JProfiler, YourKit, JVM built-in tools | Method execution time, object allocation | Garbage collection tuning, algorithmic optimization |\n| Rust | perf, flamegraph, criterion benchmarks | CPU cycles, memory usage patterns | Zero-cost abstractions, memory efficiency |\n| General | APM tools (New Relic, DataDog, AppDynamics) | End-to-end transaction tracing | Full-stack performance optimization |\n\n**Systematic Performance Testing Methodology:**\n\n| Testing Phase | Test Design | Data Requirements | Success Criteria |\n|--------------|-------------|-------------------|------------------|\n| Unit performance tests | Individual component benchmarks | Synthetic test data with known characteristics | Consistent performance within acceptable bounds |\n| Integration performance tests | End-to-end workflow testing | Realistic transaction volumes and patterns | Performance scales linearly with data volume |\n| Load testing | Simulated production workload | Production-like dataset size | System remains responsive under peak load |\n| Stress testing | Beyond-normal capacity testing | Dataset larger than production | Graceful degradation rather than catastrophic failure |\n| Regression testing | Performance comparison after changes | Identical dataset before and after optimization | No performance regression in unrelated areas |\n\n### Audit Trail Troubleshooting\n\n**Audit trail problems** represent the most critical category of ledger system issues because they affect regulatory compliance and data integrity verification. Think of audit trail troubleshooting like investigating a crime scene - every change to financial data must be traceable, and any gap in the audit trail could indicate tampering, system failure, or compliance violation. Unlike performance or balance problems that affect operations, audit trail issues can have legal and regulatory consequences.\n\nThe complexity of audit trail debugging stems from the immutable nature of the audit system itself - you cannot simply \"fix\" audit records without potentially destroying evidence. Instead, diagnosis must identify the root cause while preserving all existing audit evidence, and fixes must be implemented through additional audit entries that document the correction process itself.\n\n> **Compliance Principle:** Audit trail integrity is non-negotiable in financial systems. Any modification to audit records must itself be audited, and any gap in the audit trail must be documented and explained to auditors and regulators.\n\nThe diagnostic approach focuses on systematic verification of audit trail completeness and integrity, using cryptographic verification and cross-referencing techniques to identify and document any anomalies.\n\n#### Audit Trail Integrity Verification\n\nAudit trail integrity verification involves multiple layers of validation that ensure both completeness (no missing records) and authenticity (no unauthorized modifications). This verification must be performed regularly and especially after any system incidents.\n\n**Cryptographic Integrity Checking:**\n\nThe hash chain verification process ensures that no audit records have been modified since creation. Each audit event includes a hash of the previous event, creating a cryptographic chain that reveals any tampering attempts.\n\n| Verification Step | Technical Process | Expected Result | Action if Failed |\n|------------------|-------------------|-----------------|------------------|\n| Individual record hashing | Recalculate content hash for each audit event | Hash matches stored ContentHash | Record has been modified - investigate timing and source |\n| Chain hash validation | Verify each ChainHash references correct previous record | Sequential hash chain maintained | Chain break indicates insertion or deletion |\n| Digital signature verification | Validate digital signatures using public key | All signatures valid | Invalid signature indicates system compromise |\n| Timestamp consistency | Check that timestamps increase monotonically | No out-of-order timestamps | System clock issues or backdated entries |\n| Hash algorithm consistency | Verify all records use same hash algorithm | Consistent algorithm throughout chain | Algorithm change not properly implemented |\n\n**Audit Record Completeness Validation:**\n\nCompleteness validation ensures that all required business events have corresponding audit records and that no audit records have been deleted.\n\n| Completeness Check | Validation Method | Coverage Scope | Gap Resolution |\n|-------------------|------------------|----------------|----------------|\n| Business event coverage | Cross-reference all journal entries with audit events | Every posted entry has creation audit record | Identify missing audit events and investigate cause |\n| State transition tracking | Verify all status changes recorded | Entry lifecycle completely audited | Document where audit events were not generated |\n| User action auditing | Check that all user-initiated actions logged | Complete user activity trail | Identify system actions not properly attributed |\n| System event auditing | Validate automated process auditing | All scheduled and triggered processes | Ensure system processes generate audit events |\n| Approval workflow auditing | Verify approval process completely documented | Multi-step approvals fully tracked | Reconstruct approval history from other sources |\n\n#### Common Audit Trail Failure Patterns\n\nAudit trail failures follow predictable patterns that help identify the root cause and scope of the problem. Understanding these patterns enables targeted investigation and appropriate remediation strategies.\n\n**Missing Audit Events:**\n\n| Failure Pattern | Typical Causes | Detection Method | Impact Assessment |\n|----------------|---------------|------------------|-------------------|\n| Complete event silence | Audit system offline or misconfigured | Large gaps in event timeline | Critical - entire period unaudited |\n| Selective event gaps | Code paths bypassing audit system | Spot-checking reveals missing events for specific operations | High - specific operations not compliant |\n| User action gaps | Authentication integration issues | User actions not attributed to specific users | Medium - accountability compromised |\n| System process gaps | Automated processes not instrumented | Scheduled job results not audited | Medium - system changes not tracked |\n| Error condition gaps | Exception handling bypasses audit logging | Failed operations not recorded | High - failures not documented |\n\n**Audit Data Corruption:**\n\n| Corruption Type | Symptoms | Root Cause Investigation | Recovery Strategy |\n|----------------|----------|-------------------------|-------------------|\n| Hash chain breaks | ChainHash validation failures | Find first break point and investigate timing | Rebuild chain from that point forward |\n| Content tampering | ContentHash mismatch for individual records | Compare with backup systems or database logs | Document discrepancy and investigate source |\n| Timestamp anomalies | Events with impossible timestamps | Check system clock synchronization | Correlate with other log sources for actual timing |\n| Orphaned audit records | Audit events reference non-existent business records | Database referential integrity issues | Cross-reference with business data to identify scope |\n| Duplicate events | Same business event recorded multiple times | Idempotency failure in audit system | Deduplicate while preserving evidence of duplication |\n\n#### Systematic Audit Trail Investigation Process\n\nThe investigation process must balance thoroughness with preservation of evidence, ensuring that the diagnostic process itself doesn't compromise the audit trail integrity.\n\n**Phase 1: Evidence Preservation**\n\nBefore beginning any investigation, all current audit data must be preserved in an immutable state to prevent any questions about tampering during the diagnostic process.\n\n| Preservation Activity | Implementation Method | Verification Process | Documentation Requirements |\n|---------------------|----------------------|-------------------|-------------------------|\n| Complete audit trail backup | Export all audit events to tamper-evident storage | Calculate hash of entire export | Timestamp and digitally sign backup |\n| Database transaction logs backup | Preserve database WAL/transaction logs | Verify log completeness | Document log file names and sizes |\n| System logs preservation | Collect application and system logs | Cross-reference timing with audit events | Maintain chain of custody documentation |\n| Configuration snapshot | Document current audit system configuration | Compare with known-good configuration | Record any configuration changes |\n\n**Phase 2: Integrity Assessment**\n\nThe integrity assessment systematically evaluates the audit trail for completeness, authenticity, and consistency.\n\n| Assessment Category | Validation Process | Tools and Queries | Acceptance Criteria |\n|--------------------|-------------------|-------------------|-------------------|\n| Cryptographic integrity | Run hash chain validation across all records | Custom verification scripts | No hash mismatches or chain breaks |\n| Temporal consistency | Analyze timestamp patterns and sequences | Time-series analysis tools | Monotonically increasing timestamps within reasonable bounds |\n| Business event correlation | Match audit events to business transactions | Cross-reference queries between audit and business tables | Every significant business event has audit trail |\n| User attribution accuracy | Verify user context in audit records | Authentication log correlation | All user actions properly attributed |\n| System process documentation | Check automated process audit coverage | Process execution log analysis | All automated changes documented |\n\n**Phase 3: Root Cause Analysis**\n\nRoot cause analysis focuses on understanding how audit trail problems occurred and implementing preventive measures.\n\n| Investigation Focus | Analysis Method | Evidence Collection | Remediation Planning |\n|--------------------|----------------|-------------------|---------------------|\n| System failure impact | Timeline analysis of system outages | Correlate with audit gaps | Implement audit resilience improvements |\n| Code deployment correlation | Match audit issues with software releases | Deployment logs and timing analysis | Fix audit bypass bugs in application code |\n| Configuration drift | Compare current vs baseline configuration | Configuration management history | Implement configuration monitoring |\n| Operator error assessment | Review manual administrative actions | Administrator action logs | Improve administrative procedures |\n| Security incident investigation | Check for evidence of unauthorized access | Security log analysis | Implement additional security controls |\n\n#### Audit Trail Recovery and Remediation\n\nRecovery from audit trail problems requires careful balance between fixing the immediate issue and maintaining regulatory compliance through proper documentation.\n\n**Recovery Strategy Decision Matrix:**\n\n| Problem Scope | Business Impact | Recovery Approach | Regulatory Implications |\n|---------------|----------------|------------------|----------------------|\n| Single transaction missing audit | Low - isolated incident | Document gap and reason, implement monitoring | Minimal - document in next audit |\n| Multiple transactions missing audit | Medium - compliance gap | Reconstruct audit trail from other sources | Moderate - may require disclosure |\n| Hash chain corruption | High - integrity compromised | Investigate source, rebuild from clean point | High - may question entire audit trail |\n| Systematic audit bypass | Critical - widespread non-compliance | Code fix, retrospective audit reconstruction | Critical - regulatory reporting required |\n\n**Remediation Implementation Steps:**\n\n| Remediation Phase | Activities | Validation Requirements | Documentation Needs |\n|------------------|-----------|----------------------|-------------------|\n| Immediate containment | Stop further audit trail degradation | Verify audit system functioning correctly | Document timeline and actions taken |\n| Gap assessment | Quantify extent of missing or corrupted audit data | Cross-reference with all available data sources | Create comprehensive gap analysis report |\n| Recovery implementation | Reconstruct missing audit events from available data | Validate reconstructed events against business records | Document reconstruction methodology |\n| Process improvement | Implement preventive measures | Test improvements under failure scenarios | Update audit procedures and monitoring |\n| Compliance reporting | Notify auditors and regulators as required | Provide complete documentation package | Maintain ongoing compliance monitoring |\n\n**Preventive Measures Implementation:**\n\n| Prevention Layer | Implementation Strategy | Monitoring Method | Effectiveness Validation |\n|-----------------|----------------------|-------------------|----------------------|\n| Application-level controls | Mandatory audit event generation in all code paths | Code review and automated testing | No business operations bypass audit |\n| Infrastructure resilience | Redundant audit storage and processing | Real-time replication monitoring | Audit system survives single points of failure |\n| Real-time validation | Continuous audit trail integrity checking | Automated monitoring and alerting | Immediate notification of audit issues |\n| Regular compliance audits | Periodic comprehensive audit trail review | Scheduled validation reports | Proactive identification of potential issues |\n\n### Implementation Guidance\n\nThe debugging implementation requires comprehensive diagnostic tools and systematic procedures that can quickly identify and resolve the four major categories of ledger system problems. The implementation focuses on providing both automated detection and guided manual investigation procedures.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|----------------|\n| Performance Monitoring | Go pprof + custom timing logs (net/http/pprof) | Application Performance Monitoring with distributed tracing (OpenTelemetry + Jaeger) |\n| Database Diagnostics | SQL query logging + EXPLAIN plans | Database-specific monitoring (pg_stat_statements for PostgreSQL) |\n| Audit Trail Validation | Custom hash verification scripts | Blockchain-based immutable audit (Hyperledger Fabric or similar) |\n| Error Detection | Standard Go error handling + logging | Structured error classification with error codes and categories |\n| Load Testing | Simple Go benchmark tests | Professional load testing (k6 or Artillery) |\n| Metrics Collection | Prometheus metrics + Grafana dashboards | Full observability stack (Prometheus/Grafana/AlertManager) |\n\n#### Recommended File Structure\n\n```\nproject-root/\n  internal/debug/\n    balance_debugger.go          ← Balance discrepancy diagnosis\n    balance_debugger_test.go\n    entry_validator.go           ← Unbalanced entry detection\n    entry_validator_test.go\n    performance_profiler.go      ← Performance problem diagnosis\n    performance_profiler_test.go\n    audit_verifier.go           ← Audit trail troubleshooting\n    audit_verifier_test.go\n    diagnostic_reports.go       ← Report generation for all debugging\n    diagnostic_reports_test.go\n  internal/monitoring/\n    metrics.go                  ← Performance metrics collection\n    health_checks.go           ← System health monitoring\n  cmd/debug/\n    main.go                    ← CLI tool for debugging operations\n  scripts/\n    validate_system.sh         ← Comprehensive system validation script\n    performance_baseline.sh    ← Performance baseline measurement\n```\n\n#### Balance Debugger Infrastructure\n\nThis infrastructure provides comprehensive balance discrepancy detection and diagnosis capabilities.\n\n```go\npackage debug\n\nimport (\n    \"context\"\n    \"database/sql\"\n    \"fmt\"\n    \"time\"\n    \n    \"github.com/shopspring/decimal\"\n    \"github.com/your-org/ledger/internal/types\"\n)\n\n// BalanceDebugger provides comprehensive balance discrepancy diagnosis\ntype BalanceDebugger struct {\n    db           *sql.DB\n    balanceEngine types.BalanceEngine\n    auditTrail    types.AuditStorage\n}\n\n// DiscrepancyReport contains complete analysis of balance discrepancies\ntype DiscrepancyReport struct {\n    AccountID           string\n    ExpectedBalance     types.Money\n    ActualBalance       types.Money\n    CachedBalance       types.Money\n    Variance           types.Money\n    LastRecalculatedAt time.Time\n    AffectedEntries    []string\n    RootCauseAnalysis  string\n    RecommendedActions []string\n    SeverityLevel      string\n}\n\n// SystemIntegrityReport provides overall ledger health assessment\ntype SystemIntegrityReport struct {\n    GeneratedAt        time.Time\n    TrialBalanceStatus string\n    TotalVariance      types.Money\n    AccountsAffected   int\n    CriticalIssues     []DiscrepancyReport\n    WarningIssues      []DiscrepancyReport\n    RecommendedActions []string\n    SystemHealthScore  int\n}\n\n// NewBalanceDebugger creates a new balance debugging instance\nfunc NewBalanceDebugger(db *sql.DB, engine types.BalanceEngine, audit types.AuditStorage) *BalanceDebugger {\n    return &BalanceDebugger{\n        db:            db,\n        balanceEngine: engine,\n        auditTrail:    audit,\n    }\n}\n\n// DiagnoseAccountDiscrepancy performs comprehensive analysis of account balance issues\nfunc (bd *BalanceDebugger) DiagnoseAccountDiscrepancy(ctx context.Context, accountID string) (*DiscrepancyReport, error) {\n    // TODO 1: Retrieve current cached balance from RunningBalance table\n    // TODO 2: Recalculate balance from entry lines (sum debits minus credits)\n    // TODO 3: Check account type and apply normal balance logic\n    // TODO 4: Identify variance between cached and calculated balances\n    // TODO 5: Query recent entry lines that affected this account\n    // TODO 6: Check for concurrent transaction timing issues\n    // TODO 7: Validate currency consistency across all entry lines\n    // TODO 8: Generate root cause analysis based on findings\n    // TODO 9: Recommend specific corrective actions\n    // TODO 10: Assign severity level based on variance amount and impact\n    \n    return nil, fmt.Errorf(\"not implemented\")\n}\n\n// ValidateSystemIntegrity performs comprehensive ledger-wide validation\nfunc (bd *BalanceDebugger) ValidateSystemIntegrity(ctx context.Context) (*SystemIntegrityReport, error) {\n    // TODO 1: Generate current trial balance and check for zero sum\n    // TODO 2: Identify all accounts with cached vs calculated balance variance\n    // TODO 3: Check for orphaned entry lines without valid journal entries\n    // TODO 4: Validate that all posted entries have balanced debit/credit totals\n    // TODO 5: Verify account type consistency across all entry lines\n    // TODO 6: Check for entries posted to inactive accounts\n    // TODO 7: Identify currency conversion inconsistencies\n    // TODO 8: Analyze audit trail for balance update failures\n    // TODO 9: Generate prioritized list of issues requiring attention\n    // TODO 10: Calculate overall system health score based on findings\n    \n    return nil, fmt.Errorf(\"not implemented\")\n}\n```\n\n#### Entry Validation Infrastructure\n\nThis component provides systematic unbalanced entry detection and validation.\n\n```go\n// EntryValidator provides comprehensive journal entry validation and debugging\ntype EntryValidator struct {\n    db         *sql.DB\n    auditTrail types.AuditStorage\n}\n\n// ValidationIssue represents a specific entry validation problem\ntype ValidationIssue struct {\n    EntryID         string\n    IssueType       string\n    Severity        string\n    Description     string\n    DebitTotal      types.Money\n    CreditTotal     types.Money\n    Variance        types.Money\n    AffectedLines   []string\n    DetectedAt      time.Time\n    RecommendedFix  string\n}\n\n// EntryValidationReport contains comprehensive entry validation results\ntype EntryValidationReport struct {\n    GeneratedAt      time.Time\n    EntriesScanned   int\n    IssuesFound      int\n    CriticalIssues   []ValidationIssue\n    WarningIssues    []ValidationIssue\n    SystemImpact     string\n    OverallStatus    string\n    NextSteps        []string\n}\n\n// NewEntryValidator creates a new entry validation instance\nfunc NewEntryValidator(db *sql.DB, audit types.AuditStorage) *EntryValidator {\n    return &EntryValidator{\n        db:         db,\n        auditTrail: audit,\n    }\n}\n\n// DetectUnbalancedEntries finds all journal entries that violate double-entry rules\nfunc (ev *EntryValidator) DetectUnbalancedEntries(ctx context.Context, dateFrom, dateTo time.Time) (*EntryValidationReport, error) {\n    // TODO 1: Query all journal entries in the specified date range\n    // TODO 2: For each entry, calculate total debit and credit amounts\n    // TODO 3: Identify entries where debits do not equal credits\n    // TODO 4: Check for entries with missing or invalid entry lines\n    // TODO 5: Validate currency consistency within each entry\n    // TODO 6: Analyze audit trail for evidence of post-posting modifications\n    // TODO 7: Categorize issues by severity and potential impact\n    // TODO 8: Generate specific repair recommendations for each issue\n    // TODO 9: Calculate overall system impact of unbalanced entries\n    // TODO 10: Prioritize issues for correction based on business impact\n    \n    return nil, fmt.Errorf(\"not implemented\")\n}\n\n// ValidateTrialBalance performs comprehensive trial balance validation\nfunc (ev *EntryValidator) ValidateTrialBalance(ctx context.Context, asOfDate time.Time) error {\n    // TODO 1: Calculate trial balance for specified date\n    // TODO 2: Verify that total debits equal total credits\n    // TODO 3: Check that all account balances are reasonable for account type\n    // TODO 4: Identify any accounts with unexpected zero balances\n    // TODO 5: Validate that asset and expense accounts have debit balances\n    // TODO 6: Verify that liability, equity, and revenue accounts have credit balances\n    // TODO 7: Check for any accounts with balances in wrong currency\n    // TODO 8: Generate detailed variance report if trial balance doesn't balance\n    // TODO 9: Provide specific account-level recommendations for correction\n    // TODO 10: Update system health metrics based on validation results\n    \n    return fmt.Errorf(\"not implemented\")\n}\n```\n\n#### Performance Profiler Infrastructure\n\nThis infrastructure provides comprehensive performance monitoring and diagnosis capabilities.\n\n```go\n// PerformanceProfiler provides systematic performance analysis and optimization guidance\ntype PerformanceProfiler struct {\n    db      *sql.DB\n    metrics map[string]*PerformanceMetric\n}\n\n// PerformanceMetric tracks timing and throughput for specific operations\ntype PerformanceMetric struct {\n    OperationName    string\n    SampleCount      int64\n    TotalDuration    time.Duration\n    MinDuration      time.Duration\n    MaxDuration      time.Duration\n    AverageDuration  time.Duration\n    P95Duration      time.Duration\n    P99Duration      time.Duration\n    ErrorCount       int64\n    LastMeasurement  time.Time\n}\n\n// PerformanceReport contains comprehensive system performance analysis\ntype PerformanceReport struct {\n    GeneratedAt         time.Time\n    SystemLoad          string\n    DatabasePerformance map[string]*PerformanceMetric\n    CacheEfficiency     map[string]float64\n    BottleneckAnalysis  []string\n    OptimizationPlan    []string\n    ResourceUtilization map[string]interface{}\n}\n\n// NewPerformanceProfiler creates a new performance profiling instance\nfunc NewPerformanceProfiler(db *sql.DB) *PerformanceProfiler {\n    return &PerformanceProfiler{\n        db:      db,\n        metrics: make(map[string]*PerformanceMetric),\n    }\n}\n\n// MeasureOperation wraps an operation with performance measurement\nfunc (pp *PerformanceProfiler) MeasureOperation(operationName string, operation func() error) error {\n    // TODO 1: Record operation start time\n    // TODO 2: Execute the provided operation function\n    // TODO 3: Calculate operation duration\n    // TODO 4: Update performance metrics for this operation type\n    // TODO 5: Check if operation exceeded expected performance thresholds\n    // TODO 6: Log slow operations for further analysis\n    // TODO 7: Update rolling averages and percentile calculations\n    // TODO 8: Trigger alerts if performance degrades significantly\n    // TODO 9: Return original operation result or error\n    \n    return fmt.Errorf(\"not implemented\")\n}\n\n// AnalyzeSystemPerformance generates comprehensive performance analysis\nfunc (pp *PerformanceProfiler) AnalyzeSystemPerformance(ctx context.Context) (*PerformanceReport, error) {\n    // TODO 1: Collect current performance metrics for all tracked operations\n    // TODO 2: Analyze database query performance using EXPLAIN plans\n    // TODO 3: Check cache hit rates and efficiency metrics\n    // TODO 4: Identify operations exceeding performance thresholds\n    // TODO 5: Analyze resource utilization patterns (CPU, memory, I/O)\n    // TODO 6: Correlate performance issues with system load patterns\n    // TODO 7: Generate prioritized list of performance bottlenecks\n    // TODO 8: Recommend specific optimization strategies\n    // TODO 9: Estimate performance improvement potential for each recommendation\n    // TODO 10: Create actionable performance improvement roadmap\n    \n    return nil, fmt.Errorf(\"not implemented\")\n}\n```\n\n#### Audit Trail Verifier Infrastructure\n\nThis component provides comprehensive audit trail integrity verification and problem diagnosis.\n\n```go\n// AuditVerifier provides systematic audit trail integrity verification\ntype AuditVerifier struct {\n    auditStorage types.AuditStorage\n    db           *sql.DB\n}\n\n// IntegrityViolation represents a specific audit trail integrity problem\ntype IntegrityViolation struct {\n    ViolationType   string\n    EventID         string\n    Description     string\n    DetectedAt      time.Time\n    Severity        string\n    Evidence        map[string]interface{}\n    RecommendedFix  string\n    ComplianceImpact string\n}\n\n// AuditIntegrityReport contains comprehensive audit trail health assessment\ntype AuditIntegrityReport struct {\n    GeneratedAt        time.Time\n    EventsValidated    int64\n    IntegrityViolations []IntegrityViolation\n    HashChainStatus    string\n    CompletenessStatus string\n    ComplianceStatus   string\n    RecommendedActions []string\n    RegulatoryRisk     string\n}\n\n// NewAuditVerifier creates a new audit verification instance\nfunc NewAuditVerifier(audit types.AuditStorage, db *sql.DB) *AuditVerifier {\n    return &AuditVerifier{\n        auditStorage: audit,\n        db:           db,\n    }\n}\n\n// VerifyAuditIntegrity performs comprehensive audit trail validation\nfunc (av *AuditVerifier) VerifyAuditIntegrity(ctx context.Context, dateFrom, dateTo time.Time) (*AuditIntegrityReport, error) {\n    // TODO 1: Validate cryptographic hash chain continuity\n    // TODO 2: Verify digital signatures on all audit events\n    // TODO 3: Check timestamp consistency and monotonic progression\n    // TODO 4: Cross-reference audit events with business transactions\n    // TODO 5: Identify any gaps in the audit trail timeline\n    // TODO 6: Validate that all required business events have audit records\n    // TODO 7: Check for orphaned audit records without corresponding business data\n    // TODO 8: Verify user attribution accuracy for all recorded events\n    // TODO 9: Analyze audit event patterns for anomalies\n    // TODO 10: Generate compliance risk assessment based on findings\n    \n    return nil, fmt.Errorf(\"not implemented\")\n}\n\n// DetectAuditGaps identifies missing or corrupted audit records\nfunc (av *AuditVerifier) DetectAuditGaps(ctx context.Context) ([]IntegrityViolation, error) {\n    // TODO 1: Query all business transactions and corresponding audit events\n    // TODO 2: Identify business events without corresponding audit records\n    // TODO 3: Check for audit events without valid business transaction references\n    // TODO 4: Analyze timing gaps in audit event sequences\n    // TODO 5: Validate that state transitions are completely audited\n    // TODO 6: Check for missing user authentication context in audit events\n    // TODO 7: Identify system processes that may not be generating audit events\n    // TODO 8: Cross-reference with system logs to identify missed events\n    // TODO 9: Categorize gaps by severity and compliance impact\n    // TODO 10: Generate specific remediation steps for each identified gap\n    \n    return nil, fmt.Errorf(\"not implemented\")\n}\n```\n\n#### Debugging CLI Tool Implementation\n\nA command-line interface provides easy access to all debugging functions for system administrators and developers.\n\n```go\n// cmd/debug/main.go\npackage main\n\nimport (\n    \"context\"\n    \"flag\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"time\"\n    \n    \"github.com/your-org/ledger/internal/debug\"\n)\n\nfunc main() {\n    var (\n        operation = flag.String(\"operation\", \"\", \"Debug operation: balance, entries, performance, audit\")\n        accountID = flag.String(\"account\", \"\", \"Account ID for balance debugging\")\n        dateFrom  = flag.String(\"from\", \"\", \"Start date for analysis (YYYY-MM-DD)\")\n        dateTo    = flag.String(\"to\", \"\", \"End date for analysis (YYYY-MM-DD)\")\n        output    = flag.String(\"output\", \"console\", \"Output format: console, json, csv\")\n    )\n    flag.Parse()\n\n    // TODO 1: Initialize database connection from environment variables\n    // TODO 2: Create appropriate debugger instance based on operation type\n    // TODO 3: Parse and validate date parameters\n    // TODO 4: Execute requested debugging operation\n    // TODO 5: Format and output results according to specified format\n    // TODO 6: Exit with appropriate status code based on findings\n    \n    switch *operation {\n    case \"balance\":\n        // TODO: Implement balance discrepancy diagnosis\n    case \"entries\":\n        // TODO: Implement unbalanced entry detection\n    case \"performance\":\n        // TODO: Implement performance analysis\n    case \"audit\":\n        // TODO: Implement audit trail verification\n    default:\n        fmt.Fprintf(os.Stderr, \"Invalid operation: %s\\n\", *operation)\n        os.Exit(1)\n    }\n}\n```\n\n#### Milestone Checkpoints\n\nEach milestone should include specific debugging capabilities that demonstrate the system's robustness and maintainability.\n\n**Milestone 1-2 Checkpoint: Basic Validation**\n- Run `go run cmd/debug/main.go -operation=entries` to detect any unbalanced journal entries\n- Expected output: \"No unbalanced entries detected\" or specific details of any violations\n- Verify that trial balance validation passes with `go test ./internal/debug -v -run=TestTrialBalance`\n\n**Milestone 3 Checkpoint: Balance Consistency**\n- Run `go run cmd/debug/main.go -operation=balance -account=<test-account-id>` \n- Expected output: Cached balance matches calculated balance within acceptable precision\n- Performance baseline: Balance queries should complete in under 100ms for accounts with <10,000 transactions\n\n**Milestone 4-5 Checkpoint: Full System Validation**\n- Run comprehensive system validation: `go run cmd/debug/main.go -operation=audit -from=2024-01-01 -to=2024-12-31`\n- Expected output: Complete audit trail with no integrity violations\n- All debugging tools should execute without errors and provide actionable insights\n\n\n## Future Extensions\n\n> **Milestone(s):** 1-5 (All milestones), as this section describes potential system enhancements that build upon the complete double-entry ledger foundation including advanced reporting capabilities, workflow automation, external integrations, and scalability improvements\n\nBuilding a production-ready double-entry ledger system opens numerous opportunities for enhancement and growth. Think of the current system as a solid financial foundation—like a well-built house with strong bones that can support room additions, upgraded utilities, and modern amenities. The architectural decisions made throughout the core system design enable these extensions while maintaining the fundamental principles of accounting integrity and audit trail immutability.\n\nThe key insight is that all future extensions must preserve the **accounting invariants** that make the system trustworthy. Just as a structural engineer never compromises load-bearing walls when renovating a house, our extensions must never violate the double-entry principle, compromise transaction atomicity, or break the immutable audit trail. This section explores four major categories of enhancements that represent natural growth paths for the ledger system.\n\n### Advanced Reporting Features\n\nThink of advanced reporting as transforming raw accounting data into business intelligence—like having a skilled financial analyst who can spot patterns, trends, and insights that aren't immediately obvious from basic trial balances and income statements. While the current system provides fundamental reports required for regulatory compliance, businesses need sophisticated analytical tools to make strategic decisions.\n\nThe **cash flow statement** represents the most critical missing piece from the standard financial reporting suite. Unlike the income statement, which shows profitability using accrual accounting, the cash flow statement tracks actual money movement through the business. This requires classifying journal entries into operating, investing, and financing activities—a complex analytical process that goes beyond simple account type categorization.\n\n> **Decision: Cash Flow Statement Architecture**\n> - **Context**: Businesses need to track actual cash movements separately from accrual accounting profits, requiring classification of transactions into operating, investing, and financing activities\n> - **Options Considered**: \n>   - Direct method (track actual cash receipts/payments)\n>   - Indirect method (reconcile net income to cash flow)\n>   - Hybrid approach with configurable methodology\n> - **Decision**: Implement indirect method with optional direct method support\n> - **Rationale**: Indirect method integrates naturally with existing journal entry data, while direct method requires additional cash transaction tracking that may not exist in all implementations\n> - **Consequences**: Enables standard cash flow reporting with reasonable implementation complexity, but requires business rules engine for activity classification\n\nThe **variance analysis** capability transforms the ledger into a management accounting tool by comparing actual results against budgets, forecasts, and prior periods. This requires extending the data model to store budget data and implementing sophisticated comparison algorithms that handle different time periods, currencies, and organizational structures.\n\n**Custom report builders** represent the most complex enhancement, essentially creating a domain-specific language for financial reporting. Think of this as building a specialized SQL query interface that understands accounting semantics—users can define their own reports without writing complex database queries or understanding the underlying schema relationships.\n\n| Enhancement | Data Requirements | Processing Complexity | Business Value |\n|-------------|------------------|----------------------|----------------|\n| Cash Flow Statement | Transaction activity classification rules | Medium - requires reconciliation logic | High - critical for cash management |\n| Variance Analysis | Budget/forecast data storage | Low - mostly comparison operations | High - enables management decisions |\n| Custom Report Builder | Report template metadata schema | High - requires query language parser | Medium - reduces IT dependency |\n| Consolidated Reporting | Inter-company elimination rules | Very High - complex entity relationships | High - required for corporate groups |\n| Real-time Analytics | Streaming data processing | Very High - requires event-driven architecture | Medium - nice-to-have for most businesses |\n\nThe architecture naturally accommodates these reporting enhancements through the existing `Financial Reporting Module`. The `ReportGenerator` interface can be extended with new implementations that leverage the same underlying data access patterns while providing sophisticated analytical capabilities.\n\n```go\ntype AdvancedReportGenerator interface {\n    GenerateCashFlowStatement(ctx context.Context, periodStart, periodEnd time.Time, method CashFlowMethod) (*CashFlowStatement, error)\n    GenerateVarianceAnalysis(ctx context.Context, actual *TrialBalance, budget *BudgetData, analysisType VarianceType) (*VarianceReport, error)\n    ExecuteCustomReport(ctx context.Context, template *ReportTemplate, parameters map[string]interface{}) (*CustomReport, error)\n}\n```\n\n### Workflow and Approval Systems\n\nImagine transforming the current direct journal entry posting into a sophisticated approval pipeline—like upgrading from a simple email system to a modern document workflow platform where different types of transactions require different levels of authorization based on amount, risk, and organizational policies.\n\nThe current system posts journal entries immediately upon validation, which works well for automated transactions and trusted users. However, production accounting systems often require **multi-level approval processes** where transactions above certain thresholds, or entries affecting sensitive accounts, must be reviewed and approved by managers before posting to the ledger.\n\n> **Decision: Approval Workflow Architecture**  \n> - **Context**: Production accounting requires human oversight for high-risk transactions, with approval requirements varying by amount, account type, and organizational hierarchy\n> - **Options Considered**:\n>   - Simple binary approval (pending/approved)\n>   - Multi-stage workflow with configurable approval chains\n>   - Rule-based automatic approval with exception handling\n> - **Decision**: Implement configurable multi-stage workflow with rule engine\n> - **Rationale**: Different organizations have vastly different approval requirements, and flexibility is more valuable than simplicity for production deployment\n> - **Consequences**: Enables sophisticated approval processes but requires workflow engine and notification infrastructure\n\n**Automated posting rules** represent the opposite end of the spectrum—intelligent automation that can recognize transaction patterns and create journal entries without human intervention. Think of this as teaching the system to recognize common business events (like receiving an invoice or completing a sale) and automatically generate the corresponding accounting entries.\n\nThe workflow system extends the `EntryStatus` enumeration to include intermediate states like `PENDING_APPROVAL`, `REJECTED`, and `APPROVED_PENDING_POST`. This requires fundamental changes to the transaction recording workflow while preserving the atomic posting guarantees of the core system.\n\n| Workflow Component | Responsibility | Integration Point | Technical Complexity |\n|-------------------|----------------|-------------------|---------------------|\n| Approval Engine | Route entries through approval chains | Transaction Recording Engine | Medium |\n| Rule Engine | Evaluate approval and automation rules | Account Management Component | High |\n| Notification System | Alert approvers and requesters | External email/messaging service | Low |\n| Workflow History | Track approval decisions and timing | Audit Trail System | Low |\n| Delegation Manager | Handle temporary approval delegation | User management system (external) | Medium |\n\nThe **automated posting rules** require a sophisticated **rule engine** that can evaluate complex business conditions. For example: \"If transaction amount > $10,000 AND affects cash accounts AND is created by non-manager user, then require CFO approval.\" This rule engine must integrate with the validation pipeline while maintaining the same error handling and rollback capabilities.\n\n```go\ntype WorkflowRule interface {\n    EvaluateCondition(ctx context.Context, entry *JournalEntry, userContext *UserContext) (bool, error)\n    GetRequiredApprovers(ctx context.Context, entry *JournalEntry) ([]ApproverID, error)\n    CanAutoApprove(ctx context.Context, entry *JournalEntry, userContext *UserContext) (bool, error)\n}\n\ntype ApprovalWorkflow struct {\n    Rules []WorkflowRule\n    NotificationService NotificationService\n    ApprovalStorage ApprovalStorage\n}\n```\n\nThe most sophisticated enhancement is **delegation management**, allowing temporary transfer of approval authority when managers are unavailable. This requires time-limited delegation records, automated expiration, and notification systems—essentially building a mini-workflow management system within the accounting system.\n\n### External System Integration\n\nThink of external integrations as building bridges between the ledger system and the broader business ecosystem—like connecting individual buildings with sky bridges so people and information can flow seamlessly between them. The current ledger operates as a standalone system, but production deployments must integrate with ERP systems, banks, payment processors, and third-party accounting software.\n\n**ERP integration** represents the most complex integration challenge because ERPs often have their own accounting modules. The integration must handle bidirectional synchronization while maintaining the ledger as the authoritative source of financial truth. This requires sophisticated **data mapping** between different chart of accounts structures and **conflict resolution** when the same transaction appears in both systems.\n\n> **Decision: ERP Integration Strategy**\n> - **Context**: Enterprise customers use comprehensive ERP systems (SAP, Oracle, NetSuite) with built-in accounting modules, requiring integration without creating dual sources of financial truth\n> - **Options Considered**:\n>   - Replace ERP accounting module entirely\n>   - Bidirectional synchronization with conflict resolution\n>   - ERP as source with ledger as analytical layer\n> - **Decision**: Implement unidirectional integration with ERP as source and ledger as analytical layer\n> - **Rationale**: Replacing ERP accounting disrupts established business processes, while bidirectional sync creates complex conflict scenarios that risk data integrity\n> - **Consequences**: Enables advanced analytics and audit capabilities while preserving existing ERP workflows, but requires robust ETL pipeline and data validation\n\n**Bank feed integration** automates transaction recording by importing bank statements and matching them against expected transactions. This is like having a smart assistant that can read bank statements and automatically create the corresponding journal entries, with sophisticated matching algorithms that can handle timing differences, transaction fees, and currency conversions.\n\nThe technical challenge lies in **transaction matching**—determining which bank transactions correspond to which journal entries. Banks provide different levels of transaction detail, and timing differences between when transactions are recorded in the ledger versus when they clear the bank create matching complexity.\n\n| Integration Type | Data Flow Direction | Synchronization Frequency | Complexity Level |\n|------------------|-------------------|-------------------------|------------------|\n| ERP Systems | Bidirectional | Real-time or batch | Very High |\n| Bank Feeds | Inbound only | Daily batch import | High |\n| Payment Processors | Bidirectional | Real-time via webhooks | Medium |\n| Tax Software | Outbound only | Monthly/quarterly | Low |\n| Business Intelligence | Outbound only | Real-time or batch | Medium |\n\n**API design for integrations** requires careful consideration of data formats, authentication, rate limiting, and error handling. The APIs must expose ledger functionality while protecting the integrity constraints that make the system trustworthy. This often means providing higher-level business operations rather than direct database access.\n\n```go\ntype IntegrationAPI interface {\n    // ERP Integration\n    ImportChartOfAccounts(ctx context.Context, accounts []ExternalAccount) (*ImportResult, error)\n    SynchronizeTransactions(ctx context.Context, transactions []ExternalTransaction) (*SyncResult, error)\n    \n    // Bank Feed Integration\n    ImportBankStatement(ctx context.Context, statement *BankStatement) (*ReconciliationResult, error)\n    MatchTransactions(ctx context.Context, bankTx []BankTransaction, ledgerTx []JournalEntry) (*MatchResult, error)\n    \n    // Generic Export\n    ExportTrialBalance(ctx context.Context, format ExportFormat, asOfDate time.Time) ([]byte, error)\n    ExportJournalEntries(ctx context.Context, criteria *ExportCriteria) (*ExportPackage, error)\n}\n```\n\nThe most sophisticated integration capability is **real-time event streaming**, where the ledger publishes events about transaction posting, account balance changes, and period closing to external subscribers. This enables building event-driven architectures where other business systems can react immediately to financial events.\n\n### Scalability and Distribution\n\nScaling a double-entry ledger presents unique challenges because the **fundamental accounting constraints** cannot be compromised. Think of it like scaling a bank vault—you can build more vaults and hire more guards, but every vault must maintain the same level of security, and the total money across all vaults must still reconcile perfectly.\n\nThe core challenge is that double-entry bookkeeping has inherent dependencies that resist typical horizontal scaling approaches. Every transaction must maintain the invariant that debits equal credits, and trial balances must sum to zero across the entire system. These global consistency requirements seem to demand centralized processing.\n\n> **Decision: Distributed Ledger Architecture**\n> - **Context**: High-volume financial systems need horizontal scalability, but accounting integrity requires global consistency that traditionally demands centralized processing\n> - **Options Considered**:\n>   - Centralized ledger with read replicas\n>   - Sharded ledger by account or entity\n>   - Event-sourced architecture with eventual consistency\n> - **Decision**: Implement hybrid approach with centralized posting and distributed read processing\n> - **Rationale**: Accounting integrity is non-negotiable, so all posting must maintain ACID properties, but read operations (balance queries, report generation) can be distributed without compromising integrity\n> - **Consequences**: Enables read scalability while preserving accounting accuracy, but write scalability remains limited by consensus requirements\n\n**Read replica distribution** represents the safest scaling approach. The master ledger handles all write operations (journal entry posting, account creation, period closing), while read replicas serve balance queries, report generation, and analytical workloads. The replication must handle **temporal consistency**—ensuring that balance queries see all journal entries posted before a given timestamp.\n\n**Horizontal partitioning** by entity or subsidiary enables scaling for organizations with natural business boundaries. Each partition maintains its own complete trial balance, and a **consolidation layer** handles inter-entity transactions and consolidated reporting. This is like having separate accounting books for each division, with a corporate accounting team that combines them for overall financial statements.\n\nThe most advanced approach is **distributed consensus** for transaction posting, using algorithms like Raft or Byzantine Fault Tolerance to ensure that all nodes agree on transaction ordering and posting. This enables **active-active** deployments where multiple nodes can accept transactions, but requires sophisticated **conflict resolution** when simultaneous transactions affect the same accounts.\n\n| Scaling Approach | Write Scalability | Read Scalability | Consistency Model | Implementation Complexity |\n|------------------|------------------|------------------|-------------------|-------------------------|\n| Master-Slave Replication | None | High | Strong eventual | Low |\n| Horizontal Partitioning | Medium | High | Strong per partition | Medium |\n| Distributed Consensus | Medium | High | Strong global | Very High |\n| Event Sourcing | High | High | Eventually consistent | High |\n| Blockchain/DLT | Low | Medium | Strong global | Very High |\n\n**Performance optimization** for distributed systems requires sophisticated **caching strategies** that respect accounting semantics. Balance caches must be invalidated correctly across multiple nodes, and **cache coherence protocols** must ensure that no node serves stale financial data that could lead to incorrect business decisions.\n\n```go\ntype DistributedLedger interface {\n    // Distributed Write Operations\n    PostEntryWithConsensus(ctx context.Context, entry *JournalEntry) (*ConsensusResult, error)\n    \n    // Partition Management\n    CreatePartition(ctx context.Context, partitionID string, config *PartitionConfig) error\n    TransferAccount(ctx context.Context, accountID, fromPartition, toPartition string) error\n    \n    // Cross-Partition Operations\n    PostInterEntityTransaction(ctx context.Context, entry *JournalEntry, partitions []string) (*DistributedPostingResult, error)\n    GenerateConsolidatedReport(ctx context.Context, reportType string, partitions []string) (*ConsolidatedReport, error)\n    \n    // Consistency and Recovery\n    VerifyGlobalConsistency(ctx context.Context) (*ConsistencyReport, error)\n    RecoverPartition(ctx context.Context, partitionID string, recoveryPoint time.Time) error\n}\n```\n\nThe ultimate scaling challenge is **global distribution** across multiple geographic regions while maintaining **regulatory compliance** in each jurisdiction. This requires **data residency** controls, **regional audit trails**, and **cross-border transaction** handling that complies with international financial regulations.\n\n**Common Pitfalls in Future Extensions:**\n\n⚠️ **Pitfall: Breaking Accounting Integrity for Performance**\nMany scalability solutions compromise the fundamental accounting invariants in pursuit of performance gains. For example, implementing eventual consistency where trial balances might temporarily not sum to zero violates the core principle that makes double-entry bookkeeping trustworthy. Always prioritize accounting accuracy over performance—a fast but incorrect accounting system is worse than useless.\n\n⚠️ **Pitfall: Insufficient Integration Testing**\nComplex integrations often work perfectly in isolation but fail when multiple systems interact simultaneously. For example, an ERP integration might work fine until someone uses the bank feed integration at the same time, creating duplicate transactions. Implement comprehensive integration test suites that exercise all combinations of external systems.\n\n⚠️ **Pitfall: Neglecting Audit Trail in Extensions**\nNew features often bypass the audit trail system, creating blind spots in the financial record. Every extension must maintain the same level of auditability as the core system—workflow approvals, automated posting rules, and external integrations all generate events that must be tracked for regulatory compliance.\n\n⚠️ **Pitfall: Underestimating Configuration Complexity**\nAdvanced features require sophisticated configuration management. Approval workflows, automated posting rules, and integration mappings create complex configuration dependencies that can be difficult to test and troubleshoot. Design configuration systems with validation, versioning, and rollback capabilities.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|----------------|\n| Workflow Engine | Database-based state machine | Temporal or Zeebe workflow service |\n| Report Builder | Template-based generator | Apache Superset or custom DSL |\n| Message Queue | Redis Streams | Apache Kafka or AWS SQS |\n| External APIs | HTTP REST with OpenAPI | GraphQL with federation |\n| Caching Layer | Redis with manual invalidation | Hazelcast with event-based invalidation |\n| Distributed Consensus | Single leader with failover | Raft consensus (hashicorp/raft) |\n\n#### Recommended Extension Structure\n\n```\nproject-root/\n  internal/extensions/\n    reporting/\n      cashflow/\n        statement.go              ← cash flow statement generator\n        classification.go         ← activity classification rules\n      variance/\n        analysis.go              ← budget vs actual comparison\n      builder/\n        custom_reports.go        ← report template engine\n    workflow/\n      approval/\n        engine.go                ← approval workflow coordinator\n        rules.go                 ← approval rule evaluation\n      automation/\n        posting_rules.go         ← automated entry generation\n    integration/\n      erp/\n        sap_connector.go         ← SAP integration\n        netsuite_connector.go    ← NetSuite integration\n      banking/\n        bank_feed.go             ← bank statement import\n        reconciliation.go        ← transaction matching\n    scaling/\n      partition/\n        manager.go               ← horizontal partitioning\n      consensus/\n        raft_coordinator.go      ← distributed consensus\n      cache/\n        distributed_cache.go     ← multi-node cache coherence\n```\n\n#### Workflow Engine Infrastructure\n\n```go\n// Complete workflow infrastructure for approval processes\ntype WorkflowState struct {\n    EntryID       string                 `json:\"entry_id\"`\n    CurrentStep   string                 `json:\"current_step\"`\n    Status        WorkflowStatus         `json:\"status\"`\n    Approvers     []ApprovalRecord       `json:\"approvers\"`\n    Variables     map[string]interface{} `json:\"variables\"`\n    CreatedAt     time.Time             `json:\"created_at\"`\n    UpdatedAt     time.Time             `json:\"updated_at\"`\n}\n\ntype WorkflowStatus string\n\nconst (\n    WorkflowStatusPending   WorkflowStatus = \"PENDING\"\n    WorkflowStatusApproved  WorkflowStatus = \"APPROVED\" \n    WorkflowStatusRejected  WorkflowStatus = \"REJECTED\"\n    WorkflowStatusExpired   WorkflowStatus = \"EXPIRED\"\n)\n\ntype ApprovalRecord struct {\n    ApproverID string    `json:\"approver_id\"`\n    Action     string    `json:\"action\"` // APPROVE, REJECT, DELEGATE\n    Comment    string    `json:\"comment\"`\n    Timestamp  time.Time `json:\"timestamp\"`\n    IPAddress  string    `json:\"ip_address\"`\n}\n\ntype WorkflowEngine struct {\n    db           *sql.DB\n    ruleEngine   *RuleEngine\n    notification NotificationService\n    audit        AuditStorage\n}\n\nfunc NewWorkflowEngine(db *sql.DB, audit AuditStorage) *WorkflowEngine {\n    return &WorkflowEngine{\n        db:           db,\n        ruleEngine:   NewRuleEngine(),\n        notification: NewEmailNotificationService(),\n        audit:        audit,\n    }\n}\n\n// StartApprovalWorkflow initiates workflow for journal entry\nfunc (w *WorkflowEngine) StartApprovalWorkflow(ctx context.Context, entry *JournalEntry, userContext *UserContext) (*WorkflowState, error) {\n    // TODO 1: Evaluate rules to determine required approvers for this entry\n    // TODO 2: Create workflow state record in database\n    // TODO 3: Send notifications to required approvers\n    // TODO 4: Create audit event for workflow initiation\n    // TODO 5: Return workflow state with pending status\n}\n\n// ProcessApproval handles approver decision on pending entry\nfunc (w *WorkflowEngine) ProcessApproval(ctx context.Context, entryID string, approverID string, decision ApprovalDecision) error {\n    // TODO 1: Validate approver has authority for this entry\n    // TODO 2: Update workflow state with approval decision\n    // TODO 3: Check if all required approvals are complete\n    // TODO 4: If approved, post entry to ledger atomically\n    // TODO 5: Send notifications to requestor and other stakeholders\n    // TODO 6: Create audit trail for approval decision\n}\n```\n\n#### Bank Feed Integration Starter\n\n```go\n// Complete bank feed integration for automated reconciliation\ntype BankFeedProcessor struct {\n    db              *sql.DB\n    ledger          *TransactionRecorder\n    matcher         *TransactionMatcher\n    reconciliation  *ReconciliationEngine\n}\n\ntype BankTransaction struct {\n    BankTxID      string          `json:\"bank_tx_id\"`\n    Date          time.Time       `json:\"date\"`\n    Amount        Money           `json:\"amount\"`\n    Description   string          `json:\"description\"`\n    Reference     string          `json:\"reference\"`\n    AccountNumber string          `json:\"account_number\"`\n    TxType        string          `json:\"tx_type\"` // DEBIT, CREDIT\n    Balance       Money           `json:\"balance\"`\n}\n\ntype MatchResult struct {\n    BankTxID     string          `json:\"bank_tx_id\"`\n    LedgerTxID   *string         `json:\"ledger_tx_id\"`\n    MatchType    MatchType       `json:\"match_type\"`\n    Confidence   float64         `json:\"confidence\"`\n    Variance     *Money          `json:\"variance\"`\n}\n\ntype MatchType string\n\nconst (\n    MatchTypeExact      MatchType = \"EXACT\"\n    MatchTypePartial    MatchType = \"PARTIAL\"\n    MatchTypeUnmatched  MatchType = \"UNMATCHED\"\n    MatchTypeDuplicate  MatchType = \"DUPLICATE\"\n)\n\n// ProcessBankStatement imports and matches bank transactions\nfunc (b *BankFeedProcessor) ProcessBankStatement(ctx context.Context, statement *BankStatement) (*ReconciliationResult, error) {\n    // TODO 1: Validate bank statement format and completeness\n    // TODO 2: Import bank transactions to temporary staging table\n    // TODO 3: Run matching algorithm against posted journal entries\n    // TODO 4: Auto-create entries for matched transactions if configured\n    // TODO 5: Generate reconciliation report with unmatched items\n    // TODO 6: Update account reconciliation status\n    // Hint: Use fuzzy string matching for transaction descriptions\n    // Hint: Consider date ranges (±3 days) for timing differences\n}\n```\n\n#### Distributed Consensus Core Logic\n\n```go\n// Core distributed consensus for scalable transaction posting\ntype ConsensusCoordinator struct {\n    nodeID      string\n    raftNode    *raft.Raft\n    fsm         *LedgerStateMachine\n    transport   raft.Transport\n    logStore    raft.LogStore\n    stableStore raft.StableStore\n}\n\ntype LedgerStateMachine struct {\n    ledger *TransactionRecorder\n    audit  AuditStorage\n}\n\n// Apply implements raft.FSM for ledger operations\nfunc (l *LedgerStateMachine) Apply(log *raft.Log) interface{} {\n    // TODO 1: Deserialize log entry to determine operation type\n    // TODO 2: Validate operation maintains accounting integrity\n    // TODO 3: Apply operation to local ledger state atomically\n    // TODO 4: Update running balances if transaction posted\n    // TODO 5: Return operation result for client response\n    // Hint: All nodes must apply operations in identical order\n    // Hint: Operations must be deterministic across all nodes\n}\n\n// PostEntryWithConsensus coordinates distributed transaction posting\nfunc (c *ConsensusCoordinator) PostEntryWithConsensus(ctx context.Context, entry *JournalEntry) (*ConsensusResult, error) {\n    // TODO 1: Serialize journal entry for consensus log\n    // TODO 2: Submit operation to Raft cluster for agreement\n    // TODO 3: Wait for operation to be committed by majority\n    // TODO 4: Return success when operation applied to state machine\n    // TODO 5: Handle leader election and network partition scenarios\n    // Hint: Only leader can accept writes, followers redirect to leader\n}\n```\n\n#### Extension Milestone Checkpoints\n\n**Advanced Reporting Milestone:**\n- Run `go test ./internal/extensions/reporting/...` - all tests should pass\n- Generate cash flow statement: `curl http://localhost:8080/reports/cashflow?period=2023Q4`\n- Verify statement shows Operating, Investing, and Financing sections with proper totals\n- Create custom report template and verify it executes without errors\n\n**Workflow Engine Milestone:**\n- Start approval workflow: POST entry with approval required, verify it enters PENDING status\n- Test approval process: approve entry via API, verify it posts to ledger automatically\n- Check notification delivery: verify emails sent to approvers and requestors\n- Validate audit trail: confirm all workflow actions recorded with user attribution\n\n**Integration API Milestone:**\n- Import bank statement: POST CSV file, verify transactions imported correctly\n- Test ERP sync: push chart of accounts to external system and verify mapping\n- Validate error handling: send malformed data, confirm graceful error responses\n- Check rate limiting: make rapid API calls, verify throttling works correctly\n\n**Distributed Scaling Milestone:**\n- Deploy multiple ledger nodes with consensus enabled\n- Post transactions through different nodes, verify consistent ordering\n- Test failover: stop leader node, verify new leader elected and operations continue\n- Validate global consistency: run trial balance across all partitions, confirm zero variance\n\n\n## Glossary\n\n> **Milestone(s):** 1-5 (All milestones), as this section provides definitions of accounting and technical terms used throughout the double-entry ledger system design\n\nThis glossary provides comprehensive definitions of accounting principles, technical concepts, and system terminology used throughout the double-entry ledger system design document. The terms are organized to build understanding from fundamental accounting concepts through advanced implementation details.\n\nThink of this glossary as your financial engineering dictionary - just as software engineers need precise definitions for technical terms like \"idempotency\" and \"atomic transactions,\" accounting systems require equally precise definitions for financial concepts like \"normal balance\" and \"trial balance.\" Each term builds upon others to create a coherent understanding of both accounting principles and their technical implementation.\n\n### Core Accounting Concepts\n\nThe foundation of any accounting system rests on time-tested principles that have governed financial record-keeping for centuries. These concepts form the mathematical and logical framework that ensures financial integrity.\n\n**Double-Entry Bookkeeping** is the fundamental accounting method where every financial transaction affects at least two accounts, and the total debits must always equal the total credits. This creates a self-balancing system that provides built-in error detection - if debits don't equal credits, you know something is wrong. The system acts like a mathematical proof where the accounting equation (Assets = Liabilities + Equity) must always balance.\n\n**Trial Balance** serves as the primary verification report showing all account balances to confirm that total debits equal total credits across the entire ledger. Think of it as a mathematical checkpoint that proves the fundamental accounting equation holds true. The trial balance acts as both a validation tool and the foundation for generating financial statements.\n\n**Chart of Accounts** represents the organized catalog of all accounts used by an organization, structured hierarchically to support both detailed transaction recording and summarized financial reporting. Each account has a unique code, descriptive name, and defined type that determines its normal balance and financial statement presentation.\n\n**Journal Entry** constitutes the complete transaction record containing balanced debits and credits that document a specific business event. Each entry includes a description, reference information, posting date, and multiple line items that reference specific accounts with corresponding amounts.\n\n**Normal Balance** defines whether an account type typically carries a debit or credit balance based on the fundamental accounting equation. Asset and expense accounts are debit-normal (increases recorded as debits), while liability, equity, and revenue accounts are credit-normal (increases recorded as credits).\n\n### Account Type System\n\nThe account type system provides the structural foundation for organizing financial data according to established accounting principles and financial statement presentation requirements.\n\n| Account Type | Normal Balance | Financial Statement | Examples |\n|--------------|----------------|-------------------|----------|\n| ASSET | Debit | Balance Sheet | Cash, Accounts Receivable, Equipment |\n| LIABILITY | Credit | Balance Sheet | Accounts Payable, Loans, Accrued Expenses |\n| EQUITY | Credit | Balance Sheet | Common Stock, Retained Earnings, Paid-in Capital |\n| REVENUE | Credit | Income Statement | Sales Revenue, Service Income, Interest Income |\n| EXPENSE | Debit | Income Statement | Salaries, Rent, Depreciation, Cost of Goods Sold |\n\n### Transaction Processing Terminology\n\nTransaction processing concepts define how business events are recorded, validated, and posted to maintain ledger integrity and provide audit trails.\n\n**Posting** represents the process of officially recording a journal entry in the ledger system, transitioning it from draft status to a permanent, immutable record. Once posted, entries cannot be modified - only reversed through offsetting entries.\n\n**Idempotency** ensures that operations can be safely repeated without changing the result, preventing duplicate transactions when API calls are retried due to network timeouts or system failures. The system uses unique request keys to detect and prevent duplicate processing.\n\n**Atomic Transaction** guarantees that database operations either complete entirely or fail entirely, preventing partial updates that could leave the ledger in an inconsistent state. This is crucial for maintaining the double-entry principle across multiple database tables.\n\n**Reversal Entry** provides the mechanism for correcting posted transactions by creating an offsetting journal entry that cancels out the original entry without deleting historical records. This maintains the complete audit trail while fixing errors.\n\n**Validation Pipeline** implements the multi-stage process for checking entry correctness before posting, including debit-credit balance verification, account existence validation, and business rule compliance checks.\n\n### Balance Calculation Concepts\n\nBalance calculation terminology describes the methods and mechanisms used to efficiently compute and maintain account balances while supporting both current and historical reporting requirements.\n\n**Running Balance** maintains continuously updated current balances for performance optimization, avoiding the need to sum all historical transactions for every balance inquiry. The system updates running balances automatically when new entries are posted.\n\n**Point-in-Time Balance** calculates historical account balances for specific dates by considering only transactions posted on or before that date. This supports historical financial statement generation and audit requirements.\n\n**Balance Caching** implements performance optimization through materialized balance tables and in-memory caches, reducing query response times for frequently accessed account balances while maintaining data consistency.\n\n**Cache Invalidation** removes stale cached values when underlying transaction data changes, ensuring that cached balances remain consistent with the source ledger data. The system uses event-driven invalidation triggered by journal entry posting.\n\n**Balance Engine** serves as the component responsible for efficient balance calculations, managing both current and historical balance queries while coordinating cache updates and invalidation.\n\n### Audit and Compliance Framework\n\nAudit and compliance terminology encompasses the mechanisms that ensure complete transaction traceability, data integrity, and regulatory compliance throughout the system lifecycle.\n\n**Immutable Audit Trail** provides an unchangeable record of all transactions and system modifications, supporting regulatory compliance and forensic analysis. Once created, audit records cannot be modified or deleted.\n\n**Append-Only Ledger** implements a storage system that only allows adding new records while preventing modification or deletion of existing entries. This design ensures that historical financial data remains intact and verifiable.\n\n**Hash Chain** creates cryptographic linking where each audit record includes the hash of the previous record, enabling tamper detection and integrity verification. Breaking the chain indicates potential data corruption or unauthorized modification.\n\n**Change History Tracking** maintains complete audit logs documenting who made what changes when, including before and after values for all modifications. This supports compliance requirements and forensic investigation.\n\n**Cryptographic Integrity** provides tamper detection capabilities using hash chains and digital signatures to verify that audit records haven't been altered since creation. The system can detect any unauthorized changes to historical data.\n\n**Content Hash** generates a fixed-size digest that uniquely identifies the content of a journal entry or audit record, enabling efficient integrity verification and duplicate detection.\n\n**Digital Signature** offers cryptographic proof that data was created by an authorized system component, providing non-repudiation and authenticity verification for audit records.\n\n### Financial Reporting Terminology\n\nFinancial reporting concepts define the generation and presentation of standard financial statements and management reports from the underlying ledger data.\n\n**Balance Sheet** presents point-in-time financial position showing that assets equal liabilities plus equity at a specific date. The report validates the fundamental accounting equation and provides stakeholders with a snapshot of organizational financial health.\n\n**Income Statement** calculates period-based profit and loss from revenue and expense accounts over a specified time range. The report shows operational performance and determines net income that flows to the balance sheet.\n\n**Multi-Currency Translation** converts foreign currency account balances using appropriate exchange rates for consolidated financial reporting in a single presentation currency. The system handles both transaction-date and period-end translation methods.\n\n**Accounting Period Closing** executes the process of finalizing transactions for a reporting period and transferring temporary account balances (revenues and expenses) to permanent accounts (retained earnings). This creates a clean starting point for the next reporting period.\n\n**Period Activity** measures the net change in account balances during a reporting period, calculated by comparing opening and closing balances while accounting for all transactions posted within the period.\n\n**Closing Entries** are journal entries that transfer revenue and expense account balances to retained earnings at period end, resetting temporary accounts to zero for the next reporting period.\n\n### Technical Architecture Concepts\n\nTechnical architecture terminology describes the system design patterns, data structures, and algorithms that implement the accounting business rules with appropriate performance and reliability characteristics.\n\n**Optimistic Locking** implements concurrency control using version numbers to detect conflicts when multiple processes attempt to modify the same data simultaneously. This prevents lost updates while allowing high concurrency for read operations.\n\n**Circuit Breaker** protects against cascading failures by temporarily rejecting requests to failing downstream services, allowing systems to recover before resuming normal operations.\n\n**Two-Phase Commit** ensures atomic transactions across multiple database resources by coordinating a voting phase followed by a commit phase, guaranteeing that either all participants commit or all abort.\n\n**Read Replica** provides read-only database copies for distributing query load and improving read performance while maintaining a single authoritative source for writes.\n\n**Leader Election** selects a single system instance for coordinating distributed operations, ensuring consistent decision-making across multiple nodes in a distributed deployment.\n\n**Exponential Backoff** implements a retry strategy with increasing delays between attempts, preventing overwhelming of failing systems while allowing eventual recovery.\n\n**Point-in-Time Recovery** enables restoration of the system to any previous consistent state, supporting disaster recovery and data correction scenarios.\n\n### Performance and Scalability Terms\n\nPerformance terminology describes the mechanisms used to achieve efficient operations while maintaining correctness under varying load conditions.\n\n**Compensation Transaction Patterns** implement reversal entries to undo partial multi-step operations when distributed transactions fail partway through execution.\n\n**Balance Consistency Verification** compares cached balance values against freshly calculated values to detect and correct any inconsistencies that might arise from system failures or bugs.\n\n**Startup Integrity Verification** performs systematic checking of critical system invariants before resuming normal operations after a restart or failure.\n\n**Fail-Safe Accounting Integrity** ensures that the system never allows unbalanced entries or inconsistent state, even under failure conditions. The design prioritizes correctness over availability.\n\n### Data Quality and Validation\n\nData quality terminology encompasses the mechanisms that ensure financial data accuracy, completeness, and compliance with accounting principles throughout the system lifecycle.\n\n**Accounting Equation** represents the fundamental mathematical relationship (Assets = Liabilities + Equity) that must always remain balanced in a correctly functioning accounting system.\n\n**Accounting Invariant** defines mathematical relationships or business rules that must always hold true regardless of the specific transactions processed or system operations performed.\n\n**Fixed-Point Arithmetic** provides exact decimal calculations without floating-point precision errors, ensuring that monetary amounts maintain perfect accuracy through all calculations and aggregations.\n\n**Trial Balance Variance** measures any difference between total debits and credits in the trial balance, which should always be zero in a correctly balanced ledger system.\n\n**Balance Discrepancy** occurs when calculated account balances don't match expected values, indicating potential data corruption, calculation errors, or system bugs requiring investigation.\n\n**Unbalanced Entry** represents a journal entry that violates the double-entry principle where total debits don't equal total credits, which the system must prevent from being posted.\n\n### Testing and Quality Assurance\n\nTesting terminology describes the comprehensive verification approaches used to ensure system correctness, performance, and reliability across all accounting operations.\n\n**Property-Based Testing** uses automatically generated test data to verify that system invariants (like the accounting equation) hold true across a wide range of input scenarios and edge cases.\n\n**Test Oracle** provides the mechanism for determining whether test results are correct, often by comparing against known mathematical relationships or business rules.\n\n**Integration Test** verifies that multiple system components work together correctly to complete end-to-end workflows like journal entry posting and financial statement generation.\n\n**Unit Test** focuses on individual components in isolation, verifying that each module correctly implements its specific responsibilities without dependencies on other system parts.\n\n### System Operations and Maintenance\n\nOperations terminology covers the ongoing management, monitoring, and maintenance activities required to keep the accounting system running reliably in production environments.\n\n**Cache Coherence** ensures consistency between cached balance values and authoritative database values, preventing stale data from causing incorrect financial reports or decisions.\n\n**Concurrent Access Control** implements mechanisms that prevent data corruption when multiple users or processes attempt to modify accounting data simultaneously.\n\n**Performance Profiling** systematically measures system operation timing and resource usage to identify bottlenecks and optimization opportunities.\n\n**Root Cause Analysis** provides investigation techniques for identifying the underlying source of system problems, data discrepancies, or performance issues.\n\n**Hash Chain Verification** validates the cryptographic integrity of the complete audit record sequence to detect any unauthorized modifications to historical data.\n\n**Forensic Accounting** applies specialized investigation techniques for analyzing financial data anomalies, potentially fraudulent transactions, or system integrity violations.\n\n**Compensating Entry** creates a journal entry that corrects a previous error while maintaining the complete audit trail, providing transparency into the correction process.\n\n### Advanced Features and Extensions\n\nAdvanced terminology describes sophisticated capabilities that extend beyond basic double-entry bookkeeping to support complex organizational requirements and modern business processes.\n\n**Cash Flow Statement** tracks actual money movements through operating, investing, and financing activities, providing insight into organizational liquidity and cash management effectiveness.\n\n**Variance Analysis** compares actual financial results against budgets, forecasts, or prior periods to identify performance differences and support management decision-making.\n\n**Custom Report Builder** provides user interface capabilities allowing non-technical users to create tailored financial reports without requiring programming knowledge or IT support.\n\n**Multi-Level Approval Processes** implement workflow systems requiring multiple authorization steps based on transaction amount, risk level, or organizational hierarchy before journal entries are posted.\n\n**Automated Posting Rules** contain business logic that automatically generates journal entries from recognized transaction patterns, reducing manual data entry and improving consistency.\n\n**ERP Integration** establishes connections between the ledger system and enterprise resource planning systems for seamless data synchronization and unified business process management.\n\n**Bank Feed Integration** automates the import and matching of bank statement transactions with ledger entries, streamlining the reconciliation process and reducing manual effort.\n\n**Transaction Matching** implements algorithmic processes for correlating bank transactions with corresponding journal entries based on amounts, dates, and reference information.\n\n**Workflow Engine** manages multi-step approval processes with configurable business rules, delegation capabilities, and audit trails for complex organizational authorization requirements.\n\n**Rule Engine** evaluates complex business conditions to determine approval requirements, posting rules, and validation criteria based on organizational policies and regulatory requirements.\n\n**Data Mapping** translates between different chart of accounts structures when integrating with external systems that use different account coding schemes or organizational structures.\n\n**Conflict Resolution** handles situations where simultaneous updates to the same data occur across multiple systems or users, ensuring data consistency and preventing lost updates.\n\n**Transaction Reconciliation** matches and verifies transactions between different systems to ensure completeness and accuracy of financial data across integrated applications.\n\n**Event-Driven Architecture** enables systems to communicate through published events, supporting loose coupling and scalable integration patterns for complex enterprise environments.\n\n**Horizontal Partitioning** distributes ledger data across multiple databases or systems based on entity, business unit, or other criteria to support large-scale operations while maintaining data locality.\n\n**Distributed Consensus** ensures that multiple nodes in a distributed system agree on transaction ordering and posting decisions, maintaining consistency across geographically distributed deployments.\n\n**Configuration Management** provides systematic approaches for managing complex system settings, business rules, and organizational policies that govern ledger operations and reporting requirements.\n\n**Temporal Consistency** guarantees that related data changes are visible together at any point in time, ensuring that financial statements reflect a consistent view of the organization's financial position.\n\n**Data Residency Controls** ensure that financial data remains within required geographic boundaries to comply with local regulations and organizational data governance policies.\n\n### Implementation Guidance\n\nUnderstanding these terms is essential for implementing a robust double-entry ledger system. The terminology provides the shared vocabulary needed for clear communication between business stakeholders, system architects, and implementation teams.\n\nWhen implementing the system, developers should reference these definitions to ensure consistent interpretation of business requirements and technical specifications. The terms form a hierarchy where fundamental accounting concepts support advanced technical implementations, and each component builds upon the foundational principles established by double-entry bookkeeping.\n\nThe glossary serves as both a learning resource for new team members and a reference guide for experienced developers working on system enhancements or integrations. Understanding the precise meaning of each term enables more effective system design decisions and clearer documentation of business rules and technical requirements.\n\nRegular review of these definitions helps maintain consistency across development teams and ensures that the implemented system accurately reflects the intended accounting principles and business requirements. The terms also provide the vocabulary needed for effective communication with accounting professionals, auditors, and regulatory compliance teams.\n"}