{"html":"<h1 id=\"lisp-interpreter-design-document\">Lisp Interpreter: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This system implements a minimal Lisp interpreter that parses S-expressions into data structures, evaluates them in lexically-scoped environments, and supports functional programming constructs. The key architectural challenge is building a recursive evaluator that correctly handles special forms, function closures, and proper lexical scoping while maintaining clean separation between parsing, evaluation, and environment management.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - this foundational understanding applies throughout the project</p>\n</blockquote>\n<p>Building a programming language interpreter is one of the most intellectually rewarding challenges in computer science, combining theoretical concepts with practical engineering skills. At its core, an interpreter must solve the fundamental problem of translating human-readable text into computational actions that a computer can execute. This requires understanding not just what the code should do, but how to represent programs as data structures, how to maintain execution context, and how to implement the semantic rules that define the language&#39;s behavior.</p>\n<p>The challenge becomes particularly interesting when we consider that programming languages exist at multiple levels of abstraction simultaneously. At the textual level, a program is simply a sequence of characters. At the syntactic level, it becomes a structured tree of expressions and statements. At the semantic level, it represents a series of computational steps with precise meaning. An interpreter must navigate these levels of abstraction while maintaining correctness, efficiency, and meaningful error reporting when things go wrong.</p>\n<p>Lisp presents a uniquely elegant solution to many interpreter implementation challenges through its uniform syntax based on S-expressions (symbolic expressions). Unlike languages with complex grammatical rules, operator precedence, and varied statement forms, Lisp represents all code as nested lists of atoms. This syntactic uniformity means that the same parsing logic that handles arithmetic expressions can also handle function definitions, conditionals, and any other language construct. The result is an interpreter architecture that is both simpler to implement and easier to understand than alternatives targeting more syntactically complex languages.</p>\n<p>The uniform syntax also reveals a profound insight about computation: the distinction between code and data becomes fluid when both are represented identically. This homoiconicity (code-as-data property) allows Lisp programs to manipulate their own structure, enabling powerful metaprogramming capabilities. For learning purposes, this means that understanding how to manipulate Lisp data structures immediately translates to understanding how to manipulate program structure itself.</p>\n<p>Our implementation will focus on a minimal but complete Lisp dialect that includes the essential features found in all functional programming languages: arithmetic operations, conditional expressions, variable binding, function definition and application, list processing, and recursion. By keeping the feature set focused, we can deeply explore the fundamental concepts without getting lost in language design complexities that don&#39;t contribute to the core learning objectives.</p>\n<h3 id=\"mental-model-the-universal-calculator\">Mental Model: The Universal Calculator</h3>\n<p>When approaching Lisp interpreter design, it helps to start with a familiar mental model: an enhanced calculator that can remember things. A basic calculator takes expressions like &quot;2 + 3 * 4&quot; and produces results, but it can only work with numbers and has no memory of previous calculations. Our Lisp interpreter extends this concept in several fundamental ways that transform a simple calculator into a complete programming system.</p>\n<p><strong>Memory and Naming</strong>: Unlike a basic calculator, our Lisp system can remember values by associating them with names. When you evaluate <code>(define pi 3.14159)</code>, the system stores the value 3.14159 under the name <code>pi</code> for future reference. This is analogous to the memory buttons on a scientific calculator, but with unlimited named storage slots instead of just a few numbered ones. The environment system maintains these name-to-value associations across multiple expressions.</p>\n<p><strong>Custom Operations</strong>: A standard calculator has built-in operations like addition and multiplication, but you cannot teach it new operations. Our Lisp interpreter allows you to define new operations using <code>lambda</code> expressions. When you write <code>(lambda (x) (* x x))</code>, you are creating a new &quot;square&quot; operation that the calculator can use just like its built-in functions. This is like being able to program new buttons on your calculator that combine existing operations in useful ways.</p>\n<p><strong>Deferred Computation</strong>: Traditional calculators evaluate everything immediately, but our Lisp system can create expressions that are evaluated later. Lambda expressions are recipes for computation that can be stored, passed around, and invoked when needed. This is similar to how a scientific calculator might store a formula for later evaluation with different variable values, but with much more flexibility.</p>\n<p><strong>Self-Extension</strong>: The most powerful aspect of this enhanced calculator model is that it can extend itself. Since the calculator understands its own language (S-expressions), it can create new expressions programmatically. This reflexive capability means that the boundary between the calculator&#39;s built-in functions and user-defined functions disappears entirely.</p>\n<p><strong>Structured Data</strong>: While basic calculators work only with numbers, our Lisp calculator works with structured data through lists. A list like <code>(1 2 3 4)</code> is not just a collection of numbers but a structured value that can be manipulated as a unit. This allows the calculator to work with complex data structures while maintaining the same simple evaluation rules.</p>\n<p>The key insight is that evaluation in Lisp follows consistent rules regardless of complexity. Whether evaluating <code>(+ 1 2)</code>, <code>(define factorial (lambda (n) (if (= n 0) 1 (* n (factorial (- n 1))))))</code>, or <code>(map factorial (list 1 2 3 4 5))</code>, the same fundamental process applies: look up symbols in the environment, apply functions to their arguments, and return values. This uniformity makes the interpreter architecture remarkably clean and predictable.</p>\n<h3 id=\"interpreter-implementation-approaches\">Interpreter Implementation Approaches</h3>\n<p>When designing a programming language interpreter, architects must choose from several fundamental implementation strategies, each with distinct trade-offs in complexity, performance, and debugging capabilities. Understanding these approaches helps contextualize our design decisions and provides insight into how production language implementations evolve over time.</p>\n<blockquote>\n<p><strong>Decision: Tree-Walking Interpreter Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to choose an interpreter implementation strategy that balances learning value with implementation complexity while providing good debugging capabilities for educational use.</li>\n<li><strong>Options Considered</strong>: Tree-walking interpreter, bytecode virtual machine, direct compilation to native code</li>\n<li><strong>Decision</strong>: Implement a tree-walking interpreter that directly evaluates parsed abstract syntax trees</li>\n<li><strong>Rationale</strong>: Tree-walking interpreters provide the clearest mapping between source code and execution behavior, making debugging intuitive. The implementation directly reflects the language semantics without requiring additional abstraction layers like bytecode generation or compilation phases. For educational purposes, the performance overhead is acceptable compared to the implementation clarity gained.</li>\n<li><strong>Consequences</strong>: Enables straightforward debugging where each evaluation step corresponds directly to source constructs. Sacrifices runtime performance compared to bytecode or compiled approaches, but gains implementation simplicity and maintainability for learning scenarios.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Implementation Approach</th>\n<th>Execution Model</th>\n<th>Performance</th>\n<th>Implementation Complexity</th>\n<th>Debugging Clarity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tree-Walking Interpreter</td>\n<td>Direct AST evaluation</td>\n<td>Slow (high per-operation overhead)</td>\n<td>Low (direct semantic mapping)</td>\n<td>Excellent (1:1 source mapping)</td>\n</tr>\n<tr>\n<td>Bytecode Virtual Machine</td>\n<td>Compile to intermediate code, interpret bytecode</td>\n<td>Moderate (optimized instruction set)</td>\n<td>Moderate (requires compilation phase)</td>\n<td>Good (source maps to bytecode)</td>\n</tr>\n<tr>\n<td>Native Compilation</td>\n<td>Compile directly to machine code</td>\n<td>Fast (no interpretation overhead)</td>\n<td>High (requires code generation)</td>\n<td>Difficult (optimized away source structure)</td>\n</tr>\n</tbody></table>\n<p><strong>Tree-Walking Interpreter Characteristics</strong>: A tree-walking interpreter operates by recursively traversing the abstract syntax tree produced by the parser, evaluating each node according to the language&#39;s semantic rules. When the interpreter encounters a function call like <code>(+ 1 2)</code>, it identifies the operator <code>+</code>, recursively evaluates the arguments <code>1</code> and <code>2</code>, then applies the addition function to the results. This direct correspondence between syntax tree structure and evaluation steps makes the execution model highly transparent.</p>\n<p>The tree-walking approach excels in educational contexts because every evaluation step corresponds to a visible source construct. When debugging a recursive function, you can trace exactly which source expressions are being evaluated at each step. Error messages can point directly to source locations without complex mapping between intermediate representations and original code. This clarity comes at a performance cost, as each evaluation step requires tree traversal overhead and dynamic type checking.</p>\n<p><strong>Bytecode Virtual Machine Characteristics</strong>: A bytecode interpreter introduces an intermediate representation between source code and execution. The parser generates an abstract syntax tree, which a compiler transforms into a sequence of bytecode instructions optimized for efficient interpretation. A virtual machine then executes these instructions using a stack-based or register-based execution model.</p>\n<p>Bytecode compilation enables optimizations like constant folding, dead code elimination, and instruction combining that are difficult to apply during direct tree evaluation. The bytecode instruction set can be designed for efficient interpretation, reducing the per-operation overhead compared to tree traversal. However, this approach requires implementing both a compiler (AST to bytecode) and a virtual machine (bytecode executor), significantly increasing implementation complexity.</p>\n<p>The debugging experience becomes more complex as errors must be mapped from bytecode instructions back to source locations. Performance profiling requires understanding both the source-level algorithm and the generated bytecode patterns. For production languages, this complexity trade-off often makes sense, but for learning-oriented implementations, the additional abstraction layers can obscure the fundamental concepts.</p>\n<p><strong>Native Compilation Characteristics</strong>: A native compiler transforms source code directly into machine code for the target architecture, eliminating interpretation overhead entirely. Modern compilers apply sophisticated optimizations like inlining, loop unrolling, and register allocation to produce highly efficient executable code. Languages like Rust, Go, and C++ use this approach to achieve maximum runtime performance.</p>\n<p>The implementation complexity of native compilation is substantial, requiring deep understanding of target architectures, calling conventions, and optimization techniques. The debugging experience becomes challenging as compiler optimizations can reorder, eliminate, or merge source constructs in ways that make runtime behavior difficult to correlate with original code. Advanced debugging requires specialized tools that can reconstruct source-level views from optimized machine code.</p>\n<p>For educational interpreter projects, native compilation introduces complexity that distracts from core language implementation concepts. The focus shifts from semantic design to code generation mechanics, which, while valuable, represents a different learning objective than understanding how programming languages work conceptually.</p>\n<p><strong>Hybrid Approaches</strong>: Production language implementations often combine multiple strategies for different use cases. Just-in-time (JIT) compilation starts with interpretation or bytecode execution, then compiles frequently executed code paths to native code for better performance. Languages like Java, C#, and modern JavaScript engines use this approach to balance startup time with steady-state performance.</p>\n<p>Some implementations provide multiple execution modes: an interpreter for development (fast compilation, good debugging) and a compiler for production (optimized performance). This allows language designers to optimize for different phases of the software development lifecycle while maintaining a single language definition.</p>\n<p><strong>Implementation Decision Rationale</strong>: Our choice of tree-walking interpretation aligns with the educational objectives of this project. The direct mapping between source constructs and evaluation steps makes it easier to understand how language features work internally. When implementing lexical scoping, for example, the environment lookup logic corresponds directly to the scoping rules described in language documentation.</p>\n<p>The performance limitations of tree-walking interpretation are acceptable for learning scenarios where program complexity remains moderate. The ability to trace execution step-by-step through source code provides invaluable insight into how different language constructs interact. This understanding forms a solid foundation for later exploration of more sophisticated implementation techniques.</p>\n<p>Furthermore, the tree-walking approach allows us to focus implementation effort on core language semantics rather than optimization infrastructure. Topics like environment management, closure implementation, and recursion handling become more prominent when not overshadowed by bytecode generation or machine code emission concerns. These semantic concepts transfer directly to understanding any language implementation, regardless of the underlying execution strategy.</p>\n<p><strong>Common Pitfalls in Approach Selection</strong>:</p>\n<p>⚠️ <strong>Pitfall: Premature Optimization Focus</strong> - Beginning interpreter implementers often start with bytecode or compilation concerns before understanding basic evaluation semantics. This leads to complex architectures that are difficult to debug when semantic issues arise. Start with direct evaluation to understand the language behavior, then optimize later if needed.</p>\n<p>⚠️ <strong>Pitfall: Underestimating Debugging Complexity</strong> - Complex execution models make it difficult to understand why programs behave unexpectedly. For learning projects, choose approaches that maintain clear relationships between source code and runtime behavior. The ability to step through evaluation logic is more valuable than runtime performance.</p>\n<p>⚠️ <strong>Pitfall: Mixing Abstraction Levels</strong> - Some implementations attempt to combine tree-walking with bytecode generation or partial compilation, creating hybrid systems that inherit the complexity of multiple approaches without clear benefits. Choose one approach and implement it thoroughly rather than creating architectural inconsistencies.</p>\n<p>The interpreter implementation approach fundamentally shapes how you understand and debug language behavior. By choosing tree-walking interpretation, we prioritize learning clarity over runtime efficiency, enabling deep exploration of language semantics without the abstractions introduced by more complex execution models.</p>\n<hr>\n<p><img src=\"/api/project/lisp-interp/architecture-doc/asset?path=diagrams%2Fsystem-architecture.svg\" alt=\"System Component Architecture\"></p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete technical recommendations for implementing the foundational architecture decisions described above, with specific focus on Python-based development that balances educational clarity with practical functionality.</p>\n<p><strong>A. Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Text Processing</td>\n<td>Built-in <code>str</code> methods with manual parsing</td>\n<td><code>re</code> module for tokenization patterns</td>\n</tr>\n<tr>\n<td>Data Structures</td>\n<td>Native <code>list</code> and <code>dict</code> for AST representation</td>\n<td>Custom classes with <code>__repr__</code> for debugging</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Simple exception raising with <code>raise ValueError()</code></td>\n<td>Custom exception hierarchy with source location tracking</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>Built-in <code>assert</code> statements in functions</td>\n<td><code>pytest</code> with parameterized test cases</td>\n</tr>\n<tr>\n<td>Development Environment</td>\n<td>Basic Python REPL for testing</td>\n<td><code>ipython</code> with enhanced introspection capabilities</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended Project Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lisp-interpreter/\n├── src/\n│   ├── __init__.py\n│   ├── tokenizer.py          ← Convert text to token stream\n│   ├── parser.py             ← Build AST from tokens  \n│   ├── evaluator.py          ← Core evaluation engine\n│   ├── environment.py        ← Variable binding and scope\n│   ├── lisp_types.py         ← Data type definitions\n│   └── primitives.py         ← Built-in functions (+, -, car, etc.)\n├── tests/\n│   ├── __init__.py\n│   ├── test_tokenizer.py\n│   ├── test_parser.py\n│   ├── test_evaluator.py\n│   └── test_integration.py\n├── examples/\n│   ├── arithmetic.lisp       ← Basic math expressions\n│   ├── functions.lisp        ← Lambda and function calls\n│   └── recursion.lisp        ← Recursive algorithms\n├── repl.py                   ← Interactive interpreter\n└── README.md</code></pre></div>\n\n<p>This structure separates concerns clearly while maintaining simplicity. Each module has a single responsibility, making testing and debugging straightforward. The <code>src/</code> directory contains core implementation components, while <code>tests/</code> provides comprehensive validation and <code>examples/</code> offers learning materials.</p>\n<p><strong>C. Core Data Type Infrastructure (Complete Implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># lisp_types.py - Complete foundation for Lisp value representation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, List, Dict, Callable, Optional, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispValueType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Enumeration of all Lisp value types for runtime type checking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NUMBER</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"number\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SYMBOL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"symbol\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LIST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"list\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FUNCTION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"function\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BUILTIN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"builtin\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispValue</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all Lisp values with common operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, value: Any, value_type: LispValueType):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value_type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_truthy</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Lisp truthiness: only #f (False) and empty list are falsy.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LispValueType.</span><span style=\"color:#79B8FF\">LIST</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.value) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"String representation for REPL output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LispValueType.</span><span style=\"color:#79B8FF\">LIST</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            elements </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \" \"</span><span style=\"color:#E1E4E8\">.join(</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(item) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> item </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.value)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"(</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">elements</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LispValueType.</span><span style=\"color:#79B8FF\">SYMBOL</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.value)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LispValueType.</span><span style=\"color:#79B8FF\">FUNCTION</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"&#x3C;function:</span><span style=\"color:#79B8FF\">{id</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">>\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> str</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __repr__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Debugging representation showing type and value.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"LispValue(</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.value</span><span style=\"color:#F97583\">!r</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_number</span><span style=\"color:#E1E4E8\">(value: Union[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Factory function for numeric values.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> LispValue(value, LispValueType.</span><span style=\"color:#79B8FF\">NUMBER</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_symbol</span><span style=\"color:#E1E4E8\">(name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Factory function for symbol values.\"\"\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> LispValue(name, LispValueType.</span><span style=\"color:#79B8FF\">SYMBOL</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_list</span><span style=\"color:#E1E4E8\">(elements: List[LispValue]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Factory function for list values.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> LispValue(elements, LispValueType.</span><span style=\"color:#79B8FF\">LIST</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_number</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Type predicate for numeric values.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LispValueType.</span><span style=\"color:#79B8FF\">NUMBER</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_symbol</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Type predicate for symbol values.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LispValueType.</span><span style=\"color:#79B8FF\">SYMBOL</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_list</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Type predicate for list values.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LispValueType.</span><span style=\"color:#79B8FF\">LIST</span></span></code></pre></div>\n\n<p><strong>D. Error Handling Infrastructure (Complete Implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># errors.py - Comprehensive error handling for all interpreter phases</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception class for all Lisp interpreter errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, source_location: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.source_location </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source_location</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.source_location </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Error at position </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.source_location</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Error: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenizerError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Errors during tokenization phase (unclosed strings, invalid characters).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Errors during parsing phase (unbalanced parentheses, invalid syntax).\"\"\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EvaluationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Errors during evaluation phase (undefined variables, type mismatches).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> NameError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Variable or function name not found in environment.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Wrong type for operation (e.g., calling a number as function).\"\"\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArityError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Wrong number of arguments to function.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, expected: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, actual: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, function_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"function\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">function_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> expects </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> arguments, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">actual</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expected </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expected</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.actual </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.function_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> function_name</span></span></code></pre></div>\n\n<p><strong>E. Main Interpreter Loop Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># repl.py - Read-Eval-Print Loop implementation skeleton</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.tokenizer </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> tokenize</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parse </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.evaluator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> evaluate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> create_global_environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Main REPL loop with error handling and environment persistence.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Lisp Interpreter v0.1\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Type expressions or 'quit' to exit\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create global environment with built-in functions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    global_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_global_environment()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    while</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Read input from user </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            user_input </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> input</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"lisp> \"</span><span style=\"color:#E1E4E8\">).strip()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle special REPL commands</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> user_input </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"quit\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"exit\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\":q\"</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            elif</span><span style=\"color:#E1E4E8\"> user_input </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Process input through tokenizer -> parser -> evaluator</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tokenize(user_input)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ast </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parse(tokens)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> evaluate(ast, global_env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Display result to user</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(result))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> LispError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle interpreter errors gracefully</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Error: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> KeyboardInterrupt</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Handle Ctrl+C gracefully</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">Interrupted\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> EOFError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Handle Ctrl+D gracefully  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">Goodbye!\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> __name__</span><span style=\"color:#F97583\"> ==</span><span style=\"color:#9ECBFF\"> \"__main__\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    main()</span></span></code></pre></div>\n\n<p><strong>F. Language-Specific Python Hints:</strong></p>\n<ul>\n<li><p><strong>Use <code>typing</code> module extensively</strong>: Python&#39;s dynamic typing can make interpreter debugging difficult. Type hints for function parameters and return values catch many errors early and make the code self-documenting.</p>\n</li>\n<li><p><strong>Leverage <code>dataclasses</code> for AST nodes</strong>: Python 3.7+ dataclasses eliminate boilerplate for value objects while providing useful <code>__repr__</code> implementations for debugging.</p>\n</li>\n<li><p><strong>Use <code>enum.Enum</code> for type tags</strong>: Instead of string constants for type checking, enums provide type safety and better IDE support.</p>\n</li>\n<li><p><strong>Implement <code>__str__</code> vs <code>__repr__</code> carefully</strong>: <code>__str__</code> should produce user-friendly output for the REPL, while <code>__repr__</code> should show internal structure for debugging.</p>\n</li>\n<li><p><strong>Consider <code>functools.singledispatch</code></strong>: For operations that behave differently based on value type, single-dispatch generic functions provide cleaner code than manual type checking.</p>\n</li>\n</ul>\n<p><strong>G. Development Workflow Recommendations:</strong></p>\n<ol>\n<li><p><strong>Start with the REPL</strong>: Build a minimal REPL first, even if it only echoes input. This provides immediate feedback for testing tokenizer and parser components.</p>\n</li>\n<li><p><strong>Test each component in isolation</strong>: Write unit tests for tokenizer, parser, and evaluator separately before integration testing. Python&#39;s <code>pytest</code> framework makes this straightforward.</p>\n</li>\n<li><p><strong>Use doctest for examples</strong>: Python&#39;s <code>doctest</code> module lets you embed executable examples in docstrings, ensuring documentation stays current with implementation.</p>\n</li>\n<li><p><strong>Implement incrementally by milestone</strong>: Don&#39;t try to build everything at once. Start with basic arithmetic, then add variables, then functions, following the milestone progression.</p>\n</li>\n<li><p><strong>Add debug output early</strong>: Include optional verbose modes that show tokenization results, parsed AST structure, and evaluation steps. This makes debugging much easier when things go wrong.</p>\n</li>\n</ol>\n<p><strong>H. Milestone 1 Checkpoint:</strong></p>\n<p>After implementing the basic project structure and data types:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test that imports work correctly</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"from src.lisp_types import make_number, make_symbol, make_list; print('Types working')\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test error handling infrastructure  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"from src.errors import LispError, ParseError; raise ParseError('test')\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test REPL shell (should start and accept 'quit')</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> repl.py</span></span></code></pre></div>\n\n<p>Expected behavior:</p>\n<ul>\n<li>All imports succeed without errors</li>\n<li>Error classes can be instantiated and raised</li>\n<li>REPL starts, shows prompt, and exits cleanly on &#39;quit&#39; command</li>\n<li>At this stage, actual Lisp evaluation doesn&#39;t work yet - that comes in later milestones</li>\n</ul>\n<p>If these checkpoints fail, verify Python path settings and that all <code>__init__.py</code> files exist in appropriate directories.</p>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - this section establishes the architectural boundaries and feature scope that guide the entire implementation</p>\n</blockquote>\n<p>Building an interpreter involves countless design decisions and feature possibilities. Without clear boundaries, it&#39;s easy to get lost in implementation details or attempt to solve problems that aren&#39;t core to the learning objectives. This section establishes the precise scope of our minimal Lisp implementation, focusing on the fundamental concepts that every interpreter must address while explicitly excluding advanced features that would complicate the architecture without adding proportional educational value.</p>\n<p>The key insight here is that a minimal Lisp can still be a complete, functional programming language. By carefully choosing which features to include and exclude, we create a system that demonstrates all the essential interpreter components—tokenization, parsing, evaluation, environments, and function application—without the complexity that would obscure these fundamental concepts.</p>\n<h3 id=\"functional-requirements\">Functional Requirements</h3>\n<p>Our Lisp interpreter must implement a carefully curated set of language features that collectively demonstrate the core principles of interpreter design. Each requirement directly supports one or more learning objectives and contributes to building a complete mental model of how programming languages work.</p>\n<p><strong>S-Expression Syntax and Data Types</strong></p>\n<p>The interpreter must support Lisp&#39;s fundamental uniform syntax where all code and data are represented as S-expressions. This homoiconicity—where code and data share the same representation—is what makes Lisp an ideal learning vehicle for interpreter construction.</p>\n<table>\n<thead>\n<tr>\n<th>Data Type</th>\n<th>Syntax Examples</th>\n<th>Internal Representation</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Numbers</td>\n<td><code>42</code>, <code>3.14</code>, <code>-17</code></td>\n<td>Native numeric types</td>\n<td>Arithmetic operations and mathematical computation</td>\n</tr>\n<tr>\n<td>Symbols</td>\n<td><code>foo</code>, <code>+</code>, <code>lambda</code></td>\n<td>String identifiers</td>\n<td>Variable names and operator references</td>\n</tr>\n<tr>\n<td>Lists</td>\n<td><code>(1 2 3)</code>, <code>(+ x y)</code></td>\n<td>Nested array structures</td>\n<td>Function calls and data structures</td>\n</tr>\n<tr>\n<td>Strings</td>\n<td><code>&quot;hello world&quot;</code></td>\n<td>String literals with escape sequences</td>\n<td>Text data and output</td>\n</tr>\n<tr>\n<td>Booleans</td>\n<td><code>#t</code>, <code>#f</code></td>\n<td>Special truth values</td>\n<td>Conditional logic and predicates</td>\n</tr>\n</tbody></table>\n<p>The parser must handle arbitrarily nested list structures, properly tokenize string literals with escape sequences, and distinguish between numeric atoms and symbolic atoms. Comments initiated with semicolons must be ignored during tokenization, and whitespace must be handled correctly to separate tokens without affecting program semantics.</p>\n<p><strong>Arithmetic and Comparison Operations</strong></p>\n<p>The evaluator must implement a complete set of mathematical operations that work with both integers and floating-point numbers. These operations serve as the foundation for computational logic and demonstrate how built-in functions are integrated into the evaluation system.</p>\n<table>\n<thead>\n<tr>\n<th>Operator Category</th>\n<th>Operations</th>\n<th>Behavior</th>\n<th>Examples</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Arithmetic</td>\n<td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></td>\n<td>Variable arity, numeric coercion</td>\n<td><code>(+ 1 2 3)</code> → <code>6</code></td>\n</tr>\n<tr>\n<td>Comparison</td>\n<td><code>&lt;</code>, <code>&gt;</code>, <code>=</code>, <code>&lt;=</code>, <code>&gt;=</code></td>\n<td>Return boolean values</td>\n<td><code>(&lt; 5 10)</code> → <code>#t</code></td>\n</tr>\n<tr>\n<td>Logical</td>\n<td><code>and</code>, <code>or</code>, <code>not</code></td>\n<td>Short-circuit evaluation</td>\n<td><code>(and #f (/ 1 0))</code> → <code>#f</code></td>\n</tr>\n</tbody></table>\n<p>These operations must handle type checking (ensuring arguments are numeric where required), arity checking (verifying the correct number of arguments), and proper error reporting when invalid operations are attempted.</p>\n<p><strong>Variable Definition and Lexical Scoping</strong></p>\n<p>The interpreter must implement a complete variable system with lexical scoping, where variable lookups are determined by the code&#39;s static structure rather than the dynamic call sequence. This demonstrates one of the most fundamental concepts in programming language design.</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Syntax</th>\n<th>Semantics</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Global Definition</td>\n<td><code>(define x 42)</code></td>\n<td>Binds name in current environment</td>\n<td><code>(define pi 3.14159)</code></td>\n</tr>\n<tr>\n<td>Local Binding</td>\n<td><code>(let ((x 1) (y 2)) ...)</code></td>\n<td>Creates new scope for body</td>\n<td><code>(let ((x 10)) (+ x 1))</code></td>\n</tr>\n<tr>\n<td>Variable Reference</td>\n<td><code>x</code>, <code>foo</code></td>\n<td>Looks up value in environment chain</td>\n<td>Variable resolution through parent scopes</td>\n</tr>\n</tbody></table>\n<p>The environment system must support proper variable shadowing, where inner scopes can temporarily hide outer variable bindings without affecting them, and the bindings must be correctly restored when leaving the inner scope.</p>\n<p><strong>Function Definition and Application</strong></p>\n<p>The interpreter must support first-class functions through lambda expressions, demonstrating how functions can be created, stored, passed as arguments, and applied with proper argument binding and lexical scope capture.</p>\n<table>\n<thead>\n<tr>\n<th>Function Aspect</th>\n<th>Syntax</th>\n<th>Implementation Requirement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Creation</td>\n<td><code>(lambda (x y) (+ x y))</code></td>\n<td>Capture lexical environment as closure</td>\n</tr>\n<tr>\n<td>Application</td>\n<td><code>(f 1 2)</code></td>\n<td>Evaluate arguments, bind parameters, evaluate body</td>\n</tr>\n<tr>\n<td>Recursion</td>\n<td>Function calls itself by name</td>\n<td>Support self-reference within function body</td>\n</tr>\n<tr>\n<td>Higher-order</td>\n<td>Functions as arguments/return values</td>\n<td>Functions as first-class values</td>\n</tr>\n</tbody></table>\n<p>Function application must create a new environment that extends the closure&#39;s captured environment, bind the actual arguments to the formal parameters, and evaluate the function body in this new environment. This demonstrates the complete lifecycle of function invocation.</p>\n<p><strong>Conditional Logic</strong></p>\n<p>The interpreter must implement conditional expressions that allow programs to make decisions based on computed values. This requires understanding Lisp&#39;s truthiness semantics and proper handling of branch evaluation.</p>\n<table>\n<thead>\n<tr>\n<th>Conditional Form</th>\n<th>Syntax</th>\n<th>Evaluation Rule</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>If Expression</td>\n<td><code>(if test consequent alternative)</code></td>\n<td>Evaluate test; if truthy, evaluate consequent, else alternative</td>\n</tr>\n<tr>\n<td>Cond Expression</td>\n<td><code>(cond (test1 result1) (test2 result2) (else default))</code></td>\n<td>Evaluate tests in order; return first matching result</td>\n</tr>\n</tbody></table>\n<p>Only one branch should be evaluated based on the test result, demonstrating proper control flow and lazy evaluation of alternatives.</p>\n<p><strong>List Processing Operations</strong></p>\n<p>The interpreter must implement the fundamental list operations that make functional programming possible. These operations demonstrate how complex data structures can be built from simple primitives.</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Syntax</th>\n<th>Semantics</th>\n<th>Type Signature</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Constructor</td>\n<td><code>(cons a b)</code></td>\n<td>Create pair with head a and tail b</td>\n<td><code>cons :: a -&gt; b -&gt; (a . b)</code></td>\n</tr>\n<tr>\n<td>Head Access</td>\n<td><code>(car lst)</code></td>\n<td>Return first element of pair</td>\n<td><code>car :: (a . b) -&gt; a</code></td>\n</tr>\n<tr>\n<td>Tail Access</td>\n<td><code>(cdr lst)</code></td>\n<td>Return second element of pair</td>\n<td><code>cdr :: (a . b) -&gt; b</code></td>\n</tr>\n<tr>\n<td>List Builder</td>\n<td><code>(list a b c)</code></td>\n<td>Create proper list from arguments</td>\n<td><code>list :: a* -&gt; [a]</code></td>\n</tr>\n<tr>\n<td>Empty Check</td>\n<td><code>(null? lst)</code></td>\n<td>Test if list is empty</td>\n<td><code>null? :: [a] -&gt; Bool</code></td>\n</tr>\n</tbody></table>\n<p>These operations must properly handle the empty list (<code>nil</code> or <code>()</code>), distinguish between proper lists (terminated by nil) and improper lists (terminated by a non-nil atom), and provide appropriate error messages when operations are applied to invalid data types.</p>\n<p><strong>Recursive Function Support</strong></p>\n<p>The interpreter must allow functions to call themselves by name, enabling recursive algorithms that are fundamental to functional programming. This requires careful handling of function binding in environments and proper stack management.</p>\n<p>Functions defined with <code>define</code> must be available for self-reference within their own bodies, and the interpreter should handle reasonable recursion depths without stack overflow. This demonstrates how named functions differ from anonymous lambda expressions in their binding semantics.</p>\n<blockquote>\n<p><strong>Decision: Minimal but Complete Feature Set</strong></p>\n<ul>\n<li><strong>Context</strong>: We could implement either a toy calculator or a full Lisp with macros, I/O, and modules</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Calculator with arithmetic only</li>\n<li>Minimal Lisp with functions and lists</li>\n<li>Full Lisp with macros and I/O</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Minimal Lisp with functions and lists</li>\n<li><strong>Rationale</strong>: Option 1 doesn&#39;t demonstrate environments or closures. Option 3 adds complexity without teaching core interpreter concepts. Option 2 teaches all fundamental concepts while remaining implementable in a learning context.</li>\n<li><strong>Consequences</strong>: Students learn complete interpreter pipeline while avoiding feature creep that obscures core concepts.</li>\n</ul>\n</blockquote>\n<h3 id=\"explicit-non-goals\">Explicit Non-Goals</h3>\n<p>To maintain focus on core interpreter concepts, we explicitly exclude several advanced features that, while interesting, would complicate the architecture without providing proportional learning value. Understanding what we&#39;re not building is as important as understanding what we are building.</p>\n<p><strong>Advanced Language Features</strong></p>\n<p>Several Lisp features require sophisticated implementation techniques that would obscure the fundamental concepts we&#39;re trying to teach.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Feature</th>\n<th>Why Excluded</th>\n<th>Complexity Added</th>\n<th>Learning Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Macros</td>\n<td>Require compile-time evaluation and code transformation</td>\n<td>Meta-circular evaluation, hygiene rules</td>\n<td>Distracts from basic evaluation model</td>\n</tr>\n<tr>\n<td>Multiple Value Return</td>\n<td>Needs special calling conventions</td>\n<td>Modified function application protocol</td>\n<td>Adds complexity without teaching core concepts</td>\n</tr>\n<tr>\n<td>Exceptions/Error Handling</td>\n<td>Requires unwinding and handler search</td>\n<td>Control flow stack management</td>\n<td>Better learned after mastering basic evaluation</td>\n</tr>\n<tr>\n<td>Tail Call Optimization</td>\n<td>Complex stack frame management</td>\n<td>Optimization and space analysis</td>\n<td>Advanced topic for performance, not correctness</td>\n</tr>\n<tr>\n<td>Garbage Collection</td>\n<td>Memory management implementation</td>\n<td>Reference counting or mark-sweep algorithms</td>\n<td>Separate concern from language semantics</td>\n</tr>\n</tbody></table>\n<p>Macros, in particular, would require implementing a macro expansion phase before evaluation, introducing concepts like compile-time versus runtime, hygiene, and meta-circular evaluation that would significantly complicate the mental model.</p>\n<p><strong>Advanced Data Types and Operations</strong></p>\n<p>While many Lisps provide rich data type libraries, our minimal implementation focuses on the types necessary to demonstrate core evaluation concepts.</p>\n<table>\n<thead>\n<tr>\n<th>Excluded Type</th>\n<th>Alternative in Our Lisp</th>\n<th>Reasoning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Vectors/Arrays</td>\n<td>Lists with <code>car</code>/<code>cdr</code></td>\n<td>Lists demonstrate recursive data structures adequately</td>\n</tr>\n<tr>\n<td>Hash Tables/Maps</td>\n<td>Association lists <code>((key . value) ...)</code></td>\n<td>Simple nested lists teach same concepts</td>\n</tr>\n<tr>\n<td>Characters</td>\n<td>Single-character strings</td>\n<td>String handling demonstrates tokenization sufficiently</td>\n</tr>\n<tr>\n<td>Multiple Numeric Types</td>\n<td>Generic numeric tower</td>\n<td>Complexity doesn&#39;t teach interpretation concepts</td>\n</tr>\n<tr>\n<td>Regular Expressions</td>\n<td>String operations if needed</td>\n<td>Pattern matching is separate from evaluation</td>\n</tr>\n</tbody></table>\n<p>Using lists for all compound data keeps the implementation simple while still allowing students to build any data structure they need through composition.</p>\n<p><strong>Performance Optimizations</strong></p>\n<p>Our interpreter prioritizes code clarity and educational value over runtime performance. Several optimization techniques are explicitly excluded to keep the implementation straightforward.</p>\n<table>\n<thead>\n<tr>\n<th>Optimization</th>\n<th>Performance Benefit</th>\n<th>Implementation Cost</th>\n<th>Educational Trade-off</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Bytecode Compilation</td>\n<td>10-100x speedup</td>\n<td>Compiler infrastructure, VM design</td>\n<td>Obscures direct evaluation model</td>\n</tr>\n<tr>\n<td>Just-In-Time Compilation</td>\n<td>100-1000x speedup</td>\n<td>Code generation, optimization passes</td>\n<td>Far beyond scope of basic interpreter</td>\n</tr>\n<tr>\n<td>Constant Folding</td>\n<td>Modest improvement</td>\n<td>AST analysis and transformation</td>\n<td>Adds compilation phase complexity</td>\n</tr>\n<tr>\n<td>Instruction Caching</td>\n<td>Modest improvement</td>\n<td>Memoization infrastructure</td>\n<td>Doesn&#39;t teach interpretation concepts</td>\n</tr>\n</tbody></table>\n<p>We implement a tree-walking interpreter that directly evaluates the AST because this approach provides the clearest mapping between source code and evaluation steps, making it easier to understand and debug.</p>\n<p><strong>Development Environment Features</strong></p>\n<p>While a complete Lisp system would include development tools, these features don&#39;t contribute to understanding the core interpreter implementation.</p>\n<table>\n<thead>\n<tr>\n<th>Tool Category</th>\n<th>Examples</th>\n<th>Why Excluded</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Interactive REPL Features</td>\n<td>Command history, tab completion, syntax highlighting</td>\n<td>UI concerns separate from language implementation</td>\n</tr>\n<tr>\n<td>Debugging Tools</td>\n<td>Breakpoints, step execution, variable inspection</td>\n<td>Debugging infrastructure orthogonal to evaluation</td>\n</tr>\n<tr>\n<td>Module System</td>\n<td>File loading, namespace management, export/import</td>\n<td>File I/O and dependency management complexity</td>\n</tr>\n<tr>\n<td>Standard Library</td>\n<td>File operations, network I/O, system calls</td>\n<td>External API integration beyond interpreter scope</td>\n</tr>\n<tr>\n<td>Documentation Tools</td>\n<td>Docstring extraction, help system</td>\n<td>Meta-programming unrelated to evaluation</td>\n</tr>\n</tbody></table>\n<p>Students can add a basic REPL loop around their interpreter, but sophisticated REPL features would require significant additional infrastructure.</p>\n<p><strong>Concurrency and Parallelism</strong></p>\n<p>Modern languages often include concurrency primitives, but these features add substantial complexity without teaching interpreter fundamentals.</p>\n<table>\n<thead>\n<tr>\n<th>Concurrency Feature</th>\n<th>Complexity Added</th>\n<th>Why Excluded</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Threading Support</td>\n<td>Thread-safe environments, locking</td>\n<td>Concurrency is separate from sequential evaluation</td>\n</tr>\n<tr>\n<td>Async/Await</td>\n<td>Continuation-passing style, event loops</td>\n<td>Advanced control flow beyond basic interpretation</td>\n</tr>\n<tr>\n<td>Channels/Message Passing</td>\n<td>Inter-process communication</td>\n<td>System programming unrelated to language semantics</td>\n</tr>\n<tr>\n<td>Atomic Operations</td>\n<td>Memory model, synchronization</td>\n<td>Hardware-level concerns beyond language design</td>\n</tr>\n</tbody></table>\n<p>Sequential evaluation is complex enough for a learning project. Concurrent evaluation requires understanding both interpretation and concurrency, which is too much for a single project.</p>\n<p><strong>Error Recovery and IDE Integration</strong></p>\n<p>Production language implementations include sophisticated error recovery and tooling integration, but these features focus on user experience rather than interpreter fundamentals.</p>\n<table>\n<thead>\n<tr>\n<th>Feature Category</th>\n<th>Examples</th>\n<th>Implementation Burden</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Recovery</td>\n<td>Partial parsing after syntax errors</td>\n<td>Requires error production handling in parser</td>\n</tr>\n<tr>\n<td>IDE Integration</td>\n<td>Language server protocol, semantic highlighting</td>\n<td>API design and tooling infrastructure</td>\n</tr>\n<tr>\n<td>Static Analysis</td>\n<td>Type checking, unused variable detection</td>\n<td>Separate analysis passes and type systems</td>\n</tr>\n<tr>\n<td>Code Formatting</td>\n<td>Pretty-printing, automatic indentation</td>\n<td>Text processing unrelated to evaluation</td>\n</tr>\n<tr>\n<td>Refactoring Support</td>\n<td>Rename, extract function, inline</td>\n<td>Program transformation and analysis</td>\n</tr>\n</tbody></table>\n<p>Our interpreter reports errors and stops, which is sufficient for understanding how errors propagate through the interpretation pipeline.</p>\n<blockquote>\n<p><strong>Decision: Educational Focus Over Production Features</strong></p>\n<ul>\n<li><strong>Context</strong>: We could build either a learning interpreter or a production-ready language implementation</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Minimal educational interpreter with clear code</li>\n<li>Production interpreter with error recovery, optimization, and tooling</li>\n<li>Hybrid approach with some production features</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Minimal educational interpreter</li>\n<li><strong>Rationale</strong>: Production features like error recovery, optimization, and IDE integration require substantial additional code that obscures the core interpretation concepts. Students learn better from clear, simple implementations.</li>\n<li><strong>Consequences</strong>: Code is easier to understand and modify, but the interpreter is not suitable for real programming tasks beyond learning exercises.</li>\n</ul>\n</blockquote>\n<p>This careful scoping ensures that every feature we implement directly contributes to understanding interpreter design, while excluded features can be added later as advanced exercises once the core concepts are mastered. The result is a complete, working Lisp that demonstrates all the essential interpreter components without unnecessary complexity.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>A. Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Core Data Types</td>\n<td>Native Python types (int, float, str, list)</td>\n<td>Custom LispValue classes with type tagging</td>\n</tr>\n<tr>\n<td>Environment Storage</td>\n<td>Python dict with parent references</td>\n<td>Custom Environment class with optimized lookup</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Python exceptions with custom classes</td>\n<td>Result types with error chaining</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>Python unittest (built-in)</td>\n<td>pytest with fixtures and parametrization</td>\n</tr>\n<tr>\n<td>REPL Interface</td>\n<td>Simple input/print loop</td>\n<td>readline with history and completion</td>\n</tr>\n</tbody></table>\n<p>For learning purposes, start with native Python types and gradually refactor to custom classes as you understand the requirements better.</p>\n<p><strong>B. Recommended File Structure</strong></p>\n<p>Organize your interpreter into logical modules that separate concerns and make testing easier:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lisp-interpreter/\n├── src/\n│   ├── __init__.py\n│   ├── tokenizer.py          # Milestone 1: S-expression parsing\n│   ├── parser.py             # Milestone 1: AST construction\n│   ├── evaluator.py          # Milestones 2-4: Core evaluation engine\n│   ├── environment.py        # Milestone 3: Variable scoping\n│   ├── functions.py          # Milestone 3: Lambda and application\n│   ├── builtins.py           # Milestones 2-4: Built-in functions\n│   ├── errors.py             # All milestones: Error definitions\n│   └── repl.py               # Interactive loop (optional)\n├── tests/\n│   ├── __init__.py\n│   ├── test_tokenizer.py     # Unit tests for each component\n│   ├── test_parser.py\n│   ├── test_evaluator.py\n│   ├── test_environment.py\n│   ├── test_functions.py\n│   └── test_integration.py   # End-to-end tests\n├── examples/\n│   ├── arithmetic.lisp       # Test programs for each milestone\n│   ├── variables.lisp\n│   ├── functions.lisp\n│   └── recursion.lisp\n└── main.py                   # Entry point and REPL</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p>Here&#39;s complete infrastructure code for error handling and basic types that you can use immediately:</p>\n<p><strong>errors.py</strong> (Complete implementation):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Error classes for the Lisp interpreter.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">These provide structured error reporting throughout the interpretation pipeline.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all Lisp interpreter errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, source_location: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.source_location </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source_location</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.format_message())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_message</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.source_location </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Error at position </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.source_location</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Error: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenizerError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when tokenization fails (unclosed strings, invalid characters).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when parsing fails (unbalanced parentheses, unexpected EOF).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EvaluationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when evaluation fails (general evaluation problems).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> NameError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when a variable or function name cannot be found.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when an operation is applied to wrong types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArityError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when a function is called with wrong number of arguments.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, expected: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, actual: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, function_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, source_location: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expected </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expected</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.actual </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.function_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> function_name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Function '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">function_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">' expects </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> arguments, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">actual</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, source_location)</span></span></code></pre></div>\n\n<p><strong>types.py</strong> (Complete implementation):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Core data types for Lisp values.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides type-safe representation of all Lisp data.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, List, Callable, Optional, Dict</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispValueType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NUMBER</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"number\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SYMBOL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"symbol\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LIST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"list\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FUNCTION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"function\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BUILTIN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"builtin\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispValue</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents any value in the Lisp system.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, value: Any, type: LispValueType):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.type </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __repr__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"LispValue(</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __eq__</span><span style=\"color:#E1E4E8\">(self, other) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(other, LispValue):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.value </span><span style=\"color:#F97583\">and</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.type</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Constants for special values</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">LISP_TRUE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> LispValue(</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, LispValueType.</span><span style=\"color:#79B8FF\">SYMBOL</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">LISP_FALSE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> LispValue(</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, LispValueType.</span><span style=\"color:#79B8FF\">SYMBOL</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">EMPTY_LIST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> LispValue([], LispValueType.</span><span style=\"color:#79B8FF\">LIST</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Constructor functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_number</span><span style=\"color:#E1E4E8\">(value: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Creates a numeric LispValue.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> LispValue(value, LispValueType.</span><span style=\"color:#79B8FF\">NUMBER</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_symbol</span><span style=\"color:#E1E4E8\">(name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Creates a symbol LispValue.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> LispValue(name, LispValueType.</span><span style=\"color:#79B8FF\">SYMBOL</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_list</span><span style=\"color:#E1E4E8\">(elements: List[LispValue]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Creates a list LispValue.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> LispValue(elements, LispValueType.</span><span style=\"color:#79B8FF\">LIST</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Type predicate functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_number</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Checks if value is a number.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LispValueType.</span><span style=\"color:#79B8FF\">NUMBER</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_symbol</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Checks if value is a symbol.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LispValueType.</span><span style=\"color:#79B8FF\">SYMBOL</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_list</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Checks if value is a list.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LispValueType.</span><span style=\"color:#79B8FF\">LIST</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_truthy</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Determines if a value is truthy in Lisp semantics.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # In our Lisp, only #f (false) is falsy, everything else is truthy</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> LISP_FALSE</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<p>Here are the main function signatures you&#39;ll implement, with detailed TODO steps:</p>\n<p><strong>tokenizer.py</strong> (Skeleton for you to implement):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TokenizerError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> tokenize</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Converts Lisp source text into a list of tokens.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Handles parentheses, atoms, string literals, and comments.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Loop through each character in text</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Skip whitespace characters (space, tab, newline)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle semicolon comments - skip to end of line</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle opening and closing parentheses as separate tokens</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle string literals - collect characters until closing quote</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle atoms (numbers and symbols) - collect until delimiter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Raise TokenizerError for invalid characters or unclosed strings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use str.isspace() to check for whitespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Track line numbers for better error reporting</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> tokens</span></span></code></pre></div>\n\n<p><strong>parser.py</strong> (Skeleton for you to implement):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispValue, make_number, make_symbol, make_list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ParseError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse</span><span style=\"color:#E1E4E8\">(tokens: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Parses a list of tokens into a LispValue AST.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Handles nested lists and quote syntax transformation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> tokens:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> ParseError(</span><span style=\"color:#9ECBFF\">\"Unexpected end of input\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create a token iterator to track current position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call read_expression to parse the first complete expression</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify that all tokens were consumed (no extra closing parens)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the parsed expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> read_expression</span><span style=\"color:#E1E4E8\">(token_iter):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Get the next token from the iterator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle opening paren - call read_list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Handle quote character - transform into (quote expr)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Handle atoms - determine if number or symbol</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Raise ParseError for unexpected tokens</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use float(token) in try/except to detect numbers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Quote 'x should become (quote x)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> read_list</span><span style=\"color:#E1E4E8\">(token_iter):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 10: Read expressions until closing paren</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 11: Handle nested lists recursively</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 12: Raise ParseError for unbalanced parentheses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 13: Return make_list() of collected expressions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ul>\n<li><strong>Type Checking</strong>: Use <code>isinstance(value, LispValue)</code> and check the <code>.type</code> field rather than checking Python types directly</li>\n<li><strong>Environment Chaining</strong>: Use a simple dict with a <code>parent</code> field pointing to the enclosing scope</li>\n<li><strong>Function Application</strong>: Create new environment with <code>{**closure_env, **param_bindings}</code> to extend the closure environment</li>\n<li><strong>Error Context</strong>: Pass token positions through parsing to provide better error locations</li>\n<li><strong>Recursion Handling</strong>: Python&#39;s default recursion limit (1000) should be sufficient for learning exercises</li>\n<li><strong>Testing</strong>: Use <code>unittest.TestCase</code> and create helper methods like <code>self.eval_expr(&quot;(+ 1 2)&quot;)</code> for easy test writing</li>\n</ul>\n<p><strong>F. Milestone Checkpoints</strong></p>\n<p>After implementing each milestone, verify these behaviors:</p>\n<p><strong>Milestone 1 - S-Expression Parser:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_tokenizer.py</span><span style=\"color:#9ECBFF\"> tests/test_parser.py</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n<p>Expected behavior:</p>\n<ul>\n<li><code>tokenize(&quot;(+ 1 2)&quot;)</code> returns <code>[&quot;(&quot;, &quot;+&quot;, &quot;1&quot;, &quot;2&quot;, &quot;)&quot;]</code></li>\n<li><code>parse([&quot;(&quot;, &quot;+&quot;, &quot;1&quot;, &quot;2&quot;, &quot;)&quot;])</code> returns nested LispValue structures</li>\n<li><code>parse([&quot;&#39;&quot;, &quot;x&quot;])</code> becomes <code>(quote x)</code> form</li>\n<li>Comments and extra whitespace are ignored</li>\n</ul>\n<p><strong>Milestone 2 - Basic Evaluation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_evaluator.py::test_arithmetic</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n<p>Test these expressions in a REPL:</p>\n<ul>\n<li><code>42</code> → <code>42</code></li>\n<li><code>(+ 1 2 3)</code> → <code>6</code></li>\n<li><code>(&lt; 5 10)</code> → <code>#t</code></li>\n<li><code>(if #t 1 2)</code> → <code>1</code></li>\n</ul>\n<p><strong>Milestone 3 - Variables and Functions:</strong>\nTest these programs:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lisp</span><pre class=\"arch-pre shiki-highlighted\"><code>(define x 42)\nx  ; Should return 42\n\n(define square (lambda (n) (* n n)))\n(square 5)  ; Should return 25\n\n(let ((x 1) (y 2)) (+ x y))  ; Should return 3</code></pre></div>\n\n<p><strong>Milestone 4 - List Operations &amp; Recursion:</strong>\nTest recursive factorial:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lisp</span><pre class=\"arch-pre shiki-highlighted\"><code>(define factorial \n  (lambda (n) \n    (if (= n 0) \n        1 \n        (* n (factorial (- n 1))))))\n(factorial 5)  ; Should return 120</code></pre></div>\n\n<p><strong>G. Debugging Tips</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Symbol not found&quot; errors</td>\n<td>Environment lookup failing</td>\n<td>Print environment contents during lookup</td>\n<td>Check environment chaining and variable binding</td>\n</tr>\n<tr>\n<td>Infinite recursion in evaluation</td>\n<td>Evaluating arguments of special forms</td>\n<td>Add debug prints to evaluator dispatch</td>\n<td>Don&#39;t evaluate arguments of <code>if</code>, <code>define</code>, <code>lambda</code></td>\n</tr>\n<tr>\n<td>Parser crashes on nested lists</td>\n<td>Recursion not handling token consumption</td>\n<td>Trace token iterator position</td>\n<td>Ensure each <code>read_expression</code> consumes exactly one complete expression</td>\n</tr>\n<tr>\n<td>Functions can&#39;t see their parameters</td>\n<td>New environment not extending closure</td>\n<td>Print environment chain during application</td>\n<td>New environment should have closure environment as parent</td>\n</tr>\n<tr>\n<td>Quote not working</td>\n<td>Quote syntax not transformed</td>\n<td>Check parser output for quoted expressions</td>\n<td>Transform <code>&#39;x</code> to <code>(quote x)</code> during parsing</td>\n</tr>\n</tbody></table>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - the three-stage pipeline and module organization provides the foundational structure for the entire interpreter implementation</p>\n</blockquote>\n<p>Building a Lisp interpreter requires transforming human-readable text into executable computations through a carefully orchestrated pipeline. The architecture we present here follows the classical interpreter design pattern of <strong>separation of concerns</strong>, where each stage has a single, well-defined responsibility. This design enables independent development, testing, and debugging of each component while maintaining clear data flow boundaries.</p>\n<p>The fundamental challenge in interpreter architecture is balancing simplicity with extensibility. We need a design that is approachable for learning purposes yet robust enough to support the full spectrum of Lisp language features. Our solution employs a <strong>three-stage pipeline</strong> architecture that mirrors how human programmers mentally process code: first we identify the basic building blocks (tokenization), then we understand the structure (parsing), and finally we compute the meaning (evaluation).</p>\n<h3 id=\"three-stage-pipeline-how-text-flows-through-tokenizer-parser-and-evaluator-stages\">Three-Stage Pipeline: How Text Flows Through Tokenizer, Parser, and Evaluator Stages</h3>\n<p>Think of our interpreter pipeline as a <strong>factory assembly line for ideas</strong>. Raw text enters one end as an unstructured stream of characters, and executable results emerge from the other end. Each stage in the pipeline performs a specific transformation, converting the input into a more structured, more meaningful representation. Like a real assembly line, each station depends on receiving properly formatted input from the previous station and produces standardized output for the next station.</p>\n<p><img src=\"/api/project/lisp-interp/architecture-doc/asset?path=diagrams%2Fsystem-architecture.svg\" alt=\"System Component Architecture\"></p>\n<p>The three stages represent progressively higher levels of abstraction and semantic understanding. The tokenizer operates at the <strong>lexical level</strong>, identifying individual symbols, numbers, and punctuation without understanding their relationships. The parser operates at the <strong>syntactic level</strong>, recognizing how tokens combine into meaningful structures like lists and nested expressions. The evaluator operates at the <strong>semantic level</strong>, computing the actual meaning and results of these structures within the context of variable bindings and function definitions.</p>\n<p><strong>Stage 1: Tokenization - From Characters to Symbols</strong></p>\n<p>The tokenizer serves as the <strong>lexical scanner</strong> that converts raw character streams into a sequence of meaningful tokens. This stage handles the low-level details of character encoding, whitespace handling, and comment removal, producing a clean stream of atomic elements that the parser can work with. The tokenizer is responsible for recognizing the boundaries between different syntactic elements and classifying each element into its appropriate token type.</p>\n<p>The tokenizer&#39;s primary responsibility is <strong>character classification and boundary detection</strong>. It must distinguish between symbol characters, numeric digits, string delimiters, parentheses, and whitespace. It also handles special cases like negative numbers (where the minus sign is part of the number token rather than a separate operator), string escapes, and comment syntax. The output is a linear sequence of tokens, each tagged with its type and source location for error reporting.</p>\n<table>\n<thead>\n<tr>\n<th>Token Type</th>\n<th>Recognition Pattern</th>\n<th>Examples</th>\n<th>Error Conditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>NUMBER</code></td>\n<td>Digits with optional decimal point and negative sign</td>\n<td><code>42</code>, <code>-3.14</code>, <code>0</code></td>\n<td>Invalid number format, overflow</td>\n</tr>\n<tr>\n<td><code>SYMBOL</code></td>\n<td>Alphanumeric characters and allowed punctuation</td>\n<td><code>+</code>, <code>define</code>, <code>car</code></td>\n<td>Reserved keywords (handled by parser)</td>\n</tr>\n<tr>\n<td><code>STRING</code></td>\n<td>Characters enclosed in double quotes</td>\n<td><code>&quot;hello&quot;</code>, <code>&quot;world\\n&quot;</code></td>\n<td>Unterminated string, invalid escapes</td>\n</tr>\n<tr>\n<td><code>LEFT_PAREN</code></td>\n<td>Opening parenthesis character</td>\n<td><code>(</code></td>\n<td>Never an error at tokenizer level</td>\n</tr>\n<tr>\n<td><code>RIGHT_PAREN</code></td>\n<td>Closing parenthesis character</td>\n<td><code>)</code></td>\n<td>Never an error at tokenizer level</td>\n</tr>\n<tr>\n<td><code>QUOTE</code></td>\n<td>Single quote character</td>\n<td><code>&#39;</code></td>\n<td>Never an error at tokenizer level</td>\n</tr>\n</tbody></table>\n<p><strong>Stage 2: Parsing - From Tokens to Structure</strong></p>\n<p>The parser transforms the flat sequence of tokens into a <strong>hierarchical Abstract Syntax Tree (AST)</strong> that represents the nested structure of S-expressions. This stage implements the core principle of Lisp&#39;s <strong>homoiconicity</strong> - the property that code and data share the same representation. The parser&#39;s output is a tree of <code>LispValue</code> objects that can represent both the program structure and the data the program manipulates.</p>\n<p>The parser employs a <strong>recursive descent strategy</strong> that mirrors the recursive nature of S-expressions. When it encounters an opening parenthesis, it recursively parses the contents until it finds the matching closing parenthesis, building nested list structures of arbitrary depth. The parser also handles <strong>quote syntax transformation</strong>, converting the <code>&#39;expr</code> shorthand into the equivalent <code>(quote expr)</code> list form that the evaluator can process uniformly.</p>\n<table>\n<thead>\n<tr>\n<th>Parse Element</th>\n<th>Input Tokens</th>\n<th>Output AST</th>\n<th>Recursive Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Atom</td>\n<td><code>NUMBER</code> or <code>SYMBOL</code> or <code>STRING</code></td>\n<td><code>LispValue</code> with appropriate type</td>\n<td>Base case - no recursion</td>\n</tr>\n<tr>\n<td>List</td>\n<td><code>LEFT_PAREN</code> ... <code>RIGHT_PAREN</code></td>\n<td><code>LispValue</code> with <code>LIST</code> type</td>\n<td>Recursive calls for each element</td>\n</tr>\n<tr>\n<td>Quoted Expression</td>\n<td><code>QUOTE</code> followed by expression</td>\n<td><code>(quote &lt;expression&gt;)</code> list</td>\n<td>Single recursive call for quoted expression</td>\n</tr>\n<tr>\n<td>Empty List</td>\n<td><code>LEFT_PAREN</code> <code>RIGHT_PAREN</code></td>\n<td><code>EMPTY_LIST</code> constant</td>\n<td>Base case - no recursion</td>\n</tr>\n</tbody></table>\n<p>The parser maintains a <strong>token cursor</strong> that advances through the token stream as it consumes input. Error handling at this stage primarily involves detecting <strong>unbalanced parentheses</strong> and <strong>unexpected end-of-file</strong> conditions. When an error occurs, the parser includes source location information from the original tokens to help users locate problems in their source code.</p>\n<p><strong>Stage 3: Evaluation - From Structure to Results</strong></p>\n<p>The evaluator is the <strong>semantic engine</strong> that computes the actual meaning of parsed expressions within the context of variable bindings and function definitions. This stage implements the core evaluation rules that define Lisp&#39;s behavior: self-evaluating literals, variable lookup, special form handling, and function application. The evaluator operates on the AST produced by the parser and produces final results that can be displayed to the user or used as input to further computations.</p>\n<p>The evaluator&#39;s architecture centers around a <strong>dispatch mechanism</strong> that examines each AST node and applies the appropriate evaluation rule based on the node&#39;s type and structure. This design enables clean separation between different language constructs while maintaining a unified evaluation interface. The evaluator also manages the <strong>environment system</strong> that tracks variable bindings and implements lexical scoping rules.</p>\n<table>\n<thead>\n<tr>\n<th>Expression Type</th>\n<th>Evaluation Rule</th>\n<th>Environment Interaction</th>\n<th>Result Type</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Number Literal</td>\n<td>Return the number unchanged</td>\n<td>None - self-evaluating</td>\n<td><code>LispValue</code> with <code>NUMBER</code> type</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>Look up symbol in current environment</td>\n<td>Variable lookup with scope chain traversal</td>\n<td><code>LispValue</code> of whatever type was bound</td>\n</tr>\n<tr>\n<td>Empty List</td>\n<td>Evaluate to empty list</td>\n<td>None - self-evaluating</td>\n<td><code>EMPTY_LIST</code> constant</td>\n</tr>\n<tr>\n<td>Non-empty List</td>\n<td>Dispatch based on first element</td>\n<td>Environment passed to special forms and functions</td>\n<td>Depends on operation performed</td>\n</tr>\n</tbody></table>\n<p>The evaluator distinguishes between <strong>special forms</strong> and <strong>function calls</strong> - a critical architectural decision that enables Lisp&#39;s powerful macro system and control structures. Special forms like <code>if</code>, <code>define</code>, and <code>lambda</code> receive their arguments unevaluated and control the evaluation process themselves. Function calls evaluate all their arguments before applying the function to the resulting values.</p>\n<blockquote>\n<p><strong>Decision: Tree-Walking Evaluation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to choose how to execute the parsed AST - direct interpretation, bytecode compilation, or tree-walking evaluation</li>\n<li><strong>Options Considered</strong>: Bytecode virtual machine, direct AST interpretation, compilation to target language</li>\n<li><strong>Decision</strong>: Direct tree-walking evaluation of AST nodes</li>\n<li><strong>Rationale</strong>: Tree-walking provides the simplest implementation path with direct correspondence between source code and evaluation logic, making it ideal for learning interpreter concepts. Performance is adequate for educational purposes.</li>\n<li><strong>Consequences</strong>: Slower execution than bytecode VMs but dramatically simpler implementation. Each evaluation step directly corresponds to AST traversal, making debugging intuitive.</li>\n</ul>\n</blockquote>\n<p><strong>Pipeline Data Flow and Error Propagation</strong></p>\n<p>The pipeline processes input through a <strong>sequential transformation chain</strong> where each stage consumes the output of the previous stage. Error conditions at any stage halt the pipeline and propagate error information back to the user with appropriate context and source location details. This design ensures that errors are detected as early as possible and reported with maximum helpful information.</p>\n<table>\n<thead>\n<tr>\n<th>Stage</th>\n<th>Input</th>\n<th>Output</th>\n<th>Error Types</th>\n<th>Error Propagation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tokenizer</td>\n<td>Raw text string</td>\n<td>Token sequence</td>\n<td><code>TokenizerError</code> for invalid characters/strings</td>\n<td>Immediate halt with character position</td>\n</tr>\n<tr>\n<td>Parser</td>\n<td>Token sequence</td>\n<td>AST root node</td>\n<td><code>ParseError</code> for syntax errors</td>\n<td>Immediate halt with token position</td>\n</tr>\n<tr>\n<td>Evaluator</td>\n<td>AST root node</td>\n<td><code>LispValue</code> result</td>\n<td><code>EvaluationError</code>, <code>NameError</code>, <code>TypeError</code>, <code>ArityError</code></td>\n<td>Immediate halt with expression context</td>\n</tr>\n</tbody></table>\n<p>The pipeline maintains <strong>source location tracking</strong> throughout all stages to enable precise error reporting. Tokens carry position information from the original source text, AST nodes inherit position data from their constituent tokens, and evaluation errors include the expression being evaluated when the error occurred.</p>\n<h3 id=\"recommended-module-organization-how-to-structure-the-codebase-for-maintainability-and-testability\">Recommended Module Organization: How to Structure the Codebase for Maintainability and Testability</h3>\n<p>The module organization follows <strong>separation of concerns</strong> principles, with each major component isolated in its own module with clearly defined interfaces and minimal dependencies. This structure enables independent development and testing of each component while maintaining clean boundaries that prevent architectural violations. The organization also supports <strong>incremental development</strong> aligned with the project milestones.</p>\n<blockquote>\n<p><strong>Decision: Component-Based Module Structure</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to organize code to support independent development, testing, and maintenance of interpreter components</li>\n<li><strong>Options Considered</strong>: Single monolithic module, component-based separation, layer-based organization</li>\n<li><strong>Decision</strong>: Component-based modules with separate packages for tokenizer, parser, evaluator, and supporting types</li>\n<li><strong>Rationale</strong>: Component separation enables independent testing, reduces compilation dependencies, and maps directly to the three-stage pipeline architecture. Each component can be developed and debugged in isolation.</li>\n<li><strong>Consequences</strong>: More files and import statements but dramatically better maintainability, testability, and team development support.</li>\n</ul>\n</blockquote>\n<p><strong>Core Component Modules</strong></p>\n<p>The interpreter consists of four primary modules that correspond to the major architectural components. Each module encapsulates its implementation details while exposing a clean public interface for interaction with other components. The module boundaries align with the natural data flow of the pipeline, making the dependencies explicit and unidirectional.</p>\n<table>\n<thead>\n<tr>\n<th>Module</th>\n<th>Primary Responsibility</th>\n<th>Key Exports</th>\n<th>Dependencies</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>types</code></td>\n<td>Core data structures and shared constants</td>\n<td><code>LispValue</code>, <code>LispValueType</code>, error types</td>\n<td>None - foundation module</td>\n</tr>\n<tr>\n<td><code>tokenizer</code></td>\n<td>Convert text to token streams</td>\n<td><code>tokenize()</code> function, token types</td>\n<td><code>types</code> for error handling</td>\n</tr>\n<tr>\n<td><code>parser</code></td>\n<td>Convert tokens to AST</td>\n<td><code>parse()</code> function, quote handling</td>\n<td><code>types</code>, <code>tokenizer</code></td>\n</tr>\n<tr>\n<td><code>evaluator</code></td>\n<td>Execute AST in environments</td>\n<td><code>evaluate()</code> function, built-in functions</td>\n<td><code>types</code>, <code>parser</code></td>\n</tr>\n</tbody></table>\n<p><strong>Supporting Infrastructure Modules</strong></p>\n<p>Beyond the core pipeline components, the interpreter requires several supporting modules that provide infrastructure services. These modules handle cross-cutting concerns like environment management, built-in function definitions, and error handling utilities. The supporting modules are designed to be <strong>implementation details</strong> that can be refactored without affecting the core pipeline interface.</p>\n<table>\n<thead>\n<tr>\n<th>Module</th>\n<th>Primary Responsibility</th>\n<th>Key Exports</th>\n<th>Used By</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>environment</code></td>\n<td>Variable binding and lexical scope</td>\n<td><code>Environment</code> class, lookup/binding methods</td>\n<td><code>evaluator</code></td>\n</tr>\n<tr>\n<td><code>builtins</code></td>\n<td>Built-in function implementations</td>\n<td>Arithmetic, comparison, list operation functions</td>\n<td><code>evaluator</code></td>\n</tr>\n<tr>\n<td><code>errors</code></td>\n<td>Error handling utilities</td>\n<td>Error formatting, source location tracking</td>\n<td>All modules</td>\n</tr>\n<tr>\n<td><code>repl</code></td>\n<td>Interactive read-eval-print loop</td>\n<td>Command-line interface, session management</td>\n<td>Main application</td>\n</tr>\n</tbody></table>\n<p><strong>Dependency Flow and Interface Design</strong></p>\n<p>The module dependency graph forms a <strong>directed acyclic graph (DAG)</strong> that prevents circular dependencies and enables clean compilation order. Dependencies flow in the direction of data processing: from foundation types through tokenization and parsing to evaluation. No component depends on modules that come later in the pipeline, ensuring that each stage can be developed and tested independently.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>types (foundation)\n  ↑\ntokenizer → parser → evaluator\n  ↑           ↑        ↑\nerrors    errors   errors, environment, builtins\n                      ↑\n                    repl (application)</code></pre></div>\n\n<p>Each module exposes a <strong>minimal public interface</strong> that hides implementation details while providing all necessary functionality for dependent modules. This design enables internal refactoring without breaking dependent code and makes the system easier to understand by reducing the cognitive load of understanding inter-module interactions.</p>\n<p><strong>Testing and Development Workflow</strong></p>\n<p>The module organization directly supports <strong>test-driven development</strong> and <strong>incremental implementation</strong> aligned with project milestones. Each module can be unit tested in isolation, and integration tests verify the interaction between components. The dependency structure ensures that lower-level components can be completed and tested before higher-level components that depend on them.</p>\n<table>\n<thead>\n<tr>\n<th>Development Phase</th>\n<th>Modules to Implement</th>\n<th>Testing Focus</th>\n<th>Integration Points</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Milestone 1</td>\n<td><code>types</code>, <code>tokenizer</code>, <code>parser</code></td>\n<td>Token recognition, AST construction</td>\n<td>Token stream format, AST structure</td>\n</tr>\n<tr>\n<td>Milestone 2</td>\n<td><code>evaluator</code>, <code>environment</code>, <code>builtins</code> (arithmetic)</td>\n<td>Basic evaluation rules, environment lookup</td>\n<td>AST evaluation interface</td>\n</tr>\n<tr>\n<td>Milestone 3</td>\n<td>Extend <code>evaluator</code> and <code>builtins</code> (variables, functions)</td>\n<td>Variable binding, function application</td>\n<td>Closure creation, scope management</td>\n</tr>\n<tr>\n<td>Milestone 4</td>\n<td>Extend <code>builtins</code> (list operations), optimize <code>evaluator</code></td>\n<td>List primitives, recursion support</td>\n<td>Tail call optimization</td>\n</tr>\n</tbody></table>\n<p><strong>Common Module Organization Pitfalls</strong></p>\n<p>⚠️ <strong>Pitfall: Circular Dependencies Between Core Components</strong>\nMany learners create circular dependencies by having the parser import evaluation utilities or the evaluator import parsing helpers. This violates the pipeline architecture and prevents independent testing. The fix is to move shared utilities into the <code>types</code> module or create separate utility modules that both components can import.</p>\n<p>⚠️ <strong>Pitfall: Monolithic Evaluator Module</strong>\nPutting all evaluation logic, environment management, and built-in functions in a single large module makes testing difficult and violates separation of concerns. The evaluator should focus on evaluation dispatch and delegate environment operations to the <code>environment</code> module and built-in function implementations to the <code>builtins</code> module.</p>\n<p>⚠️ <strong>Pitfall: Inconsistent Error Handling Across Modules</strong>\nEach module implementing its own error handling style creates inconsistent user experience and makes error testing difficult. All modules should use the shared error types from the <code>errors</code> module and follow consistent patterns for error creation and propagation.</p>\n<p>⚠️ <strong>Pitfall: Tight Coupling Through Global State</strong>\nUsing global variables for configuration or state creates hidden dependencies between modules and makes testing difficult. All state should be explicitly passed through function parameters or encapsulated in objects with clear ownership and lifecycle management.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The implementation strategy emphasizes <strong>incremental development</strong> with working code at each milestone. Start with the foundational types and build each component incrementally, testing thoroughly before moving to the next component. This approach ensures that each piece works correctly before adding complexity.</p>\n<p><strong>Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Approach</th>\n<th>Advanced Approach</th>\n<th>Recommended for Learning</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Module System</td>\n<td>Single file per component</td>\n<td>Package hierarchy with submodules</td>\n<td>Single file per component</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Exception-based with custom types</td>\n<td>Result types with error chaining</td>\n<td>Exception-based (simpler for beginners)</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>Built-in unittest module</td>\n<td>Property-based testing with hypothesis</td>\n<td>Built-in unittest (sufficient coverage)</td>\n</tr>\n<tr>\n<td>Documentation</td>\n<td>Inline docstrings</td>\n<td>Sphinx with API docs</td>\n<td>Inline docstrings (faster iteration)</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended Project Structure</strong></p>\n<p>Organize your code to support clean separation of concerns and easy navigation. Each module should live in its own file with clear naming that reflects its responsibility in the interpreter pipeline.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lisp-interpreter/\n├── main.py                    # Entry point and REPL implementation\n├── lisp/                      # Core interpreter package\n│   ├── __init__.py           # Package initialization and public API\n│   ├── types.py              # LispValue, LispValueType, error classes\n│   ├── tokenizer.py          # tokenize() and token handling\n│   ├── parser.py             # parse() and AST construction\n│   ├── evaluator.py          # evaluate() and evaluation dispatch\n│   ├── environment.py        # Environment class and scope management\n│   ├── builtins.py           # Built-in function implementations\n│   └── errors.py             # Error formatting and utility functions\n├── tests/                     # Test suite organized by component\n│   ├── test_tokenizer.py     # Unit tests for tokenization\n│   ├── test_parser.py        # Unit tests for parsing\n│   ├── test_evaluator.py     # Unit tests for evaluation\n│   ├── test_integration.py   # End-to-end integration tests\n│   └── fixtures/             # Test data files with example Lisp programs\n└── examples/                  # Example Lisp programs for manual testing\n    ├── arithmetic.lisp        # Basic math operations\n    ├── functions.lisp         # Lambda and function definition examples\n    └── recursion.lisp         # Recursive function examples</code></pre></div>\n\n<p><strong>Foundation Types Infrastructure (Complete)</strong></p>\n<p>This provides the complete type system that all other components will use. Copy this into <code>types.py</code> and import it in other modules:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Core data types and error classes for the Lisp interpreter.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides the foundation that all other components depend on.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, List, Optional, Union</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispValueType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Enumeration of all possible Lisp value types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NUMBER</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"NUMBER\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SYMBOL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"SYMBOL\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LIST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"LIST\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FUNCTION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"FUNCTION\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BUILTIN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"BUILTIN\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispValue</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Universal container for all values in the Lisp interpreter.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Combines the value data with type information for runtime type checking.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, value: Any, value_type: LispValueType):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value_type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __eq__</span><span style=\"color:#E1E4E8\">(self, other):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(other, LispValue):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.value </span><span style=\"color:#F97583\">and</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> other.type</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __repr__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"LispValue(</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Constants for special values</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">LISP_TRUE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> LispValue(</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, LispValueType.</span><span style=\"color:#79B8FF\">SYMBOL</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">LISP_FALSE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> LispValue(</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, LispValueType.</span><span style=\"color:#79B8FF\">SYMBOL</span><span style=\"color:#E1E4E8\">)  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">EMPTY_LIST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> LispValue([], LispValueType.</span><span style=\"color:#79B8FF\">LIST</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all interpreter errors with source location tracking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, source_location: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.source_location </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source_location</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenizerError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Errors that occur during tokenization phase.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Errors that occur during parsing phase.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EvaluationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for errors that occur during evaluation phase.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> NameError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Error for undefined variable references.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Error for type mismatches in operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArityError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Error for incorrect number of arguments to functions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, expected: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, actual: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, function_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, source_location: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expected </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expected</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.actual </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.function_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> function_name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">function_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> expects </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> arguments, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">actual</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, source_location)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Type constructor functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_number</span><span style=\"color:#E1E4E8\">(value: Union[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a numeric LispValue from int or float.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> LispValue(value, LispValueType.</span><span style=\"color:#79B8FF\">NUMBER</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_symbol</span><span style=\"color:#E1E4E8\">(name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a symbol LispValue from string name.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> LispValue(name, LispValueType.</span><span style=\"color:#79B8FF\">SYMBOL</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_list</span><span style=\"color:#E1E4E8\">(elements: List[LispValue]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a list LispValue from list of elements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> LispValue(elements, LispValueType.</span><span style=\"color:#79B8FF\">LIST</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Type predicate functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_number</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if value is a number.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LispValueType.</span><span style=\"color:#79B8FF\">NUMBER</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_symbol</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if value is a symbol.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LispValueType.</span><span style=\"color:#79B8FF\">SYMBOL</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_list</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if value is a list.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LispValueType.</span><span style=\"color:#79B8FF\">LIST</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_truthy</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Determine truthiness in Lisp: only LISP_FALSE is falsy.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Everything else, including empty lists and zero, is truthy.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> LISP_FALSE</span></span></code></pre></div>\n\n<p><strong>Core Component Skeleton Code</strong></p>\n<p>Here are the skeleton implementations for each major component. Each contains detailed TODO comments that map to the concepts explained in this section:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tokenizer.py - Convert text to tokens</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Tokenizer for Lisp S-expressions.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Handles numbers, symbols, strings, parentheses, quotes, and comments.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, NamedTuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TokenizerError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">NamedTuple</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Individual token with type and source location.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    type</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    position: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> tokenize</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[Token]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Convert input text into a sequence of tokens.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns list of Token objects representing numbers, symbols, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    parentheses, quotes, and string literals.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize empty token list and position counter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Iterate through each character in input text</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Skip whitespace characters (space, tab, newline)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle semicolon comments - skip to end of line</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Recognize parentheses as single-character tokens  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle quote character as QUOTE token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Parse string literals enclosed in double quotes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Parse numbers (integers and floats, including negative)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Parse symbols (everything else that's not whitespace/special)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 10: Return completed token list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use text.isdigit(), text.isalpha() for character classification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Handle string escapes like \\n, \\\", \\\\</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># parser.py - Convert tokens to AST</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Recursive descent parser for Lisp S-expressions.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Builds nested LispValue structures from token streams.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispValue, ParseError, make_symbol, make_number, make_list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .tokenizer </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Token</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse</span><span style=\"color:#E1E4E8\">(tokens: List[Token]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Parse a complete S-expression from token list.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns the root LispValue of the abstract syntax tree.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize token position counter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call read_expr to parse the first expression</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check that all tokens were consumed (no extra tokens)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the parsed expression</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use a mutable position counter that read_expr can update</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> read_expr</span><span style=\"color:#E1E4E8\">(tokens: List[Token], pos: List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Read a single expression from token stream.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Updates pos[0] to point to next unprocessed token.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check for end of token stream - raise ParseError if empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle QUOTE token - transform 'expr to (quote expr)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle LEFT_PAREN token - call read_list for nested structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle NUMBER token - convert to LispValue number</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle SYMBOL token - convert to LispValue symbol  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle STRING token - convert to LispValue string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Advance position counter before returning result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Quote transformation creates a list with 'quote' symbol and expression</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> read_list</span><span style=\"color:#E1E4E8\">(tokens: List[Token], pos: List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Read a parenthesized list from token stream.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Assumes LEFT_PAREN already consumed, reads until RIGHT_PAREN.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize empty list to collect elements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Loop until RIGHT_PAREN or end of tokens</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For each element, call read_expr recursively</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add each parsed element to the list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Consume the closing RIGHT_PAREN token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return LispValue list containing all elements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Handle empty lists () correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Detect unbalanced parentheses and raise ParseError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># evaluator.py - Execute AST in environments  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Core evaluation engine for Lisp expressions.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Implements evaluation rules for atoms, lists, special forms, and function calls.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispValue, EvaluationError, </span><span style=\"color:#79B8FF\">NameError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">TypeError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Environment</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(ast: LispValue, env: Environment) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Evaluate a Lisp expression in the given environment.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Implements the core evaluation rules based on expression type.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Handle self-evaluating atoms (numbers)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle symbol lookup in environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle empty list (evaluates to itself)  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle non-empty lists - check first element</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Dispatch to special form handlers (if, define, lambda)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle function application for regular function calls</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Evaluate arguments and apply function to results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use is_number(), is_symbol(), is_list() type predicates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Special forms get unevaluated arguments, functions get evaluated arguments</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_special_form</span><span style=\"color:#E1E4E8\">(symbol_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if a symbol names a special form.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return True for 'if', 'define', 'lambda', 'quote'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> apply_function</span><span style=\"color:#E1E4E8\">(func: LispValue, args: List[LispValue], env: Environment) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Apply a function to its arguments.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Handles both built-in functions and user-defined lambda functions.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check function type (BUILTIN vs FUNCTION)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For built-ins, call the Python function directly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For lambdas, create new environment with parameter bindings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Bind each parameter to corresponding argument value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Evaluate function body in the new environment  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return the result of body evaluation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Lambda functions store parameter list, body, and closure environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>Python-Specific Implementation Hints</strong></p>\n<ul>\n<li>Use <code>isinstance(obj, type)</code> for runtime type checking instead of manual type field inspection</li>\n<li>Use <code>enumerate()</code> when you need both index and value while iterating: <code>for i, char in enumerate(text)</code></li>\n<li>Use list slicing for token stream manipulation: <code>tokens[pos:]</code> to get remaining tokens</li>\n<li>Use <code>str.isdigit()</code>, <code>str.isalpha()</code>, <code>str.isalnum()</code> for character classification during tokenization</li>\n<li>Use <code>try/except</code> blocks for number parsing: <code>int(token)</code> and <code>float(token)</code> with exception handling</li>\n<li>Use dictionary dispatch for special forms: <code>special_forms = {&quot;if&quot;: eval_if, &quot;define&quot;: eval_define}</code></li>\n</ul>\n<p><strong>Milestone Checkpoint</strong></p>\n<p>After implementing the high-level architecture with skeleton components:</p>\n<ol>\n<li><strong>Run basic import test</strong>: <code>python -c &quot;import lisp.types, lisp.tokenizer, lisp.parser, lisp.evaluator&quot;</code></li>\n<li><strong>Expected output</strong>: No errors - all modules should import successfully</li>\n<li><strong>Test type constructors</strong>: Create <code>LispValue</code> instances with each type and verify they print correctly</li>\n<li><strong>Verify module boundaries</strong>: Tokenizer should not import parser, parser should not import evaluator</li>\n<li><strong>Test error classes</strong>: Create each error type and verify inheritance hierarchy works correctly</li>\n</ol>\n<p>If imports fail, check for circular dependencies or missing <code>__init__.py</code> files. If type constructors fail, verify the <code>LispValue</code> class implementation matches the specification exactly.</p>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - the data model provides the foundational structures used throughout tokenization (Milestone 1), parsing (Milestone 1), evaluation (Milestones 2-4), environment management (Milestone 3), and function operations (Milestones 3-4)</p>\n</blockquote>\n<h3 id=\"mental-model-the-universal-data-container\">Mental Model: The Universal Data Container</h3>\n<p>Think of our data model as a universal container system, like a warehouse that can hold different types of cargo. Just as a shipping warehouse needs containers that can hold automobiles, furniture, or electronics while maintaining their distinct properties, our Lisp interpreter needs a unified way to represent numbers, symbols, lists, and functions while preserving their unique characteristics.</p>\n<p>The key insight is that Lisp achieves its power through <strong>homoiconicity</strong> - the property where code and data use exactly the same representation. When you write <code>(+ 1 2)</code>, the parser sees this as a three-element list containing a symbol <code>+</code> followed by two numbers. When the evaluator processes this same list, it recognizes the special meaning: apply the addition function to the arguments 1 and 2. This dual nature - data structure during parsing, executable code during evaluation - requires our data model to be both flexible and precise.</p>\n<p><img src=\"/api/project/lisp-interp/architecture-doc/asset?path=diagrams%2Fdata-model.svg\" alt=\"Lisp Value Type Hierarchy\"></p>\n<p>Our data model serves three critical architectural purposes. First, it provides the <strong>runtime representation</strong> for all Lisp values during evaluation, ensuring type safety and enabling dynamic dispatch. Second, it defines the <strong>environment structure</strong> that implements lexical scoping through parent-child chains. Third, it establishes the <strong>abstract syntax tree</strong> format that bridges parsing and evaluation phases.</p>\n<blockquote>\n<p><strong>Architecture Principle: Uniform Value Representation</strong></p>\n<p>Every piece of data in our Lisp system - whether a number literal, a variable name, a list of expressions, or a function definition - is represented using the same <code>LispValue</code> wrapper type. This uniformity enables generic evaluation algorithms while maintaining type safety through runtime type checking.</p>\n</blockquote>\n<h3 id=\"lisp-value-types\">Lisp Value Types</h3>\n<p>The <code>LispValue</code> type serves as the universal container for all data in our interpreter. Every expression that gets parsed, every intermediate result during evaluation, and every value stored in an environment uses this same representation. This design choice reflects Lisp&#39;s fundamental philosophy that everything is data, and data can become executable code.</p>\n<h4 id=\"lispvalue-core-structure\">LispValue Core Structure</h4>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>value</code></td>\n<td><code>Any</code></td>\n<td>The actual data payload - could be int, float, str, list, or function object</td>\n</tr>\n<tr>\n<td><code>type</code></td>\n<td><code>LispValueType</code></td>\n<td>Discriminator tag indicating which interpretation to apply to the value field</td>\n</tr>\n</tbody></table>\n<h4 id=\"lispvaluetype-enumeration\">LispValueType Enumeration</h4>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Runtime Representation</th>\n<th>Typical Value Examples</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>NUMBER</code></td>\n<td><code>int</code> or <code>float</code></td>\n<td><code>42</code>, <code>3.14159</code>, <code>-17</code></td>\n</tr>\n<tr>\n<td><code>SYMBOL</code></td>\n<td><code>str</code></td>\n<td><code>x</code>, <code>+</code>, <code>lambda</code>, <code>define</code></td>\n</tr>\n<tr>\n<td><code>LIST</code></td>\n<td><code>List[LispValue]</code></td>\n<td><code>[]</code> (empty), <code>[make_symbol(&#39;+&#39;), make_number(1), make_number(2)]</code></td>\n</tr>\n<tr>\n<td><code>FUNCTION</code></td>\n<td><code>LispFunction</code></td>\n<td>User-defined lambda functions with parameter lists and closures</td>\n</tr>\n<tr>\n<td><code>BUILTIN</code></td>\n<td><code>BuiltinFunction</code></td>\n<td>Native Python functions like addition, comparison operators</td>\n</tr>\n</tbody></table>\n<p>The choice to use a discriminated union through the <code>type</code> field rather than inheritance reflects a pragmatic decision about runtime dispatch and serialization simplicity. Each type has distinct evaluation semantics and storage requirements.</p>\n<blockquote>\n<p><strong>Decision: Discriminated Union vs Inheritance</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to represent multiple data types in a uniform way while enabling type-specific operations</li>\n<li><strong>Options Considered</strong>: Class inheritance hierarchy, discriminated union with type tags, variant types</li>\n<li><strong>Decision</strong>: Discriminated union with <code>LispValueType</code> enum</li>\n<li><strong>Rationale</strong>: Simpler serialization, easier pattern matching in evaluator, no virtual method overhead, clearer type checking</li>\n<li><strong>Consequences</strong>: Enables straightforward type checking via <code>is_number()</code>, <code>is_symbol()</code>, etc., but requires explicit type field management</li>\n</ul>\n</blockquote>\n<h4 id=\"number-type-representation\">Number Type Representation</h4>\n<p>Numbers in our Lisp implementation support both integers and floating-point values within the same <code>NUMBER</code> type. The underlying Python value can be either <code>int</code> or <code>float</code>, with automatic promotion occurring during arithmetic operations.</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Integer Example</th>\n<th>Float Example</th>\n<th>Mixed Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Creation</td>\n<td><code>make_number(42)</code></td>\n<td><code>make_number(3.14)</code></td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>Type check</td>\n<td><code>is_number(val) and isinstance(val.value, int)</code></td>\n<td><code>is_number(val) and isinstance(val.value, float)</code></td>\n<td><code>is_number(val)</code></td>\n</tr>\n<tr>\n<td>Arithmetic</td>\n<td><code>42 + 17 = 59</code></td>\n<td><code>3.14 + 2.86 = 6.0</code></td>\n<td><code>42 + 3.14 = 45.14</code></td>\n</tr>\n</tbody></table>\n<p>The decision to support both integer and floating-point arithmetic within a single type reflects the mathematical nature of Lisp, where numeric operations should feel natural rather than requiring explicit type conversions.</p>\n<h4 id=\"symbol-type-representation\">Symbol Type Representation</h4>\n<p>Symbols represent identifiers in Lisp code - variable names, function names, and special form keywords. Unlike strings, symbols have <strong>identity semantics</strong> where two symbols with the same name should be considered identical for the purposes of variable lookup and comparison.</p>\n<table>\n<thead>\n<tr>\n<th>Symbol Category</th>\n<th>Examples</th>\n<th>Usage Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Variable names</td>\n<td><code>x</code>, <code>counter</code>, <code>my-variable</code></td>\n<td>Variable binding and lookup in environments</td>\n</tr>\n<tr>\n<td>Function names</td>\n<td><code>+</code>, <code>car</code>, <code>my-function</code></td>\n<td>Function application and definition</td>\n</tr>\n<tr>\n<td>Special forms</td>\n<td><code>if</code>, <code>define</code>, <code>lambda</code>, <code>quote</code></td>\n<td>Control evaluation flow in evaluator</td>\n</tr>\n<tr>\n<td>Boolean values</td>\n<td><code>#t</code>, <code>#f</code></td>\n<td>Truth values (though we use Python booleans internally)</td>\n</tr>\n</tbody></table>\n<p>The string representation of symbols allows for easy comparison and environment lookup, while the <code>SYMBOL</code> type tag distinguishes them from string literals during evaluation.</p>\n<h4 id=\"list-type-representation\">List Type Representation</h4>\n<p>Lists form the backbone of Lisp syntax, representing both data structures and executable code. Our implementation uses Python lists internally, with each element being a <code>LispValue</code> to maintain type uniformity.</p>\n<table>\n<thead>\n<tr>\n<th>List Type</th>\n<th>Internal Structure</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Empty list</td>\n<td><code>[]</code></td>\n<td><code>()</code> in source code</td>\n</tr>\n<tr>\n<td>Data list</td>\n<td><code>[make_number(1), make_number(2), make_number(3)]</code></td>\n<td><code>(1 2 3)</code> in source code</td>\n</tr>\n<tr>\n<td>Code list</td>\n<td><code>[make_symbol(&#39;+&#39;), make_number(1), make_number(2)]</code></td>\n<td><code>(+ 1 2)</code> in source code</td>\n</tr>\n<tr>\n<td>Nested list</td>\n<td><code>[make_symbol(&#39;list&#39;), make_list([make_number(1)]), make_number(2)]</code></td>\n<td><code>(list (1) 2)</code> in source code</td>\n</tr>\n</tbody></table>\n<p>The homoiconic property means that <code>(+ 1 2)</code> is simultaneously a data structure (three-element list) and an executable expression (function call). The evaluator determines the interpretation based on context.</p>\n<h4 id=\"function-type-representation\">Function Type Representation</h4>\n<p>Functions in our Lisp implementation come in two flavors: user-defined functions created by <code>lambda</code> expressions, and built-in functions implemented in Python. Both are wrapped in <code>LispValue</code> containers but have different internal representations.</p>\n<p><strong>User-Defined Functions (<code>LispFunction</code>)</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>parameters</code></td>\n<td><code>List[str]</code></td>\n<td>Parameter names that will be bound when function is called</td>\n</tr>\n<tr>\n<td><code>body</code></td>\n<td><code>LispValue</code></td>\n<td>The expression to evaluate when function is applied (typically a list)</td>\n</tr>\n<tr>\n<td><code>closure_env</code></td>\n<td><code>Environment</code></td>\n<td>The lexical environment captured when lambda was defined</td>\n</tr>\n<tr>\n<td><code>name</code></td>\n<td><code>Optional[str]</code></td>\n<td>Optional name for debugging and recursive calls</td>\n</tr>\n</tbody></table>\n<p><strong>Built-in Functions (<code>BuiltinFunction</code>)</strong>:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>implementation</code></td>\n<td><code>Callable</code></td>\n<td>Python function that implements the operation</td>\n</tr>\n<tr>\n<td><code>name</code></td>\n<td><code>str</code></td>\n<td>Function name for error reporting and debugging</td>\n</tr>\n<tr>\n<td><code>arity</code></td>\n<td><code>Optional[int]</code></td>\n<td>Expected argument count, or None for variadic functions</td>\n</tr>\n</tbody></table>\n<p>The distinction between user-defined and built-in functions reflects their different evaluation requirements. Built-ins can directly manipulate Python values, while user-defined functions must evaluate their bodies in properly constructed lexical environments.</p>\n<h4 id=\"type-predicate-functions\">Type Predicate Functions</h4>\n<p>Type checking in our interpreter uses predicate functions that examine the <code>type</code> field of <code>LispValue</code> objects. These predicates enable the evaluator to dispatch to appropriate handling logic.</p>\n<table>\n<thead>\n<tr>\n<th>Predicate</th>\n<th>Returns True When</th>\n<th>Example Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>is_number(value)</code></td>\n<td><code>value.type == LispValueType.NUMBER</code></td>\n<td>Arithmetic operation type checking</td>\n</tr>\n<tr>\n<td><code>is_symbol(value)</code></td>\n<td><code>value.type == LispValueType.SYMBOL</code></td>\n<td>Variable lookup and special form detection</td>\n</tr>\n<tr>\n<td><code>is_list(value)</code></td>\n<td><code>value.type == LispValueType.LIST</code></td>\n<td>Function application and list operations</td>\n</tr>\n<tr>\n<td><code>is_function(value)</code></td>\n<td><code>value.type in [LispValueType.FUNCTION, LispValueType.BUILTIN]</code></td>\n<td>Function application validation</td>\n</tr>\n<tr>\n<td><code>is_truthy(value)</code></td>\n<td>Complex boolean evaluation</td>\n<td>Conditional expression evaluation</td>\n</tr>\n</tbody></table>\n<p>The <code>is_truthy()</code> function deserves special attention as it implements Lisp&#39;s truth semantics: only the explicit false value <code>LISP_FALSE</code> is considered false, while everything else (including empty lists and zero) is considered true.</p>\n<h3 id=\"environment-structure\">Environment Structure</h3>\n<p>Environments implement <strong>lexical scoping</strong> in our interpreter by maintaining mappings from variable names to their bound values. Think of environments as nested filing cabinets where each cabinet represents a scope level, and variable lookup searches from the innermost cabinet outward until a matching folder is found.</p>\n<h4 id=\"mental-model-nested-filing-cabinets\">Mental Model: Nested Filing Cabinets</h4>\n<p>Imagine a series of filing cabinets arranged in a chain, where each cabinet represents a scope level in your program. When you define a function with <code>lambda</code>, it&#39;s like adding a new cabinet to the chain. When you look up a variable, you start with the most recently added cabinet (current scope) and work backward through the chain until you find a folder with that variable&#39;s name.</p>\n<p>The critical insight is that when a function captures its environment in a closure, it&#39;s like taking a snapshot of the entire cabinet chain as it existed when the function was defined. This captured chain travels with the function, ensuring that variables remain accessible even after the original scopes have been exited.</p>\n<h4 id=\"environment-core-structure\">Environment Core Structure</h4>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>bindings</code></td>\n<td><code>Dict[str, LispValue]</code></td>\n<td>Maps variable names to their current values in this scope level</td>\n</tr>\n<tr>\n<td><code>parent</code></td>\n<td><code>Optional[Environment]</code></td>\n<td>Reference to the enclosing scope, or None for global environment</td>\n</tr>\n</tbody></table>\n<h4 id=\"environment-chain-operations\">Environment Chain Operations</h4>\n<p>Variable lookup in lexical scoping follows a specific traversal pattern through the environment chain. The algorithm embodies the principle that inner scopes can shadow outer scopes, but cannot modify bindings in outer scopes (in our immutable approach).</p>\n<p><strong>Variable Lookup Algorithm:</strong></p>\n<ol>\n<li>Start with the current environment (innermost scope)</li>\n<li>Check if the variable name exists in the current environment&#39;s <code>bindings</code> dictionary</li>\n<li>If found, return the associated <code>LispValue</code> immediately</li>\n<li>If not found and <code>parent</code> is not None, recursively search the parent environment</li>\n<li>If not found and <code>parent</code> is None (reached global scope), raise a <code>NameError</code></li>\n</ol>\n<p><strong>Variable Binding Algorithm:</strong></p>\n<ol>\n<li>Add or update the name-value mapping in the current environment&#39;s <code>bindings</code> dictionary</li>\n<li>Do not traverse the parent chain - bindings always occur in the current scope</li>\n<li>This enables shadowing where inner scopes can define variables with the same names as outer scopes</li>\n</ol>\n<h4 id=\"environment-types-and-lifecycles\">Environment Types and Lifecycles</h4>\n<p>Our interpreter uses environments in several distinct contexts, each with different creation patterns and lifespans.</p>\n<table>\n<thead>\n<tr>\n<th>Environment Type</th>\n<th>Creation Context</th>\n<th>Lifespan</th>\n<th>Parent Environment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Global</td>\n<td>Interpreter startup</td>\n<td>Entire session</td>\n<td>None</td>\n</tr>\n<tr>\n<td>Function application</td>\n<td>Function call begins</td>\n<td>Until function returns</td>\n<td>Function&#39;s closure environment</td>\n</tr>\n<tr>\n<td>Let binding</td>\n<td>Let expression evaluation</td>\n<td>Until let body completes</td>\n<td>Current evaluation environment</td>\n</tr>\n<tr>\n<td>Lambda definition</td>\n<td>Lambda expression created</td>\n<td>Captured in closure indefinitely</td>\n<td>Current definition environment</td>\n</tr>\n</tbody></table>\n<h4 id=\"closure-environment-capture\">Closure Environment Capture</h4>\n<p>When a <code>lambda</code> expression is evaluated, the resulting function value captures the current environment as its closure. This capture is <strong>by reference</strong>, meaning the closure maintains a pointer to the actual environment objects rather than copying their contents.</p>\n<blockquote>\n<p><strong>Decision: Environment Capture Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Lambda functions need access to variables from their definition scope, even after that scope has been exited</li>\n<li><strong>Options Considered</strong>: Copy environment contents, reference environment chain, hybrid copy-on-write</li>\n<li><strong>Decision</strong>: Reference the environment chain directly</li>\n<li><strong>Rationale</strong>: Simpler implementation, supports recursive function definitions, matches standard lexical scoping semantics</li>\n<li><strong>Consequences</strong>: Closures can access mutable state changes in captured environments, but our immutable binding approach limits mutation</li>\n</ul>\n</blockquote>\n<p>The capture mechanism ensures that functions defined in inner scopes retain access to outer scope variables, enabling powerful patterns like function factories and curried functions.</p>\n<h4 id=\"global-environment-initialization\">Global Environment Initialization</h4>\n<p>The global environment contains all built-in functions and special constants available to user programs. It serves as the root of all environment chains and is initialized once during interpreter startup.</p>\n<table>\n<thead>\n<tr>\n<th>Binding Name</th>\n<th>Value Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>+</code></td>\n<td><code>BUILTIN</code></td>\n<td>Arithmetic addition function</td>\n</tr>\n<tr>\n<td><code>-</code></td>\n<td><code>BUILTIN</code></td>\n<td>Arithmetic subtraction function</td>\n</tr>\n<tr>\n<td><code>*</code></td>\n<td><code>BUILTIN</code></td>\n<td>Arithmetic multiplication function</td>\n</tr>\n<tr>\n<td><code>/</code></td>\n<td><code>BUILTIN</code></td>\n<td>Arithmetic division function</td>\n</tr>\n<tr>\n<td><code>=</code></td>\n<td><code>BUILTIN</code></td>\n<td>Equality comparison function</td>\n</tr>\n<tr>\n<td><code>&lt;</code></td>\n<td><code>BUILTIN</code></td>\n<td>Less-than comparison function</td>\n</tr>\n<tr>\n<td><code>car</code></td>\n<td><code>BUILTIN</code></td>\n<td>List head access function</td>\n</tr>\n<tr>\n<td><code>cdr</code></td>\n<td><code>BUILTIN</code></td>\n<td>List tail access function</td>\n</tr>\n<tr>\n<td><code>cons</code></td>\n<td><code>BUILTIN</code></td>\n<td>List construction function</td>\n</tr>\n<tr>\n<td><code>list</code></td>\n<td><code>BUILTIN</code></td>\n<td>Multi-element list constructor</td>\n</tr>\n<tr>\n<td><code>null?</code></td>\n<td><code>BUILTIN</code></td>\n<td>Empty list predicate</td>\n</tr>\n<tr>\n<td><code>#t</code></td>\n<td><code>SYMBOL</code></td>\n<td>Boolean true constant</td>\n</tr>\n<tr>\n<td><code>#f</code></td>\n<td><code>SYMBOL</code></td>\n<td>Boolean false constant</td>\n</tr>\n</tbody></table>\n<h4 id=\"environment-error-conditions\">Environment Error Conditions</h4>\n<p>Environment operations can fail in several specific ways, each requiring different error handling approaches:</p>\n<table>\n<thead>\n<tr>\n<th>Error Condition</th>\n<th>Detection Point</th>\n<th>Error Type</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unbound variable lookup</td>\n<td>Variable reference evaluation</td>\n<td><code>NameError</code></td>\n<td>Report undefined variable name</td>\n</tr>\n<tr>\n<td>Redefinition in same scope</td>\n<td><code>define</code> with existing name</td>\n<td>Warning or allow</td>\n<td>Depends on Lisp dialect choice</td>\n</tr>\n<tr>\n<td>Circular environment chain</td>\n<td>Environment creation</td>\n<td><code>RuntimeError</code></td>\n<td>Prevent during construction</td>\n</tr>\n<tr>\n<td>Null environment access</td>\n<td>Variable lookup</td>\n<td><code>RuntimeError</code></td>\n<td>Check parent before traversal</td>\n</tr>\n</tbody></table>\n<h3 id=\"abstract-syntax-tree\">Abstract Syntax Tree</h3>\n<p>The Abstract Syntax Tree (AST) represents the structural interpretation of parsed S-expressions before evaluation. In our Lisp interpreter, the AST is remarkably simple due to Lisp&#39;s uniform syntax - every expression is either an atom or a list, and this direct correspondence eliminates the complexity found in ASTs for other programming languages.</p>\n<h4 id=\"mental-model-structured-blueprint\">Mental Model: Structured Blueprint</h4>\n<p>Think of the AST as a blueprint that describes the structure of your program without the visual noise of parentheses and whitespace. Just as an architectural blueprint shows the relationships between rooms without showing wall colors or furniture placement, the AST shows the relationships between expressions without the syntactic details of how they were written.</p>\n<p>The key insight is that Lisp&#39;s homoiconic nature means our AST is nearly identical to our runtime data structures. A list in the source code becomes a <code>LIST</code> type <code>LispValue</code>, and an atom becomes the corresponding <code>NUMBER</code> or <code>SYMBOL</code> type <code>LispValue</code>. This simplicity is one of Lisp&#39;s greatest strengths for interpreter implementation.</p>\n<h4 id=\"ast-node-types\">AST Node Types</h4>\n<p>Since Lisp expressions have uniform structure, our AST uses the same <code>LispValue</code> types that represent runtime data. This design decision eliminates the need for separate AST node classes and enables the same tree-walking algorithms to handle both parsing results and evaluation inputs.</p>\n<table>\n<thead>\n<tr>\n<th>Expression Type</th>\n<th>Source Code Example</th>\n<th>AST Representation</th>\n<th>Node Type</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Number literal</td>\n<td><code>42</code></td>\n<td><code>LispValue(42, NUMBER)</code></td>\n<td>Leaf node</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td><code>x</code></td>\n<td><code>LispValue(&quot;x&quot;, SYMBOL)</code></td>\n<td>Leaf node</td>\n</tr>\n<tr>\n<td>Empty list</td>\n<td><code>()</code></td>\n<td><code>LispValue([], LIST)</code></td>\n<td>Leaf node</td>\n</tr>\n<tr>\n<td>Function call</td>\n<td><code>(+ 1 2)</code></td>\n<td><code>LispValue([LispValue(&quot;+&quot;, SYMBOL), LispValue(1, NUMBER), LispValue(2, NUMBER)], LIST)</code></td>\n<td>Internal node</td>\n</tr>\n<tr>\n<td>Nested expression</td>\n<td><code>(* (+ 1 2) 3)</code></td>\n<td>Nested <code>LispValue</code> structure with lists containing lists</td>\n<td>Internal node</td>\n</tr>\n</tbody></table>\n<h4 id=\"ast-construction-process\">AST Construction Process</h4>\n<p>The parser constructs AST nodes incrementally as it processes the token stream. Each successful parse operation returns a <code>LispValue</code> that represents the structure of the parsed expression.</p>\n<p><strong>Atom Parsing:</strong></p>\n<ol>\n<li>Read the next token from the token stream</li>\n<li>Determine the atom type based on token characteristics (numeric pattern, special symbols, etc.)</li>\n<li>Create appropriate <code>LispValue</code> with correct type tag and converted value</li>\n<li>Return the <code>LispValue</code> as a complete AST leaf node</li>\n</ol>\n<p><strong>List Parsing:</strong></p>\n<ol>\n<li>Consume the opening parenthesis token</li>\n<li>Initialize an empty list to collect child expressions</li>\n<li>Recursively parse expressions until closing parenthesis is encountered</li>\n<li>Create a <code>LispValue</code> with <code>LIST</code> type containing the collected child expressions</li>\n<li>Return the <code>LispValue</code> as a complete AST subtree</li>\n</ol>\n<h4 id=\"ast-traversal-patterns\">AST Traversal Patterns</h4>\n<p>The evaluator traverses AST nodes using pattern matching on the <code>type</code> field of <code>LispValue</code> objects. This dispatch mechanism enables different evaluation strategies for different expression types.</p>\n<table>\n<thead>\n<tr>\n<th>AST Node Type</th>\n<th>Traversal Pattern</th>\n<th>Evaluation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>NUMBER</code></td>\n<td>No traversal (leaf)</td>\n<td>Return value unchanged</td>\n</tr>\n<tr>\n<td><code>SYMBOL</code></td>\n<td>No traversal (leaf)</td>\n<td>Look up binding in environment</td>\n</tr>\n<tr>\n<td><code>LIST</code> (empty)</td>\n<td>No traversal (leaf)</td>\n<td>Return empty list value</td>\n</tr>\n<tr>\n<td><code>LIST</code> (non-empty)</td>\n<td>Traverse all children</td>\n<td>Check for special forms vs function calls</td>\n</tr>\n</tbody></table>\n<p>The traversal order matters critically for function calls, where arguments must be evaluated left-to-right before being passed to the function implementation.</p>\n<h4 id=\"special-form-ast-recognition\">Special Form AST Recognition</h4>\n<p>Special forms like <code>if</code>, <code>define</code>, and <code>lambda</code> require special handling during evaluation because they control the evaluation of their sub-expressions rather than evaluating all arguments and applying a function.</p>\n<table>\n<thead>\n<tr>\n<th>Special Form</th>\n<th>AST Pattern</th>\n<th>Argument Evaluation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(if test then else)</code></td>\n<td>4-element list starting with <code>if</code> symbol</td>\n<td>Test evaluated first, then only one branch</td>\n</tr>\n<tr>\n<td><code>(define name value)</code></td>\n<td>3-element list starting with <code>define</code> symbol</td>\n<td>Only value expression is evaluated</td>\n</tr>\n<tr>\n<td><code>(lambda params body)</code></td>\n<td>3-element list starting with <code>lambda</code> symbol</td>\n<td>Neither params nor body evaluated at definition time</td>\n</tr>\n<tr>\n<td><code>(quote expr)</code></td>\n<td>2-element list starting with <code>quote</code> symbol</td>\n<td>Expression is not evaluated</td>\n</tr>\n</tbody></table>\n<p>The evaluator recognizes special forms by checking if the first element of a list is a symbol with a special form name. This check happens before argument evaluation, allowing special forms to implement their own evaluation strategies.</p>\n<h4 id=\"ast-transformation-and-optimization\">AST Transformation and Optimization</h4>\n<p>While our basic interpreter performs minimal AST transformation, the structure supports several optimization opportunities that could be added in future iterations.</p>\n<table>\n<thead>\n<tr>\n<th>Transformation Type</th>\n<th>Before</th>\n<th>After</th>\n<th>Benefit</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Constant folding</td>\n<td><code>(+ 1 2)</code></td>\n<td><code>3</code></td>\n<td>Eliminates runtime arithmetic</td>\n</tr>\n<tr>\n<td>Quote expansion</td>\n<td><code>&#39;expr</code></td>\n<td><code>(quote expr)</code></td>\n<td>Normalizes syntax variants</td>\n</tr>\n<tr>\n<td>Tail call marking</td>\n<td><code>(f (g x))</code></td>\n<td>Tagged AST indicating tail position</td>\n<td>Enables tail call optimization</td>\n</tr>\n<tr>\n<td>Variable reference resolution</td>\n<td><code>x</code></td>\n<td>Direct environment slot reference</td>\n<td>Faster variable lookup</td>\n</tr>\n</tbody></table>\n<h4 id=\"ast-error-conditions\">AST Error Conditions</h4>\n<p>Several error conditions can be detected during AST construction or traversal, each indicating different categories of problems in the source code.</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Example</th>\n<th>Detection Point</th>\n<th>Error Category</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Malformed special form</td>\n<td><code>(if condition)</code></td>\n<td>AST traversal during evaluation</td>\n<td><code>EvaluationError</code></td>\n</tr>\n<tr>\n<td>Invalid parameter list</td>\n<td><code>(lambda &quot;not-a-list&quot; body)</code></td>\n<td>Lambda evaluation</td>\n<td><code>TypeError</code></td>\n</tr>\n<tr>\n<td>Arity mismatch</td>\n<td><code>(+ 1)</code> called with two args</td>\n<td>Function application</td>\n<td><code>ArityError</code></td>\n</tr>\n<tr>\n<td>Unquoted list in parameter position</td>\n<td><code>(lambda (x y z) body)</code> expected but got <code>(lambda x y z body)</code></td>\n<td>Lambda parsing</td>\n<td><code>ParseError</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Confusing AST and Runtime Values</strong></p>\n<p>Many learners initially try to create separate classes for AST nodes and runtime values, not realizing that Lisp&#39;s homoiconic nature means they can be the same. This leads to unnecessary conversion logic and type confusion.</p>\n<p><strong>Why it&#39;s wrong</strong>: Creates artificial complexity and breaks the fundamental property that code is data in Lisp.</p>\n<p><strong>How to fix</strong>: Use <code>LispValue</code> for both parsed expressions and runtime values. The same data structure that represents <code>(+ 1 2)</code> during parsing also represents the list <code>(+ 1 2)</code> as a data value if it appears in a quoted context.</p>\n<p>⚠️ <strong>Pitfall: Shallow vs Deep Environment Copying</strong></p>\n<p>When implementing closures, learners sometimes copy only the immediate environment rather than preserving the entire parent chain, breaking lexical scoping for nested functions.</p>\n<p><strong>Why it&#39;s wrong</strong>: Functions lose access to variables from outer scopes that aren&#39;t immediately visible, violating lexical scoping rules.</p>\n<p><strong>How to fix</strong>: Closure capture should reference the entire environment chain, not just the immediate environment. The <code>closure_env</code> field should point to the complete environment where the lambda was defined.</p>\n<p>⚠️ <strong>Pitfall: Evaluating Special Form Arguments</strong></p>\n<p>A common mistake is evaluating all list elements before checking for special forms, which breaks forms like <code>if</code> where only one branch should be evaluated.</p>\n<p><strong>Why it&#39;s wrong</strong>: Expressions like <code>(if #t 1 (/ 1 0))</code> would crash instead of safely returning 1, and forms like <code>(define x 10)</code> would try to evaluate <code>x</code> before it&#39;s defined.</p>\n<p><strong>How to fix</strong>: Check the first element of non-empty lists for special form names before evaluating any arguments. Only regular function calls should evaluate all their arguments.</p>\n<p>⚠️ <strong>Pitfall: Mutable vs Immutable Environment Bindings</strong></p>\n<p>Some implementations modify parent environments during variable assignment, breaking the isolation between scopes and causing unexpected variable shadowing behavior.</p>\n<p><strong>Why it&#39;s wrong</strong>: Inner scopes can accidentally modify outer scope variables, violating lexical scoping principles and making programs unpredictable.</p>\n<p><strong>How to fix</strong>: Variable bindings should only modify the current environment&#39;s <code>bindings</code> dictionary. Variable lookup traverses the parent chain, but variable assignment always creates new bindings in the current scope.</p>\n<p>⚠️ <strong>Pitfall: Missing Type Tag Validation</strong></p>\n<p>Forgetting to validate the <code>type</code> field before casting the <code>value</code> field leads to runtime type errors when invalid combinations occur.</p>\n<p><strong>Why it&#39;s wrong</strong>: Code like <code>val.value.upper()</code> crashes if <code>val.type</code> is <code>NUMBER</code> instead of <code>SYMBOL</code>, and arithmetic operations fail silently or crash on non-numeric values.</p>\n<p><strong>How to fix</strong>: Always use type predicate functions like <code>is_number()</code> and <code>is_symbol()</code> before accessing the <code>value</code> field with type-specific operations.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides concrete Python implementations for the core data structures described above. The code follows object-oriented principles while maintaining the simplicity that makes Lisp interpreters approachable for learning.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Value Types</td>\n<td>Python dataclasses with enum discriminators</td>\n<td>Tagged union with Protocol classes</td>\n</tr>\n<tr>\n<td>Environment</td>\n<td>Dictionary with optional parent reference</td>\n<td>Immutable mapping with structural sharing</td>\n</tr>\n<tr>\n<td>Type Checking</td>\n<td>Runtime isinstance checks</td>\n<td>Static typing with Union types</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Exception hierarchy with descriptive messages</td>\n<td>Result types with error accumulation</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lisp_interpreter/\n  src/\n    __init__.py\n    data_model.py           ← this implementation (LispValue, Environment)\n    errors.py               ← error type definitions\n    tokenizer.py           ← converts text to tokens\n    parser.py              ← converts tokens to AST\n    evaluator.py           ← evaluates AST in environments\n  tests/\n    test_data_model.py     ← unit tests for data structures\n    test_integration.py    ← end-to-end interpreter tests\n  main.py                  ← REPL interface</code></pre></div>\n\n<h4 id=\"core-data-structure-implementation\">Core Data Structure Implementation</h4>\n<p><strong>Complete <code>errors.py</code> (Infrastructure Code):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all Lisp interpreter errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, source_location: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.source_location </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source_location</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenizerError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when tokenization fails due to invalid syntax.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when parsing fails due to malformed expressions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EvaluationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for errors during expression evaluation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> NameError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when referencing an unbound variable.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when using a value with an inappropriate type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArityError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when calling a function with wrong number of arguments.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, expected: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, actual: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, function_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expected </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expected</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.actual </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.function_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> function_name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">function_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> expects </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> arguments, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">actual</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span></code></pre></div>\n\n<p><strong>Core Value Types Skeleton (<code>data_model.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Dict, List, Optional, Callable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispValueType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NUMBER</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"number\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SYMBOL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"symbol\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LIST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"list\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FUNCTION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"function\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BUILTIN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"builtin\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispValue</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Universal container for all Lisp values during parsing and evaluation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value: Any</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    type</span><span style=\"color:#E1E4E8\">: LispValueType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"String representation for debugging and REPL output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Handle NUMBER type - return str(self.value)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle SYMBOL type - return self.value directly  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle LIST type - format as (elem1 elem2 ...) with recursive __str__</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle FUNCTION type - return something like \"&#x3C;function:name>\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle BUILTIN type - return something like \"&#x3C;builtin:name>\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Value constructor functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_number</span><span style=\"color:#E1E4E8\">(value: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> |</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a numeric LispValue from a Python number.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return LispValue with appropriate type tag and converted value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_symbol</span><span style=\"color:#E1E4E8\">(name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a symbol LispValue from a string name.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return LispValue with SYMBOL type and name as value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_list</span><span style=\"color:#E1E4E8\">(elements: List[LispValue]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a list LispValue from a sequence of elements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return LispValue with LIST type and elements as value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Type predicate functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_number</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if a LispValue represents a number.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check if value.type equals LispValueType.NUMBER</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_symbol</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if a LispValue represents a symbol.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check if value.type equals LispValueType.SYMBOL  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_list</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if a LispValue represents a list.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check if value.type equals LispValueType.LIST</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_truthy</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Implement Lisp truthiness: only LISP_FALSE is false.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if value equals LISP_FALSE constant - if so return False</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: All other values (including empty lists, zero) are truthy - return True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Constants</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">LISP_TRUE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> make_symbol(</span><span style=\"color:#9ECBFF\">\"#t\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">LISP_FALSE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> make_symbol(</span><span style=\"color:#9ECBFF\">\"#f\"</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">EMPTY_LIST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> make_list([])</span></span></code></pre></div>\n\n<h4 id=\"environment-implementation-skeleton\">Environment Implementation Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Lexical environment mapping variable names to values.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bindings: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, LispValue]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parent: Optional[</span><span style=\"color:#9ECBFF\">'Environment'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> lookup</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Look up a variable binding, searching parent environments if necessary.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if name exists in self.bindings - if so return the value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If not found and self.parent is not None, recursively search parent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If not found and self.parent is None, raise NameError with descriptive message</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use \"in\" operator to check dictionary membership</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> define</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: LispValue) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create or update a variable binding in the current environment.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Add the name->value mapping to self.bindings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Do not search parent environments - always bind in current scope</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # This enables variable shadowing in inner scopes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> extend</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#9ECBFF\">'Environment'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create a new child environment with this environment as parent.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return new Environment with empty bindings and self as parent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # This is used when entering function calls or let expressions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_global_environment</span><span style=\"color:#E1E4E8\">() -> Environment:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create the global environment with built-in functions and constants.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Environment(</span><span style=\"color:#FFAB70\">bindings</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{})</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Add arithmetic operators (+, -, *, /) as BUILTIN LispValues</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add comparison operators (=, &#x3C;, >, &#x3C;=, >=) as BUILTIN LispValues  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add list operators (car, cdr, cons, list, null?) as BUILTIN LispValues</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add boolean constants (#t, #f) using LISP_TRUE and LISP_FALSE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # For now, create placeholder BuiltinFunction objects:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # env.define(\"+\", LispValue(BuiltinFunction(lambda *args: ...), LispValueType.BUILTIN))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> env</span></span></code></pre></div>\n\n<h4 id=\"function-type-implementation-skeleton\">Function Type Implementation Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispFunction</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"User-defined function created by lambda expressions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parameters: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    body: LispValue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    closure_env: Environment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        name_part </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">else</span><span style=\"color:#9ECBFF\"> \"anonymous\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"&#x3C;function:</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name_part</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">>\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BuiltinFunction</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Built-in function implemented in Python.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    implementation: Callable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    arity: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # None means variadic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"&#x3C;builtin:</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">>\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_function</span><span style=\"color:#E1E4E8\">(parameters: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], body: LispValue, closure_env: Environment, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a user-defined function LispValue.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create LispFunction object and wrap in LispValue with FUNCTION type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_builtin</span><span style=\"color:#E1E4E8\">(implementation: Callable, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, arity: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a built-in function LispValue.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create BuiltinFunction object and wrap in LispValue with BUILTIN type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<ul>\n<li>Use <code>isinstance(value.value, (int, float))</code> to check for numeric types within NUMBER values</li>\n<li>Python&#39;s <code>dataclass</code> decorator automatically generates <code>__init__</code>, <code>__eq__</code>, and <code>__repr__</code> methods</li>\n<li>Use <code>typing.Union</code> or the <code>|</code> operator (Python 3.10+) for parameters that accept multiple types</li>\n<li>Dictionary membership testing with <code>name in self.bindings</code> is O(1) average case</li>\n<li>Use <code>Optional[Type]</code> instead of <code>Union[Type, None]</code> for nullable references</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the data model structures:</p>\n<p><strong>What to test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_data_model.py</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p><strong>Expected behavior:</strong></p>\n<ul>\n<li>Value constructors create LispValues with correct type tags</li>\n<li>Type predicates correctly identify value types</li>\n<li>Environment lookup traverses parent chain correctly</li>\n<li>Environment definition creates bindings in current scope only</li>\n<li>Function objects store closure environments properly</li>\n</ul>\n<p><strong>Manual verification:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># In Python REPL or test file:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#F97583\"> *</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Create values</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">num </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> make_number(</span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">sym </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> make_symbol(</span><span style=\"color:#9ECBFF\">\"x\"</span><span style=\"color:#E1E4E8\">) </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">lst </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> make_list([num, sym])</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test type predicates  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> is_number(num)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> is_symbol(sym)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> is_list(lst)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test environment chains</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">global_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_global_environment()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">local_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> global_env.extend()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">local_env.define(</span><span style=\"color:#9ECBFF\">\"x\"</span><span style=\"color:#E1E4E8\">, num)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> local_env.lookup(</span><span style=\"color:#9ECBFF\">\"x\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> num</span></span></code></pre></div>\n\n<p><strong>Signs something is wrong:</strong></p>\n<ul>\n<li>Type predicates return incorrect results → Check LispValueType enum values</li>\n<li>Environment lookup fails → Check parent chain traversal logic</li>\n<li>Value constructors crash → Check type tag assignment in constructors</li>\n</ul>\n<h2 id=\"tokenizer-design\">Tokenizer Design</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (S-Expression Parser) - the tokenizer is the first stage of the three-part pipeline that converts raw Lisp source text into tokens that the parser can consume</p>\n</blockquote>\n<p>The tokenizer serves as the foundation of our Lisp interpreter, transforming raw source text into a structured stream of tokens that the parser can understand. This component must handle the unique characteristics of Lisp syntax while maintaining the simplicity that makes Lisp an excellent learning vehicle for interpreter construction.</p>\n<h3 id=\"mental-model-text-dissection\">Mental Model: Text Dissection</h3>\n<p>Understanding tokenization requires thinking of it as <strong>careful text surgery that preserves meaning</strong>. Imagine you&#39;re a librarian who receives a handwritten manuscript that needs to be cataloged. The text flows continuously across pages with no clear boundaries between ideas, but you need to identify distinct conceptual units: individual words, complete sentences, chapter boundaries, and special notations.</p>\n<p>The tokenizer performs similar surgery on Lisp source code. It receives an unstructured stream of characters and must identify meaningful boundaries: where one symbol ends and another begins, which parentheses belong together, where strings start and end, and which parts are comments that should be ignored. Like a skilled surgeon, the tokenizer must make precise cuts that preserve the semantic meaning of each piece while preparing them for the next stage of processing.</p>\n<p>Consider the Lisp expression <code>(+ 42 (* 3 14))</code>. To human eyes, this clearly contains symbols, numbers, and nested structure. But to a computer, this is just a sequence of 15 characters. The tokenizer&#39;s job is to recognize that the opening parenthesis starts a list, that <code>+</code> is a complete symbol, that <code>42</code> represents a number, and that the nested parentheses create a sub-expression. Each recognition requires looking ahead and behind in the character stream to determine precise boundaries.</p>\n<p>The critical insight is that tokenization is <strong>boundary detection with context sensitivity</strong>. Unlike simple word processing where spaces clearly separate words, Lisp tokenization must handle cases where meaningful tokens can be adjacent without separators (<code>()</code> contains two tokens) and where the same character can have different meanings in different contexts (a quote character inside a string literal versus a quote character that starts symbol quoting).</p>\n<h3 id=\"token-types-and-recognition\">Token Types and Recognition</h3>\n<p>The Lisp tokenizer recognizes a carefully designed set of token types that capture all meaningful elements of S-expression syntax. Each token type has specific recognition rules and carries different semantic information for the parser.</p>\n<table>\n<thead>\n<tr>\n<th>Token Type</th>\n<th>Character Patterns</th>\n<th>Recognition Rules</th>\n<th>Semantic Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>LEFT_PAREN</td>\n<td><code>(</code></td>\n<td>Single character match</td>\n<td>Marks beginning of list structure</td>\n</tr>\n<tr>\n<td>RIGHT_PAREN</td>\n<td><code>)</code></td>\n<td>Single character match</td>\n<td>Marks end of list structure</td>\n</tr>\n<tr>\n<td>NUMBER</td>\n<td>Digits, optional decimal, optional sign</td>\n<td>Regex: <code>^[+-]?[0-9]+(\\.[0-9]+)?$</code></td>\n<td>Literal numeric values</td>\n</tr>\n<tr>\n<td>SYMBOL</td>\n<td>Letters, digits, allowed punctuation</td>\n<td>Non-numeric atoms, function names</td>\n<td>Identifiers and operators</td>\n</tr>\n<tr>\n<td>STRING</td>\n<td>Content between quotes</td>\n<td>Paired quote delimiters with escape handling</td>\n<td>String literal values</td>\n</tr>\n<tr>\n<td>QUOTE</td>\n<td><code>&#39;</code></td>\n<td>Single character match</td>\n<td>Shorthand for quote special form</td>\n</tr>\n<tr>\n<td>COMMENT</td>\n<td><code>;</code> to end of line</td>\n<td>Semicolon to newline</td>\n<td>Ignored by parser</td>\n</tr>\n<tr>\n<td>WHITESPACE</td>\n<td>Spaces, tabs, newlines</td>\n<td>Character class match</td>\n<td>Token separation only</td>\n</tr>\n<tr>\n<td>EOF</td>\n<td>End of input stream</td>\n<td>Position-based detection</td>\n<td>Signals end of parsing</td>\n</tr>\n</tbody></table>\n<p><strong>Number Recognition</strong>: Numbers in our Lisp support both integers and floating-point values, with optional signs. The tokenizer must distinguish between valid numbers like <code>42</code>, <code>-17</code>, <code>3.14159</code>, and <code>+0.5</code> versus invalid patterns like <code>3.14.159</code> or <code>++42</code>. The recognition algorithm scans for an optional sign, followed by one or more digits, optionally followed by a decimal point and more digits.</p>\n<p><strong>Symbol Recognition</strong>: Symbols represent the most complex token type because they encompass everything that isn&#39;t a number, string, or structural element. Valid Lisp symbols include traditional identifiers like <code>factorial</code> and <code>list-length</code>, operators like <code>+</code> and <code>&lt;=</code>, and special characters like <code>*global-counter*</code>. The key insight is that symbol recognition works by <strong>exclusion</strong> - if it&#39;s not a number, string, or structural token, and it contains valid symbol characters, it&#39;s a symbol.</p>\n<table>\n<thead>\n<tr>\n<th>Symbol Class</th>\n<th>Examples</th>\n<th>Character Set</th>\n<th>Special Rules</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Identifiers</td>\n<td><code>factorial</code>, <code>my-function</code></td>\n<td>Letters, digits, <code>-</code>, <code>_</code></td>\n<td>Cannot start with digit</td>\n</tr>\n<tr>\n<td>Operators</td>\n<td><code>+</code>, <code>*</code>, <code>&lt;=</code>, <code>&gt;=</code></td>\n<td>Arithmetic and comparison symbols</td>\n<td>Complete operator sequences</td>\n</tr>\n<tr>\n<td>Special Symbols</td>\n<td><code>*global*</code>, <code>nil</code>, <code>t</code></td>\n<td>Letters with special punctuation</td>\n<td>Conventional naming patterns</td>\n</tr>\n<tr>\n<td>Keywords</td>\n<td><code>:keyword</code>, <code>:type</code></td>\n<td>Starts with <code>:</code></td>\n<td>Self-evaluating symbols</td>\n</tr>\n</tbody></table>\n<p><strong>String Recognition</strong>: String literals begin and end with double quotes and can contain any characters except unescaped quotes. The tokenizer must handle escape sequences like <code>\\&quot;</code> for embedded quotes, <code>\\n</code> for newlines, and <code>\\\\</code> for literal backslashes. String recognition requires <strong>stateful scanning</strong> because the meaning of each character depends on what came before it.</p>\n<p><strong>Comment Handling</strong>: Lisp uses semicolon-initiated comments that extend to the end of the line. The tokenizer recognizes <code>;</code> as the start of a comment and consumes all characters until it encounters a newline or end-of-file. Comments are typically discarded during tokenization rather than passed to the parser, simplifying the parsing logic.</p>\n<blockquote>\n<p><strong>Decision: Token Position Tracking</strong></p>\n<ul>\n<li><strong>Context</strong>: Error reporting requires knowing where in the source text each token originated</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>No position tracking (simpler implementation)</li>\n<li>Line and column numbers (human-readable locations)</li>\n<li>Character offset positions (simpler arithmetic)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Character offset positions with line/column computation on demand</li>\n<li><strong>Rationale</strong>: Offset positions are simpler to maintain during tokenization and can be converted to line/column for error display when needed</li>\n<li><strong>Consequences</strong>: Enables precise error reporting while keeping tokenizer logic straightforward</li>\n</ul>\n</blockquote>\n<h3 id=\"tokenization-algorithm\">Tokenization Algorithm</h3>\n<p>The tokenization process follows a <strong>single-pass scanning algorithm</strong> that examines each character in the input stream exactly once while maintaining minimal state. This approach ensures linear time complexity and predictable memory usage regardless of input size.</p>\n<p>The core algorithm structure uses a <strong>state machine approach</strong> where the tokenizer&#39;s behavior depends on its current state and the next character in the input stream. The primary states are: scanning normal text, inside a string literal, and inside a comment.</p>\n<p><img src=\"/api/project/lisp-interp/architecture-doc/asset?path=diagrams%2Ftokenizer-state-machine.svg\" alt=\"Tokenizer State Machine\"></p>\n<p><strong>Main Tokenization Loop</strong>:</p>\n<ol>\n<li><strong>Initialize scanner state</strong> with input text, current position at zero, and empty token list</li>\n<li><strong>Skip leading whitespace</strong> by advancing position while current character is space, tab, or newline</li>\n<li><strong>Check for end of input</strong> - if position &gt;= text length, emit EOF token and terminate</li>\n<li><strong>Examine current character</strong> to determine token type:<ul>\n<li><code>(</code> → emit LEFT_PAREN token, advance one position</li>\n<li><code>)</code> → emit RIGHT_PAREN token, advance one position  </li>\n<li><code>&#39;</code> → emit QUOTE token, advance one position</li>\n<li><code>;</code> → enter comment scanning mode</li>\n<li><code>&quot;</code> → enter string scanning mode</li>\n<li>Digit or sign followed by digit → enter number scanning mode</li>\n<li>Other characters → enter symbol scanning mode</li>\n</ul>\n</li>\n<li><strong>Emit completed token</strong> with type, value, and starting position</li>\n<li><strong>Return to step 2</strong> until EOF is reached</li>\n</ol>\n<p><strong>String Scanning Subroutine</strong>:</p>\n<ol>\n<li><strong>Record starting position</strong> and advance past opening quote character</li>\n<li><strong>Accumulate characters</strong> until closing quote or end of input:<ul>\n<li>Regular character → append to string value</li>\n<li><code>\\</code> → enter escape sequence handling</li>\n<li><code>&quot;</code> → complete string token</li>\n<li>EOF → emit TokenizerError for unterminated string</li>\n</ul>\n</li>\n<li><strong>Handle escape sequences</strong> by examining character after backslash:<ul>\n<li><code>\\&quot;</code> → append literal quote character</li>\n<li><code>\\n</code> → append newline character</li>\n<li><code>\\\\</code> → append literal backslash character</li>\n<li>Other → emit TokenizerError for invalid escape</li>\n</ul>\n</li>\n<li><strong>Emit STRING token</strong> with accumulated value and starting position</li>\n</ol>\n<p><strong>Number Scanning Subroutine</strong>:</p>\n<ol>\n<li><strong>Record starting position</strong> and check for optional sign character</li>\n<li><strong>Scan integer portion</strong> by accumulating consecutive digits</li>\n<li><strong>Check for decimal point</strong> - if found, scan fractional portion</li>\n<li><strong>Validate number format</strong> to ensure at least one digit was found</li>\n<li><strong>Emit NUMBER token</strong> with string representation for later parsing</li>\n</ol>\n<p><strong>Symbol Scanning Subroutine</strong>:</p>\n<ol>\n<li><strong>Record starting position</strong> and begin accumulating valid symbol characters</li>\n<li><strong>Continue scanning</strong> while characters match symbol character set (letters, digits, allowed punctuation)</li>\n<li><strong>Stop at delimiter</strong> (whitespace, parentheses, quotes, or end of input)</li>\n<li><strong>Emit SYMBOL token</strong> with accumulated character sequence</li>\n</ol>\n<p><strong>Comment Scanning Subroutine</strong>:</p>\n<ol>\n<li><strong>Advance past semicolon</strong> that started the comment</li>\n<li><strong>Skip characters</strong> until newline or end of input is reached</li>\n<li><strong>Return to main loop</strong> without emitting any token (comments are discarded)</li>\n</ol>\n<blockquote>\n<p>The tokenizer&#39;s <strong>single-pass guarantee</strong> means that once a character has been examined, it never needs to be reconsidered. This property enables streaming tokenization of large files and ensures predictable performance characteristics.</p>\n</blockquote>\n<h3 id=\"common-tokenizer-pitfalls\">Common Tokenizer Pitfalls</h3>\n<p>Beginning interpreter implementers frequently encounter specific categories of errors when building tokenizers. Understanding these pitfalls helps avoid debugging sessions that can consume hours of development time.</p>\n<p><strong>⚠️ Pitfall: Incomplete String Escape Handling</strong></p>\n<p>Many implementations correctly handle basic escape sequences like <code>\\&quot;</code> but fail on edge cases like <code>&quot;She said \\&quot;Hello, world!\\&quot;&quot;</code> or strings ending with backslashes like <code>&quot;path\\\\to\\\\file\\\\&quot;</code>. The error manifests as either incorrectly parsed strings or tokenizer exceptions when processing valid Lisp code.</p>\n<p><em>Why this fails</em>: String scanning requires <strong>lookahead logic</strong> to distinguish between escape sequences and literal characters. A naive implementation might treat <code>\\&quot;</code> as an escaped quote but fail to handle the quote that follows it, or might not properly handle a backslash at the end of a string.</p>\n<p><em>How to fix it</em>: Implement a proper <strong>escape state machine</strong> within string scanning. When encountering a backslash, examine the next character to determine the complete escape sequence before continuing. Always verify that the string has a closing quote after processing all escape sequences.</p>\n<p><strong>⚠️ Pitfall: Negative Number Recognition Conflicts</strong></p>\n<p>The expression <code>(- 5)</code> should tokenize as LEFT_PAREN, SYMBOL(<code>-</code>), NUMBER(<code>5</code>), RIGHT_PAREN, but incorrect implementations might tokenize it as LEFT_PAREN, NUMBER(<code>-5</code>), RIGHT_PAREN. This happens because the tokenizer incorrectly treats the <code>-</code> as the start of a negative number rather than a separate operator symbol.</p>\n<p><em>Why this fails</em>: Number recognition logic that only checks &quot;starts with <code>-</code>&quot; doesn&#39;t consider the <strong>contextual requirements</strong> for negative numbers. A minus sign only starts a negative number when it&#39;s followed immediately by digits, not when it appears as a standalone operator.</p>\n<p><em>How to fix it</em>: Implement <strong>lookahead checking</strong> in number recognition. When encountering a <code>-</code> or <code>+</code>, examine the next character. Only begin number scanning if the following character is a digit. Otherwise, treat the sign as a symbol.</p>\n<p><strong>⚠️ Pitfall: Whitespace Handling in String Literals</strong></p>\n<p>Some tokenizers incorrectly skip whitespace inside string literals, turning <code>&quot;hello world&quot;</code> into <code>&quot;helloworld&quot;</code>. This occurs when the main tokenization loop&#39;s whitespace-skipping logic runs even during string scanning.</p>\n<p><em>Why this fails</em>: The tokenizer applies <strong>global whitespace rules</strong> regardless of context. Inside string literals, whitespace is meaningful and must be preserved exactly as written.</p>\n<p><em>How to fix it</em>: Use <strong>state-dependent character handling</strong>. Only skip whitespace when in the normal scanning state. When inside string literals, preserve all characters including spaces, tabs, and newlines.</p>\n<p><strong>⚠️ Pitfall: Symbol Character Set Inconsistency</strong></p>\n<p>Different parts of the tokenizer might use inconsistent rules for what constitutes a valid symbol character. For example, the symbol <code>list-&gt;vector</code> might be accepted during initial scanning but rejected when the evaluator tries to look it up, or vice versa.</p>\n<p><em>Why this fails</em>: Symbol validation logic scattered across multiple functions can become <strong>inconsistent over time</strong> as the codebase evolves. Each function might implement slightly different character set rules.</p>\n<p><em>How to fix it</em>: Define symbol character validation in <strong>one canonical location</strong> and reference it consistently. Create a helper function like <code>is_symbol_char(char)</code> that encapsulates all symbol character rules and use it throughout the tokenizer.</p>\n<p><strong>⚠️ Pitfall: EOF Handling in Partial Tokens</strong></p>\n<p>When input ends unexpectedly (like an unterminated string <code>&quot;hello</code> or an incomplete number <code>3.</code>), some tokenizers crash instead of producing helpful error messages. This makes debugging difficult for users of the Lisp interpreter.</p>\n<p><em>Why this fails</em>: Token scanning subroutines assume they can always read ahead to complete a token. When EOF occurs in the middle of token construction, they may access invalid memory or throw generic exceptions.</p>\n<p><em>How to fix it</em>: Add <strong>explicit EOF checking</strong> in all scanning subroutines. Before accessing the next character, verify that the position hasn&#39;t exceeded the input length. When EOF occurs during token construction, emit a descriptive TokenizerError that explains what was expected.</p>\n<table>\n<thead>\n<tr>\n<th>Error Scenario</th>\n<th>Bad Behavior</th>\n<th>Correct Behavior</th>\n<th>Detection Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unterminated string</td>\n<td>Crash or wrong parse</td>\n<td>TokenizerError with position</td>\n<td>Check EOF in string scanner</td>\n</tr>\n<tr>\n<td>Invalid escape <code>\\x</code></td>\n<td>Silent corruption</td>\n<td>TokenizerError describing valid escapes</td>\n<td>Validate escape sequences</td>\n</tr>\n<tr>\n<td>Incomplete number <code>3.</code></td>\n<td>Parse as symbol or crash</td>\n<td>TokenizerError or complete as <code>3.0</code></td>\n<td>Validate number format before emitting</td>\n</tr>\n<tr>\n<td>Standalone <code>-</code> treated as number</td>\n<td>Wrong token type</td>\n<td>Recognize as symbol</td>\n<td>Lookahead for digits after sign</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The tokenizer implementation requires careful balance between simplicity and robustness. The following guidance provides both working infrastructure and clear extension points for the core learning components.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Input Handling</td>\n<td>String slicing with index</td>\n<td>StringIO or custom stream reader</td>\n</tr>\n<tr>\n<td>Token Storage</td>\n<td>List of Token objects</td>\n<td>Generator yielding tokens on demand</td>\n</tr>\n<tr>\n<td>Error Reporting</td>\n<td>Exception with message</td>\n<td>Rich error with position and context</td>\n</tr>\n<tr>\n<td>Character Classification</td>\n<td>Individual character checks</td>\n<td>Precomputed character class sets</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<p>The tokenizer should be organized as a self-contained module with clear separation between token definitions, scanning logic, and error handling:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lisp-interpreter/\n  src/\n    tokenizer/\n      __init__.py          ← Public API exports\n      tokens.py            ← Token class and type definitions\n      scanner.py           ← Core tokenization logic\n      errors.py            ← Tokenizer-specific error classes\n      char_utils.py        ← Character classification utilities\n    tests/\n      test_tokenizer.py    ← Comprehensive tokenizer tests\n  examples/\n    sample_tokens.lisp     ← Test cases for manual verification</code></pre></div>\n\n<p><strong>Infrastructure Starter Code (Complete):</strong></p>\n<p>This code provides the foundational data structures and utilities that support tokenization but aren&#39;t the primary learning focus:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tokens.py - Complete token representation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum, auto</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LEFT_PAREN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RIGHT_PAREN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NUMBER</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SYMBOL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    STRING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    QUOTE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    COMMENT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WHITESPACE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EOF</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> auto()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">frozen</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    type</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    position: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">(</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.value</span><span style=\"color:#F97583\">!r</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)@</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.position</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __repr__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__str__</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># errors.py - Complete error handling infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for all Lisp interpreter errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, source_location: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.source_location </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source_location</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenizerError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Errors that occur during tokenization phase.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># char_utils.py - Complete character classification utilities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_whitespace</span><span style=\"color:#E1E4E8\">(char: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if character is Lisp whitespace (space, tab, newline).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">in</span><span style=\"color:#9ECBFF\"> ' </span><span style=\"color:#79B8FF\">\\t\\n\\r</span><span style=\"color:#9ECBFF\">'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_digit</span><span style=\"color:#E1E4E8\">(char: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if character is a decimal digit.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> '0'</span><span style=\"color:#F97583\"> &#x3C;=</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#9ECBFF\"> '9'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_letter</span><span style=\"color:#E1E4E8\">(char: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if character is an ASCII letter.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">'a'</span><span style=\"color:#F97583\"> &#x3C;=</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#9ECBFF\"> 'z'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#9ECBFF\">'A'</span><span style=\"color:#F97583\"> &#x3C;=</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#9ECBFF\"> 'Z'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_symbol_start_char</span><span style=\"color:#E1E4E8\">(char: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if character can start a symbol.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> is_letter(char):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">in</span><span style=\"color:#9ECBFF\"> '+-*/&#x3C;>=!?$%&#x26;_'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_symbol_char</span><span style=\"color:#E1E4E8\">(char: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if character can appear in a symbol.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> is_letter(char) </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> is_digit(char):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">in</span><span style=\"color:#9ECBFF\"> '+-*/&#x3C;>=!?$%&#x26;_-'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_sign_char</span><span style=\"color:#E1E4E8\">(char: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if character is a numeric sign.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">in</span><span style=\"color:#9ECBFF\"> '+-'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ESCAPE_SEQUENCES</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'n'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    't'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'r'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '</span><span style=\"color:#79B8FF\">\\\\</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\\\</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '\"'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'\"'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Core Tokenizer Skeleton (Learning Focus):</strong></p>\n<p>This skeleton provides the structure for the main tokenization algorithm that learners should implement themselves:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># scanner.py - Core tokenization logic for learners to complete</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .tokens </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Token, TokenType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TokenizerError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .char_utils </span><span style=\"color:#F97583\">import</span><span style=\"color:#F97583\"> *</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Scanner</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Converts Lisp source text into a stream of tokens.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.text </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.position </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.tokens: List[Token] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> tokenize</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[Token]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Main entry point: convert text to token list.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        scanner </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Scanner(text)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> scanner.scan_all()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> scan_all</span><span style=\"color:#E1E4E8\">(self) -> List[Token]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Main tokenization loop that processes entire input.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns list of all tokens including final EOF token.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Loop until EOF is reached</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Skip whitespace at current position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check for end of input and emit EOF token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Determine token type based on current character</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Call appropriate scanning method for token type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Add completed token to results list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Continue until EOF token is emitted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use self.current_char() to examine next character</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Each scan_* method should advance self.position appropriately</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> current_char</span><span style=\"color:#E1E4E8\">(self) -> Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return current character or None if at EOF.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check if position is within text bounds</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return character at current position or None</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> advance</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Move to next character position.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Increment position counter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure we don't advance past end of text</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> skip_whitespace</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Skip over whitespace characters at current position.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Loop while current character is whitespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Use is_whitespace() helper function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Advance position for each whitespace character</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> scan_string</span><span style=\"color:#E1E4E8\">(self) -> Token:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Scan a string literal starting at current position.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Handles escape sequences and validates proper termination.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Advance past opening quote character</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Initialize empty string for accumulating characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Loop until closing quote or EOF</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle regular characters by adding to result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle escape sequences using ESCAPE_SEQUENCES dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Check for EOF before string termination (error case)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Advance past closing quote</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Return STRING token with accumulated value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: When you see '\\', look at next character for escape type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Raise TokenizerError for unterminated strings</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> scan_number</span><span style=\"color:#E1E4E8\">(self) -> Token:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Scan a numeric literal (integer or floating-point).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Handles optional signs and decimal points.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check for optional sign character and include if present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Scan integer portion (sequence of digits)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check for decimal point</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If decimal point found, scan fractional portion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Validate that at least one digit was found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return NUMBER token with complete numeric string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use is_digit() and is_sign_char() helper functions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Track whether we've seen any digits to validate number format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> scan_symbol</span><span style=\"color:#E1E4E8\">(self) -> Token:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Scan a symbol (identifier, operator, or keyword).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Continues until delimiter character is encountered.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize empty string for accumulating symbol characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Loop while current character is valid for symbols</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add each valid character to result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Stop at whitespace, parentheses, quotes, or EOF</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return SYMBOL token with accumulated characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use is_symbol_char() helper function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Don't advance past the delimiter character</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> scan_comment</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Skip a comment from semicolon to end of line.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Comments are discarded rather than returned as tokens.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Advance past the semicolon character</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Skip characters until newline or EOF</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Don't emit any token (comments are ignored)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Look for '\\n' character or end of input</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> make_single_char_token</span><span style=\"color:#E1E4E8\">(self, token_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Token:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create token for single-character elements like parentheses.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Record current position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Get current character as token value  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Advance past the character</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return Token with specified type, character value, and position</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints:</strong></p>\n<ul>\n<li><strong>String Handling</strong>: Python&#39;s string slicing (<code>text[pos:pos+1]</code>) is efficient for single character access, but be careful with index bounds checking</li>\n<li><strong>Character Classification</strong>: Use Python&#39;s built-in string methods like <code>char.isdigit()</code> and <code>char.isalpha()</code> for basic checks, but implement custom logic for Lisp-specific symbol characters  </li>\n<li><strong>Error Reporting</strong>: Include the problematic character and its position in error messages: <code>f&quot;Invalid escape sequence &#39;\\\\{char}&#39; at position {pos}&quot;</code></li>\n<li><strong>Performance</strong>: For large files, consider using <code>io.StringIO</code> instead of string indexing, but the simple approach works fine for learning</li>\n</ul>\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing the tokenizer, verify correct behavior with these test cases:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test basic tokenization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tokenize(</span><span style=\"color:#9ECBFF\">\"(+ 42 3.14)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">expected_types </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"LEFT_PAREN\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"SYMBOL\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"NUMBER\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"NUMBER\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"RIGHT_PAREN\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"EOF\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> [t.type </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> t </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> tokens] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> expected_types</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test string handling  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tokenize(</span><span style=\"color:#9ECBFF\">'\"hello, world!\"'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> tokens[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"hello, world!\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test escape sequences</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tokenize(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#DBEDFF\">\"She said </span><span style=\"color:#85E89D;font-weight:bold\">\\\"</span><span style=\"color:#DBEDFF\">Hello!</span><span style=\"color:#85E89D;font-weight:bold\">\\\"</span><span style=\"color:#DBEDFF\">\"</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> tokens[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].value </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'She said \"Hello!\"'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test comments are ignored</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tokenize(</span><span style=\"color:#9ECBFF\">\"42 ; this is a comment</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">43\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">values </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [t.value </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> t </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> tokens </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> t.type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"EOF\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> values </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"42\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"43\"</span><span style=\"color:#E1E4E8\">]</span></span></code></pre></div>\n\n<p><strong>Signs of Success</strong>: The tokenizer should handle nested parentheses, preserve string content exactly (including whitespace), correctly identify numbers versus symbols, and provide helpful error messages for malformed input.</p>\n<p><strong>Signs of Problems</strong>: If you see symbols being split incorrectly (<code>list-&gt;vector</code> becoming separate <code>list</code>, <code>-&gt;</code>, <code>vector</code> tokens), numbers not being recognized (negative numbers appearing as separate <code>-</code> and <code>42</code> tokens), or crashes on unterminated strings, revisit the character classification and lookahead logic in the scanning methods.</p>\n<h2 id=\"parser-design\">Parser Design</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (S-Expression Parser) - the parser transforms the token stream produced by the tokenizer into nested data structures representing the abstract syntax tree</p>\n</blockquote>\n<p>The <strong>parser</strong> transforms a linear sequence of tokens into a hierarchical tree structure that represents the nested nature of Lisp S-expressions. This component bridges the gap between the flat token stream from tokenization and the structured data needed for evaluation. The parser must handle arbitrarily deep nesting, special syntax like quotes, and error conditions while maintaining the structural integrity of the original S-expression.</p>\n<p><img src=\"/api/project/lisp-interp/architecture-doc/asset?path=diagrams%2Fparsing-sequence.svg\" alt=\"Parse Tree Construction Sequence\"></p>\n<h3 id=\"mental-model-nested-container-assembly\">Mental Model: Nested Container Assembly</h3>\n<p>Think of parsing as <strong>assembling nested containers from a stream of parts</strong>. Imagine you&#39;re working on an assembly line where containers (parentheses) and items (atoms) flow past you in sequence. Your job is to recognize when a container starts, collect all the items that belong inside it (including other nested containers), and close the container when you reach its matching end piece.</p>\n<p>When you see a left parenthesis <code>(</code>, you know a new container has started. You must now collect everything that follows—atoms, strings, numbers, and even other complete containers—until you find the matching right parenthesis <code>)</code>. The tricky part is that containers can contain other containers, so you might need to pause assembling the current container to fully assemble a nested one first.</p>\n<p>This process mirrors exactly how Lisp parsing works. The parser maintains a mental stack of &quot;containers being assembled.&quot; When it encounters <code>(</code>, it starts a new list. When it encounters atoms, it adds them to the current list being built. When it encounters <code>)</code>, it completes the current list and either returns it (if it&#39;s the top-level expression) or adds it to the parent list being assembled.</p>\n<p>The key insight is that <strong>parsing is inherently recursive</strong>—to parse a list, you must be able to parse all the expressions inside it, some of which might themselves be lists requiring the same parsing process.</p>\n<h3 id=\"recursive-descent-strategy\">Recursive Descent Strategy</h3>\n<p><strong>Recursive descent parsing</strong> is the natural strategy for handling Lisp&#39;s nested structure. The algorithm uses the call stack to mirror the nesting structure of the S-expressions being parsed. Each level of nesting corresponds to a recursive function call, making the parser&#39;s structure match the data structure it&#39;s building.</p>\n<blockquote>\n<p><strong>Decision: Recursive Descent Parser Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to parse arbitrarily nested S-expressions into tree structures</li>\n<li><strong>Options Considered</strong>: Recursive descent, shift-reduce parser, parser combinator library</li>\n<li><strong>Decision</strong>: Implement recursive descent parser with mutual recursion between expression and list parsing</li>\n<li><strong>Rationale</strong>: Recursive descent naturally mirrors Lisp&#39;s recursive structure, is simple to implement and debug, and provides excellent error reporting with clear stack traces</li>\n<li><strong>Consequences</strong>: Easy to extend with new syntax, but may hit stack limits on extremely deep nesting (acceptable for learning purposes)</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Parsing Strategy</th>\n<th>Implementation Complexity</th>\n<th>Error Reporting Quality</th>\n<th>Memory Usage</th>\n<th>Extensibility</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Recursive Descent</td>\n<td>Low - mirrors data structure</td>\n<td>Excellent - clear stack traces</td>\n<td>High - uses call stack</td>\n<td>Excellent - easy to add syntax</td>\n</tr>\n<tr>\n<td>Shift-Reduce</td>\n<td>High - requires state tables</td>\n<td>Good - but cryptic conflicts</td>\n<td>Low - explicit stack</td>\n<td>Moderate - table regeneration</td>\n</tr>\n<tr>\n<td>Parser Combinators</td>\n<td>Moderate - library learning curve</td>\n<td>Excellent - composable errors</td>\n<td>Moderate - lazy evaluation</td>\n<td>Excellent - highly composable</td>\n</tr>\n</tbody></table>\n<p>The recursive descent strategy centers around two mutually recursive functions that mirror the two main structures in Lisp:</p>\n<ol>\n<li><strong><code>read_expr</code></strong> - Reads a single complete expression from the token stream, dispatching based on the first token type</li>\n<li><strong><code>read_list</code></strong> - Reads a parenthesized list by repeatedly calling <code>read_expr</code> until the closing parenthesis</li>\n</ol>\n<p>The parsing algorithm follows these steps:</p>\n<ol>\n<li><strong>Token Stream Positioning</strong>: The parser maintains a current position in the token stream, advancing as tokens are consumed</li>\n<li><strong>Expression Type Dispatch</strong>: <code>read_expr</code> examines the current token type to determine what kind of expression to parse</li>\n<li><strong>Atomic Expression Handling</strong>: For atoms (numbers, symbols, strings), create the appropriate <code>LispValue</code> and advance position</li>\n<li><strong>List Expression Delegation</strong>: For left parentheses, delegate to <code>read_list</code> to handle the nested structure</li>\n<li><strong>Quote Syntax Transformation</strong>: For quote marks, transform into canonical <code>(quote expr)</code> form</li>\n<li><strong>Recursive List Assembly</strong>: <code>read_list</code> repeatedly calls <code>read_expr</code> to collect list elements until finding the closing parenthesis</li>\n<li><strong>Position Management</strong>: Each parsing function returns both the parsed value and the new token stream position</li>\n<li><strong>Error Boundary Detection</strong>: Invalid token sequences trigger <code>ParseError</code> exceptions with position information</li>\n</ol>\n<blockquote>\n<p>The critical insight is that <strong>each recursive call handles exactly one level of nesting</strong>. The call stack automatically tracks which lists are currently being assembled, eliminating the need for explicit stack management.</p>\n</blockquote>\n<p>Here&#39;s the detailed parsing algorithm:</p>\n<p><strong><code>read_expr</code> Algorithm:</strong></p>\n<ol>\n<li>Check if current position is beyond token stream bounds—if so, raise EOF error</li>\n<li>Examine the token type at current position to determine expression kind</li>\n<li>For <code>TokenType.NUMBER</code>: Convert token value to numeric <code>LispValue</code>, advance position, return result</li>\n<li>For <code>TokenType.SYMBOL</code>: Create symbol <code>LispValue</code> with token value, advance position, return result  </li>\n<li>For <code>TokenType.STRING</code>: Create string <code>LispValue</code> with unescaped token value, advance position, return result</li>\n<li>For <code>TokenType.LEFT_PAREN</code>: Delegate to <code>read_list</code> to parse parenthesized expression</li>\n<li>For <code>TokenType.QUOTE</code>: Parse quoted expression by recursively calling <code>read_expr</code> and wrapping result in <code>(quote ...)</code> form</li>\n<li>For <code>TokenType.RIGHT_PAREN</code>: Raise error about unmatched closing parenthesis</li>\n<li>For any other token type: Raise error about unexpected token</li>\n</ol>\n<p><strong><code>read_list</code> Algorithm:</strong></p>\n<ol>\n<li>Verify current token is <code>TokenType.LEFT_PAREN</code>, advance position past opening parenthesis</li>\n<li>Initialize empty list to collect parsed elements</li>\n<li>Enter parsing loop: while current token is not <code>TokenType.RIGHT_PAREN</code> and not at EOF:\na. Call <code>read_expr</code> recursively to parse next list element\nb. Add parsed element to the growing list\nc. Update position to continue after parsed element</li>\n<li>Check that loop terminated due to <code>TokenType.RIGHT_PAREN</code> (not EOF)—if EOF, raise unmatched parentheses error</li>\n<li>Advance position past closing parenthesis</li>\n<li>Create list <code>LispValue</code> containing all collected elements and return with updated position</li>\n</ol>\n<p>The parser maintains <strong>position threading</strong>—each parsing function receives a token stream position and returns both its result and the updated position after consuming tokens. This functional approach prevents position management bugs and makes the parser easier to test and debug.</p>\n<table>\n<thead>\n<tr>\n<th>Function</th>\n<th>Input</th>\n<th>Output</th>\n<th>Responsibility</th>\n<th>Error Conditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>read_expr</code></td>\n<td>tokens, position</td>\n<td>(LispValue, new_position)</td>\n<td>Parse single expression</td>\n<td>EOF, unexpected token, unmatched <code>)</code></td>\n</tr>\n<tr>\n<td><code>read_list</code></td>\n<td>tokens, position</td>\n<td>(LispValue, new_position)</td>\n<td>Parse parenthesized list</td>\n<td>EOF before <code>)</code>, nested parse errors</td>\n</tr>\n</tbody></table>\n<h3 id=\"quote-syntax-transformation\">Quote Syntax Transformation</h3>\n<p>Lisp&#39;s <strong>quote syntax</strong> provides a shorthand for preventing evaluation—<code>&#39;expr</code> is equivalent to <code>(quote expr)</code>. The parser must recognize this syntax and transform it into the canonical form during parsing, not evaluation. This transformation happens in the parser because it&#39;s purely syntactic sugar that doesn&#39;t change the semantic meaning of the code.</p>\n<blockquote>\n<p><strong>Decision: Parse-Time Quote Transformation</strong></p>\n<ul>\n<li><strong>Context</strong>: Lisp provides <code>&#39;expr</code> shorthand for <code>(quote expr)</code> that must be handled somewhere in the pipeline</li>\n<li><strong>Options Considered</strong>: Transform during tokenization, transform during parsing, handle during evaluation</li>\n<li><strong>Decision</strong>: Transform quote syntax during parsing phase</li>\n<li><strong>Rationale</strong>: Quotes are syntactic sugar that should be normalized before evaluation; parsing is responsible for syntax tree construction; keeps tokenizer simple and focused on boundary detection</li>\n<li><strong>Consequences</strong>: Parser complexity increases slightly, but evaluator remains clean and doesn&#39;t need special quote token handling</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Transformation Stage</th>\n<th>Complexity Impact</th>\n<th>Semantic Clarity</th>\n<th>Component Responsibility Alignment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Tokenization</strong></td>\n<td>High - tokenizer must track context</td>\n<td>Poor - quotes mixed with atoms</td>\n<td>Poor - syntax transformation in wrong phase</td>\n</tr>\n<tr>\n<td><strong>Parsing</strong> ✓</td>\n<td>Low - single transformation rule</td>\n<td>Excellent - canonical form before evaluation</td>\n<td>Excellent - syntax handling in syntax phase</td>\n</tr>\n<tr>\n<td><strong>Evaluation</strong></td>\n<td>Moderate - special case in evaluator</td>\n<td>Good - but mixes syntax and semantics</td>\n<td>Poor - evaluation handling syntax</td>\n</tr>\n</tbody></table>\n<p>The quote transformation algorithm works as follows:</p>\n<p><strong>Quote Transformation Steps:</strong></p>\n<ol>\n<li><strong>Quote Token Detection</strong>: When <code>read_expr</code> encounters <code>TokenType.QUOTE</code>, it recognizes this as shorthand syntax</li>\n<li><strong>Position Advancement</strong>: Move past the quote token to access the expression being quoted</li>\n<li><strong>Recursive Expression Parsing</strong>: Call <code>read_expr</code> recursively to parse the expression immediately following the quote</li>\n<li><strong>Canonical Form Construction</strong>: Create a list <code>LispValue</code> with two elements: a symbol <code>LispValue</code> containing &quot;quote&quot; and the parsed expression</li>\n<li><strong>Position Threading</strong>: Return both the constructed quote form and the position after the quoted expression</li>\n</ol>\n<p>This transformation ensures that by the time expressions reach the evaluator, all quote syntax has been normalized into the standard <code>(quote expr)</code> form. The evaluator only needs to handle the canonical form, simplifying its implementation.</p>\n<p><strong>Example Transformations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Input Syntax</th>\n<th>Token Sequence</th>\n<th>Transformed AST</th>\n<th>Equivalent Canonical Form</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>&#39;42</code></td>\n<td><code>[QUOTE, NUMBER(&quot;42&quot;)]</code></td>\n<td><code>make_list([make_symbol(&quot;quote&quot;), make_number(42)])</code></td>\n<td><code>(quote 42)</code></td>\n</tr>\n<tr>\n<td><code>&#39;foo</code></td>\n<td><code>[QUOTE, SYMBOL(&quot;foo&quot;)]</code></td>\n<td><code>make_list([make_symbol(&quot;quote&quot;), make_symbol(&quot;foo&quot;)])</code></td>\n<td><code>(quote foo)</code></td>\n</tr>\n<tr>\n<td><code>&#39;(a b c)</code></td>\n<td><code>[QUOTE, LEFT_PAREN, SYMBOL(&quot;a&quot;), ...]</code></td>\n<td><code>make_list([make_symbol(&quot;quote&quot;), make_list([...])])</code></td>\n<td><code>(quote (a b c))</code></td>\n</tr>\n<tr>\n<td><code>&#39;&#39;x</code></td>\n<td><code>[QUOTE, QUOTE, SYMBOL(&quot;x&quot;)]</code></td>\n<td><code>make_list([make_symbol(&quot;quote&quot;), make_list([make_symbol(&quot;quote&quot;), make_symbol(&quot;x&quot;)])])</code></td>\n<td><code>(quote (quote x))</code></td>\n</tr>\n</tbody></table>\n<p>The transformation handles nested quotes correctly—<code>&#39;&#39;x</code> becomes <code>(quote (quote x))</code> because each quote token triggers its own transformation, and the outer quote processes the result of the inner quote transformation.</p>\n<blockquote>\n<p>Quote transformation must happen <strong>before</strong> the expression enters the evaluator because <code>&#39;(+ 1 2)</code> should evaluate to the list <code>(+ 1 2)</code>, not to <code>3</code>. The evaluator sees <code>(quote (+ 1 2))</code> and knows to return the second element without evaluating it.</p>\n</blockquote>\n<h3 id=\"common-parser-pitfalls\">Common Parser Pitfalls</h3>\n<p>Understanding the common mistakes helps build a robust parser that handles edge cases gracefully. These pitfalls frequently trap learners because they involve subtle interactions between tokenization, parsing, and error handling.</p>\n<p>⚠️ <strong>Pitfall: Unbalanced Parentheses Detection</strong></p>\n<p>Many learners implement parsers that crash with stack overflow or array bounds errors when parentheses don&#39;t match, instead of producing clear error messages.</p>\n<p><strong>The Problem</strong>: When <code>read_list</code> encounters EOF while looking for a closing parenthesis, naive implementations either crash trying to access tokens beyond the array bounds or return incomplete data structures.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Users need clear error messages that pinpoint the location of unmatched parentheses. A stack overflow or &quot;index out of bounds&quot; exception provides no useful information for fixing the syntax error.</p>\n<p><strong>The Fix</strong>: Before accessing tokens by index, always check bounds. When <code>read_list</code> reaches EOF without finding <code>TokenType.RIGHT_PAREN</code>, raise a <code>ParseError</code> with a message like &quot;Unmatched opening parenthesis at position X&quot; and include the position of the opening parenthesis.</p>\n<p>⚠️ <strong>Pitfall: Position Management Bugs</strong></p>\n<p>Beginners often update the token stream position inconsistently, leading to tokens being skipped or processed twice.</p>\n<p><strong>The Problem</strong>: Forgetting to thread position updates through recursive calls, or updating position in multiple places, causes the parser to get &quot;lost&quot; in the token stream.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Position bugs manifest as mysterious parsing failures where the parser sees the wrong tokens or reports errors at incorrect locations. These bugs are extremely difficult to debug without careful position tracking.</p>\n<p><strong>The Fix</strong>: Use <strong>functional position threading</strong>—every parsing function receives a position parameter and returns a new position. Never mutate a global position variable. Always use the position returned by recursive calls for subsequent operations.</p>\n<p>⚠️ <strong>Pitfall: EOF Handling Inconsistency</strong></p>\n<p>Inconsistent EOF checking leads to crashes or incorrect parsing when input ends unexpectedly.</p>\n<p><strong>The Problem</strong>: Some parsing functions check for EOF properly while others assume tokens are always available, creating inconsistent error handling behavior.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Real-world input often ends abruptly or contains incomplete expressions. The parser must handle EOF gracefully at every point where it accesses tokens.</p>\n<p><strong>The Fix</strong>: Create a helper function <code>is_at_end(tokens, position)</code> and call it before every token access. Define clear EOF semantics—what constitutes a complete vs. incomplete expression—and enforce them consistently.</p>\n<p>⚠️ <strong>Pitfall: Error Recovery Absence</strong></p>\n<p>Parsers that stop at the first error provide poor user experience and make debugging difficult.</p>\n<p><strong>The Problem</strong>: When the parser encounters an error, it immediately raises an exception without attempting to parse the rest of the input or provide context about nearby valid syntax.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Users often have multiple syntax errors in their code. Stopping at the first error forces a slow fix-one-test-again cycle. Additionally, early termination provides no context about what the parser expected to find.</p>\n<p><strong>The Fix</strong>: Implement <strong>panic mode recovery</strong>—when an error occurs, skip tokens until reaching a likely recovery point (like the next top-level expression) and continue parsing. Report all errors found, not just the first one.</p>\n<p>⚠️ <strong>Pitfall: Quote Handling in Error Cases</strong></p>\n<p>Forgetting that quotes consume two tokens (the quote mark and the following expression) leads to position management errors in error scenarios.</p>\n<p><strong>The Problem</strong>: When a quote token appears at EOF or is followed by an invalid token, the error handling code doesn&#39;t account for the two-token nature of quote syntax.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Error messages report incorrect positions, and position recovery after quote-related errors may cause subsequent valid syntax to be misparsed.</p>\n<p><strong>The Fix</strong>: In quote handling code, always check that a parseable expression follows the quote token before attempting to parse it. If EOF or an invalid token follows a quote, report &quot;Incomplete quote syntax&quot; rather than letting the recursive <code>read_expr</code> call fail with a generic error.</p>\n<p>⚠️ <strong>Pitfall: Deep Nesting Stack Overflow</strong></p>\n<p>Recursive descent parsers can exhaust the call stack on deeply nested input, causing crashes instead of graceful error handling.</p>\n<p><strong>The Problem</strong>: Input like <code>(((((...))))</code> with hundreds of nesting levels causes each level to add a stack frame, eventually overflowing the call stack.</p>\n<p><strong>Why It&#39;s Wrong</strong>: Stack overflow crashes are abrupt and provide no information about the nesting depth or location of the problem. Users can&#39;t easily determine how to fix their code.</p>\n<p><strong>The Fix</strong>: Implement <strong>nesting depth limiting</strong>—track recursion depth and raise a <code>ParseError</code> when it exceeds a reasonable limit (e.g., 1000 levels). This provides a clear error message and prevents crashes.</p>\n<table>\n<thead>\n<tr>\n<th>Pitfall</th>\n<th>Symptom</th>\n<th>Root Cause</th>\n<th>Detection Strategy</th>\n<th>Fix Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unbalanced Parentheses</td>\n<td>Crashes or wrong results</td>\n<td>Missing bounds checks</td>\n<td>Test with <code>(((</code> input</td>\n<td>Check EOF before token access</td>\n</tr>\n<tr>\n<td>Position Threading</td>\n<td>Tokens skipped/repeated</td>\n<td>Inconsistent position updates</td>\n<td>Test complex nested expressions</td>\n<td>Functional position passing</td>\n</tr>\n<tr>\n<td>EOF Handling</td>\n<td>Crashes on incomplete input</td>\n<td>Inconsistent EOF checks</td>\n<td>Test input ending mid-expression</td>\n<td>Consistent <code>is_at_end()</code> checks</td>\n</tr>\n<tr>\n<td>Error Recovery</td>\n<td>Single error reported</td>\n<td>Early termination</td>\n<td>Test multiple syntax errors</td>\n<td>Panic mode recovery</td>\n</tr>\n<tr>\n<td>Quote Error Handling</td>\n<td>Wrong error positions</td>\n<td>Two-token quote nature ignored</td>\n<td>Test <code>&#39;</code> at EOF</td>\n<td>Validate quote completeness</td>\n</tr>\n<tr>\n<td>Stack Overflow</td>\n<td>Crash on deep nesting</td>\n<td>Unbounded recursion</td>\n<td>Test deeply nested input</td>\n<td>Depth limiting with clear errors</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The parser implementation requires careful coordination between token stream management, recursive descent logic, and error handling. The following guidance provides both complete infrastructure code and detailed skeletons for the core parsing logic.</p>\n<p><strong>A. Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Token Stream Access</td>\n<td>List indexing with bounds checks</td>\n<td>Iterator pattern with lookahead buffer</td>\n</tr>\n<tr>\n<td>Error Collection</td>\n<td>Exception-based with single error</td>\n<td>Error accumulation with multiple errors</td>\n</tr>\n<tr>\n<td>Position Tracking</td>\n<td>Integer index threading</td>\n<td>Position object with line/column info</td>\n</tr>\n<tr>\n<td>AST Construction</td>\n<td>Direct <code>LispValue</code> creation</td>\n<td>AST builder pattern with validation</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>src/\n  lisp_interpreter/\n    __init__.py              ← main module exports\n    tokenizer.py             ← tokenizer from previous section\n    parser.py                ← this component\n    evaluator.py             ← next component\n    data_model.py            ← LispValue, Token definitions\n    errors.py                ← error type hierarchy\n  tests/\n    test_parser.py           ← parser unit tests\n    test_integration.py      ← end-to-end parsing tests</code></pre></div>\n\n<p><strong>C. Complete Infrastructure Code</strong></p>\n<p>Here&#39;s the complete error handling and position management infrastructure:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># errors.py - Complete error hierarchy for parser</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all Lisp interpreter errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, source_location: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.source_location </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source_location</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when parsing fails due to invalid syntax.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, position: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, token_value: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.position </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> position</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.token_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> token_value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        location_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\" at position </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">position</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> token_value:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            location_info </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\" (near '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">token_value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">')\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> location_info, position)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Position management utilities - complete implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_at_end</span><span style=\"color:#E1E4E8\">(tokens, position):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if position is at or beyond end of token stream.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> position </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(tokens) </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> tokens[position].type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> TokenType.</span><span style=\"color:#79B8FF\">EOF</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> current_token</span><span style=\"color:#E1E4E8\">(tokens, position):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Get current token, ensuring bounds safety.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> is_at_end(tokens, position):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Return synthetic EOF token if past end</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Token(</span><span style=\"color:#FFAB70\">type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">TokenType.</span><span style=\"color:#79B8FF\">EOF</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">value</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">position</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">position)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> tokens[position]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> peek_token</span><span style=\"color:#E1E4E8\">(tokens, position, offset</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Look ahead at token without advancing position.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    peek_pos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> position </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> offset</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> current_token(tokens, peek_pos)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> expect_token</span><span style=\"color:#E1E4E8\">(tokens, position, expected_type):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Verify current token matches expected type, advance if so.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_token(tokens, position)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> token.type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> expected_type:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> ParseError(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            f</span><span style=\"color:#9ECBFF\">\"Expected </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">token.type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            position,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            token.value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> position </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Quote syntax constants</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">QUOTE_SYMBOL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"quote\"</span></span></code></pre></div>\n\n<p><strong>D. Core Parser Skeleton Code</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># parser.py - Core parsing logic for learner implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Tuple, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispValue, Token, TokenType, make_symbol, make_number, make_list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ParseError, is_at_end, current_token, expect_token</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Parser</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Recursive descent parser for Lisp S-expressions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, max_nesting_depth: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.max_nesting_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> max_nesting_depth</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse</span><span style=\"color:#E1E4E8\">(self, tokens: List[Token]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Parse complete expression from token stream.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            tokens: List of tokens from tokenizer</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            LispValue representing parsed S-expression</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ParseError: If syntax is invalid or tokens malformed</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> tokens </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> tokens[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> TokenType.</span><span style=\"color:#79B8FF\">EOF</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> ParseError(</span><span style=\"color:#9ECBFF\">\"Empty input - no expression to parse\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expr, final_position </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.read_expr(tokens, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">depth</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if there are unparsed tokens after the main expression</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If so, raise ParseError about unexpected tokens after expression</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use is_at_end() to check if all tokens consumed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> expr</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> read_expr</span><span style=\"color:#E1E4E8\">(self, tokens: List[Token], position: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, depth: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Tuple[LispValue, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Read single expression from token stream starting at position.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            tokens: Token stream to parse from</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            position: Current position in token stream</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            depth: Current nesting depth for overflow protection</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Tuple of (parsed_expression, new_position_after_expression)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ParseError: If expression is malformed or nesting too deep</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if depth exceeds max_nesting_depth, raise ParseError if so</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check if at end of tokens, raise ParseError about unexpected EOF</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Get current token using current_token() helper</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Dispatch based on token type:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - TokenType.NUMBER: convert to number LispValue, advance position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - TokenType.SYMBOL: create symbol LispValue, advance position  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - TokenType.STRING: create string LispValue, advance position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - TokenType.LEFT_PAREN: delegate to read_list()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - TokenType.QUOTE: handle quote transformation (see read_quote_expr)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - TokenType.RIGHT_PAREN: raise ParseError about unmatched parenthesis</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   - other types: raise ParseError about unexpected token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return tuple of (created_value, updated_position)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use make_number(), make_symbol(), make_list() from data_model</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> read_list</span><span style=\"color:#E1E4E8\">(self, tokens: List[Token], position: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, depth: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Tuple[LispValue, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Read parenthesized list expression from token stream.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            tokens: Token stream to parse from</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            position: Position of LEFT_PAREN token</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            depth: Current nesting depth</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Tuple of (list_value, position_after_closing_paren)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ParseError: If list is malformed or not properly closed</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Verify current token is LEFT_PAREN using current_token()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Advance position past opening parenthesis</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Initialize empty list to collect elements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Loop while not at RIGHT_PAREN and not at EOF:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   a. Call read_expr() recursively to parse next element</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   b. Add parsed element to collection list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #   c. Update position to continue after parsed element</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Check loop terminated due to RIGHT_PAREN, not EOF</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If EOF reached, raise ParseError about unmatched opening parenthesis</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Advance position past closing RIGHT_PAREN</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Create list LispValue from collected elements using make_list()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Return tuple of (list_value, final_position)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Track opening_paren_position for better error messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> read_quote_expr</span><span style=\"color:#E1E4E8\">(self, tokens: List[Token], position: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, depth: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Tuple[LispValue, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle quote syntax transformation from 'expr to (quote expr).</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            tokens: Token stream to parse from  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            position: Position of QUOTE token</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            depth: Current nesting depth</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Tuple of (quote_list_value, position_after_quoted_expr)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ParseError: If quote is incomplete or malformed</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Verify current token is QUOTE using current_token()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Advance position past quote token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check if at EOF - if so, raise ParseError about incomplete quote</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Call read_expr() recursively to parse quoted expression</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create symbol LispValue for \"quote\" using make_symbol()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Create list LispValue containing quote symbol and quoted expr using make_list()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return tuple of (quote_list, position_after_quoted_expr)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: The result should be equivalent to parsing (quote &#x3C;expr>)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Helper function for creating parser instance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse</span><span style=\"color:#E1E4E8\">(tokens: List[Token]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convenience function for parsing tokens into AST.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        tokens: Output from tokenizer</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        LispValue representing the parsed expression</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Parser()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> parser.parse(tokens)</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ul>\n<li><strong>Exception Handling</strong>: Use <code>try</code>/<code>except</code> blocks to catch recursive parsing errors and add context about the current parsing location</li>\n<li><strong>List Construction</strong>: Python lists work well for collecting parsed elements before creating the final <code>LispValue</code></li>\n<li><strong>String Handling</strong>: When parsing string tokens, remember to unescape any escape sequences that were preserved during tokenization</li>\n<li><strong>Type Checking</strong>: Use <code>isinstance()</code> to verify token types if not using enums, or direct equality comparison with enum values</li>\n<li><strong>Debugging</strong>: Add optional debug logging that shows the current token and depth at each parsing step</li>\n</ul>\n<p><strong>F. Milestone Checkpoint</strong></p>\n<p>After implementing the parser, verify these behaviors:</p>\n<p><strong>Test Commands:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_parser.py</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"from lisp_interpreter import tokenize, parse; print(parse(tokenize('(+ 1 2)')))\"</span></span></code></pre></div>\n\n<p><strong>Expected Outputs:</strong></p>\n<ul>\n<li>Simple atom: <code>42</code> → <code>LispValue(value=42, type=LispValueType.NUMBER)</code></li>\n<li>Simple list: <code>(+ 1 2)</code> → <code>LispValue(value=[symbol(&#39;+&#39;), number(1), number(2)], type=LispValueType.LIST)</code></li>\n<li>Quote syntax: <code>&#39;foo</code> → <code>LispValue(value=[symbol(&#39;quote&#39;), symbol(&#39;foo&#39;)], type=LispValueType.LIST)</code></li>\n<li>Nested lists: <code>(a (b c))</code> → Properly nested list structure</li>\n</ul>\n<p><strong>Manual Verification:</strong></p>\n<ol>\n<li>Parse valid S-expressions and inspect the resulting data structure</li>\n<li>Try malformed input like <code>(((</code> and verify you get clear error messages, not crashes</li>\n<li>Test quote syntax with <code>&#39;(a b c)</code> and verify it becomes <code>(quote (a b c))</code></li>\n<li>Test deeply nested expressions to ensure depth limiting works</li>\n</ol>\n<p><strong>Signs of Problems:</strong></p>\n<ul>\n<li><strong>&quot;Index out of range&quot; errors</strong>: Position threading is broken—check that all recursive calls properly thread position updates</li>\n<li><strong>Wrong number of list elements</strong>: Quote handling isn&#39;t advancing position correctly—ensure quote processing consumes exactly two tokens</li>\n<li><strong>Stack overflow on nested input</strong>: Depth limiting not implemented—add nesting depth checks in <code>read_expr</code></li>\n<li><strong>Malformed AST structures</strong>: Make sure each parsing function creates the correct <code>LispValue</code> type and structure</li>\n</ul>\n<h2 id=\"evaluator-design\">Evaluator Design</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestones 2-4 (Basic Evaluation, Variables and Functions, List Operations &amp; Recursion) - the evaluator is the final stage of the three-part pipeline that implements Lisp semantics and brings the parsed code to life</p>\n</blockquote>\n<p>The evaluator is the heart of our Lisp interpreter - where the parsed abstract syntax tree transforms into actual computation. While the tokenizer and parser handle the mechanical aspects of breaking down and structuring text, the evaluator implements the semantic rules that make Lisp a functioning programming language. It must correctly handle arithmetic, conditionals, variable binding, function creation and application, lexical scoping, and recursive computation.</p>\n<h3 id=\"mental-model-universal-calculator-with-memory\">Mental Model: Universal Calculator with Memory</h3>\n<p>Think of the evaluator as an extraordinarily sophisticated calculator that has evolved beyond simple arithmetic. A basic calculator takes expressions like &quot;2 + 3&quot; and produces results. Our Lisp evaluator does the same thing, but with three crucial enhancements that transform it from a simple calculator into a universal computing engine.</p>\n<p>First, it has <strong>perfect memory</strong> - when you define a variable with <code>(define x 10)</code>, the evaluator remembers that <code>x</code> means <code>10</code> in all future calculations. Unlike a calculator that forgets everything when you turn it off, the evaluator maintains a persistent memory of all the names and values you&#39;ve defined.</p>\n<p>Second, it can <strong>learn new operations</strong> - when you create a function with <code>(lambda (x y) (+ (* x x) (* y y)))</code>, you&#39;re teaching the evaluator a new operation (calculating the sum of squares). From that point on, the evaluator can perform this new operation just as easily as basic arithmetic. It&#39;s like giving a calculator the ability to learn and remember new mathematical functions.</p>\n<p>Third, it has <strong>contextual awareness</strong> - the evaluator understands that the same name might mean different things in different contexts. When a function defines parameters, those names create a local context where they have specific meanings, separate from any global definitions. This is like having a calculator that can temporarily redefine what the variable &quot;x&quot; means while solving a particular problem.</p>\n<p>The beauty of this mental model is that it scales from simple arithmetic <code>(+ 2 3)</code> all the way up to complex recursive functions. Whether evaluating a number, looking up a variable, or applying a function, the evaluator follows the same basic pattern: examine the expression, determine what kind of computation it represents, and produce the appropriate result using its memory and learned operations.</p>\n<h3 id=\"core-evaluation-rules\">Core Evaluation Rules</h3>\n<p>The evaluator implements a small set of fundamental rules that, when combined, create the full power of Lisp computation. These rules form a hierarchy based on the type of expression being evaluated, with each rule handling a specific category of Lisp syntax.</p>\n<p><strong>Self-Evaluating Expressions</strong> form the base case of evaluation. Numbers like <code>42</code> or <code>3.14</code> evaluate to themselves - they represent literal values that need no further computation. This seems trivial, but it&#39;s crucial because it provides the foundation for all other computation. Without self-evaluating atoms, we&#39;d have no way to introduce concrete values into our computations.</p>\n<p><strong>Symbol Lookup</strong> handles variable references. When the evaluator encounters a symbol like <code>x</code> or <code>factorial</code>, it searches through the environment chain to find what value that name represents. This rule transforms names into values, enabling the memory aspect of our universal calculator. The lookup process starts in the current environment and walks up the parent chain until it finds a binding or reaches the global environment.</p>\n<p><strong>List Evaluation</strong> handles the most complex case - parenthesized expressions that represent either function calls or special forms. The evaluator must first examine the first element of the list to determine how to proceed. If the first element is a symbol that names a special form like <code>if</code> or <code>define</code>, the evaluator follows special form rules. Otherwise, it treats the expression as a function call.</p>\n<p><strong>Function Application</strong> represents the general case of computation. The evaluator first evaluates all elements of the list: the function position (first element) should evaluate to a function, and the remaining elements become the arguments. Once all arguments are evaluated, the evaluator applies the function to the arguments in a new environment that binds the function&#39;s parameters to the argument values.</p>\n<p><strong>Special Form Handling</strong> provides the control structures and binding mechanisms that make Lisp powerful. Unlike function calls, special forms control when and how their arguments are evaluated. The <code>if</code> special form evaluates its test expression, then evaluates either the consequent or alternative based on the result. The <code>define</code> form evaluates its value expression and creates a binding in the current environment. The <code>lambda</code> form creates a new function without evaluating its body.</p>\n<table>\n<thead>\n<tr>\n<th>Expression Type</th>\n<th>Evaluation Rule</th>\n<th>Environment Usage</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Number</td>\n<td>Return the numeric value unchanged</td>\n<td>None</td>\n<td><code>42</code> → <code>42</code></td>\n</tr>\n<tr>\n<td>String</td>\n<td>Return the string value unchanged</td>\n<td>None</td>\n<td><code>&quot;hello&quot;</code> → <code>&quot;hello&quot;</code></td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>Look up binding in environment chain</td>\n<td>Read from environment</td>\n<td><code>x</code> → value bound to <code>x</code></td>\n</tr>\n<tr>\n<td>Empty List</td>\n<td>Return empty list unchanged</td>\n<td>None</td>\n<td><code>()</code> → <code>()</code></td>\n</tr>\n<tr>\n<td>List (special form)</td>\n<td>Follow special form rules</td>\n<td>Varies by form</td>\n<td><code>(if test a b)</code></td>\n</tr>\n<tr>\n<td>List (function call)</td>\n<td>Evaluate function and args, then apply</td>\n<td>Function creates new scope</td>\n<td><code>(+ 1 2)</code></td>\n</tr>\n</tbody></table>\n<p>The evaluation process follows a recursive structure that mirrors the nested structure of Lisp expressions. When evaluating a complex expression like <code>(+ (* 2 3) (- 10 4))</code>, the evaluator recursively evaluates the subexpressions <code>(* 2 3)</code> and <code>(- 10 4)</code> before applying the addition function to their results. This recursive approach naturally handles arbitrarily nested expressions without requiring special case logic for different levels of nesting.</p>\n<blockquote>\n<p><strong>Key Insight</strong>: The recursive nature of evaluation mirrors the recursive structure of Lisp syntax. Every compound expression breaks down into simpler expressions until we reach atoms, which evaluate to themselves or look up to values.</p>\n</blockquote>\n<p><strong>Environment Threading</strong> ensures that variable bindings flow correctly through the evaluation process. Every evaluation operation takes an environment parameter and either uses it unchanged (for atoms and simple lookups) or creates modified environments (for function calls and special forms that introduce bindings). This threading pattern ensures that each expression evaluates in the correct lexical context.</p>\n<p><strong>Error Propagation</strong> handles cases where evaluation cannot proceed normally. When a symbol has no binding, when a function is called with wrong number of arguments, or when a non-function appears in function position, the evaluator must generate appropriate error messages and halt evaluation. These errors must include enough context to help the programmer identify and fix the problem.</p>\n<h3 id=\"special-forms-vs-function-calls\">Special Forms vs Function Calls</h3>\n<p>Understanding the distinction between special forms and function calls is crucial to implementing a correct Lisp evaluator. This distinction affects when arguments are evaluated, how control flows through the program, and what kinds of language constructs are possible to implement.</p>\n<p><strong>Function calls</strong> follow a predictable evaluation pattern: evaluate the function expression, evaluate all argument expressions, then apply the function to the argument values. This eager evaluation strategy means that all arguments are computed before the function sees them. For example, in <code>(+ (* 2 3) (- 10 4))</code>, both multiplication and subtraction execute before the addition function receives the values <code>6</code> and <code>6</code>.</p>\n<p><strong>Special forms</strong> break this pattern by controlling when and whether their arguments are evaluated. The <code>if</code> special form evaluates its test expression first, then evaluates either the consequent or alternative - but never both. The <code>define</code> form evaluates its value expression but never evaluates the symbol being bound. The <code>lambda</code> form never evaluates its body expression during function creation - the body only gets evaluated later when the function is called.</p>\n<blockquote>\n<p><strong>Decision: Special Form Implementation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to distinguish special forms from regular functions during evaluation, but both appear as lists starting with symbols</li>\n<li><strong>Options Considered</strong>: 1) Mark special forms with metadata during parsing, 2) Check symbol names during evaluation, 3) Pre-populate environment with special form markers</li>\n<li><strong>Decision</strong>: Check symbol names during evaluation using <code>is_special_form()</code> predicate</li>\n<li><strong>Rationale</strong>: This approach keeps parsing simple and avoids complex metadata systems while making the evaluation logic explicit</li>\n<li><strong>Consequences</strong>: Slight performance cost from string comparisons, but clearer separation between parsing and evaluation phases</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Function Calls</th>\n<th>Special Forms</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Argument Evaluation</td>\n<td>All arguments evaluated before application</td>\n<td>Controlled evaluation - some args may not be evaluated</td>\n</tr>\n<tr>\n<td>Implementation</td>\n<td>User-defined or built-in functions</td>\n<td>Hard-coded in evaluator</td>\n</tr>\n<tr>\n<td>Extensibility</td>\n<td>Unlimited - users can define new functions</td>\n<td>Fixed set defined by language</td>\n</tr>\n<tr>\n<td>Examples</td>\n<td><code>(+ 1 2)</code>, <code>(factorial 5)</code></td>\n<td><code>(if test a b)</code>, <code>(define x 10)</code></td>\n</tr>\n</tbody></table>\n<p><strong>Conditional Evaluation</strong> exemplifies why special forms matter. Consider <code>(if (&gt; x 0) (/ 10 x) 0)</code>. If <code>if</code> were a regular function, both <code>(/ 10 x)</code> and <code>0</code> would be evaluated before <code>if</code> could make its decision. When <code>x</code> is zero, this would cause a division by zero error even though the conditional logic should prevent it. By making <code>if</code> a special form that only evaluates the chosen branch, we avoid this problem.</p>\n<p><strong>Binding and Scope</strong> require special forms because they affect the evaluation environment rather than just computing values. The <code>define</code> form must bind a symbol to a value in the current environment - this is a side effect that changes how future expressions evaluate. A regular function cannot modify the environment in which it was called, so <code>define</code> must be implemented as a special form in the evaluator itself.</p>\n<p><strong>Short-Circuit Logic</strong> in forms like <code>and</code> and <code>or</code> requires special form treatment. The expression <code>(and (valid-input? x) (process x))</code> should not call <code>process</code> if the input is invalid. Regular function evaluation would call both functions and combine their results, but the special form can stop evaluation as soon as one operand determines the final result.</p>\n<p><strong>Macro Expansion</strong> (though not implemented in our minimal Lisp) represents the ultimate special form - code that transforms other code before evaluation. This demonstrates why the special form mechanism is fundamental to Lisp&#39;s power, even though our implementation focuses on the essential special forms needed for basic computation.</p>\n<p>The evaluator handles this distinction through a dispatch mechanism that examines the first element of each list expression. If it&#39;s a symbol that names a special form, the evaluator calls the appropriate special form handler. Otherwise, it proceeds with normal function call evaluation.</p>\n<table>\n<thead>\n<tr>\n<th>Special Form</th>\n<th>Argument Evaluation Pattern</th>\n<th>Purpose</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>if</code></td>\n<td>Test expression only, then chosen branch</td>\n<td>Conditional execution</td>\n<td><code>(if (&gt; x 0) x (- x))</code></td>\n</tr>\n<tr>\n<td><code>define</code></td>\n<td>Value expression only, symbol stays unevaluated</td>\n<td>Variable binding</td>\n<td><code>(define pi 3.14159)</code></td>\n</tr>\n<tr>\n<td><code>lambda</code></td>\n<td>Parameters and body stay unevaluated</td>\n<td>Function creation</td>\n<td><code>(lambda (x) (* x x))</code></td>\n</tr>\n<tr>\n<td><code>quote</code></td>\n<td>No arguments evaluated</td>\n<td>Literal data</td>\n<td><code>(quote (a b c))</code></td>\n</tr>\n<tr>\n<td><code>let</code></td>\n<td>Value expressions evaluated, variables stay unevaluated</td>\n<td>Local bindings</td>\n<td><code>(let ((x 5)) (* x x))</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"common-evaluator-pitfalls\">Common Evaluator Pitfalls</h3>\n<p>Building an evaluator involves subtle decisions about evaluation order, environment management, and error handling. These pitfalls represent the most frequent mistakes that cause evaluators to behave incorrectly or inconsistently.</p>\n<p>⚠️ <strong>Pitfall: Evaluating Special Form Arguments</strong></p>\n<p>The most common mistake is treating special forms like regular functions and evaluating all their arguments before processing them. New implementers often write code like this:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># WRONG - evaluates all arguments first</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> evaluate_if</span><span style=\"color:#E1E4E8\">(args, env):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    test_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> evaluate(args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    consequent_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> evaluate(args[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], env)  </span><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">BUG</span><span style=\"color:#6A737D\">: always evaluates</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    alternative_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> evaluate(args[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">], env)  </span><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">BUG</span><span style=\"color:#6A737D\">: always evaluates</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> consequent_value </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> is_truthy(test_value) </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> alternative_value</span></span></code></pre></div>\n\n<p>This breaks the fundamental semantics of conditional execution. The correct implementation only evaluates the chosen branch:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># CORRECT - only evaluates chosen branch</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> evaluate_if</span><span style=\"color:#E1E4E8\">(args, env):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    test_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> evaluate(args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">], env)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> is_truthy(test_value):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> evaluate(args[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">], env)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> evaluate(args[</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">], env)</span></span></code></pre></div>\n\n<p>The symptom is that expressions like <code>(if false (error &quot;boom&quot;) 42)</code> crash instead of returning <code>42</code>. Always evaluate special form arguments conditionally based on the form&#39;s semantics.</p>\n<p>⚠️ <strong>Pitfall: Function vs Special Form Confusion</strong></p>\n<p>Another frequent error is implementing language constructs as functions when they should be special forms, or vice versa. For example, implementing <code>and</code> as a regular function:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># WRONG - and should be a special form for short-circuiting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> builtin_and</span><span style=\"color:#E1E4E8\">(args):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> all</span><span style=\"color:#E1E4E8\">(is_truthy(arg) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> arg </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> args)  </span><span style=\"color:#6A737D\"># all args already evaluated!</span></span></code></pre></div>\n\n<p>This breaks short-circuit evaluation. The expression <code>(and (safe-check) (risky-operation))</code> will always call both functions, even if <code>safe-check</code> returns false. The correct implementation makes <code>and</code> a special form that can stop evaluation early.</p>\n<p>⚠️ <strong>Pitfall: Environment Mutation vs Extension</strong></p>\n<p>A subtle but critical error involves modifying environments incorrectly. Some implementations mutate the global environment when they should create new local environments:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># WRONG - modifies the global environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> apply_function</span><span style=\"color:#E1E4E8\">(func, args, env):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> param, arg </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> zip</span><span style=\"color:#E1E4E8\">(func.parameters, args):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        env.bindings[param] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> arg  </span><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">BUG</span><span style=\"color:#6A737D\">: pollutes caller's environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> evaluate(func.body, env)</span></span></code></pre></div>\n\n<p>This causes variables defined in function calls to leak into the calling scope. The correct approach creates a new environment that extends the function&#39;s closure environment:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># CORRECT - creates new environment for function</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> apply_function</span><span style=\"color:#E1E4E8\">(func, args, env):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> func.closure_env.extend()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> param, arg </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> zip</span><span style=\"color:#E1E4E8\">(func.parameters, args):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        new_env.define(param, arg)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> evaluate(func.body, new_env)</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Recursive Function Name Binding</strong></p>\n<p>When implementing recursive functions, a common mistake is not making the function name available in its own body:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># WRONG - function cannot call itself</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> evaluate_define</span><span style=\"color:#E1E4E8\">(name, value, env):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> evaluate(value, env)  </span><span style=\"color:#6A737D\"># function not yet bound</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    env.define(name, result)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span></code></pre></div>\n\n<p>For recursive functions defined with <code>(define factorial (lambda (n) ...))</code>, the lambda body cannot reference <code>factorial</code> because it&#39;s not bound until after the lambda is fully evaluated. The fix is to handle self-reference specially or use a two-phase binding approach.</p>\n<p>⚠️ <strong>Pitfall: Arity Checking Inconsistency</strong></p>\n<p>Many implementations check function arity inconsistently between built-in functions and user-defined functions:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># INCONSISTENT - built-ins don't check arity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> builtin_add</span><span style=\"color:#E1E4E8\">(args):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> sum</span><span style=\"color:#E1E4E8\">(args)  </span><span style=\"color:#6A737D\"># accepts any number of arguments</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> apply_function</span><span style=\"color:#E1E4E8\">(func, args, env):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(args) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(func.parameters):  </span><span style=\"color:#6A737D\"># user functions strictly checked</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> ArityError(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(func.parameters), </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(args), func.name)</span></span></code></pre></div>\n\n<p>This creates confusing behavior where some functions are flexible about argument counts while others are strict. Decide on a consistent arity policy and apply it everywhere.</p>\n<p>⚠️ <strong>Pitfall: Error Context Loss</strong></p>\n<p>Poor error handling loses the context needed for debugging:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># BAD - generic error with no context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> lookup</span><span style=\"color:#E1E4E8\">(name, env):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> env.bindings:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> NameError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"undefined variable\"</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># which variable?</span></span></code></pre></div>\n\n<p>Better error handling preserves context:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># BETTER - specific error with context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> lookup</span><span style=\"color:#E1E4E8\">(name, env):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> env.bindings:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> NameError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"undefined variable '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">' in </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">env.scope_description()</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p>⚠️ <strong>Pitfall: Infinite Recursion in Evaluation</strong></p>\n<p>Careless handling of evaluation can create infinite loops:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># DANGEROUS - can loop infinitely</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(expr, env):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> is_symbol(expr):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> env.lookup(expr.name)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> evaluate(value, env)  </span><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">BUG</span><span style=\"color:#6A737D\">: re-evaluates resolved values</span></span></code></pre></div>\n\n<p>The problem is re-evaluating values that are already fully evaluated. Numbers, strings, and functions should not be re-evaluated when retrieved from the environment.</p>\n<table>\n<thead>\n<tr>\n<th>Pitfall Category</th>\n<th>Common Mistake</th>\n<th>Symptom</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Special Forms</td>\n<td>Evaluating all arguments</td>\n<td>Conditional errors, performance issues</td>\n<td>Conditional evaluation based on form semantics</td>\n</tr>\n<tr>\n<td>Environment</td>\n<td>Mutating instead of extending</td>\n<td>Variable leaking between scopes</td>\n<td>Always create new environments for new scopes</td>\n</tr>\n<tr>\n<td>Function Application</td>\n<td>Inconsistent arity checking</td>\n<td>Confusing error behavior</td>\n<td>Uniform arity checking policy</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Generic error messages</td>\n<td>Hard-to-debug failures</td>\n<td>Include specific context in all errors</td>\n</tr>\n<tr>\n<td>Recursion</td>\n<td>Infinite evaluation loops</td>\n<td>Stack overflow on simple expressions</td>\n<td>Only evaluate unevaluated expressions</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The evaluator implementation requires careful attention to the interaction between expression types, environment management, and function application. The following guidance provides a foundation for building a correct and extensible evaluator that handles all the language features required by our Lisp implementation.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Expression Dispatch</td>\n<td>Dictionary mapping types to handlers</td>\n<td>Visitor pattern with type-based dispatch</td>\n</tr>\n<tr>\n<td>Environment Storage</td>\n<td>Dictionary with parent reference</td>\n<td>Persistent data structure with structural sharing</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Exception hierarchy with context</td>\n<td>Result types with error chaining</td>\n</tr>\n<tr>\n<td>Function Representation</td>\n<td>Simple dataclass with fields</td>\n<td>Tagged union with interface methods</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  src/\n    evaluator/\n      __init__.py           ← exports main evaluate() function\n      core.py               ← main evaluation dispatch logic\n      special_forms.py      ← handlers for if, define, lambda, etc.\n      builtins.py          ← arithmetic, comparison, list operations\n      environment.py        ← environment management (from previous section)\n      errors.py            ← evaluation-specific error types\n    tests/\n      test_evaluator.py    ← integration tests for full evaluation\n      test_special_forms.py ← unit tests for special form handlers\n      test_builtins.py     ← unit tests for built-in functions</code></pre></div>\n\n<p><strong>Core Evaluator Infrastructure (Complete):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/evaluator/errors.py - Complete error handling for evaluation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EvaluationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all evaluation errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> NameError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when a symbol is not bound in any environment.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, symbol_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, scope_info: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.symbol_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> symbol_name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.scope_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> scope_info</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"undefined variable '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">symbol_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">scope_info</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when an operation is applied to the wrong type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, expected_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, actual_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, operation: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expected_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expected_type</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.actual_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual_type</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.operation </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> operation</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">operation</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> expects </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">actual_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArityError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when a function is called with wrong number of arguments.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, expected: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, actual: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, function_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expected </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expected</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.actual </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.function_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> function_name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">function_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> expects </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> arguments, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">actual</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># src/evaluator/builtins.py - Complete built-in function implementations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispValue, make_number, make_symbol, make_list, is_number</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ArityError, </span><span style=\"color:#79B8FF\">TypeError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> builtin_add</span><span style=\"color:#E1E4E8\">(args: List[LispValue]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Addition operator: (+ num1 num2 ...)\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> args:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> make_number(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, arg </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(args):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> is_number(arg):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"number\"</span><span style=\"color:#E1E4E8\">, arg.type.name, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"+ argument </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> arg.value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> make_number(result)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> builtin_subtract</span><span style=\"color:#E1E4E8\">(args: List[LispValue]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Subtraction operator: (- num1 num2 ...)\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> args:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> ArityError(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"-\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> is_number(args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"number\"</span><span style=\"color:#E1E4E8\">, args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].type.name, </span><span style=\"color:#9ECBFF\">\"- first argument\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(args) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> make_number(</span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, arg </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(args[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:], </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> is_number(arg):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"number\"</span><span style=\"color:#E1E4E8\">, arg.type.name, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"- argument </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">-=</span><span style=\"color:#E1E4E8\"> arg.value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> make_number(result)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> builtin_multiply</span><span style=\"color:#E1E4E8\">(args: List[LispValue]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Multiplication operator: (* num1 num2 ...)\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> args:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> make_number(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, arg </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(args):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> is_number(arg):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"number\"</span><span style=\"color:#E1E4E8\">, arg.type.name, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"* argument </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">*=</span><span style=\"color:#E1E4E8\"> arg.value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> make_number(result)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> builtin_divide</span><span style=\"color:#E1E4E8\">(args: List[LispValue]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Division operator: (/ num1 num2 ...)\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> args:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> ArityError(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"/\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> is_number(args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"number\"</span><span style=\"color:#E1E4E8\">, args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].type.name, </span><span style=\"color:#9ECBFF\">\"/ first argument\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(args) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].value </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> EvaluationError(</span><span style=\"color:#9ECBFF\">\"division by zero in (/ 0)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> make_number(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> /</span><span style=\"color:#E1E4E8\"> args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, arg </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(args[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:], </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> is_number(arg):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"number\"</span><span style=\"color:#E1E4E8\">, arg.type.name, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"/ argument </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> arg.value </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> EvaluationError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"division by zero in / argument </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">/=</span><span style=\"color:#E1E4E8\"> arg.value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> make_number(result)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> builtin_less_than</span><span style=\"color:#E1E4E8\">(args: List[LispValue]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Less than comparison: (&#x3C; num1 num2)\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(args) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> ArityError(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(args), </span><span style=\"color:#9ECBFF\">\"&#x3C;\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i, arg </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(args):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> is_number(arg):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"number\"</span><span style=\"color:#E1E4E8\">, arg.type.name, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"&#x3C; argument </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> LISP_TRUE</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].value </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> args[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].value </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> LISP_FALSE</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Constants for Lisp truth values</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">LISP_TRUE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> make_symbol(</span><span style=\"color:#9ECBFF\">\"true\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">LISP_FALSE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> make_symbol(</span><span style=\"color:#9ECBFF\">\"false\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_truthy</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Determine if a Lisp value is considered true.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> LISP_FALSE</span><span style=\"color:#F97583\"> and</span><span style=\"color:#E1E4E8\"> value.value </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Built-in function registry</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">BUILTIN_FUNCTIONS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"+\"</span><span style=\"color:#E1E4E8\">: builtin_add,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"-\"</span><span style=\"color:#E1E4E8\">: builtin_subtract, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"*\"</span><span style=\"color:#E1E4E8\">: builtin_multiply,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"/\"</span><span style=\"color:#E1E4E8\">: builtin_divide,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"&#x3C;\"</span><span style=\"color:#E1E4E8\">: builtin_less_than,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Add more built-ins as needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_global_environment</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create the global environment with all built-in functions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    from</span><span style=\"color:#E1E4E8\"> .environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    from</span><span style=\"color:#E1E4E8\"> ..data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> make_builtin</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    global_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Environment()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> name, implementation </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> BUILTIN_FUNCTIONS</span><span style=\"color:#E1E4E8\">.items():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        builtin_func </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> make_builtin(implementation, name, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        global_env.define(name, builtin_func)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Add built-in constants</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    global_env.define(</span><span style=\"color:#9ECBFF\">\"true\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">LISP_TRUE</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    global_env.define(</span><span style=\"color:#9ECBFF\">\"false\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">LISP_FALSE</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> global_env</span></span></code></pre></div>\n\n<p><strong>Core Evaluation Logic Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/evaluator/core.py - Main evaluation dispatch logic</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    LispValue, LispValueType, Environment, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_number, is_symbol, is_list, is_function</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> EvaluationError, </span><span style=\"color:#79B8FF\">NameError</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">TypeError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .special_forms </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> SPECIAL_FORMS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .builtins </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> BUILTIN_FUNCTIONS</span><span style=\"color:#E1E4E8\">, is_truthy</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(ast: LispValue, env: Environment) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Main evaluation function - dispatches based on expression type.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This is the core of the interpreter that implements Lisp evaluation rules:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    - Numbers and strings evaluate to themselves</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    - Symbols look up their bindings in the environment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    - Lists are either special forms or function calls</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Handle self-evaluating expressions (numbers, strings)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Check ast.type and return ast unchanged for literals</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle symbol lookup in environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use env.lookup(ast.value) and handle NameError for unbound symbols</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle empty list (should evaluate to itself)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Check if list is empty and return unchanged</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle special forms (if, define, lambda, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Check if first element is a symbol naming a special form</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Use is_special_form(first_symbol) and dispatch to appropriate handler</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle function calls (general case)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Evaluate the function position and all arguments,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # then call apply_function with the results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle invalid expression types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Raise EvaluationError for anything that doesn't match above cases</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> apply_function</span><span style=\"color:#E1E4E8\">(func: LispValue, args: List[LispValue], env: Environment) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Apply a function to its arguments.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Handles both built-in functions and user-defined functions created by lambda.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Built-ins call their implementation directly, user functions create new</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    environments and evaluate their bodies.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Handle built-in functions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Check func.type == LispValueType.BUILTIN</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Call func.implementation(args) and return result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle user-defined functions  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Check func.type == LispValueType.FUNCTION</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Verify arity matches len(func.parameters) vs len(args)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create new environment for function body</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Start with func.closure_env.extend()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Bind each parameter to corresponding argument value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Evaluate function body in new environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: return evaluate(func.body, new_env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle non-function values in function position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Raise TypeError if func is not a callable type</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_special_form</span><span style=\"color:#E1E4E8\">(symbol_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if a symbol names a special form.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> symbol_name </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> SPECIAL_FORMS</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># src/evaluator/special_forms.py - Special form handler skeletons</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispValue, Environment, make_function, </span><span style=\"color:#79B8FF\">EMPTY_LIST</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> EvaluationError, ArityError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> handle_if</span><span style=\"color:#E1E4E8\">(args: List[LispValue], env: Environment) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Handle if special form: (if test consequent alternative)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Evaluates test expression, then evaluates either consequent or </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    alternative based on whether test is truthy.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check argument count (should be 2 or 3)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: if len(args) &#x3C; 2 or len(args) > 3: raise ArityError</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Evaluate test expression</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: test_result = evaluate(args[0], env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Choose and evaluate appropriate branch</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use is_truthy(test_result) to decide</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # If true, evaluate args[1]; if false, evaluate args[2] (or return false if no alternative)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> handle_define</span><span style=\"color:#E1E4E8\">(args: List[LispValue], env: Environment) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Handle define special form: (define symbol value)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Evaluates value expression and binds it to symbol in current environment.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check argument count (should be exactly 2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Verify first argument is a symbol</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Check args[0].type == LispValueType.SYMBOL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Evaluate the value expression</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: value = evaluate(args[1], env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create binding in current environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: env.define(args[0].value, value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return the bound value</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> handle_lambda</span><span style=\"color:#E1E4E8\">(args: List[LispValue], env: Environment) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Handle lambda special form: (lambda (param1 param2 ...) body)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Creates a function that captures the current environment as its closure.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check argument count (should be exactly 2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract and validate parameter list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: params = args[0], check that it's a list of symbols</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Extract body expression (not evaluated yet!)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: body = args[1]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Convert parameter list to list of strings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: param_names = [param.value for param in params.value]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create and return function object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: return make_function(param_names, body, env, None)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Special form dispatch table</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">SPECIAL_FORMS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"if\"</span><span style=\"color:#E1E4E8\">: handle_if,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"define\"</span><span style=\"color:#E1E4E8\">: handle_define,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"lambda\"</span><span style=\"color:#E1E4E8\">: handle_lambda,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Add more special forms as needed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints:</strong></p>\n<ul>\n<li><strong>Error Context</strong>: Use f-strings for detailed error messages that include the symbol name, expected vs actual types, and operation being performed</li>\n<li><strong>Type Checking</strong>: Use <code>isinstance()</code> sparingly - prefer the type predicates like <code>is_number()</code>, <code>is_symbol()</code> for consistency with the data model</li>\n<li><strong>Environment Threading</strong>: Always pass the environment explicitly rather than using global state - this makes the evaluator easier to test and debug</li>\n<li><strong>Function Dispatch</strong>: Use dictionary dispatch for both special forms and built-in functions rather than long if/elif chains for better performance and maintainability</li>\n<li><strong>Recursion Handling</strong>: Python has a default recursion limit of 1000 - consider using <code>sys.setrecursionlimit()</code> for deeply nested expressions or implement iterative evaluation for tail calls</li>\n</ul>\n<p><strong>Milestone Checkpoints:</strong></p>\n<p>After <strong>Milestone 2</strong> (Basic Evaluation), you should be able to:</p>\n<ul>\n<li>Run <code>python -m src.evaluator</code> and evaluate expressions like <code>(+ 1 2 3)</code> → <code>6</code></li>\n<li>Test conditionals: <code>(if (&lt; 2 3) 10 20)</code> → <code>10</code></li>\n<li>Verify error handling: <code>(+ 1 &quot;hello&quot;)</code> → <code>TypeError: + expects number, got string</code></li>\n</ul>\n<p>After <strong>Milestone 3</strong> (Variables and Functions), you should be able to:</p>\n<ul>\n<li>Define variables: <code>(define x 42)</code> then <code>x</code> → <code>42</code></li>\n<li>Create functions: <code>(define square (lambda (n) (* n n)))</code> then <code>(square 5)</code> → <code>25</code></li>\n<li>Test lexical scoping: nested function definitions should access variables from their definition environment</li>\n</ul>\n<p>After <strong>Milestone 4</strong> (List Operations &amp; Recursion), you should be able to:</p>\n<ul>\n<li>Test recursion: <code>(define factorial (lambda (n) (if (&lt; n 2) 1 (* n (factorial (- n 1))))))</code> then <code>(factorial 5)</code> → <code>120</code></li>\n<li>List operations: <code>(cons 1 (cons 2 ()))</code> → <code>(1 2)</code></li>\n<li>Verify tail call behavior doesn&#39;t crash on reasonable recursion depths</li>\n</ul>\n<p><img src=\"/api/project/lisp-interp/architecture-doc/asset?path=diagrams%2Fevaluation-flow.svg\" alt=\"Expression Evaluation Flow\"></p>\n<h2 id=\"environment-and-scope-management\">Environment and Scope Management</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3 (Variables and Functions) - environment and scope management enables lexical scoping for variables and functions, supporting define forms, lambda closures, and proper variable resolution</p>\n</blockquote>\n<p>Building variable scoping in a programming language is like constructing a sophisticated filing system where every function and code block gets its own filing cabinet, but these cabinets are nested inside each other. When you need to find a document (variable), you start with the innermost cabinet and work your way out through the parent cabinets until you find what you&#39;re looking for. This nested structure ensures that inner scopes can access variables from outer scopes, but outer scopes cannot see variables defined in inner scopes.</p>\n<p>The environment system is the interpreter&#39;s memory management mechanism for variable bindings. It determines which variables are visible at any point during program execution and how variable names resolve to their values. Unlike simple interpreters that might use a single global dictionary, our Lisp interpreter implements lexical scoping through a chain of environment objects, each containing local bindings and a reference to its parent environment.</p>\n<h3 id=\"mental-model-nested-filing-cabinets\">Mental Model: Nested Filing Cabinets</h3>\n<p>Think of environments as a series of filing cabinets arranged in a nested hierarchy, similar to how Russian nesting dolls fit inside each other. Each function call, let binding, or lambda definition creates a new filing cabinet (environment) that sits inside the current one. When you need to look up a variable, you start with the innermost cabinet and work your way outward through the parent cabinets until you find a folder with the variable&#39;s name.</p>\n<p>Consider this mental model in action: when you define a global variable, it goes into the outermost filing cabinet that everyone can access. When you define a function with parameters, those parameters get their own cabinet that sits inside the global one. If that function defines local variables or calls another function, those create even more nested cabinets. The key insight is that inner cabinets can always reach into outer cabinets to retrieve documents, but outer cabinets cannot access documents stored in inner cabinets.</p>\n<p>This filing cabinet analogy captures the essence of lexical scoping: variable visibility is determined by the nesting structure of your code, not by the order in which functions are called at runtime. A function defined inside another function can always access the outer function&#39;s variables, regardless of when or where the inner function is eventually called.</p>\n<p>The filing cabinet hierarchy also explains closure behavior. When you create a lambda function (closure), it&#39;s like making a photocopy of all the filing cabinet keys it currently has access to. Even if you take that function elsewhere and call it in a completely different context, it still has those keys and can access the original cabinets where its variables were defined.</p>\n<h3 id=\"lexical-scoping-rules\">Lexical Scoping Rules</h3>\n<p>Lexical scoping, also called static scoping, determines variable visibility based on where variables are defined in the source code structure, not where functions are called at runtime. This predictable scoping behavior is essential for writing maintainable programs and enabling powerful features like closures.</p>\n<p>The fundamental rule of lexical scoping is the <strong>innermost binding wins principle</strong>: when looking up a variable name, the interpreter searches from the innermost scope outward, returning the value from the first matching binding it encounters. This means that inner scopes can shadow (temporarily hide) variables from outer scopes by defining variables with the same name.</p>\n<p>Variable lookup follows a systematic search algorithm. The interpreter starts with the current environment and checks if the variable name exists in its bindings dictionary. If found, it returns that value immediately. If not found, it follows the parent reference to the next outer environment and repeats the search. This process continues until either the variable is found or the search reaches the global environment and finds no binding, resulting in a <code>NameError</code>.</p>\n<p>The scoping rules create several important behavioral guarantees. First, <strong>variable access is predictable</strong>: you can determine what variables a piece of code can access simply by examining the nested structure of function definitions and let bindings in the source text. Second, <strong>inner scopes see outer variables</strong>: any variable defined in an outer scope remains accessible to all inner scopes, unless shadowed by a local binding with the same name. Third, <strong>outer scopes cannot see inner variables</strong>: variables defined inside functions or let bindings are completely invisible to code outside those constructs.</p>\n<p>Consider this example scope chain: the global environment contains a binding for <code>x = 10</code>. A function <code>outer</code> defines a parameter <code>y = 20</code> and a local variable <code>z = 30</code>. Inside <code>outer</code>, another function <code>inner</code> defines a parameter <code>z = 40</code>. When code inside <code>inner</code> references these variables, the lookup behavior is: <code>z</code> resolves to <code>40</code> (innermost binding), <code>y</code> resolves to <code>20</code> (from <code>outer</code>&#39;s environment), and <code>x</code> resolves to <code>10</code> (from global environment). The original <code>z = 30</code> from <code>outer</code> is shadowed and inaccessible from within <code>inner</code>.</p>\n<p>Lexical scoping also determines the behavior of function definitions. When a lambda function is created, it captures a reference to the environment where it was defined, not where it&#39;s called. This means the function will always see the variables that were in scope at definition time, regardless of what environment it&#39;s called from later.</p>\n<blockquote>\n<p>The critical insight is that lexical scoping makes variable access predictable by tying it to code structure rather than execution flow. This predictability is essential for program reasoning and enables advanced features like closures and higher-order functions.</p>\n</blockquote>\n<p><strong>Decision: Lexical vs Dynamic Scoping</strong></p>\n<ul>\n<li><strong>Context</strong>: Programming languages can resolve variable names based on where they&#39;re defined (lexical) or where functions are called (dynamic)</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Lexical scoping with environment chains</li>\n<li>Dynamic scoping with call stack lookup</li>\n<li>Hybrid approach with explicit dynamic variables</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Pure lexical scoping with environment chains</li>\n<li><strong>Rationale</strong>: Lexical scoping provides predictable behavior, enables closures, aligns with modern language design, and makes programs easier to reason about. Dynamic scoping can create action-at-a-distance bugs where changing a variable name in one function unexpectedly affects distant functions.</li>\n<li><strong>Consequences</strong>: Functions capture their defining environment, enabling closures but requiring careful environment management. Variable lookup is O(depth) in nesting level but provides strong encapsulation guarantees.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Scoping Type</th>\n<th>Predictability</th>\n<th>Closure Support</th>\n<th>Performance</th>\n<th>Debugging</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Lexical</td>\n<td>High - determined by code structure</td>\n<td>Full support</td>\n<td>O(nesting depth) lookup</td>\n<td>Easy - scope visible in code</td>\n</tr>\n<tr>\n<td>Dynamic</td>\n<td>Low - depends on call stack</td>\n<td>Not possible</td>\n<td>O(call depth) lookup</td>\n<td>Hard - scope depends on execution</td>\n</tr>\n<tr>\n<td>Hybrid</td>\n<td>Medium - mix of both</td>\n<td>Partial support</td>\n<td>Variable overhead</td>\n<td>Medium - multiple lookup rules</td>\n</tr>\n</tbody></table>\n<h3 id=\"closure-environment-capture\">Closure Environment Capture</h3>\n<p>Closures are functions that capture and retain access to variables from their defining environment, even after that environment would normally be destroyed. This powerful feature enables functional programming patterns like partial application, callback functions with persistent state, and factory functions that generate specialized behavior.</p>\n<p>When a lambda expression is evaluated, the interpreter creates a <code>LispFunction</code> object that stores not just the parameter list and function body, but also a reference to the current environment. This captured environment, called the <strong>closure environment</strong>, preserves all variable bindings that were in scope when the lambda was defined. The closure environment forms a permanent link to the lexical context, ensuring the function can always access these variables regardless of when or where it&#39;s called.</p>\n<p>The environment capture mechanism works through <strong>environment sharing</strong> rather than copying. When a closure is created, it stores a reference to the actual environment object, not a copy of its bindings. This means multiple closures created in the same scope share the same environment object, and changes to mutable variables in that environment are visible to all closures. This sharing behavior is crucial for implementing features like counter functions or stateful callbacks.</p>\n<p>Closure environment capture creates a <strong>parent-child relationship</strong> between environments. When a closure is called, the interpreter creates a new environment for the function&#39;s parameters and local variables, with the closure&#39;s captured environment as the parent. This means the closure can access both its own parameters/locals and all variables from its defining scope, maintaining the full lexical scope chain.</p>\n<p>The lifetime implications of closures are significant. Normally, when a function returns, its environment can be garbage collected because no references remain. However, if the function created and returned a closure, that closure holds a reference to the function&#39;s environment, keeping it alive indefinitely. This can lead to memory leaks if not managed carefully, but it&#39;s essential for closure functionality.</p>\n<p>Consider a factory function that creates counter closures: each call to the factory creates a new environment containing a local counter variable, then returns a closure that increments and returns that counter. Even after the factory function returns, each closure retains access to its own counter variable through the captured environment. Multiple closures from the same factory call share the same environment and thus the same counter variable, while closures from different factory calls have independent counters.</p>\n<blockquote>\n<p>The fundamental principle of closure capture is that functions remember where they came from. A closure is not just code to execute, but code plus the complete lexical context where that code was born.</p>\n</blockquote>\n<p><strong>Decision: Environment Reference vs Environment Copying</strong></p>\n<ul>\n<li><strong>Context</strong>: When creating closures, we can either store a reference to the defining environment or copy all relevant bindings</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Store reference to actual environment object (sharing)</li>\n<li>Copy all accessible bindings into closure-specific environment</li>\n<li>Copy-on-write approach with shared immutable environments</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Store reference to actual environment object</li>\n<li><strong>Rationale</strong>: Reference sharing enables proper closure semantics where multiple closures can share mutable state, aligns with standard Lisp behavior, and avoids expensive copying. Copying would break expected closure behavior where closures can communicate through shared variables.</li>\n<li><strong>Consequences</strong>: Enables full closure functionality and shared mutable state, but requires careful memory management to avoid environment leaks. Multiple closures from the same scope can share and modify common variables.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Capture Strategy</th>\n<th>Memory Usage</th>\n<th>Shared State</th>\n<th>Implementation Complexity</th>\n<th>Standard Compliance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Reference Sharing</td>\n<td>Low - single environment</td>\n<td>Full sharing</td>\n<td>Low - direct references</td>\n<td>Standard behavior</td>\n</tr>\n<tr>\n<td>Environment Copying</td>\n<td>High - duplicate bindings</td>\n<td>No sharing</td>\n<td>Medium - selective copying</td>\n<td>Non-standard behavior</td>\n</tr>\n<tr>\n<td>Copy-on-Write</td>\n<td>Medium - shared until write</td>\n<td>Limited sharing</td>\n<td>High - complex bookkeeping</td>\n<td>Partial compliance</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-environment-pitfalls\">Common Environment Pitfalls</h3>\n<p>Environment and scoping management presents several subtle pitfalls that frequently trap developers implementing interpreters. These issues often arise from misunderstanding the relationship between lexical scoping, environment lifetime, and closure semantics.</p>\n<p>⚠️ <strong>Pitfall: Confusing Variable Shadowing with Variable Mutation</strong></p>\n<p>Many implementers incorrectly handle the difference between creating a new binding that shadows an outer variable versus modifying an existing variable&#39;s value. When you write <code>(define x 10)</code> in a local scope where <code>x</code> already exists in an outer scope, this creates a new binding in the current environment rather than modifying the outer binding. However, if the language supported variable mutation (which our minimal Lisp doesn&#39;t), updating an existing variable should modify the binding in the environment where it was originally defined, not create a new local binding.</p>\n<p>This confusion leads to implementations that either always create new bindings (breaking mutation semantics) or always modify existing bindings (breaking shadowing semantics). The correct behavior requires checking whether you&#39;re performing a definition (creates new binding in current environment) or an assignment (modifies existing binding in the environment where it&#39;s found).</p>\n<p>⚠️ <strong>Pitfall: Capturing Environments Too Late in Function Creation</strong></p>\n<p>A critical timing error occurs when implementations capture the environment for closures during function application rather than during function definition. This mistake leads to closures that see variables from their call site rather than their definition site, essentially implementing dynamic scoping instead of lexical scoping.</p>\n<p>The environment must be captured immediately when the lambda expression is evaluated, not when the resulting function is later called. The <code>handle_lambda</code> function must store a reference to the current environment in the <code>LispFunction</code> object at creation time. If environment capture is delayed until function application, the closure will see whatever environment happens to be active when it&#39;s called, breaking lexical scoping guarantees.</p>\n<p>⚠️ <strong>Pitfall: Creating Circular Environment References</strong></p>\n<p>Improper environment management can create circular references that prevent garbage collection and cause memory leaks. This typically happens when implementing recursive function definitions where the function name needs to be bound in the environment where the function body is evaluated.</p>\n<p>For example, when processing <code>(define factorial (lambda (n) (if (= n 0) 1 (* n (factorial (- n 1))))))</code>, the function needs to reference itself by name. If you bind <code>factorial</code> in the closure environment after creating the function, you create a circular reference: the environment references the function, and the function references the environment. The correct approach is to bind the function name in the same environment where the lambda is defined, before capturing that environment in the closure.</p>\n<p>⚠️ <strong>Pitfall: Incorrect Environment Chain Traversal</strong></p>\n<p>Environment lookup implementations often contain off-by-one errors or incorrect termination conditions that cause variables to be found in the wrong scope or not found when they should be accessible. Common mistakes include forgetting to check the current environment before moving to the parent, checking the parent before exhausting the current environment, or failing to handle the case where the parent environment is None.</p>\n<p>The correct lookup algorithm must check bindings in the current environment first, then recursively check parent environments until either the variable is found or there are no more parent environments. Failing to check the current environment, or checking environments in the wrong order, breaks the innermost-binding-wins rule of lexical scoping.</p>\n<p>⚠️ <strong>Pitfall: Environment Sharing vs Environment Inheritance Confusion</strong></p>\n<p>Many implementations confuse environment sharing (multiple references to the same environment object) with environment inheritance (parent-child relationships between different environment objects). This confusion leads to incorrect behavior when multiple closures should share state versus when they should have independent state.</p>\n<p>Environment sharing occurs when multiple closures are created in the same lexical scope - they should share the same closure environment and thus see modifications to common variables. Environment inheritance occurs during function application - the new environment for parameters and locals should have the closure environment as its parent, not share the closure environment directly. Mixing these concepts leads to either unwanted variable sharing or broken lexical access.</p>\n<p>⚠️ <strong>Pitfall: Forgetting to Handle Empty Environment Chains</strong></p>\n<p>Edge case handling often fails when the environment chain is empty or when lookups reach the end of the chain without finding a binding. Implementations may attempt to access the parent of the global environment (which should be None) or fail to properly signal name errors when variables are not found.</p>\n<p>Robust environment lookup must handle the case where the current environment is None (indicating the end of the chain) and raise an appropriate <code>NameError</code> with helpful diagnostic information. The global environment should have a parent of None, and lookup should check for this condition to avoid attempting to search beyond the global scope.</p>\n<table>\n<thead>\n<tr>\n<th>Pitfall Category</th>\n<th>Symptom</th>\n<th>Root Cause</th>\n<th>Detection Method</th>\n<th>Prevention Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Shadowing vs Mutation</td>\n<td>Variables not updating as expected</td>\n<td>Wrong environment for binding modification</td>\n<td>Test nested scopes with same names</td>\n<td>Always create new bindings for define</td>\n</tr>\n<tr>\n<td>Late Environment Capture</td>\n<td>Closures see call-site variables</td>\n<td>Capturing environment at call time</td>\n<td>Test closure accessing outer variables</td>\n<td>Capture environment at lambda creation</td>\n</tr>\n<tr>\n<td>Circular References</td>\n<td>Memory leaks, infinite recursion</td>\n<td>Function and environment reference cycles</td>\n<td>Memory profiling, recursion tests</td>\n<td>Careful recursive function binding</td>\n</tr>\n<tr>\n<td>Chain Traversal Errors</td>\n<td>Wrong variable values or name errors</td>\n<td>Incorrect lookup order or termination</td>\n<td>Test variable precedence in nested scopes</td>\n<td>Systematic current-then-parent search</td>\n</tr>\n<tr>\n<td>Sharing vs Inheritance</td>\n<td>Unexpected variable modifications</td>\n<td>Confusing reference sharing with parent links</td>\n<td>Test multiple closures from same scope</td>\n<td>Clear distinction between sharing and inheritance</td>\n</tr>\n<tr>\n<td>Empty Chain Handling</td>\n<td>Crashes on variable lookup</td>\n<td>Missing None checks in chain traversal</td>\n<td>Test undefined variable access</td>\n<td>Explicit None checks and proper error handling</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The environment system serves as the interpreter&#39;s variable management backbone, requiring careful attention to data structure design, lookup algorithms, and memory management. The implementation must balance simplicity with correctness while providing the foundation for advanced features like closures and recursive functions.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Environment Storage</td>\n<td>Python dict with parent reference</td>\n<td>Custom hash table with optimized lookup</td>\n</tr>\n<tr>\n<td>Variable Lookup</td>\n<td>Recursive parent traversal</td>\n<td>Iterative traversal with depth tracking</td>\n</tr>\n<tr>\n<td>Closure Capture</td>\n<td>Direct environment reference</td>\n<td>Weak references with explicit lifetime management</td>\n</tr>\n<tr>\n<td>Error Reporting</td>\n<td>Simple NameError with variable name</td>\n<td>Rich diagnostics with scope chain and suggestions</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Python garbage collection</td>\n<td>Manual reference counting with cycle detection</td>\n</tr>\n</tbody></table>\n<h4 id=\"module-structure\">Module Structure</h4>\n<p>The environment management functionality integrates closely with the evaluator while maintaining clear separation of concerns for variable resolution and scope management:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lisp_interpreter/\n  core/\n    environment.py           ← Environment class and scope management\n    values.py               ← LispValue types including functions\n    evaluator.py            ← Main evaluation logic using environments\n    errors.py               ← Environment-related error types\n  tests/\n    test_environment.py     ← Environment and scoping tests\n    test_closures.py        ← Closure capture and application tests\n    test_scoping.py         ← Lexical scoping behavior tests</code></pre></div>\n\n<h4 id=\"environment-infrastructure-complete-implementation\">Environment Infrastructure (Complete Implementation)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Complete environment implementation for lexical scoping and variable management.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">This provides the full infrastructure needed for variable binding, lookup, and</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">closure environment capture.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> core.values </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispValue</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> core.errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> NameError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Environment represents a single scope containing variable bindings.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Environments form a chain through parent references to implement lexical scoping.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bindings: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, LispValue]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parent: Optional[</span><span style=\"color:#9ECBFF\">'Environment'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> lookup</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Look up a variable name in this environment and parent environments.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Implements the innermost-binding-wins rule of lexical scoping.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            name: Variable name to look up</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            LispValue associated with the name</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            NameError: If name is not found in any environment in the chain</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> current_env </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> current_env.bindings:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> current_env.bindings[name]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_env.parent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Name not found in any environment in the chain</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> NameError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"undefined variable: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> define</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: LispValue) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create a new binding in this environment.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Always creates a new binding in the current environment, never modifies parent.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            name: Variable name to bind</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            value: LispValue to associate with the name</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.bindings[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> extend</span><span style=\"color:#E1E4E8\">(self, new_bindings: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, LispValue]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Environment'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create a new child environment with this environment as parent.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Used for function calls, let bindings, and other scope creation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            new_bindings: Optional initial bindings for the new environment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            New Environment with this environment as parent</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> new_bindings </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            new_bindings </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> Environment(</span><span style=\"color:#FFAB70\">bindings</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">new_bindings.copy(), </span><span style=\"color:#FFAB70\">parent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> depth</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Calculate the depth of this environment in the chain.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Useful for debugging and performance analysis.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Number of parent environments plus one</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.parent </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.parent.depth()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> all_names</span><span style=\"color:#E1E4E8\">(self) -> set[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Get all variable names visible from this environment.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Includes names from this environment and all parent environments.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Set of all accessible variable names</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        names </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.bindings.keys())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.parent </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            names.update(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.parent.all_names())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> names</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_global_environment</span><span style=\"color:#E1E4E8\">() -> Environment:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Create the global environment with built-in functions and constants.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This serves as the root of all environment chains.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Environment containing built-in bindings</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    from</span><span style=\"color:#E1E4E8\"> core.builtins </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> BUILTIN_FUNCTIONS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    from</span><span style=\"color:#E1E4E8\"> core.values </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> make_builtin, </span><span style=\"color:#79B8FF\">LISP_TRUE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">LISP_FALSE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    global_bindings </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Add built-in functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> name, (implementation, arity) </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> BUILTIN_FUNCTIONS</span><span style=\"color:#E1E4E8\">.items():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        global_bindings[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> make_builtin(implementation, name, arity)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Add built-in constants</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    global_bindings[</span><span style=\"color:#9ECBFF\">'true'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> LISP_TRUE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    global_bindings[</span><span style=\"color:#9ECBFF\">'false'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> LISP_FALSE</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    global_bindings[</span><span style=\"color:#9ECBFF\">'nil'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> EMPTY_LIST</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> Environment(</span><span style=\"color:#FFAB70\">bindings</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">global_bindings, </span><span style=\"color:#FFAB70\">parent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ScopeTracker</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Debug utility for tracking scope changes during evaluation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Helps diagnose environment and variable lookup issues.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.scope_stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.lookup_history </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> push_scope</span><span style=\"color:#E1E4E8\">(self, description: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, env: Environment):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record entering a new scope.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.scope_stack.append((description, env.depth()))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> pop_scope</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record leaving the current scope.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.scope_stack:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.scope_stack.pop()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> record_lookup</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, found_at_depth: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record a variable lookup attempt.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.scope_stack[</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">][</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.scope_stack </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.lookup_history.append((name, current_depth, found_at_depth))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> current_scope_description</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get description of current scope for error messages.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.scope_stack:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#9ECBFF\"> \"global scope\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \" -> \"</span><span style=\"color:#E1E4E8\">.join(desc </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> desc, _ </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.scope_stack)</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-for-environment-integration\">Core Logic Skeleton for Environment Integration</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> handle_lambda</span><span style=\"color:#E1E4E8\">(args: List[LispValue], env: Environment) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Create a lambda function (closure) that captures the current environment.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        args: [parameters, body] where parameters is a list of symbols</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        env: Current environment to capture for closure</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        LispFunction value representing the closure</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ArityError: If args doesn't contain exactly 2 elements</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        TypeError: If parameters is not a list of symbols</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate that args contains exactly 2 elements (parameters and body)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract parameters list and body expression from args</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate that parameters is a list of symbols (not numbers or other types)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Convert parameters from LispValue symbols to string names</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create LispFunction with parameters, body, and current environment as closure_env</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return the function as a LispValue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use is_list() and is_symbol() to validate parameter structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: The current environment (env) becomes the closure_env for the function</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> handle_define</span><span style=\"color:#E1E4E8\">(args: List[LispValue], env: Environment) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Define a variable in the current environment.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Supports both variable definition and function definition syntactic sugar.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        args: [name, value] or [(name, params...), body] for function sugar</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        env: Current environment to create binding in</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        The defined value</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ArityError: If args doesn't contain exactly 2 elements</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        TypeError: If name is not a symbol or parameter list is malformed</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate that args contains exactly 2 elements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check if first element is a symbol (variable definition) or list (function sugar)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For variable definition: extract name and evaluate value in current environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For function sugar: extract function name and parameters from first element</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: For function sugar: create lambda with parameters and body, then bind to name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Use env.define() to create binding in current environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return the value that was bound</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Function sugar (define (name params...) body) expands to (define name (lambda (params...) body))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Always evaluate the value expression before binding it</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> apply_function</span><span style=\"color:#E1E4E8\">(func: LispValue, args: List[LispValue], current_env: Environment) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Apply a function to arguments, creating new environment for execution.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        func: LispFunction or BuiltinFunction to apply</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        args: Evaluated arguments to pass to function</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        current_env: Current environment (may not be used for lexically scoped functions)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Result of function application</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        TypeError: If func is not a function</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ArityError: If argument count doesn't match function parameters</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if func is a BuiltinFunction - if so, call implementation directly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate that func is a LispFunction (user-defined function)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check that len(args) matches len(func.parameters) (arity checking)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create new environment extending func.closure_env (not current_env!)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Bind each parameter name to corresponding argument value in new environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If function has a name (recursive functions), bind name to func in new environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Evaluate function body in the new environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Return the evaluation result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use func.closure_env.extend() to create the new environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: The closure environment, not current_env, determines lexical scope</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints-for-python\">Language-Specific Hints for Python</h4>\n<p><strong>Environment Reference Management</strong>: Python&#39;s garbage collector handles circular references between environments and functions automatically, but be aware that long chains of environments can consume significant memory. Use weak references from the <code>weakref</code> module if you need to break cycles manually.</p>\n<p><strong>Dictionary Performance</strong>: Python dictionaries are highly optimized and provide O(1) average case lookup. For environments with many variables, this performs better than lists or arrays. Use <code>dict.get(name, None)</code> for safe lookups that return None instead of raising KeyError.</p>\n<p><strong>Exception Handling</strong>: Inherit from Python&#39;s built-in <code>NameError</code> for undefined variables to maintain consistency with Python&#39;s error hierarchy. Add custom attributes like <code>variable_name</code> and <code>scope_description</code> for better error messages.</p>\n<p><strong>Memory Debugging</strong>: Use <code>gc.get_objects()</code> and <code>sys.getsizeof()</code> to monitor environment memory usage during development. Large numbers of long-lived closures can create memory pressure through retained environment references.</p>\n<p><strong>Function Object Integration</strong>: Python&#39;s function objects provide good inspiration for closure design. Consider storing additional metadata like function name, source location, or documentation strings in your <code>LispFunction</code> objects for better debugging support.</p>\n<h4 id=\"milestone-checkpoint-environment-and-scoping\">Milestone Checkpoint: Environment and Scoping</h4>\n<p>After implementing the environment system, verify the following behaviors:</p>\n<p><strong>Variable Definition and Lookup</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test in your REPL or test suite</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_global_environment()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> evaluate(parse(</span><span style=\"color:#9ECBFF\">\"(define x 42)\"</span><span style=\"color:#E1E4E8\">), env)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> evaluate(parse(</span><span style=\"color:#9ECBFF\">\"x\"</span><span style=\"color:#E1E4E8\">), env) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> make_number(</span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Lexical Scoping with Shadowing</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">code </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">(define x 10)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">(define f (lambda (x) (+ x 1)))</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">(f 5)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should return 6, not 11 (inner x shadows outer x)</span></span></code></pre></div>\n\n<p><strong>Closure Environment Capture</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">code </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">(define make-counter (lambda (start)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  (lambda () (define start (+ start 1)) start)))</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">(define counter (make-counter 0))</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">(counter)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">(counter)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Should return 1, then 2 (closure captures and modifies start)</span></span></code></pre></div>\n\n<p><strong>Expected Error Behaviors</strong>:</p>\n<ul>\n<li>Referencing undefined variables should raise <code>NameError</code></li>\n<li>Function calls with wrong argument count should raise <code>ArityError</code></li>\n<li>Defining variables in inner scopes should not affect outer scopes</li>\n</ul>\n<p><strong>Performance Expectations</strong>:</p>\n<ul>\n<li>Variable lookup should be fast for reasonable nesting depths (&lt; 10 levels)</li>\n<li>Creating many closures should not cause obvious memory leaks</li>\n<li>Environment chains should not grow excessively during recursive function calls</li>\n</ul>\n<p>If any of these behaviors fail, check:</p>\n<ol>\n<li>Environment capture timing in lambda creation</li>\n<li>Parent-child relationships in environment chains</li>\n<li>Binding creation vs binding modification logic</li>\n<li>Proper scope extension during function application</li>\n</ol>\n<h2 id=\"function-system-design\">Function System Design</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3 (Variables and Functions) - this section implements lambda functions, closures, and function application with proper argument binding to support first-class functions</p>\n</blockquote>\n<h3 id=\"mental-model-customizable-machines\">Mental Model: Customizable Machines</h3>\n<p>Think of functions in Lisp as <strong>customizable machines</strong> that can be configured once and then reused many times. Just like a factory machine that can be set up with different dies to produce various shapes, a lambda function is a template that can be &quot;stamped&quot; with different arguments to produce different results.</p>\n<p>When you create a lambda function with <code>(lambda (x y) (+ x y))</code>, you&#39;re building a machine blueprint that says &quot;I have two input slots labeled x and y, and when you feed me values for those slots, I&#39;ll add them together and give you the result.&quot; The machine remembers not just its internal blueprint (the parameter list and body), but also the <strong>environment where it was built</strong> - like a machine that remembers which factory it came from and can access that factory&#39;s shared tools and resources.</p>\n<p>This mental model helps explain three critical aspects of functions: <strong>configuration</strong> (parameter binding), <strong>reusability</strong> (the same function can be called multiple times), and <strong>context retention</strong> (closures capture their defining environment). Unlike simple arithmetic operations that work the same way everywhere, these customizable machines carry their birthplace with them, enabling sophisticated programming patterns like closures and higher-order functions.</p>\n<p>The factory analogy extends to function application: when you call <code>(my-function 5 3)</code>, you&#39;re feeding raw materials (arguments 5 and 3) into your configured machine (my-function), which processes them according to its internal blueprint and produces a finished product (the result 8). The machine can be used over and over with different raw materials, always following the same process but producing different outputs.</p>\n<h3 id=\"lambda-function-creation\">Lambda Function Creation</h3>\n<p>Lambda functions in Lisp represent the transition from a purely arithmetic calculator to a programming language capable of abstraction and code reuse. The <code>lambda</code> special form creates <strong>first-class function values</strong> that can be stored in variables, passed as arguments, and returned from other functions, embodying the principle that functions are data.</p>\n<p>The syntax <code>(lambda (param1 param2 ...) body-expression)</code> defines three essential components: the <strong>parameter list</strong> specifying the function&#39;s inputs, the <strong>body expression</strong> defining the computation to perform, and implicitly, the <strong>lexical environment</strong> where the lambda is evaluated. Unlike mathematical functions that exist in abstract isolation, Lisp lambda functions are <strong>closures</strong> that capture and retain access to variables from their defining scope.</p>\n<blockquote>\n<p><strong>Decision: Closure Environment Capture</strong></p>\n<ul>\n<li><strong>Context</strong>: Lambda functions need access to variables from their defining scope, but the stack frame where they&#39;re defined may no longer exist when they&#39;re called</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Dynamic scoping - look up variables in the calling environment</li>\n<li>Lexical scoping with environment capture - store defining environment in function object</li>\n<li>Static scoping with variable copying - copy all accessible variables into function</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Lexical scoping with environment capture</li>\n<li><strong>Rationale</strong>: Provides predictable behavior where function meaning depends only on where it&#39;s defined, not where it&#39;s called. Environment references are more memory-efficient than copying all variables.</li>\n<li><strong>Consequences</strong>: Enables powerful closure patterns but requires garbage collection of captured environments. Functions become heavier objects carrying environment references.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Closure Approach</th>\n<th>Memory Usage</th>\n<th>Predictability</th>\n<th>Implementation Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Dynamic Scoping</td>\n<td>Low</td>\n<td>Low (depends on call site)</td>\n<td>Simple</td>\n</tr>\n<tr>\n<td>Environment Capture</td>\n<td>Medium</td>\n<td>High (depends only on definition)</td>\n<td>Moderate</td>\n</tr>\n<tr>\n<td>Variable Copying</td>\n<td>High</td>\n<td>High</td>\n<td>Simple</td>\n</tr>\n</tbody></table>\n<p>The lambda creation process involves several critical steps that transform source code into a callable function object. First, the parameter list is <strong>validated and stored</strong> as a list of symbol names that will become local variable bindings during function calls. The parameter validation ensures no duplicate names exist and that all parameters are valid symbols, preventing runtime confusion about argument binding.</p>\n<p>Second, the body expression is <strong>stored without evaluation</strong> - this is crucial because the body should only be evaluated when the function is called, not when it&#39;s defined. The body remains as an abstract syntax tree that will be evaluated later in the context of the function call&#39;s environment. This delayed evaluation enables recursion and forward references that wouldn&#39;t be possible if the body were evaluated immediately.</p>\n<p>Third, and most importantly, the lambda creation captures a <strong>reference to the current environment</strong> where the lambda form is being evaluated. This captured environment becomes the function&#39;s &quot;closure environment&quot; that provides access to variables from the defining scope. The environment capture is a shallow copy of the environment reference, not a deep copy of all variables, allowing multiple closures to share the same environment efficiently.</p>\n<table>\n<thead>\n<tr>\n<th>Lambda Creation Step</th>\n<th>Purpose</th>\n<th>Error Conditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Parameter Validation</td>\n<td>Ensure valid symbol names, no duplicates</td>\n<td><code>TypeError</code> if non-symbol parameters, <code>ArityError</code> if duplicates</td>\n</tr>\n<tr>\n<td>Body Storage</td>\n<td>Preserve unevaluated expression for later</td>\n<td><code>ParseError</code> if body missing</td>\n</tr>\n<tr>\n<td>Environment Capture</td>\n<td>Enable lexical scoping and closure behavior</td>\n<td>Never fails - always captures current environment</td>\n</tr>\n<tr>\n<td>Function Object Creation</td>\n<td>Package components into callable value</td>\n<td>Memory allocation failure only</td>\n</tr>\n</tbody></table>\n<p>Consider the creation of a closure that demonstrates environment capture:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lisp</span><pre class=\"arch-pre shiki-highlighted\"><code>(define make-counter\n  (lambda (start)\n    (lambda ()\n      (define start (+ start 1))\n      start)))\n\n(define counter (make-counter 10))</code></pre></div>\n\n<p>When <code>make-counter</code> is called with argument 10, it creates a new environment where <code>start</code> is bound to 10. The inner lambda <code>(lambda () ...)</code> captures this environment, creating a closure that retains access to the <code>start</code> variable even after <code>make-counter</code> returns. Each call to the returned counter function will access and modify the same <code>start</code> variable, demonstrating how closures maintain persistent state.</p>\n<p>The <code>LispFunction</code> data structure encapsulates all the information needed for later function application:</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>parameters</code></td>\n<td><code>List[str]</code></td>\n<td>Parameter names for argument binding</td>\n</tr>\n<tr>\n<td><code>body</code></td>\n<td><code>LispValue</code></td>\n<td>Unevaluated expression to execute when called</td>\n</tr>\n<tr>\n<td><code>closure_env</code></td>\n<td><code>Environment</code></td>\n<td>Captured environment providing lexical scope</td>\n</tr>\n<tr>\n<td><code>name</code></td>\n<td><code>Optional[str]</code></td>\n<td>Function name for debugging and recursion</td>\n</tr>\n</tbody></table>\n<p>The optional <code>name</code> field supports both anonymous and named functions. Anonymous functions created by lambda expressions have <code>name</code> set to <code>None</code>, while functions created by <code>define</code> forms store the defined name. This name is crucial for recursive functions, allowing them to reference themselves by name within their body.</p>\n<h3 id=\"function-application-process\">Function Application Process</h3>\n<p>Function application transforms a function call like <code>(my-function arg1 arg2)</code> into a result value through a carefully orchestrated sequence of steps that maintain proper lexical scoping and argument binding. The application process bridges the gap between abstract function definitions and concrete computation, handling the complex interaction between the caller&#39;s environment, the function&#39;s closure environment, and the new environment created for the function execution.</p>\n<p>The application process begins with <strong>argument evaluation</strong> in the caller&#39;s current environment. Unlike special forms that control which arguments get evaluated, function calls follow the standard Lisp evaluation rule of evaluating all arguments before passing them to the function. This eager evaluation strategy ensures that by the time the function body executes, all arguments have been reduced to their final values.</p>\n<blockquote>\n<p><strong>Decision: Eager Argument Evaluation</strong></p>\n<ul>\n<li><strong>Context</strong>: Function arguments could be evaluated before or during function execution, affecting both semantics and implementation complexity</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Eager evaluation - evaluate all arguments in caller&#39;s environment before function call</li>\n<li>Lazy evaluation - pass unevaluated arguments and evaluate them when accessed</li>\n<li>Call-by-need - evaluate arguments on first access and cache results</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Eager argument evaluation</li>\n<li><strong>Rationale</strong>: Provides predictable semantics, simplifies function implementation, and matches standard Lisp behavior. Arguments are evaluated in the caller&#39;s scope where they have clear meaning.</li>\n<li><strong>Consequences</strong>: Enables straightforward function calls but prevents some advanced patterns like delayed computation. All argument side effects occur before function body execution.</li>\n</ul>\n</blockquote>\n<p>After arguments are evaluated, the system performs <strong>arity checking</strong> to ensure the number of provided arguments matches the function&#39;s parameter count. This validation prevents runtime errors that would occur from unbound parameters or ignored arguments, providing early feedback about incorrect function calls.</p>\n<table>\n<thead>\n<tr>\n<th>Arity Mismatch Type</th>\n<th>Detection</th>\n<th>Error Type</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Too Few Arguments</td>\n<td><code>len(args) &lt; len(parameters)</code></td>\n<td><code>ArityError</code></td>\n<td><code>((lambda (x y) (+ x y)) 5)</code> missing y</td>\n</tr>\n<tr>\n<td>Too Many Arguments</td>\n<td><code>len(args) &gt; len(parameters)</code></td>\n<td><code>ArityError</code></td>\n<td><code>((lambda (x) x) 1 2 3)</code> extra args 2,3</td>\n</tr>\n<tr>\n<td>Correct Arity</td>\n<td><code>len(args) == len(parameters)</code></td>\n<td>No error</td>\n<td><code>((lambda (x y) (+ x y)) 5 3)</code></td>\n</tr>\n</tbody></table>\n<p>The core of function application is <strong>environment extension and parameter binding</strong>. The system creates a new environment that extends the function&#39;s closure environment (not the caller&#39;s environment), establishing the lexical scoping chain. Into this new environment, it binds each parameter name to its corresponding argument value, creating the local variable context for function execution.</p>\n<p>The environment extension process follows this sequence:</p>\n<ol>\n<li><strong>Start with closure environment</strong>: Use the function&#39;s <code>closure_env</code> as the parent environment, ensuring access to variables from the function&#39;s defining scope</li>\n<li><strong>Create extended environment</strong>: Call <code>closure_env.extend()</code> to create a child environment with the closure as parent</li>\n<li><strong>Bind parameters to arguments</strong>: For each parameter-argument pair, call <code>extended_env.define(param_name, arg_value)</code> to create local bindings</li>\n<li><strong>Handle recursive functions</strong>: If the function has a name, bind that name to the function itself in the extended environment, enabling self-reference</li>\n</ol>\n<p>This environment structure ensures that variable lookups follow the proper precedence order: local parameters first, then closure-captured variables, then global bindings. The recursive function binding is particularly important - it allows functions to call themselves by name without requiring special syntax or forward declarations.</p>\n<p>Consider the environment chain during this recursive factorial call:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lisp</span><pre class=\"arch-pre shiki-highlighted\"><code>(define factorial\n  (lambda (n)\n    (if (&lt;= n 1)\n        1\n        (* n (factorial (- n 1))))))\n\n(factorial 3)</code></pre></div>\n\n<p>When <code>factorial</code> is called with argument 3, the environment chain looks like:</p>\n<ul>\n<li><strong>Local environment</strong>: <code>n -&gt; 3, factorial -&gt; &lt;function-object&gt;</code></li>\n<li><strong>Closure environment</strong>: <code>factorial -&gt; &lt;function-object&gt;</code> (from global define)</li>\n<li><strong>Global environment</strong>: built-in functions like <code>*</code>, <code>-</code>, <code>&lt;=</code></li>\n</ul>\n<p>The final step is <strong>body evaluation</strong> in the extended environment. The function&#39;s body expression is evaluated using the newly created environment, giving it access to the parameter bindings and closure variables. The result of this evaluation becomes the return value of the function call.</p>\n<table>\n<thead>\n<tr>\n<th>Application Step</th>\n<th>Purpose</th>\n<th>Environment Used</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Argument Evaluation</td>\n<td>Convert argument expressions to values</td>\n<td>Caller&#39;s current environment</td>\n</tr>\n<tr>\n<td>Arity Checking</td>\n<td>Validate argument count matches parameters</td>\n<td>N/A (pure validation)</td>\n</tr>\n<tr>\n<td>Environment Extension</td>\n<td>Create local scope for function execution</td>\n<td>Function&#39;s closure environment as parent</td>\n</tr>\n<tr>\n<td>Parameter Binding</td>\n<td>Bind parameter names to argument values</td>\n<td>Extended environment</td>\n</tr>\n<tr>\n<td>Body Evaluation</td>\n<td>Execute function logic and compute result</td>\n<td>Extended environment</td>\n</tr>\n</tbody></table>\n<p>The complete function application signature follows this pattern:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>apply_function(func: LispFunction, args: List[LispValue], current_env: Environment) -&gt; LispValue</code></pre></div>\n\n<p>The <code>current_env</code> parameter represents the caller&#39;s environment and is used only for argument evaluation. The actual function execution uses the environment chain built from the function&#39;s closure environment, maintaining proper lexical scoping semantics.</p>\n<h3 id=\"common-function-pitfalls\">Common Function Pitfalls</h3>\n<p>Function implementation presents several subtle challenges that frequently trip up developers new to interpreter design. These pitfalls arise from the complex interaction between evaluation order, environment management, and the distinction between function definition and function application.</p>\n<p>⚠️ <strong>Pitfall: Evaluating Function Body During Lambda Creation</strong></p>\n<p>A common mistake is evaluating the lambda body expression when the lambda form is processed, rather than storing it for later evaluation during function calls. This premature evaluation breaks recursion, prevents forward references, and can cause undefined variable errors.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lisp</span><pre class=\"arch-pre shiki-highlighted\"><code>; This should work but fails with premature evaluation:\n(define factorial\n  (lambda (n)\n    (if (&lt;= n 1)\n        1\n        (* n (factorial (- n 1)))))) ; ERROR: factorial not yet defined</code></pre></div>\n\n<p>The problem occurs because if the body is evaluated during lambda creation, the recursive call to <code>factorial</code> happens before the <code>define</code> has completed binding the name <code>factorial</code> to the function. The fix is to store the body as an unevaluated AST node and only evaluate it when the function is actually called.</p>\n<p><strong>Detection</strong>: Function definition fails with &quot;undefined variable&quot; errors for recursive calls, or functions that reference variables not available at definition time fail unexpectedly.</p>\n<p><strong>Fix</strong>: Store the body expression as a <code>LispValue</code> without evaluating it. Only evaluate the body during <code>apply_function</code> in the function call&#39;s environment.</p>\n<p>⚠️ <strong>Pitfall: Wrong Environment for Argument Evaluation</strong></p>\n<p>Another frequent error is evaluating function arguments in the function&#39;s closure environment instead of the caller&#39;s current environment. This violates lexical scoping because arguments should be evaluated in the context where the function call appears, not where the function was defined.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lisp</span><pre class=\"arch-pre shiki-highlighted\"><code>(define x 10)\n(define f (lambda (y) (+ x y)))\n(define x 20)\n(f x) ; Should be 30 (20 + 10), not 40 (20 + 20)</code></pre></div>\n\n<p>If arguments are evaluated in the function&#39;s environment, the argument <code>x</code> would be looked up in the closure environment where <code>x</code> is 10, yielding the wrong result. The correct behavior evaluates <code>x</code> in the caller&#39;s environment where <code>x</code> is 20.</p>\n<p><strong>Detection</strong>: Function calls produce unexpected results when argument expressions contain variables that have different values in the caller vs function definition contexts.</p>\n<p><strong>Fix</strong>: Always evaluate arguments using the <code>current_env</code> parameter passed to <code>apply_function</code>, which represents the caller&#39;s environment. Only use the closure environment for the function body evaluation.</p>\n<p>⚠️ <strong>Pitfall: Incorrect Parameter Binding Environment</strong></p>\n<p>A subtle mistake is binding parameters in the caller&#39;s environment or the closure environment directly, rather than creating a new extended environment. This can cause variable name conflicts or make parameters visible where they shouldn&#39;t be.</p>\n<p>The wrong approach might extend the caller&#39;s environment:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lisp</span><pre class=\"arch-pre shiki-highlighted\"><code>(define x 5)\n(define f (lambda (x) (* x 2)))\n(f 10)\n; If parameters bind in caller's environment, global x becomes 10!</code></pre></div>\n\n<p><strong>Detection</strong>: Function calls modify global variables unexpectedly, or parameter names conflict with existing bindings in confusing ways.</p>\n<p><strong>Fix</strong>: Always create a new environment that extends the closure environment: <code>extended_env = func.closure_env.extend()</code>. Bind parameters in this new environment, keeping them isolated from both the caller and the closure.</p>\n<p>⚠️ <strong>Pitfall: Missing Recursive Function Binding</strong></p>\n<p>For recursive functions, forgetting to bind the function name to itself in the function&#39;s execution environment prevents self-reference and causes &quot;undefined variable&quot; errors during recursive calls.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lisp</span><pre class=\"arch-pre shiki-highlighted\"><code>(define countdown\n  (lambda (n)\n    (if (&lt;= n 0)\n        &quot;done&quot;\n        (countdown (- n 1))))) ; ERROR: countdown undefined in function body</code></pre></div>\n\n<p><strong>Detection</strong>: Recursive functions fail with &quot;undefined variable&quot; errors when they try to call themselves by name.</p>\n<p><strong>Fix</strong>: When applying a named function (one with <code>func.name</code> not <code>None</code>), bind the function name to the function object itself in the extended environment: <code>extended_env.define(func.name, func)</code>.</p>\n<p>⚠️ <strong>Pitfall: Arity Checking After Environment Creation</strong></p>\n<p>Performing arity validation after creating the function&#39;s environment wastes computational resources and can leave partially constructed environments in inconsistent states if the validation fails.</p>\n<p><strong>Detection</strong>: Performance issues with functions that have arity mismatches, or debugger shows environment creation before arity errors.</p>\n<p><strong>Fix</strong>: Check arity immediately after argument evaluation, before any environment manipulation: <code>if len(args) != len(func.parameters): raise ArityError(...)</code>.</p>\n<p>⚠️ <strong>Pitfall: Shallow vs Deep Environment Capture</strong></p>\n<p>Misunderstanding whether closure environment capture should be a shallow reference or a deep copy leads to either incorrect sharing of environment modifications or excessive memory usage.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lisp</span><pre class=\"arch-pre shiki-highlighted\"><code>(define make-incrementer\n  (lambda (start)\n    (lambda () (define start (+ start 1)) start)))\n\n(define inc1 (make-incrementer 0))\n(define inc2 (make-incrementer 0))\n(inc1) ; Should be 1\n(inc2) ; Should be 1, not 2!</code></pre></div>\n\n<p><strong>Detection</strong>: Multiple closures created from the same function interfere with each other&#39;s variables, or excessive memory usage from deep copying environments.</p>\n<p><strong>Fix</strong>: Capture environment references (shallow copy) but ensure each function call gets its own extended environment for parameter binding. The closure environments can be shared, but the execution environments must be isolated.</p>\n<table>\n<thead>\n<tr>\n<th>Pitfall</th>\n<th>Symptom</th>\n<th>Root Cause</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Premature Body Evaluation</td>\n<td>Recursion fails, forward references break</td>\n<td>Body evaluated at lambda creation time</td>\n<td>Store body as unevaluated AST</td>\n</tr>\n<tr>\n<td>Wrong Argument Environment</td>\n<td>Unexpected variable values in arguments</td>\n<td>Arguments evaluated in closure environment</td>\n<td>Use caller&#39;s environment for arguments</td>\n</tr>\n<tr>\n<td>Incorrect Parameter Binding</td>\n<td>Global variable modification, name conflicts</td>\n<td>Parameters bound in wrong environment</td>\n<td>Create new extended environment</td>\n</tr>\n<tr>\n<td>Missing Recursive Binding</td>\n<td>&quot;Undefined variable&quot; in recursive calls</td>\n<td>Function name not bound in execution environment</td>\n<td>Bind function name to self if present</td>\n</tr>\n<tr>\n<td>Late Arity Checking</td>\n<td>Performance issues, inconsistent state</td>\n<td>Validation after environment creation</td>\n<td>Check arity before environment work</td>\n</tr>\n<tr>\n<td>Environment Capture Confusion</td>\n<td>Variable interference or memory bloat</td>\n<td>Wrong sharing/copying strategy</td>\n<td>Shallow capture with isolated execution</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The function system implementation bridges the gap between the abstract concept of lambda expressions and the concrete mechanics of creating, storing, and applying first-class function values. This implementation requires careful coordination between the evaluator&#39;s special form handling and the environment system&#39;s scoping mechanisms.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Function Representation</td>\n<td>Named tuple with fields</td>\n<td>Full class with methods</td>\n</tr>\n<tr>\n<td>Environment Capture</td>\n<td>Direct reference storage</td>\n<td>Weak references with GC integration</td>\n</tr>\n<tr>\n<td>Parameter Binding</td>\n<td>Dictionary-based environment</td>\n<td>Optimized slot-based binding</td>\n</tr>\n<tr>\n<td>Recursion Support</td>\n<td>Name binding in environment</td>\n<td>Trampolined execution</td>\n</tr>\n<tr>\n<td>Closure Storage</td>\n<td>Environment reference</td>\n<td>Captured variable analysis</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-filemodule-structure\">Recommended File/Module Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lisp_interpreter/\n  core/\n    evaluator.py              ← main evaluation logic\n    environment.py            ← environment and scope management\n    functions.py              ← function system (this component)\n    special_forms.py          ← lambda, define, if handling\n  data/\n    values.py                 ← LispValue, LispFunction types\n    errors.py                 ← function-specific errors\n  tests/\n    test_functions.py         ← function system tests\n    test_closures.py          ← closure behavior tests\n    test_recursion.py         ← recursive function tests</code></pre></div>\n\n<h4 id=\"core-function-types-complete-infrastructure\">Core Function Types (Complete Infrastructure)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Any, Callable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispValueType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NUMBER</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"number\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SYMBOL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"symbol\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LIST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"list\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FUNCTION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"function\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BUILTIN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"builtin\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispValue</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value: Any</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    type</span><span style=\"color:#E1E4E8\">: LispValueType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __repr__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LispValueType.</span><span style=\"color:#79B8FF\">FUNCTION</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            func </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            params </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> ' '</span><span style=\"color:#E1E4E8\">.join(func.parameters)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> func.name </span><span style=\"color:#F97583\">or</span><span style=\"color:#9ECBFF\"> \"anonymous\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"&#x3C;function </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">(</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">params</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)>\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"&#x3C;</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.type.value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">>\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispFunction</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parameters: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    body: LispValue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    closure_env: </span><span style=\"color:#9ECBFF\">'Environment'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Validate parameters are unique symbols</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">set</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.parameters)) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.parameters):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Duplicate parameter names in function definition\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> param </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.parameters:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(param, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">or</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> param:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Parameter must be non-empty string, got </span><span style=\"color:#79B8FF\">{type</span><span style=\"color:#E1E4E8\">(param)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BuiltinFunction</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    implementation: Callable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    arity: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # None means variable arity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __call__</span><span style=\"color:#E1E4E8\">(self, args: List[LispValue]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.arity </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#F97583\"> and</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(args) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.arity:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> ArityError(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.arity, </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(args), </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.name)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.implementation(args)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArityError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, expected: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, actual: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, function_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expected </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expected</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.actual </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.function_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> function_name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Function </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">function_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> expects </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> arguments, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">actual</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Value constructors for type safety</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_function</span><span style=\"color:#E1E4E8\">(parameters: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], body: LispValue, closure_env: </span><span style=\"color:#9ECBFF\">'Environment'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a user-defined function value.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    func </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LispFunction(parameters, body, closure_env, name)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> LispValue(func, LispValueType.</span><span style=\"color:#79B8FF\">FUNCTION</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_builtin</span><span style=\"color:#E1E4E8\">(implementation: Callable, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, arity: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a built-in function value.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    builtin </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BuiltinFunction(implementation, name, arity)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> LispValue(builtin, LispValueType.</span><span style=\"color:#79B8FF\">BUILTIN</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_function</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if value is a callable function (user-defined or builtin).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value.type </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> (LispValueType.</span><span style=\"color:#79B8FF\">FUNCTION</span><span style=\"color:#E1E4E8\">, LispValueType.</span><span style=\"color:#79B8FF\">BUILTIN</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_user_function</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if value is specifically a user-defined function.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LispValueType.</span><span style=\"color:#79B8FF\">FUNCTION</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_builtin_function</span><span style=\"color:#E1E4E8\">(value: LispValue) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if value is specifically a built-in function.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> value.type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> LispValueType.</span><span style=\"color:#79B8FF\">BUILTIN</span></span></code></pre></div>\n\n<h4 id=\"lambda-special-form-handler-core-logic-skeleton\">Lambda Special Form Handler (Core Logic Skeleton)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> handle_lambda</span><span style=\"color:#E1E4E8\">(args: List[LispValue], env: </span><span style=\"color:#9ECBFF\">'Environment'</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Process lambda special form: (lambda (param1 param2 ...) body-expr)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Creates a closure capturing the current environment.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        args: [parameter-list, body-expression] from lambda form</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        env: Current environment where lambda is being evaluated</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        LispValue containing LispFunction with captured environment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        TypeError: Invalid parameter list or missing body</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ArityError: Wrong number of arguments to lambda form</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate lambda form has exactly 2 arguments (parameter list + body)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: lambda special form syntax is (lambda (params...) body)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract and validate parameter list from first argument</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Parameter list should be a LIST type containing only SYMBOL values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Must check: args[0].type == LispValueType.LIST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Must validate each element is a symbol</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Extract parameter names as list of strings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Convert each symbol LispValue to its string representation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Handle empty parameter list: (lambda () body)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Extract body expression from second argument</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Body is already a parsed LispValue, store without evaluating</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Critical: Do NOT evaluate body here - save for function application</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create LispFunction with captured environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use make_function(param_names, body, env, name=None)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # The 'env' parameter becomes the closure_env</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return the function as a LispValue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: make_function already returns proper LispValue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span><span style=\"color:#6A737D\">  # Replace with implementation</span></span></code></pre></div>\n\n<h4 id=\"function-application-logic-core-logic-skeleton\">Function Application Logic (Core Logic Skeleton)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> apply_function</span><span style=\"color:#E1E4E8\">(func: LispValue, args: List[LispValue], current_env: </span><span style=\"color:#9ECBFF\">'Environment'</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Apply a function to its arguments with proper scoping.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        func: Function to call (user-defined or builtin)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        args: Already-evaluated argument values</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        current_env: Environment where function call appears (for debugging only)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Result of function execution</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        TypeError: func is not callable</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ArityError: Wrong number of arguments</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        EvaluationError: Error during function body evaluation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate func is callable (user function or builtin)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use is_function(func) to check both types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle builtin functions separately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: if is_builtin_function(func): return func.value(args)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Builtin functions handle their own arity checking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Extract LispFunction from user-defined function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: lisp_func = func.value  # gets the LispFunction object</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Perform arity checking for user-defined function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: if len(args) != len(lisp_func.parameters): raise ArityError(...)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Use ArityError(expected, actual, function_name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create extended environment for function execution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: execution_env = lisp_func.closure_env.extend()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # This creates child of closure environment, not current_env!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Bind parameters to argument values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: for param_name, arg_value in zip(lisp_func.parameters, args):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #           execution_env.define(param_name, arg_value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Handle recursive function binding if function has name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: if lisp_func.name is not None:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #           execution_env.define(lisp_func.name, func)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Evaluate function body in execution environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: from .evaluator import evaluate  # avoid circular import</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    #       return evaluate(lisp_func.body, execution_env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span><span style=\"color:#6A737D\">  # Replace with implementation</span></span></code></pre></div>\n\n<h4 id=\"integration-with-evaluator-complete-infrastructure\">Integration with Evaluator (Complete Infrastructure)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Add to evaluator.py special forms registry</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">SPECIAL_FORMS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'if'</span><span style=\"color:#E1E4E8\">: handle_if,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'define'</span><span style=\"color:#E1E4E8\">: handle_define,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'lambda'</span><span style=\"color:#E1E4E8\">: handle_lambda,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'quote'</span><span style=\"color:#E1E4E8\">: handle_quote,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> evaluate_list</span><span style=\"color:#E1E4E8\">(expr: LispValue, env: Environment) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Evaluate list expression - either special form or function call.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> expr.value:  </span><span style=\"color:#6A737D\"># Empty list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> expr</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    elements </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expr.value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    first_element </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> elements[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Check for special forms</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> (is_symbol(first_element) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        first_element.value </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> SPECIAL_FORMS</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        handler </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> SPECIAL_FORMS</span><span style=\"color:#E1E4E8\">[first_element.value]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> handler(elements[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:], env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Regular function call</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    func </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> evaluate(first_element, env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    args </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [evaluate(arg, env) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> arg </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> elements[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:]]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> apply_function(func, args, env)</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint-function-system\">Milestone Checkpoint: Function System</h4>\n<p>After implementing the function system, verify these behaviors work correctly:</p>\n<p><strong>Test 1: Basic Lambda Creation and Application</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test command</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">python </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">c </span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> lisp_interpreter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> evaluate_string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> evaluate_string(</span><span style=\"color:#9ECBFF\">'((lambda (x) (* x 2)) 5)'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> result.value </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 10</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'✓ Basic lambda works'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p><strong>Test 2: Closure Environment Capture</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test command  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">python </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">c </span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> lisp_interpreter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> evaluate_string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">code </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '''</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">(define x 10)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">(define f (lambda (y) (+ x y)))</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">(define x 20)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">(f 5)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">'''</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> evaluate_string(code)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> result.value </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 15</span><span style=\"color:#6A737D\">  # Uses captured x=10, not current x=20</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'✓ Closure capture works'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p><strong>Test 3: Recursive Function</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test command</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">python </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\">c </span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> lisp_interpreter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> evaluate_string  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">code </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '''</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">(define factorial </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">  (lambda (n)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    (if (&#x3C;= n 1)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        1</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        (* n (factorial (- n 1))))))</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">(factorial 5)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">'''</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> evaluate_string(code)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> result.value </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 120</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'✓ Recursion works'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p><strong>Expected Behaviors:</strong></p>\n<ul>\n<li>Lambda expressions create function values without evaluation errors</li>\n<li>Function calls bind arguments to parameters in isolated environments  </li>\n<li>Closures access variables from their definition scope, not call scope</li>\n<li>Recursive functions can reference themselves by name</li>\n<li>Arity mismatches produce clear error messages with function names</li>\n</ul>\n<p><strong>Common Issues and Fixes:</strong></p>\n<ul>\n<li><strong>&quot;Undefined variable &#39;factorial&#39;&quot;</strong>: Missing recursive name binding in execution environment</li>\n<li><strong>Wrong closure values</strong>: Arguments evaluated in closure environment instead of caller environment  </li>\n<li><strong>Parameter conflicts</strong>: Parameters bound in global environment instead of isolated execution environment</li>\n<li><strong>Premature evaluation errors</strong>: Function body evaluated during lambda creation instead of application</li>\n</ul>\n<p><img src=\"/api/project/lisp-interp/architecture-doc/asset?path=diagrams%2Fdata-model.svg\" alt=\"Lisp Value Type Hierarchy\"></p>\n<p><img src=\"/api/project/lisp-interp/architecture-doc/asset?path=diagrams%2Fevaluation-flow.svg\" alt=\"Expression Evaluation Flow\"></p>\n<p><img src=\"/api/project/lisp-interp/architecture-doc/asset?path=diagrams%2Ffunction-application-sequence.svg\" alt=\"Function Application Process\"></p>\n<h2 id=\"list-operations-and-recursion\">List Operations and Recursion</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 4 (List Operations &amp; Recursion) - this section implements fundamental list operations (car, cdr, cons) and supports recursive function definitions, completing the core Lisp interpreter functionality</p>\n</blockquote>\n<p>Lists are the fundamental data structure in Lisp, serving as both the mechanism for representing data and the syntax for code itself. This homoiconicity—where code and data share the same representation—is what makes Lisp uniquely powerful and elegant. In this section, we implement the core list manipulation primitives that enable sophisticated data processing and the recursive function capabilities that allow functions to call themselves by name.</p>\n<p>The list operations we implement—<code>car</code>, <code>cdr</code>, and <code>cons</code>—form the foundation of all list processing in Lisp. These three primitives are sufficient to build any list-based algorithm, from simple traversals to complex tree transformations. Additionally, we enable recursive function definitions, allowing functions to reference themselves by name within their own bodies, which is essential for implementing algorithms that process nested or variable-sized data structures.</p>\n<h3 id=\"mental-model-chain-links\">Mental Model: Chain Links</h3>\n<p>Understanding Lisp lists requires shifting from thinking about arrays or vectors to visualizing <strong>chain links</strong>. Each list element is like a chain link that contains two things: a <strong>payload</strong> (the actual data) and a <strong>connection</strong> (a pointer to the next link in the chain). This is fundamentally different from arrays, where elements are stored in contiguous memory slots.</p>\n<p><img src=\"/api/project/lisp-interp/architecture-doc/asset?path=diagrams%2Fenvironment-chain.svg\" alt=\"Environment Scope Chain\"></p>\n<p>In the chain link mental model, <code>car</code> is like examining the payload in the current link—you can see what data it contains without breaking the chain. The <code>cdr</code> operation is like following the connection to see the rest of the chain that extends beyond the current link. Finally, <code>cons</code> is like forging a new link: you take a payload (the new element) and attach it to an existing chain (the rest of the list), creating a longer chain.</p>\n<p>This mental model helps explain several important properties of Lisp lists. First, accessing the first element (<code>car</code>) is always fast—you just look at the payload in the first link. However, accessing the nth element requires following n connections, making list traversal a sequential operation. Second, adding an element to the front (<code>cons</code>) is extremely efficient—you&#39;re just forging one new link and attaching it to the existing chain. Third, lists naturally share structure—multiple chains can reference the same tail sequence, which is both memory-efficient and enables powerful functional programming patterns.</p>\n<p>The chain link model also illuminates why proper list termination matters. In Lisp, proper lists end with a special &quot;null&quot; or &quot;empty list&quot; marker, like a chain that terminates with a special end link. Improper lists, by contrast, end with some other value, like a chain where the final link connects to something unexpected instead of the proper termination marker.</p>\n<h3 id=\"core-list-primitives\">Core List Primitives</h3>\n<p>The three fundamental list operations—<code>car</code>, <code>cdr</code>, and <code>cons</code>—provide complete control over list structure construction and deconstruction. These operations must be implemented as built-in functions within our interpreter&#39;s global environment, alongside the arithmetic and comparison operators from earlier milestones.</p>\n<blockquote>\n<p><strong>Decision: Lisp List Representation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to represent Lisp lists within our Python host language, balancing efficiency, simplicity, and semantic correctness</li>\n<li><strong>Options Considered</strong>: Python lists with special terminator, linked list nodes with explicit pointers, tuple pairs for cons cells</li>\n<li><strong>Decision</strong>: Use Python lists with <code>None</code> as the empty list marker, wrapping them in <code>LispValue</code> objects</li>\n<li><strong>Rationale</strong>: Python lists provide efficient operations and familiar semantics, while the <code>None</code> terminator clearly distinguishes empty lists from other values. This approach leverages the host language&#39;s optimized list implementation while maintaining clean Lisp semantics.</li>\n<li><strong>Consequences</strong>: Enables efficient list operations and natural integration with Python&#39;s garbage collector, but requires careful handling of proper vs improper list distinctions</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Representation Strategy</th>\n<th>Implementation Efficiency</th>\n<th>Semantic Correctness</th>\n<th>Host Language Integration</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Python lists + None terminator</td>\n<td>High (native operations)</td>\n<td>Good (clear empty list)</td>\n<td>Excellent (natural fit)</td>\n</tr>\n<tr>\n<td>Explicit cons cell objects</td>\n<td>Medium (pointer traversal)</td>\n<td>Excellent (true Lisp semantics)</td>\n<td>Poor (manual memory management)</td>\n</tr>\n<tr>\n<td>Tuple pairs (head, tail)</td>\n<td>Low (immutable recreation)</td>\n<td>Excellent (functional purity)</td>\n<td>Medium (tuple overhead)</td>\n</tr>\n</tbody></table>\n<p>The <code>car</code> function extracts the first element from a list, corresponding to the &quot;head&quot; of the chain. It must handle several important cases: non-empty lists return their first element, empty lists should trigger an error since they have no first element, and non-list arguments should also trigger a type error. The implementation must unwrap the <code>LispValue</code> container to access the underlying Python list, then rewrap the first element as a <code>LispValue</code> for return.</p>\n<table>\n<thead>\n<tr>\n<th>Function</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n<th>Error Conditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>builtin_car</code></td>\n<td><code>args: List[LispValue]</code></td>\n<td><code>LispValue</code></td>\n<td>Returns first element of list</td>\n<td>Empty list, non-list argument, wrong arity</td>\n</tr>\n<tr>\n<td><code>builtin_cdr</code></td>\n<td><code>args: List[LispValue]</code></td>\n<td><code>LispValue</code></td>\n<td>Returns rest of list after first element</td>\n<td>Non-list argument, wrong arity</td>\n</tr>\n<tr>\n<td><code>builtin_cons</code></td>\n<td><code>args: List[LispValue]</code></td>\n<td><code>LispValue</code></td>\n<td>Creates new list with element prepended</td>\n<td>Wrong arity</td>\n</tr>\n<tr>\n<td><code>builtin_list</code></td>\n<td><code>args: List[LispValue]</code></td>\n<td><code>LispValue</code></td>\n<td>Creates proper list from arguments</td>\n<td>Never fails</td>\n</tr>\n<tr>\n<td><code>builtin_null_p</code></td>\n<td><code>args: List[LispValue]</code></td>\n<td><code>LispValue</code></td>\n<td>Tests if argument is empty list</td>\n<td>Wrong arity</td>\n</tr>\n</tbody></table>\n<p>The <code>cdr</code> function returns the &quot;rest&quot; of a list after removing the first element. For a list with multiple elements, <code>cdr</code> returns a new list containing all elements except the first. For a single-element list, <code>cdr</code> returns the empty list. Like <code>car</code>, attempting to take the <code>cdr</code> of an empty list should trigger an error, as should passing a non-list argument.</p>\n<p>The <code>cons</code> function constructs a new list by prepending an element to an existing list. This is the fundamental list construction operation in Lisp. The first argument becomes the new first element, and the second argument should be a list that becomes the rest of the new list. If the second argument is not a list, the result is an &quot;improper list&quot;—a valid Lisp data structure but one that doesn&#39;t terminate properly with the empty list.</p>\n<blockquote>\n<p>The key insight about cons is that it always creates sharing—the new list shares its tail with the original list passed as the second argument. This structural sharing is both memory-efficient and enables powerful functional programming patterns where operations create new data structures without copying entire trees.</p>\n</blockquote>\n<p>Additional list utilities enhance the programmer&#39;s toolkit. The <code>list</code> function provides a convenient way to create proper lists from a variable number of arguments, equivalent to repeatedly calling <code>cons</code> with a final argument of the empty list. The <code>null?</code> predicate (often written with a question mark in Lisp convention, though our implementation may use <code>null_p</code> for Python compatibility) tests whether a value is the empty list, providing a crucial tool for recursive list processing algorithms.</p>\n<p>Here&#39;s the algorithmic breakdown for implementing these primitives:</p>\n<p><strong>Car Implementation Algorithm:</strong></p>\n<ol>\n<li>Verify exactly one argument was provided, raising <code>ArityError</code> if not</li>\n<li>Extract the single argument from the argument list</li>\n<li>Check that the argument is a list type using <code>is_list()</code>, raising <code>TypeError</code> if not</li>\n<li>Access the underlying Python list from the <code>LispValue</code> wrapper</li>\n<li>Check that the list is not empty, raising <code>EvaluationError</code> with descriptive message if empty</li>\n<li>Extract the first element from the Python list</li>\n<li>Return the first element (already a <code>LispValue</code>) without additional wrapping</li>\n</ol>\n<p><strong>Cdr Implementation Algorithm:</strong></p>\n<ol>\n<li>Verify exactly one argument was provided, raising <code>ArityError</code> if not</li>\n<li>Extract the single argument from the argument list</li>\n<li>Check that the argument is a list type using <code>is_list()</code>, raising <code>TypeError</code> if not</li>\n<li>Access the underlying Python list from the <code>LispValue</code> wrapper</li>\n<li>Check that the list is not empty, raising <code>EvaluationError</code> if empty</li>\n<li>Create a new Python list containing all elements except the first (using slice notation)</li>\n<li>Wrap the new Python list in a <code>LispValue</code> with <code>LIST</code> type and return it</li>\n</ol>\n<p><strong>Cons Implementation Algorithm:</strong></p>\n<ol>\n<li>Verify exactly two arguments were provided, raising <code>ArityError</code> if not</li>\n<li>Extract the first argument (the new head element) and second argument (the tail)</li>\n<li>Check that the second argument is a list type using <code>is_list()</code>, raising <code>TypeError</code> if not</li>\n<li>Access the underlying Python list from the tail <code>LispValue</code></li>\n<li>Create a new Python list with the head element followed by all elements from the tail</li>\n<li>Wrap the new Python list in a <code>LispValue</code> with <code>LIST</code> type and return it</li>\n</ol>\n<h3 id=\"recursive-function-support\">Recursive Function Support</h3>\n<p>Enabling functions to call themselves by name is essential for implementing algorithms that process nested or variable-sized data structures. Without recursion, programmers cannot write functions that traverse lists of unknown length or process tree-like structures. However, implementing recursion correctly requires careful consideration of how function names are bound within function bodies.</p>\n<p>The challenge lies in the timing of name binding. When a function is defined using <code>lambda</code>, its body is parsed but not evaluated until the function is called. At call time, the function body is evaluated in an environment that extends the function&#39;s closure environment with parameter bindings. For recursion to work, the function&#39;s own name must be accessible within this extended environment.</p>\n<blockquote>\n<p><strong>Decision: Recursive Function Name Binding Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Functions need to call themselves by name, but lambda functions are anonymous and define creates bindings after function creation</li>\n<li><strong>Options Considered</strong>: Modify environment during function creation, special recursive lambda form, environment extension during application</li>\n<li><strong>Decision</strong>: Extend the function application environment with the function&#39;s own name when a named function calls itself</li>\n<li><strong>Rationale</strong>: This approach maintains the separation between anonymous lambda functions and named function bindings created by define, while ensuring recursive calls can resolve the function name correctly</li>\n<li><strong>Consequences</strong>: Enables natural recursion without complicating lambda semantics, but requires tracking function names and extending environments during application</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Recursion Strategy</th>\n<th>Lambda Simplicity</th>\n<th>Define Semantics</th>\n<th>Implementation Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Name binding during application</td>\n<td>Preserved (lambdas remain anonymous)</td>\n<td>Clean (define binds after creation)</td>\n<td>Medium (conditional binding)</td>\n</tr>\n<tr>\n<td>Self-referential closure capture</td>\n<td>Complicated (lambdas become self-aware)</td>\n<td>Complex (binding before creation)</td>\n<td>High (circular references)</td>\n</tr>\n<tr>\n<td>Special recursive lambda form</td>\n<td>Preserved (separate constructs)</td>\n<td>Clean (define unchanged)</td>\n<td>Low (new special form)</td>\n</tr>\n</tbody></table>\n<p>The implementation strategy extends the function application process to include recursive name binding when appropriate. During function application, after creating the new environment with parameter bindings but before evaluating the function body, we check if the function has a name (indicating it was bound by <code>define</code>). If so, we add a binding from that name to the function itself in the application environment.</p>\n<p><strong>Recursive Function Application Algorithm:</strong></p>\n<ol>\n<li>Begin with the standard function application process through parameter binding</li>\n<li>Create a new environment extending the function&#39;s closure environment</li>\n<li>Bind each parameter name to its corresponding evaluated argument value</li>\n<li>Check if the function has a name (stored in the <code>LispFunction.name</code> field)</li>\n<li>If the function is named, add a binding from that name to the function itself in the new environment</li>\n<li>Evaluate the function body in this enhanced environment with recursive name binding</li>\n<li>Return the result of body evaluation, allowing recursive calls to resolve correctly</li>\n</ol>\n<p>This approach ensures that recursive functions work naturally while preserving the clean semantics of both <code>lambda</code> and <code>define</code>. Anonymous lambda functions remain anonymous—they cannot call themselves recursively unless they&#39;re first bound to a name via <code>define</code>. Named functions created through <code>define</code> automatically gain the ability to call themselves recursively.</p>\n<p>Consider this example evaluation trace for a recursive factorial function:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>(define factorial (lambda (n) (if (= n 0) 1 (* n (factorial (- n 1))))))\n(factorial 3)</code></pre></div>\n\n<p>When <code>factorial</code> is called with argument 3, the application algorithm creates a new environment extending the global environment (where <code>factorial</code> is defined) with the binding <code>n -&gt; 3</code>. Since the function has the name &quot;factorial&quot;, it also adds the binding <code>factorial -&gt; &lt;function object&gt;</code>. When the function body evaluates the recursive call <code>(factorial (- n 1))</code>, the name lookup for &quot;factorial&quot; succeeds in finding the function in the application environment.</p>\n<h3 id=\"tail-call-optimization-strategy\">Tail Call Optimization Strategy</h3>\n<p>Recursive functions can quickly exhaust the call stack when processing large data structures. In languages without tail call optimization, each recursive call consumes additional stack space, leading to stack overflow errors for deep recursions. Tail call optimization recognizes when a function call is in &quot;tail position&quot;—the last operation before returning—and reuses the current stack frame instead of creating a new one.</p>\n<p>A function call is in tail position when its return value becomes the return value of the calling function without any additional computation. In the expression <code>(* n (factorial (- n 1)))</code>, the call to <code>factorial</code> is <strong>not</strong> in tail position because its result must be multiplied by <code>n</code> before returning. However, in a tail-recursive factorial implementation like <code>(factorial-helper (- n 1) (* acc n))</code>, the recursive call is in tail position because its result is returned directly.</p>\n<blockquote>\n<p><strong>Decision: Tail Call Optimization Implementation Approach</strong></p>\n<ul>\n<li><strong>Context</strong>: Deep recursion causes stack overflow in the Python host language, limiting the practical use of recursive Lisp functions</li>\n<li><strong>Options Considered</strong>: Trampoline with continuation passing, iterative loop transformation, Python stack frame manipulation</li>\n<li><strong>Decision</strong>: Implement trampoline-style optimization with explicit continuation objects for tail calls</li>\n<li><strong>Rationale</strong>: Trampolines provide clean tail call semantics without relying on host language features, work reliably across Python implementations, and maintain clear separation between tail and non-tail calls</li>\n<li><strong>Consequences</strong>: Enables deep recursion for tail calls while maintaining stack safety, but adds complexity to function application and requires tail position detection</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Optimization Strategy</th>\n<th>Stack Safety</th>\n<th>Implementation Complexity</th>\n<th>Host Language Independence</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Trampoline with continuations</td>\n<td>Complete (constant stack)</td>\n<td>High (continuation objects)</td>\n<td>Excellent (pure Python)</td>\n</tr>\n<tr>\n<td>Python recursion limit increase</td>\n<td>Partial (configurable limit)</td>\n<td>Low (simple setting)</td>\n<td>Poor (Python-specific)</td>\n</tr>\n<tr>\n<td>Iterative transformation</td>\n<td>Complete (no recursion)</td>\n<td>Very High (complex analysis)</td>\n<td>Good (general technique)</td>\n</tr>\n</tbody></table>\n<p>The trampoline optimization works by detecting when a function call is in tail position and, instead of immediately executing the call, returning a special &quot;continuation&quot; object that describes the call to be made. The main evaluation loop checks for continuation objects and executes them iteratively, effectively converting tail recursion into iteration.</p>\n<p><strong>Tail Call Detection Algorithm:</strong></p>\n<ol>\n<li>During function body evaluation, track whether the current expression is in tail position</li>\n<li>The body of a function is initially in tail position (its result is the function&#39;s result)</li>\n<li>For conditional expressions (<code>if</code>), both the consequent and alternative are in tail position</li>\n<li>For function calls in tail position, create a <code>TailCall</code> continuation object instead of immediate evaluation</li>\n<li>Return the continuation object to the evaluation loop for iterative processing</li>\n<li>For non-tail calls, evaluate immediately using the standard recursive evaluation</li>\n</ol>\n<p><strong>Trampoline Execution Algorithm:</strong></p>\n<ol>\n<li>Begin function application with normal parameter binding and environment extension</li>\n<li>Evaluate the function body in the application environment</li>\n<li>If the result is a <code>TailCall</code> continuation, enter the trampoline loop</li>\n<li>Extract the function and arguments from the continuation object</li>\n<li>Perform the tail call by updating the environment and re-evaluating with new arguments</li>\n<li>Continue the loop until a non-continuation result is produced</li>\n<li>Return the final result, having executed all tail calls iteratively</li>\n</ol>\n<p>The trampoline approach requires modifications to both the evaluation engine and the function application logic. The evaluator must detect tail position contexts and generate continuation objects appropriately. The function application logic must recognize continuation objects and execute the trampoline loop instead of immediately returning results.</p>\n<table>\n<thead>\n<tr>\n<th>Tail Call Context</th>\n<th>Tail Position</th>\n<th>Optimization Applied</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(func args...)</code> at end of function body</td>\n<td>Yes</td>\n<td>Create continuation</td>\n</tr>\n<tr>\n<td><code>(if test (func args...) other)</code></td>\n<td>Yes (both branches)</td>\n<td>Create continuation</td>\n</tr>\n<tr>\n<td><code>(+ 1 (func args...)))</code></td>\n<td>No (result used in addition)</td>\n<td>Standard evaluation</td>\n</tr>\n<tr>\n<td><code>((lambda (x) (func x)) arg)</code></td>\n<td>Yes (lambda body tail)</td>\n<td>Create continuation</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-list-operation-pitfalls\">Common List Operation Pitfalls</h3>\n<p>List operations in Lisp present several common pitfalls that can lead to subtle bugs or runtime errors. Understanding these pitfalls helps developers write more robust code and debug issues more effectively.</p>\n<p>⚠️ <strong>Pitfall: Confusing Empty List with False</strong></p>\n<p>Many developers coming from other languages assume that empty lists are &quot;falsy&quot; in conditional expressions. In Lisp, only the explicit false value (<code>#f</code> or <code>nil</code> depending on dialect) is false—empty lists are truthy. This leads to incorrect conditional logic when checking for list termination.</p>\n<p>The problematic pattern appears in recursive functions that process lists:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>(define process-list (lambda (lst)\n  (if lst  ; WRONG: empty list is truthy\n      (cons (process-element (car lst)) (process-list (cdr lst)))\n      '())))</code></pre></div>\n\n<p>This function will attempt to call <code>car</code> and <code>cdr</code> on the empty list, causing runtime errors. The correct approach uses the <code>null?</code> predicate to explicitly test for the empty list:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>(define process-list (lambda (lst)\n  (if (null? lst)  ; CORRECT: explicit empty list test\n      '()\n      (cons (process-element (car lst)) (process-list (cdr lst))))))</code></pre></div>\n\n<p>To avoid this pitfall, always use <code>null?</code> when testing for list termination in recursive functions. Never rely on implicit truthiness of lists for termination conditions.</p>\n<p>⚠️ <strong>Pitfall: Improper List Construction</strong></p>\n<p>Developers sometimes create &quot;improper lists&quot; by passing non-list values as the second argument to <code>cons</code>. While improper lists are valid Lisp data structures, they cannot be processed by functions that expect proper lists, leading to confusing errors.</p>\n<p>An improper list results when the final <code>cdr</code> is not the empty list:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>(cons 1 (cons 2 3))  ; Creates improper list (1 2 . 3)</code></pre></div>\n\n<p>Many list processing functions assume proper list structure and will fail when encountering improper lists. The <code>length</code> function, for example, may enter an infinite loop or crash when processing improper lists because it expects to eventually reach the empty list terminator.</p>\n<p>To avoid this pitfall, always ensure that the second argument to <code>cons</code> is either the empty list or another proper list. When building lists programmatically, use the <code>list</code> function instead of nested <code>cons</code> calls, or ensure that your recursive list construction always terminates with the empty list.</p>\n<p>⚠️ <strong>Pitfall: Stack Overflow in Non-Tail Recursive Functions</strong></p>\n<p>Recursive functions that are not tail-recursive will consume stack space proportional to their recursion depth. For large inputs, this leads to stack overflow errors that can be difficult to debug, especially when the overflow occurs deep in a complex computation.</p>\n<p>Consider this non-tail-recursive length function:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>(define length (lambda (lst)\n  (if (null? lst)\n      0\n      (+ 1 (length (cdr lst))))))  ; Addition happens after recursive call</code></pre></div>\n\n<p>For a list of 10,000 elements, this function will create 10,000 stack frames, likely causing a stack overflow. The recursive call is not in tail position because the addition occurs after the recursive call returns.</p>\n<p>The tail-recursive version avoids this problem by using an accumulator:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>(define length-helper (lambda (lst acc)\n  (if (null? lst)\n      acc\n      (length-helper (cdr lst) (+ acc 1)))))  ; Recursive call in tail position\n\n(define length (lambda (lst) (length-helper lst 0)))</code></pre></div>\n\n<p>To avoid stack overflow, write recursive functions in tail-recursive form whenever possible, using accumulator parameters to carry intermediate results forward rather than computing them on the return path.</p>\n<p>⚠️ <strong>Pitfall: Mutation vs Structural Sharing Confusion</strong></p>\n<p>Lisp lists use structural sharing, where multiple lists can share common tail sections. Developers sometimes expect that modifying one list will affect shared portions, but proper functional programming in Lisp creates new structures rather than modifying existing ones.</p>\n<p>This confusion arises when developers expect reference semantics but encounter value semantics:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>(define original '(1 2 3))\n(define extended (cons 0 original))\n; Developers might expect that changing 'original' affects 'extended'\n; But functional operations create new structures without mutation</code></pre></div>\n\n<p>The <code>cons</code> operation creates a new list that shares structure with the original, but no operation modifies the original list. If mutation is needed, it requires special functions (like <code>set-car!</code> and <code>set-cdr!</code> in some Lisps) that explicitly modify existing structure.</p>\n<p>To avoid confusion, remember that standard list operations (<code>cons</code>, <code>car</code>, <code>cdr</code>) are non-mutating and create new structures. If you need to modify existing lists, use explicit mutation functions where available, or create new lists with the desired structure.</p>\n<p>⚠️ <strong>Pitfall: Inefficient List Access Patterns</strong></p>\n<p>Developers accustomed to array-based languages sometimes write inefficient list processing code by repeatedly accessing elements by index rather than using sequential traversal patterns.</p>\n<p>This inefficient pattern performs redundant traversals:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>(define process-by-index (lambda (lst)\n  (if (null? lst)\n      '()\n      (cons (process-element (list-ref lst 0))  ; Redundant traversal\n            (process-by-index (list-ref lst 1 (length lst)))))))</code></pre></div>\n\n<p>Each call to <code>list-ref</code> traverses the list from the beginning to reach the specified index, making this an O(n²) algorithm for processing an n-element list.</p>\n<p>The efficient approach uses <code>car</code> and <code>cdr</code> for sequential access:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>(define process-sequentially (lambda (lst)\n  (if (null? lst)\n      '()\n      (cons (process-element (car lst))\n            (process-sequentially (cdr lst))))))</code></pre></div>\n\n<p>This version accesses each element exactly once, making it O(n) for processing an n-element list.</p>\n<p>To avoid inefficiency, design list algorithms around sequential traversal using <code>car</code> and <code>cdr</code> rather than indexed access. When random access is truly needed, consider using vector data structures instead of lists.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides Python-specific code structures and complete implementations for the list operation primitives and recursive function support. The code integrates with the existing interpreter architecture established in previous milestones.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>List Representation</td>\n<td>Python lists with None terminator</td>\n<td>Explicit cons cell classes</td>\n</tr>\n<tr>\n<td>Recursion Control</td>\n<td>Manual stack depth checking</td>\n<td>Full trampoline implementation</td>\n</tr>\n<tr>\n<td>Tail Call Detection</td>\n<td>Simple tail position tracking</td>\n<td>Static analysis with AST annotation</td>\n</tr>\n<tr>\n<td>Memory Management</td>\n<td>Python garbage collection</td>\n<td>Explicit reference counting</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure Integration:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lisp_interpreter/\n  interpreter/\n    evaluator.py              ← extend with list primitives\n    environment.py            ← extend with recursive binding\n    builtins.py              ← add list operation implementations\n    tail_calls.py            ← NEW: tail call optimization\n  tests/\n    test_lists.py            ← NEW: comprehensive list operation tests\n    test_recursion.py        ← NEW: recursive function tests</code></pre></div>\n\n<p><strong>Complete List Primitive Implementations:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># builtins.py - Complete implementations ready to use</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispValue, LispValueType, EvaluationError, </span><span style=\"color:#79B8FF\">TypeError</span><span style=\"color:#E1E4E8\">, ArityError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> builtin_car</span><span style=\"color:#E1E4E8\">(args: List[LispValue]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Extract the first element from a list.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        args: Single-element list containing the list to process</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        The first element of the input list</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ArityError: If not exactly one argument provided</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        TypeError: If argument is not a list</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        EvaluationError: If list is empty</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(args) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> ArityError(</span><span style=\"color:#FFAB70\">expected</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">actual</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(args), </span><span style=\"color:#FFAB70\">function_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"car\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lst_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> is_list(lst_value):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"car requires a list argument, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">lst_value.type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    python_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> lst_value.value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> python_list:  </span><span style=\"color:#6A737D\"># Empty list check</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> EvaluationError(</span><span style=\"color:#9ECBFF\">\"car: cannot take car of empty list\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> python_list[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># First element is already a LispValue</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> builtin_cdr</span><span style=\"color:#E1E4E8\">(args: List[LispValue]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Extract the rest of a list after the first element.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        args: Single-element list containing the list to process</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        New list containing all elements except the first</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ArityError: If not exactly one argument provided</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        TypeError: If argument is not a list</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        EvaluationError: If list is empty</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(args) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> ArityError(</span><span style=\"color:#FFAB70\">expected</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">actual</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(args), </span><span style=\"color:#FFAB70\">function_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"cdr\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lst_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> is_list(lst_value):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"cdr requires a list argument, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">lst_value.type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    python_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> lst_value.value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> python_list:  </span><span style=\"color:#6A737D\"># Empty list check</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> EvaluationError(</span><span style=\"color:#9ECBFF\">\"cdr: cannot take cdr of empty list\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Create new list with all elements except first</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rest_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> python_list[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> make_list(rest_list)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> builtin_cons</span><span style=\"color:#E1E4E8\">(args: List[LispValue]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a new list by prepending an element to an existing list.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        args: Two-element list [new_head, existing_tail]</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        New list with head prepended to tail</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ArityError: If not exactly two arguments provided</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        TypeError: If second argument is not a list</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(args) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> ArityError(</span><span style=\"color:#FFAB70\">expected</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">actual</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(args), </span><span style=\"color:#FFAB70\">function_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"cons\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    head </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tail </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> args[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> is_list(tail):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"cons requires second argument to be a list, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">tail.type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Create new list with head followed by tail elements</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tail_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tail.value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    new_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [head] </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> tail_list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> make_list(new_list)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> builtin_list</span><span style=\"color:#E1E4E8\">(args: List[LispValue]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create a proper list from variable number of arguments.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        args: Variable number of elements to include in list</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        New proper list containing all arguments in order</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> make_list(args)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> builtin_null_p</span><span style=\"color:#E1E4E8\">(args: List[LispValue]) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test whether argument is the empty list.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        args: Single-element list containing value to test</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        LISP_TRUE if argument is empty list, LISP_FALSE otherwise</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ArityError: If not exactly one argument provided</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(args) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> ArityError(</span><span style=\"color:#FFAB70\">expected</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">actual</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(args), </span><span style=\"color:#FFAB70\">function_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"null?\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> args[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> is_list(value) </span><span style=\"color:#F97583\">and</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> value.value:  </span><span style=\"color:#6A737D\"># Empty list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> LISP_TRUE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> LISP_FALSE</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Helper function for registering list primitives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> register_list_builtins</span><span style=\"color:#E1E4E8\">(env: </span><span style=\"color:#9ECBFF\">'Environment'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Register all list operation built-ins in the given environment.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    list_builtins </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'car'</span><span style=\"color:#E1E4E8\">: make_builtin(builtin_car, </span><span style=\"color:#9ECBFF\">'car'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'cdr'</span><span style=\"color:#E1E4E8\">: make_builtin(builtin_cdr, </span><span style=\"color:#9ECBFF\">'cdr'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'cons'</span><span style=\"color:#E1E4E8\">: make_builtin(builtin_cons, </span><span style=\"color:#9ECBFF\">'cons'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'list'</span><span style=\"color:#E1E4E8\">: make_builtin(builtin_list, </span><span style=\"color:#9ECBFF\">'list'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">),  </span><span style=\"color:#6A737D\"># Variable arity</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'null?'</span><span style=\"color:#E1E4E8\">: make_builtin(builtin_null_p, </span><span style=\"color:#9ECBFF\">'null?'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> name, func </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> list_builtins.items():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        env.define(name, func)</span></span></code></pre></div>\n\n<p><strong>Core Recursive Function Support Skeleton:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># environment.py - extend Environment class for recursive binding</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, bindings: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, LispValue] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 parent: Optional[</span><span style=\"color:#9ECBFF\">'Environment'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.bindings </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> bindings </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parent </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> extend_with_recursion</span><span style=\"color:#E1E4E8\">(self, new_bindings: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, LispValue], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                             function_name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                             function_value: Optional[LispValue] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Environment'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create child environment with parameter bindings and optional recursion.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            new_bindings: Parameter name to argument value mappings</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            function_name: Name of function being called (for recursion)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            function_value: Function object being called (for recursion)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            New environment extending this one with bindings and recursion</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create base child environment with new_bindings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If function_name and function_value provided, add recursive binding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return the enhanced child environment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        child_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Environment(new_bindings.copy(), </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> function_name </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> function_value:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            child_env.define(function_name, function_value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> child_env</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># evaluator.py - extend apply_function for recursive support</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> apply_function</span><span style=\"color:#E1E4E8\">(func: LispValue, args: List[LispValue], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  current_env: Environment) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Apply function to arguments with recursive name binding support.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        func: Function object to call</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        args: Evaluated argument values</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        current_env: Environment for evaluation context</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Result of function application</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        TypeError: If func is not callable</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ArityError: If argument count doesn't match parameters</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Verify func is a function type (user-defined or builtin)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle builtin functions (delegate to implementation)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For user functions, create parameter bindings dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check for function name (stored in LispFunction.name field)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create application environment with recursive binding if named</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Evaluate function body in the application environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return evaluation result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> is_function(func):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Cannot call non-function value: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">func</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> is_builtin_function(func):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        builtin </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> func.value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> builtin.arity </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#F97583\"> and</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(args) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> builtin.arity:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> ArityError(</span><span style=\"color:#FFAB70\">expected</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">builtin.arity, </span><span style=\"color:#FFAB70\">actual</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(args), </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                           function_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">builtin.name)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> builtin.implementation(args)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # User-defined function</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    user_func </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> func.value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(args) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(user_func.parameters):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> ArityError(</span><span style=\"color:#FFAB70\">expected</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(user_func.parameters), </span><span style=\"color:#FFAB70\">actual</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(args),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                        function_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">user_func.name </span><span style=\"color:#F97583\">or</span><span style=\"color:#9ECBFF\"> \"&#x3C;anonymous>\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Create parameter bindings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    param_bindings </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> dict</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">zip</span><span style=\"color:#E1E4E8\">(user_func.parameters, args))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Create application environment with recursion support</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    app_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> user_func.closure_env.extend_with_recursion(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        param_bindings, user_func.name, func</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> evaluate(user_func.body, app_env)</span></span></code></pre></div>\n\n<p><strong>Tail Call Optimization Infrastructure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tail_calls.py - Complete tail call optimization system</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispValue, Environment</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TailCall</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a function call in tail position.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    function: LispValue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    arguments: List[LispValue]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    environment: Environment</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TailCallOptimizer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages tail call detection and trampoline execution.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.in_tail_position </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.call_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_tail_context</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if current evaluation context is in tail position.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.in_tail_position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> enter_tail_context</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Mark that we're entering a tail position context.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.in_tail_position </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> exit_tail_context</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Mark that we're leaving tail position context.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.in_tail_position </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_tail_call</span><span style=\"color:#E1E4E8\">(self, func: LispValue, args: List[LispValue], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        env: Environment) -> TailCall:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create a tail call continuation for trampoline execution.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> TailCall(</span><span style=\"color:#FFAB70\">function</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">func, </span><span style=\"color:#FFAB70\">arguments</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#FFAB70\">environment</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">env)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> execute_trampoline</span><span style=\"color:#E1E4E8\">(self, initial_call: TailCall) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute tail calls iteratively using trampoline technique.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            initial_call: First tail call to execute</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Final result after all tail calls complete</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize current call with initial_call</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Loop while current result is a TailCall continuation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Extract function, arguments, and environment from continuation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Apply function using standard application logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If result is another TailCall, continue loop</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If result is a value, return it as final result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Track iteration count to prevent infinite loops</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> initial_call</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        iteration_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        max_iterations </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#6A737D\">  # Prevent infinite loops</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(current, TailCall) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> iteration_count </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> max_iterations:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> apply_function(current.function, current.arguments, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  current.environment)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(result, TailCall):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                current </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            iteration_count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> iteration_count </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> max_iterations:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> EvaluationError(</span><span style=\"color:#9ECBFF\">\"Maximum tail call iterations exceeded\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> current </span><span style=\"color:#F97583\">if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(current, TailCall) </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> LISP_FALSE</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Global optimizer instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">tail_optimizer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TailCallOptimizer()</span></span></code></pre></div>\n\n<p><strong>Milestone 4 Validation Checkpoint:</strong></p>\n<p>After implementing list operations and recursion, verify your implementation with these tests:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test basic list operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> evaluate_string(</span><span style=\"color:#9ECBFF\">\"(car '(1 2 3))\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> make_number(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> evaluate_string(</span><span style=\"color:#9ECBFF\">\"(cdr '(1 2 3))\"</span><span style=\"color:#E1E4E8\">).value </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> [make_number(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">), make_number(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> evaluate_string(</span><span style=\"color:#9ECBFF\">\"(cons 0 '(1 2))\"</span><span style=\"color:#E1E4E8\">).value </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> [make_number(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">), make_number(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">), make_number(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> evaluate_string(</span><span style=\"color:#9ECBFF\">\"(null? '())\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> LISP_TRUE</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> evaluate_string(</span><span style=\"color:#9ECBFF\">\"(null? '(1))\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> LISP_FALSE</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test recursive functions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">factorial_def </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"(define fact (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">evaluate_string(factorial_def)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> evaluate_string(</span><span style=\"color:#9ECBFF\">\"(fact 5)\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> make_number(</span><span style=\"color:#79B8FF\">120</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test list processing recursion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">length_def </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"(define len (lambda (lst) (if (null? lst) 0 (+ 1 (len (cdr lst))))))\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">evaluate_string(length_def)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> evaluate_string(</span><span style=\"color:#9ECBFF\">\"(len '(a b c d))\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> make_number(</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Debugging Tips for List Operations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&quot;Cannot take car of empty list&quot;</td>\n<td>Recursive function doesn&#39;t check for empty list</td>\n<td>Add print statements to show list contents before car/cdr</td>\n<td>Add <code>(null? lst)</code> check before calling car/cdr</td>\n</tr>\n<tr>\n<td>Stack overflow in recursion</td>\n<td>Function is not tail-recursive</td>\n<td>Check if recursive call is last operation</td>\n<td>Rewrite with accumulator parameter for tail recursion</td>\n</tr>\n<tr>\n<td>&quot;Expected list, got number&quot;</td>\n<td>Passing non-list to car/cdr/cons</td>\n<td>Trace argument types through function calls</td>\n<td>Ensure all list operations receive proper lists</td>\n</tr>\n<tr>\n<td>Infinite recursion</td>\n<td>Missing or incorrect base case</td>\n<td>Add debug output showing recursion depth</td>\n<td>Fix base case condition (usually <code>null?</code> check)</td>\n</tr>\n<tr>\n<td>Wrong list length</td>\n<td>Improper list structure</td>\n<td>Print list structure before processing</td>\n<td>Ensure lists end with empty list, not other values</td>\n</tr>\n</tbody></table>\n<p>The list operations and recursion support complete the core functionality of your Lisp interpreter. With these features, users can process arbitrarily complex nested data structures and implement sophisticated algorithms using functional programming techniques.</p>\n<h2 id=\"component-interactions-and-data-flow\">Component Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - component interactions underpin the entire interpreter implementation, from the tokenizer-parser handoff in Milestone 1 through the complex environment and function interactions in Milestones 3-4</p>\n</blockquote>\n<p>The Lisp interpreter&#39;s architecture follows a three-stage pipeline where components must work together seamlessly to transform source text into evaluated results. Understanding how these components interact, how errors propagate between them, and how state persists across evaluations is crucial for building a robust interpreter. This section details the orchestration between the tokenizer, parser, and evaluator, along with the supporting environment and function systems.</p>\n<h3 id=\"end-to-end-processing-pipeline\">End-to-End Processing Pipeline</h3>\n<h4 id=\"mental-model-assembly-line-with-feedback\">Mental Model: Assembly Line with Feedback</h4>\n<p>Think of the interpreter pipeline as a sophisticated manufacturing assembly line where each station (tokenizer, parser, evaluator) performs specialized work on the product, but unlike a simple assembly line, later stations can send feedback upstream and maintain state between processing cycles. Each station has quality control that can halt the entire line when defects are detected, and the final station (evaluator) maintains a workspace (global environment) that remembers previous work.</p>\n<p>The end-to-end processing pipeline represents the complete journey from raw Lisp source text to final evaluation results. This pipeline coordinates the three main components while managing error conditions and state persistence. The pipeline design ensures that each component receives properly formatted input and produces output in the expected format for the next stage.</p>\n<p>The processing pipeline begins when user input arrives, either as a complete program file or as a single expression in a REPL session. The pipeline coordinator validates that the input is not empty and determines whether to process it as a single expression or multiple expressions. For multi-expression input, the coordinator processes each expression sequentially, maintaining state between evaluations.</p>\n<h4 id=\"pipeline-processing-stages\">Pipeline Processing Stages</h4>\n<p>The first stage involves the tokenizer, which receives the raw text input and produces a stream of <code>Token</code> objects. The tokenizer maintains its internal position state and accumulates tokens in its <code>tokens</code> list field. The pipeline coordinator calls <code>tokenize(text)</code> and receives either a successful token list or a <code>TokenizerError</code> exception. The tokenizer&#39;s <code>Scanner</code> processes each character exactly once, building tokens that contain the original text value, token type classification, and source position for error reporting.</p>\n<p>The second stage feeds the token stream to the parser, which calls <code>read_expr(tokens, position, depth)</code> to build the abstract syntax tree. The parser maintains nesting depth tracking to prevent stack overflow and returns a <code>LispValue</code> representing the parsed expression along with the updated position in the token stream. The parser handles quote syntax transformation and validates parenthesis balancing during this phase. Any malformed syntax generates a <code>ParseError</code> with specific location information.</p>\n<p>The third stage passes the AST to the evaluator via <code>evaluate(ast, env)</code>, where the global environment provides access to all previously defined variables and functions. The evaluator dispatches based on the AST&#39;s structure, handling self-evaluating expressions, symbol lookups, special forms, and function applications. The evaluator may recursively call itself for subexpressions and can modify the environment through <code>define</code> operations or create new local environments for function calls.</p>\n<h4 id=\"data-transformation-flow\">Data Transformation Flow</h4>\n<p>The data transformation flow demonstrates how information changes form at each pipeline stage. The initial input is a string containing Lisp source code with whitespace, comments, and syntactic structure. The tokenizer transforms this into a sequence of classified tokens, each containing a type indicator from <code>TokenType</code>, the literal text value, and source position information.</p>\n<table>\n<thead>\n<tr>\n<th>Stage</th>\n<th>Input Format</th>\n<th>Output Format</th>\n<th>Key Transformations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tokenizer</td>\n<td>Raw text string</td>\n<td>List of <code>Token</code> objects</td>\n<td>Text → classified tokens with positions</td>\n</tr>\n<tr>\n<td>Parser</td>\n<td>Token stream</td>\n<td><code>LispValue</code> AST</td>\n<td>Tokens → nested data structures</td>\n</tr>\n<tr>\n<td>Evaluator</td>\n<td>AST + Environment</td>\n<td><code>LispValue</code> result</td>\n<td>AST → computed values</td>\n</tr>\n</tbody></table>\n<p>The parser transforms the flat token sequence into nested <code>LispValue</code> structures that preserve the hierarchical relationship of the original S-expressions. Numbers become <code>LispValue</code> objects with <code>NUMBER</code> type and parsed numeric values. Symbols become <code>LispValue</code> objects with <code>SYMBOL</code> type and string names. Lists become <code>LispValue</code> objects with <code>LIST</code> type containing arrays of nested <code>LispValue</code> elements.</p>\n<p>The evaluator transforms the AST into final computed values by applying Lisp evaluation semantics. Self-evaluating expressions like numbers pass through unchanged. Symbol expressions trigger environment lookups that replace the symbol with its bound value. List expressions undergo function application or special form processing, potentially creating new environments or recursive evaluation calls.</p>\n<h4 id=\"pipeline-coordination-logic\">Pipeline Coordination Logic</h4>\n<p>The pipeline coordinator manages the flow between components and handles the complexity of processing multiple expressions. For single-expression input, the coordinator simply chains the three stages sequentially. For multi-expression input, the coordinator must parse the token stream multiple times, evaluating each expression in sequence while maintaining the same global environment.</p>\n<p>The coordinator implements position threading to track progress through the token stream. After parsing one expression, the parser returns both the AST and the updated position. The coordinator uses this position to continue parsing the next expression from the remaining tokens. This approach allows processing multiple expressions like <code>(define x 10) (+ x 5)</code> in a single input string.</p>\n<p>The coordinator also manages the global environment lifecycle. For each new processing session, the coordinator either creates a fresh global environment via <code>create_global_environment()</code> or reuses an existing environment from a REPL session. The environment persists across expression evaluations within a session, allowing later expressions to reference variables defined in earlier expressions.</p>\n<blockquote>\n<p><strong>Decision: Sequential Expression Processing</strong></p>\n<ul>\n<li><strong>Context</strong>: Multi-expression input requires deciding whether to parse all expressions first then evaluate, or interleave parsing and evaluation</li>\n<li><strong>Options Considered</strong>: Batch processing (parse all, then evaluate all), interleaved processing (parse one, evaluate one, repeat), hybrid approach</li>\n<li><strong>Decision</strong>: Interleaved processing with position threading</li>\n<li><strong>Rationale</strong>: Allows early error detection, supports REPL-style interaction, enables expressions to reference results of previous expressions in the same input</li>\n<li><strong>Consequences</strong>: Requires careful position tracking but provides better user experience and simpler error handling</li>\n</ul>\n</blockquote>\n<h4 id=\"error-recovery-and-continuation\">Error Recovery and Continuation</h4>\n<p>The pipeline coordinator implements error recovery strategies that allow processing to continue after recoverable errors. When the tokenizer encounters invalid character sequences, it can skip the problematic characters and continue tokenizing the rest of the input. The parser can recover from unbalanced parentheses by skipping to the next complete expression. The evaluator can catch runtime errors and continue processing subsequent expressions.</p>\n<p>The coordinator distinguishes between fatal errors that halt all processing and recoverable errors that affect only the current expression. Tokenizer errors for invalid string literals or numeric formats are typically recoverable. Parser errors for unbalanced parentheses may be recoverable if the parser can find synchronization points. Evaluator errors for undefined variables or type mismatches are usually recoverable, allowing the REPL to continue after displaying the error.</p>\n<p>For batch processing of multiple expressions, the coordinator collects both successful results and error information. This allows users to see which expressions succeeded and which failed, rather than halting at the first error. The coordinator maintains a processing context that tracks the current expression number and source location for comprehensive error reporting.</p>\n<h3 id=\"error-propagation-between-components\">Error Propagation Between Components</h3>\n<p><img src=\"/api/project/lisp-interp/architecture-doc/asset?path=diagrams%2Ferror-flow.svg\" alt=\"Error Handling Flow\"></p>\n<h4 id=\"mental-model-quality-control-checkpoints\">Mental Model: Quality Control Checkpoints</h4>\n<p>Think of error handling like quality control checkpoints in a manufacturing process. Each station (tokenizer, parser, evaluator) has specific quality standards it must enforce. When a defect is detected, the station must decide whether to fix it locally, escalate it to a supervisor (error handler), or halt the entire production line. The error information flows upward through management layers, gaining context at each level until it reaches the user with enough detail to understand and fix the problem.</p>\n<p>Error propagation ensures that problems detected deep in the interpreter pipeline are properly classified, contextualized, and reported to users in actionable form. The interpreter implements a hierarchical error system where each component can generate specific error types, and higher-level coordinators enrich these errors with additional context before presenting them to users.</p>\n<h4 id=\"error-classification-hierarchy\">Error Classification Hierarchy</h4>\n<p>The interpreter uses a structured error hierarchy that reflects the pipeline architecture. The base <code>LispError</code> class provides common functionality for error messages and source location tracking. Each pipeline component defines specific error subclasses that capture the types of problems that component can detect.</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Component</th>\n<th>Common Causes</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>TokenizerError</code></td>\n<td>Tokenizer</td>\n<td>Invalid characters, unterminated strings</td>\n<td>Skip to next token boundary</td>\n</tr>\n<tr>\n<td><code>ParseError</code></td>\n<td>Parser</td>\n<td>Unbalanced parens, invalid quote syntax</td>\n<td>Skip to next complete expression</td>\n</tr>\n<tr>\n<td><code>EvaluationError</code></td>\n<td>Evaluator</td>\n<td>Runtime errors, type mismatches</td>\n<td>Continue with next expression</td>\n</tr>\n<tr>\n<td><code>NameError</code></td>\n<td>Evaluator</td>\n<td>Undefined variable access</td>\n<td>Variable suggestion, continue</td>\n</tr>\n<tr>\n<td><code>TypeError</code></td>\n<td>Evaluator</td>\n<td>Wrong argument types</td>\n<td>Type hint, continue</td>\n</tr>\n<tr>\n<td><code>ArityError</code></td>\n<td>Evaluator</td>\n<td>Wrong argument count</td>\n<td>Expected vs actual count</td>\n</tr>\n</tbody></table>\n<p>The tokenizer generates <code>TokenizerError</code> exceptions when it encounters character sequences that cannot be classified into valid tokens. These include unterminated string literals, invalid numeric formats, or characters that are not valid in any token context. The tokenizer includes the exact character position where the error occurred to enable precise error reporting.</p>\n<p>The parser generates <code>ParseError</code> exceptions when token sequences do not conform to valid S-expression syntax. The most common parse errors involve unbalanced parentheses, but the parser also detects malformed quote expressions and unexpected end-of-file conditions. Parse errors include both the token position and a description of what was expected versus what was found.</p>\n<p>The evaluator generates several types of <code>EvaluationError</code> subclasses depending on the specific runtime problem. <code>NameError</code> occurs when symbol lookup fails in the environment chain. <code>TypeError</code> occurs when functions receive arguments of incorrect types. <code>ArityError</code> occurs when functions are called with the wrong number of arguments, and includes both expected and actual argument counts.</p>\n<h4 id=\"error-context-enrichment\">Error Context Enrichment</h4>\n<p>As errors propagate up through the pipeline, each level adds contextual information that helps users understand and fix the problem. The tokenizer provides precise character positions. The parser adds information about the syntactic context and expected constructs. The evaluator adds semantic context about the operation being attempted and the values involved.</p>\n<p>The pipeline coordinator performs the final error enrichment by adding source location mapping that translates internal positions back to line and column numbers in the original source. For REPL environments, the coordinator adds session context that shows the expression number and any relevant previous definitions. For file processing, the coordinator adds filename and surrounding code context.</p>\n<blockquote>\n<p><strong>Key Insight: Error Context Accumulation</strong>\nEach pipeline stage adds its own contextual information to errors without losing the lower-level details. This creates rich error messages that help users understand not just what went wrong, but where and why it happened.</p>\n</blockquote>\n<p>The error enrichment process preserves the original low-level error information while adding higher-level context. A tokenizer error for an unterminated string includes the exact character position where the string started. The parser adds context about whether the string appeared in a function call or special form. The evaluator adds information about what operation was being attempted when the error occurred.</p>\n<h4 id=\"error-reporting-strategies\">Error Reporting Strategies</h4>\n<p>The interpreter implements different error reporting strategies depending on the execution context. Interactive REPL sessions emphasize immediate feedback with suggestions for common mistakes. Batch file processing emphasizes comprehensive error collection with source location mapping. Development environments may include additional debugging information like environment dumps and evaluation traces.</p>\n<p>For tokenizer errors, the interpreter reports the problematic character sequence along with suggestions for common fixes. An unterminated string error shows the string content and suggests adding the closing quote. An invalid number format shows the problematic text and suggests valid numeric formats.</p>\n<p>For parser errors, the interpreter reports the syntactic context and suggests structural fixes. An unbalanced parenthesis error shows the nesting depth and suggests where the missing parenthesis should be added. A malformed quote expression shows the problematic syntax and suggests the correct quote form.</p>\n<p>For evaluator errors, the interpreter reports the semantic context and suggests behavioral fixes. An undefined variable error lists similar variable names that are defined. A type error shows the expected and actual types with examples of correct usage. An arity error shows the function signature and suggests the correct argument pattern.</p>\n<blockquote>\n<p><strong>Decision: Structured Error Types vs String Messages</strong></p>\n<ul>\n<li><strong>Context</strong>: Errors can be represented as simple strings or structured objects with specific fields</li>\n<li><strong>Options Considered</strong>: String messages only, structured error objects, hybrid approach with structured data and formatted messages</li>\n<li><strong>Decision</strong>: Structured error objects with formatting methods</li>\n<li><strong>Rationale</strong>: Enables programmatic error handling, supports multiple output formats, allows error analysis tooling</li>\n<li><strong>Consequences</strong>: More complex error handling code but much better user experience and tooling support</li>\n</ul>\n</blockquote>\n<h4 id=\"error-recovery-mechanisms\">Error Recovery Mechanisms</h4>\n<p>The interpreter implements several error recovery mechanisms that allow processing to continue after errors occur. The tokenizer can skip invalid characters and continue tokenizing the rest of the input. The parser can synchronize at expression boundaries to recover from syntax errors. The evaluator can catch exceptions and continue with the next expression.</p>\n<p>Tokenizer recovery works by advancing past invalid character sequences until a valid token boundary is found. When the tokenizer encounters an invalid character in normal text, it skips characters until it finds whitespace or a delimiter. When the tokenizer encounters an unterminated string, it can either skip to the end of the line or search for the likely intended closing quote.</p>\n<p>Parser recovery works by synchronizing at known safe points in the token stream. When the parser encounters an unbalanced parenthesis, it can skip tokens until it finds a matching delimiter or reaches the end of the current expression. The parser maintains a stack of expected closing delimiters to guide its recovery decisions.</p>\n<p>Evaluator recovery works by catching exceptions and determining whether they represent recoverable errors or fatal problems. Undefined variable errors are recoverable because they don&#39;t affect the interpreter state. Type errors in function calls are recoverable because they don&#39;t modify the environment. However, stack overflow or memory exhaustion errors may require terminating the entire session.</p>\n<h3 id=\"state-management-across-evaluations\">State Management Across Evaluations</h3>\n<h4 id=\"mental-model-persistent-workspace\">Mental Model: Persistent Workspace</h4>\n<p>Think of state management like a craftsperson&#39;s workshop that persists between projects. Each time the craftsperson (evaluator) works on a new piece (expression), they have access to all their tools (built-in functions), materials (defined variables), and custom jigs (user-defined functions) from previous work. The workshop layout (global environment) evolves as new tools are acquired and new storage areas (local environments) are created for specific projects, but the fundamental workspace persists and accumulates knowledge over time.</p>\n<p>State management in the interpreter ensures that variable bindings and function definitions persist across multiple expression evaluations while maintaining proper scoping rules and supporting nested execution contexts. The state management system must handle global environment persistence, temporary environment creation for function calls, and proper cleanup when execution contexts end.</p>\n<h4 id=\"global-environment-persistence\">Global Environment Persistence</h4>\n<p>The global environment serves as the persistent state repository that maintains variable bindings and function definitions across expression evaluations. The global environment is created once per interpreter session and continues to accumulate bindings as expressions are evaluated. This persistence enables the fundamental Lisp development pattern where functions and variables are defined incrementally and build upon each other.</p>\n<table>\n<thead>\n<tr>\n<th>State Component</th>\n<th>Persistence Scope</th>\n<th>Mutation Rules</th>\n<th>Cleanup Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Global Environment</td>\n<td>Entire session</td>\n<td>Additive bindings via define</td>\n<td>Manual reset or session restart</td>\n</tr>\n<tr>\n<td>Function Closures</td>\n<td>Function lifetime</td>\n<td>Immutable after creation</td>\n<td>Garbage collected with function</td>\n</tr>\n<tr>\n<td>Local Environments</td>\n<td>Function call</td>\n<td>Temporary bindings only</td>\n<td>Automatic cleanup on return</td>\n</tr>\n<tr>\n<td>Evaluation Stack</td>\n<td>Single expression</td>\n<td>Call frame management</td>\n<td>Automatic unwinding</td>\n</tr>\n</tbody></table>\n<p>The global environment contains built-in functions that are installed during interpreter initialization via <code>create_global_environment()</code>. These built-ins include arithmetic operators like <code>builtin_add</code>, <code>builtin_subtract</code>, comparison operators like <code>builtin_less_than</code>, and list operations like <code>builtin_car</code>, <code>builtin_cdr</code>. The built-in functions never change during a session and provide the foundational operations for all computation.</p>\n<p>User-defined variables and functions are added to the global environment through <code>define</code> special forms. When the evaluator processes a define expression, it calls the environment&#39;s <code>define(name, value)</code> method to create a new binding in the global scope. These bindings persist for the entire session and can be referenced by subsequent expressions.</p>\n<p>The global environment implements proper shadowing rules where new definitions can replace previous definitions with the same name. When a variable is redefined via <code>define</code>, the new binding replaces the old binding in the global environment. However, any existing closures that captured the old binding continue to reference the old value, maintaining lexical scoping semantics.</p>\n<blockquote>\n<p><strong>Decision: Global Environment Mutation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Global environment needs to support incremental definition while maintaining referential integrity</li>\n<li><strong>Options Considered</strong>: Immutable environment with copy-on-write, mutable environment with binding replacement, hybrid approach with immutable bindings</li>\n<li><strong>Decision</strong>: Mutable environment with binding replacement and closure capture</li>\n<li><strong>Rationale</strong>: Supports natural REPL workflow, matches user expectations for variable redefinition, enables incremental development</li>\n<li><strong>Consequences</strong>: More complex closure semantics but natural user experience for interactive development</li>\n</ul>\n</blockquote>\n<h4 id=\"environment-chain-management\">Environment Chain Management</h4>\n<p>The interpreter creates temporary environment chains for function calls and local binding constructs like <code>let</code>. These temporary environments are linked to parent environments through the <code>parent</code> field, creating a chain that supports lexical scoping lookups. The environment chain management ensures that variable lookups search from the most local scope outward to the global scope.</p>\n<p>When a user-defined function is called, the evaluator creates a new local environment via the parent environment&#39;s <code>extend()</code> method. This new environment has its <code>parent</code> field pointing to the function&#39;s closure environment, not the calling environment. This distinction is crucial for maintaining lexical scoping semantics where variables are resolved based on where functions were defined, not where they are called.</p>\n<p>The local environment receives parameter bindings that map the function&#39;s parameter names to the evaluated argument values. These parameter bindings shadow any variables with the same names in parent environments. The function body evaluation occurs in this local environment, with any nested function calls creating additional environment layers.</p>\n<p>Recursive function calls receive special handling through the <code>extend_with_recursion(bindings, name, func)</code> method. This method creates a local environment where the function name is bound to the function itself, enabling recursive calls. The recursive binding uses a self-referential structure where the function&#39;s closure environment includes a binding to the function itself.</p>\n<p>Environment cleanup occurs automatically when function calls complete. Local environments are eligible for garbage collection when no references remain to them. However, closures may capture references to environments, extending their lifetime beyond the original function call. The environment chain management must support this lifetime extension while avoiding memory leaks.</p>\n<h4 id=\"closure-environment-capture\">Closure Environment Capture</h4>\n<p>Closures represent the most complex aspect of state management because they capture references to their defining environment that must persist beyond the original scope. When the evaluator processes a <code>lambda</code> expression via <code>handle_lambda(args, env)</code>, it creates a <code>LispFunction</code> object whose <code>closure_env</code> field contains a reference to the current environment.</p>\n<p>The closure environment capture process creates a snapshot of the environment chain at the time the lambda is evaluated. This snapshot includes not just the immediate environment bindings, but also references to parent environments that the lambda might need to access. The captured environment chain remains accessible as long as the function object exists.</p>\n<p>Closure environment capture interacts with the global environment persistence in subtle ways. If a lambda captures a reference to the global environment, and the global environment is later modified through new <code>define</code> operations, the lambda will see the modified global environment. This behavior matches user expectations that functions can access newly defined global variables.</p>\n<p>However, closure environment capture for local variables works differently. If a lambda captures a reference to a local environment from an enclosing function call, that local environment persists even after the enclosing function returns. This persistence is essential for closures to maintain access to their captured variables, but it requires careful memory management to avoid leaks.</p>\n<table>\n<thead>\n<tr>\n<th>Capture Scenario</th>\n<th>Environment Source</th>\n<th>Persistence Rules</th>\n<th>Access Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Global Variable</td>\n<td>Global environment</td>\n<td>Session lifetime</td>\n<td>Sees updates</td>\n</tr>\n<tr>\n<td>Local Variable</td>\n<td>Function call environment</td>\n<td>Extended by closure</td>\n<td>Frozen at capture</td>\n</tr>\n<tr>\n<td>Parameter Variable</td>\n<td>Function parameter environment</td>\n<td>Extended by closure</td>\n<td>Frozen at capture</td>\n</tr>\n<tr>\n<td>Recursive Reference</td>\n<td>Self-referential environment</td>\n<td>Extended by closure</td>\n<td>Enables recursion</td>\n</tr>\n</tbody></table>\n<p>The closure environment capture mechanism must handle self-referential functions where a lambda needs to call itself recursively. This requires creating an environment where the function name is bound to the function being defined, but the function is not yet complete. The evaluator resolves this circular dependency by creating the function object first, then updating the environment binding to reference the completed function.</p>\n<h4 id=\"state-consistency-and-isolation\">State Consistency and Isolation</h4>\n<p>The interpreter maintains state consistency by ensuring that environment modifications are atomic and that temporary environments do not interfere with persistent state. Global environment modifications through <code>define</code> are immediately visible to all subsequent evaluations. Local environment modifications during function calls remain isolated from both the global environment and other concurrent function calls.</p>\n<p>State isolation is particularly important for recursive function calls where multiple invocations of the same function create separate local environments. Each recursive call receives its own parameter bindings and local variable space, preventing interference between recursion levels. The environment chain structure naturally provides this isolation by creating separate environment objects for each call.</p>\n<p>The interpreter handles state consistency during error conditions by ensuring that failed evaluations do not leave the environment in an inconsistent state. If an error occurs during the evaluation of a <code>define</code> expression, the global environment should not be modified. If an error occurs during function argument evaluation, the function should not be called and no new environment should be created.</p>\n<blockquote>\n<p><strong>Key Insight: Environment Lifetime Management</strong>\nEnvironments have complex lifetime semantics where local environments may outlive their creating function calls due to closure capture, but the environment chain structure ensures that lookups always traverse the correct sequence of scopes regardless of timing.</p>\n</blockquote>\n<p>The state management system supports debugging and introspection by maintaining metadata about environment creation and modification. Each environment can track its creation context, parent relationships, and binding history. This metadata enables debugging tools to display environment chains, track variable modifications, and identify closure capture relationships.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical guidance for implementing the component interactions and data flow management in your Lisp interpreter.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Handling</td>\n<td>Exception classes with message strings</td>\n<td>Structured error objects with source mapping</td>\n</tr>\n<tr>\n<td>State Management</td>\n<td>Global dictionary for environment</td>\n<td>Environment chain with proper scoping</td>\n</tr>\n<tr>\n<td>Pipeline Coordination</td>\n<td>Sequential function calls</td>\n<td>Pipeline coordinator class with recovery</td>\n</tr>\n<tr>\n<td>Error Reporting</td>\n<td>Print error messages to stdout</td>\n<td>Structured error reporting with context</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lisp-interpreter/\n  src/\n    interpreter.py           ← main pipeline coordinator\n    errors.py               ← error class hierarchy\n    environment.py          ← environment and state management\n    pipeline.py             ← component interaction logic\n  tests/\n    test_integration.py     ← end-to-end pipeline tests\n    test_errors.py          ← error propagation tests\n    test_state.py           ← state management tests</code></pre></div>\n\n<h4 id=\"pipeline-coordinator-infrastructure-complete\">Pipeline Coordinator Infrastructure (Complete)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Any, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispError, TokenizerError, ParseError, EvaluationError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> tokenizer </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> tokenize, Token</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parse</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> evaluator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> evaluate, create_global_environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Environment</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EvaluationResult</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Result of evaluating a single expression.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value: Optional[Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    error: Optional[LispError] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expression_text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InterpreterSession</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages state and coordination for a Lisp interpreter session.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.global_env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_global_environment()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expression_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.evaluation_history </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> evaluate_text</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[EvaluationResult]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate one or more expressions from text input.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> text.strip():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tokenize(text)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            position </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            while</span><span style=\"color:#E1E4E8\"> position </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(tokens) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> tokens[position].type </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> 'EOF'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    ast, position </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._parse_single_expression(tokens, position)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._evaluate_single_expression(ast, text)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    results.append(result)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                except</span><span style=\"color:#E1E4E8\"> (ParseError, EvaluationError) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    error_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> EvaluationResult(</span><span style=\"color:#FFAB70\">error</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">e, </span><span style=\"color:#FFAB70\">expression_text</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">text)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    results.append(error_result)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Try to recover by skipping to next complete expression</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    position </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._find_next_expression(tokens, position)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> TokenizerError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Tokenizer errors are usually fatal for the entire input</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            error_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> EvaluationResult(</span><span style=\"color:#FFAB70\">error</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">e, </span><span style=\"color:#FFAB70\">expression_text</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">text)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            results.append(error_result)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _parse_single_expression</span><span style=\"color:#E1E4E8\">(self, tokens: List[Token], position: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Parse a single expression starting at the given position.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Call read_expr with tokens, position, and depth=0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return the parsed AST and updated position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle ParseError exceptions and add context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _evaluate_single_expression</span><span style=\"color:#E1E4E8\">(self, ast, original_text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> EvaluationResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate a single AST node and return the result.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Call evaluate(ast, self.global_env)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Increment self.expression_count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add result to self.evaluation_history</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return EvaluationResult with value and metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle EvaluationError exceptions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _find_next_expression</span><span style=\"color:#E1E4E8\">(self, tokens: List[Token], error_position: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Find the start of the next complete expression after an error.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Skip tokens until finding a safe synchronization point</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Look for balanced parentheses or top-level expressions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return position of next expression or EOF</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"error-class-hierarchy-complete\">Error Class Hierarchy (Complete)</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all Lisp interpreter errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, source_location: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.source_location </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source_location</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> with_context</span><span style=\"color:#E1E4E8\">(self, context: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'LispError'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add additional context to the error message.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        enhanced_message </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">context</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.message</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Create new instance of the same type with enhanced message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__class__</span><span style=\"color:#E1E4E8\">(enhanced_message, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.source_location)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenizerError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Error during tokenization phase.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Error during parsing phase.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EvaluationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for evaluation-time errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> NameError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Variable name not found in environment.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, source_location: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Undefined variable: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, source_location)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Type mismatch in operation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, expected: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, actual: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, operation: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 source_location: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Type error in </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">operation</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: expected </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">actual</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, source_location)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expected </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expected</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.actual </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.operation </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> operation</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArityError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Wrong number of arguments to function.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, expected: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, actual: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, function_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 source_location: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Arity error in </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">function_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: expected </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> arguments, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">actual</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, source_location)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expected </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expected</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.actual </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.function_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> function_name</span></span></code></pre></div>\n\n<h4 id=\"core-pipeline-logic-skeleton\">Core Pipeline Logic Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PipelineCoordinator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Coordinates the three-stage processing pipeline.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.tokenizer </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Will be injected</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">     # Will be injected</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.evaluator </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # Will be injected</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_expression</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, environment: Environment) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Process a single expression through the complete pipeline.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Call tokenize(text) and handle TokenizerError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call parse(tokens) and handle ParseError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Call evaluate(ast, environment) and handle EvaluationError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add error context at each stage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return final result or re-raise enriched error</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> enrich_tokenizer_error</span><span style=\"color:#E1E4E8\">(self, error: TokenizerError, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> TokenizerError:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add source context to tokenizer errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract line and column from error.source_location</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Get surrounding context from original text</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create enhanced error message with context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return new TokenizerError with enhanced message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> enrich_parser_error</span><span style=\"color:#E1E4E8\">(self, error: ParseError, tokens: List[Token]) -> ParseError:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add syntactic context to parser errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Identify the token where parsing failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Determine expected vs actual syntax</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Suggest likely fixes (missing parens, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return new ParseError with enhanced message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> enrich_evaluation_error</span><span style=\"color:#E1E4E8\">(self, error: EvaluationError, ast: Any) -> EvaluationError:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add semantic context to evaluation errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Identify the operation being attempted</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add information about involved values/types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Suggest corrections for common mistakes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return new EvaluationError with enhanced message</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"state-management-core-logic-skeleton\">State Management Core Logic Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> StateManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages interpreter state across multiple evaluations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.global_environment </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_global_environment()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.evaluation_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.debug_mode </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> prepare_evaluation_context</span><span style=\"color:#E1E4E8\">(self, ast: Any) -> Environment:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Prepare the environment context for evaluating an expression.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Determine if this is a top-level evaluation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return global_environment for top-level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle function call context preparation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add debugging hooks if debug_mode is enabled</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> finalize_evaluation_context</span><span style=\"color:#E1E4E8\">(self, result: Any, environment: Environment):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Clean up after evaluation and update persistent state.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Increment evaluation_count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Update global_environment if needed (define operations)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Clean up temporary environments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Record evaluation in history if debugging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_define_operation</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: Any):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle global variable definition.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate that name is a valid symbol</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call global_environment.define(name, value)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Update any debugging/introspection metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check for redefinition warnings if enabled</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<ul>\n<li>Use Python&#39;s exception hierarchy naturally - create your error classes as subclasses of the appropriate base exceptions</li>\n<li>Leverage Python&#39;s <code>dataclasses</code> for clean data structure definitions with automatic constructors</li>\n<li>Use <code>typing</code> module annotations for better error catching and IDE support</li>\n<li>Python&#39;s <code>traceback</code> module can provide source location information for errors</li>\n<li>Consider using <code>contextlib.contextmanager</code> for temporary environment creation</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing component interactions:</p>\n<p><strong>Test Command</strong>: <code>python -m pytest tests/test_integration.py -v</code></p>\n<p><strong>Expected Output</strong>: All pipeline coordination tests should pass, showing proper error propagation and state management</p>\n<p><strong>Manual Verification</strong>:</p>\n<ol>\n<li>Start your interpreter REPL</li>\n<li>Enter <code>(define x 10)</code> - should complete without error and remember the binding</li>\n<li>Enter <code>(+ x 5)</code> - should return 15, showing state persistence</li>\n<li>Enter <code>(undefined-var)</code> - should show clear error message with suggestions</li>\n<li>Enter <code>(+ 1 2</code> - should show parse error for unbalanced parentheses</li>\n<li>Enter <code>(+ 1 2 3)</code> after the error - should recover and return 6</li>\n</ol>\n<p><strong>Signs of Problems</strong>:</p>\n<ul>\n<li>Errors without useful context messages → improve error enrichment</li>\n<li>State not persisting between expressions → check environment management</li>\n<li>Crashes instead of graceful error handling → add more try/catch blocks</li>\n<li>Inconsistent behavior after errors → implement proper error recovery</li>\n</ul>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - error handling is crucial throughout the entire interpreter implementation, from tokenization errors in Milestone 1 to evaluation errors in Milestones 2-4</p>\n</blockquote>\n<p>Error handling in a Lisp interpreter presents unique challenges because errors can occur at any of the three pipeline stages, and each stage has different types of failures with different recovery strategies. Unlike simple applications that might crash on error, an interpreter must provide helpful feedback to users debugging their Lisp programs while maintaining system stability. The challenge lies in detecting errors early, preserving enough context to generate meaningful error messages, and determining when to attempt recovery versus when to fail fast.</p>\n<h3 id=\"mental-model-the-quality-control-checkpoint-system\">Mental Model: The Quality Control Checkpoint System</h3>\n<p>Think of error handling in the interpreter like a series of quality control checkpoints in a manufacturing pipeline. At each checkpoint (tokenizer, parser, evaluator), inspectors examine the work product and can either pass it to the next station, send it back for repair, or reject it entirely with detailed feedback about what went wrong and where.</p>\n<p>Just as quality inspectors need different skills to check raw materials versus assembled components versus finished products, each stage of our interpreter needs specialized error detection appropriate to its inputs and outputs. The tokenizer inspects character sequences for basic validity, the parser examines token arrangements for structural correctness, and the evaluator validates semantic meaning and runtime behavior.</p>\n<p>The key insight is that errors caught early in the pipeline are easier to diagnose and fix than errors that propagate through multiple stages. A malformed string literal detected during tokenization produces a clearer error message than the same problem manifesting as a mysterious evaluation failure several stages later.</p>\n<h3 id=\"error-categories-and-detection\">Error Categories and Detection</h3>\n<p>The interpreter encounters several distinct categories of errors, each requiring different detection strategies and recovery approaches. Understanding these categories helps design appropriate error handling mechanisms and determines where in the pipeline each type of error should be caught.</p>\n<p><strong>Lexical Errors</strong> occur during tokenization when the scanner encounters character sequences that cannot be converted into valid tokens. These errors happen at the lowest level of processing and typically indicate syntax problems in the source text itself.</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Detection Point</th>\n<th>Trigger Condition</th>\n<th>Example Input</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unterminated String</td>\n<td><code>scan_string()</code></td>\n<td>EOF reached before closing quote</td>\n<td><code>&quot;hello world</code></td>\n<td>Skip to next token boundary</td>\n</tr>\n<tr>\n<td>Invalid Number Format</td>\n<td><code>scan_number()</code></td>\n<td>Multiple decimal points or invalid digits</td>\n<td><code>12.34.56</code></td>\n<td>Treat as symbol instead</td>\n</tr>\n<tr>\n<td>Illegal Character</td>\n<td><code>scan_all()</code></td>\n<td>Character not valid in any token type</td>\n<td><code>@#$%</code></td>\n<td>Skip character and continue</td>\n</tr>\n<tr>\n<td>Unterminated Comment</td>\n<td><code>scan_comment()</code></td>\n<td>EOF in multi-line comment block</td>\n<td><code>/* comment...</code></td>\n<td>Treat as complete comment</td>\n</tr>\n</tbody></table>\n<p>The tokenizer detects lexical errors by maintaining state as it scans characters and recognizing when character sequences violate token formation rules. For example, when scanning a string literal, the tokenizer tracks whether it has encountered the opening quote and whether each character until the closing quote is valid or properly escaped.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenizerError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message, source_location</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, character</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, context</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, source_location)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.character </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> character</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> context  </span><span style=\"color:#6A737D\"># surrounding text for context</span></span></code></pre></div>\n\n<p><strong>Syntactic Errors</strong> occur during parsing when token sequences are structurally invalid according to Lisp grammar rules. The parser detects these errors when token patterns don&#39;t match expected S-expression structures.</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Detection Point</th>\n<th>Trigger Condition</th>\n<th>Example Input</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unbalanced Parentheses</td>\n<td><code>read_list()</code></td>\n<td>EOF with open paren or extra close paren</td>\n<td><code>(+ 1 2</code> or <code>(+ 1 2))</code></td>\n<td>Skip to next balanced expression</td>\n</tr>\n<tr>\n<td>Empty Expression</td>\n<td><code>parse()</code></td>\n<td>Empty token stream or only whitespace</td>\n<td>`` (empty)</td>\n<td>Return special empty value</td>\n</tr>\n<tr>\n<td>Malformed Quote</td>\n<td><code>read_quote_expr()</code></td>\n<td>Quote followed by EOF</td>\n<td><code>&#39;</code></td>\n<td>Treat as symbol literal</td>\n</tr>\n<tr>\n<td>Excessive Nesting</td>\n<td><code>read_expr()</code></td>\n<td>Nesting depth exceeds maximum</td>\n<td><code>(((((...))))</code></td>\n<td>Reject with depth limit error</td>\n</tr>\n</tbody></table>\n<p>The parser detects syntactic errors by tracking expected tokens based on the current parsing context. When parsing a list, it expects either more expressions or a closing parenthesis. When it encounters EOF or an unexpected token type, it can generate specific error messages about what was expected versus what was found.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message, source_location</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, expected_token</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, actual_token</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, context_tokens</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, source_location)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expected_token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expected_token</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.actual_token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual_token</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.context_tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> context_tokens  </span><span style=\"color:#6A737D\"># surrounding tokens for context</span></span></code></pre></div>\n\n<p><strong>Semantic Errors</strong> occur during evaluation when expressions are syntactically valid but semantically meaningless or violate runtime constraints. The evaluator detects these errors when attempting to perform operations on incompatible types or access undefined variables.</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Detection Point</th>\n<th>Trigger Condition</th>\n<th>Example Input</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Undefined Variable</td>\n<td><code>lookup()</code></td>\n<td>Symbol not found in environment chain</td>\n<td><code>undefined_var</code></td>\n<td>Suggest similar names</td>\n</tr>\n<tr>\n<td>Type Mismatch</td>\n<td>Builtin functions</td>\n<td>Operation on incompatible types</td>\n<td><code>(+ &quot;hello&quot; 5)</code></td>\n<td>Show expected vs actual types</td>\n</tr>\n<tr>\n<td>Arity Mismatch</td>\n<td><code>apply_function()</code></td>\n<td>Wrong number of arguments</td>\n<td><code>(+ 1)</code> for binary +</td>\n<td>Show expected vs actual count</td>\n</tr>\n<tr>\n<td>Division by Zero</td>\n<td><code>builtin_divide()</code></td>\n<td>Zero divisor in arithmetic</td>\n<td><code>(/ 5 0)</code></td>\n<td>Return special infinity value</td>\n</tr>\n<tr>\n<td>Stack Overflow</td>\n<td><code>evaluate()</code></td>\n<td>Recursion depth exceeds limit</td>\n<td>Infinite recursion</td>\n<td>Detect cycle or depth limit</td>\n</tr>\n</tbody></table>\n<p>Semantic errors are detected by the evaluator and builtin functions as they attempt to perform operations. Each operation has preconditions about the types and values of its arguments, and violations of these preconditions trigger semantic errors.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EvaluationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message, source_location</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, expression</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, environment_context</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, source_location)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expression </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expression</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.environment_context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> environment_context</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> NameError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, symbol_name, similar_names</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Undefined variable: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">symbol_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.symbol_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> symbol_name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.similar_names </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> similar_names </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, operation, expected_type, actual_type, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">operation</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> expected </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">actual_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.operation </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> operation</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expected_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expected_type</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.actual_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual_type</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArityError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, function_name, expected, actual, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">function_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> expects </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> arguments, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">actual</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.function_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> function_name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expected </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expected</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.actual </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual</span></span></code></pre></div>\n\n<p><strong>Runtime Errors</strong> occur during evaluation when operations fail due to resource constraints or system limitations rather than logical errors in the Lisp code. These errors often indicate environmental problems rather than programming mistakes.</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Detection Point</th>\n<th>Trigger Condition</th>\n<th>Example</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory Exhaustion</td>\n<td><code>make_list()</code></td>\n<td>Insufficient memory for allocation</td>\n<td>Huge list creation</td>\n<td>Garbage collection trigger</td>\n</tr>\n<tr>\n<td>Stack Overflow</td>\n<td><code>evaluate()</code></td>\n<td>Call stack exceeds system limits</td>\n<td>Deep recursion</td>\n<td>Convert to tail call optimization</td>\n</tr>\n<tr>\n<td>File I/O Error</td>\n<td>File operations</td>\n<td>File system access failure</td>\n<td>Read nonexistent file</td>\n<td>Return error value</td>\n</tr>\n<tr>\n<td>Timeout</td>\n<td>Long operations</td>\n<td>Operation exceeds time limit</td>\n<td>Infinite loop detection</td>\n<td>Interrupt evaluation</td>\n</tr>\n</tbody></table>\n<p>Runtime errors are detected by monitoring resource usage and system constraints during evaluation. The interpreter can implement safeguards like recursion depth limits, evaluation step counters, and memory usage tracking to detect and prevent resource exhaustion.</p>\n<blockquote>\n<p><strong>Key Design Insight</strong>: Error detection should happen as early as possible in the pipeline. A malformed string literal should be caught during tokenization, not discovered later when the evaluator tries to use an invalid token. This principle of &quot;fail fast&quot; makes debugging easier because error messages can be more specific about the actual root cause.</p>\n</blockquote>\n<h3 id=\"common-error-detection-pitfalls\">Common Error Detection Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Late Error Detection</strong>\nMany interpreter implementations defer error checking until the evaluator, making all errors appear as evaluation failures. This approach loses valuable context about where the error actually originated. For example, detecting an unterminated string literal during evaluation instead of tokenization makes it seem like a semantic error when it&#39;s actually a lexical problem.</p>\n<p><strong>Why this is wrong</strong>: Late detection makes error messages confusing and harder to debug. Users see &quot;evaluation error&quot; when they have a simple syntax mistake.</p>\n<p><strong>How to fix</strong>: Implement comprehensive error checking at each pipeline stage. The tokenizer should validate all character sequences, the parser should verify structural correctness, and the evaluator should focus on semantic validation.</p>\n<p>⚠️ <strong>Pitfall: Generic Error Messages</strong>\nUsing the same error type and message format for all errors makes it difficult for users to understand what went wrong and how to fix it. Generic messages like &quot;syntax error&quot; or &quot;evaluation failed&quot; provide no actionable information.</p>\n<p><strong>Why this is wrong</strong>: Users need specific information to fix their code. Knowing that a function expects 2 arguments but got 3 is much more helpful than &quot;function call failed&quot;.</p>\n<p><strong>How to fix</strong>: Create specific error types for different failure modes with detailed context. Include information about what was expected, what was actually found, and suggestions for fixes.</p>\n<p>⚠️ <strong>Pitfall: No Error Recovery</strong>\nStopping interpretation after the first error prevents users from discovering multiple problems in their code. This approach is particularly frustrating during development when fixing one error reveals several others.</p>\n<p><strong>Why this is wrong</strong>: Users want to see as many errors as possible in a single run to minimize development iteration cycles.</p>\n<p><strong>How to fix</strong>: Implement error recovery strategies that allow parsing and evaluation to continue after recoverable errors. Skip malformed expressions and attempt to parse the next valid expression.</p>\n<h3 id=\"user-friendly-error-reporting\">User-Friendly Error Reporting</h3>\n<p>The primary goal of error reporting is to help users understand what went wrong and how to fix it. This requires translating internal error representations into human-readable messages with sufficient context for debugging. The challenge lies in providing enough information to be helpful without overwhelming users with implementation details.</p>\n<p><strong>Error Message Components</strong> provide the essential information users need to understand and fix errors. Each error message should include several key components arranged in a consistent format that users can learn to interpret quickly.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Purpose</th>\n<th>Example</th>\n<th>When to Include</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Type</td>\n<td>Categorizes the kind of problem</td>\n<td><code>SyntaxError</code>, <code>NameError</code>, <code>TypeError</code></td>\n<td>Always</td>\n</tr>\n<tr>\n<td>Description</td>\n<td>Human-readable explanation of what went wrong</td>\n<td>&quot;Undefined variable &#39;x&#39;&quot;</td>\n<td>Always</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>Where in the source code the error occurred</td>\n<td>&quot;Line 5, column 12&quot;</td>\n<td>When source location available</td>\n</tr>\n<tr>\n<td>Context</td>\n<td>Surrounding code showing the error location</td>\n<td><code>&gt;&gt;&gt; (+ x 5)</code> with <code>x</code> highlighted</td>\n<td>When helpful for disambiguation</td>\n</tr>\n<tr>\n<td>Expected vs Actual</td>\n<td>What was expected and what was found instead</td>\n<td>&quot;Expected number, got string &#39;hello&#39;&quot;</td>\n<td>For type and arity errors</td>\n</tr>\n<tr>\n<td>Suggestions</td>\n<td>Specific recommendations for fixing the error</td>\n<td>&quot;Did you mean &#39;y&#39;?&quot; for undefined variable</td>\n<td>When applicable</td>\n</tr>\n</tbody></table>\n<p>The error reporting system builds these components by enriching basic error information as it propagates up through the pipeline stages. Each stage adds context appropriate to its level of processing.</p>\n<p><strong>Error Message Formatting</strong> presents error information in a consistent, scannable format that helps users quickly identify the problem type and location. The format should be familiar to users of other programming languages while accommodating Lisp-specific concepts.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>ErrorType: Description\n  at expression: (problematic code here)\n  in context: (surrounding code for reference)\n  \n  Expected: (what was expected)\n  Actual: (what was found)\n  \n  Suggestion: (specific recommendation for fixing)</code></pre></div>\n\n<p>For example, a type error in arithmetic might appear as:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>TypeError: Cannot add string to number\n  at expression: (+ &quot;hello&quot; 5)\n  in context: (define result (+ &quot;hello&quot; 5))\n  \n  Expected: number for second argument\n  Actual: string &quot;hello&quot;\n  \n  Suggestion: Use string concatenation or convert string to number</code></pre></div>\n\n<p><strong>Progressive Error Detail</strong> allows users to control how much information they see in error messages. Beginners benefit from verbose explanations while experienced users prefer concise summaries. The interpreter can provide multiple levels of error detail.</p>\n<table>\n<thead>\n<tr>\n<th>Detail Level</th>\n<th>Target Audience</th>\n<th>Information Included</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Concise</td>\n<td>Experienced users</td>\n<td>Error type and location only</td>\n<td><code>NameError: &#39;x&#39; undefined at line 5</code></td>\n</tr>\n<tr>\n<td>Standard</td>\n<td>General users</td>\n<td>Type, description, location, context</td>\n<td>Full format shown above</td>\n</tr>\n<tr>\n<td>Verbose</td>\n<td>Beginners</td>\n<td>Includes explanation of concepts</td>\n<td>Explains what variable binding means</td>\n</tr>\n<tr>\n<td>Debug</td>\n<td>Developers</td>\n<td>Internal state and call stack</td>\n<td>Shows environment contents and evaluation steps</td>\n</tr>\n</tbody></table>\n<p><strong>Error Context Enrichment</strong> adds information as errors flow up through the pipeline stages. Each stage contributes context appropriate to its processing level, building a complete picture of what went wrong and where.</p>\n<p>The tokenizer contributes character-level context:</p>\n<ul>\n<li>Character position in source text</li>\n<li>Surrounding characters for context</li>\n<li>Current tokenizer state when error occurred</li>\n<li>Partial token being processed</li>\n</ul>\n<p>The parser contributes structural context:</p>\n<ul>\n<li>Token position in token stream</li>\n<li>Current parsing context (inside list, after quote, etc.)</li>\n<li>Partial parse tree built so far</li>\n<li>Expected token types at error location</li>\n</ul>\n<p>The evaluator contributes semantic context:</p>\n<ul>\n<li>Expression being evaluated</li>\n<li>Current environment bindings</li>\n<li>Call stack for function applications</li>\n<li>Values of related variables</li>\n</ul>\n<blockquote>\n<p><strong>Design Decision: Staged Error Enrichment</strong></p>\n<ul>\n<li><strong>Context</strong>: Error information needs to be preserved and enhanced as it flows through pipeline stages</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Collect all context at error detection point</li>\n<li>Enrich error information at each pipeline stage</li>\n<li>Defer context collection until error display time</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Enrich error information at each pipeline stage</li>\n<li><strong>Rationale</strong>: Each stage has unique context that would be difficult to reconstruct later. Staged enrichment allows each component to contribute its specialized knowledge while preserving information from earlier stages.</li>\n<li><strong>Consequences</strong>: More complex error propagation but much better error messages with complete context from all pipeline stages.</li>\n</ul>\n</blockquote>\n<h3 id=\"error-recovery-strategies\">Error Recovery Strategies</h3>\n<p>Error recovery allows the interpreter to continue processing after encountering errors, enabling users to discover multiple problems in a single run. Different types of errors require different recovery strategies based on their severity and the likelihood of producing meaningful results from continued processing.</p>\n<p><strong>Tokenizer Recovery</strong> handles lexical errors by skipping problematic characters or tokens and attempting to resume normal tokenization. The tokenizer can often recover from localized problems without affecting the rest of the input.</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Recovery Strategy</th>\n<th>Implementation</th>\n<th>Trade-offs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unterminated String</td>\n<td>Insert closing quote and continue</td>\n<td>Add <code>&quot;</code> token and resume scanning</td>\n<td>May misinterpret subsequent text</td>\n</tr>\n<tr>\n<td>Invalid Character</td>\n<td>Skip character and continue</td>\n<td>Advance position and scan next</td>\n<td>Character is lost from input</td>\n</tr>\n<tr>\n<td>Malformed Number</td>\n<td>Treat as symbol instead</td>\n<td>Create <code>SYMBOL</code> token with full text</td>\n<td>May cause later type errors</td>\n</tr>\n<tr>\n<td>Invalid Escape</td>\n<td>Use literal character</td>\n<td>Include backslash in string content</td>\n<td>String content may be incorrect</td>\n</tr>\n</tbody></table>\n<p>The tokenizer implements recovery by detecting error conditions, creating the best possible token representation, and resuming normal scanning from the next character position. Recovery decisions should err on the side of preserving user intent when possible.</p>\n<p><strong>Parser Recovery</strong> handles structural errors by skipping malformed expressions and synchronizing to the next valid parse point. The parser looks for token patterns that indicate expression boundaries and resumes parsing from those points.</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Recovery Strategy</th>\n<th>Synchronization Points</th>\n<th>Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unbalanced Parens</td>\n<td>Skip to next balanced expression</td>\n<td>Top-level expression boundaries</td>\n<td>Current expression discarded</td>\n</tr>\n<tr>\n<td>Unexpected Token</td>\n<td>Skip token and continue</td>\n<td>End of current subexpression</td>\n<td>Token ignored</td>\n</tr>\n<tr>\n<td>Excessive Nesting</td>\n<td>Flatten deeply nested structure</td>\n<td>Matching closing parentheses</td>\n<td>Structure simplified</td>\n</tr>\n<tr>\n<td>Malformed Quote</td>\n<td>Treat quote as literal symbol</td>\n<td>Next complete expression</td>\n<td>Quote becomes symbol value</td>\n</tr>\n</tbody></table>\n<p>Parser recovery works by maintaining a stack of parsing contexts and using panic mode recovery when errors occur. The parser discards tokens until it finds a synchronization point where it can confidently resume normal parsing.</p>\n<p><strong>Evaluator Recovery</strong> handles semantic errors by providing default values or skipping problematic expressions. Evaluator recovery is more complex because semantic errors often indicate logical problems that affect program correctness.</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Recovery Strategy</th>\n<th>Default Value</th>\n<th>Continuing Evaluation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Undefined Variable</td>\n<td>Use special undefined value</td>\n<td><code>#&lt;undefined&gt;</code></td>\n<td>Continue with placeholder</td>\n</tr>\n<tr>\n<td>Type Mismatch</td>\n<td>Return error value</td>\n<td><code>#&lt;error&gt;</code></td>\n<td>Propagate error marker</td>\n</tr>\n<tr>\n<td>Arity Error</td>\n<td>Use partial application or defaults</td>\n<td>Function with remaining params</td>\n<td>May produce unexpected results</td>\n</tr>\n<tr>\n<td>Division by Zero</td>\n<td>Return infinity or NaN</td>\n<td><code>#&lt;infinity&gt;</code></td>\n<td>Mathematical convention</td>\n</tr>\n</tbody></table>\n<p>Evaluator recovery must balance the desire to continue processing with the risk of producing meaningless results. Some errors are recoverable (division by zero can return infinity) while others indicate fundamental problems that make continued evaluation unreliable.</p>\n<blockquote>\n<p><strong>Key Design Principle</strong>: Recovery strategies should be conservative about correctness. It&#39;s better to stop evaluation after a serious semantic error than to continue with potentially incorrect results that might mislead the user about program behavior.</p>\n</blockquote>\n<h3 id=\"edge-case-handling\">Edge Case Handling</h3>\n<p>Edge cases in interpreter design involve boundary conditions, unusual inputs, and resource limitations that can cause unexpected behavior if not handled properly. Robust edge case handling ensures the interpreter behaves predictably across the full range of possible inputs and system conditions.</p>\n<p><strong>Input Boundary Conditions</strong> include empty inputs, extremely large inputs, and inputs at the limits of data type ranges. These conditions test the interpreter&#39;s robustness with unusual but valid inputs.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Detection Point</th>\n<th>Handling Strategy</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Empty Source Text</td>\n<td><code>tokenize()</code></td>\n<td>Return empty token list</td>\n<td>Parse to empty program</td>\n</tr>\n<tr>\n<td>Single Character Input</td>\n<td><code>tokenize()</code></td>\n<td>Handle as minimal token</td>\n<td>Parse to single atom or error</td>\n</tr>\n<tr>\n<td>Extremely Long Lines</td>\n<td><code>scan_all()</code></td>\n<td>Process incrementally</td>\n<td>No memory overflow</td>\n</tr>\n<tr>\n<td>Very Deep Nesting</td>\n<td><code>read_expr()</code></td>\n<td>Enforce depth limits</td>\n<td>Reject beyond threshold</td>\n</tr>\n<tr>\n<td>Huge Number Literals</td>\n<td><code>scan_number()</code></td>\n<td>Use arbitrary precision or overflow detection</td>\n<td>Preserve precision or error</td>\n</tr>\n<tr>\n<td>Maximum Length Symbols</td>\n<td><code>scan_symbol()</code></td>\n<td>Enforce length limits</td>\n<td>Reject or truncate with warning</td>\n</tr>\n</tbody></table>\n<p>The interpreter handles input boundary conditions by implementing appropriate limits and safeguards. For example, the parser can enforce a maximum nesting depth to prevent stack overflow from deeply nested expressions.</p>\n<p><strong>Numeric Edge Cases</strong> involve arithmetic operations at the boundaries of numeric representation, including overflow, underflow, and special floating-point values.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Operation</th>\n<th>Detection</th>\n<th>Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Integer Overflow</td>\n<td>Addition, multiplication</td>\n<td>Result exceeds type limits</td>\n<td>Promote to bigger type or arbitrary precision</td>\n</tr>\n<tr>\n<td>Division by Zero</td>\n<td>Division, modulo</td>\n<td>Zero divisor</td>\n<td>Return infinity or error value</td>\n</tr>\n<tr>\n<td>Negative Zero</td>\n<td>Floating-point arithmetic</td>\n<td>Sign bit analysis</td>\n<td>Preserve IEEE 754 semantics</td>\n</tr>\n<tr>\n<td>NaN Propagation</td>\n<td>Operations with NaN</td>\n<td>NaN input detection</td>\n<td>Propagate NaN through calculations</td>\n</tr>\n<tr>\n<td>Infinity Arithmetic</td>\n<td>Operations with infinity</td>\n<td>Infinity input detection</td>\n<td>Follow IEEE 754 rules</td>\n</tr>\n</tbody></table>\n<p>Numeric edge cases are handled by implementing proper arithmetic overflow detection and following established conventions for special values. The interpreter can choose between different numeric representations (fixed-precision vs arbitrary-precision) based on its design goals.</p>\n<p><strong>Memory and Resource Limits</strong> protect the interpreter from inputs that could exhaust system resources or cause denial of service. These limits must be high enough for legitimate use while preventing abuse.</p>\n<table>\n<thead>\n<tr>\n<th>Resource</th>\n<th>Limit Type</th>\n<th>Threshold</th>\n<th>Detection</th>\n<th>Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Token Count</td>\n<td>Per expression</td>\n<td>10,000 tokens</td>\n<td>During tokenization</td>\n<td>Reject with error</td>\n</tr>\n<tr>\n<td>Parse Tree Depth</td>\n<td>Nested expressions</td>\n<td>100 levels</td>\n<td>During parsing</td>\n<td>Reject with error</td>\n</tr>\n<tr>\n<td>Environment Depth</td>\n<td>Nested scopes</td>\n<td>1,000 levels</td>\n<td>During evaluation</td>\n<td>Reject with error</td>\n</tr>\n<tr>\n<td>Symbol Table Size</td>\n<td>Number of bindings</td>\n<td>100,000 symbols</td>\n<td>During definition</td>\n<td>Garbage collection</td>\n</tr>\n<tr>\n<td>Evaluation Steps</td>\n<td>Computation length</td>\n<td>1,000,000 steps</td>\n<td>During evaluation</td>\n<td>Timeout error</td>\n</tr>\n<tr>\n<td>String Length</td>\n<td>String literals</td>\n<td>1MB characters</td>\n<td>During tokenization</td>\n<td>Reject or truncate</td>\n</tr>\n</tbody></table>\n<p>Resource limits are implemented by adding counters and checks throughout the interpreter. These limits should be configurable to accommodate different use cases while providing reasonable defaults.</p>\n<p><strong>Concurrent Access Edge Cases</strong> arise when multiple evaluation contexts share mutable state or when the interpreter is used in multi-threaded environments.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Scenario</th>\n<th>Detection</th>\n<th>Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Environment Mutation</td>\n<td>Multiple threads modifying global environment</td>\n<td>Race condition detection</td>\n<td>Synchronization or immutable environments</td>\n</tr>\n<tr>\n<td>Shared Function State</td>\n<td>Closures with mutable captured variables</td>\n<td>Concurrent modification</td>\n<td>Copy-on-write or locking</td>\n</tr>\n<tr>\n<td>Recursive Environment Access</td>\n<td>Function modifying its own closure environment</td>\n<td>Cycle detection</td>\n<td>Detect and prevent cycles</td>\n</tr>\n<tr>\n<td>Resource Contention</td>\n<td>Multiple evaluations competing for limited resources</td>\n<td>Resource monitoring</td>\n<td>Fair scheduling or queueing</td>\n</tr>\n</tbody></table>\n<p>Concurrent access edge cases are handled by careful design of shared data structures and appropriate synchronization mechanisms. Many Lisp interpreters avoid these issues by using immutable data structures and functional programming principles.</p>\n<h3 id=\"common-edge-case-pitfalls\">Common Edge Case Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Ignoring Numeric Overflow</strong>\nMany interpreter implementations ignore integer overflow, leading to incorrect results for large arithmetic operations. This problem manifests as wrong answers rather than obvious errors, making it particularly dangerous.</p>\n<p><strong>Why this is wrong</strong>: Silent overflow produces incorrect results that users might not notice until they affect program correctness in subtle ways.</p>\n<p><strong>How to fix</strong>: Implement overflow detection in arithmetic operations and either promote to larger numeric types, use arbitrary precision arithmetic, or report overflow errors explicitly.</p>\n<p>⚠️ <strong>Pitfall: Unbounded Resource Usage</strong>\nFailing to implement resource limits allows malicious or buggy code to consume unlimited memory, CPU time, or stack space, potentially crashing the interpreter or the entire system.</p>\n<p><strong>Why this is wrong</strong>: Resource exhaustion can make the interpreter unusable and affect other programs on the same system.</p>\n<p><strong>How to fix</strong>: Implement configurable limits on all resource usage: maximum expression depth, evaluation step count, memory allocation, and string lengths. Provide clear error messages when limits are exceeded.</p>\n<p>⚠️ <strong>Pitfall: Inconsistent Error Handling</strong>\nDifferent parts of the interpreter handling similar edge cases in different ways creates unpredictable behavior that confuses users and makes debugging difficult.</p>\n<p><strong>Why this is wrong</strong>: Users need consistent behavior to build mental models of how the interpreter works and predict how it will handle unusual situations.</p>\n<p><strong>How to fix</strong>: Establish consistent policies for edge case handling and implement them uniformly across all interpreter components. Document the policies clearly for users.</p>\n<p><img src=\"/api/project/lisp-interp/architecture-doc/asset?path=diagrams%2Ferror-flow.svg\" alt=\"Error Handling Flow\"></p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This subsection provides concrete implementation patterns and code structures for building a robust error handling system in the Lisp interpreter. The focus is on Python-specific approaches that integrate cleanly with the three-stage pipeline architecture.</p>\n<p><strong>Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Types</td>\n<td>Python exceptions with inheritance</td>\n<td>Custom error hierarchy with structured data</td>\n</tr>\n<tr>\n<td>Error Context</td>\n<td>String concatenation for messages</td>\n<td>Template-based formatting with context objects</td>\n</tr>\n<tr>\n<td>Source Location Tracking</td>\n<td>Line/column counters</td>\n<td>Full source mapping with character ranges</td>\n</tr>\n<tr>\n<td>Error Recovery</td>\n<td>Basic exception handling</td>\n<td>Sophisticated recovery with continuation strategies</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Python logging module</td>\n<td>Structured logging with error categorization</td>\n</tr>\n<tr>\n<td>User Interface</td>\n<td>Plain text error messages</td>\n<td>Rich formatting with syntax highlighting</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File/Module Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lisp_interpreter/\n  errors/\n    __init__.py              ← Export all error types\n    base.py                  ← Base error classes and common functionality\n    tokenizer_errors.py      ← Lexical error types and detection\n    parser_errors.py         ← Syntactic error types and recovery\n    evaluator_errors.py      ← Semantic and runtime error types\n    formatting.py            ← Error message formatting and display\n    recovery.py              ← Error recovery strategies\n  tokenizer/\n    scanner.py               ← Integration with error detection\n  parser/\n    parser.py                ← Integration with error recovery\n  evaluator/\n    evaluator.py             ← Integration with semantic error handling\n  utils/\n    source_location.py       ← Source position tracking utilities</code></pre></div>\n\n<p><strong>Infrastructure Starter Code (Complete Error Foundation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># errors/base.py - Complete error hierarchy foundation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, List, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SourceLocation</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Tracks position in source text for error reporting.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    column: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    position: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    length: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"line </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.line</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, column </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.column</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all Lisp interpreter errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, source_location: Optional[SourceLocation] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.source_location </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source_location</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.context_info: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_context</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: Any) -> </span><span style=\"color:#9ECBFF\">'LispError'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add contextual information to the error.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.context_info[key] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_message</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format the complete error message with context.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.message]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.source_location:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            parts.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\" at </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.source_location</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.context_info:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> key, value </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.context_info.items():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                parts.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#79B8FF\">  {</span><span style=\"color:#E1E4E8\">key</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">.join(parts)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenizerError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Errors occurring during lexical analysis.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, source_location: Optional[SourceLocation] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 character: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, context: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, source_location)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.character </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> character</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> context</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Errors occurring during syntactic analysis.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, source_location: Optional[SourceLocation] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 expected_token: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, actual_token: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, source_location)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expected_token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expected_token</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.actual_token </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual_token</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EvaluationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Errors occurring during semantic evaluation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, source_location: Optional[SourceLocation] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 expression: Optional[Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, environment_context: Optional[Dict] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, source_location)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expression </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expression</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.environment_context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> environment_context </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Specific evaluation error types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> NameError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Variable or function name not found in environment.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, symbol_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, similar_names: Optional[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Undefined variable: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">symbol_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.symbol_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> symbol_name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.similar_names </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> similar_names </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Type mismatch in operation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, operation: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, expected_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, actual_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">operation</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> expected </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">actual_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.operation </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> operation</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expected_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expected_type</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.actual_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual_type</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArityError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Function called with wrong number of arguments.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, function_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, expected: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, actual: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">function_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> expects </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">expected</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> arguments, got </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">actual</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.function_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> function_name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expected </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> expected</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.actual </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> actual</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Error recovery utilities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorRecovery</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Utilities for error recovery strategies.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> skip_to_synchronization_point</span><span style=\"color:#E1E4E8\">(tokens: List, position: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, sync_tokens: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Skip tokens until reaching a synchronization point.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> position </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(tokens) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> tokens[position].type </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> sync_tokens:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            position </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> position</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> suggest_similar_names</span><span style=\"color:#E1E4E8\">(target: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, available_names: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], max_suggestions: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Suggest similar variable names for undefined variable errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        def</span><span style=\"color:#B392F0\"> edit_distance</span><span style=\"color:#E1E4E8\">(s1: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, s2: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Simple Levenshtein distance implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(s1) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(s2):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> edit_distance(s2, s1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            distances </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(s2) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> i1, c1 </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(s1):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                new_distances </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [i1 </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                for</span><span style=\"color:#E1E4E8\"> i2, c2 </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(s2):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> c1 </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> c2:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        new_distances.append(distances[i2])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        new_distances.append(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\"> min</span><span style=\"color:#E1E4E8\">(distances[i2], distances[i2 </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">], new_distances[</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                distances </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> new_distances</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> distances[</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Find names with small edit distance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        candidates </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [(name, edit_distance(target, name)) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> available_names]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        candidates.sort(</span><span style=\"color:#FFAB70\">key</span><span style=\"color:#F97583\">=lambda</span><span style=\"color:#E1E4E8\"> x: x[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Return names within reasonable edit distance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        suggestions </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> name, distance </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> candidates[:max_suggestions]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> distance </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> max</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(target) </span><span style=\"color:#F97583\">//</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#E1E4E8\">):  </span><span style=\"color:#6A737D\"># Allow up to 1/3 character differences</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                suggestions.append(name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> suggestions</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton Code:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># errors/formatting.py - Error message formatting (implement the TODOs)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorFormatter</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Formats error messages for user-friendly display.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, source_text: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.source_text </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source_text</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source_text.split(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> source_text </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_error</span><span style=\"color:#E1E4E8\">(self, error: LispError, detail_level: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> 'standard'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format a complete error message with appropriate detail level.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            error: The error to format</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            detail_level: 'concise', 'standard', 'verbose', or 'debug'</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Formatted error message string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create error type header (e.g., \"SyntaxError:\", \"NameError:\")</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add main error description</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add source location if available (line/column)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add source context (show problematic line with highlighting)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: For standard/verbose: add expected vs actual information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: For verbose: add explanation of concepts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: For debug: add internal state information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Add suggestions for fixing the error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use different formatting based on detail_level parameter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> extract_source_context</span><span style=\"color:#E1E4E8\">(self, location: SourceLocation, context_lines: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Extract source code context around an error location.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            location: Source location of the error</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            context_lines: Number of lines before/after to include</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Formatted source context with error highlighting</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate line range to display (location.line +/- context_lines)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract relevant lines from source text</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add line numbers to each line</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Highlight the specific error location (underline or arrow)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Format as readable block with consistent indentation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use location.column to position the error indicator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_suggestions</span><span style=\"color:#E1E4E8\">(self, error: LispError) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate helpful suggestions based on error type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check error type and provide type-specific suggestions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For NameError: suggest similar variable names</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For TypeError: suggest correct types or conversions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For ArityError: show correct function signature</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: For SyntaxError: suggest common fixes (balanced parens, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use isinstance() to check error types and access specific fields</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Integration with tokenizer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SafeScanner</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Scanner with integrated error handling and recovery.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.text </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.position </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> scan_all</span><span style=\"color:#E1E4E8\">(self) -> List[Token]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Main tokenization loop with error recovery.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize position tracking for source locations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Loop through all characters in text</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Try to scan next token, catching TokenizerError exceptions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: On error: record error, attempt recovery, continue scanning</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Add EOF token at end</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return tokens even if errors occurred (for error tolerance)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use try/except around individual token scanning operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> recover_from_error</span><span style=\"color:#E1E4E8\">(self, error: TokenizerError) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Attempt to recover from tokenization error.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Based on error type, choose appropriate recovery strategy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For unterminated string: insert closing quote and continue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For invalid character: skip character and advance position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For malformed number: treat remainder as symbol</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Record recovery action for debugging</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Different error types need different recovery strategies</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Integration with parser  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SafeParser</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parser with error recovery and synchronization.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, max_nesting_depth: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.max_nesting_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> max_nesting_depth</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse</span><span style=\"color:#E1E4E8\">(self, tokens: List[Token]) -> Optional[LispValue]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Parse tokens with error recovery.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Try to parse main expression, catching ParseError exceptions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: On error: record error, attempt synchronization, continue if possible</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return partial parse results even with errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return None only for completely unparseable input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use panic mode recovery to skip to next valid expression boundary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> synchronize_after_error</span><span style=\"color:#E1E4E8\">(self, tokens: List[Token], position: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Find next synchronization point after parse error.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Define synchronization points (top-level expressions, balanced parens)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Skip tokens until reaching synchronization point</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Ensure parentheses are balanced at synchronization point</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return new position to resume parsing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Look for tokens that clearly start new expressions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Integration with evaluator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SafeEvaluator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Evaluator with comprehensive error handling.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.evaluation_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.max_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.step_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.max_steps </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1000000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(self, ast: LispValue, env: Environment) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate with error detection and resource limits.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check resource limits (depth, step count) before evaluation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Try evaluation, catching all EvaluationError types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Enrich errors with current evaluation context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For recoverable errors: return error value and continue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: For unrecoverable errors: propagate with full context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Update resource usage counters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Different error types need different handling strategies</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> check_resource_limits</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if resource limits have been exceeded.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check current evaluation depth against maximum</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check step count against maximum</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check memory usage if tracking is enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Raise appropriate ResourceError if limits exceeded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Limits should be configurable for different use cases</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> enrich_evaluation_error</span><span style=\"color:#E1E4E8\">(self, error: EvaluationError, ast: LispValue, env: Environment) -> EvaluationError:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add evaluation context to error.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Add current expression being evaluated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add relevant environment bindings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add call stack information if available</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add suggestions based on error type and context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Only include context that helps user understand the problem</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing error handling:</p>\n<ol>\n<li><strong>Test Error Detection</strong>: Run <code>python -m pytest tests/test_errors.py -v</code></li>\n<li><strong>Expected Output</strong>: All error types properly detected and categorized</li>\n<li><strong>Manual Verification</strong>: <ul>\n<li>Try malformed input: <code>(+ 1</code> should show unbalanced parentheses error</li>\n<li>Try undefined variable: <code>undefined_var</code> should suggest similar names</li>\n<li>Try type error: <code>(+ &quot;hello&quot; 5)</code> should show expected vs actual types</li>\n<li>Try arity error: <code>(+)</code> should show expected argument count</li>\n</ul>\n</li>\n</ol>\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Generic error messages</td>\n<td>Using base Exception class</td>\n<td>Check error type hierarchy</td>\n<td>Use specific error subclasses</td>\n</tr>\n<tr>\n<td>Missing error context</td>\n<td>Errors not enriched as they propagate</td>\n<td>Add logging to error handling paths</td>\n<td>Implement context enrichment at each stage</td>\n</tr>\n<tr>\n<td>Poor error recovery</td>\n<td>Stopping on first error</td>\n<td>Check exception handling logic</td>\n<td>Implement recovery strategies</td>\n</tr>\n<tr>\n<td>Confusing error locations</td>\n<td>Source location not tracked properly</td>\n<td>Verify position tracking in tokenizer/parser</td>\n<td>Fix position threading through pipeline</td>\n</tr>\n<tr>\n<td>Resource exhaustion crashes</td>\n<td>No resource limits implemented</td>\n<td>Monitor memory and stack usage</td>\n<td>Add resource limit checks</td>\n</tr>\n</tbody></table>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - testing strategy provides validation checkpoints for each stage of interpreter development, from tokenization verification in Milestone 1 through complete Lisp program evaluation in Milestone 4</p>\n</blockquote>\n<h3 id=\"mental-model-the-quality-pyramid\">Mental Model: The Quality Pyramid</h3>\n<p>Think of interpreter testing as building a <strong>quality pyramid</strong> where each level depends on the stability of the levels below it. At the base, you have unit tests that verify individual components like the tokenizer producing correct tokens from text. In the middle, you have integration tests that verify components work together correctly, like the parser consuming tokenizer output to build proper ASTs. At the top, you have end-to-end tests that validate complete Lisp programs execute with expected results. Just as a pyramid collapses if the foundation is weak, interpreter bugs at lower levels cascade upward and cause confusing failures in higher-level functionality.</p>\n<p>The key insight is that <strong>interpreter testing requires both microscopic precision and telescopic vision</strong>. You need microscopic precision to verify that individual characters become correct tokens, tokens become correct parse trees, and expressions evaluate to correct values. But you also need telescopic vision to verify that complete Lisp programs exhibit the expected computational behavior. Most interpreter bugs manifest as subtle mismatches between expected and actual behavior that only become apparent when you test both the individual components and their orchestrated interactions.</p>\n<p>A robust testing strategy for an interpreter must address three fundamental challenges: <strong>component isolation</strong>, <strong>state management across evaluations</strong>, and <strong>error propagation verification</strong>. Component isolation ensures that tokenizer bugs don&#39;t mask parser bugs and parser bugs don&#39;t mask evaluator bugs. State management testing verifies that variable bindings persist correctly between expressions and that environments maintain proper lexical scoping. Error propagation testing ensures that malformed input produces helpful error messages rather than cryptic crashes or infinite loops.</p>\n<h3 id=\"unit-testing-by-component\">Unit Testing by Component</h3>\n<p>Unit testing for an interpreter requires testing each component of the three-stage pipeline in complete isolation from the others. This isolation is crucial because interpreter components have complex internal logic that can fail in subtle ways, and you need to verify the correctness of each component before testing their interactions.</p>\n<p>The fundamental principle of interpreter unit testing is <strong>property-based verification</strong>: instead of just testing specific inputs and outputs, you verify that each component maintains essential properties that must hold for all valid inputs. For the tokenizer, these properties include position consistency (every token knows its source location), boundary detection (token boundaries align with meaningful text boundaries), and round-trip preservation (concatenating token values reconstructs the original text minus comments and whitespace). For the parser, key properties include structural integrity (parentheses balance correctly), nesting consistency (nested structures have proper depth relationships), and semantic preservation (the AST represents the same computation as the source text). For the evaluator, critical properties include type safety (operations receive arguments of expected types), environment consistency (variable lookups find the correct bindings), and computational correctness (arithmetic and logical operations produce expected results).</p>\n<h4 id=\"tokenizer-unit-testing\">Tokenizer Unit Testing</h4>\n<p>Tokenizer testing focuses on <strong>boundary detection accuracy</strong> and <strong>token classification correctness</strong>. The tokenizer must correctly identify where tokens begin and end in the source text, classify each token according to its syntactic role, and preserve enough information for error reporting and source location tracking.</p>\n<p><strong>Token Boundary Detection Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Input Example</th>\n<th>Expected Token Sequence</th>\n<th>Boundary Challenge</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Adjacent Symbols</td>\n<td><code>abc+def</code></td>\n<td><code>[SYMBOL(&quot;abc&quot;), SYMBOL(&quot;+&quot;), SYMBOL(&quot;def&quot;)]</code></td>\n<td>No whitespace separation</td>\n</tr>\n<tr>\n<td>Number-Symbol Boundary</td>\n<td><code>123abc</code></td>\n<td><code>[NUMBER(123), SYMBOL(&quot;abc&quot;)]</code></td>\n<td>Transition from digit to letter</td>\n</tr>\n<tr>\n<td>String Literal Boundaries</td>\n<td><code>&quot;hello&quot;world</code></td>\n<td><code>[STRING(&quot;hello&quot;), SYMBOL(&quot;world&quot;)]</code></td>\n<td>Quote termination</td>\n</tr>\n<tr>\n<td>Parenthesis Attachment</td>\n<td><code>(+ 1 2)</code></td>\n<td><code>[LEFT_PAREN, SYMBOL(&quot;+&quot;), NUMBER(1), NUMBER(2), RIGHT_PAREN]</code></td>\n<td>Parentheses as separate tokens</td>\n</tr>\n<tr>\n<td>Quote Shorthand</td>\n<td><code>&#39;(a b)</code></td>\n<td><code>[QUOTE, LEFT_PAREN, SYMBOL(&quot;a&quot;), SYMBOL(&quot;b&quot;), RIGHT_PAREN]</code></td>\n<td>Quote as distinct token</td>\n</tr>\n</tbody></table>\n<p><strong>Token Classification Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Input Pattern</th>\n<th>Expected Type</th>\n<th>Value Extraction</th>\n<th>Classification Rule</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>42</code></td>\n<td><code>TokenType.NUMBER</code></td>\n<td><code>42</code> (integer)</td>\n<td>All digits</td>\n</tr>\n<tr>\n<td><code>3.14</code></td>\n<td><code>TokenType.NUMBER</code></td>\n<td><code>3.14</code> (float)</td>\n<td>Digits with decimal point</td>\n</tr>\n<tr>\n<td><code>-17</code></td>\n<td><code>TokenType.NUMBER</code></td>\n<td><code>-17</code> (negative integer)</td>\n<td>Minus followed by digits</td>\n</tr>\n<tr>\n<td><code>abc</code></td>\n<td><code>TokenType.SYMBOL</code></td>\n<td><code>&quot;abc&quot;</code></td>\n<td>Letter followed by symbol chars</td>\n</tr>\n<tr>\n<td><code>+</code></td>\n<td><code>TokenType.SYMBOL</code></td>\n<td><code>&quot;+&quot;</code></td>\n<td>Single operator character</td>\n</tr>\n<tr>\n<td><code>&quot;text&quot;</code></td>\n<td><code>TokenType.STRING</code></td>\n<td><code>&quot;text&quot;</code></td>\n<td>Content between quotes</td>\n</tr>\n<tr>\n<td><code>(</code></td>\n<td><code>TokenType.LEFT_PAREN</code></td>\n<td><code>&quot;(&quot;</code></td>\n<td>Opening parenthesis</td>\n</tr>\n<tr>\n<td><code>)</code></td>\n<td><code>TokenType.RIGHT_PAREN</code></td>\n<td><code>&quot;)&quot;</code></td>\n<td>Closing parenthesis</td>\n</tr>\n<tr>\n<td><code>&#39;</code></td>\n<td><code>TokenType.QUOTE</code></td>\n<td><code>&quot;&#39;&quot;</code></td>\n<td>Single quote character</td>\n</tr>\n</tbody></table>\n<p><strong>Position Tracking Tests:</strong></p>\n<p>Position tracking verification ensures that every token maintains accurate source location information for error reporting. These tests verify that the <code>position</code> field of each <code>Token</code> correctly identifies the character offset in the source text where the token begins.</p>\n<table>\n<thead>\n<tr>\n<th>Source Text</th>\n<th>Token</th>\n<th>Expected Position</th>\n<th>Position Calculation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(+ 1 2)</code></td>\n<td><code>LEFT_PAREN</code></td>\n<td>0</td>\n<td>First character</td>\n</tr>\n<tr>\n<td><code>(+ 1 2)</code></td>\n<td><code>SYMBOL(&quot;+&quot;)</code></td>\n<td>1</td>\n<td>After opening paren</td>\n</tr>\n<tr>\n<td><code>(+ 1 2)</code></td>\n<td><code>NUMBER(1)</code></td>\n<td>3</td>\n<td>After space</td>\n</tr>\n<tr>\n<td><code>  abc</code></td>\n<td><code>SYMBOL(&quot;abc&quot;)</code></td>\n<td>2</td>\n<td>After leading whitespace</td>\n</tr>\n<tr>\n<td><code>&quot;hello world&quot;</code></td>\n<td><code>STRING(&quot;hello world&quot;)</code></td>\n<td>0</td>\n<td>String starts at quote</td>\n</tr>\n</tbody></table>\n<p><strong>Error Recovery Tests:</strong></p>\n<p>The tokenizer should handle malformed input gracefully and provide helpful error messages rather than crashing or producing incorrect token sequences.</p>\n<table>\n<thead>\n<tr>\n<th>Malformed Input</th>\n<th>Expected Behavior</th>\n<th>Error Type</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>&quot;unclosed string</code></td>\n<td><code>TokenizerError</code> with position</td>\n<td>Unterminated string literal</td>\n<td>Stop at end of line</td>\n</tr>\n<tr>\n<td><code>&quot;bad\\escape&quot;</code></td>\n<td><code>TokenizerError</code> with position</td>\n<td>Invalid escape sequence</td>\n<td>Skip invalid escape</td>\n</tr>\n<tr>\n<td><code>123.45.67</code></td>\n<td><code>TokenizerError</code> with position</td>\n<td>Invalid number format</td>\n<td>Treat as separate tokens</td>\n</tr>\n<tr>\n<td><code>\\invalid</code></td>\n<td><code>TokenizerError</code> with position</td>\n<td>Invalid character</td>\n<td>Skip character, continue</td>\n</tr>\n</tbody></table>\n<h4 id=\"parser-unit-testing\">Parser Unit Testing</h4>\n<p>Parser testing focuses on <strong>structural correctness</strong> and <strong>syntactic transformation accuracy</strong>. The parser must correctly build nested data structures from token sequences, handle quote syntax transformation, and detect structural errors like unbalanced parentheses.</p>\n<p><strong>Structural Building Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Token Sequence</th>\n<th>Expected AST Structure</th>\n<th>Structural Challenge</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>[NUMBER(42)]</code></td>\n<td><code>LispValue(type=NUMBER, value=42)</code></td>\n<td>Simple atom parsing</td>\n</tr>\n<tr>\n<td><code>[SYMBOL(&quot;x&quot;)]</code></td>\n<td><code>LispValue(type=SYMBOL, value=&quot;x&quot;)</code></td>\n<td>Symbol atom parsing</td>\n</tr>\n<tr>\n<td><code>[LEFT_PAREN, RIGHT_PAREN]</code></td>\n<td><code>LispValue(type=LIST, value=[])</code></td>\n<td>Empty list construction</td>\n</tr>\n<tr>\n<td><code>[LEFT_PAREN, NUMBER(1), NUMBER(2), RIGHT_PAREN]</code></td>\n<td><code>LispValue(type=LIST, value=[1, 2])</code></td>\n<td>Simple list construction</td>\n</tr>\n<tr>\n<td><code>[LEFT_PAREN, LEFT_PAREN, RIGHT_PAREN, RIGHT_PAREN]</code></td>\n<td><code>LispValue(type=LIST, value=[[]])</code></td>\n<td>Nested list construction</td>\n</tr>\n</tbody></table>\n<p><strong>Nested Structure Tests:</strong></p>\n<p>Testing deeply nested structures verifies that the recursive descent parser correctly handles arbitrary nesting depths without stack overflow or structural corruption.</p>\n<table>\n<thead>\n<tr>\n<th>Input Expression</th>\n<th>Nesting Depth</th>\n<th>Expected Structure</th>\n<th>Recursive Challenge</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(((1)))</code></td>\n<td>3</td>\n<td><code>[[[1]]]</code></td>\n<td>Triple-nested list</td>\n</tr>\n<tr>\n<td><code>(a (b (c)))</code></td>\n<td>3</td>\n<td><code>[a, [b, [c]]]</code></td>\n<td>Mixed nesting</td>\n</tr>\n<tr>\n<td><code>((1 2) (3 4))</code></td>\n<td>2</td>\n<td><code>[[1, 2], [3, 4]]</code></td>\n<td>Parallel nesting</td>\n</tr>\n<tr>\n<td><code>(+ (* 2 3) (- 4 1))</code></td>\n<td>2</td>\n<td><code>[+, [*, 2, 3], [-, 4, 1]]</code></td>\n<td>Arithmetic nesting</td>\n</tr>\n</tbody></table>\n<p><strong>Quote Transformation Tests:</strong></p>\n<p>The parser must correctly transform quote shorthand syntax <code>&#39;expr</code> into the expanded form <code>(quote expr)</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Quoted Expression</th>\n<th>Expected Transformation</th>\n<th>Transformation Rule</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>&#39;a</code></td>\n<td><code>(quote a)</code></td>\n<td>Simple symbol quote</td>\n</tr>\n<tr>\n<td><code>&#39;(a b)</code></td>\n<td><code>(quote (a b))</code></td>\n<td>List quote</td>\n</tr>\n<tr>\n<td><code>&#39;(quote a)</code></td>\n<td><code>(quote (quote a))</code></td>\n<td>Nested quote</td>\n</tr>\n<tr>\n<td><code>(f &#39;x)</code></td>\n<td><code>(f (quote x))</code></td>\n<td>Quote in function call</td>\n</tr>\n</tbody></table>\n<p><strong>Parser Error Detection Tests:</strong></p>\n<p>The parser should detect structural errors and report them with helpful location information.</p>\n<table>\n<thead>\n<tr>\n<th>Malformed Input</th>\n<th>Error Type</th>\n<th>Error Message Pattern</th>\n<th>Detection Point</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(+ 1 2</code></td>\n<td><code>ParseError</code></td>\n<td>&quot;Unclosed parenthesis at position X&quot;</td>\n<td>End of token stream</td>\n</tr>\n<tr>\n<td><code>+ 1 2)</code></td>\n<td><code>ParseError</code></td>\n<td>&quot;Unexpected closing parenthesis at position X&quot;</td>\n<td>Unmatched closer</td>\n</tr>\n<tr>\n<td><code>(())</code></td>\n<td>Valid</td>\n<td>No error</td>\n<td>Properly nested</td>\n</tr>\n<tr>\n<td><code>)</code></td>\n<td><code>ParseError</code></td>\n<td>&quot;Unexpected closing parenthesis at position 0&quot;</td>\n<td>Immediate mismatch</td>\n</tr>\n</tbody></table>\n<h4 id=\"evaluator-unit-testing\">Evaluator Unit Testing</h4>\n<p>Evaluator testing focuses on <strong>semantic correctness</strong> and <strong>type safety</strong>. The evaluator must correctly implement Lisp evaluation rules, maintain environment consistency, and handle both successful computations and error conditions.</p>\n<p><strong>Expression Type Dispatch Tests:</strong></p>\n<p>The evaluator&#39;s main <code>evaluate</code> function must correctly identify expression types and dispatch to appropriate handlers.</p>\n<table>\n<thead>\n<tr>\n<th>Expression</th>\n<th>Expression Type</th>\n<th>Handler Called</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>42</code></td>\n<td>Self-evaluating number</td>\n<td>Direct return</td>\n<td>Returns <code>LispValue(NUMBER, 42)</code></td>\n</tr>\n<tr>\n<td><code>x</code></td>\n<td>Symbol lookup</td>\n<td>Environment lookup</td>\n<td>Returns bound value or <code>NameError</code></td>\n</tr>\n<tr>\n<td><code>(+ 1 2)</code></td>\n<td>Function call</td>\n<td>Function application</td>\n<td>Evaluates args, applies function</td>\n</tr>\n<tr>\n<td><code>(if #t 1 2)</code></td>\n<td>Special form</td>\n<td>Special form handler</td>\n<td>Conditional evaluation</td>\n</tr>\n<tr>\n<td><code>(define x 5)</code></td>\n<td>Special form</td>\n<td>Define handler</td>\n<td>Environment binding</td>\n</tr>\n</tbody></table>\n<p><strong>Arithmetic Operation Tests:</strong></p>\n<p>Built-in arithmetic functions must handle various numeric types and argument counts correctly.</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Arguments</th>\n<th>Expected Result</th>\n<th>Error Condition</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(+ 1 2)</code></td>\n<td><code>[1, 2]</code></td>\n<td><code>3</code></td>\n<td>None</td>\n</tr>\n<tr>\n<td><code>(+ 1 2 3)</code></td>\n<td><code>[1, 2, 3]</code></td>\n<td><code>6</code></td>\n<td>None</td>\n</tr>\n<tr>\n<td><code>(+)</code></td>\n<td><code>[]</code></td>\n<td><code>0</code></td>\n<td>None (identity)</td>\n</tr>\n<tr>\n<td><code>(- 5 2)</code></td>\n<td><code>[5, 2]</code></td>\n<td><code>3</code></td>\n<td>None</td>\n</tr>\n<tr>\n<td><code>(-)</code></td>\n<td><code>[]</code></td>\n<td><code>ArityError</code></td>\n<td>Too few arguments</td>\n</tr>\n<tr>\n<td><code>(/ 6 2)</code></td>\n<td><code>[6, 2]</code></td>\n<td><code>3</code></td>\n<td>None</td>\n</tr>\n<tr>\n<td><code>(/ 1 0)</code></td>\n<td><code>[1, 0]</code></td>\n<td><code>EvaluationError</code></td>\n<td>Division by zero</td>\n</tr>\n</tbody></table>\n<p><strong>Comparison Operation Tests:</strong></p>\n<p>Comparison functions must handle numeric comparisons and return proper boolean values.</p>\n<table>\n<thead>\n<tr>\n<th>Comparison</th>\n<th>Arguments</th>\n<th>Expected Result</th>\n<th>Type Requirement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(&lt; 1 2)</code></td>\n<td><code>[1, 2]</code></td>\n<td><code>LISP_TRUE</code></td>\n<td>Both numbers</td>\n</tr>\n<tr>\n<td><code>(&gt; 2 1)</code></td>\n<td><code>[2, 1]</code></td>\n<td><code>LISP_TRUE</code></td>\n<td>Both numbers</td>\n</tr>\n<tr>\n<td><code>(= 1 1)</code></td>\n<td><code>[1, 1]</code></td>\n<td><code>LISP_TRUE</code></td>\n<td>Both numbers</td>\n</tr>\n<tr>\n<td><code>(&lt; 2 1)</code></td>\n<td><code>[2, 1]</code></td>\n<td><code>LISP_FALSE</code></td>\n<td>Both numbers</td>\n</tr>\n<tr>\n<td><code>(&lt; 1 &quot;x&quot;)</code></td>\n<td><code>[1, &quot;x&quot;]</code></td>\n<td><code>TypeError</code></td>\n<td>Type mismatch</td>\n</tr>\n</tbody></table>\n<p><strong>Special Form Tests:</strong></p>\n<p>Special forms require careful testing because they control evaluation order and environment modification.</p>\n<table>\n<thead>\n<tr>\n<th>Special Form</th>\n<th>Test Input</th>\n<th>Expected Behavior</th>\n<th>Evaluation Rule</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>if</code></td>\n<td><code>(if #t 1 2)</code></td>\n<td>Returns <code>1</code></td>\n<td>Evaluates test, then appropriate branch</td>\n</tr>\n<tr>\n<td><code>if</code></td>\n<td><code>(if #f 1 2)</code></td>\n<td>Returns <code>2</code></td>\n<td>Evaluates test, then appropriate branch</td>\n</tr>\n<tr>\n<td><code>define</code></td>\n<td><code>(define x 5)</code></td>\n<td>Binds <code>x</code> to <code>5</code></td>\n<td>Evaluates value, binds to name</td>\n</tr>\n<tr>\n<td><code>lambda</code></td>\n<td><code>(lambda (x) x)</code></td>\n<td>Creates function</td>\n<td>Creates closure with parameters</td>\n</tr>\n<tr>\n<td><code>quote</code></td>\n<td><code>(quote (+ 1 2))</code></td>\n<td>Returns <code>(+ 1 2)</code> unevaluated</td>\n<td>No evaluation of argument</td>\n</tr>\n</tbody></table>\n<h3 id=\"integration-testing-strategy\">Integration Testing Strategy</h3>\n<p>Integration testing verifies that the tokenizer, parser, and evaluator work correctly together to process complete Lisp expressions from source text to final results. Unlike unit testing, which isolates individual components, integration testing focuses on <strong>component interactions</strong>, <strong>data flow consistency</strong>, and <strong>end-to-end correctness</strong>.</p>\n<p>The core principle of interpreter integration testing is <strong>pipeline validation</strong>: ensuring that data flows correctly through the three-stage pipeline without loss of information or introduction of errors. This requires testing not just that each stage produces correct output, but that the output from each stage serves as correct input to the next stage. For example, the tokenizer must produce tokens that the parser can consume without ambiguity, and the parser must produce AST nodes that the evaluator can process according to Lisp semantics.</p>\n<h4 id=\"pipeline-integration-tests\">Pipeline Integration Tests</h4>\n<p>Pipeline integration tests verify the complete flow from source text through tokenization, parsing, and evaluation to final results. These tests ensure that the three components work together seamlessly and that complex expressions evaluate correctly.</p>\n<p><strong>Complete Expression Processing Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Source Text</th>\n<th>Tokenizer Output</th>\n<th>Parser Output</th>\n<th>Evaluator Output</th>\n<th>Integration Point</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>42</code></td>\n<td><code>[NUMBER(42)]</code></td>\n<td><code>LispValue(NUMBER, 42)</code></td>\n<td><code>42</code></td>\n<td>Simple atom pipeline</td>\n</tr>\n<tr>\n<td><code>(+ 1 2)</code></td>\n<td><code>[LEFT_PAREN, SYMBOL(&quot;+&quot;), NUMBER(1), NUMBER(2), RIGHT_PAREN]</code></td>\n<td><code>[+, 1, 2]</code></td>\n<td><code>3</code></td>\n<td>Function call pipeline</td>\n</tr>\n<tr>\n<td><code>&#39;(a b)</code></td>\n<td><code>[QUOTE, LEFT_PAREN, SYMBOL(&quot;a&quot;), SYMBOL(&quot;b&quot;), RIGHT_PAREN]</code></td>\n<td><code>(quote (a b))</code></td>\n<td><code>(a b)</code></td>\n<td>Quote transformation pipeline</td>\n</tr>\n<tr>\n<td><code>(if #t (+ 1 2) 3)</code></td>\n<td>Token sequence</td>\n<td><code>[if, #t, [+, 1, 2], 3]</code></td>\n<td><code>3</code></td>\n<td>Conditional evaluation pipeline</td>\n</tr>\n</tbody></table>\n<p><strong>Multi-Expression Session Tests:</strong></p>\n<p>These tests verify that the interpreter maintains consistent state across multiple expression evaluations, particularly for variable definitions and function definitions.</p>\n<table>\n<thead>\n<tr>\n<th>Expression Sequence</th>\n<th>Expected Results</th>\n<th>State Changes</th>\n<th>Persistence Test</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(define x 5)</code>, <code>x</code></td>\n<td><code>x</code>, <code>5</code></td>\n<td><code>x</code> bound to <code>5</code></td>\n<td>Variable definition persistence</td>\n</tr>\n<tr>\n<td><code>(define f (lambda (x) (+ x 1)))</code>, <code>(f 2)</code></td>\n<td><code>f</code>, <code>3</code></td>\n<td><code>f</code> bound to function</td>\n<td>Function definition persistence</td>\n</tr>\n<tr>\n<td><code>(define x 1)</code>, <code>(define x 2)</code>, <code>x</code></td>\n<td><code>x</code>, <code>x</code>, <code>2</code></td>\n<td><code>x</code> rebound to <code>2</code></td>\n<td>Variable redefinition</td>\n</tr>\n<tr>\n<td><code>(let ((x 1)) x)</code>, <code>(define x 2)</code>, <code>x</code></td>\n<td><code>1</code>, <code>x</code>, <code>2</code></td>\n<td>Local scope, then global</td>\n<td>Scope isolation</td>\n</tr>\n</tbody></table>\n<p><strong>Error Propagation Integration Tests:</strong></p>\n<p>Integration tests must verify that errors detected at any stage of the pipeline are properly propagated and enriched with contextual information as they move upward through the system.</p>\n<table>\n<thead>\n<tr>\n<th>Input with Error</th>\n<th>Error Source</th>\n<th>Expected Error Type</th>\n<th>Error Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>&quot;unclosed</code></td>\n<td>Tokenizer</td>\n<td><code>TokenizerError</code></td>\n<td>Character position in source</td>\n</tr>\n<tr>\n<td><code>(+ 1 2</code></td>\n<td>Parser</td>\n<td><code>ParseError</code></td>\n<td>Token position and nesting context</td>\n</tr>\n<tr>\n<td><code>(+ 1 &quot;x&quot;)</code></td>\n<td>Evaluator</td>\n<td><code>TypeError</code></td>\n<td>Expression context and type info</td>\n</tr>\n<tr>\n<td><code>undefined_var</code></td>\n<td>Evaluator</td>\n<td><code>NameError</code></td>\n<td>Environment context and suggestions</td>\n</tr>\n</tbody></table>\n<h4 id=\"environment-integration-tests\">Environment Integration Tests</h4>\n<p>Environment integration testing verifies that lexical scoping, variable binding, and closure capture work correctly across the complete evaluation pipeline. These tests are crucial because environment management involves complex interactions between the parser (which identifies variable references) and the evaluator (which resolves bindings and creates closures).</p>\n<p><strong>Lexical Scoping Integration Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Lisp Program</th>\n<th>Expected Result</th>\n<th>Scoping Challenge</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>((lambda (x) x) 5)</code></td>\n<td><code>5</code></td>\n<td>Simple parameter binding</td>\n</tr>\n<tr>\n<td><code>((lambda (x) ((lambda (y) x) 2)) 1)</code></td>\n<td><code>1</code></td>\n<td>Nested scope access to outer variable</td>\n</tr>\n<tr>\n<td><code>(let ((x 1)) (let ((x 2)) x))</code></td>\n<td><code>2</code></td>\n<td>Variable shadowing</td>\n</tr>\n<tr>\n<td><code>(let ((x 1)) (let ((y 2)) x))</code></td>\n<td><code>1</code></td>\n<td>Nested scope access without shadowing</td>\n</tr>\n</tbody></table>\n<p><strong>Closure Capture Integration Tests:</strong></p>\n<p>These tests verify that lambda functions correctly capture their lexical environment and can access captured variables even after the defining scope has exited.</p>\n<table>\n<thead>\n<tr>\n<th>Closure Definition</th>\n<th>Usage Context</th>\n<th>Expected Behavior</th>\n<th>Capture Test</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(let ((x 5)) (lambda () x))</code></td>\n<td>Call returned function</td>\n<td>Returns <code>5</code></td>\n<td>Captures local variable</td>\n</tr>\n<tr>\n<td><code>(let ((x 1)) (let ((x 2)) (lambda () x)))</code></td>\n<td>Call returned function</td>\n<td>Returns <code>2</code></td>\n<td>Captures innermost binding</td>\n</tr>\n<tr>\n<td><code>(define make-adder (lambda (n) (lambda (x) (+ n x))))</code></td>\n<td><code>((make-adder 5) 3)</code></td>\n<td>Returns <code>8</code></td>\n<td>Captures parameter from outer function</td>\n</tr>\n</tbody></table>\n<h4 id=\"state-persistence-integration-tests\">State Persistence Integration Tests</h4>\n<p>State persistence integration tests verify that the global environment correctly maintains variable and function definitions across multiple evaluation cycles, which is essential for REPL-style interaction and building up complex programs incrementally.</p>\n<p><strong>Global Environment Persistence Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Evaluation Sequence</th>\n<th>Global State After Each Step</th>\n<th>Persistence Verification</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(define pi 3.14)</code></td>\n<td><code>{pi: 3.14}</code></td>\n<td>Variable persists</td>\n</tr>\n<tr>\n<td><code>(define circle-area (lambda (r) (* pi (* r r))))</code></td>\n<td><code>{pi: 3.14, circle-area: &lt;function&gt;}</code></td>\n<td>Function persists with closure</td>\n</tr>\n<tr>\n<td><code>(circle-area 2)</code></td>\n<td>Same as previous</td>\n<td>Function application doesn&#39;t modify globals</td>\n</tr>\n</tbody></table>\n<p><strong>Environment Chain Integration Tests:</strong></p>\n<p>These tests verify that the environment chain correctly supports nested scopes and that variable lookups traverse the chain in the correct order.</p>\n<table>\n<thead>\n<tr>\n<th>Test Program</th>\n<th>Environment Chain Structure</th>\n<th>Lookup Path</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(let ((x 1)) ((lambda (y) (+ x y)) 2))</code></td>\n<td>Global → Let → Lambda</td>\n<td><code>x</code> found in Let, <code>y</code> found in Lambda</td>\n</tr>\n<tr>\n<td><code>(define x 0) (let ((x 1)) ((lambda () x)))</code></td>\n<td>Global → Let → Lambda</td>\n<td><code>x</code> found in Let (shadows Global)</td>\n</tr>\n</tbody></table>\n<h3 id=\"milestone-validation-checkpoints\">Milestone Validation Checkpoints</h3>\n<p>Milestone validation checkpoints provide concrete verification criteria for each stage of interpreter development. These checkpoints help learners confirm that their implementation is working correctly before proceeding to the next milestone, preventing the accumulation of bugs that become harder to diagnose in more complex functionality.</p>\n<p>Each checkpoint includes <strong>functional tests</strong> (verifying that features work as specified), <strong>regression tests</strong> (ensuring that new features don&#39;t break existing functionality), and <strong>integration tests</strong> (confirming that components work together correctly). The checkpoint also includes <strong>debugging guidance</strong> to help learners diagnose common problems that arise at each milestone.</p>\n<h4 id=\"milestone-1-checkpoint-s-expression-parser\">Milestone 1 Checkpoint: S-Expression Parser</h4>\n<p>After completing Milestone 1, learners should have a working tokenizer and parser that can convert Lisp source text into nested data structures. The validation checkpoint focuses on structural correctness and error handling.</p>\n<p><strong>Tokenizer Validation Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Input Text</th>\n<th>Expected Token Stream</th>\n<th>Pass/Fail Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>42</code></td>\n<td><code>[NUMBER(42), EOF]</code></td>\n<td>Correct number parsing</td>\n</tr>\n<tr>\n<td><code>hello</code></td>\n<td><code>[SYMBOL(&quot;hello&quot;), EOF]</code></td>\n<td>Correct symbol parsing</td>\n</tr>\n<tr>\n<td><code>&quot;world&quot;</code></td>\n<td><code>[STRING(&quot;world&quot;), EOF]</code></td>\n<td>Correct string parsing</td>\n</tr>\n<tr>\n<td><code>(+ 1 2)</code></td>\n<td><code>[LEFT_PAREN, SYMBOL(&quot;+&quot;), NUMBER(1), NUMBER(2), RIGHT_PAREN, EOF]</code></td>\n<td>Correct token sequence</td>\n</tr>\n<tr>\n<td><code>&#39;(a b)</code></td>\n<td><code>[QUOTE, LEFT_PAREN, SYMBOL(&quot;a&quot;), SYMBOL(&quot;b&quot;), RIGHT_PAREN, EOF]</code></td>\n<td>Quote handling</td>\n</tr>\n<tr>\n<td><code>;comment\\n(test)</code></td>\n<td><code>[LEFT_PAREN, SYMBOL(&quot;test&quot;), RIGHT_PAREN, EOF]</code></td>\n<td>Comment removal</td>\n</tr>\n</tbody></table>\n<p><strong>Parser Validation Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Token Stream</th>\n<th>Expected AST</th>\n<th>Structural Correctness</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>[NUMBER(42), EOF]</code></td>\n<td><code>LispValue(NUMBER, 42)</code></td>\n<td>Simple atom</td>\n</tr>\n<tr>\n<td><code>[LEFT_PAREN, RIGHT_PAREN, EOF]</code></td>\n<td><code>LispValue(LIST, [])</code></td>\n<td>Empty list</td>\n</tr>\n<tr>\n<td><code>[LEFT_PAREN, NUMBER(1), NUMBER(2), RIGHT_PAREN, EOF]</code></td>\n<td><code>LispValue(LIST, [1, 2])</code></td>\n<td>Simple list</td>\n</tr>\n<tr>\n<td><code>[QUOTE, SYMBOL(&quot;x&quot;), EOF]</code></td>\n<td><code>LispValue(LIST, [quote, x])</code></td>\n<td>Quote transformation</td>\n</tr>\n</tbody></table>\n<p><strong>Error Handling Validation:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Malformed Input</th>\n<th>Expected Error</th>\n<th>Error Quality</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>&quot;unclosed</code></td>\n<td><code>TokenizerError</code> with position</td>\n<td>Helpful error message</td>\n</tr>\n<tr>\n<td><code>(unclosed</code></td>\n<td><code>ParseError</code> with context</td>\n<td>Structural error detection</td>\n</tr>\n<tr>\n<td><code>unexpected)</code></td>\n<td><code>ParseError</code> with position</td>\n<td>Unmatched parenthesis detection</td>\n</tr>\n</tbody></table>\n<p><strong>Milestone 1 Manual Testing:</strong></p>\n<ol>\n<li>Create a simple test program that calls <code>tokenize()</code> on various input strings</li>\n<li>Verify that each token has the correct type and value</li>\n<li>Create a test program that calls <code>parse()</code> on token streams</li>\n<li>Verify that the resulting AST has the expected nested structure</li>\n<li>Test error conditions and verify that helpful error messages are produced</li>\n</ol>\n<h4 id=\"milestone-2-checkpoint-basic-evaluation\">Milestone 2 Checkpoint: Basic Evaluation</h4>\n<p>After completing Milestone 2, learners should have a working evaluator that can handle arithmetic operations, comparisons, and conditional expressions. The validation checkpoint focuses on computational correctness and error handling.</p>\n<p><strong>Arithmetic Evaluation Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Expression</th>\n<th>Expected Result</th>\n<th>Correctness Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>42</code></td>\n<td><code>42</code></td>\n<td>Self-evaluating numbers</td>\n</tr>\n<tr>\n<td><code>(+ 1 2)</code></td>\n<td><code>3</code></td>\n<td>Addition operator</td>\n</tr>\n<tr>\n<td><code>(- 5 2)</code></td>\n<td><code>3</code></td>\n<td>Subtraction operator</td>\n</tr>\n<tr>\n<td><code>(* 3 4)</code></td>\n<td><code>12</code></td>\n<td>Multiplication operator</td>\n</tr>\n<tr>\n<td><code>(/ 8 2)</code></td>\n<td><code>4</code></td>\n<td>Division operator</td>\n</tr>\n<tr>\n<td><code>(+ 1 2 3)</code></td>\n<td><code>6</code></td>\n<td>Multiple arguments</td>\n</tr>\n</tbody></table>\n<p><strong>Comparison Evaluation Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Expression</th>\n<th>Expected Result</th>\n<th>Boolean Correctness</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(&lt; 1 2)</code></td>\n<td><code>LISP_TRUE</code></td>\n<td>Less than comparison</td>\n</tr>\n<tr>\n<td><code>(&gt; 2 1)</code></td>\n<td><code>LISP_TRUE</code></td>\n<td>Greater than comparison</td>\n</tr>\n<tr>\n<td><code>(= 1 1)</code></td>\n<td><code>LISP_TRUE</code></td>\n<td>Equality comparison</td>\n</tr>\n<tr>\n<td><code>(&lt; 2 1)</code></td>\n<td><code>LISP_FALSE</code></td>\n<td>False comparison result</td>\n</tr>\n</tbody></table>\n<p><strong>Conditional Evaluation Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Expression</th>\n<th>Expected Result</th>\n<th>Control Flow Correctness</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(if #t 1 2)</code></td>\n<td><code>1</code></td>\n<td>True branch selection</td>\n</tr>\n<tr>\n<td><code>(if #f 1 2)</code></td>\n<td><code>2</code></td>\n<td>False branch selection</td>\n</tr>\n<tr>\n<td><code>(if (&lt; 1 2) &quot;yes&quot; &quot;no&quot;)</code></td>\n<td><code>&quot;yes&quot;</code></td>\n<td>Computed test condition</td>\n</tr>\n</tbody></table>\n<p><strong>Milestone 2 Manual Testing:</strong></p>\n<ol>\n<li>Create a REPL-style test program that evaluates expressions and prints results</li>\n<li>Test all arithmetic operators with various argument patterns</li>\n<li>Test all comparison operators with different numeric relationships</li>\n<li>Test conditional expressions with both literal and computed test conditions</li>\n<li>Verify that type errors produce helpful error messages</li>\n</ol>\n<h4 id=\"milestone-3-checkpoint-variables-and-functions\">Milestone 3 Checkpoint: Variables and Functions</h4>\n<p>After completing Milestone 3, learners should have support for variable definitions, lambda functions, and lexical scoping. The validation checkpoint focuses on environment management and closure correctness.</p>\n<p><strong>Variable Definition and Lookup Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Expression Sequence</th>\n<th>Expected Results</th>\n<th>Environment Correctness</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(define x 5)</code>, <code>x</code></td>\n<td><code>x</code>, <code>5</code></td>\n<td>Variable binding and lookup</td>\n</tr>\n<tr>\n<td><code>(define x 1)</code>, <code>(define x 2)</code>, <code>x</code></td>\n<td><code>x</code>, <code>x</code>, <code>2</code></td>\n<td>Variable redefinition</td>\n</tr>\n<tr>\n<td><code>undefined_var</code></td>\n<td><code>NameError</code></td>\n<td>Undefined variable detection</td>\n</tr>\n</tbody></table>\n<p><strong>Lambda Function Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Expression</th>\n<th>Expected Result</th>\n<th>Function Correctness</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>((lambda (x) x) 5)</code></td>\n<td><code>5</code></td>\n<td>Identity function</td>\n</tr>\n<tr>\n<td><code>((lambda (x y) (+ x y)) 1 2)</code></td>\n<td><code>3</code></td>\n<td>Multi-parameter function</td>\n</tr>\n<tr>\n<td><code>((lambda () 42))</code></td>\n<td><code>42</code></td>\n<td>Zero-parameter function</td>\n</tr>\n</tbody></table>\n<p><strong>Lexical Scoping Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Expression</th>\n<th>Expected Result</th>\n<th>Scoping Correctness</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>((lambda (x) ((lambda (y) x) 2)) 1)</code></td>\n<td><code>1</code></td>\n<td>Closure captures outer variable</td>\n</tr>\n<tr>\n<td><code>(let ((x 1)) (let ((x 2)) x))</code></td>\n<td><code>2</code></td>\n<td>Variable shadowing</td>\n</tr>\n<tr>\n<td><code>(define x 0) ((lambda (x) x) 5)</code></td>\n<td><code>5</code></td>\n<td>Parameter shadows global</td>\n</tr>\n</tbody></table>\n<p><strong>Milestone 3 Manual Testing:</strong></p>\n<ol>\n<li>Test variable definition and lookup in isolation</li>\n<li>Test lambda function creation and application</li>\n<li>Test nested function calls with parameter passing</li>\n<li>Test closure behavior by creating functions that capture variables</li>\n<li>Test let expressions for local variable binding</li>\n</ol>\n<h4 id=\"milestone-4-checkpoint-list-operations-amp-recursion\">Milestone 4 Checkpoint: List Operations &amp; Recursion</h4>\n<p>After completing Milestone 4, learners should have support for list operations (car, cdr, cons) and recursive function definitions. The validation checkpoint focuses on list manipulation correctness and recursion handling.</p>\n<p><strong>List Primitive Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Expression</th>\n<th>Expected Result</th>\n<th>List Operation Correctness</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(cons 1 2)</code></td>\n<td><code>(1 . 2)</code></td>\n<td>Cons cell creation</td>\n</tr>\n<tr>\n<td><code>(car (cons 1 2))</code></td>\n<td><code>1</code></td>\n<td>Car extraction</td>\n</tr>\n<tr>\n<td><code>(cdr (cons 1 2))</code></td>\n<td><code>2</code></td>\n<td>Cdr extraction</td>\n</tr>\n<tr>\n<td><code>(list 1 2 3)</code></td>\n<td><code>(1 2 3)</code></td>\n<td>Proper list construction</td>\n</tr>\n<tr>\n<td><code>(null? &#39;())</code></td>\n<td><code>LISP_TRUE</code></td>\n<td>Empty list detection</td>\n</tr>\n<tr>\n<td><code>(null? &#39;(1))</code></td>\n<td><code>LISP_FALSE</code></td>\n<td>Non-empty list detection</td>\n</tr>\n</tbody></table>\n<p><strong>Recursive Function Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Function Definition</th>\n<th>Test Call</th>\n<th>Expected Result</th>\n<th>Recursion Correctness</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(define factorial (lambda (n) (if (= n 0) 1 (* n (factorial (- n 1))))))</code></td>\n<td><code>(factorial 5)</code></td>\n<td><code>120</code></td>\n<td>Basic recursion</td>\n</tr>\n<tr>\n<td><code>(define length (lambda (lst) (if (null? lst) 0 (+ 1 (length (cdr lst))))))</code></td>\n<td><code>(length &#39;(a b c))</code></td>\n<td><code>3</code></td>\n<td>List recursion</td>\n</tr>\n</tbody></table>\n<p><strong>List Processing Integration Tests:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Expression</th>\n<th>Expected Result</th>\n<th>Integration Correctness</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>(car &#39;(a b c))</code></td>\n<td><code>a</code></td>\n<td>Quote and car integration</td>\n</tr>\n<tr>\n<td><code>(cdr &#39;(a))</code></td>\n<td><code>()</code></td>\n<td>Single-element list handling</td>\n</tr>\n<tr>\n<td><code>(cons &#39;a &#39;(b c))</code></td>\n<td><code>(a b c)</code></td>\n<td>Cons with proper list</td>\n</tr>\n</tbody></table>\n<p><strong>Milestone 4 Manual Testing:</strong></p>\n<ol>\n<li>Test all list primitives (car, cdr, cons, list, null?) individually</li>\n<li>Test recursive function definitions that call themselves</li>\n<li>Test list processing functions that combine multiple primitives</li>\n<li>Test tail recursion optimization if implemented</li>\n<li>Verify that deep recursion doesn&#39;t cause stack overflow</li>\n</ol>\n<h3 id=\"common-testing-pitfalls\">Common Testing Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Testing Components in the Wrong Order</strong></p>\n<p>Many learners attempt to test the evaluator before thoroughly testing the tokenizer and parser. This leads to confusing debugging sessions where evaluation bugs mask parsing bugs, and parsing bugs mask tokenization bugs. The symptom is that simple expressions fail to evaluate correctly, but the actual problem is in an earlier pipeline stage.</p>\n<p><strong>Why this is problematic:</strong> Interpreter bugs cascade upward through the pipeline. If the tokenizer produces incorrect tokens, the parser will build incorrect ASTs, and the evaluator will produce incorrect results. Testing the evaluator first means you&#39;re debugging three components simultaneously instead of isolating the actual source of the problem.</p>\n<p><strong>How to avoid it:</strong> Always test components in dependency order: tokenizer first, then parser, then evaluator. Don&#39;t proceed to integration testing until each component passes its unit tests. Create helper functions that let you inspect intermediate results at each pipeline stage.</p>\n<p>⚠️ <strong>Pitfall: Insufficient Edge Case Coverage</strong></p>\n<p>Learners often test only the &quot;happy path&quot; scenarios where input is well-formed and operations succeed. They miss edge cases like empty lists, undefined variables, division by zero, deeply nested structures, and malformed input. The symptom is that the interpreter works fine during initial testing but crashes or behaves incorrectly when given unexpected input.</p>\n<p><strong>Why this is problematic:</strong> Real-world Lisp programs contain errors, edge cases, and boundary conditions. An interpreter that only handles perfect input is not robust enough for practical use. Edge case bugs are often the most difficult to diagnose because they manifest in unusual circumstances.</p>\n<p><strong>How to avoid it:</strong> For every feature you implement, create a &quot;boundary conditions&quot; test suite that covers empty input, maximum input, malformed input, and type mismatches. Test what happens when operations receive no arguments, too many arguments, or arguments of the wrong type.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Error Message Quality</strong></p>\n<p>Many implementations focus on detecting errors correctly but produce cryptic error messages that don&#39;t help users understand what went wrong or how to fix it. The symptom is that the interpreter correctly identifies error conditions but users can&#39;t diagnose their mistakes from the error output.</p>\n<p><strong>Why this is problematic:</strong> Error messages are part of the user interface. Poor error messages make the interpreter difficult to use and debug, even when the underlying implementation is correct. Users need to understand not just that an error occurred, but where it occurred and how to fix it.</p>\n<p><strong>How to avoid it:</strong> Test error messages as carefully as you test correct behavior. Verify that error messages include source location information, describe what was expected versus what was found, and suggest corrections when possible. Create tests that verify the text content of error messages, not just their error types.</p>\n<p>⚠️ <strong>Pitfall: Testing Only Isolated Components</strong></p>\n<p>Some learners thoroughly test individual components but skip integration testing that verifies components work together correctly. The symptom is that individual unit tests pass, but complete expressions fail to evaluate correctly due to data format mismatches or incorrect assumptions about component interfaces.</p>\n<p><strong>Why this is problematic:</strong> Interpreters are complex systems where components must cooperate precisely. The tokenizer must produce tokens in the format the parser expects, and the parser must produce ASTs in the format the evaluator expects. Component interface mismatches only become apparent during integration testing.</p>\n<p><strong>How to avoid it:</strong> After unit testing each component, create integration tests that exercise the complete pipeline from source text to final results. Test that data flows correctly through all three stages and that errors are properly propagated and enriched as they move upward through the system.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The testing strategy for a Lisp interpreter requires a structured approach that builds confidence incrementally while providing rapid feedback during development. This implementation guidance provides concrete code structures and testing patterns specifically designed for Python-based interpreter development.</p>\n<h4 id=\"testing-framework-setup\">Testing Framework Setup</h4>\n<p><strong>Testing Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Test Framework</td>\n<td><code>unittest</code> (standard library)</td>\n<td><code>pytest</code> with fixtures and parameterization</td>\n</tr>\n<tr>\n<td>Assertion Library</td>\n<td>Built-in <code>assert</code> statements</td>\n<td><code>pytest</code> assertions with detailed failure output</td>\n</tr>\n<tr>\n<td>Test Organization</td>\n<td>Single test file per component</td>\n<td>Test directory structure with shared fixtures</td>\n</tr>\n<tr>\n<td>Coverage Tracking</td>\n<td>Manual verification</td>\n<td><code>coverage.py</code> with branch coverage reporting</td>\n</tr>\n<tr>\n<td>Test Data</td>\n<td>Hardcoded strings in tests</td>\n<td>External test case files with JSON/YAML</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended Test Directory Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>lisp-interpreter/\n  src/\n    tokenizer.py      ← Implementation files\n    parser.py\n    evaluator.py\n    environment.py\n    lisp_types.py\n  tests/\n    test_tokenizer.py      ← Unit tests\n    test_parser.py\n    test_evaluator.py\n    test_environment.py\n    test_integration.py    ← Integration tests\n    test_milestones.py     ← Milestone checkpoints\n    fixtures/\n      test_programs.lisp   ← Sample Lisp programs\n      error_cases.json     ← Error test cases\n    helpers/\n      test_utils.py        ← Testing utility functions</code></pre></div>\n\n<h4 id=\"unit-testing-infrastructure\">Unit Testing Infrastructure</h4>\n<p><strong>Complete Tokenizer Test Framework:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> unittest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.tokenizer </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> tokenize, Token, TokenType, TokenizerError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenizerTestCase</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">unittest</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class providing helper methods for tokenizer testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assertTokenSequence</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, expected_tokens: List[</span><span style=\"color:#79B8FF\">tuple</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify that text produces expected token sequence.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            text: Source text to tokenize</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            expected_tokens: List of (TokenType, value) tuples</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Call tokenize(text) and handle any TokenizerError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Compare actual token count with expected count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For each token, verify type and value match expected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Provide detailed failure message showing actual vs expected</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assertTokenPositions</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, expected_positions: List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify that tokens have correct source positions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Tokenize the text</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract position from each token</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Compare with expected positions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Account for EOF token position</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assertTokenizerError</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, expected_error_pattern: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify that malformed text produces appropriate TokenizerError.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Call tokenize and expect TokenizerError to be raised</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Verify error message matches expected pattern</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify error includes source position information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestBasicTokenization</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TokenizerTestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test basic token recognition and classification.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_number_tokens</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test integer numbers, floating point, negative numbers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_symbol_tokens</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test identifiers, operators, special symbols</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_string_tokens</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test string literals, escape sequences, unterminated strings</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_parenthesis_tokens</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test left and right parentheses as separate tokens</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_quote_tokens</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test single quote as distinct token</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestTokenBoundaries</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">TokenizerTestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test correct identification of token boundaries.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_adjacent_tokens</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.assertTokenSequence(</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"abc+def\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            [(TokenType.</span><span style=\"color:#79B8FF\">SYMBOL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"abc\"</span><span style=\"color:#E1E4E8\">), (TokenType.</span><span style=\"color:#79B8FF\">SYMBOL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"+\"</span><span style=\"color:#E1E4E8\">), (TokenType.</span><span style=\"color:#79B8FF\">SYMBOL</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"def\"</span><span style=\"color:#E1E4E8\">)]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_whitespace_separation</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test that whitespace correctly separates tokens</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_comment_handling</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test that comments are ignored and don't appear in token stream</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Complete Parser Test Framework:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> unittest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> parse, ParseError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.lisp_types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispValue, LispValueType, make_number, make_symbol, make_list</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParserTestCase</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">unittest</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class providing helper methods for parser testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assertParseResult</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, expected_ast: LispValue):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify that text parses to expected AST structure.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Tokenize the text first</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Parse the token stream</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Compare AST structure recursively</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle type differences (numbers, symbols, lists)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assertParseError</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, expected_error_pattern: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify that malformed text produces appropriate ParseError.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Tokenize text and attempt to parse</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Expect ParseError to be raised</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify error message matches pattern</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify error includes structural context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assertASTStructure</span><span style=\"color:#E1E4E8\">(self, ast: LispValue, expected_type: LispValueType):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify AST node has expected type and valid structure.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check that ast.type matches expected_type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For lists, verify all elements are valid LispValues</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For atoms, verify value has correct Python type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestBasicParsing</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ParserTestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test parsing of basic expression types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_atom_parsing</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.assertParseResult(</span><span style=\"color:#9ECBFF\">\"42\"</span><span style=\"color:#E1E4E8\">, make_number(</span><span style=\"color:#79B8FF\">42</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.assertParseResult(</span><span style=\"color:#9ECBFF\">\"hello\"</span><span style=\"color:#E1E4E8\">, make_symbol(</span><span style=\"color:#9ECBFF\">\"hello\"</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add more atom types</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_empty_list_parsing</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.assertParseResult(</span><span style=\"color:#9ECBFF\">\"()\"</span><span style=\"color:#E1E4E8\">, make_list([]))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_simple_list_parsing</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test lists with atoms, nested lists</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_quote_transformation</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Expected: 'x becomes (quote x)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> make_list([make_symbol(</span><span style=\"color:#9ECBFF\">\"quote\"</span><span style=\"color:#E1E4E8\">), make_symbol(</span><span style=\"color:#9ECBFF\">\"x\"</span><span style=\"color:#E1E4E8\">)])</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.assertParseResult(</span><span style=\"color:#9ECBFF\">\"'x\"</span><span style=\"color:#E1E4E8\">, expected)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestNestedParsing</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ParserTestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test parsing of deeply nested structures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_nested_lists</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test ((1 2) (3 4)) and similar patterns</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_deep_nesting</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test (((((1))))) type patterns</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Complete Evaluator Test Framework:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> unittest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.evaluator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> evaluate, create_global_environment, EvaluationError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.lisp_types </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispValue, </span><span style=\"color:#79B8FF\">LISP_TRUE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">LISP_FALSE</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EvaluatorTestCase</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">unittest</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class providing helper methods for evaluator testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> setUp</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create fresh environment for each test.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_global_environment()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assertEvaluatesTo</span><span style=\"color:#E1E4E8\">(self, program: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, expected_result):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify that program evaluates to expected result.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Parse program text into AST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Evaluate AST in test environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Compare result with expected value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle different result types (numbers, booleans, lists)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assertEvaluationError</span><span style=\"color:#E1E4E8\">(self, program: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, error_type: </span><span style=\"color:#79B8FF\">type</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify that program raises expected evaluation error.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Parse program into AST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Attempt evaluation and expect specific error type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify error includes helpful context information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assertEnvironmentBinding</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, expected_value):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify that variable is bound to expected value in environment.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Look up name in current environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Compare bound value with expected value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle case where name is not bound</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestArithmetic</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluatorTestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test arithmetic operator evaluation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_addition</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.assertEvaluatesTo(</span><span style=\"color:#9ECBFF\">\"(+ 1 2)\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.assertEvaluatesTo(</span><span style=\"color:#9ECBFF\">\"(+ 1 2 3)\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test edge cases like (+ ) and (+ 1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_subtraction</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test (- 5 2), (- 10), etc.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_division_by_zero</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.assertEvaluationError(</span><span style=\"color:#9ECBFF\">\"(/ 1 0)\"</span><span style=\"color:#E1E4E8\">, EvaluationError)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestVariables</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluatorTestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test variable definition and lookup.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_define_and_lookup</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Evaluate (define x 5)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Verify x is bound in environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Evaluate x and verify it returns 5</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_undefined_variable</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.assertEvaluationError(</span><span style=\"color:#9ECBFF\">\"undefined_var\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">NameError</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestFunctions</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluatorTestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test lambda functions and application.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_lambda_creation</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test that (lambda (x) x) creates function value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_function_application</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.assertEvaluatesTo(</span><span style=\"color:#9ECBFF\">\"((lambda (x) x) 5)\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test multi-parameter functions</span></span></code></pre></div>\n\n<h4 id=\"integration-testing-framework\">Integration Testing Framework</h4>\n<p><strong>Complete Pipeline Integration Tests:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> unittest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.lisp_interpreter </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispInterpreter, InterpreterSession</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> IntegrationTestCase</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">unittest</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for end-to-end interpreter testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> setUp</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create fresh interpreter session for each test.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.interpreter </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LispInterpreter()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.session </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> InterpreterSession()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assertPipelineResult</span><span style=\"color:#E1E4E8\">(self, source_text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, expected_result):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test complete pipeline from source to result.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Process source_text through complete pipeline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle tokenization, parsing, and evaluation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Compare final result with expected value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify no errors occurred in pipeline</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assertMultiExpressionSequence</span><span style=\"color:#E1E4E8\">(self, expressions: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], expected_results: List):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test sequence of expressions with persistent state.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Evaluate each expression in sequence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Verify each result matches expected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify state persists between expressions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestCompletePrograms</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">IntegrationTestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test evaluation of complete Lisp programs.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_arithmetic_programs</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.assertPipelineResult(</span><span style=\"color:#9ECBFF\">\"(+ (* 2 3) (- 8 3))\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">11</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add more complex arithmetic expressions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_conditional_programs</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.assertPipelineResult(</span><span style=\"color:#9ECBFF\">\"(if (&#x3C; 1 2) (+ 1 1) (- 1 1))\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test nested conditionals</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_function_definition_programs</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        program </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        (define square (lambda (x) (* x x)))</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        (square 4)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle multi-line program evaluation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestErrorPropagation</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">IntegrationTestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test that errors are properly detected and reported.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_tokenizer_error_propagation</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test that tokenizer errors include source context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_parser_error_propagation</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test that parser errors include token context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_evaluator_error_propagation</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test that evaluation errors include expression context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint-implementation\">Milestone Checkpoint Implementation</h4>\n<p><strong>Milestone Validation Test Suite:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> unittest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> tests.helpers.milestone_validator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> MilestoneValidator</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestMilestone1</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">unittest</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validation tests for Milestone 1: S-Expression Parser.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> setUp</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.validator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> MilestoneValidator(</span><span style=\"color:#FFAB70\">milestone</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_tokenizer_requirements</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify all Milestone 1 tokenizer requirements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        test_cases </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#9ECBFF\">\"42\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"number parsing\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#9ECBFF\">\"hello\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"symbol parsing\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#9ECBFF\">'(+ 1 2)'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"parenthesis and operator parsing\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#9ECBFF\">\"'(a b)\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"quote syntax parsing\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#9ECBFF\">\";comment</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">(test)\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"comment handling\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> text, description </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> test_cases:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            with</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.subTest(</span><span style=\"color:#FFAB70\">text</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">text, </span><span style=\"color:#FFAB70\">description</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">description):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Use validator to check tokenizer output</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_parser_requirements</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify all Milestone 1 parser requirements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test nested list construction</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test quote transformation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test error detection for unbalanced parens</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_milestone1_integration</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"End-to-end test of complete Milestone 1 functionality.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test complete pipeline from text to AST</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestMilestone2</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">unittest</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">TestCase</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validation tests for Milestone 2: Basic Evaluation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_arithmetic_evaluation</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify arithmetic operators work correctly.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test +, -, *, / operators</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test multiple arguments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test type checking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_comparison_evaluation</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify comparison operators work correctly.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test &#x3C;, >, =, &#x3C;=, >= operators</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test boolean result values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_conditional_evaluation</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify if expressions work correctly.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test true and false branches</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test computed test conditions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Similar patterns for Milestone 3 and 4...</span></span></code></pre></div>\n\n<p><strong>Debugging Helper Implementation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> debug_pipeline_stages</span><span style=\"color:#E1E4E8\">(source_text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Debug helper that shows pipeline output at each stage.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"=== Debugging Pipeline for: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">source_text</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> ===\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Stage 1: Tokenization</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tokens </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tokenize(source_text)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Tokens:\"</span><span style=\"color:#E1E4E8\">, [(t.type, t.value, t.position) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> t </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> tokens])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#E1E4E8\"> TokenizerError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Tokenization failed: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Stage 2: Parsing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ast </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parse(tokens)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"AST:\"</span><span style=\"color:#E1E4E8\">, ast)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#E1E4E8\"> ParseError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Parsing failed: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Stage 3: Evaluation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        env </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> create_global_environment()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> evaluate(ast, env)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Result:\"</span><span style=\"color:#E1E4E8\">, result)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#E1E4E8\"> EvaluationError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Evaluation failed: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_milestone_progress</span><span style=\"color:#E1E4E8\">(milestone_number: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Automated validation of milestone completion.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load test cases for specified milestone</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Run all required tests and collect results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Generate pass/fail report with specific feedback</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Suggest next steps if tests fail</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - debugging techniques are essential throughout interpreter development, from troubleshooting tokenization issues in Milestone 1 to diagnosing complex evaluation and recursion problems in Milestones 2-4</p>\n</blockquote>\n<p>Debugging interpreters presents unique challenges that differ significantly from debugging typical application software. Unlike traditional programs where you&#39;re primarily concerned with business logic and data processing, interpreter debugging requires understanding the meta-level execution: how your code executes other code. This creates a two-layer debugging problem where issues can manifest either in your interpreter&#39;s implementation or in the programs being interpreted, and distinguishing between these layers becomes crucial for effective problem resolution.</p>\n<h3 id=\"mental-model-the-detective39s-multi-level-investigation\">Mental Model: The Detective&#39;s Multi-Level Investigation</h3>\n<p>Think of interpreter debugging as a detective investigating a crime scene where the evidence exists on multiple floors of a building. The <strong>surface level</strong> shows symptoms - programs crash, produce wrong results, or hang indefinitely. The <strong>implementation level</strong> reveals how your tokenizer, parser, and evaluator process the problematic code. The <strong>semantic level</strong> exposes whether your interpreter correctly implements Lisp&#39;s evaluation rules. A skilled interpreter debugger moves fluidly between these levels, using evidence from one to guide investigation at another, much like a detective who examines physical evidence, witness testimony, and circumstantial patterns to reconstruct what actually happened.</p>\n<p>The fundamental challenge in interpreter debugging is that your primary tool - the debugger - operates on your interpreter&#39;s implementation, but the problems you&#39;re solving often manifest in the interpreted program&#39;s behavior. This requires developing specialized debugging techniques that bridge between the host language (Python) debugger and the interpreted language (Lisp) execution model.</p>\n<h3 id=\"interpreter-specific-debugging-techniques\">Interpreter-Specific Debugging Techniques</h3>\n<p>Effective interpreter debugging requires a toolkit of specialized techniques that provide visibility into the interpretation process itself. Unlike application debugging where you primarily trace data flow and control flow, interpreter debugging demands tracing the <strong>meta-execution</strong>: how your interpreter processes and transforms the input program through each stage of the pipeline.</p>\n<h4 id=\"environment-state-inspection\">Environment State Inspection</h4>\n<p>The environment chain represents the most critical state in your interpreter, as it determines how variables resolve and functions close over their lexical scope. Developing systematic techniques for inspecting environment state transforms debugging from guesswork into methodical investigation.</p>\n<p>Environment debugging requires understanding that variable lookup failures can occur at multiple points in the environment chain, and the failure location determines both the root cause and the appropriate fix. When a <code>NameError</code> occurs, the issue might be an unbound variable, a scoping problem where the variable exists but isn&#39;t accessible, or an environment corruption where the chain structure itself is malformed.</p>\n<p>The environment inspection process follows a systematic pattern. First, verify the environment chain structure by tracing parent links from the current environment to the global environment. This reveals whether environments are properly linked and whether the chain terminates correctly at the global environment. Second, examine the bindings at each level to identify where the expected variable should exist and whether it&#39;s actually present. Third, trace the variable binding history to understand when and where the variable was defined, and whether subsequent operations might have corrupted or shadowed the binding.</p>\n<table>\n<thead>\n<tr>\n<th>Environment Debugging Operation</th>\n<th>Information Revealed</th>\n<th>When to Use</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Chain traversal inspection</td>\n<td>Environment linkage correctness</td>\n<td><code>NameError</code> with variables that should exist</td>\n</tr>\n<tr>\n<td>Binding enumeration at level</td>\n<td>What variables exist in specific scope</td>\n<td>Scoping problems and shadowing issues</td>\n</tr>\n<tr>\n<td>Parent environment verification</td>\n<td>Environment creation correctness</td>\n<td>Function calls producing wrong scope</td>\n</tr>\n<tr>\n<td>Closure environment inspection</td>\n<td>Captured environment correctness</td>\n<td>Functions accessing wrong variable values</td>\n</tr>\n<tr>\n<td>Global environment baseline check</td>\n<td>Built-in function availability</td>\n<td>Missing or corrupted standard functions</td>\n</tr>\n</tbody></table>\n<h4 id=\"evaluation-trace-generation\">Evaluation Trace Generation</h4>\n<p>Evaluation tracing provides visibility into how expressions are processed through the evaluation engine, revealing the decision tree that leads to final results or errors. Unlike simple logging, evaluation tracing must capture both the <strong>structural transformation</strong> of expressions and the <strong>contextual changes</strong> in environment state.</p>\n<p>The key insight for evaluation tracing is that every evaluation step involves three components: the <strong>input expression</strong> being evaluated, the <strong>environment context</strong> in which evaluation occurs, and the <strong>evaluation rule</strong> that determines how the expression is processed. Effective tracing captures all three components, allowing you to reconstruct the exact evaluation path that led to any particular result or failure.</p>\n<p>Evaluation tracing becomes particularly powerful when it captures the recursive structure of evaluation. Since Lisp evaluation is inherently recursive - evaluating compound expressions requires evaluating their components - your tracing system must handle nested evaluation calls and present them in a way that reveals the hierarchical evaluation structure.</p>\n<table>\n<thead>\n<tr>\n<th>Trace Information</th>\n<th>Purpose</th>\n<th>Example Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Expression input structure</td>\n<td>Understanding what&#39;s being evaluated</td>\n<td>Debugging unexpected evaluation results</td>\n</tr>\n<tr>\n<td>Environment at entry</td>\n<td>Variable resolution context</td>\n<td>Diagnosing variable binding problems</td>\n</tr>\n<tr>\n<td>Special form vs function call decision</td>\n<td>Evaluation path selection</td>\n<td>Fixing incorrect special form handling</td>\n</tr>\n<tr>\n<td>Argument evaluation sequence</td>\n<td>Order-dependent evaluation issues</td>\n<td>Finding evaluation order problems</td>\n</tr>\n<tr>\n<td>Return value and type</td>\n<td>Result verification</td>\n<td>Verifying correct evaluation outcomes</td>\n</tr>\n<tr>\n<td>Recursive evaluation depth</td>\n<td>Stack usage and infinite recursion</td>\n<td>Preventing and diagnosing stack overflow</td>\n</tr>\n</tbody></table>\n<h4 id=\"ast-structure-examination\">AST Structure Examination</h4>\n<p>Abstract syntax tree inspection reveals how your parser translates token streams into the internal representation that drives evaluation. AST debugging focuses on verifying that the parsed structure correctly represents the intended program semantics, particularly for nested expressions and special syntax transformations.</p>\n<p>The most common AST debugging scenario involves expressions that evaluate incorrectly due to parsing problems rather than evaluation logic errors. These issues manifest as structurally correct AST nodes that don&#39;t represent the intended program structure. For example, quote syntax transformation failures might produce AST structures where <code>&#39;(a b c)</code> parses as a symbol named <code>&#39;(a</code> followed by separate symbols <code>b c)</code> rather than the correct transformation to <code>(quote (a b c))</code>.</p>\n<p>AST debugging requires understanding the relationship between surface syntax and internal representation. Your parser makes numerous decisions about how to represent different syntactic constructs, and each decision point represents a potential source of structural errors that will cause evaluation problems downstream.</p>\n<table>\n<thead>\n<tr>\n<th>AST Inspection Focus</th>\n<th>Common Problems</th>\n<th>Debugging Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>List structure nesting</td>\n<td>Incorrect parenthesis handling</td>\n<td>Verify nested list depth matches source</td>\n</tr>\n<tr>\n<td>Quote transformation correctness</td>\n<td>Quote syntax not expanded properly</td>\n<td>Check quote forms become <code>(quote expr)</code></td>\n</tr>\n<tr>\n<td>Atom type classification</td>\n<td>Numbers parsed as symbols or vice versa</td>\n<td>Verify token type mapping to AST nodes</td>\n</tr>\n<tr>\n<td>Symbol name preservation</td>\n<td>Symbol names corrupted during parsing</td>\n<td>Compare AST symbol names to source tokens</td>\n</tr>\n<tr>\n<td>Empty list representation</td>\n<td>Empty lists parsed as <code>nil</code> or other forms</td>\n<td>Verify empty list canonical representation</td>\n</tr>\n</tbody></table>\n<h4 id=\"token-stream-analysis\">Token Stream Analysis</h4>\n<p>Tokenization debugging focuses on verifying that your tokenizer correctly identifies token boundaries and classifies tokens by type. Since tokenization provides the foundation for all subsequent processing, tokenization errors propagate through the entire pipeline and often manifest as confusing parsing or evaluation failures.</p>\n<p>The primary tokenization debugging challenge is <strong>boundary detection errors</strong> where the tokenizer splits input text at incorrect positions, creating tokens that don&#39;t match the intended syntactic units. These errors often occur at the boundaries between different token types - for example, where numbers adjacent to symbols might be tokenized as a single symbol rather than separate number and symbol tokens.</p>\n<p>Token stream analysis requires examining both the <strong>token sequence</strong> produced by tokenization and the <strong>position information</strong> that tracks where each token originated in the source text. This dual perspective allows you to verify that tokenization preserves the relationship between source text and token representation.</p>\n<table>\n<thead>\n<tr>\n<th>Tokenization Issue</th>\n<th>Symptoms</th>\n<th>Diagnostic Technique</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Boundary detection errors</td>\n<td>Parsing fails with unexpected tokens</td>\n<td>Compare token boundaries to manual parsing</td>\n</tr>\n<tr>\n<td>Token type misclassification</td>\n<td>Numbers evaluated as symbols or vice versa</td>\n<td>Verify token type matches expected classification</td>\n</tr>\n<tr>\n<td>String literal boundary problems</td>\n<td>Parsing errors on strings with escapes</td>\n<td>Check string token includes entire literal</td>\n</tr>\n<tr>\n<td>Comment handling failures</td>\n<td>Comments treated as code tokens</td>\n<td>Verify comment tokens are filtered from parser input</td>\n</tr>\n<tr>\n<td>Whitespace boundary issues</td>\n<td>Adjacent tokens incorrectly merged</td>\n<td>Examine whitespace handling between tokens</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-bug-patterns\">Common Bug Patterns</h3>\n<p>Interpreter debugging follows predictable patterns because the same conceptual errors manifest in similar ways across different implementations. Understanding these patterns transforms debugging from ad-hoc problem solving into systematic pattern recognition, where symptoms guide you directly to likely root causes.</p>\n<h4 id=\"environment-chain-corruption-patterns\">Environment Chain Corruption Patterns</h4>\n<p>Environment chain corruption represents one of the most common and difficult-to-diagnose interpreter bug patterns. These issues manifest as variables that should be accessible becoming mysteriously unbound, or variables resolving to incorrect values despite being defined correctly.</p>\n<p><strong>⚠️ Pitfall: Parent Environment Reference Loss</strong></p>\n<p>Environment chain corruption most commonly occurs when environment extension operations fail to maintain proper parent references. This happens when the <code>extend()</code> method creates a new environment but either doesn&#39;t set the parent reference or sets it to the wrong environment object.</p>\n<p>The symptoms appear as <code>NameError</code> exceptions for variables that definitely exist in outer scopes. The error is particularly confusing because the variable lookup works correctly in some contexts but fails in others, typically when function calls or <code>let</code> expressions create new environment extensions.</p>\n<p>The root cause lies in broken environment chains where child environments lose their connection to parent environments. When <code>lookup()</code> traverses the environment chain searching for a variable binding, it stops at the broken link and fails to find variables that exist in parent environments.</p>\n<p>To diagnose this issue, trace the environment chain manually from the current environment to the global environment. If the chain terminates before reaching the global environment, or if any parent reference is <code>None</code> when it shouldn&#39;t be, you&#39;ve identified the corruption point.</p>\n<p><strong>⚠️ Pitfall: Environment Sharing Between Closures</strong></p>\n<p>Closure environment capture represents another common corruption pattern where multiple closures incorrectly share the same environment object, causing variable modifications in one closure to unexpectedly affect other closures.</p>\n<p>This occurs when closure creation captures a reference to the same environment object for multiple functions defined in the same scope, rather than each closure capturing its own environment snapshot. The result is that closures behave as if they share local variables, violating lexical scoping rules.</p>\n<p>The bug manifests as functions that modify local variables affecting the behavior of seemingly unrelated functions. This is particularly noticeable when closures are created in loops, where all closures end up sharing the same loop variable environment.</p>\n<table>\n<thead>\n<tr>\n<th>Environment Corruption Type</th>\n<th>Symptom</th>\n<th>Root Cause</th>\n<th>Fix Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Broken parent chain</td>\n<td><code>NameError</code> for outer scope variables</td>\n<td><code>extend()</code> doesn&#39;t set parent reference</td>\n<td>Verify parent assignment in environment creation</td>\n</tr>\n<tr>\n<td>Shared closure environments</td>\n<td>Closures interfere with each other</td>\n<td>Multiple closures reference same environment</td>\n<td>Create environment copies for each closure</td>\n</tr>\n<tr>\n<td>Circular environment references</td>\n<td>Infinite loops during lookup</td>\n<td>Parent references form cycles</td>\n<td>Validate parent references prevent cycles</td>\n</tr>\n<tr>\n<td>Premature environment garbage collection</td>\n<td>Variables disappear unexpectedly</td>\n<td>Environment objects collected while still needed</td>\n<td>Ensure closures maintain environment references</td>\n</tr>\n</tbody></table>\n<h4 id=\"special-form-mishandling-patterns\">Special Form Mishandling Patterns</h4>\n<p>Special forms require careful handling because they control evaluation rather than participating in normal function evaluation. The most common special form bugs stem from treating special forms like regular functions, leading to incorrect argument evaluation behavior.</p>\n<p><strong>⚠️ Pitfall: Premature Argument Evaluation</strong></p>\n<p>The most frequent special form error involves evaluating arguments before processing the special form, violating the evaluation control that defines special forms. This typically occurs when the evaluation dispatch mechanism doesn&#39;t properly distinguish between special forms and function calls.</p>\n<p>For example, in an <code>if</code> expression like <code>(if condition then-branch else-branch)</code>, both branches should not be evaluated - only the branch selected by the condition should be evaluated. If your evaluator mistakenly evaluates all three arguments before processing the <code>if</code> special form, both branches execute, causing incorrect side effects and potentially infinite loops in recursive functions.</p>\n<p>The symptoms include functions that should not be called being executed anyway, infinite recursion in conditional logic that should terminate, and side effects occurring when they should be prevented by conditional logic.</p>\n<p>The root cause lies in evaluation dispatch logic that calls <code>evaluate()</code> on special form arguments before invoking the special form handler. Special forms must control argument evaluation themselves, receiving unevaluated arguments and deciding which arguments to evaluate based on special form semantics.</p>\n<p><strong>⚠️ Pitfall: Special Form Name Collision</strong></p>\n<p>Special form name collisions occur when user-defined functions or variables shadow built-in special form names, causing the interpreter to lose access to essential language constructs. This typically happens when the special form lookup mechanism doesn&#39;t take precedence over variable lookup.</p>\n<p>The symptom is that previously working special forms like <code>if</code>, <code>define</code>, or <code>lambda</code> suddenly start behaving like function calls, often producing <code>TypeError</code> or <code>ArityError</code> exceptions because special forms don&#39;t behave like regular functions.</p>\n<table>\n<thead>\n<tr>\n<th>Special Form Bug Pattern</th>\n<th>Symptom</th>\n<th>Cause</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Arguments evaluated too early</td>\n<td>Infinite recursion in conditionals</td>\n<td>Special forms treated as functions</td>\n<td>Check special form before evaluating arguments</td>\n</tr>\n<tr>\n<td>Special form shadowing</td>\n<td>Built-in special forms become inaccessible</td>\n<td>Variable bindings override special forms</td>\n<td>Special form lookup takes precedence over variables</td>\n</tr>\n<tr>\n<td>Incorrect arity checking</td>\n<td>Special forms reject valid argument counts</td>\n<td>Special forms validated like function arity</td>\n<td>Special forms have custom arity validation</td>\n</tr>\n<tr>\n<td>Missing environment threading</td>\n<td>Special forms can&#39;t access local variables</td>\n<td>Environment not passed to special form handlers</td>\n<td>Thread environment through all special form calls</td>\n</tr>\n</tbody></table>\n<h4 id=\"function-application-error-patterns\">Function Application Error Patterns</h4>\n<p>Function application errors represent complex debugging scenarios because they involve multiple interacting systems: argument evaluation, environment extension, parameter binding, and body evaluation. Errors can occur at any of these stages, and the symptoms often don&#39;t clearly indicate which stage failed.</p>\n<p><strong>⚠️ Pitfall: Argument-Parameter Binding Mismatch</strong></p>\n<p>Parameter binding errors occur when the function application process incorrectly maps evaluated arguments to function parameters. This typically happens when argument evaluation changes the argument count or when parameter binding logic doesn&#39;t handle edge cases like zero-parameter functions or variable-arity functions.</p>\n<p>The symptoms include functions receiving the wrong number of arguments despite being called with the correct number, argument values being assigned to the wrong parameters, or <code>ArityError</code> exceptions for functions called with seemingly correct argument counts.</p>\n<p>The root cause often lies in argument evaluation or parameter binding logic that doesn&#39;t properly handle the transition from unevaluated argument expressions to evaluated argument values bound to parameter names.</p>\n<p><strong>⚠️ Pitfall: Recursive Function Self-Reference</strong></p>\n<p>Recursive functions require special handling to make the function name available within the function body, allowing the function to call itself. The most common error is creating the function binding after evaluating the function body, meaning the function name isn&#39;t available during its own definition.</p>\n<p>This manifests as <code>NameError</code> exceptions when recursive functions attempt to call themselves, even though the function appears to be properly defined. The error is confusing because the function exists in the environment after definition completes, but isn&#39;t available during the function&#39;s own evaluation.</p>\n<table>\n<thead>\n<tr>\n<th>Function Application Bug</th>\n<th>Symptom</th>\n<th>Common Cause</th>\n<th>Debugging Steps</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Wrong argument values in parameters</td>\n<td>Function receives incorrect arguments</td>\n<td>Argument evaluation order problems</td>\n<td>Trace argument evaluation sequence</td>\n</tr>\n<tr>\n<td><code>NameError</code> for function self-reference</td>\n<td>Recursive calls fail</td>\n<td>Function name not bound during evaluation</td>\n<td>Check function name availability in function environment</td>\n</tr>\n<tr>\n<td><code>ArityError</code> with correct argument count</td>\n<td>Function rejects correct arguments</td>\n<td>Arity checking logic errors</td>\n<td>Verify argument count calculation</td>\n</tr>\n<tr>\n<td>Environment corruption in function calls</td>\n<td>Variables have wrong values after function calls</td>\n<td>Environment extension problems</td>\n<td>Inspect environment chain after function application</td>\n</tr>\n</tbody></table>\n<h4 id=\"list-operation-implementation-bugs\">List Operation Implementation Bugs</h4>\n<p>List operations like <code>car</code>, <code>cdr</code>, and <code>cons</code> involve careful management of list structure representation and type checking. The most common bugs stem from incorrect assumptions about list structure or improper handling of edge cases like empty lists.</p>\n<p><strong>⚠️ Pitfall: Improper List vs Empty List Handling</strong></p>\n<p>List operation bugs frequently occur at the boundary between non-empty lists and the empty list. Many implementations incorrectly assume that all list values have the same internal structure, failing to handle the empty list as a special case with different structure requirements.</p>\n<p>The symptom is <code>TypeError</code> or <code>AttributeError</code> exceptions when list operations encounter empty lists, or incorrect results when list operations should produce empty lists. This is particularly common with <code>cdr</code> operations that should return empty lists but instead return <code>None</code> or malformed values.</p>\n<p><strong>⚠️ Pitfall: Improper List Construction</strong></p>\n<p>List construction bugs occur when <code>cons</code> operations don&#39;t create proper list structure, or when list construction functions like <code>list()</code> don&#39;t properly terminate lists with the empty list marker. This creates improper lists that break list traversal operations.</p>\n<p>These bugs manifest as infinite loops during list traversal, incorrect list length calculations, or list operations that work correctly on constructed lists but fail on lists created through <code>cons</code> operations.</p>\n<table>\n<thead>\n<tr>\n<th>List Operation Bug</th>\n<th>Symptom</th>\n<th>Typical Cause</th>\n<th>Fix Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>car</code> fails on empty list</td>\n<td><code>TypeError</code> when accessing car of empty list</td>\n<td>Empty list not handled as special case</td>\n<td>Check for empty list before structure access</td>\n</tr>\n<tr>\n<td><code>cdr</code> returns wrong type</td>\n<td><code>cdr</code> returns <code>None</code> instead of empty list</td>\n<td>Incorrect empty list representation</td>\n<td>Ensure <code>cdr</code> of single-element list returns empty list</td>\n</tr>\n<tr>\n<td>Infinite loops in list traversal</td>\n<td>List operations never terminate</td>\n<td>Improper list construction creates cycles</td>\n<td>Verify list construction terminates with empty list</td>\n</tr>\n<tr>\n<td><code>cons</code> creates malformed lists</td>\n<td>Lists created by <code>cons</code> break other operations</td>\n<td><code>cons</code> doesn&#39;t create proper list structure</td>\n<td>Ensure <code>cons</code> result is valid list structure</td>\n</tr>\n</tbody></table>\n<h3 id=\"building-diagnostic-tools\">Building Diagnostic Tools</h3>\n<p>Effective interpreter debugging requires building specialized diagnostic tools that provide visibility into the interpretation process. Unlike general-purpose debugging, interpreter diagnostics must bridge between the host language implementation and the interpreted language behavior, providing views of both levels simultaneously.</p>\n<h4 id=\"evaluation-tracer-implementation\">Evaluation Tracer Implementation</h4>\n<p>An evaluation tracer provides step-by-step visibility into how expressions are evaluated, revealing the decision path through your evaluation engine. The tracer must capture not just the final result, but the intermediate steps that led to that result, including environment lookups, special form dispatch decisions, and recursive evaluation calls.</p>\n<p>The key insight for evaluation tracing is that Lisp evaluation follows a recursive pattern where compound expressions are evaluated by evaluating their components and combining the results. Your tracer must capture this recursive structure while presenting the information in a format that reveals the evaluation logic clearly.</p>\n<p>The evaluation tracer works by instrumenting the main <code>evaluate()</code> function to log entry and exit information, along with key decision points within the evaluation logic. The tracer maintains a call stack that tracks recursive evaluation calls, allowing it to present the evaluation trace as a nested structure that reflects the expression structure being evaluated.</p>\n<table>\n<thead>\n<tr>\n<th>Tracer Component</th>\n<th>Information Captured</th>\n<th>Output Format</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Expression entry logging</td>\n<td>Input expression and environment</td>\n<td><code>EVAL: (+ 1 2) in env@depth-3</code></td>\n</tr>\n<tr>\n<td>Evaluation dispatch decision</td>\n<td>Special form vs function call choice</td>\n<td><code>DISPATCH: + -&gt; builtin function</code></td>\n</tr>\n<tr>\n<td>Argument evaluation sequence</td>\n<td>Sub-expression evaluation order</td>\n<td><code>ARG[0]: 1 -&gt; 1, ARG[1]: 2 -&gt; 2</code></td>\n</tr>\n<tr>\n<td>Environment lookup results</td>\n<td>Variable resolution outcomes</td>\n<td><code>LOOKUP: x in env@depth-2 -&gt; 42</code></td>\n</tr>\n<tr>\n<td>Function application details</td>\n<td>Function call parameter binding</td>\n<td><code>APPLY: user-func(x=1, y=2) -&gt; ...</code></td>\n</tr>\n<tr>\n<td>Result value and type</td>\n<td>Evaluation outcome</td>\n<td><code>RESULT: 3 (NUMBER)</code></td>\n</tr>\n</tbody></table>\n<p>The tracer implementation requires careful consideration of output formatting to make complex nested evaluations comprehensible. Deep recursive evaluations can generate overwhelming amounts of trace information, so the tracer should support filtering by expression type, depth limiting, and summary modes that hide routine evaluations while highlighting interesting decision points.</p>\n<h4 id=\"environment-inspector-interface\">Environment Inspector Interface</h4>\n<p>Environment inspection requires tools that make the abstract environment chain concrete and browsable. Since environment problems often involve complex interactions between multiple scopes, the inspector must present environment information in a way that reveals both the structure of individual environments and the relationships between environments in the chain.</p>\n<p>The environment inspector operates by providing multiple views of environment state: a <strong>chain view</strong> that shows the parent-child relationships between environments, a <strong>bindings view</strong> that lists all variables accessible at a particular point, and a <strong>closure view</strong> that shows what environments are captured by function closures.</p>\n<p>The chain view reveals environment structure problems by displaying each environment in the chain with its identity, parent reference, and binding count. This view quickly identifies broken chains, circular references, and unexpected environment structures that indicate environment management bugs.</p>\n<p>The bindings view flattens the environment chain into a single namespace view, showing all variables accessible at a particular point along with their values and the environment where each binding originated. This view helps diagnose variable shadowing issues and confirms that expected variables are accessible with correct values.</p>\n<table>\n<thead>\n<tr>\n<th>Inspector View</th>\n<th>Purpose</th>\n<th>Information Displayed</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Chain structure</td>\n<td>Environment linkage verification</td>\n<td><code>env@0 -&gt; env@1 -&gt; env@2 -&gt; global</code></td>\n</tr>\n<tr>\n<td>Bindings at level</td>\n<td>Specific environment contents</td>\n<td><code>{x: 42, y: &quot;hello&quot;, func: &lt;function&gt;}</code></td>\n</tr>\n<tr>\n<td>Flattened namespace</td>\n<td>All accessible variables</td>\n<td><code>x: 42@env-2, y: &quot;hello&quot;@env-1, +: &lt;builtin&gt;@global</code></td>\n</tr>\n<tr>\n<td>Closure environments</td>\n<td>Captured environment inspection</td>\n<td><code>function@addr captures env@3 with {a: 1, b: 2}</code></td>\n</tr>\n<tr>\n<td>Environment lifecycle</td>\n<td>Creation and destruction tracking</td>\n<td><code>env@5 created for function call, destroyed after return</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"ast-visualization-tools\">AST Visualization Tools</h4>\n<p>Abstract syntax tree visualization transforms the internal tree structure into a format that clearly reveals the parsed program structure. Since AST problems often involve subtle structural differences that are difficult to spot in text representations, visualization tools must present tree structure in a way that makes structural errors obvious.</p>\n<p>The AST visualizer works by traversing the parsed AST and generating a tree representation that shows both the hierarchical structure of expressions and the detailed information at each node. The visualizer must handle the recursive nature of AST structures while presenting the information in a format that makes structural problems immediately apparent.</p>\n<p>AST visualization becomes particularly valuable for debugging quote syntax transformation and nested list structure parsing. These features involve complex structural transformations that are difficult to verify through simple inspection of the final AST representation.</p>\n<table>\n<thead>\n<tr>\n<th>Visualization Component</th>\n<th>Structure Revealed</th>\n<th>Diagnostic Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tree hierarchy display</td>\n<td>Nested expression structure</td>\n<td>Verify parsing preserves intended nesting</td>\n</tr>\n<tr>\n<td>Node type annotations</td>\n<td>AST node classification</td>\n<td>Confirm tokens become correct AST node types</td>\n</tr>\n<tr>\n<td>Quote transformation visualization</td>\n<td>Quote syntax expansion</td>\n<td>Verify <code>&#39;expr</code> becomes <code>(quote expr)</code> structure</td>\n</tr>\n<tr>\n<td>Position tracking display</td>\n<td>Source location preservation</td>\n<td>Trace AST nodes back to source text positions</td>\n</tr>\n<tr>\n<td>List structure validation</td>\n<td>Proper vs improper list identification</td>\n<td>Ensure list parsing creates valid list structures</td>\n</tr>\n</tbody></table>\n<h4 id=\"interactive-repl-debugging\">Interactive REPL Debugging</h4>\n<p>The Read-Eval-Print Loop provides an interactive environment for testing interpreter behavior and exploring edge cases. A well-designed REPL includes debugging features that make it easy to inspect interpreter state, test specific scenarios, and experiment with interpreter behavior.</p>\n<p>The debugging-enabled REPL extends the basic read-eval-print cycle with commands that provide access to internal interpreter state. These commands allow you to inspect the current environment, trace evaluation of specific expressions, and examine the results of tokenization and parsing without writing separate test programs.</p>\n<p>REPL debugging commands should be designed to feel natural within the interactive environment while providing powerful diagnostic capabilities. The commands integrate with the normal REPL workflow, allowing you to seamlessly switch between testing program behavior and inspecting interpreter internals.</p>\n<table>\n<thead>\n<tr>\n<th>REPL Debug Command</th>\n<th>Function</th>\n<th>Example Usage</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>:trace &lt;expr&gt;</code></td>\n<td>Enable evaluation tracing for expression</td>\n<td><code>:trace (factorial 5)</code></td>\n</tr>\n<tr>\n<td><code>:env</code></td>\n<td>Display current environment chain</td>\n<td><code>:env</code></td>\n</tr>\n<tr>\n<td><code>:parse &lt;expr&gt;</code></td>\n<td>Show AST for expression</td>\n<td><code>:parse &#39;(a b c)</code></td>\n</tr>\n<tr>\n<td><code>:tokens &lt;expr&gt;</code></td>\n<td>Show tokenization of expression</td>\n<td><code>:tokens &quot;hello world&quot;</code></td>\n</tr>\n<tr>\n<td><code>:reset</code></td>\n<td>Reset interpreter to clean state</td>\n<td><code>:reset</code></td>\n</tr>\n<tr>\n<td><code>:help</code></td>\n<td>List available debug commands</td>\n<td><code>:help</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Building effective debugging tools for your Lisp interpreter requires integrating diagnostic capabilities throughout your implementation rather than adding them as an afterthought. The most effective approach is to build debugging support into your core data structures and algorithms from the beginning, making diagnostic information naturally available when problems occur.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Logging Framework</td>\n<td>Python <code>logging</code> module with custom formatters</td>\n<td>Structured logging with JSON output</td>\n</tr>\n<tr>\n<td>Trace Visualization</td>\n<td>Plain text indented output</td>\n<td>Rich terminal formatting with colors</td>\n</tr>\n<tr>\n<td>Interactive Debugging</td>\n<td>Basic print statements</td>\n<td>IPython integration with custom magic commands</td>\n</tr>\n<tr>\n<td>AST Visualization</td>\n<td>Simple tree printing</td>\n<td>Graphical tree rendering with SVG output</td>\n</tr>\n<tr>\n<td>Performance Profiling</td>\n<td>Basic timing measurements</td>\n<td>Python <code>cProfile</code> integration</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">lisp_interpreter</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  debug</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    __init__</span><span style=\"color:#E1E4E8\">.py              ← debug module exports</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    tracer.py               ← evaluation tracing system</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    environment_inspector.py ← environment debugging tools</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ast_visualizer.py       ← </span><span style=\"color:#79B8FF\">AST</span><span style=\"color:#E1E4E8\"> structure visualization</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    repl_debugger.py        ← </span><span style=\"color:#79B8FF\">REPL</span><span style=\"color:#E1E4E8\"> debugging commands</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  core</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    evaluator.py            ← instrumented </span><span style=\"color:#F97583\">with</span><span style=\"color:#E1E4E8\"> debug hooks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    environment.py          ← enhanced </span><span style=\"color:#F97583\">with</span><span style=\"color:#E1E4E8\"> inspection methods</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser.py              ← enhanced </span><span style=\"color:#F97583\">with</span><span style=\"color:#E1E4E8\"> debug information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  tests</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    debug</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      test_tracer.py        ← tracer functionality tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      test_inspector.py     ← environment inspector tests</span></span></code></pre></div>\n\n<h4 id=\"evaluation-tracer-infrastructure\">Evaluation Tracer Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># debug/tracer.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Any, Dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> contextlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> contextmanager</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TraceEvent</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a single event in the evaluation trace.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # 'enter', 'exit', 'lookup', 'apply'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expression: Any</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    environment_id: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    depth: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result: Optional[Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    error: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EvaluationTracer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provides detailed tracing of expression evaluation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, output_file</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, max_depth</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.events: List[TraceEvent] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.output_file </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> output_file </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> sys.stdout</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.max_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> max_depth</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @contextmanager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> trace_evaluation</span><span style=\"color:#E1E4E8\">(self, expression, environment):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Context manager for tracing a single evaluation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create enter event with expression and environment info</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Increment depth counter and check against max_depth</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Yield control to evaluation code</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Capture result or exception information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create exit event with result/error information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Decrement depth counter and log event if enabled</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> log_lookup</span><span style=\"color:#E1E4E8\">(self, variable_name, environment, result):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Log a variable lookup operation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create lookup event with variable name and environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Record whether lookup succeeded or failed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Include resolved value if lookup succeeded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add event to trace log</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_trace_output</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format collected trace events for display.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Group events by evaluation call (enter/exit pairs)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Format each event with appropriate indentation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Include expression, environment, and result information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle error events with clear error indication</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return formatted string representation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"environment-inspector-implementation\">Environment Inspector Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># debug/environment_inspector.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Set, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispValue</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EnvironmentInspector</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provides detailed inspection of environment chains and variable bindings.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, environment: Environment):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.environment </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> environment</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.inspection_cache: Dict[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> inspect_chain</span><span style=\"color:#E1E4E8\">(self) -> List[Dict]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate detailed information about the entire environment chain.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Start from current environment and traverse to root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each environment, collect identity, bindings count, parent reference</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Detect circular references and broken chains</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return list of environment information dictionaries</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Cache results to avoid repeated traversal overhead</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_all_accessible_variables</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">tuple</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return all variables accessible from current environment with their sources.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Traverse environment chain from current to global</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Collect variable bindings from each level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle variable shadowing by keeping first occurrence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return dict mapping variable names to (value, source_env) tuples</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Include metadata about which environment each binding comes from</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> analyze_closure_environments</span><span style=\"color:#E1E4E8\">(self, function_value: LispValue) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Analyze environment capture in function closures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract closure environment from function value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Traverse closure environment chain</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Identify which variables are captured vs inherited</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check for potential memory leaks from captured environments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return analysis report with captured variables and chain depth</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> diagnose_lookup_failure</span><span style=\"color:#E1E4E8\">(self, variable_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Provide detailed diagnosis when variable lookup fails.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Search for variable in each environment level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check for similar variable names that might indicate typos</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Identify if variable exists in inaccessible scopes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Generate suggestions for fixing the lookup failure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return comprehensive diagnostic report</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"ast-visualizer-tools\">AST Visualizer Tools</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># debug/ast_visualizer.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, List, Dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LispValue, LispValueType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ASTVisualizer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provides visualization and analysis of parsed AST structures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, max_depth</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.max_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> max_depth</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.node_counter </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> visualize_tree</span><span style=\"color:#E1E4E8\">(self, ast: LispValue, format</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'text'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate visual representation of AST structure.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Reset node counter and start tree traversal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle different node types (atoms, lists, functions)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Generate appropriate representation based on format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Include type information and value details</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Apply depth limiting to prevent overwhelming output</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> analyze_structure</span><span style=\"color:#E1E4E8\">(self, ast: LispValue) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Analyze AST structure and identify potential issues.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Count nodes by type and calculate tree depth</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Identify malformed structures (improper lists, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check for quote syntax transformation correctness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate that list structures are properly terminated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return analysis report with structure statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> compare_structures</span><span style=\"color:#E1E4E8\">(self, ast1: LispValue, ast2: LispValue) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Compare two AST structures and highlight differences.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Traverse both trees simultaneously</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Identify structural differences (shape, node types)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Highlight value differences in matching nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Generate diff report showing specific differences</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Suggest likely causes for structural mismatches</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"repl-debug-integration\">REPL Debug Integration</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># debug/repl_debugger.py</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Callable, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.evaluator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Evaluator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.environment </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Environment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .tracer </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> EvaluationTracer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .environment_inspector </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> EnvironmentInspector</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .ast_visualizer </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ASTVisualizer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> REPLDebugger</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provides debugging commands for interactive REPL sessions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, evaluator: Evaluator):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.evaluator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> evaluator</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.tracer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> EvaluationTracer()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.commands: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Callable] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'trace'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.cmd_trace,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'env'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.cmd_environment,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'parse'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.cmd_parse,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'tokens'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.cmd_tokens,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'reset'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.cmd_reset,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'help'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.cmd_help</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_debug_command</span><span style=\"color:#E1E4E8\">(self, command_line: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Process debug command and return result.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Parse command line to extract command and arguments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Look up command in commands dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Execute command with parsed arguments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle command errors gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return formatted command result</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> cmd_trace</span><span style=\"color:#E1E4E8\">(self, expression_text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Enable tracing for expression evaluation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Parse expression text into AST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Enable tracer and evaluate expression</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Format trace output for display</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return formatted trace information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> cmd_environment</span><span style=\"color:#E1E4E8\">(self, args: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Display current environment information.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create environment inspector for current environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Generate environment chain analysis</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Format environment information for display</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Include variable bindings and chain structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p>After implementing each debugging component, verify functionality with these checkpoints:</p>\n<p><strong>Tracer Verification:</strong></p>\n<ul>\n<li>Run <code>python -c &quot;from debug.tracer import EvaluationTracer; print(&#39;Tracer loaded&#39;)&quot;</code> to verify imports</li>\n<li>Trace a simple expression like <code>(+ 1 2)</code> and verify output shows evaluation steps</li>\n<li>Trace a recursive function and verify depth tracking works correctly</li>\n</ul>\n<p><strong>Environment Inspector Verification:</strong></p>\n<ul>\n<li>Create nested environments with variable bindings</li>\n<li>Use inspector to display environment chain and verify structure</li>\n<li>Test lookup failure diagnosis with undefined variables</li>\n</ul>\n<p><strong>AST Visualizer Verification:</strong></p>\n<ul>\n<li>Parse complex nested expressions and visualize tree structure</li>\n<li>Compare AST structures for similar expressions</li>\n<li>Verify quote syntax transformation visualization</li>\n</ul>\n<p><strong>REPL Debugger Verification:</strong></p>\n<ul>\n<li>Start REPL and test <code>:help</code> command shows available debug commands</li>\n<li>Use <code>:trace</code> command to trace expression evaluation</li>\n<li>Use <code>:env</code> command to inspect environment state</li>\n</ul>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Steps</th>\n<th>Fix Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tracer shows wrong evaluation order</td>\n<td>Evaluation dispatch logic error</td>\n<td>Check special form vs function call detection</td>\n<td>Fix evaluation dispatch mechanism</td>\n</tr>\n<tr>\n<td>Environment inspector shows broken chains</td>\n<td>Environment extension problems</td>\n<td>Trace environment creation and parent assignment</td>\n<td>Verify <code>extend()</code> method implementation</td>\n</tr>\n<tr>\n<td>AST visualizer shows malformed trees</td>\n<td>Parser structural errors</td>\n<td>Compare AST to expected structure for sample inputs</td>\n<td>Fix recursive parsing logic</td>\n</tr>\n<tr>\n<td>Debug commands cause REPL crashes</td>\n<td>Exception handling in debug code</td>\n<td>Test debug commands with invalid inputs</td>\n<td>Add comprehensive error handling</td>\n</tr>\n<tr>\n<td>Trace output too verbose</td>\n<td>Missing depth limiting</td>\n<td>Check tracer depth configuration</td>\n<td>Implement trace filtering and depth limits</td>\n</tr>\n</tbody></table>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - future extensions build upon the complete interpreter implementation established through all four milestones, providing pathways for continued learning and system evolution</p>\n</blockquote>\n<p>Once you have completed the basic Lisp interpreter through all four milestones, you will have built a solid foundation that demonstrates the core principles of language implementation. However, this foundation represents just the beginning of what is possible with programming language design and implementation. The architecture you have constructed is intentionally extensible, designed with clean separation of concerns and modular components that can be enhanced without requiring fundamental restructuring.</p>\n<h3 id=\"mental-model-the-expandable-workshop\">Mental Model: The Expandable Workshop</h3>\n<p>Think of your completed interpreter as a well-organized workshop with solid foundations, reliable tools, and clear work areas. Just as a carpenter&#39;s workshop can be expanded with specialized tools (a router table for fine joinery, a dust collection system for cleaner work, or power tools for increased productivity), your interpreter can be enhanced with additional language features, performance optimizations, and development environment improvements. The key insight is that these extensions build upon your existing infrastructure rather than replacing it - your tokenizer, parser, evaluator, and environment system remain the core tools, but they gain new capabilities and efficiency improvements.</p>\n<p>The extensions fall into three main categories: additional language features that expand what programs can express, performance optimizations that make the interpreter run faster and handle larger programs, and development environment enhancements that improve the programmer experience. Each category offers different learning opportunities and practical benefits, allowing you to choose extensions based on your interests and goals.</p>\n<h3 id=\"additional-language-features\">Additional Language Features</h3>\n<p>The minimal Lisp you have implemented covers the essential elements of functional programming, but many practical programming tasks benefit from additional language constructs. These extensions introduce new concepts while building on your existing architecture, providing opportunities to deepen your understanding of language design principles and implementation techniques.</p>\n<h4 id=\"macro-system-implementation\">Macro System Implementation</h4>\n<p>Macros represent one of Lisp&#39;s most powerful and distinctive features - the ability to manipulate code as data before evaluation occurs. Unlike functions, which operate on evaluated arguments, macros receive their arguments as unevaluated S-expressions and return new S-expressions that replace the original macro call. This capability enables programmers to extend the language syntax and create domain-specific languages embedded within Lisp.</p>\n<blockquote>\n<p><strong>Decision: Macro System Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Programmers need the ability to define new syntactic constructs and eliminate repetitive code patterns that cannot be abstracted with functions alone</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Compile-time macro expansion with separate expansion phase</li>\n<li>Runtime macro expansion during evaluation</li>\n<li>Template-based macro system with pattern matching</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Compile-time expansion with AST transformation phase</li>\n<li><strong>Rationale</strong>: Compile-time expansion provides better performance and error reporting, while AST transformation fits naturally with the existing parser output</li>\n<li><strong>Consequences</strong>: Requires adding a macro expansion phase between parsing and evaluation, but maintains clear separation of concerns and enables powerful metaprogramming</li>\n</ul>\n</blockquote>\n<p>The macro system requires extending your data model to distinguish between regular functions and macro functions, along with adding a macro expansion phase to your evaluation pipeline. The <code>LispValue</code> type needs a new variant for macros, and the evaluator needs logic to recognize macro calls and perform expansion before normal evaluation.</p>\n<table>\n<thead>\n<tr>\n<th>Macro System Component</th>\n<th>Purpose</th>\n<th>Integration Point</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>MacroFunction</code> type</td>\n<td>Stores macro parameter list and body template</td>\n<td>Extends <code>LispValue</code> discriminated union</td>\n</tr>\n<tr>\n<td><code>defmacro</code> special form</td>\n<td>Creates macro binding in environment</td>\n<td>Adds new case to special form handler</td>\n</tr>\n<tr>\n<td>Macro expansion phase</td>\n<td>Transforms macro calls into expanded code</td>\n<td>Inserts between parsing and evaluation</td>\n</tr>\n<tr>\n<td>Expansion context tracking</td>\n<td>Prevents infinite macro expansion loops</td>\n<td>Maintains expansion depth counter</td>\n</tr>\n<tr>\n<td>Hygienic identifier generation</td>\n<td>Avoids variable capture in macro expansions</td>\n<td>Generates unique symbols for macro-introduced variables</td>\n</tr>\n</tbody></table>\n<p>The implementation challenges center around handling variable capture and ensuring that macro-generated code does not accidentally interfere with user variables. A sophisticated macro system includes hygiene mechanisms that automatically rename variables introduced by macros to avoid conflicts.</p>\n<p>⚠️ <strong>Pitfall: Variable Capture in Macros</strong>\nMany macro implementations suffer from variable capture problems where macro-generated code accidentally refers to variables in the calling context. For example, a macro that generates a <code>let</code> binding with a hardcoded variable name can shadow variables the macro user expects to access. The solution involves either manual variable renaming or automatic hygienic macro expansion that generates unique identifiers for macro-introduced bindings.</p>\n<h4 id=\"advanced-data-types\">Advanced Data Types</h4>\n<p>While the basic interpreter handles numbers, symbols, and lists, practical programming often requires additional data types that provide better abstraction and performance for specific use cases. These extensions demonstrate how language implementers balance expressiveness, performance, and implementation complexity.</p>\n<p><strong>String Operations and Text Processing</strong></p>\n<p>String literals exist in your tokenizer, but the evaluator treats them as atomic values without built-in operations. Adding comprehensive string support requires implementing string concatenation, substring extraction, pattern matching, and character manipulation functions. This extension illustrates how built-in operations can provide both convenience and performance benefits over implementing equivalent functionality in user code.</p>\n<table>\n<thead>\n<tr>\n<th>String Operation</th>\n<th>Function Signature</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>string-append</code></td>\n<td><code>(string-append str1 str2 ...)</code></td>\n<td>Concatenates multiple strings efficiently</td>\n</tr>\n<tr>\n<td><code>substring</code></td>\n<td><code>(substring str start end)</code></td>\n<td>Extracts portion of string by position</td>\n</tr>\n<tr>\n<td><code>string-length</code></td>\n<td><code>(string-length str)</code></td>\n<td>Returns character count</td>\n</tr>\n<tr>\n<td><code>string-&gt;list</code></td>\n<td><code>(string-&gt;list str)</code></td>\n<td>Converts string to list of characters</td>\n</tr>\n<tr>\n<td><code>list-&gt;string</code></td>\n<td><code>(list-&gt;string chars)</code></td>\n<td>Converts character list to string</td>\n</tr>\n<tr>\n<td><code>string=?</code></td>\n<td><code>(string=? str1 str2)</code></td>\n<td>Tests string equality</td>\n</tr>\n</tbody></table>\n<p><strong>Vector Data Structure</strong></p>\n<p>Lists provide excellent support for recursive algorithms and functional programming patterns, but they offer poor performance for random access and modification operations. Vectors (dynamic arrays) complement lists by providing constant-time indexing and efficient append operations, making them suitable for different algorithmic patterns.</p>\n<p>The vector implementation requires extending the <code>LispValueType</code> enumeration and adding vector-specific operations to the built-in function registry. Vectors can share many operations with lists (like <code>map</code> and <code>reduce</code>) while providing their own access patterns through indexing operations.</p>\n<table>\n<thead>\n<tr>\n<th>Vector Operation</th>\n<th>Function Signature</th>\n<th>Time Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>make-vector</code></td>\n<td><code>(make-vector size initial-value)</code></td>\n<td>O(size)</td>\n</tr>\n<tr>\n<td><code>vector-ref</code></td>\n<td><code>(vector-ref vec index)</code></td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>vector-set!</code></td>\n<td><code>(vector-set! vec index value)</code></td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>vector-length</code></td>\n<td><code>(vector-length vec)</code></td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td><code>vector-append</code></td>\n<td><code>(vector-append vec1 vec2)</code></td>\n<td>O(n + m)</td>\n</tr>\n</tbody></table>\n<p><strong>Hash Table Implementation</strong></p>\n<p>Hash tables (dictionaries or maps in other languages) provide efficient key-value storage with average constant-time lookup, insertion, and deletion. This data structure enables efficient implementation of algorithms that require fast membership testing or associative storage patterns that would be inefficient with lists.</p>\n<p>Hash tables introduce interesting implementation challenges around hash function design, collision resolution, and dynamic resizing. The implementation also raises questions about key equality semantics and whether to support mutable or immutable variants.</p>\n<h4 id=\"advanced-control-structures\">Advanced Control Structures</h4>\n<p>The basic interpreter provides conditional evaluation through <code>if</code> expressions, but many programming patterns benefit from additional control structures that reduce code duplication and express intent more clearly.</p>\n<p><strong>Pattern Matching with Match Expressions</strong></p>\n<p>Pattern matching allows programs to destructure data and dispatch behavior based on data shape in a single construct. Unlike cascaded <code>if</code> expressions that test conditions sequentially, pattern matching expresses the programmer&#39;s intent to handle different cases of a discriminated union or data structure variant.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">lisp</span><pre class=\"arch-pre shiki-highlighted\"><code>(match expression\n  (pattern1 result1)\n  (pattern2 result2)\n  (_ default-result))</code></pre></div>\n\n<p>Pattern matching requires extending the parser to recognize match syntax and implementing pattern compilation that translates match expressions into equivalent conditional and destructuring operations. The implementation involves pattern parsing, binding variable extraction, and generating efficient comparison code.</p>\n<p><strong>Exception Handling System</strong></p>\n<p>Error handling in the basic interpreter relies on returning error values or terminating evaluation. A more sophisticated approach involves exception handling that separates error conditions from normal control flow, enabling cleaner error recovery and resource cleanup patterns.</p>\n<p>Exception handling requires new special forms for raising and catching exceptions, along with modifications to the evaluator to maintain an exception handler stack. When an exception occurs, the evaluator unwinds the call stack until it finds an appropriate handler, executing any cleanup code along the way.</p>\n<table>\n<thead>\n<tr>\n<th>Exception Construct</th>\n<th>Syntax</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>throw</code></td>\n<td><code>(throw exception-value)</code></td>\n<td>Raises exception and begins stack unwinding</td>\n</tr>\n<tr>\n<td><code>try-catch</code></td>\n<td><code>(try body (catch var handler))</code></td>\n<td>Establishes exception handler for block</td>\n</tr>\n<tr>\n<td><code>finally</code></td>\n<td><code>(finally cleanup-code)</code></td>\n<td>Ensures code runs regardless of exceptions</td>\n</tr>\n</tbody></table>\n<h3 id=\"performance-optimization-opportunities\">Performance Optimization Opportunities</h3>\n<p>The tree-walking interpreter you have built prioritizes implementation simplicity and educational clarity over execution performance. While this approach serves well for learning language implementation concepts, it leaves substantial opportunities for performance improvement that demonstrate advanced compiler and runtime techniques.</p>\n<h4 id=\"bytecode-compilation-and-virtual-machine\">Bytecode Compilation and Virtual Machine</h4>\n<p>Tree-walking interpretation performs significant overhead for each evaluation step - dispatching on expression types, looking up function implementations, and traversing nested data structures. Bytecode compilation eliminates this overhead by translating the parsed AST into a linear sequence of simple instructions that execute on a specialized virtual machine.</p>\n<blockquote>\n<p><strong>Decision: Bytecode Virtual Machine Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Tree-walking interpretation creates substantial per-operation overhead that limits performance for compute-intensive programs</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Stack-based virtual machine with operand stack</li>\n<li>Register-based virtual machine with named registers  </li>\n<li>Direct translation to native machine code</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Stack-based virtual machine with instruction stream</li>\n<li><strong>Rationale</strong>: Stack machines map naturally to nested expression evaluation, require simpler instruction encoding, and provide good performance improvement over tree-walking with moderate implementation complexity</li>\n<li><strong>Consequences</strong>: Requires implementing bytecode compiler and VM executor, but provides significant performance gains and serves as foundation for further optimizations</li>\n</ul>\n</blockquote>\n<p>The bytecode compilation approach transforms your interpreter architecture from a single evaluation phase into a two-phase system: compilation from AST to bytecode, followed by execution on the virtual machine. This transformation introduces new components while preserving your existing tokenizer and parser infrastructure.</p>\n<table>\n<thead>\n<tr>\n<th>VM Component</th>\n<th>Responsibility</th>\n<th>Data Structures</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Instruction Set</td>\n<td>Defines primitive operations</td>\n<td>Opcode enumeration, operand encoding</td>\n</tr>\n<tr>\n<td>Bytecode Compiler</td>\n<td>Translates AST to instruction sequence</td>\n<td>Symbol table, code buffer, label resolution</td>\n</tr>\n<tr>\n<td>Virtual Machine</td>\n<td>Executes instruction stream</td>\n<td>Operand stack, instruction pointer, call stack</td>\n</tr>\n<tr>\n<td>Garbage Collector</td>\n<td>Manages VM memory allocation</td>\n<td>Object heap, root set tracking</td>\n</tr>\n</tbody></table>\n<p>The instruction set design balances expressiveness with implementation simplicity. A typical instruction set includes stack manipulation (<code>PUSH</code>, <code>POP</code>), arithmetic operations (<code>ADD</code>, <code>SUB</code>, <code>MUL</code>, <code>DIV</code>), control flow (<code>JUMP</code>, <code>JUMP_IF_FALSE</code>), function operations (<code>CALL</code>, <code>RETURN</code>), and variable access (<code>LOAD_GLOBAL</code>, <code>STORE_GLOBAL</code>, <code>LOAD_LOCAL</code>, <code>STORE_LOCAL</code>).</p>\n<p><strong>Bytecode Instruction Examples</strong></p>\n<table>\n<thead>\n<tr>\n<th>Instruction</th>\n<th>Operands</th>\n<th>Stack Effect</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PUSH_NUMBER</code></td>\n<td>number value</td>\n<td>→ value</td>\n<td>Loads numeric literal onto stack</td>\n</tr>\n<tr>\n<td><code>LOAD_GLOBAL</code></td>\n<td>symbol index</td>\n<td>→ value</td>\n<td>Loads global variable value</td>\n</tr>\n<tr>\n<td><code>CALL</code></td>\n<td>argument count</td>\n<td>args, func → result</td>\n<td>Calls function with n arguments</td>\n</tr>\n<tr>\n<td><code>JUMP_IF_FALSE</code></td>\n<td>instruction offset</td>\n<td>value →</td>\n<td>Conditional branch based on stack top</td>\n</tr>\n<tr>\n<td><code>MAKE_FUNCTION</code></td>\n<td>code address, closure count</td>\n<td>closures → function</td>\n<td>Creates function object with closures</td>\n</tr>\n</tbody></table>\n<p>The compilation process traverses the AST and generates corresponding instruction sequences, handling expression evaluation order, variable scoping, and control flow. Functions require special attention as they need code addresses, closure variable capture, and proper calling conventions.</p>\n<h4 id=\"advanced-garbage-collection\">Advanced Garbage Collection</h4>\n<p>The basic interpreter likely relies on the host language&#39;s garbage collector (Python&#39;s reference counting or JavaScript&#39;s mark-and-sweep), but a production language implementation benefits from garbage collection strategies tuned for specific allocation patterns and performance characteristics.</p>\n<p><strong>Generational Garbage Collection</strong></p>\n<p>Most program values exhibit temporal locality - recently allocated objects are more likely to become garbage quickly than long-lived objects. Generational garbage collection exploits this pattern by segregating objects into generations based on age and collecting younger generations more frequently than older ones.</p>\n<p>The implementation divides the heap into nursery (young generation) and tenured (old generation) spaces. Allocation happens in the nursery, and surviving objects eventually promote to tenured space. Minor collections focus on the nursery and run frequently, while major collections examine the entire heap but run less often.</p>\n<p><strong>Copy Collection for Nursery</strong></p>\n<p>The nursery can use copy collection that divides the space into &quot;from&quot; and &quot;to&quot; semi-spaces. During collection, live objects copy from the from-space to the to-space, automatically compacting memory and eliminating fragmentation. This approach works well for short-lived objects with high garbage rates.</p>\n<h4 id=\"optimization-passes-and-analysis\">Optimization Passes and Analysis</h4>\n<p>Bytecode compilation enables sophisticated program analysis and optimization passes that improve performance without changing program semantics. These optimizations demonstrate how compilers balance compilation time against runtime performance improvements.</p>\n<p><strong>Constant Folding and Propagation</strong></p>\n<p>Many programs contain expressions that compute the same values repeatedly or perform arithmetic on compile-time constants. Constant folding evaluates these expressions during compilation, while constant propagation replaces variable references with known constant values throughout the program.</p>\n<p>For example, the expression <code>(+ 2 3)</code> can fold to <code>5</code> during compilation, eliminating runtime arithmetic. Similarly, if a variable <code>x</code> is bound to a constant value <code>42</code> and never reassigned, references to <code>x</code> can be replaced with <code>42</code>.</p>\n<p><strong>Dead Code Elimination</strong></p>\n<p>Programs often contain unreachable code paths or unused variable bindings that consume memory and compilation time without contributing to program behavior. Dead code elimination identifies and removes these constructs, reducing program size and improving cache locality.</p>\n<p>The analysis requires building a control flow graph that tracks which code paths are reachable from program entry points, then eliminating any unreachable basic blocks. Variable liveness analysis identifies unused bindings that can be eliminated.</p>\n<p><strong>Tail Call Optimization Enhancement</strong></p>\n<p>While the basic interpreter includes simple tail call optimization through trampolines, bytecode compilation enables more sophisticated tail call handling. The compiler can identify tail positions more precisely and generate specialized instructions that reuse stack frames directly, eliminating the overhead of continuation objects.</p>\n<h3 id=\"development-environment-enhancements\">Development Environment Enhancements</h3>\n<p>A complete programming language implementation extends beyond the core interpreter to include development tools that improve programmer productivity and debugging experience. These enhancements demonstrate how language tooling builds upon the interpreter infrastructure to provide richer development environments.</p>\n<h4 id=\"advanced-repl-features\">Advanced REPL Features</h4>\n<p>The Read-Eval-Print Loop serves as the primary interface for interactive development, but basic REPL implementations often lack features that programmers expect from modern development environments. Advanced REPL features transform the interpreter from a simple evaluation engine into a comprehensive development tool.</p>\n<p><strong>Command History and Editing</strong></p>\n<p>Interactive development benefits enormously from command history that allows users to recall and modify previous inputs. This feature requires maintaining a persistent history buffer and implementing line editing capabilities that support cursor movement, text insertion, and deletion operations.</p>\n<p>The implementation can integrate with existing line editing libraries (like GNU Readline) or implement basic editing from scratch. Key features include up/down arrow history navigation, left/right cursor movement, backspace deletion, and tab completion for symbol names.</p>\n<table>\n<thead>\n<tr>\n<th>REPL Command</th>\n<th>Function</th>\n<th>Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>:history</code></td>\n<td>Display recent commands</td>\n<td>Maintains ring buffer of input strings</td>\n</tr>\n<tr>\n<td><code>:load filename</code></td>\n<td>Load and evaluate file</td>\n<td>Reads file, processes through normal pipeline</td>\n</tr>\n<tr>\n<td><code>:env</code></td>\n<td>Show current bindings</td>\n<td>Iterates through environment chain</td>\n</tr>\n<tr>\n<td><code>:trace expr</code></td>\n<td>Enable evaluation tracing</td>\n<td>Wraps evaluator with debugging output</td>\n</tr>\n<tr>\n<td><code>:reset</code></td>\n<td>Clear all bindings</td>\n<td>Creates fresh global environment</td>\n</tr>\n</tbody></table>\n<p><strong>Multi-line Input Support</strong></p>\n<p>Lisp programs often span multiple lines with complex nested structures, but basic REPLs expect complete expressions on single lines. Multi-line input support allows users to enter partial expressions and continue typing until the expression is syntactically complete.</p>\n<p>The implementation requires extending the tokenizer to detect incomplete expressions (unbalanced parentheses, unterminated strings) and prompting for continuation lines. The REPL maintains a buffer of partial input until it can form a complete expression for evaluation.</p>\n<p><strong>Interactive Debugging Integration</strong></p>\n<p>When evaluation errors occur, advanced REPLs provide debugging facilities that allow users to inspect program state, examine variable values, and understand error contexts. This integration transforms error messages from opaque failures into learning opportunities.</p>\n<p>The debugging system can offer stack trace visualization, environment inspection at different call depths, and the ability to evaluate expressions in the context where errors occurred. These features require extending the evaluator to maintain detailed execution context and providing REPL commands to navigate this context.</p>\n<h4 id=\"ide-integration-and-language-server\">IDE Integration and Language Server</h4>\n<p>Modern programming environments expect language-aware editing support including syntax highlighting, error diagnostics, and code completion. The Language Server Protocol (LSP) provides a standardized way to integrate language intelligence with various editors and IDEs.</p>\n<p><strong>Syntax Analysis for Editors</strong></p>\n<p>Editors need to understand program structure to provide syntax highlighting, parentheses matching, and code folding. This requires exposing your tokenizer and parser through an API that can process partial or invalid programs without failing completely.</p>\n<p>The integration involves implementing incremental parsing that can update syntax trees efficiently as users type, along with error recovery that provides useful information even when programs contain syntax errors. The parser needs to produce partial results and continue processing after encountering errors.</p>\n<p><strong>Semantic Analysis and Error Reporting</strong></p>\n<p>Beyond syntax analysis, editors benefit from semantic analysis that understands variable bindings, function definitions, and type relationships (in typed languages). This analysis enables features like &quot;go to definition,&quot; &quot;find references,&quot; and intelligent error reporting that considers program semantics.</p>\n<p>The implementation requires extending your evaluator&#39;s environment tracking to maintain symbol definition locations and usage sites. Static analysis passes can identify potential errors (undefined variables, arity mismatches) without full program evaluation.</p>\n<p><strong>Code Completion and Documentation</strong></p>\n<p>Interactive editing benefits from code completion that suggests available functions, variables, and language constructs based on the current context. Documentation integration provides inline help for built-in functions and user-defined constructs.</p>\n<p>The completion system requires maintaining a symbol database with function signatures, documentation strings, and usage examples. The implementation can extract this information from your built-in function definitions and user code analysis.</p>\n<h4 id=\"performance-profiling-and-analysis-tools\">Performance Profiling and Analysis Tools</h4>\n<p>Understanding program performance characteristics becomes crucial as Lisp programs grow larger and more complex. Profiling tools help programmers identify performance bottlenecks and optimize critical code paths.</p>\n<p><strong>Execution Time Profiling</strong></p>\n<p>Time profiling measures how much execution time each function consumes, enabling programmers to focus optimization efforts on the most expensive operations. The implementation requires instrumenting function calls to measure entry and exit times, then aggregating statistics across program execution.</p>\n<table>\n<thead>\n<tr>\n<th>Profiling Metric</th>\n<th>Purpose</th>\n<th>Collection Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Function call count</td>\n<td>Identifies hot functions</td>\n<td>Counter increment on each call</td>\n</tr>\n<tr>\n<td>Total time per function</td>\n<td>Shows where time is spent</td>\n<td>Timestamp difference measurement</td>\n</tr>\n<tr>\n<td>Self time vs total time</td>\n<td>Distinguishes function overhead from callees</td>\n<td>Stack-based time attribution</td>\n</tr>\n<tr>\n<td>Memory allocation rate</td>\n<td>Identifies allocation-heavy functions</td>\n<td>Hook into memory allocator</td>\n</tr>\n</tbody></table>\n<p><strong>Memory Usage Analysis</strong></p>\n<p>Memory profiling helps identify memory leaks, excessive allocation, and opportunities for data structure optimization. The implementation can track allocation sites, object lifetimes, and garbage collection pressure.</p>\n<p>Memory profiling requires instrumenting object allocation and deallocation to maintain statistics about memory usage patterns. The profiler can identify functions that allocate large amounts of memory or create many short-lived objects that stress the garbage collector.</p>\n<p><strong>Execution Trace Analysis</strong></p>\n<p>Detailed execution traces show the sequence of function calls, variable accesses, and control flow decisions that occur during program execution. This information helps programmers understand program behavior and identify unexpected execution patterns.</p>\n<p>Trace analysis generates large amounts of data, so the implementation needs efficient storage and filtering mechanisms. Interactive trace browsers allow programmers to navigate execution history and correlate program behavior with source code locations.</p>\n<h3 id=\"implementation-considerations-and-architecture-evolution\">Implementation Considerations and Architecture Evolution</h3>\n<p>These extensions build upon your existing interpreter architecture while introducing new components and capabilities. The modular design you established through the four milestones provides a solid foundation that can accommodate these enhancements without requiring fundamental restructuring.</p>\n<h4 id=\"maintaining-backward-compatibility\">Maintaining Backward Compatibility</h4>\n<p>As you add new language features and optimizations, maintaining compatibility with existing programs becomes increasingly important. This requires careful attention to language semantics and implementation details that programs might depend on.</p>\n<p>Language extensions should preserve existing evaluation semantics while adding new capabilities. For example, adding vectors should not change how lists behave, and bytecode compilation should produce identical results to tree-walking interpretation. Automated testing helps ensure that enhancements do not introduce regressions.</p>\n<h4 id=\"incremental-implementation-strategy\">Incremental Implementation Strategy</h4>\n<p>These extensions represent substantial development efforts that are best approached incrementally. Each enhancement can be implemented and tested independently, allowing you to gain experience with different aspects of language implementation without overwhelming complexity.</p>\n<p>The recommended implementation order prioritizes foundational capabilities that enable subsequent enhancements:</p>\n<ol>\n<li>Additional data types (strings, vectors) that extend the core value system</li>\n<li>Advanced control structures that build on existing evaluation infrastructure  </li>\n<li>Macro system that introduces metaprogramming capabilities</li>\n<li>Bytecode compilation that provides performance improvements</li>\n<li>Development environment tools that improve programmer experience</li>\n</ol>\n<h4 id=\"performance-vs-complexity-trade-offs\">Performance vs Complexity Trade-offs</h4>\n<p>Each performance optimization introduces implementation complexity that must be weighed against the benefits provided. Bytecode compilation provides significant performance improvements but requires substantial implementation effort. Advanced garbage collection offers better memory management but introduces algorithmic complexity.</p>\n<p>The decision criteria should consider your goals: educational exploration, practical programming language development, or performance optimization learning. Different objectives justify different trade-offs between implementation complexity and performance benefits.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The extensions described above represent significant undertakings that build upon your interpreter foundation in different directions. Each category offers unique learning opportunities and practical benefits, allowing you to explore advanced language implementation topics based on your interests and goals.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Extension Category</th>\n<th>Simple Approach</th>\n<th>Advanced Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Macro System</td>\n<td>AST template substitution</td>\n<td>Hygienic macro expansion with syntax objects</td>\n</tr>\n<tr>\n<td>String Operations</td>\n<td>Python string methods wrapping</td>\n<td>Custom string type with copy-on-write optimization</td>\n</tr>\n<tr>\n<td>Hash Tables</td>\n<td>Python dict wrapping</td>\n<td>Custom hash table with open addressing</td>\n</tr>\n<tr>\n<td>Bytecode VM</td>\n<td>List-based instruction storage</td>\n<td>Packed binary instruction format</td>\n</tr>\n<tr>\n<td>Garbage Collection</td>\n<td>Reference counting with cycle detection</td>\n<td>Generational copying collector</td>\n</tr>\n<tr>\n<td>REPL Enhancement</td>\n<td>Python cmd module integration</td>\n<td>Custom line editing with termios/curses</td>\n</tr>\n<tr>\n<td>IDE Integration</td>\n<td>JSON-RPC language server</td>\n<td>Full LSP implementation with incremental parsing</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-implementation-structure\">Recommended Implementation Structure</h4>\n<p>These extensions can be integrated into your existing project structure while maintaining clear module boundaries:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>interpreter-project/\n  src/\n    tokenizer.py           # Existing tokenizer (unchanged)\n    parser.py              # Existing parser (unchanged)  \n    evaluator.py           # Enhanced with macro expansion\n    environment.py         # Existing environment (unchanged)\n    values.py              # Extended with new data types\n    \n    # New extension modules\n    macros/\n      macro_expander.py    # Macro expansion engine\n      builtin_macros.py    # Standard macro library\n      \n    bytecode/\n      compiler.py          # AST to bytecode compiler\n      vm.py               # Virtual machine implementation\n      instructions.py      # Instruction set definition\n      \n    data_types/\n      strings.py           # String operations and methods\n      vectors.py           # Vector data type implementation  \n      hash_tables.py       # Hash table implementation\n      \n    tools/\n      repl_advanced.py     # Enhanced REPL with history/editing\n      profiler.py          # Performance profiling tools\n      debugger.py          # Interactive debugging support\n      \n    lsp/\n      server.py            # Language server implementation\n      protocol.py          # LSP message handling\n      analysis.py          # Semantic analysis for IDE features</code></pre></div>\n\n<h4 id=\"macro-system-implementation-skeleton\">Macro System Implementation Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># macros/macro_expander.py</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MacroExpander</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Handles macro definition and expansion in the AST.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, environment):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.macro_environment </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> environment</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.expansion_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.max_expansion_depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> expand_macros</span><span style=\"color:#E1E4E8\">(self, ast):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Recursively expand all macros in the AST.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns new AST with macros expanded.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if AST is a macro call (list starting with macro symbol)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If macro call, retrieve macro function and expand</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If not macro call but list, recursively expand elements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If atom, return unchanged</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Track expansion depth to prevent infinite loops</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> expand_macro_call</span><span style=\"color:#E1E4E8\">(self, macro_func, args):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Expand a single macro call by applying macro to arguments.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create temporary environment for macro expansion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Bind macro parameters to unevaluated arguments</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Evaluate macro body in temporary environment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return resulting AST for further processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Increment expansion depth counter</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> define_macro</span><span style=\"color:#E1E4E8\">(self, name, parameters, body):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Define a new macro in the macro environment.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create macro function object with parameters and body</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Store in macro environment separate from regular functions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate parameter list structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Integration with existing evaluator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> evaluate_with_macros</span><span style=\"color:#E1E4E8\">(ast, env, macro_expander):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Enhanced evaluate that handles macro expansion.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Expand macros in AST before evaluation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle defmacro special form for macro definition  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Pass expanded AST to regular evaluator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"bytecode-virtual-machine-skeleton\">Bytecode Virtual Machine Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># bytecode/vm.py</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> OpCode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PUSH_NUMBER</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PUSH_SYMBOL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LOAD_GLOBAL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    STORE_GLOBAL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LOAD_LOCAL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    STORE_LOCAL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 6</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CALL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 7</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RETURN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 8</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    JUMP</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 9</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    JUMP_IF_FALSE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 10</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ADD</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 11</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SUBTRACT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 12</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MULTIPLY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 13</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DIVIDE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 14</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Instruction</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    opcode: OpCode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operand: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> VirtualMachine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Stack-based virtual machine for executing Lisp bytecode.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.call_stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.globals </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.instruction_pointer </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.instructions </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> execute</span><span style=\"color:#E1E4E8\">(self, instructions):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute a sequence of bytecode instructions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.instructions </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> instructions</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.instruction_pointer </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Main execution loop - fetch, decode, execute</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Dispatch on instruction opcode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle stack operations (push, pop, peek)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Manage call stack for function calls</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Update instruction pointer for jumps and calls</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.instruction_pointer </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.instructions):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            instruction </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.instructions[</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.instruction_pointer]</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.execute_instruction(instruction)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> execute_instruction</span><span style=\"color:#E1E4E8\">(self, instruction):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute a single bytecode instruction.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Match on instruction opcode</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Implement each instruction's stack effects</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Update instruction pointer appropriately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle function calls and returns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Manage local variable access</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> push</span><span style=\"color:#E1E4E8\">(self, value):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Push value onto operand stack.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.stack.append(value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> pop</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Pop value from operand stack.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.stack:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Stack underflow\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.stack.pop()</span></span></code></pre></div>\n\n<h4 id=\"performance-profiling-implementation\">Performance Profiling Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># tools/profiler.py</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> collections </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> defaultdict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ProfileData</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    function_name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    call_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    total_time: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    self_time: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    memory_allocated: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Profiler</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Performance profiler for Lisp interpreter execution.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.profile_data: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, ProfileData] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> defaultdict(ProfileData)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.call_stack: List[</span><span style=\"color:#79B8FF\">tuple</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []  </span><span style=\"color:#6A737D\"># (function_name, start_time)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.total_allocations </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> enable</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Enable profiling data collection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.profile_data.clear()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.call_stack.clear()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> disable</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Disable profiling and generate report.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.enabled </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.generate_report()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> enter_function</span><span style=\"color:#E1E4E8\">(self, function_name):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record function entry for timing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.enabled:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Record current timestamp</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Push function and timestamp onto call stack</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Initialize profile data if first call</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.call_stack.append((function_name, start_time))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> exit_function</span><span style=\"color:#E1E4E8\">(self, function_name):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record function exit and update timing data.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.enabled </span><span style=\"color:#F97583\">or</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.call_stack:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Pop call stack and verify function name matches</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Calculate elapsed time for this call</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Update total time and call count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Update self time (exclude time spent in callees)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        end_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stack_name, start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.call_stack.pop()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        elapsed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> end_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        profile </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.profile_data[function_name]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        profile.call_count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        profile.total_time </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> elapsed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_report</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate human-readable profiling report.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Sort functions by total time descending</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Format table with function names, call counts, times</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Include percentage of total execution time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add memory allocation statistics if available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints-for-extensions\">Milestone Checkpoints for Extensions</h4>\n<p><strong>Macro System Milestone:</strong></p>\n<ul>\n<li>Implement <code>defmacro</code> special form that defines new macros</li>\n<li>Create macro expansion phase that runs before evaluation  </li>\n<li>Test with simple macros like <code>(defmacro unless (test body) (list &#39;if (list &#39;not test) body))</code></li>\n<li>Verify macro calls expand correctly: <code>(unless (&gt; x 0) (print &quot;negative&quot;))</code> becomes <code>(if (not (&gt; x 0)) (print &quot;negative&quot;))</code></li>\n<li>Ensure macro expansion happens at appropriate time (before evaluation, not during)</li>\n</ul>\n<p><strong>Data Type Extension Milestone:</strong></p>\n<ul>\n<li>Add string operations: concatenation, substring, length, character access</li>\n<li>Implement vector type with indexing and modification operations</li>\n<li>Create hash table type with key-value storage and retrieval</li>\n<li>Test interoperability between new types and existing list operations</li>\n<li>Verify garbage collection works correctly with new data structures</li>\n</ul>\n<p><strong>Bytecode Compilation Milestone:</strong>  </p>\n<ul>\n<li>Implement basic instruction set covering arithmetic, variables, function calls</li>\n<li>Create compiler that translates AST to bytecode instruction stream</li>\n<li>Build virtual machine that executes bytecode with operand stack</li>\n<li>Verify bytecode execution produces same results as tree-walking interpreter</li>\n<li>Measure performance improvement on computation-heavy programs</li>\n</ul>\n<h4 id=\"debugging-tips-for-extensions\">Debugging Tips for Extensions</h4>\n<table>\n<thead>\n<tr>\n<th>Issue</th>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Macro expansion loops</td>\n<td>Stack overflow during expansion</td>\n<td>Recursive macro definition</td>\n<td>Check macro expansion depth counter</td>\n<td>Add maximum expansion depth limit</td>\n</tr>\n<tr>\n<td>Bytecode execution errors</td>\n<td>Wrong results or crashes</td>\n<td>Instruction encoding/decoding mismatch</td>\n<td>Compare bytecode output to expected</td>\n<td>Verify instruction operand types match</td>\n</tr>\n<tr>\n<td>Memory leaks in new data types</td>\n<td>Growing memory usage over time</td>\n<td>Missing garbage collection integration</td>\n<td>Profile memory allocation patterns</td>\n<td>Ensure new types participate in GC</td>\n</tr>\n<tr>\n<td>Performance regression</td>\n<td>Extensions slower than expected</td>\n<td>Overhead in hot code paths</td>\n<td>Profile execution with and without extensions</td>\n<td>Optimize critical path operations</td>\n</tr>\n<tr>\n<td>IDE integration failures</td>\n<td>Language server crashes or hangs</td>\n<td>Incomplete error handling in LSP</td>\n<td>Test with malformed input programs</td>\n<td>Add comprehensive error recovery</td>\n</tr>\n</tbody></table>\n<p>These extensions provide substantial opportunities for continued learning in programming language implementation, compiler optimization, and development tooling. Each enhancement demonstrates different aspects of language design and implementation, from the theoretical foundations of macro systems to the practical engineering of bytecode virtual machines and development environment integration.</p>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (1-4) - this glossary provides essential vocabulary and terminology used throughout the entire interpreter implementation</p>\n</blockquote>\n<p>Building a programming language interpreter introduces numerous specialized terms from computer science, functional programming, and language design. This glossary serves as the definitive reference for all technical terminology, data structures, functions, and concepts used throughout the Lisp interpreter design document. Understanding these terms precisely is crucial for implementing a correct and maintainable interpreter.</p>\n<h3 id=\"mental-model-the-interpreter39s-dictionary\">Mental Model: The Interpreter&#39;s Dictionary</h3>\n<p>Think of this glossary as the interpreter&#39;s comprehensive dictionary - just as human languages have dictionaries that define words, establish correct usage, and clarify subtle distinctions, our interpreter project has its own specialized vocabulary. Each term represents a precise concept with specific meaning in the context of language implementation. Like a good dictionary, this glossary not only defines terms but explains relationships between concepts, common usage patterns, and potential areas of confusion.</p>\n<p>The terminology is organized into logical categories that mirror the architecture and development progression of the interpreter. This organization helps developers understand not just individual terms, but how concepts relate to each other and fit into the larger system design.</p>\n<h3 id=\"core-data-structures-and-types\">Core Data Structures and Types</h3>\n<p>The interpreter&#39;s type system forms the foundation for representing all Lisp values and system components. These types enforce correctness through the type system and provide clear interfaces between components.</p>\n<table>\n<thead>\n<tr>\n<th>Type Name</th>\n<th>Fields</th>\n<th>Purpose</th>\n<th>Usage Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>LispValue</code></td>\n<td><code>value: Any, type: LispValueType</code></td>\n<td>Universal container for all Lisp runtime values</td>\n<td>Discriminated union pattern - check type field before accessing value</td>\n</tr>\n<tr>\n<td><code>LispValueType</code></td>\n<td>enum: <code>NUMBER, SYMBOL, LIST, FUNCTION, BUILTIN</code></td>\n<td>Type tag for runtime value discrimination</td>\n<td>Used with LispValue to implement tagged union pattern</td>\n</tr>\n<tr>\n<td><code>Token</code></td>\n<td><code>type: str, value: str, position: int</code></td>\n<td>Single lexical unit from source text</td>\n<td>Position enables source location tracking for error messages</td>\n</tr>\n<tr>\n<td><code>Environment</code></td>\n<td><code>bindings: Dict[str, LispValue], parent: Optional[Environment]</code></td>\n<td>Variable name to value mapping with lexical scope chain</td>\n<td>Parent reference implements lexical scoping through environment chain</td>\n</tr>\n<tr>\n<td><code>LispFunction</code></td>\n<td><code>parameters: List[str], body: LispValue, closure_env: Environment, name: Optional[str]</code></td>\n<td>User-defined function with closure environment</td>\n<td>Closure_env captures lexical environment at function definition time</td>\n</tr>\n<tr>\n<td><code>BuiltinFunction</code></td>\n<td><code>implementation: Callable, name: str, arity: Optional[int]</code></td>\n<td>Built-in primitive function implementation</td>\n<td>Arity None indicates variadic function (accepts any number of arguments)</td>\n</tr>\n<tr>\n<td><code>Scanner</code></td>\n<td><code>text: str, position: int, tokens: List[Token]</code></td>\n<td>Stateful tokenizer that converts text to token stream</td>\n<td>Position tracks current character index during scanning</td>\n</tr>\n<tr>\n<td><code>Parser</code></td>\n<td><code>max_nesting_depth: int</code></td>\n<td>Recursive descent parser with depth limit protection</td>\n<td>Prevents stack overflow from deeply nested expressions</td>\n</tr>\n<tr>\n<td><code>SourceLocation</code></td>\n<td><code>line: int, column: int, position: int, length: int</code></td>\n<td>Source code position information for error reporting</td>\n<td>Enables precise error location reporting to users</td>\n</tr>\n</tbody></table>\n<h3 id=\"error-hierarchy-and-exception-types\">Error Hierarchy and Exception Types</h3>\n<p>The interpreter uses a structured error hierarchy that provides specific error types for different failure modes. This hierarchy enables precise error handling and informative error messages.</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Inheritance</th>\n<th>Fields</th>\n<th>When Thrown</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>LispError</code></td>\n<td>Base class</td>\n<td><code>message: str, source_location: Optional[SourceLocation]</code></td>\n<td>Base for all interpreter errors</td>\n</tr>\n<tr>\n<td><code>TokenizerError</code></td>\n<td>Inherits from <code>LispError</code></td>\n<td>Inherited fields only</td>\n<td>Malformed tokens, unterminated strings, invalid characters</td>\n</tr>\n<tr>\n<td><code>ParseError</code></td>\n<td>Inherits from <code>LispError</code></td>\n<td>Inherited fields only</td>\n<td>Unbalanced parentheses, unexpected tokens, invalid syntax</td>\n</tr>\n<tr>\n<td><code>EvaluationError</code></td>\n<td>Base evaluation error</td>\n<td><code>message: str, source_location: Optional[int]</code></td>\n<td>Base class for runtime evaluation errors</td>\n</tr>\n<tr>\n<td><code>NameError</code></td>\n<td>Inherits from <code>EvaluationError</code></td>\n<td>Inherited fields only</td>\n<td>Undefined variable reference, unbound symbol lookup</td>\n</tr>\n<tr>\n<td><code>TypeError</code></td>\n<td>Inherits from <code>EvaluationError</code></td>\n<td>Inherited fields only</td>\n<td>Type mismatch, invalid operation on type</td>\n</tr>\n<tr>\n<td><code>ArityError</code></td>\n<td>Specific arity mismatch</td>\n<td><code>expected: int, actual: int, function_name: str</code></td>\n<td>Wrong number of arguments to function call</td>\n</tr>\n</tbody></table>\n<h3 id=\"token-classification-system\">Token Classification System</h3>\n<p>The tokenizer classifies input text into distinct token types that represent different syntactic elements. This classification drives parser behavior and enables syntax highlighting.</p>\n<table>\n<thead>\n<tr>\n<th>Token Type</th>\n<th>Symbol</th>\n<th>Recognition Pattern</th>\n<th>Semantic Role</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>TokenType.LEFT_PAREN</code></td>\n<td><code>(</code></td>\n<td>Single character <code>(</code></td>\n<td>Begins list or function call expression</td>\n</tr>\n<tr>\n<td><code>TokenType.RIGHT_PAREN</code></td>\n<td><code>)</code></td>\n<td>Single character <code>)</code></td>\n<td>Ends list or function call expression</td>\n</tr>\n<tr>\n<td><code>TokenType.NUMBER</code></td>\n<td>numeric literals</td>\n<td>Digits with optional decimal point and sign</td>\n<td>Self-evaluating numeric value</td>\n</tr>\n<tr>\n<td><code>TokenType.SYMBOL</code></td>\n<td>identifiers/operators</td>\n<td>Letter/symbol chars not in strings or parens</td>\n<td>Variable names, function names, operators</td>\n</tr>\n<tr>\n<td><code>TokenType.STRING</code></td>\n<td>string literals</td>\n<td>Text between double quotes with escape support</td>\n<td>Self-evaluating string value</td>\n</tr>\n<tr>\n<td><code>TokenType.QUOTE</code></td>\n<td><code>&#39;</code></td>\n<td>Single quote character</td>\n<td>Shorthand for quote special form</td>\n</tr>\n<tr>\n<td><code>TokenType.COMMENT</code></td>\n<td>comments</td>\n<td>Semicolon to end of line</td>\n<td>Ignored during parsing - documentation only</td>\n</tr>\n<tr>\n<td><code>TokenType.WHITESPACE</code></td>\n<td>whitespace</td>\n<td>Spaces, tabs, newlines</td>\n<td>Token separator - ignored during parsing</td>\n</tr>\n<tr>\n<td><code>TokenType.EOF</code></td>\n<td>end of file</td>\n<td>End of input stream</td>\n<td>Signals completion of token stream</td>\n</tr>\n</tbody></table>\n<h3 id=\"core-evaluation-functions\">Core Evaluation Functions</h3>\n<p>The evaluator implements the semantic rules of Lisp through a dispatch mechanism that routes different expression types to appropriate handlers. These functions form the heart of the interpreter.</p>\n<table>\n<thead>\n<tr>\n<th>Function Signature</th>\n<th>Purpose</th>\n<th>Implementation Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>evaluate(ast, env) returns LispValue</code></td>\n<td>Main evaluation dispatch</td>\n<td>Routes to specific handlers based on AST node type</td>\n</tr>\n<tr>\n<td><code>apply_function(func, args, env) returns LispValue</code></td>\n<td>Function application with argument binding</td>\n<td>Creates new environment with parameter bindings</td>\n</tr>\n<tr>\n<td><code>is_truthy(value) returns bool</code></td>\n<td>Lisp truthiness evaluation</td>\n<td>Only false and empty list are falsy in Lisp</td>\n</tr>\n<tr>\n<td><code>make_number(value) returns LispValue</code></td>\n<td>Numeric value constructor</td>\n<td>Validates numeric type and creates LispValue wrapper</td>\n</tr>\n<tr>\n<td><code>make_symbol(name) returns LispValue</code></td>\n<td>Symbol value constructor</td>\n<td>Creates symbol LispValue for identifiers and operators</td>\n</tr>\n<tr>\n<td><code>make_list(elements) returns LispValue</code></td>\n<td>List value constructor</td>\n<td>Builds proper list from element sequence</td>\n</tr>\n<tr>\n<td><code>is_number(value) returns bool</code></td>\n<td>Number type predicate</td>\n<td>Type guard for numeric operations</td>\n</tr>\n<tr>\n<td><code>is_symbol(value) returns bool</code></td>\n<td>Symbol type predicate</td>\n<td>Type guard for symbol operations</td>\n</tr>\n<tr>\n<td><code>is_list(value) returns bool</code></td>\n<td>List type predicate</td>\n<td>Type guard for list operations</td>\n</tr>\n</tbody></table>\n<h3 id=\"tokenization-and-scanning-operations\">Tokenization and Scanning Operations</h3>\n<p>The tokenizer converts raw text into a structured stream of tokens through character-by-character scanning with lookahead capabilities.</p>\n<table>\n<thead>\n<tr>\n<th>Function Signature</th>\n<th>Purpose</th>\n<th>State Management</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>scan_all() returns List[Token]</code></td>\n<td>Main tokenization loop</td>\n<td>Processes entire input text to completion</td>\n</tr>\n<tr>\n<td><code>current_char() returns Optional[str]</code></td>\n<td>Current character access</td>\n<td>Returns None at end of input</td>\n</tr>\n<tr>\n<td><code>advance() returns None</code></td>\n<td>Position advancement</td>\n<td>Moves to next character, updates line/column</td>\n</tr>\n<tr>\n<td><code>skip_whitespace() returns None</code></td>\n<td>Whitespace consumption</td>\n<td>Advances past spaces, tabs, newlines</td>\n</tr>\n<tr>\n<td><code>scan_string() returns Token</code></td>\n<td>String literal scanning</td>\n<td>Handles escape sequences within quotes</td>\n</tr>\n<tr>\n<td><code>scan_number() returns Token</code></td>\n<td>Numeric literal scanning</td>\n<td>Supports integers and floating point</td>\n</tr>\n<tr>\n<td><code>scan_symbol() returns Token</code></td>\n<td>Symbol/identifier scanning</td>\n<td>Continues until delimiter or whitespace</td>\n</tr>\n<tr>\n<td><code>scan_comment() returns Token</code></td>\n<td>Comment scanning</td>\n<td>Consumes from semicolon to end of line</td>\n</tr>\n<tr>\n<td><code>make_single_char_token(type) returns Token</code></td>\n<td>Single character token creation</td>\n<td>For parentheses and quote characters</td>\n</tr>\n</tbody></table>\n<h3 id=\"parsing-and-structure-building\">Parsing and Structure Building</h3>\n<p>The parser transforms the linear token stream into nested tree structures that represent the hierarchical structure of Lisp expressions.</p>\n<table>\n<thead>\n<tr>\n<th>Function Signature</th>\n<th>Purpose</th>\n<th>Recursion Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>parse(tokens) returns LispValue</code></td>\n<td>Main parser entry point</td>\n<td>Initiates recursive descent parsing</td>\n</tr>\n<tr>\n<td><code>read_expr(tokens, position, depth) returns (LispValue, int)</code></td>\n<td>Single expression parsing</td>\n<td>Returns parsed expression and next position</td>\n</tr>\n<tr>\n<td><code>read_list(tokens, position, depth) returns (LispValue, int)</code></td>\n<td>Parenthesized list parsing</td>\n<td>Recursively parses nested list contents</td>\n</tr>\n<tr>\n<td><code>read_quote_expr(tokens, position, depth) returns (LispValue, int)</code></td>\n<td>Quote syntax transformation</td>\n<td>Transforms &#39;expr into (quote expr)</td>\n</tr>\n<tr>\n<td><code>is_at_end(tokens, position) returns bool</code></td>\n<td>End of stream detection</td>\n<td>Prevents reading beyond token array bounds</td>\n</tr>\n<tr>\n<td><code>current_token(tokens, position) returns Token</code></td>\n<td>Safe token access</td>\n<td>Returns EOF token beyond array bounds</td>\n</tr>\n</tbody></table>\n<h3 id=\"environment-and-scope-management\">Environment and Scope Management</h3>\n<p>Environments implement lexical scoping through a chain of variable binding mappings. Each environment links to its parent scope, creating a lookup hierarchy.</p>\n<table>\n<thead>\n<tr>\n<th>Function Signature</th>\n<th>Purpose</th>\n<th>Scope Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>lookup(name) returns LispValue</code></td>\n<td>Variable resolution</td>\n<td>Searches current environment then parent chain</td>\n</tr>\n<tr>\n<td><code>define(name, value) returns None</code></td>\n<td>Variable binding</td>\n<td>Creates binding in current environment only</td>\n</tr>\n<tr>\n<td><code>extend(new_bindings) returns Environment</code></td>\n<td>Child environment creation</td>\n<td>Creates new environment with current as parent</td>\n</tr>\n<tr>\n<td><code>depth() returns int</code></td>\n<td>Scope depth calculation</td>\n<td>Returns number of environments in parent chain</td>\n</tr>\n<tr>\n<td><code>all_names() returns set[str]</code></td>\n<td>Accessible variable enumeration</td>\n<td>Returns all variables accessible from current scope</td>\n</tr>\n<tr>\n<td><code>create_global_environment() returns Environment</code></td>\n<td>Bootstrap environment creation</td>\n<td>Creates root environment with built-in functions</td>\n</tr>\n</tbody></table>\n<h3 id=\"function-system-implementation\">Function System Implementation</h3>\n<p>The function system supports both user-defined lambda functions and built-in primitive functions with proper closure environment capture.</p>\n<table>\n<thead>\n<tr>\n<th>Function Signature</th>\n<th>Purpose</th>\n<th>Closure Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>make_function(parameters, body, closure_env, name) returns LispValue</code></td>\n<td>User function creation</td>\n<td>Captures defining environment in closure</td>\n</tr>\n<tr>\n<td><code>make_builtin(implementation, name, arity) returns LispValue</code></td>\n<td>Built-in function creation</td>\n<td>No closure needed for built-ins</td>\n</tr>\n<tr>\n<td><code>is_function(value) returns bool</code></td>\n<td>Function type predicate</td>\n<td>True for both user and built-in functions</td>\n</tr>\n<tr>\n<td><code>is_user_function(value) returns bool</code></td>\n<td>User function type guard</td>\n<td>Distinguishes user-defined from built-in functions</td>\n</tr>\n<tr>\n<td><code>is_builtin_function(value) returns bool</code></td>\n<td>Built-in function type guard</td>\n<td>Identifies primitive function implementations</td>\n</tr>\n<tr>\n<td><code>apply_function(func, args, current_env) returns LispValue</code></td>\n<td>Function application</td>\n<td>Handles both user and built-in function calls</td>\n</tr>\n</tbody></table>\n<h3 id=\"list-processing-primitives\">List Processing Primitives</h3>\n<p>List operations implement the fundamental Lisp data structure manipulation primitives: cons, car, cdr, and list construction.</p>\n<table>\n<thead>\n<tr>\n<th>Function Signature</th>\n<th>Purpose</th>\n<th>List Structure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>builtin_car(args) returns LispValue</code></td>\n<td>First element extraction</td>\n<td>Returns head of cons cell or list</td>\n</tr>\n<tr>\n<td><code>builtin_cdr(args) returns LispValue</code></td>\n<td>Rest extraction</td>\n<td>Returns tail of cons cell or list</td>\n</tr>\n<tr>\n<td><code>builtin_cons(args) returns LispValue</code></td>\n<td>Pair construction</td>\n<td>Creates new cons cell with head and tail</td>\n</tr>\n<tr>\n<td><code>builtin_list(args) returns LispValue</code></td>\n<td>List construction</td>\n<td>Builds proper nil-terminated list</td>\n</tr>\n<tr>\n<td><code>builtin_null_p(args) returns LispValue</code></td>\n<td>Empty list predicate</td>\n<td>Tests for empty list (nil)</td>\n</tr>\n</tbody></table>\n<h3 id=\"arithmetic-and-comparison-operations\">Arithmetic and Comparison Operations</h3>\n<p>Built-in arithmetic and comparison functions implement the mathematical operations that form the computational core of Lisp expressions.</p>\n<table>\n<thead>\n<tr>\n<th>Function Signature</th>\n<th>Purpose</th>\n<th>Numeric Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>builtin_add(args) returns LispValue</code></td>\n<td>Addition operation</td>\n<td>Sums all arguments, supports multiple operands</td>\n</tr>\n<tr>\n<td><code>builtin_subtract(args) returns LispValue</code></td>\n<td>Subtraction operation</td>\n<td>Negation with one arg, subtraction with multiple</td>\n</tr>\n<tr>\n<td><code>builtin_multiply(args) returns LispValue</code></td>\n<td>Multiplication operation</td>\n<td>Product of all arguments</td>\n</tr>\n<tr>\n<td><code>builtin_divide(args) returns LispValue</code></td>\n<td>Division operation</td>\n<td>Reciprocal with one arg, division with multiple</td>\n</tr>\n<tr>\n<td><code>builtin_less_than(args) returns LispValue</code></td>\n<td>Less than comparison</td>\n<td>Returns boolean result of numeric comparison</td>\n</tr>\n</tbody></table>\n<h3 id=\"special-form-handlers\">Special Form Handlers</h3>\n<p>Special forms control evaluation behavior and cannot be implemented as regular functions because they require custom argument evaluation semantics.</p>\n<table>\n<thead>\n<tr>\n<th>Function Signature</th>\n<th>Purpose</th>\n<th>Evaluation Control</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>handle_if(args, env) returns LispValue</code></td>\n<td>Conditional expression</td>\n<td>Evaluates test, then either consequent or alternative</td>\n</tr>\n<tr>\n<td><code>handle_define(args, env) returns LispValue</code></td>\n<td>Variable definition</td>\n<td>Evaluates value, binds to name in current environment</td>\n</tr>\n<tr>\n<td><code>handle_lambda(args, env) returns LispValue</code></td>\n<td>Function definition</td>\n<td>Creates function value capturing current environment</td>\n</tr>\n<tr>\n<td><code>is_special_form(symbol_name) returns bool</code></td>\n<td>Special form detection</td>\n<td>Identifies symbols that require special evaluation</td>\n</tr>\n</tbody></table>\n<h3 id=\"recursion-and-tail-call-support\">Recursion and Tail Call Support</h3>\n<p>Recursion support enables functions to call themselves, with tail call optimization preventing stack overflow in tail-recursive functions.</p>\n<table>\n<thead>\n<tr>\n<th>Function Signature</th>\n<th>Purpose</th>\n<th>Optimization Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>extend_with_recursion(bindings, name, func) returns Environment</code></td>\n<td>Recursive function binding</td>\n<td>Allows function to reference itself by name</td>\n</tr>\n<tr>\n<td><code>create_tail_call(func, args, env) returns TailCall</code></td>\n<td>Tail call continuation</td>\n<td>Creates continuation for tail position calls</td>\n</tr>\n<tr>\n<td><code>execute_trampoline(initial_call) returns LispValue</code></td>\n<td>Tail call execution</td>\n<td>Iteratively executes tail calls without stack growth</td>\n</tr>\n</tbody></table>\n<h3 id=\"pipeline-coordination-and-data-flow\">Pipeline Coordination and Data Flow</h3>\n<p>The interpreter coordinates data flow between tokenizer, parser, and evaluator components through a structured pipeline architecture.</p>\n<table>\n<thead>\n<tr>\n<th>Function Signature</th>\n<th>Purpose</th>\n<th>Component Integration</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>process_expression(text, environment) returns LispValue</code></td>\n<td>Complete pipeline execution</td>\n<td>Coordinates tokenization, parsing, and evaluation</td>\n</tr>\n<tr>\n<td><code>evaluate_text(text) returns LispValue</code></td>\n<td>Multi-expression evaluation</td>\n<td>Processes multiple expressions from text input</td>\n</tr>\n<tr>\n<td><code>prepare_evaluation_context(ast) returns Environment</code></td>\n<td>Evaluation setup</td>\n<td>Prepares environment for expression evaluation</td>\n</tr>\n<tr>\n<td><code>finalize_evaluation_context(result, env) returns None</code></td>\n<td>Evaluation cleanup</td>\n<td>Handles post-evaluation state management</td>\n</tr>\n</tbody></table>\n<h3 id=\"error-handling-and-recovery\">Error Handling and Recovery</h3>\n<p>Error handling provides user-friendly error messages with source context and supports graceful recovery from certain error conditions.</p>\n<table>\n<thead>\n<tr>\n<th>Function Signature</th>\n<th>Purpose</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>format_error(error, detail_level) returns str</code></td>\n<td>Error message formatting</td>\n<td>Creates user-readable error descriptions</td>\n</tr>\n<tr>\n<td><code>extract_source_context(location, context_lines) returns str</code></td>\n<td>Source context extraction</td>\n<td>Shows relevant source lines around error</td>\n</tr>\n<tr>\n<td><code>format_suggestions(error) returns str</code></td>\n<td>Error correction suggestions</td>\n<td>Provides helpful hints for fixing errors</td>\n</tr>\n<tr>\n<td><code>recover_from_error(error) returns None</code></td>\n<td>Error recovery</td>\n<td>Attempts to continue processing after recoverable errors</td>\n</tr>\n<tr>\n<td><code>synchronize_after_error(tokens, position) returns int</code></td>\n<td>Parser synchronization</td>\n<td>Finds next valid parse position after error</td>\n</tr>\n</tbody></table>\n<h3 id=\"testing-and-validation-framework\">Testing and Validation Framework</h3>\n<p>The testing framework provides structured validation of interpreter components and milestone progress tracking.</p>\n<table>\n<thead>\n<tr>\n<th>Function Signature</th>\n<th>Purpose</th>\n<th>Validation Scope</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>assertTokenSequence(text, expected_tokens)</code></td>\n<td>Tokenization validation</td>\n<td>Verifies tokenizer produces expected token sequence</td>\n</tr>\n<tr>\n<td><code>assertParseResult(text, expected_ast)</code></td>\n<td>Parsing validation</td>\n<td>Verifies parser produces expected AST structure</td>\n</tr>\n<tr>\n<td><code>assertEvaluatesTo(program, expected_result)</code></td>\n<td>Evaluation validation</td>\n<td>Verifies program evaluation produces expected result</td>\n</tr>\n<tr>\n<td><code>assertTokenizerError(text, pattern)</code></td>\n<td>Tokenizer error validation</td>\n<td>Verifies tokenizer detects expected error conditions</td>\n</tr>\n<tr>\n<td><code>assertParseError(text, pattern)</code></td>\n<td>Parser error validation</td>\n<td>Verifies parser detects expected syntax errors</td>\n</tr>\n<tr>\n<td><code>assertEvaluationError(program, error_type)</code></td>\n<td>Evaluation error validation</td>\n<td>Verifies evaluator detects expected runtime errors</td>\n</tr>\n<tr>\n<td><code>validate_milestone_progress(milestone_number)</code></td>\n<td>Milestone validation</td>\n<td>Automated verification of milestone completion</td>\n</tr>\n</tbody></table>\n<h3 id=\"debugging-and-introspection-tools\">Debugging and Introspection Tools</h3>\n<p>Debugging tools provide visibility into interpreter internals and help developers understand evaluation behavior and diagnose problems.</p>\n<table>\n<thead>\n<tr>\n<th>Type/Function</th>\n<th>Purpose</th>\n<th>Debugging Capability</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>TraceEvent</code></td>\n<td><code>event_type: str, expression: Any, environment_id: int, depth: int, result: Optional[Any], error: Optional[str], timestamp: float</code></td>\n<td>Single evaluation step record</td>\n</tr>\n<tr>\n<td><code>EvaluationTracer</code></td>\n<td><code>events: List[TraceEvent], current_depth: int, output_file, max_depth, enabled: bool</code></td>\n<td>Evaluation tracing system</td>\n</tr>\n<tr>\n<td><code>EnvironmentInspector</code></td>\n<td><code>environment: Environment, inspection_cache: Dict[int, Dict]</code></td>\n<td>Environment introspection</td>\n</tr>\n<tr>\n<td><code>trace_evaluation(expression, environment)</code></td>\n<td>Trace single evaluation</td>\n<td>Context manager for detailed evaluation tracing</td>\n</tr>\n<tr>\n<td><code>log_lookup(variable_name, environment, result)</code></td>\n<td>Variable lookup logging</td>\n<td>Records variable resolution process</td>\n</tr>\n<tr>\n<td><code>format_trace_output() returns str</code></td>\n<td>Trace formatting</td>\n<td>Human-readable trace output generation</td>\n</tr>\n<tr>\n<td><code>inspect_chain() returns Dict</code></td>\n<td>Environment chain inspection</td>\n<td>Analysis of entire environment scope chain</td>\n</tr>\n<tr>\n<td><code>diagnose_lookup_failure(variable_name) returns str</code></td>\n<td>Lookup failure diagnosis</td>\n<td>Explains why variable lookup failed</td>\n</tr>\n</tbody></table>\n<h3 id=\"ast-analysis-and-visualization\">AST Analysis and Visualization</h3>\n<p>Abstract syntax tree analysis tools help developers understand program structure and identify potential issues in parsed expressions.</p>\n<table>\n<thead>\n<tr>\n<th>Function Signature</th>\n<th>Purpose</th>\n<th>Analysis Capability</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>visualize_tree(ast, format) returns str</code></td>\n<td>AST visualization</td>\n<td>Generates visual representation of syntax tree</td>\n</tr>\n<tr>\n<td><code>analyze_structure(ast) returns Dict</code></td>\n<td>Structure analysis</td>\n<td>Identifies structural properties and potential issues</td>\n</tr>\n<tr>\n<td><code>compare_structures(ast1, ast2) returns Dict</code></td>\n<td>Structure comparison</td>\n<td>Highlights differences between two ASTs</td>\n</tr>\n</tbody></table>\n<h3 id=\"repl-and-interactive-debugging\">REPL and Interactive Debugging</h3>\n<p>The Read-Eval-Print Loop provides interactive development capabilities with integrated debugging commands.</p>\n<table>\n<thead>\n<tr>\n<th>Type/Function</th>\n<th>Purpose</th>\n<th>Interactive Capability</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>REPLDebugger</code></td>\n<td><code>evaluator: Evaluator, tracer: EvaluationTracer, commands: Dict[str, Callable]</code></td>\n<td>Interactive debugging interface</td>\n</tr>\n<tr>\n<td><code>handle_debug_command(command_line) returns str</code></td>\n<td>Debug command processing</td>\n<td>Processes and executes debug commands</td>\n</tr>\n<tr>\n<td><code>cmd_trace(expression_text) returns str</code></td>\n<td>Trace command</td>\n<td>Enables evaluation tracing for specific expression</td>\n</tr>\n<tr>\n<td><code>cmd_environment(args) returns str</code></td>\n<td>Environment command</td>\n<td>Displays current environment information</td>\n</tr>\n</tbody></table>\n<h3 id=\"constants-and-predefined-values\">Constants and Predefined Values</h3>\n<p>The interpreter defines several important constants that represent special values and configuration parameters.</p>\n<table>\n<thead>\n<tr>\n<th>Constant Name</th>\n<th>Value/Type</th>\n<th>Purpose</th>\n<th>Usage Context</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>LISP_TRUE</code></td>\n<td>Boolean true value</td>\n<td>Represents truth in Lisp expressions</td>\n<td>Returned by comparison and logical operations</td>\n</tr>\n<tr>\n<td><code>LISP_FALSE</code></td>\n<td>Boolean false value</td>\n<td>Represents falsehood in Lisp expressions</td>\n<td>Only LISP_FALSE and EMPTY_LIST are falsy</td>\n</tr>\n<tr>\n<td><code>EMPTY_LIST</code></td>\n<td>Empty list representation</td>\n<td>Represents nil/empty list</td>\n<td>Terminates proper lists, falsy in conditionals</td>\n</tr>\n<tr>\n<td><code>QUOTE_SYMBOL</code></td>\n<td>String &#39;quote&#39;</td>\n<td>Symbol name for quote special form</td>\n<td>Used in quote syntax transformation</td>\n</tr>\n<tr>\n<td><code>BUILTIN_FUNCTIONS</code></td>\n<td>Dictionary mapping</td>\n<td>Registry of built-in function implementations</td>\n<td>Populated during global environment creation</td>\n</tr>\n<tr>\n<td><code>SPECIAL_FORMS</code></td>\n<td>Dictionary mapping</td>\n<td>Registry of special form handlers</td>\n<td>Maps special form names to handler functions</td>\n</tr>\n<tr>\n<td><code>ESCAPE_SEQUENCES</code></td>\n<td>Character mapping</td>\n<td>Maps escape sequences to actual characters</td>\n<td>Used during string literal tokenization</td>\n</tr>\n</tbody></table>\n<h3 id=\"session-and-state-management\">Session and State Management</h3>\n<p>Session management maintains interpreter state across multiple evaluations and provides coordination between interactive sessions.</p>\n<table>\n<thead>\n<tr>\n<th>Type/Function</th>\n<th>Purpose</th>\n<th>State Persistence</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>InterpreterSession</code></td>\n<td><code>global_env: Environment, expression_count: int</code></td>\n<td>Persistent interpreter session</td>\n</tr>\n<tr>\n<td><code>PipelineCoordinator</code></td>\n<td><code>tokenizer, parser, evaluator</code> components</td>\n<td>Pipeline component coordination</td>\n</tr>\n<tr>\n<td><code>StateManager</code></td>\n<td><code>global_environment: Environment, evaluation_count: int</code></td>\n<td>Global state management</td>\n</tr>\n<tr>\n<td><code>with_context(context)</code></td>\n<td>Error context management</td>\n<td>Adds contextual information to errors</td>\n</tr>\n<tr>\n<td><code>handle_define_operation(name, value)</code></td>\n<td>Global definition processing</td>\n<td>Updates persistent global environment</td>\n</tr>\n</tbody></table>\n<h3 id=\"key-architectural-concepts\">Key Architectural Concepts</h3>\n<p>Understanding these fundamental concepts is crucial for implementing and extending the interpreter correctly.</p>\n<p><strong>S-expression</strong>: The fundamental syntactic structure of Lisp, where both code and data are represented as symbolic expressions using a uniform parenthesized syntax. S-expressions enable homoiconicity - the property that code and data share the same representation.</p>\n<p><strong>Tree-walking interpreter</strong>: An interpretation strategy that directly evaluates abstract syntax tree nodes through recursive function calls, as opposed to compiling to bytecode or machine code first.</p>\n<p><strong>Lexical scoping</strong>: Variable resolution based on where variables are defined in the source code (lexically), not where they are used. Variables are resolved by searching the environment chain from innermost to outermost scope.</p>\n<p><strong>Closure</strong>: A function that captures and retains access to variables from its defining lexical environment, even when called from a different scope. Closures enable first-class functions and proper lexical scoping.</p>\n<p><strong>Environment chain</strong>: The linked sequence of nested environments that implements lexical scoping. Variable lookup traverses this chain from current environment toward root until finding a binding.</p>\n<p><strong>Homoiconicity</strong>: The property where code and data have the same syntactic representation. In Lisp, program source code is written as S-expressions, which are also the primary data structure.</p>\n<p><strong>Special forms</strong>: Language constructs like <code>if</code>, <code>define</code>, and <code>lambda</code> that control evaluation behavior and cannot be implemented as regular functions because they require custom argument evaluation semantics.</p>\n<p><strong>Eager evaluation</strong>: The evaluation strategy where all function arguments are fully evaluated before the function is called, as opposed to lazy evaluation where arguments are evaluated only when needed.</p>\n<p><strong>Recursive descent parsing</strong>: A parsing technique where the parser is structured as a set of mutually recursive functions, each responsible for parsing a particular grammatical construct.</p>\n<p><strong>Tail call optimization</strong>: An optimization technique that converts tail-recursive function calls into loops to prevent stack overflow, allowing efficient recursive algorithms.</p>\n<h3 id=\"common-implementation-pitfalls\">Common Implementation Pitfalls</h3>\n<p>Understanding these common mistakes helps developers avoid frequently encountered problems during interpreter implementation.</p>\n<p>⚠️ <strong>Pitfall: Treating Special Forms as Functions</strong>\nSpecial forms like <code>if</code>, <code>define</code>, and <code>lambda</code> control evaluation behavior and must be handled before normal function application. If treated as regular functions, their arguments will be evaluated eagerly, breaking the intended semantics. For example, <code>(if false (error &quot;boom&quot;) 42)</code> should return 42, but if <code>if</code> were a function, the error would be evaluated before <code>if</code> could choose which branch to take.</p>\n<p>⚠️ <strong>Pitfall: Broken Environment Chain References</strong>\nEnvironment parent references must form a proper chain without cycles. If parent references are incorrectly assigned or mutated, variable lookup can fail or enter infinite loops. Always ensure parent references point upward in the scope hierarchy and are never modified after creation.</p>\n<p>⚠️ <strong>Pitfall: Closure Environment Capture Errors</strong>\nLambda functions must capture the environment where they are defined, not where they are called. A common mistake is passing the call-site environment instead of the definition-site environment, breaking lexical scoping and making closures behave like dynamic scoping.</p>\n<p>⚠️ <strong>Pitfall: Improper List Structure Handling</strong>\nLisp lists must be properly terminated with the empty list marker. Improper lists (not nil-terminated) can cause infinite loops in recursive list processing functions. Always check for proper list termination when implementing car, cdr, and list traversal operations.</p>\n<p>⚠️ <strong>Pitfall: Tokenization Boundary Detection Errors</strong>\nThe tokenizer must correctly identify token boundaries, especially with numbers, symbols, and string literals. Common errors include failing to handle negative numbers, not properly escaping string literals, or incorrectly splitting compound tokens.</p>\n<p>⚠️ <strong>Pitfall: Parser Stack Overflow on Deep Nesting</strong>\nDeeply nested expressions can cause stack overflow in recursive descent parsers. Implement maximum depth limits and provide helpful error messages when nesting limits are exceeded rather than allowing silent crashes.</p>\n<p>⚠️ <strong>Pitfall: Incorrect Arity Checking</strong>\nFunctions must validate that they receive the correct number of arguments. Built-in functions should check argument count before processing, and user-defined functions should verify that the number of arguments matches the number of parameters.</p>\n<h3 id=\"future-extension-terminology\">Future Extension Terminology</h3>\n<p>These terms relate to potential enhancements that could be added to the basic interpreter architecture.</p>\n<p><strong>Macro system</strong>: A metaprogramming facility that allows manipulation of code as data before evaluation, enabling domain-specific languages and syntactic extensions.</p>\n<p><strong>Bytecode compilation</strong>: An alternative implementation strategy where the AST is compiled into a linear sequence of simple instructions that are executed by a virtual machine.</p>\n<p><strong>Virtual machine</strong>: A specialized execution engine optimized for running bytecode instructions, typically using a stack-based architecture for expression evaluation.</p>\n<p><strong>Hygienic macros</strong>: A macro system that automatically prevents variable capture problems by ensuring macro-generated identifiers don&#39;t accidentally clash with user variables.</p>\n<p><strong>Generational garbage collection</strong>: A memory management strategy that segregates objects by age, collecting short-lived objects more frequently than long-lived ones.</p>\n<p><strong>Language server protocol</strong>: A standardized communication protocol for integrating language intelligence features like autocomplete, error checking, and refactoring with text editors and IDEs.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The implementation of the Lisp interpreter requires careful attention to naming conventions and consistent terminology throughout the codebase. This guidance provides the foundation for maintainable and extensible code.</p>\n<h4 id=\"recommended-type-system-structure\">Recommended Type System Structure</h4>\n<p>The core type system should establish clear discriminated unions and maintain type safety through careful interface design:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional, Any, Callable, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispValueType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NUMBER</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"number\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SYMBOL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"symbol\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LIST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"list\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    FUNCTION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"function\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BUILTIN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"builtin\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispValue</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value: Any</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    type</span><span style=\"color:#E1E4E8\">: LispValueType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add value type validation based on LispValueType</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure value matches expected type constraints</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add helpful error messages for type mismatches</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LEFT_PAREN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"(\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    RIGHT_PAREN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \")\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    NUMBER</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"number\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SYMBOL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"symbol\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    STRING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"string\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    QUOTE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"'\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    COMMENT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"comment\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WHITESPACE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"whitespace\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EOF</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"eof\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Token</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    type</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#6A737D\">  # Should be TokenType enum value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    value: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    position: </span><span style=\"color:#79B8FF\">int</span></span></code></pre></div>\n\n<h4 id=\"error-hierarchy-implementation\">Error Hierarchy Implementation</h4>\n<p>The error system provides structured exception handling with rich context information:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SourceLocation</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    column: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    position: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    length: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, source_location: Optional[SourceLocation] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.source_location </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> source_location</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TokenizerError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EvaluationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">LispError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, source_location: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Extend to include evaluation context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add stack trace information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Include expression that caused the error</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> NameError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#79B8FF\"> TypeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">EvaluationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ArityError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    actual: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    function_name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.function_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> expects </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.expected</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> arguments, got </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.actual</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<h4 id=\"environment-implementation-framework\">Environment Implementation Framework</h4>\n<p>The environment system implements lexical scoping through parent chain linking:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Environment</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    bindings: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, LispValue]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parent: Optional[</span><span style=\"color:#9ECBFF\">'Environment'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> lookup</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Search current environment bindings first</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: If not found, recursively search parent chain</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: If not found in any environment, raise NameError</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Include helpful suggestion for similar names</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> define</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: LispValue) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add binding to current environment only</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate that name is valid identifier</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Consider whether to allow redefinition</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> extend</span><span style=\"color:#E1E4E8\">(self, new_bindings: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, LispValue]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'Environment'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create new environment with self as parent</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add new_bindings to child environment if provided</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return child environment for method chaining</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"function-system-structure\">Function System Structure</h4>\n<p>The function system supports both user-defined and built-in functions with unified application:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LispFunction</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parameters: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    body: LispValue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    closure_env: Environment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BuiltinFunction</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    implementation: Callable</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    arity: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#6A737D\">  # None indicates variadic</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_function</span><span style=\"color:#E1E4E8\">(parameters: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], body: LispValue, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 closure_env: Environment, name: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate parameter list (no duplicates, valid identifiers)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create LispFunction object with provided parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Wrap in LispValue with FUNCTION type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return wrapped function value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> make_builtin</span><span style=\"color:#E1E4E8\">(implementation: Callable, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                arity: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> LispValue:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create BuiltinFunction object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Wrap in LispValue with BUILTIN type  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add to global builtin registry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return wrapped builtin value</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"debugging-and-tracing-infrastructure\">Debugging and Tracing Infrastructure</h4>\n<p>The debugging system provides comprehensive visibility into interpreter execution:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TraceEvent</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expression: Any</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    environment_id: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    depth: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result: Optional[Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    error: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EvaluationTracer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    events: List[TraceEvent]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_depth: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    output_file: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_depth: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    enabled: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> trace_evaluation</span><span style=\"color:#E1E4E8\">(self, expression: Any, environment: Environment):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create context manager for tracing evaluation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Record entry and exit events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle exceptions and record error events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Respect max_depth and enabled settings</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EnvironmentInspector</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    environment: Environment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inspection_cache: Dict[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Dict]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> inspect_chain</span><span style=\"color:#E1E4E8\">(self) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Walk entire environment chain</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Collect all bindings with scope information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Identify variable shadowing situations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Cache results for performance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-validation-framework\">Milestone Validation Framework</h4>\n<p>Each milestone requires specific validation to ensure correct implementation progress:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MilestoneValidator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, interpreter_instance):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.interpreter </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> interpreter_instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_milestone_1</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate S-Expression Parser completion\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test tokenization of various input forms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify parsing of nested list structures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check quote syntax transformation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate error handling for malformed input</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_milestone_2</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate Basic Evaluation completion\"\"\"</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test arithmetic operations with various operands</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify conditional evaluation (if statements)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check comparison operations return boolean values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate error handling for type mismatches</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_milestone_3</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate Variables and Functions completion\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test variable definition and lookup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify lambda function creation and application</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check lexical scoping behavior with nested functions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate closure environment capture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_milestone_4</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate List Operations &#x26; Recursion completion\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test car, cdr, cons operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify recursive function definitions work</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check tail call optimization if implemented</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate proper vs improper list handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"testing-assertion-framework\">Testing Assertion Framework</h4>\n<p>The testing framework provides structured assertions for validating interpreter behavior:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> assertTokenSequence</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, expected_tokens: List[</span><span style=\"color:#79B8FF\">tuple</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Verify tokenization produces expected sequence\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Tokenize input text</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Compare resulting tokens with expected sequence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check token types, values, and positions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Provide detailed failure messages</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> assertParseResult</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, expected_ast: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Verify parsing produces expected AST\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Parse input text through full pipeline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Compare resulting AST with expected structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle nested structure comparison recursively</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Provide tree diff on failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> assertEvaluatesTo</span><span style=\"color:#E1E4E8\">(program: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, expected_result: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Verify evaluation produces expected result\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Run program through complete interpreter pipeline</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Compare result with expected value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle different LispValue types appropriately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Provide context on evaluation failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p>This glossary establishes the complete vocabulary and conceptual framework necessary for implementing a correct and maintainable Lisp interpreter. Each term represents a precise concept with specific meaning in the context of language implementation, and understanding these relationships is crucial for successful interpreter development.</p>\n","toc":[{"level":1,"text":"Lisp Interpreter: Design Document","id":"lisp-interpreter-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: The Universal Calculator","id":"mental-model-the-universal-calculator"},{"level":3,"text":"Interpreter Implementation Approaches","id":"interpreter-implementation-approaches"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Functional Requirements","id":"functional-requirements"},{"level":3,"text":"Explicit Non-Goals","id":"explicit-non-goals"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Three-Stage Pipeline: How Text Flows Through Tokenizer, Parser, and Evaluator Stages","id":"three-stage-pipeline-how-text-flows-through-tokenizer-parser-and-evaluator-stages"},{"level":3,"text":"Recommended Module Organization: How to Structure the Codebase for Maintainability and Testability","id":"recommended-module-organization-how-to-structure-the-codebase-for-maintainability-and-testability"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Mental Model: The Universal Data Container","id":"mental-model-the-universal-data-container"},{"level":3,"text":"Lisp Value Types","id":"lisp-value-types"},{"level":4,"text":"LispValue Core Structure","id":"lispvalue-core-structure"},{"level":4,"text":"LispValueType Enumeration","id":"lispvaluetype-enumeration"},{"level":4,"text":"Number Type Representation","id":"number-type-representation"},{"level":4,"text":"Symbol Type Representation","id":"symbol-type-representation"},{"level":4,"text":"List Type Representation","id":"list-type-representation"},{"level":4,"text":"Function Type Representation","id":"function-type-representation"},{"level":4,"text":"Type Predicate Functions","id":"type-predicate-functions"},{"level":3,"text":"Environment Structure","id":"environment-structure"},{"level":4,"text":"Mental Model: Nested Filing Cabinets","id":"mental-model-nested-filing-cabinets"},{"level":4,"text":"Environment Core Structure","id":"environment-core-structure"},{"level":4,"text":"Environment Chain Operations","id":"environment-chain-operations"},{"level":4,"text":"Environment Types and Lifecycles","id":"environment-types-and-lifecycles"},{"level":4,"text":"Closure Environment Capture","id":"closure-environment-capture"},{"level":4,"text":"Global Environment Initialization","id":"global-environment-initialization"},{"level":4,"text":"Environment Error Conditions","id":"environment-error-conditions"},{"level":3,"text":"Abstract Syntax Tree","id":"abstract-syntax-tree"},{"level":4,"text":"Mental Model: Structured Blueprint","id":"mental-model-structured-blueprint"},{"level":4,"text":"AST Node Types","id":"ast-node-types"},{"level":4,"text":"AST Construction Process","id":"ast-construction-process"},{"level":4,"text":"AST Traversal Patterns","id":"ast-traversal-patterns"},{"level":4,"text":"Special Form AST Recognition","id":"special-form-ast-recognition"},{"level":4,"text":"AST Transformation and Optimization","id":"ast-transformation-and-optimization"},{"level":4,"text":"AST Error Conditions","id":"ast-error-conditions"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Core Data Structure Implementation","id":"core-data-structure-implementation"},{"level":4,"text":"Environment Implementation Skeleton","id":"environment-implementation-skeleton"},{"level":4,"text":"Function Type Implementation Skeleton","id":"function-type-implementation-skeleton"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Tokenizer Design","id":"tokenizer-design"},{"level":3,"text":"Mental Model: Text Dissection","id":"mental-model-text-dissection"},{"level":3,"text":"Token Types and Recognition","id":"token-types-and-recognition"},{"level":3,"text":"Tokenization Algorithm","id":"tokenization-algorithm"},{"level":3,"text":"Common Tokenizer Pitfalls","id":"common-tokenizer-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Parser Design","id":"parser-design"},{"level":3,"text":"Mental Model: Nested Container Assembly","id":"mental-model-nested-container-assembly"},{"level":3,"text":"Recursive Descent Strategy","id":"recursive-descent-strategy"},{"level":3,"text":"Quote Syntax Transformation","id":"quote-syntax-transformation"},{"level":3,"text":"Common Parser Pitfalls","id":"common-parser-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Evaluator Design","id":"evaluator-design"},{"level":3,"text":"Mental Model: Universal Calculator with Memory","id":"mental-model-universal-calculator-with-memory"},{"level":3,"text":"Core Evaluation Rules","id":"core-evaluation-rules"},{"level":3,"text":"Special Forms vs Function Calls","id":"special-forms-vs-function-calls"},{"level":3,"text":"Common Evaluator Pitfalls","id":"common-evaluator-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Environment and Scope Management","id":"environment-and-scope-management"},{"level":3,"text":"Mental Model: Nested Filing Cabinets","id":"mental-model-nested-filing-cabinets"},{"level":3,"text":"Lexical Scoping Rules","id":"lexical-scoping-rules"},{"level":3,"text":"Closure Environment Capture","id":"closure-environment-capture"},{"level":3,"text":"Common Environment Pitfalls","id":"common-environment-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Module Structure","id":"module-structure"},{"level":4,"text":"Environment Infrastructure (Complete Implementation)","id":"environment-infrastructure-complete-implementation"},{"level":4,"text":"Core Logic Skeleton for Environment Integration","id":"core-logic-skeleton-for-environment-integration"},{"level":4,"text":"Language-Specific Hints for Python","id":"language-specific-hints-for-python"},{"level":4,"text":"Milestone Checkpoint: Environment and Scoping","id":"milestone-checkpoint-environment-and-scoping"},{"level":2,"text":"Function System Design","id":"function-system-design"},{"level":3,"text":"Mental Model: Customizable Machines","id":"mental-model-customizable-machines"},{"level":3,"text":"Lambda Function Creation","id":"lambda-function-creation"},{"level":3,"text":"Function Application Process","id":"function-application-process"},{"level":3,"text":"Common Function Pitfalls","id":"common-function-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File/Module Structure","id":"recommended-filemodule-structure"},{"level":4,"text":"Core Function Types (Complete Infrastructure)","id":"core-function-types-complete-infrastructure"},{"level":4,"text":"Lambda Special Form Handler (Core Logic Skeleton)","id":"lambda-special-form-handler-core-logic-skeleton"},{"level":4,"text":"Function Application Logic (Core Logic Skeleton)","id":"function-application-logic-core-logic-skeleton"},{"level":4,"text":"Integration with Evaluator (Complete Infrastructure)","id":"integration-with-evaluator-complete-infrastructure"},{"level":4,"text":"Milestone Checkpoint: Function System","id":"milestone-checkpoint-function-system"},{"level":2,"text":"List Operations and Recursion","id":"list-operations-and-recursion"},{"level":3,"text":"Mental Model: Chain Links","id":"mental-model-chain-links"},{"level":3,"text":"Core List Primitives","id":"core-list-primitives"},{"level":3,"text":"Recursive Function Support","id":"recursive-function-support"},{"level":3,"text":"Tail Call Optimization Strategy","id":"tail-call-optimization-strategy"},{"level":3,"text":"Common List Operation Pitfalls","id":"common-list-operation-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Component Interactions and Data Flow","id":"component-interactions-and-data-flow"},{"level":3,"text":"End-to-End Processing Pipeline","id":"end-to-end-processing-pipeline"},{"level":4,"text":"Mental Model: Assembly Line with Feedback","id":"mental-model-assembly-line-with-feedback"},{"level":4,"text":"Pipeline Processing Stages","id":"pipeline-processing-stages"},{"level":4,"text":"Data Transformation Flow","id":"data-transformation-flow"},{"level":4,"text":"Pipeline Coordination Logic","id":"pipeline-coordination-logic"},{"level":4,"text":"Error Recovery and Continuation","id":"error-recovery-and-continuation"},{"level":3,"text":"Error Propagation Between Components","id":"error-propagation-between-components"},{"level":4,"text":"Mental Model: Quality Control Checkpoints","id":"mental-model-quality-control-checkpoints"},{"level":4,"text":"Error Classification Hierarchy","id":"error-classification-hierarchy"},{"level":4,"text":"Error Context Enrichment","id":"error-context-enrichment"},{"level":4,"text":"Error Reporting Strategies","id":"error-reporting-strategies"},{"level":4,"text":"Error Recovery Mechanisms","id":"error-recovery-mechanisms"},{"level":3,"text":"State Management Across Evaluations","id":"state-management-across-evaluations"},{"level":4,"text":"Mental Model: Persistent Workspace","id":"mental-model-persistent-workspace"},{"level":4,"text":"Global Environment Persistence","id":"global-environment-persistence"},{"level":4,"text":"Environment Chain Management","id":"environment-chain-management"},{"level":4,"text":"Closure Environment Capture","id":"closure-environment-capture"},{"level":4,"text":"State Consistency and Isolation","id":"state-consistency-and-isolation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Pipeline Coordinator Infrastructure (Complete)","id":"pipeline-coordinator-infrastructure-complete"},{"level":4,"text":"Error Class Hierarchy (Complete)","id":"error-class-hierarchy-complete"},{"level":4,"text":"Core Pipeline Logic Skeleton","id":"core-pipeline-logic-skeleton"},{"level":4,"text":"State Management Core Logic Skeleton","id":"state-management-core-logic-skeleton"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Mental Model: The Quality Control Checkpoint System","id":"mental-model-the-quality-control-checkpoint-system"},{"level":3,"text":"Error Categories and Detection","id":"error-categories-and-detection"},{"level":3,"text":"Common Error Detection Pitfalls","id":"common-error-detection-pitfalls"},{"level":3,"text":"User-Friendly Error Reporting","id":"user-friendly-error-reporting"},{"level":3,"text":"Error Recovery Strategies","id":"error-recovery-strategies"},{"level":3,"text":"Edge Case Handling","id":"edge-case-handling"},{"level":3,"text":"Common Edge Case Pitfalls","id":"common-edge-case-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Mental Model: The Quality Pyramid","id":"mental-model-the-quality-pyramid"},{"level":3,"text":"Unit Testing by Component","id":"unit-testing-by-component"},{"level":4,"text":"Tokenizer Unit Testing","id":"tokenizer-unit-testing"},{"level":4,"text":"Parser Unit Testing","id":"parser-unit-testing"},{"level":4,"text":"Evaluator Unit Testing","id":"evaluator-unit-testing"},{"level":3,"text":"Integration Testing Strategy","id":"integration-testing-strategy"},{"level":4,"text":"Pipeline Integration Tests","id":"pipeline-integration-tests"},{"level":4,"text":"Environment Integration Tests","id":"environment-integration-tests"},{"level":4,"text":"State Persistence Integration Tests","id":"state-persistence-integration-tests"},{"level":3,"text":"Milestone Validation Checkpoints","id":"milestone-validation-checkpoints"},{"level":4,"text":"Milestone 1 Checkpoint: S-Expression Parser","id":"milestone-1-checkpoint-s-expression-parser"},{"level":4,"text":"Milestone 2 Checkpoint: Basic Evaluation","id":"milestone-2-checkpoint-basic-evaluation"},{"level":4,"text":"Milestone 3 Checkpoint: Variables and Functions","id":"milestone-3-checkpoint-variables-and-functions"},{"level":4,"text":"Milestone 4 Checkpoint: List Operations &amp; Recursion","id":"milestone-4-checkpoint-list-operations-amp-recursion"},{"level":3,"text":"Common Testing Pitfalls","id":"common-testing-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Testing Framework Setup","id":"testing-framework-setup"},{"level":4,"text":"Unit Testing Infrastructure","id":"unit-testing-infrastructure"},{"level":4,"text":"Integration Testing Framework","id":"integration-testing-framework"},{"level":4,"text":"Milestone Checkpoint Implementation","id":"milestone-checkpoint-implementation"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Mental Model: The Detective&#39;s Multi-Level Investigation","id":"mental-model-the-detective39s-multi-level-investigation"},{"level":3,"text":"Interpreter-Specific Debugging Techniques","id":"interpreter-specific-debugging-techniques"},{"level":4,"text":"Environment State Inspection","id":"environment-state-inspection"},{"level":4,"text":"Evaluation Trace Generation","id":"evaluation-trace-generation"},{"level":4,"text":"AST Structure Examination","id":"ast-structure-examination"},{"level":4,"text":"Token Stream Analysis","id":"token-stream-analysis"},{"level":3,"text":"Common Bug Patterns","id":"common-bug-patterns"},{"level":4,"text":"Environment Chain Corruption Patterns","id":"environment-chain-corruption-patterns"},{"level":4,"text":"Special Form Mishandling Patterns","id":"special-form-mishandling-patterns"},{"level":4,"text":"Function Application Error Patterns","id":"function-application-error-patterns"},{"level":4,"text":"List Operation Implementation Bugs","id":"list-operation-implementation-bugs"},{"level":3,"text":"Building Diagnostic Tools","id":"building-diagnostic-tools"},{"level":4,"text":"Evaluation Tracer Implementation","id":"evaluation-tracer-implementation"},{"level":4,"text":"Environment Inspector Interface","id":"environment-inspector-interface"},{"level":4,"text":"AST Visualization Tools","id":"ast-visualization-tools"},{"level":4,"text":"Interactive REPL Debugging","id":"interactive-repl-debugging"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Evaluation Tracer Infrastructure","id":"evaluation-tracer-infrastructure"},{"level":4,"text":"Environment Inspector Implementation","id":"environment-inspector-implementation"},{"level":4,"text":"AST Visualizer Tools","id":"ast-visualizer-tools"},{"level":4,"text":"REPL Debug Integration","id":"repl-debug-integration"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Mental Model: The Expandable Workshop","id":"mental-model-the-expandable-workshop"},{"level":3,"text":"Additional Language Features","id":"additional-language-features"},{"level":4,"text":"Macro System Implementation","id":"macro-system-implementation"},{"level":4,"text":"Advanced Data Types","id":"advanced-data-types"},{"level":4,"text":"Advanced Control Structures","id":"advanced-control-structures"},{"level":3,"text":"Performance Optimization Opportunities","id":"performance-optimization-opportunities"},{"level":4,"text":"Bytecode Compilation and Virtual Machine","id":"bytecode-compilation-and-virtual-machine"},{"level":4,"text":"Advanced Garbage Collection","id":"advanced-garbage-collection"},{"level":4,"text":"Optimization Passes and Analysis","id":"optimization-passes-and-analysis"},{"level":3,"text":"Development Environment Enhancements","id":"development-environment-enhancements"},{"level":4,"text":"Advanced REPL Features","id":"advanced-repl-features"},{"level":4,"text":"IDE Integration and Language Server","id":"ide-integration-and-language-server"},{"level":4,"text":"Performance Profiling and Analysis Tools","id":"performance-profiling-and-analysis-tools"},{"level":3,"text":"Implementation Considerations and Architecture Evolution","id":"implementation-considerations-and-architecture-evolution"},{"level":4,"text":"Maintaining Backward Compatibility","id":"maintaining-backward-compatibility"},{"level":4,"text":"Incremental Implementation Strategy","id":"incremental-implementation-strategy"},{"level":4,"text":"Performance vs Complexity Trade-offs","id":"performance-vs-complexity-trade-offs"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended Implementation Structure","id":"recommended-implementation-structure"},{"level":4,"text":"Macro System Implementation Skeleton","id":"macro-system-implementation-skeleton"},{"level":4,"text":"Bytecode Virtual Machine Skeleton","id":"bytecode-virtual-machine-skeleton"},{"level":4,"text":"Performance Profiling Implementation","id":"performance-profiling-implementation"},{"level":4,"text":"Milestone Checkpoints for Extensions","id":"milestone-checkpoints-for-extensions"},{"level":4,"text":"Debugging Tips for Extensions","id":"debugging-tips-for-extensions"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Mental Model: The Interpreter&#39;s Dictionary","id":"mental-model-the-interpreter39s-dictionary"},{"level":3,"text":"Core Data Structures and Types","id":"core-data-structures-and-types"},{"level":3,"text":"Error Hierarchy and Exception Types","id":"error-hierarchy-and-exception-types"},{"level":3,"text":"Token Classification System","id":"token-classification-system"},{"level":3,"text":"Core Evaluation Functions","id":"core-evaluation-functions"},{"level":3,"text":"Tokenization and Scanning Operations","id":"tokenization-and-scanning-operations"},{"level":3,"text":"Parsing and Structure Building","id":"parsing-and-structure-building"},{"level":3,"text":"Environment and Scope Management","id":"environment-and-scope-management"},{"level":3,"text":"Function System Implementation","id":"function-system-implementation"},{"level":3,"text":"List Processing Primitives","id":"list-processing-primitives"},{"level":3,"text":"Arithmetic and Comparison Operations","id":"arithmetic-and-comparison-operations"},{"level":3,"text":"Special Form Handlers","id":"special-form-handlers"},{"level":3,"text":"Recursion and Tail Call Support","id":"recursion-and-tail-call-support"},{"level":3,"text":"Pipeline Coordination and Data Flow","id":"pipeline-coordination-and-data-flow"},{"level":3,"text":"Error Handling and Recovery","id":"error-handling-and-recovery"},{"level":3,"text":"Testing and Validation Framework","id":"testing-and-validation-framework"},{"level":3,"text":"Debugging and Introspection Tools","id":"debugging-and-introspection-tools"},{"level":3,"text":"AST Analysis and Visualization","id":"ast-analysis-and-visualization"},{"level":3,"text":"REPL and Interactive Debugging","id":"repl-and-interactive-debugging"},{"level":3,"text":"Constants and Predefined Values","id":"constants-and-predefined-values"},{"level":3,"text":"Session and State Management","id":"session-and-state-management"},{"level":3,"text":"Key Architectural Concepts","id":"key-architectural-concepts"},{"level":3,"text":"Common Implementation Pitfalls","id":"common-implementation-pitfalls"},{"level":3,"text":"Future Extension Terminology","id":"future-extension-terminology"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Recommended Type System Structure","id":"recommended-type-system-structure"},{"level":4,"text":"Error Hierarchy Implementation","id":"error-hierarchy-implementation"},{"level":4,"text":"Environment Implementation Framework","id":"environment-implementation-framework"},{"level":4,"text":"Function System Structure","id":"function-system-structure"},{"level":4,"text":"Debugging and Tracing Infrastructure","id":"debugging-and-tracing-infrastructure"},{"level":4,"text":"Milestone Validation Framework","id":"milestone-validation-framework"},{"level":4,"text":"Testing Assertion Framework","id":"testing-assertion-framework"}],"title":"Lisp Interpreter: Design Document","markdown":"# Lisp Interpreter: Design Document\n\n\n## Overview\n\nThis system implements a minimal Lisp interpreter that parses S-expressions into data structures, evaluates them in lexically-scoped environments, and supports functional programming constructs. The key architectural challenge is building a recursive evaluator that correctly handles special forms, function closures, and proper lexical scoping while maintaining clean separation between parsing, evaluation, and environment management.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** All milestones (1-4) - this foundational understanding applies throughout the project\n\nBuilding a programming language interpreter is one of the most intellectually rewarding challenges in computer science, combining theoretical concepts with practical engineering skills. At its core, an interpreter must solve the fundamental problem of translating human-readable text into computational actions that a computer can execute. This requires understanding not just what the code should do, but how to represent programs as data structures, how to maintain execution context, and how to implement the semantic rules that define the language's behavior.\n\nThe challenge becomes particularly interesting when we consider that programming languages exist at multiple levels of abstraction simultaneously. At the textual level, a program is simply a sequence of characters. At the syntactic level, it becomes a structured tree of expressions and statements. At the semantic level, it represents a series of computational steps with precise meaning. An interpreter must navigate these levels of abstraction while maintaining correctness, efficiency, and meaningful error reporting when things go wrong.\n\nLisp presents a uniquely elegant solution to many interpreter implementation challenges through its uniform syntax based on S-expressions (symbolic expressions). Unlike languages with complex grammatical rules, operator precedence, and varied statement forms, Lisp represents all code as nested lists of atoms. This syntactic uniformity means that the same parsing logic that handles arithmetic expressions can also handle function definitions, conditionals, and any other language construct. The result is an interpreter architecture that is both simpler to implement and easier to understand than alternatives targeting more syntactically complex languages.\n\nThe uniform syntax also reveals a profound insight about computation: the distinction between code and data becomes fluid when both are represented identically. This homoiconicity (code-as-data property) allows Lisp programs to manipulate their own structure, enabling powerful metaprogramming capabilities. For learning purposes, this means that understanding how to manipulate Lisp data structures immediately translates to understanding how to manipulate program structure itself.\n\nOur implementation will focus on a minimal but complete Lisp dialect that includes the essential features found in all functional programming languages: arithmetic operations, conditional expressions, variable binding, function definition and application, list processing, and recursion. By keeping the feature set focused, we can deeply explore the fundamental concepts without getting lost in language design complexities that don't contribute to the core learning objectives.\n\n### Mental Model: The Universal Calculator\n\nWhen approaching Lisp interpreter design, it helps to start with a familiar mental model: an enhanced calculator that can remember things. A basic calculator takes expressions like \"2 + 3 * 4\" and produces results, but it can only work with numbers and has no memory of previous calculations. Our Lisp interpreter extends this concept in several fundamental ways that transform a simple calculator into a complete programming system.\n\n**Memory and Naming**: Unlike a basic calculator, our Lisp system can remember values by associating them with names. When you evaluate `(define pi 3.14159)`, the system stores the value 3.14159 under the name `pi` for future reference. This is analogous to the memory buttons on a scientific calculator, but with unlimited named storage slots instead of just a few numbered ones. The environment system maintains these name-to-value associations across multiple expressions.\n\n**Custom Operations**: A standard calculator has built-in operations like addition and multiplication, but you cannot teach it new operations. Our Lisp interpreter allows you to define new operations using `lambda` expressions. When you write `(lambda (x) (* x x))`, you are creating a new \"square\" operation that the calculator can use just like its built-in functions. This is like being able to program new buttons on your calculator that combine existing operations in useful ways.\n\n**Deferred Computation**: Traditional calculators evaluate everything immediately, but our Lisp system can create expressions that are evaluated later. Lambda expressions are recipes for computation that can be stored, passed around, and invoked when needed. This is similar to how a scientific calculator might store a formula for later evaluation with different variable values, but with much more flexibility.\n\n**Self-Extension**: The most powerful aspect of this enhanced calculator model is that it can extend itself. Since the calculator understands its own language (S-expressions), it can create new expressions programmatically. This reflexive capability means that the boundary between the calculator's built-in functions and user-defined functions disappears entirely.\n\n**Structured Data**: While basic calculators work only with numbers, our Lisp calculator works with structured data through lists. A list like `(1 2 3 4)` is not just a collection of numbers but a structured value that can be manipulated as a unit. This allows the calculator to work with complex data structures while maintaining the same simple evaluation rules.\n\nThe key insight is that evaluation in Lisp follows consistent rules regardless of complexity. Whether evaluating `(+ 1 2)`, `(define factorial (lambda (n) (if (= n 0) 1 (* n (factorial (- n 1))))))`, or `(map factorial (list 1 2 3 4 5))`, the same fundamental process applies: look up symbols in the environment, apply functions to their arguments, and return values. This uniformity makes the interpreter architecture remarkably clean and predictable.\n\n### Interpreter Implementation Approaches\n\nWhen designing a programming language interpreter, architects must choose from several fundamental implementation strategies, each with distinct trade-offs in complexity, performance, and debugging capabilities. Understanding these approaches helps contextualize our design decisions and provides insight into how production language implementations evolve over time.\n\n> **Decision: Tree-Walking Interpreter Architecture**\n> - **Context**: Need to choose an interpreter implementation strategy that balances learning value with implementation complexity while providing good debugging capabilities for educational use.\n> - **Options Considered**: Tree-walking interpreter, bytecode virtual machine, direct compilation to native code\n> - **Decision**: Implement a tree-walking interpreter that directly evaluates parsed abstract syntax trees\n> - **Rationale**: Tree-walking interpreters provide the clearest mapping between source code and execution behavior, making debugging intuitive. The implementation directly reflects the language semantics without requiring additional abstraction layers like bytecode generation or compilation phases. For educational purposes, the performance overhead is acceptable compared to the implementation clarity gained.\n> - **Consequences**: Enables straightforward debugging where each evaluation step corresponds directly to source constructs. Sacrifices runtime performance compared to bytecode or compiled approaches, but gains implementation simplicity and maintainability for learning scenarios.\n\n| Implementation Approach | Execution Model | Performance | Implementation Complexity | Debugging Clarity |\n|------------------------|----------------|-------------|--------------------------|------------------|\n| Tree-Walking Interpreter | Direct AST evaluation | Slow (high per-operation overhead) | Low (direct semantic mapping) | Excellent (1:1 source mapping) |\n| Bytecode Virtual Machine | Compile to intermediate code, interpret bytecode | Moderate (optimized instruction set) | Moderate (requires compilation phase) | Good (source maps to bytecode) |\n| Native Compilation | Compile directly to machine code | Fast (no interpretation overhead) | High (requires code generation) | Difficult (optimized away source structure) |\n\n**Tree-Walking Interpreter Characteristics**: A tree-walking interpreter operates by recursively traversing the abstract syntax tree produced by the parser, evaluating each node according to the language's semantic rules. When the interpreter encounters a function call like `(+ 1 2)`, it identifies the operator `+`, recursively evaluates the arguments `1` and `2`, then applies the addition function to the results. This direct correspondence between syntax tree structure and evaluation steps makes the execution model highly transparent.\n\nThe tree-walking approach excels in educational contexts because every evaluation step corresponds to a visible source construct. When debugging a recursive function, you can trace exactly which source expressions are being evaluated at each step. Error messages can point directly to source locations without complex mapping between intermediate representations and original code. This clarity comes at a performance cost, as each evaluation step requires tree traversal overhead and dynamic type checking.\n\n**Bytecode Virtual Machine Characteristics**: A bytecode interpreter introduces an intermediate representation between source code and execution. The parser generates an abstract syntax tree, which a compiler transforms into a sequence of bytecode instructions optimized for efficient interpretation. A virtual machine then executes these instructions using a stack-based or register-based execution model.\n\nBytecode compilation enables optimizations like constant folding, dead code elimination, and instruction combining that are difficult to apply during direct tree evaluation. The bytecode instruction set can be designed for efficient interpretation, reducing the per-operation overhead compared to tree traversal. However, this approach requires implementing both a compiler (AST to bytecode) and a virtual machine (bytecode executor), significantly increasing implementation complexity.\n\nThe debugging experience becomes more complex as errors must be mapped from bytecode instructions back to source locations. Performance profiling requires understanding both the source-level algorithm and the generated bytecode patterns. For production languages, this complexity trade-off often makes sense, but for learning-oriented implementations, the additional abstraction layers can obscure the fundamental concepts.\n\n**Native Compilation Characteristics**: A native compiler transforms source code directly into machine code for the target architecture, eliminating interpretation overhead entirely. Modern compilers apply sophisticated optimizations like inlining, loop unrolling, and register allocation to produce highly efficient executable code. Languages like Rust, Go, and C++ use this approach to achieve maximum runtime performance.\n\nThe implementation complexity of native compilation is substantial, requiring deep understanding of target architectures, calling conventions, and optimization techniques. The debugging experience becomes challenging as compiler optimizations can reorder, eliminate, or merge source constructs in ways that make runtime behavior difficult to correlate with original code. Advanced debugging requires specialized tools that can reconstruct source-level views from optimized machine code.\n\nFor educational interpreter projects, native compilation introduces complexity that distracts from core language implementation concepts. The focus shifts from semantic design to code generation mechanics, which, while valuable, represents a different learning objective than understanding how programming languages work conceptually.\n\n**Hybrid Approaches**: Production language implementations often combine multiple strategies for different use cases. Just-in-time (JIT) compilation starts with interpretation or bytecode execution, then compiles frequently executed code paths to native code for better performance. Languages like Java, C#, and modern JavaScript engines use this approach to balance startup time with steady-state performance.\n\nSome implementations provide multiple execution modes: an interpreter for development (fast compilation, good debugging) and a compiler for production (optimized performance). This allows language designers to optimize for different phases of the software development lifecycle while maintaining a single language definition.\n\n**Implementation Decision Rationale**: Our choice of tree-walking interpretation aligns with the educational objectives of this project. The direct mapping between source constructs and evaluation steps makes it easier to understand how language features work internally. When implementing lexical scoping, for example, the environment lookup logic corresponds directly to the scoping rules described in language documentation.\n\nThe performance limitations of tree-walking interpretation are acceptable for learning scenarios where program complexity remains moderate. The ability to trace execution step-by-step through source code provides invaluable insight into how different language constructs interact. This understanding forms a solid foundation for later exploration of more sophisticated implementation techniques.\n\nFurthermore, the tree-walking approach allows us to focus implementation effort on core language semantics rather than optimization infrastructure. Topics like environment management, closure implementation, and recursion handling become more prominent when not overshadowed by bytecode generation or machine code emission concerns. These semantic concepts transfer directly to understanding any language implementation, regardless of the underlying execution strategy.\n\n**Common Pitfalls in Approach Selection**:\n\n⚠️ **Pitfall: Premature Optimization Focus** - Beginning interpreter implementers often start with bytecode or compilation concerns before understanding basic evaluation semantics. This leads to complex architectures that are difficult to debug when semantic issues arise. Start with direct evaluation to understand the language behavior, then optimize later if needed.\n\n⚠️ **Pitfall: Underestimating Debugging Complexity** - Complex execution models make it difficult to understand why programs behave unexpectedly. For learning projects, choose approaches that maintain clear relationships between source code and runtime behavior. The ability to step through evaluation logic is more valuable than runtime performance.\n\n⚠️ **Pitfall: Mixing Abstraction Levels** - Some implementations attempt to combine tree-walking with bytecode generation or partial compilation, creating hybrid systems that inherit the complexity of multiple approaches without clear benefits. Choose one approach and implement it thoroughly rather than creating architectural inconsistencies.\n\nThe interpreter implementation approach fundamentally shapes how you understand and debug language behavior. By choosing tree-walking interpretation, we prioritize learning clarity over runtime efficiency, enabling deep exploration of language semantics without the abstractions introduced by more complex execution models.\n\n---\n\n![System Component Architecture](./diagrams/system-architecture.svg)\n\n### Implementation Guidance\n\nThis section provides concrete technical recommendations for implementing the foundational architecture decisions described above, with specific focus on Python-based development that balances educational clarity with practical functionality.\n\n**A. Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Text Processing | Built-in `str` methods with manual parsing | `re` module for tokenization patterns |\n| Data Structures | Native `list` and `dict` for AST representation | Custom classes with `__repr__` for debugging |\n| Error Handling | Simple exception raising with `raise ValueError()` | Custom exception hierarchy with source location tracking |\n| Testing Framework | Built-in `assert` statements in functions | `pytest` with parameterized test cases |\n| Development Environment | Basic Python REPL for testing | `ipython` with enhanced introspection capabilities |\n\n**B. Recommended Project Structure:**\n\n```\nlisp-interpreter/\n├── src/\n│   ├── __init__.py\n│   ├── tokenizer.py          ← Convert text to token stream\n│   ├── parser.py             ← Build AST from tokens  \n│   ├── evaluator.py          ← Core evaluation engine\n│   ├── environment.py        ← Variable binding and scope\n│   ├── lisp_types.py         ← Data type definitions\n│   └── primitives.py         ← Built-in functions (+, -, car, etc.)\n├── tests/\n│   ├── __init__.py\n│   ├── test_tokenizer.py\n│   ├── test_parser.py\n│   ├── test_evaluator.py\n│   └── test_integration.py\n├── examples/\n│   ├── arithmetic.lisp       ← Basic math expressions\n│   ├── functions.lisp        ← Lambda and function calls\n│   └── recursion.lisp        ← Recursive algorithms\n├── repl.py                   ← Interactive interpreter\n└── README.md\n```\n\nThis structure separates concerns clearly while maintaining simplicity. Each module has a single responsibility, making testing and debugging straightforward. The `src/` directory contains core implementation components, while `tests/` provides comprehensive validation and `examples/` offers learning materials.\n\n**C. Core Data Type Infrastructure (Complete Implementation):**\n\n```python\n# lisp_types.py - Complete foundation for Lisp value representation\nfrom typing import Any, List, Dict, Callable, Optional, Union\nfrom enum import Enum\n\nclass LispValueType(Enum):\n    \"\"\"Enumeration of all Lisp value types for runtime type checking.\"\"\"\n    NUMBER = \"number\"\n    SYMBOL = \"symbol\" \n    LIST = \"list\"\n    FUNCTION = \"function\"\n    BUILTIN = \"builtin\"\n\nclass LispValue:\n    \"\"\"Base class for all Lisp values with common operations.\"\"\"\n    \n    def __init__(self, value: Any, value_type: LispValueType):\n        self.value = value\n        self.type = value_type\n    \n    def is_truthy(self) -> bool:\n        \"\"\"Lisp truthiness: only #f (False) and empty list are falsy.\"\"\"\n        if self.type == LispValueType.LIST:\n            return len(self.value) > 0\n        return self.value is not False\n    \n    def __str__(self) -> str:\n        \"\"\"String representation for REPL output.\"\"\"\n        if self.type == LispValueType.LIST:\n            elements = \" \".join(str(item) for item in self.value)\n            return f\"({elements})\"\n        elif self.type == LispValueType.SYMBOL:\n            return str(self.value)\n        elif self.type == LispValueType.FUNCTION:\n            return f\"<function:{id(self)}>\"\n        else:\n            return str(self.value)\n    \n    def __repr__(self) -> str:\n        \"\"\"Debugging representation showing type and value.\"\"\"\n        return f\"LispValue({self.value!r}, {self.type})\"\n\ndef make_number(value: Union[int, float]) -> LispValue:\n    \"\"\"Factory function for numeric values.\"\"\"\n    return LispValue(value, LispValueType.NUMBER)\n\ndef make_symbol(name: str) -> LispValue:\n    \"\"\"Factory function for symbol values.\"\"\" \n    return LispValue(name, LispValueType.SYMBOL)\n\ndef make_list(elements: List[LispValue]) -> LispValue:\n    \"\"\"Factory function for list values.\"\"\"\n    return LispValue(elements, LispValueType.LIST)\n\ndef is_number(value: LispValue) -> bool:\n    \"\"\"Type predicate for numeric values.\"\"\"\n    return value.type == LispValueType.NUMBER\n\ndef is_symbol(value: LispValue) -> bool:\n    \"\"\"Type predicate for symbol values.\"\"\"\n    return value.type == LispValueType.SYMBOL\n\ndef is_list(value: LispValue) -> bool:\n    \"\"\"Type predicate for list values.\"\"\"\n    return value.type == LispValueType.LIST\n```\n\n**D. Error Handling Infrastructure (Complete Implementation):**\n\n```python\n# errors.py - Comprehensive error handling for all interpreter phases\nclass LispError(Exception):\n    \"\"\"Base exception class for all Lisp interpreter errors.\"\"\"\n    \n    def __init__(self, message: str, source_location: Optional[int] = None):\n        super().__init__(message)\n        self.message = message\n        self.source_location = source_location\n    \n    def __str__(self):\n        if self.source_location is not None:\n            return f\"Error at position {self.source_location}: {self.message}\"\n        return f\"Error: {self.message}\"\n\nclass TokenizerError(LispError):\n    \"\"\"Errors during tokenization phase (unclosed strings, invalid characters).\"\"\"\n    pass\n\nclass ParseError(LispError):\n    \"\"\"Errors during parsing phase (unbalanced parentheses, invalid syntax).\"\"\" \n    pass\n\nclass EvaluationError(LispError):\n    \"\"\"Errors during evaluation phase (undefined variables, type mismatches).\"\"\"\n    pass\n\nclass NameError(EvaluationError):\n    \"\"\"Variable or function name not found in environment.\"\"\"\n    pass\n\nclass TypeError(EvaluationError):\n    \"\"\"Wrong type for operation (e.g., calling a number as function).\"\"\" \n    pass\n\nclass ArityError(EvaluationError):\n    \"\"\"Wrong number of arguments to function.\"\"\"\n    \n    def __init__(self, expected: int, actual: int, function_name: str = \"function\"):\n        message = f\"{function_name} expects {expected} arguments, got {actual}\"\n        super().__init__(message)\n        self.expected = expected\n        self.actual = actual\n        self.function_name = function_name\n```\n\n**E. Main Interpreter Loop Skeleton:**\n\n```python\n# repl.py - Read-Eval-Print Loop implementation skeleton\nfrom src.tokenizer import tokenize\nfrom src.parser import parse \nfrom src.evaluator import evaluate\nfrom src.environment import create_global_environment\nfrom src.errors import LispError\n\ndef main():\n    \"\"\"Main REPL loop with error handling and environment persistence.\"\"\"\n    print(\"Lisp Interpreter v0.1\")\n    print(\"Type expressions or 'quit' to exit\")\n    \n    # TODO 1: Create global environment with built-in functions\n    global_env = create_global_environment()\n    \n    while True:\n        try:\n            # TODO 2: Read input from user \n            user_input = input(\"lisp> \").strip()\n            \n            # TODO 3: Handle special REPL commands\n            if user_input in [\"quit\", \"exit\", \":q\"]:\n                break\n            elif user_input == \"\":\n                continue\n            \n            # TODO 4: Process input through tokenizer -> parser -> evaluator\n            tokens = tokenize(user_input)\n            ast = parse(tokens)\n            result = evaluate(ast, global_env)\n            \n            # TODO 5: Display result to user\n            print(str(result))\n            \n        except LispError as e:\n            # TODO 6: Handle interpreter errors gracefully\n            print(f\"Error: {e}\")\n        except KeyboardInterrupt:\n            # TODO 7: Handle Ctrl+C gracefully\n            print(\"\\nInterrupted\")\n            break\n        except EOFError:\n            # TODO 8: Handle Ctrl+D gracefully  \n            print(\"\\nGoodbye!\")\n            break\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**F. Language-Specific Python Hints:**\n\n- **Use `typing` module extensively**: Python's dynamic typing can make interpreter debugging difficult. Type hints for function parameters and return values catch many errors early and make the code self-documenting.\n\n- **Leverage `dataclasses` for AST nodes**: Python 3.7+ dataclasses eliminate boilerplate for value objects while providing useful `__repr__` implementations for debugging.\n\n- **Use `enum.Enum` for type tags**: Instead of string constants for type checking, enums provide type safety and better IDE support.\n\n- **Implement `__str__` vs `__repr__` carefully**: `__str__` should produce user-friendly output for the REPL, while `__repr__` should show internal structure for debugging.\n\n- **Consider `functools.singledispatch`**: For operations that behave differently based on value type, single-dispatch generic functions provide cleaner code than manual type checking.\n\n**G. Development Workflow Recommendations:**\n\n1. **Start with the REPL**: Build a minimal REPL first, even if it only echoes input. This provides immediate feedback for testing tokenizer and parser components.\n\n2. **Test each component in isolation**: Write unit tests for tokenizer, parser, and evaluator separately before integration testing. Python's `pytest` framework makes this straightforward.\n\n3. **Use doctest for examples**: Python's `doctest` module lets you embed executable examples in docstrings, ensuring documentation stays current with implementation.\n\n4. **Implement incrementally by milestone**: Don't try to build everything at once. Start with basic arithmetic, then add variables, then functions, following the milestone progression.\n\n5. **Add debug output early**: Include optional verbose modes that show tokenization results, parsed AST structure, and evaluation steps. This makes debugging much easier when things go wrong.\n\n**H. Milestone 1 Checkpoint:**\n\nAfter implementing the basic project structure and data types:\n\n```bash\n# Test that imports work correctly\npython -c \"from src.lisp_types import make_number, make_symbol, make_list; print('Types working')\"\n\n# Test error handling infrastructure  \npython -c \"from src.errors import LispError, ParseError; raise ParseError('test')\"\n\n# Test REPL shell (should start and accept 'quit')\npython repl.py\n```\n\nExpected behavior:\n- All imports succeed without errors\n- Error classes can be instantiated and raised\n- REPL starts, shows prompt, and exits cleanly on 'quit' command\n- At this stage, actual Lisp evaluation doesn't work yet - that comes in later milestones\n\nIf these checkpoints fail, verify Python path settings and that all `__init__.py` files exist in appropriate directories.\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** All milestones (1-4) - this section establishes the architectural boundaries and feature scope that guide the entire implementation\n\nBuilding an interpreter involves countless design decisions and feature possibilities. Without clear boundaries, it's easy to get lost in implementation details or attempt to solve problems that aren't core to the learning objectives. This section establishes the precise scope of our minimal Lisp implementation, focusing on the fundamental concepts that every interpreter must address while explicitly excluding advanced features that would complicate the architecture without adding proportional educational value.\n\nThe key insight here is that a minimal Lisp can still be a complete, functional programming language. By carefully choosing which features to include and exclude, we create a system that demonstrates all the essential interpreter components—tokenization, parsing, evaluation, environments, and function application—without the complexity that would obscure these fundamental concepts.\n\n### Functional Requirements\n\nOur Lisp interpreter must implement a carefully curated set of language features that collectively demonstrate the core principles of interpreter design. Each requirement directly supports one or more learning objectives and contributes to building a complete mental model of how programming languages work.\n\n**S-Expression Syntax and Data Types**\n\nThe interpreter must support Lisp's fundamental uniform syntax where all code and data are represented as S-expressions. This homoiconicity—where code and data share the same representation—is what makes Lisp an ideal learning vehicle for interpreter construction.\n\n| Data Type | Syntax Examples | Internal Representation | Purpose |\n|-----------|----------------|----------------------|---------|\n| Numbers | `42`, `3.14`, `-17` | Native numeric types | Arithmetic operations and mathematical computation |\n| Symbols | `foo`, `+`, `lambda` | String identifiers | Variable names and operator references |\n| Lists | `(1 2 3)`, `(+ x y)` | Nested array structures | Function calls and data structures |\n| Strings | `\"hello world\"` | String literals with escape sequences | Text data and output |\n| Booleans | `#t`, `#f` | Special truth values | Conditional logic and predicates |\n\nThe parser must handle arbitrarily nested list structures, properly tokenize string literals with escape sequences, and distinguish between numeric atoms and symbolic atoms. Comments initiated with semicolons must be ignored during tokenization, and whitespace must be handled correctly to separate tokens without affecting program semantics.\n\n**Arithmetic and Comparison Operations**\n\nThe evaluator must implement a complete set of mathematical operations that work with both integers and floating-point numbers. These operations serve as the foundation for computational logic and demonstrate how built-in functions are integrated into the evaluation system.\n\n| Operator Category | Operations | Behavior | Examples |\n|------------------|------------|----------|----------|\n| Arithmetic | `+`, `-`, `*`, `/` | Variable arity, numeric coercion | `(+ 1 2 3)` → `6` |\n| Comparison | `<`, `>`, `=`, `<=`, `>=` | Return boolean values | `(< 5 10)` → `#t` |\n| Logical | `and`, `or`, `not` | Short-circuit evaluation | `(and #f (/ 1 0))` → `#f` |\n\nThese operations must handle type checking (ensuring arguments are numeric where required), arity checking (verifying the correct number of arguments), and proper error reporting when invalid operations are attempted.\n\n**Variable Definition and Lexical Scoping**\n\nThe interpreter must implement a complete variable system with lexical scoping, where variable lookups are determined by the code's static structure rather than the dynamic call sequence. This demonstrates one of the most fundamental concepts in programming language design.\n\n| Feature | Syntax | Semantics | Example |\n|---------|--------|-----------|---------|\n| Global Definition | `(define x 42)` | Binds name in current environment | `(define pi 3.14159)` |\n| Local Binding | `(let ((x 1) (y 2)) ...)` | Creates new scope for body | `(let ((x 10)) (+ x 1))` |\n| Variable Reference | `x`, `foo` | Looks up value in environment chain | Variable resolution through parent scopes |\n\nThe environment system must support proper variable shadowing, where inner scopes can temporarily hide outer variable bindings without affecting them, and the bindings must be correctly restored when leaving the inner scope.\n\n**Function Definition and Application**\n\nThe interpreter must support first-class functions through lambda expressions, demonstrating how functions can be created, stored, passed as arguments, and applied with proper argument binding and lexical scope capture.\n\n| Function Aspect | Syntax | Implementation Requirement |\n|----------------|--------|---------------------------|\n| Creation | `(lambda (x y) (+ x y))` | Capture lexical environment as closure |\n| Application | `(f 1 2)` | Evaluate arguments, bind parameters, evaluate body |\n| Recursion | Function calls itself by name | Support self-reference within function body |\n| Higher-order | Functions as arguments/return values | Functions as first-class values |\n\nFunction application must create a new environment that extends the closure's captured environment, bind the actual arguments to the formal parameters, and evaluate the function body in this new environment. This demonstrates the complete lifecycle of function invocation.\n\n**Conditional Logic**\n\nThe interpreter must implement conditional expressions that allow programs to make decisions based on computed values. This requires understanding Lisp's truthiness semantics and proper handling of branch evaluation.\n\n| Conditional Form | Syntax | Evaluation Rule |\n|-----------------|--------|----------------|\n| If Expression | `(if test consequent alternative)` | Evaluate test; if truthy, evaluate consequent, else alternative |\n| Cond Expression | `(cond (test1 result1) (test2 result2) (else default))` | Evaluate tests in order; return first matching result |\n\nOnly one branch should be evaluated based on the test result, demonstrating proper control flow and lazy evaluation of alternatives.\n\n**List Processing Operations**\n\nThe interpreter must implement the fundamental list operations that make functional programming possible. These operations demonstrate how complex data structures can be built from simple primitives.\n\n| Operation | Syntax | Semantics | Type Signature |\n|-----------|--------|-----------|----------------|\n| Constructor | `(cons a b)` | Create pair with head a and tail b | `cons :: a -> b -> (a . b)` |\n| Head Access | `(car lst)` | Return first element of pair | `car :: (a . b) -> a` |\n| Tail Access | `(cdr lst)` | Return second element of pair | `cdr :: (a . b) -> b` |\n| List Builder | `(list a b c)` | Create proper list from arguments | `list :: a* -> [a]` |\n| Empty Check | `(null? lst)` | Test if list is empty | `null? :: [a] -> Bool` |\n\nThese operations must properly handle the empty list (`nil` or `()`), distinguish between proper lists (terminated by nil) and improper lists (terminated by a non-nil atom), and provide appropriate error messages when operations are applied to invalid data types.\n\n**Recursive Function Support**\n\nThe interpreter must allow functions to call themselves by name, enabling recursive algorithms that are fundamental to functional programming. This requires careful handling of function binding in environments and proper stack management.\n\nFunctions defined with `define` must be available for self-reference within their own bodies, and the interpreter should handle reasonable recursion depths without stack overflow. This demonstrates how named functions differ from anonymous lambda expressions in their binding semantics.\n\n> **Decision: Minimal but Complete Feature Set**\n> - **Context**: We could implement either a toy calculator or a full Lisp with macros, I/O, and modules\n> - **Options Considered**: \n>   1. Calculator with arithmetic only\n>   2. Minimal Lisp with functions and lists\n>   3. Full Lisp with macros and I/O\n> - **Decision**: Minimal Lisp with functions and lists\n> - **Rationale**: Option 1 doesn't demonstrate environments or closures. Option 3 adds complexity without teaching core interpreter concepts. Option 2 teaches all fundamental concepts while remaining implementable in a learning context.\n> - **Consequences**: Students learn complete interpreter pipeline while avoiding feature creep that obscures core concepts.\n\n### Explicit Non-Goals\n\nTo maintain focus on core interpreter concepts, we explicitly exclude several advanced features that, while interesting, would complicate the architecture without providing proportional learning value. Understanding what we're not building is as important as understanding what we are building.\n\n**Advanced Language Features**\n\nSeveral Lisp features require sophisticated implementation techniques that would obscure the fundamental concepts we're trying to teach.\n\n| Excluded Feature | Why Excluded | Complexity Added | Learning Impact |\n|-----------------|--------------|------------------|-----------------|\n| Macros | Require compile-time evaluation and code transformation | Meta-circular evaluation, hygiene rules | Distracts from basic evaluation model |\n| Multiple Value Return | Needs special calling conventions | Modified function application protocol | Adds complexity without teaching core concepts |\n| Exceptions/Error Handling | Requires unwinding and handler search | Control flow stack management | Better learned after mastering basic evaluation |\n| Tail Call Optimization | Complex stack frame management | Optimization and space analysis | Advanced topic for performance, not correctness |\n| Garbage Collection | Memory management implementation | Reference counting or mark-sweep algorithms | Separate concern from language semantics |\n\nMacros, in particular, would require implementing a macro expansion phase before evaluation, introducing concepts like compile-time versus runtime, hygiene, and meta-circular evaluation that would significantly complicate the mental model.\n\n**Advanced Data Types and Operations**\n\nWhile many Lisps provide rich data type libraries, our minimal implementation focuses on the types necessary to demonstrate core evaluation concepts.\n\n| Excluded Type | Alternative in Our Lisp | Reasoning |\n|---------------|------------------------|-----------|\n| Vectors/Arrays | Lists with `car`/`cdr` | Lists demonstrate recursive data structures adequately |\n| Hash Tables/Maps | Association lists `((key . value) ...)` | Simple nested lists teach same concepts |\n| Characters | Single-character strings | String handling demonstrates tokenization sufficiently |\n| Multiple Numeric Types | Generic numeric tower | Complexity doesn't teach interpretation concepts |\n| Regular Expressions | String operations if needed | Pattern matching is separate from evaluation |\n\nUsing lists for all compound data keeps the implementation simple while still allowing students to build any data structure they need through composition.\n\n**Performance Optimizations**\n\nOur interpreter prioritizes code clarity and educational value over runtime performance. Several optimization techniques are explicitly excluded to keep the implementation straightforward.\n\n| Optimization | Performance Benefit | Implementation Cost | Educational Trade-off |\n|--------------|-------------------|-------------------|---------------------|\n| Bytecode Compilation | 10-100x speedup | Compiler infrastructure, VM design | Obscures direct evaluation model |\n| Just-In-Time Compilation | 100-1000x speedup | Code generation, optimization passes | Far beyond scope of basic interpreter |\n| Constant Folding | Modest improvement | AST analysis and transformation | Adds compilation phase complexity |\n| Instruction Caching | Modest improvement | Memoization infrastructure | Doesn't teach interpretation concepts |\n\nWe implement a tree-walking interpreter that directly evaluates the AST because this approach provides the clearest mapping between source code and evaluation steps, making it easier to understand and debug.\n\n**Development Environment Features**\n\nWhile a complete Lisp system would include development tools, these features don't contribute to understanding the core interpreter implementation.\n\n| Tool Category | Examples | Why Excluded |\n|---------------|----------|--------------|\n| Interactive REPL Features | Command history, tab completion, syntax highlighting | UI concerns separate from language implementation |\n| Debugging Tools | Breakpoints, step execution, variable inspection | Debugging infrastructure orthogonal to evaluation |\n| Module System | File loading, namespace management, export/import | File I/O and dependency management complexity |\n| Standard Library | File operations, network I/O, system calls | External API integration beyond interpreter scope |\n| Documentation Tools | Docstring extraction, help system | Meta-programming unrelated to evaluation |\n\nStudents can add a basic REPL loop around their interpreter, but sophisticated REPL features would require significant additional infrastructure.\n\n**Concurrency and Parallelism**\n\nModern languages often include concurrency primitives, but these features add substantial complexity without teaching interpreter fundamentals.\n\n| Concurrency Feature | Complexity Added | Why Excluded |\n|-------------------|------------------|--------------|\n| Threading Support | Thread-safe environments, locking | Concurrency is separate from sequential evaluation |\n| Async/Await | Continuation-passing style, event loops | Advanced control flow beyond basic interpretation |\n| Channels/Message Passing | Inter-process communication | System programming unrelated to language semantics |\n| Atomic Operations | Memory model, synchronization | Hardware-level concerns beyond language design |\n\nSequential evaluation is complex enough for a learning project. Concurrent evaluation requires understanding both interpretation and concurrency, which is too much for a single project.\n\n**Error Recovery and IDE Integration**\n\nProduction language implementations include sophisticated error recovery and tooling integration, but these features focus on user experience rather than interpreter fundamentals.\n\n| Feature Category | Examples | Implementation Burden |\n|-----------------|----------|---------------------|\n| Error Recovery | Partial parsing after syntax errors | Requires error production handling in parser |\n| IDE Integration | Language server protocol, semantic highlighting | API design and tooling infrastructure |\n| Static Analysis | Type checking, unused variable detection | Separate analysis passes and type systems |\n| Code Formatting | Pretty-printing, automatic indentation | Text processing unrelated to evaluation |\n| Refactoring Support | Rename, extract function, inline | Program transformation and analysis |\n\nOur interpreter reports errors and stops, which is sufficient for understanding how errors propagate through the interpretation pipeline.\n\n> **Decision: Educational Focus Over Production Features**\n> - **Context**: We could build either a learning interpreter or a production-ready language implementation\n> - **Options Considered**:\n>   1. Minimal educational interpreter with clear code\n>   2. Production interpreter with error recovery, optimization, and tooling\n>   3. Hybrid approach with some production features\n> - **Decision**: Minimal educational interpreter\n> - **Rationale**: Production features like error recovery, optimization, and IDE integration require substantial additional code that obscures the core interpretation concepts. Students learn better from clear, simple implementations.\n> - **Consequences**: Code is easier to understand and modify, but the interpreter is not suitable for real programming tasks beyond learning exercises.\n\nThis careful scoping ensures that every feature we implement directly contributes to understanding interpreter design, while excluded features can be added later as advanced exercises once the core concepts are mastered. The result is a complete, working Lisp that demonstrates all the essential interpreter components without unnecessary complexity.\n\n### Implementation Guidance\n\n**A. Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|--------------|----------------|\n| Core Data Types | Native Python types (int, float, str, list) | Custom LispValue classes with type tagging |\n| Environment Storage | Python dict with parent references | Custom Environment class with optimized lookup |\n| Error Handling | Python exceptions with custom classes | Result types with error chaining |\n| Testing Framework | Python unittest (built-in) | pytest with fixtures and parametrization |\n| REPL Interface | Simple input/print loop | readline with history and completion |\n\nFor learning purposes, start with native Python types and gradually refactor to custom classes as you understand the requirements better.\n\n**B. Recommended File Structure**\n\nOrganize your interpreter into logical modules that separate concerns and make testing easier:\n\n```\nlisp-interpreter/\n├── src/\n│   ├── __init__.py\n│   ├── tokenizer.py          # Milestone 1: S-expression parsing\n│   ├── parser.py             # Milestone 1: AST construction\n│   ├── evaluator.py          # Milestones 2-4: Core evaluation engine\n│   ├── environment.py        # Milestone 3: Variable scoping\n│   ├── functions.py          # Milestone 3: Lambda and application\n│   ├── builtins.py           # Milestones 2-4: Built-in functions\n│   ├── errors.py             # All milestones: Error definitions\n│   └── repl.py               # Interactive loop (optional)\n├── tests/\n│   ├── __init__.py\n│   ├── test_tokenizer.py     # Unit tests for each component\n│   ├── test_parser.py\n│   ├── test_evaluator.py\n│   ├── test_environment.py\n│   ├── test_functions.py\n│   └── test_integration.py   # End-to-end tests\n├── examples/\n│   ├── arithmetic.lisp       # Test programs for each milestone\n│   ├── variables.lisp\n│   ├── functions.lisp\n│   └── recursion.lisp\n└── main.py                   # Entry point and REPL\n```\n\n**C. Infrastructure Starter Code**\n\nHere's complete infrastructure code for error handling and basic types that you can use immediately:\n\n**errors.py** (Complete implementation):\n```python\n\"\"\"\nError classes for the Lisp interpreter.\nThese provide structured error reporting throughout the interpretation pipeline.\n\"\"\"\n\nfrom typing import Optional\n\nclass LispError(Exception):\n    \"\"\"Base class for all Lisp interpreter errors.\"\"\"\n    def __init__(self, message: str, source_location: Optional[int] = None):\n        self.message = message\n        self.source_location = source_location\n        super().__init__(self.format_message())\n    \n    def format_message(self) -> str:\n        if self.source_location is not None:\n            return f\"Error at position {self.source_location}: {self.message}\"\n        return f\"Error: {self.message}\"\n\nclass TokenizerError(LispError):\n    \"\"\"Raised when tokenization fails (unclosed strings, invalid characters).\"\"\"\n    pass\n\nclass ParseError(LispError):\n    \"\"\"Raised when parsing fails (unbalanced parentheses, unexpected EOF).\"\"\"\n    pass\n\nclass EvaluationError(LispError):\n    \"\"\"Raised when evaluation fails (general evaluation problems).\"\"\"\n    pass\n\nclass NameError(EvaluationError):\n    \"\"\"Raised when a variable or function name cannot be found.\"\"\"\n    pass\n\nclass TypeError(EvaluationError):\n    \"\"\"Raised when an operation is applied to wrong types.\"\"\"\n    pass\n\nclass ArityError(EvaluationError):\n    \"\"\"Raised when a function is called with wrong number of arguments.\"\"\"\n    def __init__(self, expected: int, actual: int, function_name: str, source_location: Optional[int] = None):\n        self.expected = expected\n        self.actual = actual\n        self.function_name = function_name\n        message = f\"Function '{function_name}' expects {expected} arguments, got {actual}\"\n        super().__init__(message, source_location)\n```\n\n**types.py** (Complete implementation):\n```python\n\"\"\"\nCore data types for Lisp values.\nProvides type-safe representation of all Lisp data.\n\"\"\"\n\nfrom enum import Enum\nfrom typing import Any, List, Callable, Optional, Dict\n\nclass LispValueType(Enum):\n    NUMBER = \"number\"\n    SYMBOL = \"symbol\"\n    LIST = \"list\"\n    FUNCTION = \"function\"\n    BUILTIN = \"builtin\"\n\nclass LispValue:\n    \"\"\"Represents any value in the Lisp system.\"\"\"\n    def __init__(self, value: Any, type: LispValueType):\n        self.value = value\n        self.type = type\n    \n    def __repr__(self) -> str:\n        return f\"LispValue({self.value}, {self.type})\"\n    \n    def __eq__(self, other) -> bool:\n        if not isinstance(other, LispValue):\n            return False\n        return self.value == other.value and self.type == other.type\n\n# Constants for special values\nLISP_TRUE = LispValue(True, LispValueType.SYMBOL)\nLISP_FALSE = LispValue(False, LispValueType.SYMBOL)\nEMPTY_LIST = LispValue([], LispValueType.LIST)\n\n# Constructor functions\ndef make_number(value: float) -> LispValue:\n    \"\"\"Creates a numeric LispValue.\"\"\"\n    return LispValue(value, LispValueType.NUMBER)\n\ndef make_symbol(name: str) -> LispValue:\n    \"\"\"Creates a symbol LispValue.\"\"\"\n    return LispValue(name, LispValueType.SYMBOL)\n\ndef make_list(elements: List[LispValue]) -> LispValue:\n    \"\"\"Creates a list LispValue.\"\"\"\n    return LispValue(elements, LispValueType.LIST)\n\n# Type predicate functions\ndef is_number(value: LispValue) -> bool:\n    \"\"\"Checks if value is a number.\"\"\"\n    return value.type == LispValueType.NUMBER\n\ndef is_symbol(value: LispValue) -> bool:\n    \"\"\"Checks if value is a symbol.\"\"\"\n    return value.type == LispValueType.SYMBOL\n\ndef is_list(value: LispValue) -> bool:\n    \"\"\"Checks if value is a list.\"\"\"\n    return value.type == LispValueType.LIST\n\ndef is_truthy(value: LispValue) -> bool:\n    \"\"\"Determines if a value is truthy in Lisp semantics.\"\"\"\n    # In our Lisp, only #f (false) is falsy, everything else is truthy\n    return value != LISP_FALSE\n```\n\n**D. Core Logic Skeleton Code**\n\nHere are the main function signatures you'll implement, with detailed TODO steps:\n\n**tokenizer.py** (Skeleton for you to implement):\n```python\nfrom typing import List\nfrom .errors import TokenizerError\n\ndef tokenize(text: str) -> List[str]:\n    \"\"\"\n    Converts Lisp source text into a list of tokens.\n    Handles parentheses, atoms, string literals, and comments.\n    \"\"\"\n    tokens = []\n    i = 0\n    \n    # TODO 1: Loop through each character in text\n    # TODO 2: Skip whitespace characters (space, tab, newline)\n    # TODO 3: Handle semicolon comments - skip to end of line\n    # TODO 4: Handle opening and closing parentheses as separate tokens\n    # TODO 5: Handle string literals - collect characters until closing quote\n    # TODO 6: Handle atoms (numbers and symbols) - collect until delimiter\n    # TODO 7: Raise TokenizerError for invalid characters or unclosed strings\n    # Hint: Use str.isspace() to check for whitespace\n    # Hint: Track line numbers for better error reporting\n    \n    return tokens\n```\n\n**parser.py** (Skeleton for you to implement):\n```python\nfrom typing import List, Union\nfrom .types import LispValue, make_number, make_symbol, make_list\nfrom .errors import ParseError\n\ndef parse(tokens: List[str]) -> LispValue:\n    \"\"\"\n    Parses a list of tokens into a LispValue AST.\n    Handles nested lists and quote syntax transformation.\n    \"\"\"\n    if not tokens:\n        raise ParseError(\"Unexpected end of input\")\n    \n    # TODO 1: Create a token iterator to track current position\n    # TODO 2: Call read_expression to parse the first complete expression\n    # TODO 3: Verify that all tokens were consumed (no extra closing parens)\n    # TODO 4: Return the parsed expression\n    \n    def read_expression(token_iter):\n        # TODO 5: Get the next token from the iterator\n        # TODO 6: Handle opening paren - call read_list\n        # TODO 7: Handle quote character - transform into (quote expr)\n        # TODO 8: Handle atoms - determine if number or symbol\n        # TODO 9: Raise ParseError for unexpected tokens\n        # Hint: Use float(token) in try/except to detect numbers\n        # Hint: Quote 'x should become (quote x)\n        pass\n    \n    def read_list(token_iter):\n        # TODO 10: Read expressions until closing paren\n        # TODO 11: Handle nested lists recursively\n        # TODO 12: Raise ParseError for unbalanced parentheses\n        # TODO 13: Return make_list() of collected expressions\n        pass\n```\n\n**E. Language-Specific Hints**\n\n- **Type Checking**: Use `isinstance(value, LispValue)` and check the `.type` field rather than checking Python types directly\n- **Environment Chaining**: Use a simple dict with a `parent` field pointing to the enclosing scope\n- **Function Application**: Create new environment with `{**closure_env, **param_bindings}` to extend the closure environment\n- **Error Context**: Pass token positions through parsing to provide better error locations\n- **Recursion Handling**: Python's default recursion limit (1000) should be sufficient for learning exercises\n- **Testing**: Use `unittest.TestCase` and create helper methods like `self.eval_expr(\"(+ 1 2)\")` for easy test writing\n\n**F. Milestone Checkpoints**\n\nAfter implementing each milestone, verify these behaviors:\n\n**Milestone 1 - S-Expression Parser:**\n```bash\npython -m pytest tests/test_tokenizer.py tests/test_parser.py -v\n```\nExpected behavior:\n- `tokenize(\"(+ 1 2)\")` returns `[\"(\", \"+\", \"1\", \"2\", \")\"]`\n- `parse([\"(\", \"+\", \"1\", \"2\", \")\"])` returns nested LispValue structures\n- `parse([\"'\", \"x\"])` becomes `(quote x)` form\n- Comments and extra whitespace are ignored\n\n**Milestone 2 - Basic Evaluation:**\n```bash\npython -m pytest tests/test_evaluator.py::test_arithmetic -v\n```\nTest these expressions in a REPL:\n- `42` → `42`\n- `(+ 1 2 3)` → `6`\n- `(< 5 10)` → `#t`\n- `(if #t 1 2)` → `1`\n\n**Milestone 3 - Variables and Functions:**\nTest these programs:\n```lisp\n(define x 42)\nx  ; Should return 42\n\n(define square (lambda (n) (* n n)))\n(square 5)  ; Should return 25\n\n(let ((x 1) (y 2)) (+ x y))  ; Should return 3\n```\n\n**Milestone 4 - List Operations & Recursion:**\nTest recursive factorial:\n```lisp\n(define factorial \n  (lambda (n) \n    (if (= n 0) \n        1 \n        (* n (factorial (- n 1))))))\n(factorial 5)  ; Should return 120\n```\n\n**G. Debugging Tips**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|----------------|-----|\n| \"Symbol not found\" errors | Environment lookup failing | Print environment contents during lookup | Check environment chaining and variable binding |\n| Infinite recursion in evaluation | Evaluating arguments of special forms | Add debug prints to evaluator dispatch | Don't evaluate arguments of `if`, `define`, `lambda` |\n| Parser crashes on nested lists | Recursion not handling token consumption | Trace token iterator position | Ensure each `read_expression` consumes exactly one complete expression |\n| Functions can't see their parameters | New environment not extending closure | Print environment chain during application | New environment should have closure environment as parent |\n| Quote not working | Quote syntax not transformed | Check parser output for quoted expressions | Transform `'x` to `(quote x)` during parsing |\n\n\n## High-Level Architecture\n\n> **Milestone(s):** All milestones (1-4) - the three-stage pipeline and module organization provides the foundational structure for the entire interpreter implementation\n\nBuilding a Lisp interpreter requires transforming human-readable text into executable computations through a carefully orchestrated pipeline. The architecture we present here follows the classical interpreter design pattern of **separation of concerns**, where each stage has a single, well-defined responsibility. This design enables independent development, testing, and debugging of each component while maintaining clear data flow boundaries.\n\nThe fundamental challenge in interpreter architecture is balancing simplicity with extensibility. We need a design that is approachable for learning purposes yet robust enough to support the full spectrum of Lisp language features. Our solution employs a **three-stage pipeline** architecture that mirrors how human programmers mentally process code: first we identify the basic building blocks (tokenization), then we understand the structure (parsing), and finally we compute the meaning (evaluation).\n\n### Three-Stage Pipeline: How Text Flows Through Tokenizer, Parser, and Evaluator Stages\n\nThink of our interpreter pipeline as a **factory assembly line for ideas**. Raw text enters one end as an unstructured stream of characters, and executable results emerge from the other end. Each stage in the pipeline performs a specific transformation, converting the input into a more structured, more meaningful representation. Like a real assembly line, each station depends on receiving properly formatted input from the previous station and produces standardized output for the next station.\n\n![System Component Architecture](./diagrams/system-architecture.svg)\n\nThe three stages represent progressively higher levels of abstraction and semantic understanding. The tokenizer operates at the **lexical level**, identifying individual symbols, numbers, and punctuation without understanding their relationships. The parser operates at the **syntactic level**, recognizing how tokens combine into meaningful structures like lists and nested expressions. The evaluator operates at the **semantic level**, computing the actual meaning and results of these structures within the context of variable bindings and function definitions.\n\n**Stage 1: Tokenization - From Characters to Symbols**\n\nThe tokenizer serves as the **lexical scanner** that converts raw character streams into a sequence of meaningful tokens. This stage handles the low-level details of character encoding, whitespace handling, and comment removal, producing a clean stream of atomic elements that the parser can work with. The tokenizer is responsible for recognizing the boundaries between different syntactic elements and classifying each element into its appropriate token type.\n\nThe tokenizer's primary responsibility is **character classification and boundary detection**. It must distinguish between symbol characters, numeric digits, string delimiters, parentheses, and whitespace. It also handles special cases like negative numbers (where the minus sign is part of the number token rather than a separate operator), string escapes, and comment syntax. The output is a linear sequence of tokens, each tagged with its type and source location for error reporting.\n\n| Token Type | Recognition Pattern | Examples | Error Conditions |\n|------------|-------------------|----------|-----------------|\n| `NUMBER` | Digits with optional decimal point and negative sign | `42`, `-3.14`, `0` | Invalid number format, overflow |\n| `SYMBOL` | Alphanumeric characters and allowed punctuation | `+`, `define`, `car` | Reserved keywords (handled by parser) |\n| `STRING` | Characters enclosed in double quotes | `\"hello\"`, `\"world\\n\"` | Unterminated string, invalid escapes |\n| `LEFT_PAREN` | Opening parenthesis character | `(` | Never an error at tokenizer level |\n| `RIGHT_PAREN` | Closing parenthesis character | `)` | Never an error at tokenizer level |\n| `QUOTE` | Single quote character | `'` | Never an error at tokenizer level |\n\n**Stage 2: Parsing - From Tokens to Structure**\n\nThe parser transforms the flat sequence of tokens into a **hierarchical Abstract Syntax Tree (AST)** that represents the nested structure of S-expressions. This stage implements the core principle of Lisp's **homoiconicity** - the property that code and data share the same representation. The parser's output is a tree of `LispValue` objects that can represent both the program structure and the data the program manipulates.\n\nThe parser employs a **recursive descent strategy** that mirrors the recursive nature of S-expressions. When it encounters an opening parenthesis, it recursively parses the contents until it finds the matching closing parenthesis, building nested list structures of arbitrary depth. The parser also handles **quote syntax transformation**, converting the `'expr` shorthand into the equivalent `(quote expr)` list form that the evaluator can process uniformly.\n\n| Parse Element | Input Tokens | Output AST | Recursive Behavior |\n|---------------|--------------|------------|-------------------|\n| Atom | `NUMBER` or `SYMBOL` or `STRING` | `LispValue` with appropriate type | Base case - no recursion |\n| List | `LEFT_PAREN` ... `RIGHT_PAREN` | `LispValue` with `LIST` type | Recursive calls for each element |\n| Quoted Expression | `QUOTE` followed by expression | `(quote <expression>)` list | Single recursive call for quoted expression |\n| Empty List | `LEFT_PAREN` `RIGHT_PAREN` | `EMPTY_LIST` constant | Base case - no recursion |\n\nThe parser maintains a **token cursor** that advances through the token stream as it consumes input. Error handling at this stage primarily involves detecting **unbalanced parentheses** and **unexpected end-of-file** conditions. When an error occurs, the parser includes source location information from the original tokens to help users locate problems in their source code.\n\n**Stage 3: Evaluation - From Structure to Results**\n\nThe evaluator is the **semantic engine** that computes the actual meaning of parsed expressions within the context of variable bindings and function definitions. This stage implements the core evaluation rules that define Lisp's behavior: self-evaluating literals, variable lookup, special form handling, and function application. The evaluator operates on the AST produced by the parser and produces final results that can be displayed to the user or used as input to further computations.\n\nThe evaluator's architecture centers around a **dispatch mechanism** that examines each AST node and applies the appropriate evaluation rule based on the node's type and structure. This design enables clean separation between different language constructs while maintaining a unified evaluation interface. The evaluator also manages the **environment system** that tracks variable bindings and implements lexical scoping rules.\n\n| Expression Type | Evaluation Rule | Environment Interaction | Result Type |\n|-----------------|-----------------|-------------------------|-------------|\n| Number Literal | Return the number unchanged | None - self-evaluating | `LispValue` with `NUMBER` type |\n| Symbol | Look up symbol in current environment | Variable lookup with scope chain traversal | `LispValue` of whatever type was bound |\n| Empty List | Evaluate to empty list | None - self-evaluating | `EMPTY_LIST` constant |\n| Non-empty List | Dispatch based on first element | Environment passed to special forms and functions | Depends on operation performed |\n\nThe evaluator distinguishes between **special forms** and **function calls** - a critical architectural decision that enables Lisp's powerful macro system and control structures. Special forms like `if`, `define`, and `lambda` receive their arguments unevaluated and control the evaluation process themselves. Function calls evaluate all their arguments before applying the function to the resulting values.\n\n> **Decision: Tree-Walking Evaluation Strategy**\n> - **Context**: We need to choose how to execute the parsed AST - direct interpretation, bytecode compilation, or tree-walking evaluation\n> - **Options Considered**: Bytecode virtual machine, direct AST interpretation, compilation to target language\n> - **Decision**: Direct tree-walking evaluation of AST nodes\n> - **Rationale**: Tree-walking provides the simplest implementation path with direct correspondence between source code and evaluation logic, making it ideal for learning interpreter concepts. Performance is adequate for educational purposes.\n> - **Consequences**: Slower execution than bytecode VMs but dramatically simpler implementation. Each evaluation step directly corresponds to AST traversal, making debugging intuitive.\n\n**Pipeline Data Flow and Error Propagation**\n\nThe pipeline processes input through a **sequential transformation chain** where each stage consumes the output of the previous stage. Error conditions at any stage halt the pipeline and propagate error information back to the user with appropriate context and source location details. This design ensures that errors are detected as early as possible and reported with maximum helpful information.\n\n| Stage | Input | Output | Error Types | Error Propagation |\n|-------|-------|--------|-------------|-------------------|\n| Tokenizer | Raw text string | Token sequence | `TokenizerError` for invalid characters/strings | Immediate halt with character position |\n| Parser | Token sequence | AST root node | `ParseError` for syntax errors | Immediate halt with token position |\n| Evaluator | AST root node | `LispValue` result | `EvaluationError`, `NameError`, `TypeError`, `ArityError` | Immediate halt with expression context |\n\nThe pipeline maintains **source location tracking** throughout all stages to enable precise error reporting. Tokens carry position information from the original source text, AST nodes inherit position data from their constituent tokens, and evaluation errors include the expression being evaluated when the error occurred.\n\n### Recommended Module Organization: How to Structure the Codebase for Maintainability and Testability\n\nThe module organization follows **separation of concerns** principles, with each major component isolated in its own module with clearly defined interfaces and minimal dependencies. This structure enables independent development and testing of each component while maintaining clean boundaries that prevent architectural violations. The organization also supports **incremental development** aligned with the project milestones.\n\n> **Decision: Component-Based Module Structure**\n> - **Context**: We need to organize code to support independent development, testing, and maintenance of interpreter components\n> - **Options Considered**: Single monolithic module, component-based separation, layer-based organization\n> - **Decision**: Component-based modules with separate packages for tokenizer, parser, evaluator, and supporting types\n> - **Rationale**: Component separation enables independent testing, reduces compilation dependencies, and maps directly to the three-stage pipeline architecture. Each component can be developed and debugged in isolation.\n> - **Consequences**: More files and import statements but dramatically better maintainability, testability, and team development support.\n\n**Core Component Modules**\n\nThe interpreter consists of four primary modules that correspond to the major architectural components. Each module encapsulates its implementation details while exposing a clean public interface for interaction with other components. The module boundaries align with the natural data flow of the pipeline, making the dependencies explicit and unidirectional.\n\n| Module | Primary Responsibility | Key Exports | Dependencies |\n|--------|----------------------|-------------|--------------|\n| `types` | Core data structures and shared constants | `LispValue`, `LispValueType`, error types | None - foundation module |\n| `tokenizer` | Convert text to token streams | `tokenize()` function, token types | `types` for error handling |\n| `parser` | Convert tokens to AST | `parse()` function, quote handling | `types`, `tokenizer` |\n| `evaluator` | Execute AST in environments | `evaluate()` function, built-in functions | `types`, `parser` |\n\n**Supporting Infrastructure Modules**\n\nBeyond the core pipeline components, the interpreter requires several supporting modules that provide infrastructure services. These modules handle cross-cutting concerns like environment management, built-in function definitions, and error handling utilities. The supporting modules are designed to be **implementation details** that can be refactored without affecting the core pipeline interface.\n\n| Module | Primary Responsibility | Key Exports | Used By |\n|--------|----------------------|-------------|---------|\n| `environment` | Variable binding and lexical scope | `Environment` class, lookup/binding methods | `evaluator` |\n| `builtins` | Built-in function implementations | Arithmetic, comparison, list operation functions | `evaluator` |\n| `errors` | Error handling utilities | Error formatting, source location tracking | All modules |\n| `repl` | Interactive read-eval-print loop | Command-line interface, session management | Main application |\n\n**Dependency Flow and Interface Design**\n\nThe module dependency graph forms a **directed acyclic graph (DAG)** that prevents circular dependencies and enables clean compilation order. Dependencies flow in the direction of data processing: from foundation types through tokenization and parsing to evaluation. No component depends on modules that come later in the pipeline, ensuring that each stage can be developed and tested independently.\n\n```\ntypes (foundation)\n  ↑\ntokenizer → parser → evaluator\n  ↑           ↑        ↑\nerrors    errors   errors, environment, builtins\n                      ↑\n                    repl (application)\n```\n\nEach module exposes a **minimal public interface** that hides implementation details while providing all necessary functionality for dependent modules. This design enables internal refactoring without breaking dependent code and makes the system easier to understand by reducing the cognitive load of understanding inter-module interactions.\n\n**Testing and Development Workflow**\n\nThe module organization directly supports **test-driven development** and **incremental implementation** aligned with project milestones. Each module can be unit tested in isolation, and integration tests verify the interaction between components. The dependency structure ensures that lower-level components can be completed and tested before higher-level components that depend on them.\n\n| Development Phase | Modules to Implement | Testing Focus | Integration Points |\n|-------------------|---------------------|---------------|-------------------|\n| Milestone 1 | `types`, `tokenizer`, `parser` | Token recognition, AST construction | Token stream format, AST structure |\n| Milestone 2 | `evaluator`, `environment`, `builtins` (arithmetic) | Basic evaluation rules, environment lookup | AST evaluation interface |\n| Milestone 3 | Extend `evaluator` and `builtins` (variables, functions) | Variable binding, function application | Closure creation, scope management |\n| Milestone 4 | Extend `builtins` (list operations), optimize `evaluator` | List primitives, recursion support | Tail call optimization |\n\n**Common Module Organization Pitfalls**\n\n⚠️ **Pitfall: Circular Dependencies Between Core Components**\nMany learners create circular dependencies by having the parser import evaluation utilities or the evaluator import parsing helpers. This violates the pipeline architecture and prevents independent testing. The fix is to move shared utilities into the `types` module or create separate utility modules that both components can import.\n\n⚠️ **Pitfall: Monolithic Evaluator Module**\nPutting all evaluation logic, environment management, and built-in functions in a single large module makes testing difficult and violates separation of concerns. The evaluator should focus on evaluation dispatch and delegate environment operations to the `environment` module and built-in function implementations to the `builtins` module.\n\n⚠️ **Pitfall: Inconsistent Error Handling Across Modules**\nEach module implementing its own error handling style creates inconsistent user experience and makes error testing difficult. All modules should use the shared error types from the `errors` module and follow consistent patterns for error creation and propagation.\n\n⚠️ **Pitfall: Tight Coupling Through Global State**\nUsing global variables for configuration or state creates hidden dependencies between modules and makes testing difficult. All state should be explicitly passed through function parameters or encapsulated in objects with clear ownership and lifecycle management.\n\n### Implementation Guidance\n\nThe implementation strategy emphasizes **incremental development** with working code at each milestone. Start with the foundational types and build each component incrementally, testing thoroughly before moving to the next component. This approach ensures that each piece works correctly before adding complexity.\n\n**Technology Recommendations**\n\n| Component | Simple Approach | Advanced Approach | Recommended for Learning |\n|-----------|-----------------|-------------------|-------------------------|\n| Module System | Single file per component | Package hierarchy with submodules | Single file per component |\n| Error Handling | Exception-based with custom types | Result types with error chaining | Exception-based (simpler for beginners) |\n| Testing Framework | Built-in unittest module | Property-based testing with hypothesis | Built-in unittest (sufficient coverage) |\n| Documentation | Inline docstrings | Sphinx with API docs | Inline docstrings (faster iteration) |\n\n**Recommended Project Structure**\n\nOrganize your code to support clean separation of concerns and easy navigation. Each module should live in its own file with clear naming that reflects its responsibility in the interpreter pipeline.\n\n```\nlisp-interpreter/\n├── main.py                    # Entry point and REPL implementation\n├── lisp/                      # Core interpreter package\n│   ├── __init__.py           # Package initialization and public API\n│   ├── types.py              # LispValue, LispValueType, error classes\n│   ├── tokenizer.py          # tokenize() and token handling\n│   ├── parser.py             # parse() and AST construction\n│   ├── evaluator.py          # evaluate() and evaluation dispatch\n│   ├── environment.py        # Environment class and scope management\n│   ├── builtins.py           # Built-in function implementations\n│   └── errors.py             # Error formatting and utility functions\n├── tests/                     # Test suite organized by component\n│   ├── test_tokenizer.py     # Unit tests for tokenization\n│   ├── test_parser.py        # Unit tests for parsing\n│   ├── test_evaluator.py     # Unit tests for evaluation\n│   ├── test_integration.py   # End-to-end integration tests\n│   └── fixtures/             # Test data files with example Lisp programs\n└── examples/                  # Example Lisp programs for manual testing\n    ├── arithmetic.lisp        # Basic math operations\n    ├── functions.lisp         # Lambda and function definition examples\n    └── recursion.lisp         # Recursive function examples\n```\n\n**Foundation Types Infrastructure (Complete)**\n\nThis provides the complete type system that all other components will use. Copy this into `types.py` and import it in other modules:\n\n```python\n\"\"\"\nCore data types and error classes for the Lisp interpreter.\nProvides the foundation that all other components depend on.\n\"\"\"\n\nfrom enum import Enum\nfrom typing import Any, List, Optional, Union\n\n\nclass LispValueType(Enum):\n    \"\"\"Enumeration of all possible Lisp value types.\"\"\"\n    NUMBER = \"NUMBER\"\n    SYMBOL = \"SYMBOL\" \n    LIST = \"LIST\"\n    FUNCTION = \"FUNCTION\"\n    BUILTIN = \"BUILTIN\"\n\n\nclass LispValue:\n    \"\"\"\n    Universal container for all values in the Lisp interpreter.\n    Combines the value data with type information for runtime type checking.\n    \"\"\"\n    \n    def __init__(self, value: Any, value_type: LispValueType):\n        self.value = value\n        self.type = value_type\n    \n    def __eq__(self, other):\n        if not isinstance(other, LispValue):\n            return False\n        return self.value == other.value and self.type == other.type\n    \n    def __repr__(self):\n        return f\"LispValue({self.value}, {self.type})\"\n\n\n# Constants for special values\nLISP_TRUE = LispValue(True, LispValueType.SYMBOL)\nLISP_FALSE = LispValue(False, LispValueType.SYMBOL)  \nEMPTY_LIST = LispValue([], LispValueType.LIST)\n\n\nclass LispError(Exception):\n    \"\"\"Base class for all interpreter errors with source location tracking.\"\"\"\n    \n    def __init__(self, message: str, source_location: Optional[int] = None):\n        self.message = message\n        self.source_location = source_location\n        super().__init__(message)\n\n\nclass TokenizerError(LispError):\n    \"\"\"Errors that occur during tokenization phase.\"\"\"\n    pass\n\n\nclass ParseError(LispError):\n    \"\"\"Errors that occur during parsing phase.\"\"\"\n    pass\n\n\nclass EvaluationError(LispError):\n    \"\"\"Base class for errors that occur during evaluation phase.\"\"\"\n    pass\n\n\nclass NameError(EvaluationError):\n    \"\"\"Error for undefined variable references.\"\"\"\n    pass\n\n\nclass TypeError(EvaluationError):\n    \"\"\"Error for type mismatches in operations.\"\"\"\n    pass\n\n\nclass ArityError(EvaluationError):\n    \"\"\"Error for incorrect number of arguments to functions.\"\"\"\n    \n    def __init__(self, expected: int, actual: int, function_name: str, source_location: Optional[int] = None):\n        self.expected = expected\n        self.actual = actual\n        self.function_name = function_name\n        message = f\"{function_name} expects {expected} arguments, got {actual}\"\n        super().__init__(message, source_location)\n\n\n# Type constructor functions\ndef make_number(value: Union[int, float]) -> LispValue:\n    \"\"\"Create a numeric LispValue from int or float.\"\"\"\n    return LispValue(value, LispValueType.NUMBER)\n\n\ndef make_symbol(name: str) -> LispValue:\n    \"\"\"Create a symbol LispValue from string name.\"\"\"\n    return LispValue(name, LispValueType.SYMBOL)\n\n\ndef make_list(elements: List[LispValue]) -> LispValue:\n    \"\"\"Create a list LispValue from list of elements.\"\"\"\n    return LispValue(elements, LispValueType.LIST)\n\n\n# Type predicate functions\ndef is_number(value: LispValue) -> bool:\n    \"\"\"Check if value is a number.\"\"\"\n    return value.type == LispValueType.NUMBER\n\n\ndef is_symbol(value: LispValue) -> bool:\n    \"\"\"Check if value is a symbol.\"\"\"\n    return value.type == LispValueType.SYMBOL\n\n\ndef is_list(value: LispValue) -> bool:\n    \"\"\"Check if value is a list.\"\"\"\n    return value.type == LispValueType.LIST\n\n\ndef is_truthy(value: LispValue) -> bool:\n    \"\"\"\n    Determine truthiness in Lisp: only LISP_FALSE is falsy.\n    Everything else, including empty lists and zero, is truthy.\n    \"\"\"\n    return value != LISP_FALSE\n```\n\n**Core Component Skeleton Code**\n\nHere are the skeleton implementations for each major component. Each contains detailed TODO comments that map to the concepts explained in this section:\n\n```python\n# tokenizer.py - Convert text to tokens\n\"\"\"\nTokenizer for Lisp S-expressions.\nHandles numbers, symbols, strings, parentheses, quotes, and comments.\n\"\"\"\n\nfrom typing import List, NamedTuple\nfrom .types import TokenizerError\n\n\nclass Token(NamedTuple):\n    \"\"\"Individual token with type and source location.\"\"\"\n    type: str\n    value: str\n    position: int\n\n\ndef tokenize(text: str) -> List[Token]:\n    \"\"\"\n    Convert input text into a sequence of tokens.\n    \n    Returns list of Token objects representing numbers, symbols, \n    parentheses, quotes, and string literals.\n    \"\"\"\n    # TODO 1: Initialize empty token list and position counter\n    # TODO 2: Iterate through each character in input text\n    # TODO 3: Skip whitespace characters (space, tab, newline)\n    # TODO 4: Handle semicolon comments - skip to end of line\n    # TODO 5: Recognize parentheses as single-character tokens  \n    # TODO 6: Handle quote character as QUOTE token\n    # TODO 7: Parse string literals enclosed in double quotes\n    # TODO 8: Parse numbers (integers and floats, including negative)\n    # TODO 9: Parse symbols (everything else that's not whitespace/special)\n    # TODO 10: Return completed token list\n    # Hint: Use text.isdigit(), text.isalpha() for character classification\n    # Hint: Handle string escapes like \\n, \\\", \\\\\n    pass\n```\n\n```python\n# parser.py - Convert tokens to AST\n\"\"\"\nRecursive descent parser for Lisp S-expressions.\nBuilds nested LispValue structures from token streams.\n\"\"\"\n\nfrom typing import List\nfrom .types import LispValue, ParseError, make_symbol, make_number, make_list\nfrom .tokenizer import Token\n\n\ndef parse(tokens: List[Token]) -> LispValue:\n    \"\"\"\n    Parse a complete S-expression from token list.\n    Returns the root LispValue of the abstract syntax tree.\n    \"\"\"\n    # TODO 1: Initialize token position counter\n    # TODO 2: Call read_expr to parse the first expression\n    # TODO 3: Check that all tokens were consumed (no extra tokens)\n    # TODO 4: Return the parsed expression\n    # Hint: Use a mutable position counter that read_expr can update\n    pass\n\n\ndef read_expr(tokens: List[Token], pos: List[int]) -> LispValue:\n    \"\"\"\n    Read a single expression from token stream.\n    Updates pos[0] to point to next unprocessed token.\n    \"\"\"\n    # TODO 1: Check for end of token stream - raise ParseError if empty\n    # TODO 2: Handle QUOTE token - transform 'expr to (quote expr)\n    # TODO 3: Handle LEFT_PAREN token - call read_list for nested structure\n    # TODO 4: Handle NUMBER token - convert to LispValue number\n    # TODO 5: Handle SYMBOL token - convert to LispValue symbol  \n    # TODO 6: Handle STRING token - convert to LispValue string\n    # TODO 7: Advance position counter before returning result\n    # Hint: Quote transformation creates a list with 'quote' symbol and expression\n    pass\n\n\ndef read_list(tokens: List[Token], pos: List[int]) -> LispValue:\n    \"\"\"\n    Read a parenthesized list from token stream.\n    Assumes LEFT_PAREN already consumed, reads until RIGHT_PAREN.\n    \"\"\"\n    # TODO 1: Initialize empty list to collect elements\n    # TODO 2: Loop until RIGHT_PAREN or end of tokens\n    # TODO 3: For each element, call read_expr recursively\n    # TODO 4: Add each parsed element to the list\n    # TODO 5: Consume the closing RIGHT_PAREN token\n    # TODO 6: Return LispValue list containing all elements\n    # Hint: Handle empty lists () correctly\n    # Hint: Detect unbalanced parentheses and raise ParseError\n    pass\n```\n\n```python\n# evaluator.py - Execute AST in environments  \n\"\"\"\nCore evaluation engine for Lisp expressions.\nImplements evaluation rules for atoms, lists, special forms, and function calls.\n\"\"\"\n\nfrom .types import LispValue, EvaluationError, NameError, TypeError\nfrom .environment import Environment\n\n\ndef evaluate(ast: LispValue, env: Environment) -> LispValue:\n    \"\"\"\n    Evaluate a Lisp expression in the given environment.\n    Implements the core evaluation rules based on expression type.\n    \"\"\"\n    # TODO 1: Handle self-evaluating atoms (numbers)\n    # TODO 2: Handle symbol lookup in environment\n    # TODO 3: Handle empty list (evaluates to itself)  \n    # TODO 4: Handle non-empty lists - check first element\n    # TODO 5: Dispatch to special form handlers (if, define, lambda)\n    # TODO 6: Handle function application for regular function calls\n    # TODO 7: Evaluate arguments and apply function to results\n    # Hint: Use is_number(), is_symbol(), is_list() type predicates\n    # Hint: Special forms get unevaluated arguments, functions get evaluated arguments\n    pass\n\n\ndef is_special_form(symbol_name: str) -> bool:\n    \"\"\"Check if a symbol names a special form.\"\"\"\n    # TODO: Return True for 'if', 'define', 'lambda', 'quote'\n    pass\n\n\ndef apply_function(func: LispValue, args: List[LispValue], env: Environment) -> LispValue:\n    \"\"\"\n    Apply a function to its arguments.\n    Handles both built-in functions and user-defined lambda functions.\n    \"\"\"\n    # TODO 1: Check function type (BUILTIN vs FUNCTION)\n    # TODO 2: For built-ins, call the Python function directly\n    # TODO 3: For lambdas, create new environment with parameter bindings\n    # TODO 4: Bind each parameter to corresponding argument value\n    # TODO 5: Evaluate function body in the new environment  \n    # TODO 6: Return the result of body evaluation\n    # Hint: Lambda functions store parameter list, body, and closure environment\n    pass\n```\n\n**Python-Specific Implementation Hints**\n\n- Use `isinstance(obj, type)` for runtime type checking instead of manual type field inspection\n- Use `enumerate()` when you need both index and value while iterating: `for i, char in enumerate(text)`\n- Use list slicing for token stream manipulation: `tokens[pos:]` to get remaining tokens\n- Use `str.isdigit()`, `str.isalpha()`, `str.isalnum()` for character classification during tokenization\n- Use `try/except` blocks for number parsing: `int(token)` and `float(token)` with exception handling\n- Use dictionary dispatch for special forms: `special_forms = {\"if\": eval_if, \"define\": eval_define}`\n\n**Milestone Checkpoint**\n\nAfter implementing the high-level architecture with skeleton components:\n\n1. **Run basic import test**: `python -c \"import lisp.types, lisp.tokenizer, lisp.parser, lisp.evaluator\"`\n2. **Expected output**: No errors - all modules should import successfully\n3. **Test type constructors**: Create `LispValue` instances with each type and verify they print correctly\n4. **Verify module boundaries**: Tokenizer should not import parser, parser should not import evaluator\n5. **Test error classes**: Create each error type and verify inheritance hierarchy works correctly\n\nIf imports fail, check for circular dependencies or missing `__init__.py` files. If type constructors fail, verify the `LispValue` class implementation matches the specification exactly.\n\n\n## Data Model\n\n> **Milestone(s):** All milestones (1-4) - the data model provides the foundational structures used throughout tokenization (Milestone 1), parsing (Milestone 1), evaluation (Milestones 2-4), environment management (Milestone 3), and function operations (Milestones 3-4)\n\n### Mental Model: The Universal Data Container\n\nThink of our data model as a universal container system, like a warehouse that can hold different types of cargo. Just as a shipping warehouse needs containers that can hold automobiles, furniture, or electronics while maintaining their distinct properties, our Lisp interpreter needs a unified way to represent numbers, symbols, lists, and functions while preserving their unique characteristics.\n\nThe key insight is that Lisp achieves its power through **homoiconicity** - the property where code and data use exactly the same representation. When you write `(+ 1 2)`, the parser sees this as a three-element list containing a symbol `+` followed by two numbers. When the evaluator processes this same list, it recognizes the special meaning: apply the addition function to the arguments 1 and 2. This dual nature - data structure during parsing, executable code during evaluation - requires our data model to be both flexible and precise.\n\n![Lisp Value Type Hierarchy](./diagrams/data-model.svg)\n\nOur data model serves three critical architectural purposes. First, it provides the **runtime representation** for all Lisp values during evaluation, ensuring type safety and enabling dynamic dispatch. Second, it defines the **environment structure** that implements lexical scoping through parent-child chains. Third, it establishes the **abstract syntax tree** format that bridges parsing and evaluation phases.\n\n> **Architecture Principle: Uniform Value Representation**\n> \n> Every piece of data in our Lisp system - whether a number literal, a variable name, a list of expressions, or a function definition - is represented using the same `LispValue` wrapper type. This uniformity enables generic evaluation algorithms while maintaining type safety through runtime type checking.\n\n### Lisp Value Types\n\nThe `LispValue` type serves as the universal container for all data in our interpreter. Every expression that gets parsed, every intermediate result during evaluation, and every value stored in an environment uses this same representation. This design choice reflects Lisp's fundamental philosophy that everything is data, and data can become executable code.\n\n#### LispValue Core Structure\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `value` | `Any` | The actual data payload - could be int, float, str, list, or function object |\n| `type` | `LispValueType` | Discriminator tag indicating which interpretation to apply to the value field |\n\n#### LispValueType Enumeration\n\n| Type | Runtime Representation | Typical Value Examples |\n|------|----------------------|----------------------|\n| `NUMBER` | `int` or `float` | `42`, `3.14159`, `-17` |\n| `SYMBOL` | `str` | `x`, `+`, `lambda`, `define` |\n| `LIST` | `List[LispValue]` | `[]` (empty), `[make_symbol('+'), make_number(1), make_number(2)]` |\n| `FUNCTION` | `LispFunction` | User-defined lambda functions with parameter lists and closures |\n| `BUILTIN` | `BuiltinFunction` | Native Python functions like addition, comparison operators |\n\nThe choice to use a discriminated union through the `type` field rather than inheritance reflects a pragmatic decision about runtime dispatch and serialization simplicity. Each type has distinct evaluation semantics and storage requirements.\n\n> **Decision: Discriminated Union vs Inheritance**\n> - **Context**: Need to represent multiple data types in a uniform way while enabling type-specific operations\n> - **Options Considered**: Class inheritance hierarchy, discriminated union with type tags, variant types\n> - **Decision**: Discriminated union with `LispValueType` enum\n> - **Rationale**: Simpler serialization, easier pattern matching in evaluator, no virtual method overhead, clearer type checking\n> - **Consequences**: Enables straightforward type checking via `is_number()`, `is_symbol()`, etc., but requires explicit type field management\n\n#### Number Type Representation\n\nNumbers in our Lisp implementation support both integers and floating-point values within the same `NUMBER` type. The underlying Python value can be either `int` or `float`, with automatic promotion occurring during arithmetic operations.\n\n| Operation | Integer Example | Float Example | Mixed Example |\n|-----------|----------------|---------------|---------------|\n| Creation | `make_number(42)` | `make_number(3.14)` | N/A |\n| Type check | `is_number(val) and isinstance(val.value, int)` | `is_number(val) and isinstance(val.value, float)` | `is_number(val)` |\n| Arithmetic | `42 + 17 = 59` | `3.14 + 2.86 = 6.0` | `42 + 3.14 = 45.14` |\n\nThe decision to support both integer and floating-point arithmetic within a single type reflects the mathematical nature of Lisp, where numeric operations should feel natural rather than requiring explicit type conversions.\n\n#### Symbol Type Representation\n\nSymbols represent identifiers in Lisp code - variable names, function names, and special form keywords. Unlike strings, symbols have **identity semantics** where two symbols with the same name should be considered identical for the purposes of variable lookup and comparison.\n\n| Symbol Category | Examples | Usage Context |\n|-----------------|----------|---------------|\n| Variable names | `x`, `counter`, `my-variable` | Variable binding and lookup in environments |\n| Function names | `+`, `car`, `my-function` | Function application and definition |\n| Special forms | `if`, `define`, `lambda`, `quote` | Control evaluation flow in evaluator |\n| Boolean values | `#t`, `#f` | Truth values (though we use Python booleans internally) |\n\nThe string representation of symbols allows for easy comparison and environment lookup, while the `SYMBOL` type tag distinguishes them from string literals during evaluation.\n\n#### List Type Representation\n\nLists form the backbone of Lisp syntax, representing both data structures and executable code. Our implementation uses Python lists internally, with each element being a `LispValue` to maintain type uniformity.\n\n| List Type | Internal Structure | Example |\n|-----------|-------------------|---------|\n| Empty list | `[]` | `()` in source code |\n| Data list | `[make_number(1), make_number(2), make_number(3)]` | `(1 2 3)` in source code |\n| Code list | `[make_symbol('+'), make_number(1), make_number(2)]` | `(+ 1 2)` in source code |\n| Nested list | `[make_symbol('list'), make_list([make_number(1)]), make_number(2)]` | `(list (1) 2)` in source code |\n\nThe homoiconic property means that `(+ 1 2)` is simultaneously a data structure (three-element list) and an executable expression (function call). The evaluator determines the interpretation based on context.\n\n#### Function Type Representation\n\nFunctions in our Lisp implementation come in two flavors: user-defined functions created by `lambda` expressions, and built-in functions implemented in Python. Both are wrapped in `LispValue` containers but have different internal representations.\n\n**User-Defined Functions (`LispFunction`)**:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `parameters` | `List[str]` | Parameter names that will be bound when function is called |\n| `body` | `LispValue` | The expression to evaluate when function is applied (typically a list) |\n| `closure_env` | `Environment` | The lexical environment captured when lambda was defined |\n| `name` | `Optional[str]` | Optional name for debugging and recursive calls |\n\n**Built-in Functions (`BuiltinFunction`)**:\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `implementation` | `Callable` | Python function that implements the operation |\n| `name` | `str` | Function name for error reporting and debugging |\n| `arity` | `Optional[int]` | Expected argument count, or None for variadic functions |\n\nThe distinction between user-defined and built-in functions reflects their different evaluation requirements. Built-ins can directly manipulate Python values, while user-defined functions must evaluate their bodies in properly constructed lexical environments.\n\n#### Type Predicate Functions\n\nType checking in our interpreter uses predicate functions that examine the `type` field of `LispValue` objects. These predicates enable the evaluator to dispatch to appropriate handling logic.\n\n| Predicate | Returns True When | Example Usage |\n|-----------|-------------------|---------------|\n| `is_number(value)` | `value.type == LispValueType.NUMBER` | Arithmetic operation type checking |\n| `is_symbol(value)` | `value.type == LispValueType.SYMBOL` | Variable lookup and special form detection |\n| `is_list(value)` | `value.type == LispValueType.LIST` | Function application and list operations |\n| `is_function(value)` | `value.type in [LispValueType.FUNCTION, LispValueType.BUILTIN]` | Function application validation |\n| `is_truthy(value)` | Complex boolean evaluation | Conditional expression evaluation |\n\nThe `is_truthy()` function deserves special attention as it implements Lisp's truth semantics: only the explicit false value `LISP_FALSE` is considered false, while everything else (including empty lists and zero) is considered true.\n\n### Environment Structure\n\nEnvironments implement **lexical scoping** in our interpreter by maintaining mappings from variable names to their bound values. Think of environments as nested filing cabinets where each cabinet represents a scope level, and variable lookup searches from the innermost cabinet outward until a matching folder is found.\n\n#### Mental Model: Nested Filing Cabinets\n\nImagine a series of filing cabinets arranged in a chain, where each cabinet represents a scope level in your program. When you define a function with `lambda`, it's like adding a new cabinet to the chain. When you look up a variable, you start with the most recently added cabinet (current scope) and work backward through the chain until you find a folder with that variable's name.\n\nThe critical insight is that when a function captures its environment in a closure, it's like taking a snapshot of the entire cabinet chain as it existed when the function was defined. This captured chain travels with the function, ensuring that variables remain accessible even after the original scopes have been exited.\n\n#### Environment Core Structure\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `bindings` | `Dict[str, LispValue]` | Maps variable names to their current values in this scope level |\n| `parent` | `Optional[Environment]` | Reference to the enclosing scope, or None for global environment |\n\n#### Environment Chain Operations\n\nVariable lookup in lexical scoping follows a specific traversal pattern through the environment chain. The algorithm embodies the principle that inner scopes can shadow outer scopes, but cannot modify bindings in outer scopes (in our immutable approach).\n\n**Variable Lookup Algorithm:**\n1. Start with the current environment (innermost scope)\n2. Check if the variable name exists in the current environment's `bindings` dictionary\n3. If found, return the associated `LispValue` immediately\n4. If not found and `parent` is not None, recursively search the parent environment\n5. If not found and `parent` is None (reached global scope), raise a `NameError`\n\n**Variable Binding Algorithm:**\n1. Add or update the name-value mapping in the current environment's `bindings` dictionary\n2. Do not traverse the parent chain - bindings always occur in the current scope\n3. This enables shadowing where inner scopes can define variables with the same names as outer scopes\n\n#### Environment Types and Lifecycles\n\nOur interpreter uses environments in several distinct contexts, each with different creation patterns and lifespans.\n\n| Environment Type | Creation Context | Lifespan | Parent Environment |\n|------------------|------------------|----------|-------------------|\n| Global | Interpreter startup | Entire session | None |\n| Function application | Function call begins | Until function returns | Function's closure environment |\n| Let binding | Let expression evaluation | Until let body completes | Current evaluation environment |\n| Lambda definition | Lambda expression created | Captured in closure indefinitely | Current definition environment |\n\n#### Closure Environment Capture\n\nWhen a `lambda` expression is evaluated, the resulting function value captures the current environment as its closure. This capture is **by reference**, meaning the closure maintains a pointer to the actual environment objects rather than copying their contents.\n\n> **Decision: Environment Capture Strategy**\n> - **Context**: Lambda functions need access to variables from their definition scope, even after that scope has been exited\n> - **Options Considered**: Copy environment contents, reference environment chain, hybrid copy-on-write\n> - **Decision**: Reference the environment chain directly\n> - **Rationale**: Simpler implementation, supports recursive function definitions, matches standard lexical scoping semantics\n> - **Consequences**: Closures can access mutable state changes in captured environments, but our immutable binding approach limits mutation\n\nThe capture mechanism ensures that functions defined in inner scopes retain access to outer scope variables, enabling powerful patterns like function factories and curried functions.\n\n#### Global Environment Initialization\n\nThe global environment contains all built-in functions and special constants available to user programs. It serves as the root of all environment chains and is initialized once during interpreter startup.\n\n| Binding Name | Value Type | Description |\n|--------------|------------|-------------|\n| `+` | `BUILTIN` | Arithmetic addition function |\n| `-` | `BUILTIN` | Arithmetic subtraction function |\n| `*` | `BUILTIN` | Arithmetic multiplication function |\n| `/` | `BUILTIN` | Arithmetic division function |\n| `=` | `BUILTIN` | Equality comparison function |\n| `<` | `BUILTIN` | Less-than comparison function |\n| `car` | `BUILTIN` | List head access function |\n| `cdr` | `BUILTIN` | List tail access function |\n| `cons` | `BUILTIN` | List construction function |\n| `list` | `BUILTIN` | Multi-element list constructor |\n| `null?` | `BUILTIN` | Empty list predicate |\n| `#t` | `SYMBOL` | Boolean true constant |\n| `#f` | `SYMBOL` | Boolean false constant |\n\n#### Environment Error Conditions\n\nEnvironment operations can fail in several specific ways, each requiring different error handling approaches:\n\n| Error Condition | Detection Point | Error Type | Recovery Strategy |\n|-----------------|-----------------|------------|-------------------|\n| Unbound variable lookup | Variable reference evaluation | `NameError` | Report undefined variable name |\n| Redefinition in same scope | `define` with existing name | Warning or allow | Depends on Lisp dialect choice |\n| Circular environment chain | Environment creation | `RuntimeError` | Prevent during construction |\n| Null environment access | Variable lookup | `RuntimeError` | Check parent before traversal |\n\n### Abstract Syntax Tree\n\nThe Abstract Syntax Tree (AST) represents the structural interpretation of parsed S-expressions before evaluation. In our Lisp interpreter, the AST is remarkably simple due to Lisp's uniform syntax - every expression is either an atom or a list, and this direct correspondence eliminates the complexity found in ASTs for other programming languages.\n\n#### Mental Model: Structured Blueprint\n\nThink of the AST as a blueprint that describes the structure of your program without the visual noise of parentheses and whitespace. Just as an architectural blueprint shows the relationships between rooms without showing wall colors or furniture placement, the AST shows the relationships between expressions without the syntactic details of how they were written.\n\nThe key insight is that Lisp's homoiconic nature means our AST is nearly identical to our runtime data structures. A list in the source code becomes a `LIST` type `LispValue`, and an atom becomes the corresponding `NUMBER` or `SYMBOL` type `LispValue`. This simplicity is one of Lisp's greatest strengths for interpreter implementation.\n\n#### AST Node Types\n\nSince Lisp expressions have uniform structure, our AST uses the same `LispValue` types that represent runtime data. This design decision eliminates the need for separate AST node classes and enables the same tree-walking algorithms to handle both parsing results and evaluation inputs.\n\n| Expression Type | Source Code Example | AST Representation | Node Type |\n|-----------------|--------------------|--------------------|-----------|\n| Number literal | `42` | `LispValue(42, NUMBER)` | Leaf node |\n| Symbol | `x` | `LispValue(\"x\", SYMBOL)` | Leaf node |\n| Empty list | `()` | `LispValue([], LIST)` | Leaf node |\n| Function call | `(+ 1 2)` | `LispValue([LispValue(\"+\", SYMBOL), LispValue(1, NUMBER), LispValue(2, NUMBER)], LIST)` | Internal node |\n| Nested expression | `(* (+ 1 2) 3)` | Nested `LispValue` structure with lists containing lists | Internal node |\n\n#### AST Construction Process\n\nThe parser constructs AST nodes incrementally as it processes the token stream. Each successful parse operation returns a `LispValue` that represents the structure of the parsed expression.\n\n**Atom Parsing:**\n1. Read the next token from the token stream\n2. Determine the atom type based on token characteristics (numeric pattern, special symbols, etc.)\n3. Create appropriate `LispValue` with correct type tag and converted value\n4. Return the `LispValue` as a complete AST leaf node\n\n**List Parsing:**\n1. Consume the opening parenthesis token\n2. Initialize an empty list to collect child expressions\n3. Recursively parse expressions until closing parenthesis is encountered\n4. Create a `LispValue` with `LIST` type containing the collected child expressions\n5. Return the `LispValue` as a complete AST subtree\n\n#### AST Traversal Patterns\n\nThe evaluator traverses AST nodes using pattern matching on the `type` field of `LispValue` objects. This dispatch mechanism enables different evaluation strategies for different expression types.\n\n| AST Node Type | Traversal Pattern | Evaluation Strategy |\n|---------------|-------------------|-------------------|\n| `NUMBER` | No traversal (leaf) | Return value unchanged |\n| `SYMBOL` | No traversal (leaf) | Look up binding in environment |\n| `LIST` (empty) | No traversal (leaf) | Return empty list value |\n| `LIST` (non-empty) | Traverse all children | Check for special forms vs function calls |\n\nThe traversal order matters critically for function calls, where arguments must be evaluated left-to-right before being passed to the function implementation.\n\n#### Special Form AST Recognition\n\nSpecial forms like `if`, `define`, and `lambda` require special handling during evaluation because they control the evaluation of their sub-expressions rather than evaluating all arguments and applying a function.\n\n| Special Form | AST Pattern | Argument Evaluation |\n|--------------|-------------|-------------------|\n| `(if test then else)` | 4-element list starting with `if` symbol | Test evaluated first, then only one branch |\n| `(define name value)` | 3-element list starting with `define` symbol | Only value expression is evaluated |\n| `(lambda params body)` | 3-element list starting with `lambda` symbol | Neither params nor body evaluated at definition time |\n| `(quote expr)` | 2-element list starting with `quote` symbol | Expression is not evaluated |\n\nThe evaluator recognizes special forms by checking if the first element of a list is a symbol with a special form name. This check happens before argument evaluation, allowing special forms to implement their own evaluation strategies.\n\n#### AST Transformation and Optimization\n\nWhile our basic interpreter performs minimal AST transformation, the structure supports several optimization opportunities that could be added in future iterations.\n\n| Transformation Type | Before | After | Benefit |\n|-------------------|--------|--------|---------|\n| Constant folding | `(+ 1 2)` | `3` | Eliminates runtime arithmetic |\n| Quote expansion | `'expr` | `(quote expr)` | Normalizes syntax variants |\n| Tail call marking | `(f (g x))` | Tagged AST indicating tail position | Enables tail call optimization |\n| Variable reference resolution | `x` | Direct environment slot reference | Faster variable lookup |\n\n#### AST Error Conditions\n\nSeveral error conditions can be detected during AST construction or traversal, each indicating different categories of problems in the source code.\n\n| Error Type | Example | Detection Point | Error Category |\n|------------|---------|-----------------|----------------|\n| Malformed special form | `(if condition)` | AST traversal during evaluation | `EvaluationError` |\n| Invalid parameter list | `(lambda \"not-a-list\" body)` | Lambda evaluation | `TypeError` |\n| Arity mismatch | `(+ 1)` called with two args | Function application | `ArityError` |\n| Unquoted list in parameter position | `(lambda (x y z) body)` expected but got `(lambda x y z body)` | Lambda parsing | `ParseError` |\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Confusing AST and Runtime Values**\n\nMany learners initially try to create separate classes for AST nodes and runtime values, not realizing that Lisp's homoiconic nature means they can be the same. This leads to unnecessary conversion logic and type confusion.\n\n**Why it's wrong**: Creates artificial complexity and breaks the fundamental property that code is data in Lisp.\n\n**How to fix**: Use `LispValue` for both parsed expressions and runtime values. The same data structure that represents `(+ 1 2)` during parsing also represents the list `(+ 1 2)` as a data value if it appears in a quoted context.\n\n⚠️ **Pitfall: Shallow vs Deep Environment Copying**\n\nWhen implementing closures, learners sometimes copy only the immediate environment rather than preserving the entire parent chain, breaking lexical scoping for nested functions.\n\n**Why it's wrong**: Functions lose access to variables from outer scopes that aren't immediately visible, violating lexical scoping rules.\n\n**How to fix**: Closure capture should reference the entire environment chain, not just the immediate environment. The `closure_env` field should point to the complete environment where the lambda was defined.\n\n⚠️ **Pitfall: Evaluating Special Form Arguments**\n\nA common mistake is evaluating all list elements before checking for special forms, which breaks forms like `if` where only one branch should be evaluated.\n\n**Why it's wrong**: Expressions like `(if #t 1 (/ 1 0))` would crash instead of safely returning 1, and forms like `(define x 10)` would try to evaluate `x` before it's defined.\n\n**How to fix**: Check the first element of non-empty lists for special form names before evaluating any arguments. Only regular function calls should evaluate all their arguments.\n\n⚠️ **Pitfall: Mutable vs Immutable Environment Bindings**\n\nSome implementations modify parent environments during variable assignment, breaking the isolation between scopes and causing unexpected variable shadowing behavior.\n\n**Why it's wrong**: Inner scopes can accidentally modify outer scope variables, violating lexical scoping principles and making programs unpredictable.\n\n**How to fix**: Variable bindings should only modify the current environment's `bindings` dictionary. Variable lookup traverses the parent chain, but variable assignment always creates new bindings in the current scope.\n\n⚠️ **Pitfall: Missing Type Tag Validation**\n\nForgetting to validate the `type` field before casting the `value` field leads to runtime type errors when invalid combinations occur.\n\n**Why it's wrong**: Code like `val.value.upper()` crashes if `val.type` is `NUMBER` instead of `SYMBOL`, and arithmetic operations fail silently or crash on non-numeric values.\n\n**How to fix**: Always use type predicate functions like `is_number()` and `is_symbol()` before accessing the `value` field with type-specific operations.\n\n### Implementation Guidance\n\nThis subsection provides concrete Python implementations for the core data structures described above. The code follows object-oriented principles while maintaining the simplicity that makes Lisp interpreters approachable for learning.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Value Types | Python dataclasses with enum discriminators | Tagged union with Protocol classes |\n| Environment | Dictionary with optional parent reference | Immutable mapping with structural sharing |\n| Type Checking | Runtime isinstance checks | Static typing with Union types |\n| Error Handling | Exception hierarchy with descriptive messages | Result types with error accumulation |\n\n#### Recommended File Structure\n\n```\nlisp_interpreter/\n  src/\n    __init__.py\n    data_model.py           ← this implementation (LispValue, Environment)\n    errors.py               ← error type definitions\n    tokenizer.py           ← converts text to tokens\n    parser.py              ← converts tokens to AST\n    evaluator.py           ← evaluates AST in environments\n  tests/\n    test_data_model.py     ← unit tests for data structures\n    test_integration.py    ← end-to-end interpreter tests\n  main.py                  ← REPL interface\n```\n\n#### Core Data Structure Implementation\n\n**Complete `errors.py` (Infrastructure Code):**\n\n```python\nfrom typing import Optional\n\nclass LispError(Exception):\n    \"\"\"Base class for all Lisp interpreter errors.\"\"\"\n    def __init__(self, message: str, source_location: Optional[int] = None):\n        self.message = message\n        self.source_location = source_location\n        super().__init__(message)\n\nclass TokenizerError(LispError):\n    \"\"\"Raised when tokenization fails due to invalid syntax.\"\"\"\n    pass\n\nclass ParseError(LispError):\n    \"\"\"Raised when parsing fails due to malformed expressions.\"\"\"\n    pass\n\nclass EvaluationError(LispError):\n    \"\"\"Base class for errors during expression evaluation.\"\"\"\n    pass\n\nclass NameError(EvaluationError):\n    \"\"\"Raised when referencing an unbound variable.\"\"\"\n    pass\n\nclass TypeError(EvaluationError):\n    \"\"\"Raised when using a value with an inappropriate type.\"\"\"\n    pass\n\nclass ArityError(EvaluationError):\n    \"\"\"Raised when calling a function with wrong number of arguments.\"\"\"\n    def __init__(self, expected: int, actual: int, function_name: str):\n        self.expected = expected\n        self.actual = actual\n        self.function_name = function_name\n        message = f\"{function_name} expects {expected} arguments, got {actual}\"\n        super().__init__(message)\n```\n\n**Core Value Types Skeleton (`data_model.py`):**\n\n```python\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Callable\nfrom dataclasses import dataclass\n\nclass LispValueType(Enum):\n    NUMBER = \"number\"\n    SYMBOL = \"symbol\"\n    LIST = \"list\"\n    FUNCTION = \"function\"\n    BUILTIN = \"builtin\"\n\n@dataclass\nclass LispValue:\n    \"\"\"Universal container for all Lisp values during parsing and evaluation.\"\"\"\n    value: Any\n    type: LispValueType\n    \n    def __str__(self) -> str:\n        \"\"\"String representation for debugging and REPL output.\"\"\"\n        # TODO 1: Handle NUMBER type - return str(self.value)\n        # TODO 2: Handle SYMBOL type - return self.value directly  \n        # TODO 3: Handle LIST type - format as (elem1 elem2 ...) with recursive __str__\n        # TODO 4: Handle FUNCTION type - return something like \"<function:name>\"\n        # TODO 5: Handle BUILTIN type - return something like \"<builtin:name>\"\n        pass\n\n# Value constructor functions\ndef make_number(value: float | int) -> LispValue:\n    \"\"\"Create a numeric LispValue from a Python number.\"\"\"\n    # TODO: Return LispValue with appropriate type tag and converted value\n    pass\n\ndef make_symbol(name: str) -> LispValue:\n    \"\"\"Create a symbol LispValue from a string name.\"\"\"\n    # TODO: Return LispValue with SYMBOL type and name as value\n    pass\n\ndef make_list(elements: List[LispValue]) -> LispValue:\n    \"\"\"Create a list LispValue from a sequence of elements.\"\"\"\n    # TODO: Return LispValue with LIST type and elements as value\n    pass\n\n# Type predicate functions\ndef is_number(value: LispValue) -> bool:\n    \"\"\"Check if a LispValue represents a number.\"\"\"\n    # TODO: Check if value.type equals LispValueType.NUMBER\n    pass\n\ndef is_symbol(value: LispValue) -> bool:\n    \"\"\"Check if a LispValue represents a symbol.\"\"\"\n    # TODO: Check if value.type equals LispValueType.SYMBOL  \n    pass\n\ndef is_list(value: LispValue) -> bool:\n    \"\"\"Check if a LispValue represents a list.\"\"\"\n    # TODO: Check if value.type equals LispValueType.LIST\n    pass\n\ndef is_truthy(value: LispValue) -> bool:\n    \"\"\"Implement Lisp truthiness: only LISP_FALSE is false.\"\"\"\n    # TODO 1: Check if value equals LISP_FALSE constant - if so return False\n    # TODO 2: All other values (including empty lists, zero) are truthy - return True\n    pass\n\n# Constants\nLISP_TRUE = make_symbol(\"#t\")\nLISP_FALSE = make_symbol(\"#f\") \nEMPTY_LIST = make_list([])\n```\n\n#### Environment Implementation Skeleton\n\n```python\n@dataclass\nclass Environment:\n    \"\"\"Lexical environment mapping variable names to values.\"\"\"\n    bindings: Dict[str, LispValue]\n    parent: Optional['Environment'] = None\n    \n    def lookup(self, name: str) -> LispValue:\n        \"\"\"Look up a variable binding, searching parent environments if necessary.\"\"\"\n        # TODO 1: Check if name exists in self.bindings - if so return the value\n        # TODO 2: If not found and self.parent is not None, recursively search parent\n        # TODO 3: If not found and self.parent is None, raise NameError with descriptive message\n        # Hint: Use \"in\" operator to check dictionary membership\n        pass\n    \n    def define(self, name: str, value: LispValue) -> None:\n        \"\"\"Create or update a variable binding in the current environment.\"\"\"\n        # TODO 1: Add the name->value mapping to self.bindings\n        # TODO 2: Do not search parent environments - always bind in current scope\n        # This enables variable shadowing in inner scopes\n        pass\n    \n    def extend(self) -> 'Environment':\n        \"\"\"Create a new child environment with this environment as parent.\"\"\"\n        # TODO: Return new Environment with empty bindings and self as parent\n        # This is used when entering function calls or let expressions\n        pass\n\ndef create_global_environment() -> Environment:\n    \"\"\"Create the global environment with built-in functions and constants.\"\"\"\n    env = Environment(bindings={})\n    \n    # TODO 1: Add arithmetic operators (+, -, *, /) as BUILTIN LispValues\n    # TODO 2: Add comparison operators (=, <, >, <=, >=) as BUILTIN LispValues  \n    # TODO 3: Add list operators (car, cdr, cons, list, null?) as BUILTIN LispValues\n    # TODO 4: Add boolean constants (#t, #f) using LISP_TRUE and LISP_FALSE\n    # \n    # For now, create placeholder BuiltinFunction objects:\n    # env.define(\"+\", LispValue(BuiltinFunction(lambda *args: ...), LispValueType.BUILTIN))\n    \n    return env\n```\n\n#### Function Type Implementation Skeleton\n\n```python\n@dataclass\nclass LispFunction:\n    \"\"\"User-defined function created by lambda expressions.\"\"\"\n    parameters: List[str]\n    body: LispValue\n    closure_env: Environment\n    name: Optional[str] = None\n    \n    def __str__(self) -> str:\n        name_part = self.name if self.name else \"anonymous\"\n        return f\"<function:{name_part}>\"\n\n@dataclass  \nclass BuiltinFunction:\n    \"\"\"Built-in function implemented in Python.\"\"\"\n    implementation: Callable\n    name: str\n    arity: Optional[int] = None  # None means variadic\n    \n    def __str__(self) -> str:\n        return f\"<builtin:{self.name}>\"\n\ndef make_function(parameters: List[str], body: LispValue, closure_env: Environment, \n                 name: Optional[str] = None) -> LispValue:\n    \"\"\"Create a user-defined function LispValue.\"\"\"\n    # TODO: Create LispFunction object and wrap in LispValue with FUNCTION type\n    pass\n\ndef make_builtin(implementation: Callable, name: str, arity: Optional[int] = None) -> LispValue:\n    \"\"\"Create a built-in function LispValue.\"\"\"\n    # TODO: Create BuiltinFunction object and wrap in LispValue with BUILTIN type\n    pass\n```\n\n#### Language-Specific Hints\n\n- Use `isinstance(value.value, (int, float))` to check for numeric types within NUMBER values\n- Python's `dataclass` decorator automatically generates `__init__`, `__eq__`, and `__repr__` methods\n- Use `typing.Union` or the `|` operator (Python 3.10+) for parameters that accept multiple types\n- Dictionary membership testing with `name in self.bindings` is O(1) average case\n- Use `Optional[Type]` instead of `Union[Type, None]` for nullable references\n\n#### Milestone Checkpoint\n\nAfter implementing the data model structures:\n\n**What to test:**\n```bash\npython -m pytest tests/test_data_model.py -v\n```\n\n**Expected behavior:**\n- Value constructors create LispValues with correct type tags\n- Type predicates correctly identify value types\n- Environment lookup traverses parent chain correctly\n- Environment definition creates bindings in current scope only\n- Function objects store closure environments properly\n\n**Manual verification:**\n```python\n# In Python REPL or test file:\nfrom src.data_model import *\n\n# Create values\nnum = make_number(42)\nsym = make_symbol(\"x\") \nlst = make_list([num, sym])\n\n# Test type predicates  \nassert is_number(num)\nassert is_symbol(sym)\nassert is_list(lst)\n\n# Test environment chains\nglobal_env = create_global_environment()\nlocal_env = global_env.extend()\nlocal_env.define(\"x\", num)\nassert local_env.lookup(\"x\") == num\n```\n\n**Signs something is wrong:**\n- Type predicates return incorrect results → Check LispValueType enum values\n- Environment lookup fails → Check parent chain traversal logic\n- Value constructors crash → Check type tag assignment in constructors\n\n\n## Tokenizer Design\n\n> **Milestone(s):** Milestone 1 (S-Expression Parser) - the tokenizer is the first stage of the three-part pipeline that converts raw Lisp source text into tokens that the parser can consume\n\nThe tokenizer serves as the foundation of our Lisp interpreter, transforming raw source text into a structured stream of tokens that the parser can understand. This component must handle the unique characteristics of Lisp syntax while maintaining the simplicity that makes Lisp an excellent learning vehicle for interpreter construction.\n\n### Mental Model: Text Dissection\n\nUnderstanding tokenization requires thinking of it as **careful text surgery that preserves meaning**. Imagine you're a librarian who receives a handwritten manuscript that needs to be cataloged. The text flows continuously across pages with no clear boundaries between ideas, but you need to identify distinct conceptual units: individual words, complete sentences, chapter boundaries, and special notations.\n\nThe tokenizer performs similar surgery on Lisp source code. It receives an unstructured stream of characters and must identify meaningful boundaries: where one symbol ends and another begins, which parentheses belong together, where strings start and end, and which parts are comments that should be ignored. Like a skilled surgeon, the tokenizer must make precise cuts that preserve the semantic meaning of each piece while preparing them for the next stage of processing.\n\nConsider the Lisp expression `(+ 42 (* 3 14))`. To human eyes, this clearly contains symbols, numbers, and nested structure. But to a computer, this is just a sequence of 15 characters. The tokenizer's job is to recognize that the opening parenthesis starts a list, that `+` is a complete symbol, that `42` represents a number, and that the nested parentheses create a sub-expression. Each recognition requires looking ahead and behind in the character stream to determine precise boundaries.\n\nThe critical insight is that tokenization is **boundary detection with context sensitivity**. Unlike simple word processing where spaces clearly separate words, Lisp tokenization must handle cases where meaningful tokens can be adjacent without separators (`()` contains two tokens) and where the same character can have different meanings in different contexts (a quote character inside a string literal versus a quote character that starts symbol quoting).\n\n### Token Types and Recognition\n\nThe Lisp tokenizer recognizes a carefully designed set of token types that capture all meaningful elements of S-expression syntax. Each token type has specific recognition rules and carries different semantic information for the parser.\n\n| Token Type | Character Patterns | Recognition Rules | Semantic Purpose |\n|------------|-------------------|------------------|------------------|\n| LEFT_PAREN | `(` | Single character match | Marks beginning of list structure |\n| RIGHT_PAREN | `)` | Single character match | Marks end of list structure |\n| NUMBER | Digits, optional decimal, optional sign | Regex: `^[+-]?[0-9]+(\\.[0-9]+)?$` | Literal numeric values |\n| SYMBOL | Letters, digits, allowed punctuation | Non-numeric atoms, function names | Identifiers and operators |\n| STRING | Content between quotes | Paired quote delimiters with escape handling | String literal values |\n| QUOTE | `'` | Single character match | Shorthand for quote special form |\n| COMMENT | `;` to end of line | Semicolon to newline | Ignored by parser |\n| WHITESPACE | Spaces, tabs, newlines | Character class match | Token separation only |\n| EOF | End of input stream | Position-based detection | Signals end of parsing |\n\n**Number Recognition**: Numbers in our Lisp support both integers and floating-point values, with optional signs. The tokenizer must distinguish between valid numbers like `42`, `-17`, `3.14159`, and `+0.5` versus invalid patterns like `3.14.159` or `++42`. The recognition algorithm scans for an optional sign, followed by one or more digits, optionally followed by a decimal point and more digits.\n\n**Symbol Recognition**: Symbols represent the most complex token type because they encompass everything that isn't a number, string, or structural element. Valid Lisp symbols include traditional identifiers like `factorial` and `list-length`, operators like `+` and `<=`, and special characters like `*global-counter*`. The key insight is that symbol recognition works by **exclusion** - if it's not a number, string, or structural token, and it contains valid symbol characters, it's a symbol.\n\n| Symbol Class | Examples | Character Set | Special Rules |\n|--------------|----------|---------------|---------------|\n| Identifiers | `factorial`, `my-function` | Letters, digits, `-`, `_` | Cannot start with digit |\n| Operators | `+`, `*`, `<=`, `>=` | Arithmetic and comparison symbols | Complete operator sequences |\n| Special Symbols | `*global*`, `nil`, `t` | Letters with special punctuation | Conventional naming patterns |\n| Keywords | `:keyword`, `:type` | Starts with `:` | Self-evaluating symbols |\n\n**String Recognition**: String literals begin and end with double quotes and can contain any characters except unescaped quotes. The tokenizer must handle escape sequences like `\\\"` for embedded quotes, `\\n` for newlines, and `\\\\` for literal backslashes. String recognition requires **stateful scanning** because the meaning of each character depends on what came before it.\n\n**Comment Handling**: Lisp uses semicolon-initiated comments that extend to the end of the line. The tokenizer recognizes `;` as the start of a comment and consumes all characters until it encounters a newline or end-of-file. Comments are typically discarded during tokenization rather than passed to the parser, simplifying the parsing logic.\n\n> **Decision: Token Position Tracking**\n> - **Context**: Error reporting requires knowing where in the source text each token originated\n> - **Options Considered**: \n>   1. No position tracking (simpler implementation)\n>   2. Line and column numbers (human-readable locations)\n>   3. Character offset positions (simpler arithmetic)\n> - **Decision**: Character offset positions with line/column computation on demand\n> - **Rationale**: Offset positions are simpler to maintain during tokenization and can be converted to line/column for error display when needed\n> - **Consequences**: Enables precise error reporting while keeping tokenizer logic straightforward\n\n### Tokenization Algorithm\n\nThe tokenization process follows a **single-pass scanning algorithm** that examines each character in the input stream exactly once while maintaining minimal state. This approach ensures linear time complexity and predictable memory usage regardless of input size.\n\nThe core algorithm structure uses a **state machine approach** where the tokenizer's behavior depends on its current state and the next character in the input stream. The primary states are: scanning normal text, inside a string literal, and inside a comment.\n\n![Tokenizer State Machine](./diagrams/tokenizer-state-machine.svg)\n\n**Main Tokenization Loop**:\n\n1. **Initialize scanner state** with input text, current position at zero, and empty token list\n2. **Skip leading whitespace** by advancing position while current character is space, tab, or newline\n3. **Check for end of input** - if position >= text length, emit EOF token and terminate\n4. **Examine current character** to determine token type:\n   - `(` → emit LEFT_PAREN token, advance one position\n   - `)` → emit RIGHT_PAREN token, advance one position  \n   - `'` → emit QUOTE token, advance one position\n   - `;` → enter comment scanning mode\n   - `\"` → enter string scanning mode\n   - Digit or sign followed by digit → enter number scanning mode\n   - Other characters → enter symbol scanning mode\n5. **Emit completed token** with type, value, and starting position\n6. **Return to step 2** until EOF is reached\n\n**String Scanning Subroutine**:\n\n1. **Record starting position** and advance past opening quote character\n2. **Accumulate characters** until closing quote or end of input:\n   - Regular character → append to string value\n   - `\\` → enter escape sequence handling\n   - `\"` → complete string token\n   - EOF → emit TokenizerError for unterminated string\n3. **Handle escape sequences** by examining character after backslash:\n   - `\\\"` → append literal quote character\n   - `\\n` → append newline character\n   - `\\\\` → append literal backslash character\n   - Other → emit TokenizerError for invalid escape\n4. **Emit STRING token** with accumulated value and starting position\n\n**Number Scanning Subroutine**:\n\n1. **Record starting position** and check for optional sign character\n2. **Scan integer portion** by accumulating consecutive digits\n3. **Check for decimal point** - if found, scan fractional portion\n4. **Validate number format** to ensure at least one digit was found\n5. **Emit NUMBER token** with string representation for later parsing\n\n**Symbol Scanning Subroutine**:\n\n1. **Record starting position** and begin accumulating valid symbol characters\n2. **Continue scanning** while characters match symbol character set (letters, digits, allowed punctuation)\n3. **Stop at delimiter** (whitespace, parentheses, quotes, or end of input)\n4. **Emit SYMBOL token** with accumulated character sequence\n\n**Comment Scanning Subroutine**:\n\n1. **Advance past semicolon** that started the comment\n2. **Skip characters** until newline or end of input is reached\n3. **Return to main loop** without emitting any token (comments are discarded)\n\n> The tokenizer's **single-pass guarantee** means that once a character has been examined, it never needs to be reconsidered. This property enables streaming tokenization of large files and ensures predictable performance characteristics.\n\n### Common Tokenizer Pitfalls\n\nBeginning interpreter implementers frequently encounter specific categories of errors when building tokenizers. Understanding these pitfalls helps avoid debugging sessions that can consume hours of development time.\n\n**⚠️ Pitfall: Incomplete String Escape Handling**\n\nMany implementations correctly handle basic escape sequences like `\\\"` but fail on edge cases like `\"She said \\\"Hello, world!\\\"\"` or strings ending with backslashes like `\"path\\\\to\\\\file\\\\\"`. The error manifests as either incorrectly parsed strings or tokenizer exceptions when processing valid Lisp code.\n\n*Why this fails*: String scanning requires **lookahead logic** to distinguish between escape sequences and literal characters. A naive implementation might treat `\\\"` as an escaped quote but fail to handle the quote that follows it, or might not properly handle a backslash at the end of a string.\n\n*How to fix it*: Implement a proper **escape state machine** within string scanning. When encountering a backslash, examine the next character to determine the complete escape sequence before continuing. Always verify that the string has a closing quote after processing all escape sequences.\n\n**⚠️ Pitfall: Negative Number Recognition Conflicts**\n\nThe expression `(- 5)` should tokenize as LEFT_PAREN, SYMBOL(`-`), NUMBER(`5`), RIGHT_PAREN, but incorrect implementations might tokenize it as LEFT_PAREN, NUMBER(`-5`), RIGHT_PAREN. This happens because the tokenizer incorrectly treats the `-` as the start of a negative number rather than a separate operator symbol.\n\n*Why this fails*: Number recognition logic that only checks \"starts with `-`\" doesn't consider the **contextual requirements** for negative numbers. A minus sign only starts a negative number when it's followed immediately by digits, not when it appears as a standalone operator.\n\n*How to fix it*: Implement **lookahead checking** in number recognition. When encountering a `-` or `+`, examine the next character. Only begin number scanning if the following character is a digit. Otherwise, treat the sign as a symbol.\n\n**⚠️ Pitfall: Whitespace Handling in String Literals**\n\nSome tokenizers incorrectly skip whitespace inside string literals, turning `\"hello world\"` into `\"helloworld\"`. This occurs when the main tokenization loop's whitespace-skipping logic runs even during string scanning.\n\n*Why this fails*: The tokenizer applies **global whitespace rules** regardless of context. Inside string literals, whitespace is meaningful and must be preserved exactly as written.\n\n*How to fix it*: Use **state-dependent character handling**. Only skip whitespace when in the normal scanning state. When inside string literals, preserve all characters including spaces, tabs, and newlines.\n\n**⚠️ Pitfall: Symbol Character Set Inconsistency**\n\nDifferent parts of the tokenizer might use inconsistent rules for what constitutes a valid symbol character. For example, the symbol `list->vector` might be accepted during initial scanning but rejected when the evaluator tries to look it up, or vice versa.\n\n*Why this fails*: Symbol validation logic scattered across multiple functions can become **inconsistent over time** as the codebase evolves. Each function might implement slightly different character set rules.\n\n*How to fix it*: Define symbol character validation in **one canonical location** and reference it consistently. Create a helper function like `is_symbol_char(char)` that encapsulates all symbol character rules and use it throughout the tokenizer.\n\n**⚠️ Pitfall: EOF Handling in Partial Tokens**\n\nWhen input ends unexpectedly (like an unterminated string `\"hello` or an incomplete number `3.`), some tokenizers crash instead of producing helpful error messages. This makes debugging difficult for users of the Lisp interpreter.\n\n*Why this fails*: Token scanning subroutines assume they can always read ahead to complete a token. When EOF occurs in the middle of token construction, they may access invalid memory or throw generic exceptions.\n\n*How to fix it*: Add **explicit EOF checking** in all scanning subroutines. Before accessing the next character, verify that the position hasn't exceeded the input length. When EOF occurs during token construction, emit a descriptive TokenizerError that explains what was expected.\n\n| Error Scenario | Bad Behavior | Correct Behavior | Detection Method |\n|----------------|--------------|------------------|------------------|\n| Unterminated string | Crash or wrong parse | TokenizerError with position | Check EOF in string scanner |\n| Invalid escape `\\x` | Silent corruption | TokenizerError describing valid escapes | Validate escape sequences |\n| Incomplete number `3.` | Parse as symbol or crash | TokenizerError or complete as `3.0` | Validate number format before emitting |\n| Standalone `-` treated as number | Wrong token type | Recognize as symbol | Lookahead for digits after sign |\n\n### Implementation Guidance\n\nThe tokenizer implementation requires careful balance between simplicity and robustness. The following guidance provides both working infrastructure and clear extension points for the core learning components.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|------------------|\n| Input Handling | String slicing with index | StringIO or custom stream reader |\n| Token Storage | List of Token objects | Generator yielding tokens on demand |\n| Error Reporting | Exception with message | Rich error with position and context |\n| Character Classification | Individual character checks | Precomputed character class sets |\n\n**Recommended File Structure:**\n\nThe tokenizer should be organized as a self-contained module with clear separation between token definitions, scanning logic, and error handling:\n\n```\nlisp-interpreter/\n  src/\n    tokenizer/\n      __init__.py          ← Public API exports\n      tokens.py            ← Token class and type definitions\n      scanner.py           ← Core tokenization logic\n      errors.py            ← Tokenizer-specific error classes\n      char_utils.py        ← Character classification utilities\n    tests/\n      test_tokenizer.py    ← Comprehensive tokenizer tests\n  examples/\n    sample_tokens.lisp     ← Test cases for manual verification\n```\n\n**Infrastructure Starter Code (Complete):**\n\nThis code provides the foundational data structures and utilities that support tokenization but aren't the primary learning focus:\n\n```python\n# tokens.py - Complete token representation\nfrom dataclasses import dataclass\nfrom typing import Any, Optional\nfrom enum import Enum, auto\n\nclass TokenType(Enum):\n    LEFT_PAREN = auto()\n    RIGHT_PAREN = auto()\n    NUMBER = auto()\n    SYMBOL = auto()\n    STRING = auto()\n    QUOTE = auto()\n    COMMENT = auto()\n    WHITESPACE = auto()\n    EOF = auto()\n\n@dataclass(frozen=True)\nclass Token:\n    type: str\n    value: str\n    position: int\n    \n    def __str__(self) -> str:\n        return f\"{self.type}({self.value!r})@{self.position}\"\n    \n    def __repr__(self) -> str:\n        return self.__str__()\n\n# errors.py - Complete error handling infrastructure\nclass LispError(Exception):\n    \"\"\"Base exception for all Lisp interpreter errors.\"\"\"\n    def __init__(self, message: str, source_location: Optional[int] = None):\n        super().__init__(message)\n        self.message = message\n        self.source_location = source_location\n\nclass TokenizerError(LispError):\n    \"\"\"Errors that occur during tokenization phase.\"\"\"\n    pass\n\n# char_utils.py - Complete character classification utilities\ndef is_whitespace(char: str) -> bool:\n    \"\"\"Check if character is Lisp whitespace (space, tab, newline).\"\"\"\n    return char in ' \\t\\n\\r'\n\ndef is_digit(char: str) -> bool:\n    \"\"\"Check if character is a decimal digit.\"\"\"\n    return '0' <= char <= '9'\n\ndef is_letter(char: str) -> bool:\n    \"\"\"Check if character is an ASCII letter.\"\"\"\n    return ('a' <= char <= 'z') or ('A' <= char <= 'Z')\n\ndef is_symbol_start_char(char: str) -> bool:\n    \"\"\"Check if character can start a symbol.\"\"\"\n    if is_letter(char):\n        return True\n    return char in '+-*/<>=!?$%&_'\n\ndef is_symbol_char(char: str) -> bool:\n    \"\"\"Check if character can appear in a symbol.\"\"\"\n    if is_letter(char) or is_digit(char):\n        return True\n    return char in '+-*/<>=!?$%&_-'\n\ndef is_sign_char(char: str) -> bool:\n    \"\"\"Check if character is a numeric sign.\"\"\"\n    return char in '+-'\n\nESCAPE_SEQUENCES = {\n    'n': '\\n',\n    't': '\\t',\n    'r': '\\r',\n    '\\\\': '\\\\',\n    '\"': '\"',\n}\n```\n\n**Core Tokenizer Skeleton (Learning Focus):**\n\nThis skeleton provides the structure for the main tokenization algorithm that learners should implement themselves:\n\n```python\n# scanner.py - Core tokenization logic for learners to complete\nfrom typing import List, Optional\nfrom .tokens import Token, TokenType\nfrom .errors import TokenizerError\nfrom .char_utils import *\n\nclass Scanner:\n    \"\"\"Converts Lisp source text into a stream of tokens.\"\"\"\n    \n    def __init__(self, text: str):\n        self.text = text\n        self.position = 0\n        self.tokens: List[Token] = []\n    \n    def tokenize(text: str) -> List[Token]:\n        \"\"\"Main entry point: convert text to token list.\"\"\"\n        scanner = Scanner(text)\n        return scanner.scan_all()\n    \n    def scan_all(self) -> List[Token]:\n        \"\"\"\n        Main tokenization loop that processes entire input.\n        Returns list of all tokens including final EOF token.\n        \"\"\"\n        # TODO 1: Loop until EOF is reached\n        # TODO 2: Skip whitespace at current position\n        # TODO 3: Check for end of input and emit EOF token\n        # TODO 4: Determine token type based on current character\n        # TODO 5: Call appropriate scanning method for token type\n        # TODO 6: Add completed token to results list\n        # TODO 7: Continue until EOF token is emitted\n        # Hint: Use self.current_char() to examine next character\n        # Hint: Each scan_* method should advance self.position appropriately\n        pass\n    \n    def current_char(self) -> Optional[str]:\n        \"\"\"Return current character or None if at EOF.\"\"\"\n        # TODO: Check if position is within text bounds\n        # TODO: Return character at current position or None\n        pass\n    \n    def advance(self) -> None:\n        \"\"\"Move to next character position.\"\"\"\n        # TODO: Increment position counter\n        # TODO: Ensure we don't advance past end of text\n        pass\n    \n    def skip_whitespace(self) -> None:\n        \"\"\"Skip over whitespace characters at current position.\"\"\"\n        # TODO: Loop while current character is whitespace\n        # TODO: Use is_whitespace() helper function\n        # TODO: Advance position for each whitespace character\n        pass\n    \n    def scan_string(self) -> Token:\n        \"\"\"\n        Scan a string literal starting at current position.\n        Handles escape sequences and validates proper termination.\n        \"\"\"\n        start_pos = self.position\n        # TODO 1: Advance past opening quote character\n        # TODO 2: Initialize empty string for accumulating characters\n        # TODO 3: Loop until closing quote or EOF\n        # TODO 4: Handle regular characters by adding to result\n        # TODO 5: Handle escape sequences using ESCAPE_SEQUENCES dict\n        # TODO 6: Check for EOF before string termination (error case)\n        # TODO 7: Advance past closing quote\n        # TODO 8: Return STRING token with accumulated value\n        # Hint: When you see '\\', look at next character for escape type\n        # Hint: Raise TokenizerError for unterminated strings\n        pass\n    \n    def scan_number(self) -> Token:\n        \"\"\"\n        Scan a numeric literal (integer or floating-point).\n        Handles optional signs and decimal points.\n        \"\"\"\n        start_pos = self.position\n        # TODO 1: Check for optional sign character and include if present\n        # TODO 2: Scan integer portion (sequence of digits)\n        # TODO 3: Check for decimal point\n        # TODO 4: If decimal point found, scan fractional portion\n        # TODO 5: Validate that at least one digit was found\n        # TODO 6: Return NUMBER token with complete numeric string\n        # Hint: Use is_digit() and is_sign_char() helper functions\n        # Hint: Track whether we've seen any digits to validate number format\n        pass\n    \n    def scan_symbol(self) -> Token:\n        \"\"\"\n        Scan a symbol (identifier, operator, or keyword).\n        Continues until delimiter character is encountered.\n        \"\"\"\n        start_pos = self.position\n        # TODO 1: Initialize empty string for accumulating symbol characters\n        # TODO 2: Loop while current character is valid for symbols\n        # TODO 3: Add each valid character to result\n        # TODO 4: Stop at whitespace, parentheses, quotes, or EOF\n        # TODO 5: Return SYMBOL token with accumulated characters\n        # Hint: Use is_symbol_char() helper function\n        # Hint: Don't advance past the delimiter character\n        pass\n    \n    def scan_comment(self) -> None:\n        \"\"\"\n        Skip a comment from semicolon to end of line.\n        Comments are discarded rather than returned as tokens.\n        \"\"\"\n        # TODO 1: Advance past the semicolon character\n        # TODO 2: Skip characters until newline or EOF\n        # TODO 3: Don't emit any token (comments are ignored)\n        # Hint: Look for '\\n' character or end of input\n        pass\n    \n    def make_single_char_token(self, token_type: str) -> Token:\n        \"\"\"Create token for single-character elements like parentheses.\"\"\"\n        # TODO 1: Record current position\n        # TODO 2: Get current character as token value  \n        # TODO 3: Advance past the character\n        # TODO 4: Return Token with specified type, character value, and position\n        pass\n```\n\n**Language-Specific Hints:**\n\n- **String Handling**: Python's string slicing (`text[pos:pos+1]`) is efficient for single character access, but be careful with index bounds checking\n- **Character Classification**: Use Python's built-in string methods like `char.isdigit()` and `char.isalpha()` for basic checks, but implement custom logic for Lisp-specific symbol characters  \n- **Error Reporting**: Include the problematic character and its position in error messages: `f\"Invalid escape sequence '\\\\{char}' at position {pos}\"`\n- **Performance**: For large files, consider using `io.StringIO` instead of string indexing, but the simple approach works fine for learning\n\n**Milestone Checkpoint:**\n\nAfter implementing the tokenizer, verify correct behavior with these test cases:\n\n```python\n# Test basic tokenization\ntokens = tokenize(\"(+ 42 3.14)\")\nexpected_types = [\"LEFT_PAREN\", \"SYMBOL\", \"NUMBER\", \"NUMBER\", \"RIGHT_PAREN\", \"EOF\"]\nassert [t.type for t in tokens] == expected_types\n\n# Test string handling  \ntokens = tokenize('\"hello, world!\"')\nassert tokens[0].value == \"hello, world!\"\n\n# Test escape sequences\ntokens = tokenize(r'\"She said \\\"Hello!\\\"\"')\nassert tokens[0].value == 'She said \"Hello!\"'\n\n# Test comments are ignored\ntokens = tokenize(\"42 ; this is a comment\\n43\")\nvalues = [t.value for t in tokens if t.type != \"EOF\"]\nassert values == [\"42\", \"43\"]\n```\n\n**Signs of Success**: The tokenizer should handle nested parentheses, preserve string content exactly (including whitespace), correctly identify numbers versus symbols, and provide helpful error messages for malformed input.\n\n**Signs of Problems**: If you see symbols being split incorrectly (`list->vector` becoming separate `list`, `->`, `vector` tokens), numbers not being recognized (negative numbers appearing as separate `-` and `42` tokens), or crashes on unterminated strings, revisit the character classification and lookahead logic in the scanning methods.\n\n\n## Parser Design\n\n> **Milestone(s):** Milestone 1 (S-Expression Parser) - the parser transforms the token stream produced by the tokenizer into nested data structures representing the abstract syntax tree\n\nThe **parser** transforms a linear sequence of tokens into a hierarchical tree structure that represents the nested nature of Lisp S-expressions. This component bridges the gap between the flat token stream from tokenization and the structured data needed for evaluation. The parser must handle arbitrarily deep nesting, special syntax like quotes, and error conditions while maintaining the structural integrity of the original S-expression.\n\n![Parse Tree Construction Sequence](./diagrams/parsing-sequence.svg)\n\n### Mental Model: Nested Container Assembly\n\nThink of parsing as **assembling nested containers from a stream of parts**. Imagine you're working on an assembly line where containers (parentheses) and items (atoms) flow past you in sequence. Your job is to recognize when a container starts, collect all the items that belong inside it (including other nested containers), and close the container when you reach its matching end piece.\n\nWhen you see a left parenthesis `(`, you know a new container has started. You must now collect everything that follows—atoms, strings, numbers, and even other complete containers—until you find the matching right parenthesis `)`. The tricky part is that containers can contain other containers, so you might need to pause assembling the current container to fully assemble a nested one first.\n\nThis process mirrors exactly how Lisp parsing works. The parser maintains a mental stack of \"containers being assembled.\" When it encounters `(`, it starts a new list. When it encounters atoms, it adds them to the current list being built. When it encounters `)`, it completes the current list and either returns it (if it's the top-level expression) or adds it to the parent list being assembled.\n\nThe key insight is that **parsing is inherently recursive**—to parse a list, you must be able to parse all the expressions inside it, some of which might themselves be lists requiring the same parsing process.\n\n### Recursive Descent Strategy\n\n**Recursive descent parsing** is the natural strategy for handling Lisp's nested structure. The algorithm uses the call stack to mirror the nesting structure of the S-expressions being parsed. Each level of nesting corresponds to a recursive function call, making the parser's structure match the data structure it's building.\n\n> **Decision: Recursive Descent Parser Architecture**\n> - **Context**: We need to parse arbitrarily nested S-expressions into tree structures\n> - **Options Considered**: Recursive descent, shift-reduce parser, parser combinator library\n> - **Decision**: Implement recursive descent parser with mutual recursion between expression and list parsing\n> - **Rationale**: Recursive descent naturally mirrors Lisp's recursive structure, is simple to implement and debug, and provides excellent error reporting with clear stack traces\n> - **Consequences**: Easy to extend with new syntax, but may hit stack limits on extremely deep nesting (acceptable for learning purposes)\n\n| Parsing Strategy | Implementation Complexity | Error Reporting Quality | Memory Usage | Extensibility |\n|------------------|---------------------------|-------------------------|--------------|---------------|\n| Recursive Descent | Low - mirrors data structure | Excellent - clear stack traces | High - uses call stack | Excellent - easy to add syntax |\n| Shift-Reduce | High - requires state tables | Good - but cryptic conflicts | Low - explicit stack | Moderate - table regeneration |\n| Parser Combinators | Moderate - library learning curve | Excellent - composable errors | Moderate - lazy evaluation | Excellent - highly composable |\n\nThe recursive descent strategy centers around two mutually recursive functions that mirror the two main structures in Lisp:\n\n1. **`read_expr`** - Reads a single complete expression from the token stream, dispatching based on the first token type\n2. **`read_list`** - Reads a parenthesized list by repeatedly calling `read_expr` until the closing parenthesis\n\nThe parsing algorithm follows these steps:\n\n1. **Token Stream Positioning**: The parser maintains a current position in the token stream, advancing as tokens are consumed\n2. **Expression Type Dispatch**: `read_expr` examines the current token type to determine what kind of expression to parse\n3. **Atomic Expression Handling**: For atoms (numbers, symbols, strings), create the appropriate `LispValue` and advance position\n4. **List Expression Delegation**: For left parentheses, delegate to `read_list` to handle the nested structure\n5. **Quote Syntax Transformation**: For quote marks, transform into canonical `(quote expr)` form\n6. **Recursive List Assembly**: `read_list` repeatedly calls `read_expr` to collect list elements until finding the closing parenthesis\n7. **Position Management**: Each parsing function returns both the parsed value and the new token stream position\n8. **Error Boundary Detection**: Invalid token sequences trigger `ParseError` exceptions with position information\n\n> The critical insight is that **each recursive call handles exactly one level of nesting**. The call stack automatically tracks which lists are currently being assembled, eliminating the need for explicit stack management.\n\nHere's the detailed parsing algorithm:\n\n**`read_expr` Algorithm:**\n1. Check if current position is beyond token stream bounds—if so, raise EOF error\n2. Examine the token type at current position to determine expression kind\n3. For `TokenType.NUMBER`: Convert token value to numeric `LispValue`, advance position, return result\n4. For `TokenType.SYMBOL`: Create symbol `LispValue` with token value, advance position, return result  \n5. For `TokenType.STRING`: Create string `LispValue` with unescaped token value, advance position, return result\n6. For `TokenType.LEFT_PAREN`: Delegate to `read_list` to parse parenthesized expression\n7. For `TokenType.QUOTE`: Parse quoted expression by recursively calling `read_expr` and wrapping result in `(quote ...)` form\n8. For `TokenType.RIGHT_PAREN`: Raise error about unmatched closing parenthesis\n9. For any other token type: Raise error about unexpected token\n\n**`read_list` Algorithm:**\n1. Verify current token is `TokenType.LEFT_PAREN`, advance position past opening parenthesis\n2. Initialize empty list to collect parsed elements\n3. Enter parsing loop: while current token is not `TokenType.RIGHT_PAREN` and not at EOF:\n   a. Call `read_expr` recursively to parse next list element\n   b. Add parsed element to the growing list\n   c. Update position to continue after parsed element\n4. Check that loop terminated due to `TokenType.RIGHT_PAREN` (not EOF)—if EOF, raise unmatched parentheses error\n5. Advance position past closing parenthesis\n6. Create list `LispValue` containing all collected elements and return with updated position\n\nThe parser maintains **position threading**—each parsing function receives a token stream position and returns both its result and the updated position after consuming tokens. This functional approach prevents position management bugs and makes the parser easier to test and debug.\n\n| Function | Input | Output | Responsibility | Error Conditions |\n|----------|-------|--------|----------------|------------------|\n| `read_expr` | tokens, position | (LispValue, new_position) | Parse single expression | EOF, unexpected token, unmatched `)` |\n| `read_list` | tokens, position | (LispValue, new_position) | Parse parenthesized list | EOF before `)`, nested parse errors |\n\n### Quote Syntax Transformation\n\nLisp's **quote syntax** provides a shorthand for preventing evaluation—`'expr` is equivalent to `(quote expr)`. The parser must recognize this syntax and transform it into the canonical form during parsing, not evaluation. This transformation happens in the parser because it's purely syntactic sugar that doesn't change the semantic meaning of the code.\n\n> **Decision: Parse-Time Quote Transformation**\n> - **Context**: Lisp provides `'expr` shorthand for `(quote expr)` that must be handled somewhere in the pipeline\n> - **Options Considered**: Transform during tokenization, transform during parsing, handle during evaluation\n> - **Decision**: Transform quote syntax during parsing phase\n> - **Rationale**: Quotes are syntactic sugar that should be normalized before evaluation; parsing is responsible for syntax tree construction; keeps tokenizer simple and focused on boundary detection\n> - **Consequences**: Parser complexity increases slightly, but evaluator remains clean and doesn't need special quote token handling\n\n| Transformation Stage | Complexity Impact | Semantic Clarity | Component Responsibility Alignment |\n|---------------------|-------------------|------------------|------------------------------------|\n| **Tokenization** | High - tokenizer must track context | Poor - quotes mixed with atoms | Poor - syntax transformation in wrong phase |\n| **Parsing** ✓ | Low - single transformation rule | Excellent - canonical form before evaluation | Excellent - syntax handling in syntax phase |\n| **Evaluation** | Moderate - special case in evaluator | Good - but mixes syntax and semantics | Poor - evaluation handling syntax |\n\nThe quote transformation algorithm works as follows:\n\n**Quote Transformation Steps:**\n1. **Quote Token Detection**: When `read_expr` encounters `TokenType.QUOTE`, it recognizes this as shorthand syntax\n2. **Position Advancement**: Move past the quote token to access the expression being quoted\n3. **Recursive Expression Parsing**: Call `read_expr` recursively to parse the expression immediately following the quote\n4. **Canonical Form Construction**: Create a list `LispValue` with two elements: a symbol `LispValue` containing \"quote\" and the parsed expression\n5. **Position Threading**: Return both the constructed quote form and the position after the quoted expression\n\nThis transformation ensures that by the time expressions reach the evaluator, all quote syntax has been normalized into the standard `(quote expr)` form. The evaluator only needs to handle the canonical form, simplifying its implementation.\n\n**Example Transformations:**\n\n| Input Syntax | Token Sequence | Transformed AST | Equivalent Canonical Form |\n|--------------|----------------|-----------------|---------------------------|\n| `'42` | `[QUOTE, NUMBER(\"42\")]` | `make_list([make_symbol(\"quote\"), make_number(42)])` | `(quote 42)` |\n| `'foo` | `[QUOTE, SYMBOL(\"foo\")]` | `make_list([make_symbol(\"quote\"), make_symbol(\"foo\")])` | `(quote foo)` |\n| `'(a b c)` | `[QUOTE, LEFT_PAREN, SYMBOL(\"a\"), ...]` | `make_list([make_symbol(\"quote\"), make_list([...])])` | `(quote (a b c))` |\n| `''x` | `[QUOTE, QUOTE, SYMBOL(\"x\")]` | `make_list([make_symbol(\"quote\"), make_list([make_symbol(\"quote\"), make_symbol(\"x\")])])` | `(quote (quote x))` |\n\nThe transformation handles nested quotes correctly—`''x` becomes `(quote (quote x))` because each quote token triggers its own transformation, and the outer quote processes the result of the inner quote transformation.\n\n> Quote transformation must happen **before** the expression enters the evaluator because `'(+ 1 2)` should evaluate to the list `(+ 1 2)`, not to `3`. The evaluator sees `(quote (+ 1 2))` and knows to return the second element without evaluating it.\n\n### Common Parser Pitfalls\n\nUnderstanding the common mistakes helps build a robust parser that handles edge cases gracefully. These pitfalls frequently trap learners because they involve subtle interactions between tokenization, parsing, and error handling.\n\n⚠️ **Pitfall: Unbalanced Parentheses Detection**\n\nMany learners implement parsers that crash with stack overflow or array bounds errors when parentheses don't match, instead of producing clear error messages.\n\n**The Problem**: When `read_list` encounters EOF while looking for a closing parenthesis, naive implementations either crash trying to access tokens beyond the array bounds or return incomplete data structures.\n\n**Why It's Wrong**: Users need clear error messages that pinpoint the location of unmatched parentheses. A stack overflow or \"index out of bounds\" exception provides no useful information for fixing the syntax error.\n\n**The Fix**: Before accessing tokens by index, always check bounds. When `read_list` reaches EOF without finding `TokenType.RIGHT_PAREN`, raise a `ParseError` with a message like \"Unmatched opening parenthesis at position X\" and include the position of the opening parenthesis.\n\n⚠️ **Pitfall: Position Management Bugs**\n\nBeginners often update the token stream position inconsistently, leading to tokens being skipped or processed twice.\n\n**The Problem**: Forgetting to thread position updates through recursive calls, or updating position in multiple places, causes the parser to get \"lost\" in the token stream.\n\n**Why It's Wrong**: Position bugs manifest as mysterious parsing failures where the parser sees the wrong tokens or reports errors at incorrect locations. These bugs are extremely difficult to debug without careful position tracking.\n\n**The Fix**: Use **functional position threading**—every parsing function receives a position parameter and returns a new position. Never mutate a global position variable. Always use the position returned by recursive calls for subsequent operations.\n\n⚠️ **Pitfall: EOF Handling Inconsistency**\n\nInconsistent EOF checking leads to crashes or incorrect parsing when input ends unexpectedly.\n\n**The Problem**: Some parsing functions check for EOF properly while others assume tokens are always available, creating inconsistent error handling behavior.\n\n**Why It's Wrong**: Real-world input often ends abruptly or contains incomplete expressions. The parser must handle EOF gracefully at every point where it accesses tokens.\n\n**The Fix**: Create a helper function `is_at_end(tokens, position)` and call it before every token access. Define clear EOF semantics—what constitutes a complete vs. incomplete expression—and enforce them consistently.\n\n⚠️ **Pitfall: Error Recovery Absence**\n\nParsers that stop at the first error provide poor user experience and make debugging difficult.\n\n**The Problem**: When the parser encounters an error, it immediately raises an exception without attempting to parse the rest of the input or provide context about nearby valid syntax.\n\n**Why It's Wrong**: Users often have multiple syntax errors in their code. Stopping at the first error forces a slow fix-one-test-again cycle. Additionally, early termination provides no context about what the parser expected to find.\n\n**The Fix**: Implement **panic mode recovery**—when an error occurs, skip tokens until reaching a likely recovery point (like the next top-level expression) and continue parsing. Report all errors found, not just the first one.\n\n⚠️ **Pitfall: Quote Handling in Error Cases**\n\nForgetting that quotes consume two tokens (the quote mark and the following expression) leads to position management errors in error scenarios.\n\n**The Problem**: When a quote token appears at EOF or is followed by an invalid token, the error handling code doesn't account for the two-token nature of quote syntax.\n\n**Why It's Wrong**: Error messages report incorrect positions, and position recovery after quote-related errors may cause subsequent valid syntax to be misparsed.\n\n**The Fix**: In quote handling code, always check that a parseable expression follows the quote token before attempting to parse it. If EOF or an invalid token follows a quote, report \"Incomplete quote syntax\" rather than letting the recursive `read_expr` call fail with a generic error.\n\n⚠️ **Pitfall: Deep Nesting Stack Overflow**\n\nRecursive descent parsers can exhaust the call stack on deeply nested input, causing crashes instead of graceful error handling.\n\n**The Problem**: Input like `(((((...))))` with hundreds of nesting levels causes each level to add a stack frame, eventually overflowing the call stack.\n\n**Why It's Wrong**: Stack overflow crashes are abrupt and provide no information about the nesting depth or location of the problem. Users can't easily determine how to fix their code.\n\n**The Fix**: Implement **nesting depth limiting**—track recursion depth and raise a `ParseError` when it exceeds a reasonable limit (e.g., 1000 levels). This provides a clear error message and prevents crashes.\n\n| Pitfall | Symptom | Root Cause | Detection Strategy | Fix Approach |\n|---------|---------|------------|-------------------|---------------|\n| Unbalanced Parentheses | Crashes or wrong results | Missing bounds checks | Test with `(((` input | Check EOF before token access |\n| Position Threading | Tokens skipped/repeated | Inconsistent position updates | Test complex nested expressions | Functional position passing |\n| EOF Handling | Crashes on incomplete input | Inconsistent EOF checks | Test input ending mid-expression | Consistent `is_at_end()` checks |\n| Error Recovery | Single error reported | Early termination | Test multiple syntax errors | Panic mode recovery |\n| Quote Error Handling | Wrong error positions | Two-token quote nature ignored | Test `'` at EOF | Validate quote completeness |\n| Stack Overflow | Crash on deep nesting | Unbounded recursion | Test deeply nested input | Depth limiting with clear errors |\n\n### Implementation Guidance\n\nThe parser implementation requires careful coordination between token stream management, recursive descent logic, and error handling. The following guidance provides both complete infrastructure code and detailed skeletons for the core parsing logic.\n\n**A. Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Token Stream Access | List indexing with bounds checks | Iterator pattern with lookahead buffer |\n| Error Collection | Exception-based with single error | Error accumulation with multiple errors |\n| Position Tracking | Integer index threading | Position object with line/column info |\n| AST Construction | Direct `LispValue` creation | AST builder pattern with validation |\n\n**B. Recommended File Structure**\n\n```\nsrc/\n  lisp_interpreter/\n    __init__.py              ← main module exports\n    tokenizer.py             ← tokenizer from previous section\n    parser.py                ← this component\n    evaluator.py             ← next component\n    data_model.py            ← LispValue, Token definitions\n    errors.py                ← error type hierarchy\n  tests/\n    test_parser.py           ← parser unit tests\n    test_integration.py      ← end-to-end parsing tests\n```\n\n**C. Complete Infrastructure Code**\n\nHere's the complete error handling and position management infrastructure:\n\n```python\n# errors.py - Complete error hierarchy for parser\nfrom typing import Optional\n\nclass LispError(Exception):\n    \"\"\"Base class for all Lisp interpreter errors.\"\"\"\n    def __init__(self, message: str, source_location: Optional[int] = None):\n        self.message = message\n        self.source_location = source_location\n        super().__init__(message)\n\nclass ParseError(LispError):\n    \"\"\"Raised when parsing fails due to invalid syntax.\"\"\"\n    def __init__(self, message: str, position: int, token_value: Optional[str] = None):\n        self.position = position\n        self.token_value = token_value\n        location_info = f\" at position {position}\"\n        if token_value:\n            location_info += f\" (near '{token_value}')\"\n        super().__init__(message + location_info, position)\n\n# Position management utilities - complete implementation\ndef is_at_end(tokens, position):\n    \"\"\"Check if position is at or beyond end of token stream.\"\"\"\n    return position >= len(tokens) or tokens[position].type == TokenType.EOF\n\ndef current_token(tokens, position):\n    \"\"\"Get current token, ensuring bounds safety.\"\"\"\n    if is_at_end(tokens, position):\n        # Return synthetic EOF token if past end\n        return Token(type=TokenType.EOF, value=\"\", position=position)\n    return tokens[position]\n\ndef peek_token(tokens, position, offset=1):\n    \"\"\"Look ahead at token without advancing position.\"\"\"\n    peek_pos = position + offset\n    return current_token(tokens, peek_pos)\n\ndef expect_token(tokens, position, expected_type):\n    \"\"\"Verify current token matches expected type, advance if so.\"\"\"\n    token = current_token(tokens, position)\n    if token.type != expected_type:\n        raise ParseError(\n            f\"Expected {expected_type}, got {token.type}\",\n            position,\n            token.value\n        )\n    return position + 1\n\n# Quote syntax constants\nQUOTE_SYMBOL = \"quote\"\n```\n\n**D. Core Parser Skeleton Code**\n\n```python\n# parser.py - Core parsing logic for learner implementation\nfrom typing import Tuple, List\nfrom .data_model import LispValue, Token, TokenType, make_symbol, make_number, make_list\nfrom .errors import ParseError, is_at_end, current_token, expect_token\n\nclass Parser:\n    \"\"\"Recursive descent parser for Lisp S-expressions.\"\"\"\n    \n    def __init__(self, max_nesting_depth: int = 1000):\n        self.max_nesting_depth = max_nesting_depth\n    \n    def parse(self, tokens: List[Token]) -> LispValue:\n        \"\"\"Parse complete expression from token stream.\n        \n        Args:\n            tokens: List of tokens from tokenizer\n            \n        Returns:\n            LispValue representing parsed S-expression\n            \n        Raises:\n            ParseError: If syntax is invalid or tokens malformed\n        \"\"\"\n        if not tokens or tokens[0].type == TokenType.EOF:\n            raise ParseError(\"Empty input - no expression to parse\", 0)\n        \n        expr, final_position = self.read_expr(tokens, 0, depth=0)\n        \n        # TODO 1: Check if there are unparsed tokens after the main expression\n        # TODO 2: If so, raise ParseError about unexpected tokens after expression\n        # Hint: Use is_at_end() to check if all tokens consumed\n        \n        return expr\n    \n    def read_expr(self, tokens: List[Token], position: int, depth: int) -> Tuple[LispValue, int]:\n        \"\"\"Read single expression from token stream starting at position.\n        \n        Args:\n            tokens: Token stream to parse from\n            position: Current position in token stream\n            depth: Current nesting depth for overflow protection\n            \n        Returns:\n            Tuple of (parsed_expression, new_position_after_expression)\n            \n        Raises:\n            ParseError: If expression is malformed or nesting too deep\n        \"\"\"\n        # TODO 1: Check if depth exceeds max_nesting_depth, raise ParseError if so\n        # TODO 2: Check if at end of tokens, raise ParseError about unexpected EOF\n        # TODO 3: Get current token using current_token() helper\n        # TODO 4: Dispatch based on token type:\n        #   - TokenType.NUMBER: convert to number LispValue, advance position\n        #   - TokenType.SYMBOL: create symbol LispValue, advance position  \n        #   - TokenType.STRING: create string LispValue, advance position\n        #   - TokenType.LEFT_PAREN: delegate to read_list()\n        #   - TokenType.QUOTE: handle quote transformation (see read_quote_expr)\n        #   - TokenType.RIGHT_PAREN: raise ParseError about unmatched parenthesis\n        #   - other types: raise ParseError about unexpected token\n        # TODO 5: Return tuple of (created_value, updated_position)\n        # Hint: Use make_number(), make_symbol(), make_list() from data_model\n        pass\n    \n    def read_list(self, tokens: List[Token], position: int, depth: int) -> Tuple[LispValue, int]:\n        \"\"\"Read parenthesized list expression from token stream.\n        \n        Args:\n            tokens: Token stream to parse from\n            position: Position of LEFT_PAREN token\n            depth: Current nesting depth\n            \n        Returns:\n            Tuple of (list_value, position_after_closing_paren)\n            \n        Raises:\n            ParseError: If list is malformed or not properly closed\n        \"\"\"\n        # TODO 1: Verify current token is LEFT_PAREN using current_token()\n        # TODO 2: Advance position past opening parenthesis\n        # TODO 3: Initialize empty list to collect elements\n        # TODO 4: Loop while not at RIGHT_PAREN and not at EOF:\n        #   a. Call read_expr() recursively to parse next element\n        #   b. Add parsed element to collection list\n        #   c. Update position to continue after parsed element\n        # TODO 5: Check loop terminated due to RIGHT_PAREN, not EOF\n        # TODO 6: If EOF reached, raise ParseError about unmatched opening parenthesis\n        # TODO 7: Advance position past closing RIGHT_PAREN\n        # TODO 8: Create list LispValue from collected elements using make_list()\n        # TODO 9: Return tuple of (list_value, final_position)\n        # Hint: Track opening_paren_position for better error messages\n        pass\n    \n    def read_quote_expr(self, tokens: List[Token], position: int, depth: int) -> Tuple[LispValue, int]:\n        \"\"\"Handle quote syntax transformation from 'expr to (quote expr).\n        \n        Args:\n            tokens: Token stream to parse from  \n            position: Position of QUOTE token\n            depth: Current nesting depth\n            \n        Returns:\n            Tuple of (quote_list_value, position_after_quoted_expr)\n            \n        Raises:\n            ParseError: If quote is incomplete or malformed\n        \"\"\"\n        # TODO 1: Verify current token is QUOTE using current_token()\n        # TODO 2: Advance position past quote token\n        # TODO 3: Check if at EOF - if so, raise ParseError about incomplete quote\n        # TODO 4: Call read_expr() recursively to parse quoted expression\n        # TODO 5: Create symbol LispValue for \"quote\" using make_symbol()\n        # TODO 6: Create list LispValue containing quote symbol and quoted expr using make_list()\n        # TODO 7: Return tuple of (quote_list, position_after_quoted_expr)\n        # Hint: The result should be equivalent to parsing (quote <expr>)\n        pass\n\n# Helper function for creating parser instance\ndef parse(tokens: List[Token]) -> LispValue:\n    \"\"\"Convenience function for parsing tokens into AST.\n    \n    Args:\n        tokens: Output from tokenizer\n        \n    Returns:\n        LispValue representing the parsed expression\n    \"\"\"\n    parser = Parser()\n    return parser.parse(tokens)\n```\n\n**E. Language-Specific Hints**\n\n- **Exception Handling**: Use `try`/`except` blocks to catch recursive parsing errors and add context about the current parsing location\n- **List Construction**: Python lists work well for collecting parsed elements before creating the final `LispValue`\n- **String Handling**: When parsing string tokens, remember to unescape any escape sequences that were preserved during tokenization\n- **Type Checking**: Use `isinstance()` to verify token types if not using enums, or direct equality comparison with enum values\n- **Debugging**: Add optional debug logging that shows the current token and depth at each parsing step\n\n**F. Milestone Checkpoint**\n\nAfter implementing the parser, verify these behaviors:\n\n**Test Commands:**\n```bash\npython -m pytest tests/test_parser.py -v\npython -c \"from lisp_interpreter import tokenize, parse; print(parse(tokenize('(+ 1 2)')))\"\n```\n\n**Expected Outputs:**\n- Simple atom: `42` → `LispValue(value=42, type=LispValueType.NUMBER)`\n- Simple list: `(+ 1 2)` → `LispValue(value=[symbol('+'), number(1), number(2)], type=LispValueType.LIST)`\n- Quote syntax: `'foo` → `LispValue(value=[symbol('quote'), symbol('foo')], type=LispValueType.LIST)`\n- Nested lists: `(a (b c))` → Properly nested list structure\n\n**Manual Verification:**\n1. Parse valid S-expressions and inspect the resulting data structure\n2. Try malformed input like `(((` and verify you get clear error messages, not crashes\n3. Test quote syntax with `'(a b c)` and verify it becomes `(quote (a b c))`\n4. Test deeply nested expressions to ensure depth limiting works\n\n**Signs of Problems:**\n- **\"Index out of range\" errors**: Position threading is broken—check that all recursive calls properly thread position updates\n- **Wrong number of list elements**: Quote handling isn't advancing position correctly—ensure quote processing consumes exactly two tokens\n- **Stack overflow on nested input**: Depth limiting not implemented—add nesting depth checks in `read_expr`\n- **Malformed AST structures**: Make sure each parsing function creates the correct `LispValue` type and structure\n\n\n## Evaluator Design\n\n> **Milestone(s):** Milestones 2-4 (Basic Evaluation, Variables and Functions, List Operations & Recursion) - the evaluator is the final stage of the three-part pipeline that implements Lisp semantics and brings the parsed code to life\n\nThe evaluator is the heart of our Lisp interpreter - where the parsed abstract syntax tree transforms into actual computation. While the tokenizer and parser handle the mechanical aspects of breaking down and structuring text, the evaluator implements the semantic rules that make Lisp a functioning programming language. It must correctly handle arithmetic, conditionals, variable binding, function creation and application, lexical scoping, and recursive computation.\n\n### Mental Model: Universal Calculator with Memory\n\nThink of the evaluator as an extraordinarily sophisticated calculator that has evolved beyond simple arithmetic. A basic calculator takes expressions like \"2 + 3\" and produces results. Our Lisp evaluator does the same thing, but with three crucial enhancements that transform it from a simple calculator into a universal computing engine.\n\nFirst, it has **perfect memory** - when you define a variable with `(define x 10)`, the evaluator remembers that `x` means `10` in all future calculations. Unlike a calculator that forgets everything when you turn it off, the evaluator maintains a persistent memory of all the names and values you've defined.\n\nSecond, it can **learn new operations** - when you create a function with `(lambda (x y) (+ (* x x) (* y y)))`, you're teaching the evaluator a new operation (calculating the sum of squares). From that point on, the evaluator can perform this new operation just as easily as basic arithmetic. It's like giving a calculator the ability to learn and remember new mathematical functions.\n\nThird, it has **contextual awareness** - the evaluator understands that the same name might mean different things in different contexts. When a function defines parameters, those names create a local context where they have specific meanings, separate from any global definitions. This is like having a calculator that can temporarily redefine what the variable \"x\" means while solving a particular problem.\n\nThe beauty of this mental model is that it scales from simple arithmetic `(+ 2 3)` all the way up to complex recursive functions. Whether evaluating a number, looking up a variable, or applying a function, the evaluator follows the same basic pattern: examine the expression, determine what kind of computation it represents, and produce the appropriate result using its memory and learned operations.\n\n### Core Evaluation Rules\n\nThe evaluator implements a small set of fundamental rules that, when combined, create the full power of Lisp computation. These rules form a hierarchy based on the type of expression being evaluated, with each rule handling a specific category of Lisp syntax.\n\n**Self-Evaluating Expressions** form the base case of evaluation. Numbers like `42` or `3.14` evaluate to themselves - they represent literal values that need no further computation. This seems trivial, but it's crucial because it provides the foundation for all other computation. Without self-evaluating atoms, we'd have no way to introduce concrete values into our computations.\n\n**Symbol Lookup** handles variable references. When the evaluator encounters a symbol like `x` or `factorial`, it searches through the environment chain to find what value that name represents. This rule transforms names into values, enabling the memory aspect of our universal calculator. The lookup process starts in the current environment and walks up the parent chain until it finds a binding or reaches the global environment.\n\n**List Evaluation** handles the most complex case - parenthesized expressions that represent either function calls or special forms. The evaluator must first examine the first element of the list to determine how to proceed. If the first element is a symbol that names a special form like `if` or `define`, the evaluator follows special form rules. Otherwise, it treats the expression as a function call.\n\n**Function Application** represents the general case of computation. The evaluator first evaluates all elements of the list: the function position (first element) should evaluate to a function, and the remaining elements become the arguments. Once all arguments are evaluated, the evaluator applies the function to the arguments in a new environment that binds the function's parameters to the argument values.\n\n**Special Form Handling** provides the control structures and binding mechanisms that make Lisp powerful. Unlike function calls, special forms control when and how their arguments are evaluated. The `if` special form evaluates its test expression, then evaluates either the consequent or alternative based on the result. The `define` form evaluates its value expression and creates a binding in the current environment. The `lambda` form creates a new function without evaluating its body.\n\n| Expression Type | Evaluation Rule | Environment Usage | Example |\n|---|---|---|---|\n| Number | Return the numeric value unchanged | None | `42` → `42` |\n| String | Return the string value unchanged | None | `\"hello\"` → `\"hello\"` |\n| Symbol | Look up binding in environment chain | Read from environment | `x` → value bound to `x` |\n| Empty List | Return empty list unchanged | None | `()` → `()` |\n| List (special form) | Follow special form rules | Varies by form | `(if test a b)` |\n| List (function call) | Evaluate function and args, then apply | Function creates new scope | `(+ 1 2)` |\n\nThe evaluation process follows a recursive structure that mirrors the nested structure of Lisp expressions. When evaluating a complex expression like `(+ (* 2 3) (- 10 4))`, the evaluator recursively evaluates the subexpressions `(* 2 3)` and `(- 10 4)` before applying the addition function to their results. This recursive approach naturally handles arbitrarily nested expressions without requiring special case logic for different levels of nesting.\n\n> **Key Insight**: The recursive nature of evaluation mirrors the recursive structure of Lisp syntax. Every compound expression breaks down into simpler expressions until we reach atoms, which evaluate to themselves or look up to values.\n\n**Environment Threading** ensures that variable bindings flow correctly through the evaluation process. Every evaluation operation takes an environment parameter and either uses it unchanged (for atoms and simple lookups) or creates modified environments (for function calls and special forms that introduce bindings). This threading pattern ensures that each expression evaluates in the correct lexical context.\n\n**Error Propagation** handles cases where evaluation cannot proceed normally. When a symbol has no binding, when a function is called with wrong number of arguments, or when a non-function appears in function position, the evaluator must generate appropriate error messages and halt evaluation. These errors must include enough context to help the programmer identify and fix the problem.\n\n### Special Forms vs Function Calls\n\nUnderstanding the distinction between special forms and function calls is crucial to implementing a correct Lisp evaluator. This distinction affects when arguments are evaluated, how control flows through the program, and what kinds of language constructs are possible to implement.\n\n**Function calls** follow a predictable evaluation pattern: evaluate the function expression, evaluate all argument expressions, then apply the function to the argument values. This eager evaluation strategy means that all arguments are computed before the function sees them. For example, in `(+ (* 2 3) (- 10 4))`, both multiplication and subtraction execute before the addition function receives the values `6` and `6`.\n\n**Special forms** break this pattern by controlling when and whether their arguments are evaluated. The `if` special form evaluates its test expression first, then evaluates either the consequent or alternative - but never both. The `define` form evaluates its value expression but never evaluates the symbol being bound. The `lambda` form never evaluates its body expression during function creation - the body only gets evaluated later when the function is called.\n\n> **Decision: Special Form Implementation Strategy**\n> - **Context**: We need to distinguish special forms from regular functions during evaluation, but both appear as lists starting with symbols\n> - **Options Considered**: 1) Mark special forms with metadata during parsing, 2) Check symbol names during evaluation, 3) Pre-populate environment with special form markers\n> - **Decision**: Check symbol names during evaluation using `is_special_form()` predicate\n> - **Rationale**: This approach keeps parsing simple and avoids complex metadata systems while making the evaluation logic explicit\n> - **Consequences**: Slight performance cost from string comparisons, but clearer separation between parsing and evaluation phases\n\n| Aspect | Function Calls | Special Forms |\n|---|---|---|\n| Argument Evaluation | All arguments evaluated before application | Controlled evaluation - some args may not be evaluated |\n| Implementation | User-defined or built-in functions | Hard-coded in evaluator |\n| Extensibility | Unlimited - users can define new functions | Fixed set defined by language |\n| Examples | `(+ 1 2)`, `(factorial 5)` | `(if test a b)`, `(define x 10)` |\n\n**Conditional Evaluation** exemplifies why special forms matter. Consider `(if (> x 0) (/ 10 x) 0)`. If `if` were a regular function, both `(/ 10 x)` and `0` would be evaluated before `if` could make its decision. When `x` is zero, this would cause a division by zero error even though the conditional logic should prevent it. By making `if` a special form that only evaluates the chosen branch, we avoid this problem.\n\n**Binding and Scope** require special forms because they affect the evaluation environment rather than just computing values. The `define` form must bind a symbol to a value in the current environment - this is a side effect that changes how future expressions evaluate. A regular function cannot modify the environment in which it was called, so `define` must be implemented as a special form in the evaluator itself.\n\n**Short-Circuit Logic** in forms like `and` and `or` requires special form treatment. The expression `(and (valid-input? x) (process x))` should not call `process` if the input is invalid. Regular function evaluation would call both functions and combine their results, but the special form can stop evaluation as soon as one operand determines the final result.\n\n**Macro Expansion** (though not implemented in our minimal Lisp) represents the ultimate special form - code that transforms other code before evaluation. This demonstrates why the special form mechanism is fundamental to Lisp's power, even though our implementation focuses on the essential special forms needed for basic computation.\n\nThe evaluator handles this distinction through a dispatch mechanism that examines the first element of each list expression. If it's a symbol that names a special form, the evaluator calls the appropriate special form handler. Otherwise, it proceeds with normal function call evaluation.\n\n| Special Form | Argument Evaluation Pattern | Purpose | Example |\n|---|---|---|---|\n| `if` | Test expression only, then chosen branch | Conditional execution | `(if (> x 0) x (- x))` |\n| `define` | Value expression only, symbol stays unevaluated | Variable binding | `(define pi 3.14159)` |\n| `lambda` | Parameters and body stay unevaluated | Function creation | `(lambda (x) (* x x))` |\n| `quote` | No arguments evaluated | Literal data | `(quote (a b c))` |\n| `let` | Value expressions evaluated, variables stay unevaluated | Local bindings | `(let ((x 5)) (* x x))` |\n\n### Common Evaluator Pitfalls\n\nBuilding an evaluator involves subtle decisions about evaluation order, environment management, and error handling. These pitfalls represent the most frequent mistakes that cause evaluators to behave incorrectly or inconsistently.\n\n⚠️ **Pitfall: Evaluating Special Form Arguments**\n\nThe most common mistake is treating special forms like regular functions and evaluating all their arguments before processing them. New implementers often write code like this:\n\n```python\n# WRONG - evaluates all arguments first\ndef evaluate_if(args, env):\n    test_value = evaluate(args[0], env)\n    consequent_value = evaluate(args[1], env)  # BUG: always evaluates\n    alternative_value = evaluate(args[2], env)  # BUG: always evaluates\n    return consequent_value if is_truthy(test_value) else alternative_value\n```\n\nThis breaks the fundamental semantics of conditional execution. The correct implementation only evaluates the chosen branch:\n\n```python\n# CORRECT - only evaluates chosen branch\ndef evaluate_if(args, env):\n    test_value = evaluate(args[0], env)\n    if is_truthy(test_value):\n        return evaluate(args[1], env)\n    else:\n        return evaluate(args[2], env)\n```\n\nThe symptom is that expressions like `(if false (error \"boom\") 42)` crash instead of returning `42`. Always evaluate special form arguments conditionally based on the form's semantics.\n\n⚠️ **Pitfall: Function vs Special Form Confusion**\n\nAnother frequent error is implementing language constructs as functions when they should be special forms, or vice versa. For example, implementing `and` as a regular function:\n\n```python\n# WRONG - and should be a special form for short-circuiting\ndef builtin_and(args):\n    return all(is_truthy(arg) for arg in args)  # all args already evaluated!\n```\n\nThis breaks short-circuit evaluation. The expression `(and (safe-check) (risky-operation))` will always call both functions, even if `safe-check` returns false. The correct implementation makes `and` a special form that can stop evaluation early.\n\n⚠️ **Pitfall: Environment Mutation vs Extension**\n\nA subtle but critical error involves modifying environments incorrectly. Some implementations mutate the global environment when they should create new local environments:\n\n```python\n# WRONG - modifies the global environment\ndef apply_function(func, args, env):\n    for param, arg in zip(func.parameters, args):\n        env.bindings[param] = arg  # BUG: pollutes caller's environment\n    return evaluate(func.body, env)\n```\n\nThis causes variables defined in function calls to leak into the calling scope. The correct approach creates a new environment that extends the function's closure environment:\n\n```python\n# CORRECT - creates new environment for function\ndef apply_function(func, args, env):\n    new_env = func.closure_env.extend()\n    for param, arg in zip(func.parameters, args):\n        new_env.define(param, arg)\n    return evaluate(func.body, new_env)\n```\n\n⚠️ **Pitfall: Recursive Function Name Binding**\n\nWhen implementing recursive functions, a common mistake is not making the function name available in its own body:\n\n```python\n# WRONG - function cannot call itself\ndef evaluate_define(name, value, env):\n    result = evaluate(value, env)  # function not yet bound\n    env.define(name, result)\n    return result\n```\n\nFor recursive functions defined with `(define factorial (lambda (n) ...))`, the lambda body cannot reference `factorial` because it's not bound until after the lambda is fully evaluated. The fix is to handle self-reference specially or use a two-phase binding approach.\n\n⚠️ **Pitfall: Arity Checking Inconsistency**\n\nMany implementations check function arity inconsistently between built-in functions and user-defined functions:\n\n```python\n# INCONSISTENT - built-ins don't check arity\ndef builtin_add(args):\n    return sum(args)  # accepts any number of arguments\n\ndef apply_function(func, args, env):\n    if len(args) != len(func.parameters):  # user functions strictly checked\n        raise ArityError(len(func.parameters), len(args), func.name)\n```\n\nThis creates confusing behavior where some functions are flexible about argument counts while others are strict. Decide on a consistent arity policy and apply it everywhere.\n\n⚠️ **Pitfall: Error Context Loss**\n\nPoor error handling loses the context needed for debugging:\n\n```python\n# BAD - generic error with no context\ndef lookup(name, env):\n    if name not in env.bindings:\n        raise NameError(\"undefined variable\")  # which variable?\n```\n\nBetter error handling preserves context:\n\n```python\n# BETTER - specific error with context\ndef lookup(name, env):\n    if name not in env.bindings:\n        raise NameError(f\"undefined variable '{name}' in {env.scope_description()}\")\n```\n\n⚠️ **Pitfall: Infinite Recursion in Evaluation**\n\nCareless handling of evaluation can create infinite loops:\n\n```python\n# DANGEROUS - can loop infinitely\ndef evaluate(expr, env):\n    if is_symbol(expr):\n        value = env.lookup(expr.name)\n        return evaluate(value, env)  # BUG: re-evaluates resolved values\n```\n\nThe problem is re-evaluating values that are already fully evaluated. Numbers, strings, and functions should not be re-evaluated when retrieved from the environment.\n\n| Pitfall Category | Common Mistake | Symptom | Fix |\n|---|---|---|---|\n| Special Forms | Evaluating all arguments | Conditional errors, performance issues | Conditional evaluation based on form semantics |\n| Environment | Mutating instead of extending | Variable leaking between scopes | Always create new environments for new scopes |\n| Function Application | Inconsistent arity checking | Confusing error behavior | Uniform arity checking policy |\n| Error Handling | Generic error messages | Hard-to-debug failures | Include specific context in all errors |\n| Recursion | Infinite evaluation loops | Stack overflow on simple expressions | Only evaluate unevaluated expressions |\n\n### Implementation Guidance\n\nThe evaluator implementation requires careful attention to the interaction between expression types, environment management, and function application. The following guidance provides a foundation for building a correct and extensible evaluator that handles all the language features required by our Lisp implementation.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|---|---|---|\n| Expression Dispatch | Dictionary mapping types to handlers | Visitor pattern with type-based dispatch |\n| Environment Storage | Dictionary with parent reference | Persistent data structure with structural sharing |\n| Error Handling | Exception hierarchy with context | Result types with error chaining |\n| Function Representation | Simple dataclass with fields | Tagged union with interface methods |\n\n**Recommended File Structure:**\n\n```\nproject-root/\n  src/\n    evaluator/\n      __init__.py           ← exports main evaluate() function\n      core.py               ← main evaluation dispatch logic\n      special_forms.py      ← handlers for if, define, lambda, etc.\n      builtins.py          ← arithmetic, comparison, list operations\n      environment.py        ← environment management (from previous section)\n      errors.py            ← evaluation-specific error types\n    tests/\n      test_evaluator.py    ← integration tests for full evaluation\n      test_special_forms.py ← unit tests for special form handlers\n      test_builtins.py     ← unit tests for built-in functions\n```\n\n**Core Evaluator Infrastructure (Complete):**\n\n```python\n# src/evaluator/errors.py - Complete error handling for evaluation\nfrom typing import Optional\nfrom ..data_model import LispError\n\nclass EvaluationError(LispError):\n    \"\"\"Base class for all evaluation errors.\"\"\"\n    pass\n\nclass NameError(EvaluationError):\n    \"\"\"Raised when a symbol is not bound in any environment.\"\"\"\n    def __init__(self, symbol_name: str, scope_info: str = \"\"):\n        self.symbol_name = symbol_name\n        self.scope_info = scope_info\n        super().__init__(f\"undefined variable '{symbol_name}'{scope_info}\")\n\nclass TypeError(EvaluationError):\n    \"\"\"Raised when an operation is applied to the wrong type.\"\"\"\n    def __init__(self, expected_type: str, actual_type: str, operation: str):\n        self.expected_type = expected_type\n        self.actual_type = actual_type\n        self.operation = operation\n        super().__init__(f\"{operation} expects {expected_type}, got {actual_type}\")\n\nclass ArityError(EvaluationError):\n    \"\"\"Raised when a function is called with wrong number of arguments.\"\"\"\n    def __init__(self, expected: int, actual: int, function_name: str):\n        self.expected = expected\n        self.actual = actual\n        self.function_name = function_name\n        super().__init__(\n            f\"{function_name} expects {expected} arguments, got {actual}\"\n        )\n\n# src/evaluator/builtins.py - Complete built-in function implementations\nfrom typing import List, Any\nfrom ..data_model import LispValue, make_number, make_symbol, make_list, is_number\nfrom .errors import ArityError, TypeError\n\ndef builtin_add(args: List[LispValue]) -> LispValue:\n    \"\"\"Addition operator: (+ num1 num2 ...)\"\"\"\n    if not args:\n        return make_number(0)\n    \n    result = 0\n    for i, arg in enumerate(args):\n        if not is_number(arg):\n            raise TypeError(\"number\", arg.type.name, f\"+ argument {i}\")\n        result += arg.value\n    \n    return make_number(result)\n\ndef builtin_subtract(args: List[LispValue]) -> LispValue:\n    \"\"\"Subtraction operator: (- num1 num2 ...)\"\"\"\n    if not args:\n        raise ArityError(1, 0, \"-\")\n    \n    if not is_number(args[0]):\n        raise TypeError(\"number\", args[0].type.name, \"- first argument\")\n    \n    if len(args) == 1:\n        return make_number(-args[0].value)\n    \n    result = args[0].value\n    for i, arg in enumerate(args[1:], 1):\n        if not is_number(arg):\n            raise TypeError(\"number\", arg.type.name, f\"- argument {i}\")\n        result -= arg.value\n    \n    return make_number(result)\n\ndef builtin_multiply(args: List[LispValue]) -> LispValue:\n    \"\"\"Multiplication operator: (* num1 num2 ...)\"\"\"\n    if not args:\n        return make_number(1)\n    \n    result = 1\n    for i, arg in enumerate(args):\n        if not is_number(arg):\n            raise TypeError(\"number\", arg.type.name, f\"* argument {i}\")\n        result *= arg.value\n    \n    return make_number(result)\n\ndef builtin_divide(args: List[LispValue]) -> LispValue:\n    \"\"\"Division operator: (/ num1 num2 ...)\"\"\"\n    if not args:\n        raise ArityError(1, 0, \"/\")\n    \n    if not is_number(args[0]):\n        raise TypeError(\"number\", args[0].type.name, \"/ first argument\")\n    \n    if len(args) == 1:\n        if args[0].value == 0:\n            raise EvaluationError(\"division by zero in (/ 0)\")\n        return make_number(1 / args[0].value)\n    \n    result = args[0].value\n    for i, arg in enumerate(args[1:], 1):\n        if not is_number(arg):\n            raise TypeError(\"number\", arg.type.name, f\"/ argument {i}\")\n        if arg.value == 0:\n            raise EvaluationError(f\"division by zero in / argument {i}\")\n        result /= arg.value\n    \n    return make_number(result)\n\ndef builtin_less_than(args: List[LispValue]) -> LispValue:\n    \"\"\"Less than comparison: (< num1 num2)\"\"\"\n    if len(args) != 2:\n        raise ArityError(2, len(args), \"<\")\n    \n    for i, arg in enumerate(args):\n        if not is_number(arg):\n            raise TypeError(\"number\", arg.type.name, f\"< argument {i}\")\n    \n    return LISP_TRUE if args[0].value < args[1].value else LISP_FALSE\n\n# Constants for Lisp truth values\nLISP_TRUE = make_symbol(\"true\")\nLISP_FALSE = make_symbol(\"false\")\n\ndef is_truthy(value: LispValue) -> bool:\n    \"\"\"Determine if a Lisp value is considered true.\"\"\"\n    return value is not LISP_FALSE and value.value is not None\n\n# Built-in function registry\nBUILTIN_FUNCTIONS = {\n    \"+\": builtin_add,\n    \"-\": builtin_subtract, \n    \"*\": builtin_multiply,\n    \"/\": builtin_divide,\n    \"<\": builtin_less_than,\n    # Add more built-ins as needed\n}\n\ndef create_global_environment():\n    \"\"\"Create the global environment with all built-in functions.\"\"\"\n    from .environment import Environment\n    from ..data_model import make_builtin\n    \n    global_env = Environment()\n    \n    for name, implementation in BUILTIN_FUNCTIONS.items():\n        builtin_func = make_builtin(implementation, name, None)\n        global_env.define(name, builtin_func)\n    \n    # Add built-in constants\n    global_env.define(\"true\", LISP_TRUE)\n    global_env.define(\"false\", LISP_FALSE)\n    \n    return global_env\n```\n\n**Core Evaluation Logic Skeleton:**\n\n```python\n# src/evaluator/core.py - Main evaluation dispatch logic\nfrom typing import Any\nfrom ..data_model import (\n    LispValue, LispValueType, Environment, \n    is_number, is_symbol, is_list, is_function\n)\nfrom .errors import EvaluationError, NameError, TypeError\nfrom .special_forms import SPECIAL_FORMS\nfrom .builtins import BUILTIN_FUNCTIONS, is_truthy\n\ndef evaluate(ast: LispValue, env: Environment) -> LispValue:\n    \"\"\"\n    Main evaluation function - dispatches based on expression type.\n    \n    This is the core of the interpreter that implements Lisp evaluation rules:\n    - Numbers and strings evaluate to themselves\n    - Symbols look up their bindings in the environment\n    - Lists are either special forms or function calls\n    \"\"\"\n    # TODO 1: Handle self-evaluating expressions (numbers, strings)\n    # Hint: Check ast.type and return ast unchanged for literals\n    \n    # TODO 2: Handle symbol lookup in environment\n    # Hint: Use env.lookup(ast.value) and handle NameError for unbound symbols\n    \n    # TODO 3: Handle empty list (should evaluate to itself)\n    # Hint: Check if list is empty and return unchanged\n    \n    # TODO 4: Handle special forms (if, define, lambda, etc.)\n    # Hint: Check if first element is a symbol naming a special form\n    # Use is_special_form(first_symbol) and dispatch to appropriate handler\n    \n    # TODO 5: Handle function calls (general case)\n    # Hint: Evaluate the function position and all arguments,\n    # then call apply_function with the results\n    \n    # TODO 6: Handle invalid expression types\n    # Hint: Raise EvaluationError for anything that doesn't match above cases\n\ndef apply_function(func: LispValue, args: List[LispValue], env: Environment) -> LispValue:\n    \"\"\"\n    Apply a function to its arguments.\n    \n    Handles both built-in functions and user-defined functions created by lambda.\n    Built-ins call their implementation directly, user functions create new\n    environments and evaluate their bodies.\n    \"\"\"\n    # TODO 1: Handle built-in functions\n    # Hint: Check func.type == LispValueType.BUILTIN\n    # Call func.implementation(args) and return result\n    \n    # TODO 2: Handle user-defined functions  \n    # Hint: Check func.type == LispValueType.FUNCTION\n    # Verify arity matches len(func.parameters) vs len(args)\n    \n    # TODO 3: Create new environment for function body\n    # Hint: Start with func.closure_env.extend()\n    # Bind each parameter to corresponding argument value\n    \n    # TODO 4: Evaluate function body in new environment\n    # Hint: return evaluate(func.body, new_env)\n    \n    # TODO 5: Handle non-function values in function position\n    # Hint: Raise TypeError if func is not a callable type\n\ndef is_special_form(symbol_name: str) -> bool:\n    \"\"\"Check if a symbol names a special form.\"\"\"\n    return symbol_name in SPECIAL_FORMS\n\n# src/evaluator/special_forms.py - Special form handler skeletons\nfrom typing import List\nfrom ..data_model import LispValue, Environment, make_function, EMPTY_LIST\nfrom .errors import EvaluationError, ArityError\n\ndef handle_if(args: List[LispValue], env: Environment) -> LispValue:\n    \"\"\"\n    Handle if special form: (if test consequent alternative)\n    \n    Evaluates test expression, then evaluates either consequent or \n    alternative based on whether test is truthy.\n    \"\"\"\n    # TODO 1: Check argument count (should be 2 or 3)\n    # Hint: if len(args) < 2 or len(args) > 3: raise ArityError\n    \n    # TODO 2: Evaluate test expression\n    # Hint: test_result = evaluate(args[0], env)\n    \n    # TODO 3: Choose and evaluate appropriate branch\n    # Hint: Use is_truthy(test_result) to decide\n    # If true, evaluate args[1]; if false, evaluate args[2] (or return false if no alternative)\n\ndef handle_define(args: List[LispValue], env: Environment) -> LispValue:\n    \"\"\"\n    Handle define special form: (define symbol value)\n    \n    Evaluates value expression and binds it to symbol in current environment.\n    \"\"\"\n    # TODO 1: Check argument count (should be exactly 2)\n    \n    # TODO 2: Verify first argument is a symbol\n    # Hint: Check args[0].type == LispValueType.SYMBOL\n    \n    # TODO 3: Evaluate the value expression\n    # Hint: value = evaluate(args[1], env)\n    \n    # TODO 4: Create binding in current environment\n    # Hint: env.define(args[0].value, value)\n    \n    # TODO 5: Return the bound value\n\ndef handle_lambda(args: List[LispValue], env: Environment) -> LispValue:\n    \"\"\"\n    Handle lambda special form: (lambda (param1 param2 ...) body)\n    \n    Creates a function that captures the current environment as its closure.\n    \"\"\"\n    # TODO 1: Check argument count (should be exactly 2)\n    \n    # TODO 2: Extract and validate parameter list\n    # Hint: params = args[0], check that it's a list of symbols\n    \n    # TODO 3: Extract body expression (not evaluated yet!)\n    # Hint: body = args[1]\n    \n    # TODO 4: Convert parameter list to list of strings\n    # Hint: param_names = [param.value for param in params.value]\n    \n    # TODO 5: Create and return function object\n    # Hint: return make_function(param_names, body, env, None)\n\n# Special form dispatch table\nSPECIAL_FORMS = {\n    \"if\": handle_if,\n    \"define\": handle_define,\n    \"lambda\": handle_lambda,\n    # Add more special forms as needed\n}\n```\n\n**Language-Specific Hints:**\n\n- **Error Context**: Use f-strings for detailed error messages that include the symbol name, expected vs actual types, and operation being performed\n- **Type Checking**: Use `isinstance()` sparingly - prefer the type predicates like `is_number()`, `is_symbol()` for consistency with the data model\n- **Environment Threading**: Always pass the environment explicitly rather than using global state - this makes the evaluator easier to test and debug\n- **Function Dispatch**: Use dictionary dispatch for both special forms and built-in functions rather than long if/elif chains for better performance and maintainability\n- **Recursion Handling**: Python has a default recursion limit of 1000 - consider using `sys.setrecursionlimit()` for deeply nested expressions or implement iterative evaluation for tail calls\n\n**Milestone Checkpoints:**\n\nAfter **Milestone 2** (Basic Evaluation), you should be able to:\n- Run `python -m src.evaluator` and evaluate expressions like `(+ 1 2 3)` → `6`\n- Test conditionals: `(if (< 2 3) 10 20)` → `10`\n- Verify error handling: `(+ 1 \"hello\")` → `TypeError: + expects number, got string`\n\nAfter **Milestone 3** (Variables and Functions), you should be able to:\n- Define variables: `(define x 42)` then `x` → `42`\n- Create functions: `(define square (lambda (n) (* n n)))` then `(square 5)` → `25`\n- Test lexical scoping: nested function definitions should access variables from their definition environment\n\nAfter **Milestone 4** (List Operations & Recursion), you should be able to:\n- Test recursion: `(define factorial (lambda (n) (if (< n 2) 1 (* n (factorial (- n 1))))))` then `(factorial 5)` → `120`\n- List operations: `(cons 1 (cons 2 ()))` → `(1 2)`\n- Verify tail call behavior doesn't crash on reasonable recursion depths\n\n![Expression Evaluation Flow](./diagrams/evaluation-flow.svg)\n\n\n## Environment and Scope Management\n\n> **Milestone(s):** Milestone 3 (Variables and Functions) - environment and scope management enables lexical scoping for variables and functions, supporting define forms, lambda closures, and proper variable resolution\n\nBuilding variable scoping in a programming language is like constructing a sophisticated filing system where every function and code block gets its own filing cabinet, but these cabinets are nested inside each other. When you need to find a document (variable), you start with the innermost cabinet and work your way out through the parent cabinets until you find what you're looking for. This nested structure ensures that inner scopes can access variables from outer scopes, but outer scopes cannot see variables defined in inner scopes.\n\nThe environment system is the interpreter's memory management mechanism for variable bindings. It determines which variables are visible at any point during program execution and how variable names resolve to their values. Unlike simple interpreters that might use a single global dictionary, our Lisp interpreter implements lexical scoping through a chain of environment objects, each containing local bindings and a reference to its parent environment.\n\n### Mental Model: Nested Filing Cabinets\n\nThink of environments as a series of filing cabinets arranged in a nested hierarchy, similar to how Russian nesting dolls fit inside each other. Each function call, let binding, or lambda definition creates a new filing cabinet (environment) that sits inside the current one. When you need to look up a variable, you start with the innermost cabinet and work your way outward through the parent cabinets until you find a folder with the variable's name.\n\nConsider this mental model in action: when you define a global variable, it goes into the outermost filing cabinet that everyone can access. When you define a function with parameters, those parameters get their own cabinet that sits inside the global one. If that function defines local variables or calls another function, those create even more nested cabinets. The key insight is that inner cabinets can always reach into outer cabinets to retrieve documents, but outer cabinets cannot access documents stored in inner cabinets.\n\nThis filing cabinet analogy captures the essence of lexical scoping: variable visibility is determined by the nesting structure of your code, not by the order in which functions are called at runtime. A function defined inside another function can always access the outer function's variables, regardless of when or where the inner function is eventually called.\n\nThe filing cabinet hierarchy also explains closure behavior. When you create a lambda function (closure), it's like making a photocopy of all the filing cabinet keys it currently has access to. Even if you take that function elsewhere and call it in a completely different context, it still has those keys and can access the original cabinets where its variables were defined.\n\n### Lexical Scoping Rules\n\nLexical scoping, also called static scoping, determines variable visibility based on where variables are defined in the source code structure, not where functions are called at runtime. This predictable scoping behavior is essential for writing maintainable programs and enabling powerful features like closures.\n\nThe fundamental rule of lexical scoping is the **innermost binding wins principle**: when looking up a variable name, the interpreter searches from the innermost scope outward, returning the value from the first matching binding it encounters. This means that inner scopes can shadow (temporarily hide) variables from outer scopes by defining variables with the same name.\n\nVariable lookup follows a systematic search algorithm. The interpreter starts with the current environment and checks if the variable name exists in its bindings dictionary. If found, it returns that value immediately. If not found, it follows the parent reference to the next outer environment and repeats the search. This process continues until either the variable is found or the search reaches the global environment and finds no binding, resulting in a `NameError`.\n\nThe scoping rules create several important behavioral guarantees. First, **variable access is predictable**: you can determine what variables a piece of code can access simply by examining the nested structure of function definitions and let bindings in the source text. Second, **inner scopes see outer variables**: any variable defined in an outer scope remains accessible to all inner scopes, unless shadowed by a local binding with the same name. Third, **outer scopes cannot see inner variables**: variables defined inside functions or let bindings are completely invisible to code outside those constructs.\n\nConsider this example scope chain: the global environment contains a binding for `x = 10`. A function `outer` defines a parameter `y = 20` and a local variable `z = 30`. Inside `outer`, another function `inner` defines a parameter `z = 40`. When code inside `inner` references these variables, the lookup behavior is: `z` resolves to `40` (innermost binding), `y` resolves to `20` (from `outer`'s environment), and `x` resolves to `10` (from global environment). The original `z = 30` from `outer` is shadowed and inaccessible from within `inner`.\n\nLexical scoping also determines the behavior of function definitions. When a lambda function is created, it captures a reference to the environment where it was defined, not where it's called. This means the function will always see the variables that were in scope at definition time, regardless of what environment it's called from later.\n\n> The critical insight is that lexical scoping makes variable access predictable by tying it to code structure rather than execution flow. This predictability is essential for program reasoning and enables advanced features like closures and higher-order functions.\n\n**Decision: Lexical vs Dynamic Scoping**\n- **Context**: Programming languages can resolve variable names based on where they're defined (lexical) or where functions are called (dynamic)\n- **Options Considered**: \n  1. Lexical scoping with environment chains\n  2. Dynamic scoping with call stack lookup\n  3. Hybrid approach with explicit dynamic variables\n- **Decision**: Pure lexical scoping with environment chains\n- **Rationale**: Lexical scoping provides predictable behavior, enables closures, aligns with modern language design, and makes programs easier to reason about. Dynamic scoping can create action-at-a-distance bugs where changing a variable name in one function unexpectedly affects distant functions.\n- **Consequences**: Functions capture their defining environment, enabling closures but requiring careful environment management. Variable lookup is O(depth) in nesting level but provides strong encapsulation guarantees.\n\n| Scoping Type | Predictability | Closure Support | Performance | Debugging |\n|--------------|----------------|-----------------|-------------|-----------|\n| Lexical | High - determined by code structure | Full support | O(nesting depth) lookup | Easy - scope visible in code |\n| Dynamic | Low - depends on call stack | Not possible | O(call depth) lookup | Hard - scope depends on execution |\n| Hybrid | Medium - mix of both | Partial support | Variable overhead | Medium - multiple lookup rules |\n\n### Closure Environment Capture\n\nClosures are functions that capture and retain access to variables from their defining environment, even after that environment would normally be destroyed. This powerful feature enables functional programming patterns like partial application, callback functions with persistent state, and factory functions that generate specialized behavior.\n\nWhen a lambda expression is evaluated, the interpreter creates a `LispFunction` object that stores not just the parameter list and function body, but also a reference to the current environment. This captured environment, called the **closure environment**, preserves all variable bindings that were in scope when the lambda was defined. The closure environment forms a permanent link to the lexical context, ensuring the function can always access these variables regardless of when or where it's called.\n\nThe environment capture mechanism works through **environment sharing** rather than copying. When a closure is created, it stores a reference to the actual environment object, not a copy of its bindings. This means multiple closures created in the same scope share the same environment object, and changes to mutable variables in that environment are visible to all closures. This sharing behavior is crucial for implementing features like counter functions or stateful callbacks.\n\nClosure environment capture creates a **parent-child relationship** between environments. When a closure is called, the interpreter creates a new environment for the function's parameters and local variables, with the closure's captured environment as the parent. This means the closure can access both its own parameters/locals and all variables from its defining scope, maintaining the full lexical scope chain.\n\nThe lifetime implications of closures are significant. Normally, when a function returns, its environment can be garbage collected because no references remain. However, if the function created and returned a closure, that closure holds a reference to the function's environment, keeping it alive indefinitely. This can lead to memory leaks if not managed carefully, but it's essential for closure functionality.\n\nConsider a factory function that creates counter closures: each call to the factory creates a new environment containing a local counter variable, then returns a closure that increments and returns that counter. Even after the factory function returns, each closure retains access to its own counter variable through the captured environment. Multiple closures from the same factory call share the same environment and thus the same counter variable, while closures from different factory calls have independent counters.\n\n> The fundamental principle of closure capture is that functions remember where they came from. A closure is not just code to execute, but code plus the complete lexical context where that code was born.\n\n**Decision: Environment Reference vs Environment Copying**\n- **Context**: When creating closures, we can either store a reference to the defining environment or copy all relevant bindings\n- **Options Considered**:\n  1. Store reference to actual environment object (sharing)\n  2. Copy all accessible bindings into closure-specific environment\n  3. Copy-on-write approach with shared immutable environments\n- **Decision**: Store reference to actual environment object\n- **Rationale**: Reference sharing enables proper closure semantics where multiple closures can share mutable state, aligns with standard Lisp behavior, and avoids expensive copying. Copying would break expected closure behavior where closures can communicate through shared variables.\n- **Consequences**: Enables full closure functionality and shared mutable state, but requires careful memory management to avoid environment leaks. Multiple closures from the same scope can share and modify common variables.\n\n| Capture Strategy | Memory Usage | Shared State | Implementation Complexity | Standard Compliance |\n|------------------|--------------|--------------|---------------------------|-------------------|\n| Reference Sharing | Low - single environment | Full sharing | Low - direct references | Standard behavior |\n| Environment Copying | High - duplicate bindings | No sharing | Medium - selective copying | Non-standard behavior |\n| Copy-on-Write | Medium - shared until write | Limited sharing | High - complex bookkeeping | Partial compliance |\n\n### Common Environment Pitfalls\n\nEnvironment and scoping management presents several subtle pitfalls that frequently trap developers implementing interpreters. These issues often arise from misunderstanding the relationship between lexical scoping, environment lifetime, and closure semantics.\n\n⚠️ **Pitfall: Confusing Variable Shadowing with Variable Mutation**\n\nMany implementers incorrectly handle the difference between creating a new binding that shadows an outer variable versus modifying an existing variable's value. When you write `(define x 10)` in a local scope where `x` already exists in an outer scope, this creates a new binding in the current environment rather than modifying the outer binding. However, if the language supported variable mutation (which our minimal Lisp doesn't), updating an existing variable should modify the binding in the environment where it was originally defined, not create a new local binding.\n\nThis confusion leads to implementations that either always create new bindings (breaking mutation semantics) or always modify existing bindings (breaking shadowing semantics). The correct behavior requires checking whether you're performing a definition (creates new binding in current environment) or an assignment (modifies existing binding in the environment where it's found).\n\n⚠️ **Pitfall: Capturing Environments Too Late in Function Creation**\n\nA critical timing error occurs when implementations capture the environment for closures during function application rather than during function definition. This mistake leads to closures that see variables from their call site rather than their definition site, essentially implementing dynamic scoping instead of lexical scoping.\n\nThe environment must be captured immediately when the lambda expression is evaluated, not when the resulting function is later called. The `handle_lambda` function must store a reference to the current environment in the `LispFunction` object at creation time. If environment capture is delayed until function application, the closure will see whatever environment happens to be active when it's called, breaking lexical scoping guarantees.\n\n⚠️ **Pitfall: Creating Circular Environment References**\n\nImproper environment management can create circular references that prevent garbage collection and cause memory leaks. This typically happens when implementing recursive function definitions where the function name needs to be bound in the environment where the function body is evaluated.\n\nFor example, when processing `(define factorial (lambda (n) (if (= n 0) 1 (* n (factorial (- n 1))))))`, the function needs to reference itself by name. If you bind `factorial` in the closure environment after creating the function, you create a circular reference: the environment references the function, and the function references the environment. The correct approach is to bind the function name in the same environment where the lambda is defined, before capturing that environment in the closure.\n\n⚠️ **Pitfall: Incorrect Environment Chain Traversal**\n\nEnvironment lookup implementations often contain off-by-one errors or incorrect termination conditions that cause variables to be found in the wrong scope or not found when they should be accessible. Common mistakes include forgetting to check the current environment before moving to the parent, checking the parent before exhausting the current environment, or failing to handle the case where the parent environment is None.\n\nThe correct lookup algorithm must check bindings in the current environment first, then recursively check parent environments until either the variable is found or there are no more parent environments. Failing to check the current environment, or checking environments in the wrong order, breaks the innermost-binding-wins rule of lexical scoping.\n\n⚠️ **Pitfall: Environment Sharing vs Environment Inheritance Confusion**\n\nMany implementations confuse environment sharing (multiple references to the same environment object) with environment inheritance (parent-child relationships between different environment objects). This confusion leads to incorrect behavior when multiple closures should share state versus when they should have independent state.\n\nEnvironment sharing occurs when multiple closures are created in the same lexical scope - they should share the same closure environment and thus see modifications to common variables. Environment inheritance occurs during function application - the new environment for parameters and locals should have the closure environment as its parent, not share the closure environment directly. Mixing these concepts leads to either unwanted variable sharing or broken lexical access.\n\n⚠️ **Pitfall: Forgetting to Handle Empty Environment Chains**\n\nEdge case handling often fails when the environment chain is empty or when lookups reach the end of the chain without finding a binding. Implementations may attempt to access the parent of the global environment (which should be None) or fail to properly signal name errors when variables are not found.\n\nRobust environment lookup must handle the case where the current environment is None (indicating the end of the chain) and raise an appropriate `NameError` with helpful diagnostic information. The global environment should have a parent of None, and lookup should check for this condition to avoid attempting to search beyond the global scope.\n\n| Pitfall Category | Symptom | Root Cause | Detection Method | Prevention Strategy |\n|------------------|---------|------------|------------------|-------------------|\n| Shadowing vs Mutation | Variables not updating as expected | Wrong environment for binding modification | Test nested scopes with same names | Always create new bindings for define |\n| Late Environment Capture | Closures see call-site variables | Capturing environment at call time | Test closure accessing outer variables | Capture environment at lambda creation |\n| Circular References | Memory leaks, infinite recursion | Function and environment reference cycles | Memory profiling, recursion tests | Careful recursive function binding |\n| Chain Traversal Errors | Wrong variable values or name errors | Incorrect lookup order or termination | Test variable precedence in nested scopes | Systematic current-then-parent search |\n| Sharing vs Inheritance | Unexpected variable modifications | Confusing reference sharing with parent links | Test multiple closures from same scope | Clear distinction between sharing and inheritance |\n| Empty Chain Handling | Crashes on variable lookup | Missing None checks in chain traversal | Test undefined variable access | Explicit None checks and proper error handling |\n\n### Implementation Guidance\n\nThe environment system serves as the interpreter's variable management backbone, requiring careful attention to data structure design, lookup algorithms, and memory management. The implementation must balance simplicity with correctness while providing the foundation for advanced features like closures and recursive functions.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Environment Storage | Python dict with parent reference | Custom hash table with optimized lookup |\n| Variable Lookup | Recursive parent traversal | Iterative traversal with depth tracking |\n| Closure Capture | Direct environment reference | Weak references with explicit lifetime management |\n| Error Reporting | Simple NameError with variable name | Rich diagnostics with scope chain and suggestions |\n| Memory Management | Python garbage collection | Manual reference counting with cycle detection |\n\n#### Module Structure\n\nThe environment management functionality integrates closely with the evaluator while maintaining clear separation of concerns for variable resolution and scope management:\n\n```\nlisp_interpreter/\n  core/\n    environment.py           ← Environment class and scope management\n    values.py               ← LispValue types including functions\n    evaluator.py            ← Main evaluation logic using environments\n    errors.py               ← Environment-related error types\n  tests/\n    test_environment.py     ← Environment and scoping tests\n    test_closures.py        ← Closure capture and application tests\n    test_scoping.py         ← Lexical scoping behavior tests\n```\n\n#### Environment Infrastructure (Complete Implementation)\n\n```python\n\"\"\"\nComplete environment implementation for lexical scoping and variable management.\nThis provides the full infrastructure needed for variable binding, lookup, and\nclosure environment capture.\n\"\"\"\n\nfrom typing import Dict, Any, Optional\nfrom dataclasses import dataclass\nfrom core.values import LispValue\nfrom core.errors import NameError\n\n@dataclass\nclass Environment:\n    \"\"\"\n    Environment represents a single scope containing variable bindings.\n    Environments form a chain through parent references to implement lexical scoping.\n    \"\"\"\n    bindings: Dict[str, LispValue]\n    parent: Optional['Environment'] = None\n    \n    def lookup(self, name: str) -> LispValue:\n        \"\"\"\n        Look up a variable name in this environment and parent environments.\n        Implements the innermost-binding-wins rule of lexical scoping.\n        \n        Args:\n            name: Variable name to look up\n            \n        Returns:\n            LispValue associated with the name\n            \n        Raises:\n            NameError: If name is not found in any environment in the chain\n        \"\"\"\n        current_env = self\n        \n        while current_env is not None:\n            if name in current_env.bindings:\n                return current_env.bindings[name]\n            current_env = current_env.parent\n        \n        # Name not found in any environment in the chain\n        raise NameError(f\"undefined variable: {name}\")\n    \n    def define(self, name: str, value: LispValue) -> None:\n        \"\"\"\n        Create a new binding in this environment.\n        Always creates a new binding in the current environment, never modifies parent.\n        \n        Args:\n            name: Variable name to bind\n            value: LispValue to associate with the name\n        \"\"\"\n        self.bindings[name] = value\n    \n    def extend(self, new_bindings: Optional[Dict[str, LispValue]] = None) -> 'Environment':\n        \"\"\"\n        Create a new child environment with this environment as parent.\n        Used for function calls, let bindings, and other scope creation.\n        \n        Args:\n            new_bindings: Optional initial bindings for the new environment\n            \n        Returns:\n            New Environment with this environment as parent\n        \"\"\"\n        if new_bindings is None:\n            new_bindings = {}\n        return Environment(bindings=new_bindings.copy(), parent=self)\n    \n    def depth(self) -> int:\n        \"\"\"\n        Calculate the depth of this environment in the chain.\n        Useful for debugging and performance analysis.\n        \n        Returns:\n            Number of parent environments plus one\n        \"\"\"\n        if self.parent is None:\n            return 1\n        return 1 + self.parent.depth()\n    \n    def all_names(self) -> set[str]:\n        \"\"\"\n        Get all variable names visible from this environment.\n        Includes names from this environment and all parent environments.\n        \n        Returns:\n            Set of all accessible variable names\n        \"\"\"\n        names = set(self.bindings.keys())\n        if self.parent is not None:\n            names.update(self.parent.all_names())\n        return names\n\ndef create_global_environment() -> Environment:\n    \"\"\"\n    Create the global environment with built-in functions and constants.\n    This serves as the root of all environment chains.\n    \n    Returns:\n        Environment containing built-in bindings\n    \"\"\"\n    from core.builtins import BUILTIN_FUNCTIONS\n    from core.values import make_builtin, LISP_TRUE, LISP_FALSE\n    \n    global_bindings = {}\n    \n    # Add built-in functions\n    for name, (implementation, arity) in BUILTIN_FUNCTIONS.items():\n        global_bindings[name] = make_builtin(implementation, name, arity)\n    \n    # Add built-in constants\n    global_bindings['true'] = LISP_TRUE\n    global_bindings['false'] = LISP_FALSE\n    global_bindings['nil'] = EMPTY_LIST\n    \n    return Environment(bindings=global_bindings, parent=None)\n\nclass ScopeTracker:\n    \"\"\"\n    Debug utility for tracking scope changes during evaluation.\n    Helps diagnose environment and variable lookup issues.\n    \"\"\"\n    \n    def __init__(self):\n        self.scope_stack = []\n        self.lookup_history = []\n    \n    def push_scope(self, description: str, env: Environment):\n        \"\"\"Record entering a new scope.\"\"\"\n        self.scope_stack.append((description, env.depth()))\n    \n    def pop_scope(self):\n        \"\"\"Record leaving the current scope.\"\"\"\n        if self.scope_stack:\n            self.scope_stack.pop()\n    \n    def record_lookup(self, name: str, found_at_depth: Optional[int]):\n        \"\"\"Record a variable lookup attempt.\"\"\"\n        current_depth = self.scope_stack[-1][1] if self.scope_stack else 0\n        self.lookup_history.append((name, current_depth, found_at_depth))\n    \n    def current_scope_description(self) -> str:\n        \"\"\"Get description of current scope for error messages.\"\"\"\n        if not self.scope_stack:\n            return \"global scope\"\n        return \" -> \".join(desc for desc, _ in self.scope_stack)\n```\n\n#### Core Logic Skeleton for Environment Integration\n\n```python\ndef handle_lambda(args: List[LispValue], env: Environment) -> LispValue:\n    \"\"\"\n    Create a lambda function (closure) that captures the current environment.\n    \n    Args:\n        args: [parameters, body] where parameters is a list of symbols\n        env: Current environment to capture for closure\n        \n    Returns:\n        LispFunction value representing the closure\n        \n    Raises:\n        ArityError: If args doesn't contain exactly 2 elements\n        TypeError: If parameters is not a list of symbols\n    \"\"\"\n    # TODO 1: Validate that args contains exactly 2 elements (parameters and body)\n    # TODO 2: Extract parameters list and body expression from args\n    # TODO 3: Validate that parameters is a list of symbols (not numbers or other types)\n    # TODO 4: Convert parameters from LispValue symbols to string names\n    # TODO 5: Create LispFunction with parameters, body, and current environment as closure_env\n    # TODO 6: Return the function as a LispValue\n    # Hint: Use is_list() and is_symbol() to validate parameter structure\n    # Hint: The current environment (env) becomes the closure_env for the function\n\ndef handle_define(args: List[LispValue], env: Environment) -> LispValue:\n    \"\"\"\n    Define a variable in the current environment.\n    Supports both variable definition and function definition syntactic sugar.\n    \n    Args:\n        args: [name, value] or [(name, params...), body] for function sugar\n        env: Current environment to create binding in\n        \n    Returns:\n        The defined value\n        \n    Raises:\n        ArityError: If args doesn't contain exactly 2 elements\n        TypeError: If name is not a symbol or parameter list is malformed\n    \"\"\"\n    # TODO 1: Validate that args contains exactly 2 elements\n    # TODO 2: Check if first element is a symbol (variable definition) or list (function sugar)\n    # TODO 3: For variable definition: extract name and evaluate value in current environment\n    # TODO 4: For function sugar: extract function name and parameters from first element\n    # TODO 5: For function sugar: create lambda with parameters and body, then bind to name\n    # TODO 6: Use env.define() to create binding in current environment\n    # TODO 7: Return the value that was bound\n    # Hint: Function sugar (define (name params...) body) expands to (define name (lambda (params...) body))\n    # Hint: Always evaluate the value expression before binding it\n\ndef apply_function(func: LispValue, args: List[LispValue], current_env: Environment) -> LispValue:\n    \"\"\"\n    Apply a function to arguments, creating new environment for execution.\n    \n    Args:\n        func: LispFunction or BuiltinFunction to apply\n        args: Evaluated arguments to pass to function\n        current_env: Current environment (may not be used for lexically scoped functions)\n        \n    Returns:\n        Result of function application\n        \n    Raises:\n        TypeError: If func is not a function\n        ArityError: If argument count doesn't match function parameters\n    \"\"\"\n    # TODO 1: Check if func is a BuiltinFunction - if so, call implementation directly\n    # TODO 2: Validate that func is a LispFunction (user-defined function)\n    # TODO 3: Check that len(args) matches len(func.parameters) (arity checking)\n    # TODO 4: Create new environment extending func.closure_env (not current_env!)\n    # TODO 5: Bind each parameter name to corresponding argument value in new environment\n    # TODO 6: If function has a name (recursive functions), bind name to func in new environment\n    # TODO 7: Evaluate function body in the new environment\n    # TODO 8: Return the evaluation result\n    # Hint: Use func.closure_env.extend() to create the new environment\n    # Hint: The closure environment, not current_env, determines lexical scope\n```\n\n#### Language-Specific Hints for Python\n\n**Environment Reference Management**: Python's garbage collector handles circular references between environments and functions automatically, but be aware that long chains of environments can consume significant memory. Use weak references from the `weakref` module if you need to break cycles manually.\n\n**Dictionary Performance**: Python dictionaries are highly optimized and provide O(1) average case lookup. For environments with many variables, this performs better than lists or arrays. Use `dict.get(name, None)` for safe lookups that return None instead of raising KeyError.\n\n**Exception Handling**: Inherit from Python's built-in `NameError` for undefined variables to maintain consistency with Python's error hierarchy. Add custom attributes like `variable_name` and `scope_description` for better error messages.\n\n**Memory Debugging**: Use `gc.get_objects()` and `sys.getsizeof()` to monitor environment memory usage during development. Large numbers of long-lived closures can create memory pressure through retained environment references.\n\n**Function Object Integration**: Python's function objects provide good inspiration for closure design. Consider storing additional metadata like function name, source location, or documentation strings in your `LispFunction` objects for better debugging support.\n\n#### Milestone Checkpoint: Environment and Scoping\n\nAfter implementing the environment system, verify the following behaviors:\n\n**Variable Definition and Lookup**:\n```python\n# Test in your REPL or test suite\nenv = create_global_environment()\nresult = evaluate(parse(\"(define x 42)\"), env)\nassert evaluate(parse(\"x\"), env) == make_number(42)\n```\n\n**Lexical Scoping with Shadowing**:\n```python\ncode = \"\"\"\n(define x 10)\n(define f (lambda (x) (+ x 1)))\n(f 5)\n\"\"\"\n# Should return 6, not 11 (inner x shadows outer x)\n```\n\n**Closure Environment Capture**:\n```python\ncode = \"\"\"\n(define make-counter (lambda (start)\n  (lambda () (define start (+ start 1)) start)))\n(define counter (make-counter 0))\n(counter)\n(counter)\n\"\"\"\n# Should return 1, then 2 (closure captures and modifies start)\n```\n\n**Expected Error Behaviors**:\n- Referencing undefined variables should raise `NameError`\n- Function calls with wrong argument count should raise `ArityError`\n- Defining variables in inner scopes should not affect outer scopes\n\n**Performance Expectations**:\n- Variable lookup should be fast for reasonable nesting depths (< 10 levels)\n- Creating many closures should not cause obvious memory leaks\n- Environment chains should not grow excessively during recursive function calls\n\nIf any of these behaviors fail, check:\n1. Environment capture timing in lambda creation\n2. Parent-child relationships in environment chains\n3. Binding creation vs binding modification logic\n4. Proper scope extension during function application\n\n\n## Function System Design\n\n> **Milestone(s):** Milestone 3 (Variables and Functions) - this section implements lambda functions, closures, and function application with proper argument binding to support first-class functions\n\n### Mental Model: Customizable Machines\n\nThink of functions in Lisp as **customizable machines** that can be configured once and then reused many times. Just like a factory machine that can be set up with different dies to produce various shapes, a lambda function is a template that can be \"stamped\" with different arguments to produce different results.\n\nWhen you create a lambda function with `(lambda (x y) (+ x y))`, you're building a machine blueprint that says \"I have two input slots labeled x and y, and when you feed me values for those slots, I'll add them together and give you the result.\" The machine remembers not just its internal blueprint (the parameter list and body), but also the **environment where it was built** - like a machine that remembers which factory it came from and can access that factory's shared tools and resources.\n\nThis mental model helps explain three critical aspects of functions: **configuration** (parameter binding), **reusability** (the same function can be called multiple times), and **context retention** (closures capture their defining environment). Unlike simple arithmetic operations that work the same way everywhere, these customizable machines carry their birthplace with them, enabling sophisticated programming patterns like closures and higher-order functions.\n\nThe factory analogy extends to function application: when you call `(my-function 5 3)`, you're feeding raw materials (arguments 5 and 3) into your configured machine (my-function), which processes them according to its internal blueprint and produces a finished product (the result 8). The machine can be used over and over with different raw materials, always following the same process but producing different outputs.\n\n### Lambda Function Creation\n\nLambda functions in Lisp represent the transition from a purely arithmetic calculator to a programming language capable of abstraction and code reuse. The `lambda` special form creates **first-class function values** that can be stored in variables, passed as arguments, and returned from other functions, embodying the principle that functions are data.\n\nThe syntax `(lambda (param1 param2 ...) body-expression)` defines three essential components: the **parameter list** specifying the function's inputs, the **body expression** defining the computation to perform, and implicitly, the **lexical environment** where the lambda is evaluated. Unlike mathematical functions that exist in abstract isolation, Lisp lambda functions are **closures** that capture and retain access to variables from their defining scope.\n\n> **Decision: Closure Environment Capture**\n> - **Context**: Lambda functions need access to variables from their defining scope, but the stack frame where they're defined may no longer exist when they're called\n> - **Options Considered**: \n>   1. Dynamic scoping - look up variables in the calling environment\n>   2. Lexical scoping with environment capture - store defining environment in function object\n>   3. Static scoping with variable copying - copy all accessible variables into function\n> - **Decision**: Lexical scoping with environment capture\n> - **Rationale**: Provides predictable behavior where function meaning depends only on where it's defined, not where it's called. Environment references are more memory-efficient than copying all variables.\n> - **Consequences**: Enables powerful closure patterns but requires garbage collection of captured environments. Functions become heavier objects carrying environment references.\n\n| Closure Approach | Memory Usage | Predictability | Implementation Complexity |\n|------------------|--------------|----------------|---------------------------|\n| Dynamic Scoping | Low | Low (depends on call site) | Simple |\n| Environment Capture | Medium | High (depends only on definition) | Moderate |\n| Variable Copying | High | High | Simple |\n\nThe lambda creation process involves several critical steps that transform source code into a callable function object. First, the parameter list is **validated and stored** as a list of symbol names that will become local variable bindings during function calls. The parameter validation ensures no duplicate names exist and that all parameters are valid symbols, preventing runtime confusion about argument binding.\n\nSecond, the body expression is **stored without evaluation** - this is crucial because the body should only be evaluated when the function is called, not when it's defined. The body remains as an abstract syntax tree that will be evaluated later in the context of the function call's environment. This delayed evaluation enables recursion and forward references that wouldn't be possible if the body were evaluated immediately.\n\nThird, and most importantly, the lambda creation captures a **reference to the current environment** where the lambda form is being evaluated. This captured environment becomes the function's \"closure environment\" that provides access to variables from the defining scope. The environment capture is a shallow copy of the environment reference, not a deep copy of all variables, allowing multiple closures to share the same environment efficiently.\n\n| Lambda Creation Step | Purpose | Error Conditions |\n|---------------------|---------|------------------|\n| Parameter Validation | Ensure valid symbol names, no duplicates | `TypeError` if non-symbol parameters, `ArityError` if duplicates |\n| Body Storage | Preserve unevaluated expression for later | `ParseError` if body missing |\n| Environment Capture | Enable lexical scoping and closure behavior | Never fails - always captures current environment |\n| Function Object Creation | Package components into callable value | Memory allocation failure only |\n\nConsider the creation of a closure that demonstrates environment capture:\n\n```lisp\n(define make-counter\n  (lambda (start)\n    (lambda ()\n      (define start (+ start 1))\n      start)))\n\n(define counter (make-counter 10))\n```\n\nWhen `make-counter` is called with argument 10, it creates a new environment where `start` is bound to 10. The inner lambda `(lambda () ...)` captures this environment, creating a closure that retains access to the `start` variable even after `make-counter` returns. Each call to the returned counter function will access and modify the same `start` variable, demonstrating how closures maintain persistent state.\n\nThe `LispFunction` data structure encapsulates all the information needed for later function application:\n\n| Field | Type | Purpose |\n|-------|------|---------|\n| `parameters` | `List[str]` | Parameter names for argument binding |\n| `body` | `LispValue` | Unevaluated expression to execute when called |\n| `closure_env` | `Environment` | Captured environment providing lexical scope |\n| `name` | `Optional[str]` | Function name for debugging and recursion |\n\nThe optional `name` field supports both anonymous and named functions. Anonymous functions created by lambda expressions have `name` set to `None`, while functions created by `define` forms store the defined name. This name is crucial for recursive functions, allowing them to reference themselves by name within their body.\n\n### Function Application Process\n\nFunction application transforms a function call like `(my-function arg1 arg2)` into a result value through a carefully orchestrated sequence of steps that maintain proper lexical scoping and argument binding. The application process bridges the gap between abstract function definitions and concrete computation, handling the complex interaction between the caller's environment, the function's closure environment, and the new environment created for the function execution.\n\nThe application process begins with **argument evaluation** in the caller's current environment. Unlike special forms that control which arguments get evaluated, function calls follow the standard Lisp evaluation rule of evaluating all arguments before passing them to the function. This eager evaluation strategy ensures that by the time the function body executes, all arguments have been reduced to their final values.\n\n> **Decision: Eager Argument Evaluation**\n> - **Context**: Function arguments could be evaluated before or during function execution, affecting both semantics and implementation complexity\n> - **Options Considered**:\n>   1. Eager evaluation - evaluate all arguments in caller's environment before function call\n>   2. Lazy evaluation - pass unevaluated arguments and evaluate them when accessed\n>   3. Call-by-need - evaluate arguments on first access and cache results\n> - **Decision**: Eager argument evaluation\n> - **Rationale**: Provides predictable semantics, simplifies function implementation, and matches standard Lisp behavior. Arguments are evaluated in the caller's scope where they have clear meaning.\n> - **Consequences**: Enables straightforward function calls but prevents some advanced patterns like delayed computation. All argument side effects occur before function body execution.\n\nAfter arguments are evaluated, the system performs **arity checking** to ensure the number of provided arguments matches the function's parameter count. This validation prevents runtime errors that would occur from unbound parameters or ignored arguments, providing early feedback about incorrect function calls.\n\n| Arity Mismatch Type | Detection | Error Type | Example |\n|---------------------|-----------|------------|---------|\n| Too Few Arguments | `len(args) < len(parameters)` | `ArityError` | `((lambda (x y) (+ x y)) 5)` missing y |\n| Too Many Arguments | `len(args) > len(parameters)` | `ArityError` | `((lambda (x) x) 1 2 3)` extra args 2,3 |\n| Correct Arity | `len(args) == len(parameters)` | No error | `((lambda (x y) (+ x y)) 5 3)` |\n\nThe core of function application is **environment extension and parameter binding**. The system creates a new environment that extends the function's closure environment (not the caller's environment), establishing the lexical scoping chain. Into this new environment, it binds each parameter name to its corresponding argument value, creating the local variable context for function execution.\n\nThe environment extension process follows this sequence:\n\n1. **Start with closure environment**: Use the function's `closure_env` as the parent environment, ensuring access to variables from the function's defining scope\n2. **Create extended environment**: Call `closure_env.extend()` to create a child environment with the closure as parent\n3. **Bind parameters to arguments**: For each parameter-argument pair, call `extended_env.define(param_name, arg_value)` to create local bindings\n4. **Handle recursive functions**: If the function has a name, bind that name to the function itself in the extended environment, enabling self-reference\n\nThis environment structure ensures that variable lookups follow the proper precedence order: local parameters first, then closure-captured variables, then global bindings. The recursive function binding is particularly important - it allows functions to call themselves by name without requiring special syntax or forward declarations.\n\nConsider the environment chain during this recursive factorial call:\n\n```lisp\n(define factorial\n  (lambda (n)\n    (if (<= n 1)\n        1\n        (* n (factorial (- n 1))))))\n\n(factorial 3)\n```\n\nWhen `factorial` is called with argument 3, the environment chain looks like:\n- **Local environment**: `n -> 3, factorial -> <function-object>`\n- **Closure environment**: `factorial -> <function-object>` (from global define)\n- **Global environment**: built-in functions like `*`, `-`, `<=`\n\nThe final step is **body evaluation** in the extended environment. The function's body expression is evaluated using the newly created environment, giving it access to the parameter bindings and closure variables. The result of this evaluation becomes the return value of the function call.\n\n| Application Step | Purpose | Environment Used |\n|------------------|---------|------------------|\n| Argument Evaluation | Convert argument expressions to values | Caller's current environment |\n| Arity Checking | Validate argument count matches parameters | N/A (pure validation) |\n| Environment Extension | Create local scope for function execution | Function's closure environment as parent |\n| Parameter Binding | Bind parameter names to argument values | Extended environment |\n| Body Evaluation | Execute function logic and compute result | Extended environment |\n\nThe complete function application signature follows this pattern:\n\n```\napply_function(func: LispFunction, args: List[LispValue], current_env: Environment) -> LispValue\n```\n\nThe `current_env` parameter represents the caller's environment and is used only for argument evaluation. The actual function execution uses the environment chain built from the function's closure environment, maintaining proper lexical scoping semantics.\n\n### Common Function Pitfalls\n\nFunction implementation presents several subtle challenges that frequently trip up developers new to interpreter design. These pitfalls arise from the complex interaction between evaluation order, environment management, and the distinction between function definition and function application.\n\n⚠️ **Pitfall: Evaluating Function Body During Lambda Creation**\n\nA common mistake is evaluating the lambda body expression when the lambda form is processed, rather than storing it for later evaluation during function calls. This premature evaluation breaks recursion, prevents forward references, and can cause undefined variable errors.\n\n```lisp\n; This should work but fails with premature evaluation:\n(define factorial\n  (lambda (n)\n    (if (<= n 1)\n        1\n        (* n (factorial (- n 1)))))) ; ERROR: factorial not yet defined\n```\n\nThe problem occurs because if the body is evaluated during lambda creation, the recursive call to `factorial` happens before the `define` has completed binding the name `factorial` to the function. The fix is to store the body as an unevaluated AST node and only evaluate it when the function is actually called.\n\n**Detection**: Function definition fails with \"undefined variable\" errors for recursive calls, or functions that reference variables not available at definition time fail unexpectedly.\n\n**Fix**: Store the body expression as a `LispValue` without evaluating it. Only evaluate the body during `apply_function` in the function call's environment.\n\n⚠️ **Pitfall: Wrong Environment for Argument Evaluation**\n\nAnother frequent error is evaluating function arguments in the function's closure environment instead of the caller's current environment. This violates lexical scoping because arguments should be evaluated in the context where the function call appears, not where the function was defined.\n\n```lisp\n(define x 10)\n(define f (lambda (y) (+ x y)))\n(define x 20)\n(f x) ; Should be 30 (20 + 10), not 40 (20 + 20)\n```\n\nIf arguments are evaluated in the function's environment, the argument `x` would be looked up in the closure environment where `x` is 10, yielding the wrong result. The correct behavior evaluates `x` in the caller's environment where `x` is 20.\n\n**Detection**: Function calls produce unexpected results when argument expressions contain variables that have different values in the caller vs function definition contexts.\n\n**Fix**: Always evaluate arguments using the `current_env` parameter passed to `apply_function`, which represents the caller's environment. Only use the closure environment for the function body evaluation.\n\n⚠️ **Pitfall: Incorrect Parameter Binding Environment**\n\nA subtle mistake is binding parameters in the caller's environment or the closure environment directly, rather than creating a new extended environment. This can cause variable name conflicts or make parameters visible where they shouldn't be.\n\nThe wrong approach might extend the caller's environment:\n\n```lisp\n(define x 5)\n(define f (lambda (x) (* x 2)))\n(f 10)\n; If parameters bind in caller's environment, global x becomes 10!\n```\n\n**Detection**: Function calls modify global variables unexpectedly, or parameter names conflict with existing bindings in confusing ways.\n\n**Fix**: Always create a new environment that extends the closure environment: `extended_env = func.closure_env.extend()`. Bind parameters in this new environment, keeping them isolated from both the caller and the closure.\n\n⚠️ **Pitfall: Missing Recursive Function Binding**\n\nFor recursive functions, forgetting to bind the function name to itself in the function's execution environment prevents self-reference and causes \"undefined variable\" errors during recursive calls.\n\n```lisp\n(define countdown\n  (lambda (n)\n    (if (<= n 0)\n        \"done\"\n        (countdown (- n 1))))) ; ERROR: countdown undefined in function body\n```\n\n**Detection**: Recursive functions fail with \"undefined variable\" errors when they try to call themselves by name.\n\n**Fix**: When applying a named function (one with `func.name` not `None`), bind the function name to the function object itself in the extended environment: `extended_env.define(func.name, func)`.\n\n⚠️ **Pitfall: Arity Checking After Environment Creation**\n\nPerforming arity validation after creating the function's environment wastes computational resources and can leave partially constructed environments in inconsistent states if the validation fails.\n\n**Detection**: Performance issues with functions that have arity mismatches, or debugger shows environment creation before arity errors.\n\n**Fix**: Check arity immediately after argument evaluation, before any environment manipulation: `if len(args) != len(func.parameters): raise ArityError(...)`.\n\n⚠️ **Pitfall: Shallow vs Deep Environment Capture**\n\nMisunderstanding whether closure environment capture should be a shallow reference or a deep copy leads to either incorrect sharing of environment modifications or excessive memory usage.\n\n```lisp\n(define make-incrementer\n  (lambda (start)\n    (lambda () (define start (+ start 1)) start)))\n\n(define inc1 (make-incrementer 0))\n(define inc2 (make-incrementer 0))\n(inc1) ; Should be 1\n(inc2) ; Should be 1, not 2!\n```\n\n**Detection**: Multiple closures created from the same function interfere with each other's variables, or excessive memory usage from deep copying environments.\n\n**Fix**: Capture environment references (shallow copy) but ensure each function call gets its own extended environment for parameter binding. The closure environments can be shared, but the execution environments must be isolated.\n\n| Pitfall | Symptom | Root Cause | Solution |\n|---------|---------|------------|----------|\n| Premature Body Evaluation | Recursion fails, forward references break | Body evaluated at lambda creation time | Store body as unevaluated AST |\n| Wrong Argument Environment | Unexpected variable values in arguments | Arguments evaluated in closure environment | Use caller's environment for arguments |\n| Incorrect Parameter Binding | Global variable modification, name conflicts | Parameters bound in wrong environment | Create new extended environment |\n| Missing Recursive Binding | \"Undefined variable\" in recursive calls | Function name not bound in execution environment | Bind function name to self if present |\n| Late Arity Checking | Performance issues, inconsistent state | Validation after environment creation | Check arity before environment work |\n| Environment Capture Confusion | Variable interference or memory bloat | Wrong sharing/copying strategy | Shallow capture with isolated execution |\n\n### Implementation Guidance\n\nThe function system implementation bridges the gap between the abstract concept of lambda expressions and the concrete mechanics of creating, storing, and applying first-class function values. This implementation requires careful coordination between the evaluator's special form handling and the environment system's scoping mechanisms.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Function Representation | Named tuple with fields | Full class with methods |\n| Environment Capture | Direct reference storage | Weak references with GC integration |\n| Parameter Binding | Dictionary-based environment | Optimized slot-based binding |\n| Recursion Support | Name binding in environment | Trampolined execution |\n| Closure Storage | Environment reference | Captured variable analysis |\n\n#### Recommended File/Module Structure\n\n```\nlisp_interpreter/\n  core/\n    evaluator.py              ← main evaluation logic\n    environment.py            ← environment and scope management\n    functions.py              ← function system (this component)\n    special_forms.py          ← lambda, define, if handling\n  data/\n    values.py                 ← LispValue, LispFunction types\n    errors.py                 ← function-specific errors\n  tests/\n    test_functions.py         ← function system tests\n    test_closures.py          ← closure behavior tests\n    test_recursion.py         ← recursive function tests\n```\n\n#### Core Function Types (Complete Infrastructure)\n\n```python\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Any, Callable\nfrom enum import Enum\n\nclass LispValueType(Enum):\n    NUMBER = \"number\"\n    SYMBOL = \"symbol\"\n    LIST = \"list\"\n    FUNCTION = \"function\"\n    BUILTIN = \"builtin\"\n\n@dataclass\nclass LispValue:\n    value: Any\n    type: LispValueType\n    \n    def __repr__(self):\n        if self.type == LispValueType.FUNCTION:\n            func = self.value\n            params = ' '.join(func.parameters)\n            name = func.name or \"anonymous\"\n            return f\"<function {name}({params})>\"\n        return f\"<{self.type.value}: {self.value}>\"\n\n@dataclass\nclass LispFunction:\n    parameters: List[str]\n    body: LispValue\n    closure_env: 'Environment'\n    name: Optional[str] = None\n    \n    def __post_init__(self):\n        # Validate parameters are unique symbols\n        if len(set(self.parameters)) != len(self.parameters):\n            raise TypeError(\"Duplicate parameter names in function definition\")\n        \n        for param in self.parameters:\n            if not isinstance(param, str) or not param:\n                raise TypeError(f\"Parameter must be non-empty string, got {type(param)}\")\n\n@dataclass\nclass BuiltinFunction:\n    implementation: Callable\n    name: str\n    arity: Optional[int] = None  # None means variable arity\n    \n    def __call__(self, args: List[LispValue]) -> LispValue:\n        if self.arity is not None and len(args) != self.arity:\n            raise ArityError(self.arity, len(args), self.name)\n        return self.implementation(args)\n\nclass ArityError(Exception):\n    def __init__(self, expected: int, actual: int, function_name: str):\n        self.expected = expected\n        self.actual = actual\n        self.function_name = function_name\n        super().__init__(f\"Function {function_name} expects {expected} arguments, got {actual}\")\n\n# Value constructors for type safety\ndef make_function(parameters: List[str], body: LispValue, closure_env: 'Environment', \n                 name: Optional[str] = None) -> LispValue:\n    \"\"\"Create a user-defined function value.\"\"\"\n    func = LispFunction(parameters, body, closure_env, name)\n    return LispValue(func, LispValueType.FUNCTION)\n\ndef make_builtin(implementation: Callable, name: str, arity: Optional[int] = None) -> LispValue:\n    \"\"\"Create a built-in function value.\"\"\"\n    builtin = BuiltinFunction(implementation, name, arity)\n    return LispValue(builtin, LispValueType.BUILTIN)\n\ndef is_function(value: LispValue) -> bool:\n    \"\"\"Check if value is a callable function (user-defined or builtin).\"\"\"\n    return value.type in (LispValueType.FUNCTION, LispValueType.BUILTIN)\n\ndef is_user_function(value: LispValue) -> bool:\n    \"\"\"Check if value is specifically a user-defined function.\"\"\"\n    return value.type == LispValueType.FUNCTION\n\ndef is_builtin_function(value: LispValue) -> bool:\n    \"\"\"Check if value is specifically a built-in function.\"\"\"\n    return value.type == LispValueType.BUILTIN\n```\n\n#### Lambda Special Form Handler (Core Logic Skeleton)\n\n```python\ndef handle_lambda(args: List[LispValue], env: 'Environment') -> LispValue:\n    \"\"\"\n    Process lambda special form: (lambda (param1 param2 ...) body-expr)\n    Creates a closure capturing the current environment.\n    \n    Args:\n        args: [parameter-list, body-expression] from lambda form\n        env: Current environment where lambda is being evaluated\n        \n    Returns:\n        LispValue containing LispFunction with captured environment\n        \n    Raises:\n        TypeError: Invalid parameter list or missing body\n        ArityError: Wrong number of arguments to lambda form\n    \"\"\"\n    # TODO 1: Validate lambda form has exactly 2 arguments (parameter list + body)\n    # Hint: lambda special form syntax is (lambda (params...) body)\n    \n    # TODO 2: Extract and validate parameter list from first argument\n    # Hint: Parameter list should be a LIST type containing only SYMBOL values\n    # Must check: args[0].type == LispValueType.LIST\n    # Must validate each element is a symbol\n    \n    # TODO 3: Extract parameter names as list of strings\n    # Hint: Convert each symbol LispValue to its string representation\n    # Handle empty parameter list: (lambda () body)\n    \n    # TODO 4: Extract body expression from second argument\n    # Hint: Body is already a parsed LispValue, store without evaluating\n    # Critical: Do NOT evaluate body here - save for function application\n    \n    # TODO 5: Create LispFunction with captured environment\n    # Hint: Use make_function(param_names, body, env, name=None)\n    # The 'env' parameter becomes the closure_env\n    \n    # TODO 6: Return the function as a LispValue\n    # Hint: make_function already returns proper LispValue\n    \n    pass  # Replace with implementation\n```\n\n#### Function Application Logic (Core Logic Skeleton)\n\n```python\ndef apply_function(func: LispValue, args: List[LispValue], current_env: 'Environment') -> LispValue:\n    \"\"\"\n    Apply a function to its arguments with proper scoping.\n    \n    Args:\n        func: Function to call (user-defined or builtin)\n        args: Already-evaluated argument values\n        current_env: Environment where function call appears (for debugging only)\n        \n    Returns:\n        Result of function execution\n        \n    Raises:\n        TypeError: func is not callable\n        ArityError: Wrong number of arguments\n        EvaluationError: Error during function body evaluation\n    \"\"\"\n    # TODO 1: Validate func is callable (user function or builtin)\n    # Hint: Use is_function(func) to check both types\n    \n    # TODO 2: Handle builtin functions separately\n    # Hint: if is_builtin_function(func): return func.value(args)\n    # Builtin functions handle their own arity checking\n    \n    # TODO 3: Extract LispFunction from user-defined function\n    # Hint: lisp_func = func.value  # gets the LispFunction object\n    \n    # TODO 4: Perform arity checking for user-defined function\n    # Hint: if len(args) != len(lisp_func.parameters): raise ArityError(...)\n    # Use ArityError(expected, actual, function_name)\n    \n    # TODO 5: Create extended environment for function execution\n    # Hint: execution_env = lisp_func.closure_env.extend()\n    # This creates child of closure environment, not current_env!\n    \n    # TODO 6: Bind parameters to argument values\n    # Hint: for param_name, arg_value in zip(lisp_func.parameters, args):\n    #           execution_env.define(param_name, arg_value)\n    \n    # TODO 7: Handle recursive function binding if function has name\n    # Hint: if lisp_func.name is not None:\n    #           execution_env.define(lisp_func.name, func)\n    \n    # TODO 8: Evaluate function body in execution environment\n    # Hint: from .evaluator import evaluate  # avoid circular import\n    #       return evaluate(lisp_func.body, execution_env)\n    \n    pass  # Replace with implementation\n```\n\n#### Integration with Evaluator (Complete Infrastructure)\n\n```python\n# Add to evaluator.py special forms registry\nSPECIAL_FORMS = {\n    'if': handle_if,\n    'define': handle_define,\n    'lambda': handle_lambda,\n    'quote': handle_quote,\n}\n\ndef evaluate_list(expr: LispValue, env: Environment) -> LispValue:\n    \"\"\"Evaluate list expression - either special form or function call.\"\"\"\n    if not expr.value:  # Empty list\n        return expr\n    \n    elements = expr.value\n    first_element = elements[0]\n    \n    # Check for special forms\n    if (is_symbol(first_element) and \n        first_element.value in SPECIAL_FORMS):\n        handler = SPECIAL_FORMS[first_element.value]\n        return handler(elements[1:], env)\n    \n    # Regular function call\n    func = evaluate(first_element, env)\n    args = [evaluate(arg, env) for arg in elements[1:]]\n    \n    return apply_function(func, args, env)\n```\n\n#### Milestone Checkpoint: Function System\n\nAfter implementing the function system, verify these behaviors work correctly:\n\n**Test 1: Basic Lambda Creation and Application**\n```python\n# Test command\npython -c \"\nfrom lisp_interpreter import evaluate_string\nresult = evaluate_string('((lambda (x) (* x 2)) 5)')\nassert result.value == 10\nprint('✓ Basic lambda works')\n\"\n```\n\n**Test 2: Closure Environment Capture**\n```python\n# Test command  \npython -c \"\nfrom lisp_interpreter import evaluate_string\ncode = '''\n(define x 10)\n(define f (lambda (y) (+ x y)))\n(define x 20)\n(f 5)\n'''\nresult = evaluate_string(code)\nassert result.value == 15  # Uses captured x=10, not current x=20\nprint('✓ Closure capture works')\n\"\n```\n\n**Test 3: Recursive Function**\n```python\n# Test command\npython -c \"\nfrom lisp_interpreter import evaluate_string  \ncode = '''\n(define factorial \n  (lambda (n)\n    (if (<= n 1)\n        1\n        (* n (factorial (- n 1))))))\n(factorial 5)\n'''\nresult = evaluate_string(code)\nassert result.value == 120\nprint('✓ Recursion works')\n\"\n```\n\n**Expected Behaviors:**\n- Lambda expressions create function values without evaluation errors\n- Function calls bind arguments to parameters in isolated environments  \n- Closures access variables from their definition scope, not call scope\n- Recursive functions can reference themselves by name\n- Arity mismatches produce clear error messages with function names\n\n**Common Issues and Fixes:**\n- **\"Undefined variable 'factorial'\"**: Missing recursive name binding in execution environment\n- **Wrong closure values**: Arguments evaluated in closure environment instead of caller environment  \n- **Parameter conflicts**: Parameters bound in global environment instead of isolated execution environment\n- **Premature evaluation errors**: Function body evaluated during lambda creation instead of application\n\n![Lisp Value Type Hierarchy](./diagrams/data-model.svg)\n\n![Expression Evaluation Flow](./diagrams/evaluation-flow.svg)\n\n![Function Application Process](./diagrams/function-application-sequence.svg)\n\n\n## List Operations and Recursion\n\n> **Milestone(s):** Milestone 4 (List Operations & Recursion) - this section implements fundamental list operations (car, cdr, cons) and supports recursive function definitions, completing the core Lisp interpreter functionality\n\nLists are the fundamental data structure in Lisp, serving as both the mechanism for representing data and the syntax for code itself. This homoiconicity—where code and data share the same representation—is what makes Lisp uniquely powerful and elegant. In this section, we implement the core list manipulation primitives that enable sophisticated data processing and the recursive function capabilities that allow functions to call themselves by name.\n\nThe list operations we implement—`car`, `cdr`, and `cons`—form the foundation of all list processing in Lisp. These three primitives are sufficient to build any list-based algorithm, from simple traversals to complex tree transformations. Additionally, we enable recursive function definitions, allowing functions to reference themselves by name within their own bodies, which is essential for implementing algorithms that process nested or variable-sized data structures.\n\n### Mental Model: Chain Links\n\nUnderstanding Lisp lists requires shifting from thinking about arrays or vectors to visualizing **chain links**. Each list element is like a chain link that contains two things: a **payload** (the actual data) and a **connection** (a pointer to the next link in the chain). This is fundamentally different from arrays, where elements are stored in contiguous memory slots.\n\n![Environment Scope Chain](./diagrams/environment-chain.svg)\n\nIn the chain link mental model, `car` is like examining the payload in the current link—you can see what data it contains without breaking the chain. The `cdr` operation is like following the connection to see the rest of the chain that extends beyond the current link. Finally, `cons` is like forging a new link: you take a payload (the new element) and attach it to an existing chain (the rest of the list), creating a longer chain.\n\nThis mental model helps explain several important properties of Lisp lists. First, accessing the first element (`car`) is always fast—you just look at the payload in the first link. However, accessing the nth element requires following n connections, making list traversal a sequential operation. Second, adding an element to the front (`cons`) is extremely efficient—you're just forging one new link and attaching it to the existing chain. Third, lists naturally share structure—multiple chains can reference the same tail sequence, which is both memory-efficient and enables powerful functional programming patterns.\n\nThe chain link model also illuminates why proper list termination matters. In Lisp, proper lists end with a special \"null\" or \"empty list\" marker, like a chain that terminates with a special end link. Improper lists, by contrast, end with some other value, like a chain where the final link connects to something unexpected instead of the proper termination marker.\n\n### Core List Primitives\n\nThe three fundamental list operations—`car`, `cdr`, and `cons`—provide complete control over list structure construction and deconstruction. These operations must be implemented as built-in functions within our interpreter's global environment, alongside the arithmetic and comparison operators from earlier milestones.\n\n> **Decision: Lisp List Representation Strategy**\n> - **Context**: We need to represent Lisp lists within our Python host language, balancing efficiency, simplicity, and semantic correctness\n> - **Options Considered**: Python lists with special terminator, linked list nodes with explicit pointers, tuple pairs for cons cells\n> - **Decision**: Use Python lists with `None` as the empty list marker, wrapping them in `LispValue` objects\n> - **Rationale**: Python lists provide efficient operations and familiar semantics, while the `None` terminator clearly distinguishes empty lists from other values. This approach leverages the host language's optimized list implementation while maintaining clean Lisp semantics.\n> - **Consequences**: Enables efficient list operations and natural integration with Python's garbage collector, but requires careful handling of proper vs improper list distinctions\n\n| Representation Strategy | Implementation Efficiency | Semantic Correctness | Host Language Integration |\n|------------------------|---------------------------|---------------------|--------------------------|\n| Python lists + None terminator | High (native operations) | Good (clear empty list) | Excellent (natural fit) |\n| Explicit cons cell objects | Medium (pointer traversal) | Excellent (true Lisp semantics) | Poor (manual memory management) |\n| Tuple pairs (head, tail) | Low (immutable recreation) | Excellent (functional purity) | Medium (tuple overhead) |\n\nThe `car` function extracts the first element from a list, corresponding to the \"head\" of the chain. It must handle several important cases: non-empty lists return their first element, empty lists should trigger an error since they have no first element, and non-list arguments should also trigger a type error. The implementation must unwrap the `LispValue` container to access the underlying Python list, then rewrap the first element as a `LispValue` for return.\n\n| Function | Parameters | Returns | Description | Error Conditions |\n|----------|------------|---------|-------------|------------------|\n| `builtin_car` | `args: List[LispValue]` | `LispValue` | Returns first element of list | Empty list, non-list argument, wrong arity |\n| `builtin_cdr` | `args: List[LispValue]` | `LispValue` | Returns rest of list after first element | Non-list argument, wrong arity |\n| `builtin_cons` | `args: List[LispValue]` | `LispValue` | Creates new list with element prepended | Wrong arity |\n| `builtin_list` | `args: List[LispValue]` | `LispValue` | Creates proper list from arguments | Never fails |\n| `builtin_null_p` | `args: List[LispValue]` | `LispValue` | Tests if argument is empty list | Wrong arity |\n\nThe `cdr` function returns the \"rest\" of a list after removing the first element. For a list with multiple elements, `cdr` returns a new list containing all elements except the first. For a single-element list, `cdr` returns the empty list. Like `car`, attempting to take the `cdr` of an empty list should trigger an error, as should passing a non-list argument.\n\nThe `cons` function constructs a new list by prepending an element to an existing list. This is the fundamental list construction operation in Lisp. The first argument becomes the new first element, and the second argument should be a list that becomes the rest of the new list. If the second argument is not a list, the result is an \"improper list\"—a valid Lisp data structure but one that doesn't terminate properly with the empty list.\n\n> The key insight about cons is that it always creates sharing—the new list shares its tail with the original list passed as the second argument. This structural sharing is both memory-efficient and enables powerful functional programming patterns where operations create new data structures without copying entire trees.\n\nAdditional list utilities enhance the programmer's toolkit. The `list` function provides a convenient way to create proper lists from a variable number of arguments, equivalent to repeatedly calling `cons` with a final argument of the empty list. The `null?` predicate (often written with a question mark in Lisp convention, though our implementation may use `null_p` for Python compatibility) tests whether a value is the empty list, providing a crucial tool for recursive list processing algorithms.\n\nHere's the algorithmic breakdown for implementing these primitives:\n\n**Car Implementation Algorithm:**\n1. Verify exactly one argument was provided, raising `ArityError` if not\n2. Extract the single argument from the argument list\n3. Check that the argument is a list type using `is_list()`, raising `TypeError` if not\n4. Access the underlying Python list from the `LispValue` wrapper\n5. Check that the list is not empty, raising `EvaluationError` with descriptive message if empty\n6. Extract the first element from the Python list\n7. Return the first element (already a `LispValue`) without additional wrapping\n\n**Cdr Implementation Algorithm:**\n1. Verify exactly one argument was provided, raising `ArityError` if not\n2. Extract the single argument from the argument list\n3. Check that the argument is a list type using `is_list()`, raising `TypeError` if not\n4. Access the underlying Python list from the `LispValue` wrapper\n5. Check that the list is not empty, raising `EvaluationError` if empty\n6. Create a new Python list containing all elements except the first (using slice notation)\n7. Wrap the new Python list in a `LispValue` with `LIST` type and return it\n\n**Cons Implementation Algorithm:**\n1. Verify exactly two arguments were provided, raising `ArityError` if not\n2. Extract the first argument (the new head element) and second argument (the tail)\n3. Check that the second argument is a list type using `is_list()`, raising `TypeError` if not\n4. Access the underlying Python list from the tail `LispValue`\n5. Create a new Python list with the head element followed by all elements from the tail\n6. Wrap the new Python list in a `LispValue` with `LIST` type and return it\n\n### Recursive Function Support\n\nEnabling functions to call themselves by name is essential for implementing algorithms that process nested or variable-sized data structures. Without recursion, programmers cannot write functions that traverse lists of unknown length or process tree-like structures. However, implementing recursion correctly requires careful consideration of how function names are bound within function bodies.\n\nThe challenge lies in the timing of name binding. When a function is defined using `lambda`, its body is parsed but not evaluated until the function is called. At call time, the function body is evaluated in an environment that extends the function's closure environment with parameter bindings. For recursion to work, the function's own name must be accessible within this extended environment.\n\n> **Decision: Recursive Function Name Binding Strategy**\n> - **Context**: Functions need to call themselves by name, but lambda functions are anonymous and define creates bindings after function creation\n> - **Options Considered**: Modify environment during function creation, special recursive lambda form, environment extension during application\n> - **Decision**: Extend the function application environment with the function's own name when a named function calls itself\n> - **Rationale**: This approach maintains the separation between anonymous lambda functions and named function bindings created by define, while ensuring recursive calls can resolve the function name correctly\n> - **Consequences**: Enables natural recursion without complicating lambda semantics, but requires tracking function names and extending environments during application\n\n| Recursion Strategy | Lambda Simplicity | Define Semantics | Implementation Complexity |\n|-------------------|------------------|------------------|--------------------------|\n| Name binding during application | Preserved (lambdas remain anonymous) | Clean (define binds after creation) | Medium (conditional binding) |\n| Self-referential closure capture | Complicated (lambdas become self-aware) | Complex (binding before creation) | High (circular references) |\n| Special recursive lambda form | Preserved (separate constructs) | Clean (define unchanged) | Low (new special form) |\n\nThe implementation strategy extends the function application process to include recursive name binding when appropriate. During function application, after creating the new environment with parameter bindings but before evaluating the function body, we check if the function has a name (indicating it was bound by `define`). If so, we add a binding from that name to the function itself in the application environment.\n\n**Recursive Function Application Algorithm:**\n1. Begin with the standard function application process through parameter binding\n2. Create a new environment extending the function's closure environment\n3. Bind each parameter name to its corresponding evaluated argument value\n4. Check if the function has a name (stored in the `LispFunction.name` field)\n5. If the function is named, add a binding from that name to the function itself in the new environment\n6. Evaluate the function body in this enhanced environment with recursive name binding\n7. Return the result of body evaluation, allowing recursive calls to resolve correctly\n\nThis approach ensures that recursive functions work naturally while preserving the clean semantics of both `lambda` and `define`. Anonymous lambda functions remain anonymous—they cannot call themselves recursively unless they're first bound to a name via `define`. Named functions created through `define` automatically gain the ability to call themselves recursively.\n\nConsider this example evaluation trace for a recursive factorial function:\n\n```\n(define factorial (lambda (n) (if (= n 0) 1 (* n (factorial (- n 1))))))\n(factorial 3)\n```\n\nWhen `factorial` is called with argument 3, the application algorithm creates a new environment extending the global environment (where `factorial` is defined) with the binding `n -> 3`. Since the function has the name \"factorial\", it also adds the binding `factorial -> <function object>`. When the function body evaluates the recursive call `(factorial (- n 1))`, the name lookup for \"factorial\" succeeds in finding the function in the application environment.\n\n### Tail Call Optimization Strategy\n\nRecursive functions can quickly exhaust the call stack when processing large data structures. In languages without tail call optimization, each recursive call consumes additional stack space, leading to stack overflow errors for deep recursions. Tail call optimization recognizes when a function call is in \"tail position\"—the last operation before returning—and reuses the current stack frame instead of creating a new one.\n\nA function call is in tail position when its return value becomes the return value of the calling function without any additional computation. In the expression `(* n (factorial (- n 1)))`, the call to `factorial` is **not** in tail position because its result must be multiplied by `n` before returning. However, in a tail-recursive factorial implementation like `(factorial-helper (- n 1) (* acc n))`, the recursive call is in tail position because its result is returned directly.\n\n> **Decision: Tail Call Optimization Implementation Approach**\n> - **Context**: Deep recursion causes stack overflow in the Python host language, limiting the practical use of recursive Lisp functions\n> - **Options Considered**: Trampoline with continuation passing, iterative loop transformation, Python stack frame manipulation\n> - **Decision**: Implement trampoline-style optimization with explicit continuation objects for tail calls\n> - **Rationale**: Trampolines provide clean tail call semantics without relying on host language features, work reliably across Python implementations, and maintain clear separation between tail and non-tail calls\n> - **Consequences**: Enables deep recursion for tail calls while maintaining stack safety, but adds complexity to function application and requires tail position detection\n\n| Optimization Strategy | Stack Safety | Implementation Complexity | Host Language Independence |\n|---------------------|-------------|-------------------------|---------------------------|\n| Trampoline with continuations | Complete (constant stack) | High (continuation objects) | Excellent (pure Python) |\n| Python recursion limit increase | Partial (configurable limit) | Low (simple setting) | Poor (Python-specific) |\n| Iterative transformation | Complete (no recursion) | Very High (complex analysis) | Good (general technique) |\n\nThe trampoline optimization works by detecting when a function call is in tail position and, instead of immediately executing the call, returning a special \"continuation\" object that describes the call to be made. The main evaluation loop checks for continuation objects and executes them iteratively, effectively converting tail recursion into iteration.\n\n**Tail Call Detection Algorithm:**\n1. During function body evaluation, track whether the current expression is in tail position\n2. The body of a function is initially in tail position (its result is the function's result)\n3. For conditional expressions (`if`), both the consequent and alternative are in tail position\n4. For function calls in tail position, create a `TailCall` continuation object instead of immediate evaluation\n5. Return the continuation object to the evaluation loop for iterative processing\n6. For non-tail calls, evaluate immediately using the standard recursive evaluation\n\n**Trampoline Execution Algorithm:**\n1. Begin function application with normal parameter binding and environment extension\n2. Evaluate the function body in the application environment\n3. If the result is a `TailCall` continuation, enter the trampoline loop\n4. Extract the function and arguments from the continuation object\n5. Perform the tail call by updating the environment and re-evaluating with new arguments\n6. Continue the loop until a non-continuation result is produced\n7. Return the final result, having executed all tail calls iteratively\n\nThe trampoline approach requires modifications to both the evaluation engine and the function application logic. The evaluator must detect tail position contexts and generate continuation objects appropriately. The function application logic must recognize continuation objects and execute the trampoline loop instead of immediately returning results.\n\n| Tail Call Context | Tail Position | Optimization Applied |\n|-------------------|---------------|---------------------|\n| `(func args...)` at end of function body | Yes | Create continuation |\n| `(if test (func args...) other)` | Yes (both branches) | Create continuation |\n| `(+ 1 (func args...)))` | No (result used in addition) | Standard evaluation |\n| `((lambda (x) (func x)) arg)` | Yes (lambda body tail) | Create continuation |\n\n### Common List Operation Pitfalls\n\nList operations in Lisp present several common pitfalls that can lead to subtle bugs or runtime errors. Understanding these pitfalls helps developers write more robust code and debug issues more effectively.\n\n⚠️ **Pitfall: Confusing Empty List with False**\n\nMany developers coming from other languages assume that empty lists are \"falsy\" in conditional expressions. In Lisp, only the explicit false value (`#f` or `nil` depending on dialect) is false—empty lists are truthy. This leads to incorrect conditional logic when checking for list termination.\n\nThe problematic pattern appears in recursive functions that process lists:\n```\n(define process-list (lambda (lst)\n  (if lst  ; WRONG: empty list is truthy\n      (cons (process-element (car lst)) (process-list (cdr lst)))\n      '())))\n```\n\nThis function will attempt to call `car` and `cdr` on the empty list, causing runtime errors. The correct approach uses the `null?` predicate to explicitly test for the empty list:\n```\n(define process-list (lambda (lst)\n  (if (null? lst)  ; CORRECT: explicit empty list test\n      '()\n      (cons (process-element (car lst)) (process-list (cdr lst))))))\n```\n\nTo avoid this pitfall, always use `null?` when testing for list termination in recursive functions. Never rely on implicit truthiness of lists for termination conditions.\n\n⚠️ **Pitfall: Improper List Construction**\n\nDevelopers sometimes create \"improper lists\" by passing non-list values as the second argument to `cons`. While improper lists are valid Lisp data structures, they cannot be processed by functions that expect proper lists, leading to confusing errors.\n\nAn improper list results when the final `cdr` is not the empty list:\n```\n(cons 1 (cons 2 3))  ; Creates improper list (1 2 . 3)\n```\n\nMany list processing functions assume proper list structure and will fail when encountering improper lists. The `length` function, for example, may enter an infinite loop or crash when processing improper lists because it expects to eventually reach the empty list terminator.\n\nTo avoid this pitfall, always ensure that the second argument to `cons` is either the empty list or another proper list. When building lists programmatically, use the `list` function instead of nested `cons` calls, or ensure that your recursive list construction always terminates with the empty list.\n\n⚠️ **Pitfall: Stack Overflow in Non-Tail Recursive Functions**\n\nRecursive functions that are not tail-recursive will consume stack space proportional to their recursion depth. For large inputs, this leads to stack overflow errors that can be difficult to debug, especially when the overflow occurs deep in a complex computation.\n\nConsider this non-tail-recursive length function:\n```\n(define length (lambda (lst)\n  (if (null? lst)\n      0\n      (+ 1 (length (cdr lst))))))  ; Addition happens after recursive call\n```\n\nFor a list of 10,000 elements, this function will create 10,000 stack frames, likely causing a stack overflow. The recursive call is not in tail position because the addition occurs after the recursive call returns.\n\nThe tail-recursive version avoids this problem by using an accumulator:\n```\n(define length-helper (lambda (lst acc)\n  (if (null? lst)\n      acc\n      (length-helper (cdr lst) (+ acc 1)))))  ; Recursive call in tail position\n\n(define length (lambda (lst) (length-helper lst 0)))\n```\n\nTo avoid stack overflow, write recursive functions in tail-recursive form whenever possible, using accumulator parameters to carry intermediate results forward rather than computing them on the return path.\n\n⚠️ **Pitfall: Mutation vs Structural Sharing Confusion**\n\nLisp lists use structural sharing, where multiple lists can share common tail sections. Developers sometimes expect that modifying one list will affect shared portions, but proper functional programming in Lisp creates new structures rather than modifying existing ones.\n\nThis confusion arises when developers expect reference semantics but encounter value semantics:\n```\n(define original '(1 2 3))\n(define extended (cons 0 original))\n; Developers might expect that changing 'original' affects 'extended'\n; But functional operations create new structures without mutation\n```\n\nThe `cons` operation creates a new list that shares structure with the original, but no operation modifies the original list. If mutation is needed, it requires special functions (like `set-car!` and `set-cdr!` in some Lisps) that explicitly modify existing structure.\n\nTo avoid confusion, remember that standard list operations (`cons`, `car`, `cdr`) are non-mutating and create new structures. If you need to modify existing lists, use explicit mutation functions where available, or create new lists with the desired structure.\n\n⚠️ **Pitfall: Inefficient List Access Patterns**\n\nDevelopers accustomed to array-based languages sometimes write inefficient list processing code by repeatedly accessing elements by index rather than using sequential traversal patterns.\n\nThis inefficient pattern performs redundant traversals:\n```\n(define process-by-index (lambda (lst)\n  (if (null? lst)\n      '()\n      (cons (process-element (list-ref lst 0))  ; Redundant traversal\n            (process-by-index (list-ref lst 1 (length lst)))))))\n```\n\nEach call to `list-ref` traverses the list from the beginning to reach the specified index, making this an O(n²) algorithm for processing an n-element list.\n\nThe efficient approach uses `car` and `cdr` for sequential access:\n```\n(define process-sequentially (lambda (lst)\n  (if (null? lst)\n      '()\n      (cons (process-element (car lst))\n            (process-sequentially (cdr lst))))))\n```\n\nThis version accesses each element exactly once, making it O(n) for processing an n-element list.\n\nTo avoid inefficiency, design list algorithms around sequential traversal using `car` and `cdr` rather than indexed access. When random access is truly needed, consider using vector data structures instead of lists.\n\n### Implementation Guidance\n\nThis section provides Python-specific code structures and complete implementations for the list operation primitives and recursive function support. The code integrates with the existing interpreter architecture established in previous milestones.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| List Representation | Python lists with None terminator | Explicit cons cell classes |\n| Recursion Control | Manual stack depth checking | Full trampoline implementation |\n| Tail Call Detection | Simple tail position tracking | Static analysis with AST annotation |\n| Memory Management | Python garbage collection | Explicit reference counting |\n\n**Recommended File Structure Integration:**\n\n```\nlisp_interpreter/\n  interpreter/\n    evaluator.py              ← extend with list primitives\n    environment.py            ← extend with recursive binding\n    builtins.py              ← add list operation implementations\n    tail_calls.py            ← NEW: tail call optimization\n  tests/\n    test_lists.py            ← NEW: comprehensive list operation tests\n    test_recursion.py        ← NEW: recursive function tests\n```\n\n**Complete List Primitive Implementations:**\n\n```python\n# builtins.py - Complete implementations ready to use\n\nfrom typing import List, Any, Optional\nfrom .data_model import LispValue, LispValueType, EvaluationError, TypeError, ArityError\n\ndef builtin_car(args: List[LispValue]) -> LispValue:\n    \"\"\"Extract the first element from a list.\n    \n    Args:\n        args: Single-element list containing the list to process\n        \n    Returns:\n        The first element of the input list\n        \n    Raises:\n        ArityError: If not exactly one argument provided\n        TypeError: If argument is not a list\n        EvaluationError: If list is empty\n    \"\"\"\n    if len(args) != 1:\n        raise ArityError(expected=1, actual=len(args), function_name=\"car\")\n    \n    lst_value = args[0]\n    if not is_list(lst_value):\n        raise TypeError(f\"car requires a list argument, got {lst_value.type}\")\n    \n    python_list = lst_value.value\n    if not python_list:  # Empty list check\n        raise EvaluationError(\"car: cannot take car of empty list\")\n    \n    return python_list[0]  # First element is already a LispValue\n\ndef builtin_cdr(args: List[LispValue]) -> LispValue:\n    \"\"\"Extract the rest of a list after the first element.\n    \n    Args:\n        args: Single-element list containing the list to process\n        \n    Returns:\n        New list containing all elements except the first\n        \n    Raises:\n        ArityError: If not exactly one argument provided\n        TypeError: If argument is not a list\n        EvaluationError: If list is empty\n    \"\"\"\n    if len(args) != 1:\n        raise ArityError(expected=1, actual=len(args), function_name=\"cdr\")\n    \n    lst_value = args[0]\n    if not is_list(lst_value):\n        raise TypeError(f\"cdr requires a list argument, got {lst_value.type}\")\n    \n    python_list = lst_value.value\n    if not python_list:  # Empty list check\n        raise EvaluationError(\"cdr: cannot take cdr of empty list\")\n    \n    # Create new list with all elements except first\n    rest_list = python_list[1:]\n    return make_list(rest_list)\n\ndef builtin_cons(args: List[LispValue]) -> LispValue:\n    \"\"\"Create a new list by prepending an element to an existing list.\n    \n    Args:\n        args: Two-element list [new_head, existing_tail]\n        \n    Returns:\n        New list with head prepended to tail\n        \n    Raises:\n        ArityError: If not exactly two arguments provided\n        TypeError: If second argument is not a list\n    \"\"\"\n    if len(args) != 2:\n        raise ArityError(expected=2, actual=len(args), function_name=\"cons\")\n    \n    head = args[0]\n    tail = args[1]\n    \n    if not is_list(tail):\n        raise TypeError(f\"cons requires second argument to be a list, got {tail.type}\")\n    \n    # Create new list with head followed by tail elements\n    tail_list = tail.value\n    new_list = [head] + tail_list\n    return make_list(new_list)\n\ndef builtin_list(args: List[LispValue]) -> LispValue:\n    \"\"\"Create a proper list from variable number of arguments.\n    \n    Args:\n        args: Variable number of elements to include in list\n        \n    Returns:\n        New proper list containing all arguments in order\n    \"\"\"\n    return make_list(args)\n\ndef builtin_null_p(args: List[LispValue]) -> LispValue:\n    \"\"\"Test whether argument is the empty list.\n    \n    Args:\n        args: Single-element list containing value to test\n        \n    Returns:\n        LISP_TRUE if argument is empty list, LISP_FALSE otherwise\n        \n    Raises:\n        ArityError: If not exactly one argument provided\n    \"\"\"\n    if len(args) != 1:\n        raise ArityError(expected=1, actual=len(args), function_name=\"null?\")\n    \n    value = args[0]\n    if is_list(value) and not value.value:  # Empty list\n        return LISP_TRUE\n    else:\n        return LISP_FALSE\n\n# Helper function for registering list primitives\ndef register_list_builtins(env: 'Environment') -> None:\n    \"\"\"Register all list operation built-ins in the given environment.\"\"\"\n    list_builtins = {\n        'car': make_builtin(builtin_car, 'car', 1),\n        'cdr': make_builtin(builtin_cdr, 'cdr', 1),\n        'cons': make_builtin(builtin_cons, 'cons', 2),\n        'list': make_builtin(builtin_list, 'list', None),  # Variable arity\n        'null?': make_builtin(builtin_null_p, 'null?', 1),\n    }\n    \n    for name, func in list_builtins.items():\n        env.define(name, func)\n```\n\n**Core Recursive Function Support Skeleton:**\n\n```python\n# environment.py - extend Environment class for recursive binding\n\nclass Environment:\n    def __init__(self, bindings: Dict[str, LispValue] = None, \n                 parent: Optional['Environment'] = None):\n        self.bindings = bindings or {}\n        self.parent = parent\n    \n    def extend_with_recursion(self, new_bindings: Dict[str, LispValue], \n                             function_name: Optional[str] = None,\n                             function_value: Optional[LispValue] = None) -> 'Environment':\n        \"\"\"Create child environment with parameter bindings and optional recursion.\n        \n        Args:\n            new_bindings: Parameter name to argument value mappings\n            function_name: Name of function being called (for recursion)\n            function_value: Function object being called (for recursion)\n            \n        Returns:\n            New environment extending this one with bindings and recursion\n        \"\"\"\n        # TODO 1: Create base child environment with new_bindings\n        # TODO 2: If function_name and function_value provided, add recursive binding\n        # TODO 3: Return the enhanced child environment\n        \n        child_env = Environment(new_bindings.copy(), self)\n        \n        if function_name and function_value:\n            child_env.define(function_name, function_value)\n        \n        return child_env\n\n# evaluator.py - extend apply_function for recursive support\n\ndef apply_function(func: LispValue, args: List[LispValue], \n                  current_env: Environment) -> LispValue:\n    \"\"\"Apply function to arguments with recursive name binding support.\n    \n    Args:\n        func: Function object to call\n        args: Evaluated argument values\n        current_env: Environment for evaluation context\n        \n    Returns:\n        Result of function application\n        \n    Raises:\n        TypeError: If func is not callable\n        ArityError: If argument count doesn't match parameters\n    \"\"\"\n    # TODO 1: Verify func is a function type (user-defined or builtin)\n    # TODO 2: Handle builtin functions (delegate to implementation)\n    # TODO 3: For user functions, create parameter bindings dictionary\n    # TODO 4: Check for function name (stored in LispFunction.name field)\n    # TODO 5: Create application environment with recursive binding if named\n    # TODO 6: Evaluate function body in the application environment\n    # TODO 7: Return evaluation result\n    \n    if not is_function(func):\n        raise TypeError(f\"Cannot call non-function value: {func}\")\n    \n    if is_builtin_function(func):\n        builtin = func.value\n        if builtin.arity is not None and len(args) != builtin.arity:\n            raise ArityError(expected=builtin.arity, actual=len(args), \n                           function_name=builtin.name)\n        return builtin.implementation(args)\n    \n    # User-defined function\n    user_func = func.value\n    if len(args) != len(user_func.parameters):\n        raise ArityError(expected=len(user_func.parameters), actual=len(args),\n                        function_name=user_func.name or \"<anonymous>\")\n    \n    # Create parameter bindings\n    param_bindings = dict(zip(user_func.parameters, args))\n    \n    # Create application environment with recursion support\n    app_env = user_func.closure_env.extend_with_recursion(\n        param_bindings, user_func.name, func\n    )\n    \n    return evaluate(user_func.body, app_env)\n```\n\n**Tail Call Optimization Infrastructure:**\n\n```python\n# tail_calls.py - Complete tail call optimization system\n\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom .data_model import LispValue, Environment\n\n@dataclass\nclass TailCall:\n    \"\"\"Represents a function call in tail position.\"\"\"\n    function: LispValue\n    arguments: List[LispValue]\n    environment: Environment\n\nclass TailCallOptimizer:\n    \"\"\"Manages tail call detection and trampoline execution.\"\"\"\n    \n    def __init__(self):\n        self.in_tail_position = False\n        self.call_depth = 0\n    \n    def is_tail_context(self) -> bool:\n        \"\"\"Check if current evaluation context is in tail position.\"\"\"\n        return self.in_tail_position\n    \n    def enter_tail_context(self):\n        \"\"\"Mark that we're entering a tail position context.\"\"\"\n        self.in_tail_position = True\n    \n    def exit_tail_context(self):\n        \"\"\"Mark that we're leaving tail position context.\"\"\"\n        self.in_tail_position = False\n    \n    def create_tail_call(self, func: LispValue, args: List[LispValue], \n                        env: Environment) -> TailCall:\n        \"\"\"Create a tail call continuation for trampoline execution.\"\"\"\n        return TailCall(function=func, arguments=args, environment=env)\n    \n    def execute_trampoline(self, initial_call: TailCall) -> LispValue:\n        \"\"\"Execute tail calls iteratively using trampoline technique.\n        \n        Args:\n            initial_call: First tail call to execute\n            \n        Returns:\n            Final result after all tail calls complete\n        \"\"\"\n        # TODO 1: Initialize current call with initial_call\n        # TODO 2: Loop while current result is a TailCall continuation\n        # TODO 3: Extract function, arguments, and environment from continuation\n        # TODO 4: Apply function using standard application logic\n        # TODO 5: If result is another TailCall, continue loop\n        # TODO 6: If result is a value, return it as final result\n        # TODO 7: Track iteration count to prevent infinite loops\n        \n        current = initial_call\n        iteration_count = 0\n        max_iterations = 100000  # Prevent infinite loops\n        \n        while isinstance(current, TailCall) and iteration_count < max_iterations:\n            result = apply_function(current.function, current.arguments, \n                                  current.environment)\n            if isinstance(result, TailCall):\n                current = result\n            else:\n                return result\n            iteration_count += 1\n        \n        if iteration_count >= max_iterations:\n            raise EvaluationError(\"Maximum tail call iterations exceeded\")\n        \n        return current if not isinstance(current, TailCall) else LISP_FALSE\n\n# Global optimizer instance\ntail_optimizer = TailCallOptimizer()\n```\n\n**Milestone 4 Validation Checkpoint:**\n\nAfter implementing list operations and recursion, verify your implementation with these tests:\n\n```python\n# Test basic list operations\nassert evaluate_string(\"(car '(1 2 3))\") == make_number(1)\nassert evaluate_string(\"(cdr '(1 2 3))\").value == [make_number(2), make_number(3)]\nassert evaluate_string(\"(cons 0 '(1 2))\").value == [make_number(0), make_number(1), make_number(2)]\nassert evaluate_string(\"(null? '())\") == LISP_TRUE\nassert evaluate_string(\"(null? '(1))\") == LISP_FALSE\n\n# Test recursive functions\nfactorial_def = \"(define fact (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))\"\nevaluate_string(factorial_def)\nassert evaluate_string(\"(fact 5)\") == make_number(120)\n\n# Test list processing recursion\nlength_def = \"(define len (lambda (lst) (if (null? lst) 0 (+ 1 (len (cdr lst))))))\"\nevaluate_string(length_def)\nassert evaluate_string(\"(len '(a b c d))\") == make_number(4)\n```\n\n**Debugging Tips for List Operations:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|-------------|----------------|-----|\n| \"Cannot take car of empty list\" | Recursive function doesn't check for empty list | Add print statements to show list contents before car/cdr | Add `(null? lst)` check before calling car/cdr |\n| Stack overflow in recursion | Function is not tail-recursive | Check if recursive call is last operation | Rewrite with accumulator parameter for tail recursion |\n| \"Expected list, got number\" | Passing non-list to car/cdr/cons | Trace argument types through function calls | Ensure all list operations receive proper lists |\n| Infinite recursion | Missing or incorrect base case | Add debug output showing recursion depth | Fix base case condition (usually `null?` check) |\n| Wrong list length | Improper list structure | Print list structure before processing | Ensure lists end with empty list, not other values |\n\nThe list operations and recursion support complete the core functionality of your Lisp interpreter. With these features, users can process arbitrarily complex nested data structures and implement sophisticated algorithms using functional programming techniques.\n\n\n## Component Interactions and Data Flow\n\n> **Milestone(s):** All milestones (1-4) - component interactions underpin the entire interpreter implementation, from the tokenizer-parser handoff in Milestone 1 through the complex environment and function interactions in Milestones 3-4\n\nThe Lisp interpreter's architecture follows a three-stage pipeline where components must work together seamlessly to transform source text into evaluated results. Understanding how these components interact, how errors propagate between them, and how state persists across evaluations is crucial for building a robust interpreter. This section details the orchestration between the tokenizer, parser, and evaluator, along with the supporting environment and function systems.\n\n### End-to-End Processing Pipeline\n\n#### Mental Model: Assembly Line with Feedback\n\nThink of the interpreter pipeline as a sophisticated manufacturing assembly line where each station (tokenizer, parser, evaluator) performs specialized work on the product, but unlike a simple assembly line, later stations can send feedback upstream and maintain state between processing cycles. Each station has quality control that can halt the entire line when defects are detected, and the final station (evaluator) maintains a workspace (global environment) that remembers previous work.\n\nThe end-to-end processing pipeline represents the complete journey from raw Lisp source text to final evaluation results. This pipeline coordinates the three main components while managing error conditions and state persistence. The pipeline design ensures that each component receives properly formatted input and produces output in the expected format for the next stage.\n\nThe processing pipeline begins when user input arrives, either as a complete program file or as a single expression in a REPL session. The pipeline coordinator validates that the input is not empty and determines whether to process it as a single expression or multiple expressions. For multi-expression input, the coordinator processes each expression sequentially, maintaining state between evaluations.\n\n#### Pipeline Processing Stages\n\nThe first stage involves the tokenizer, which receives the raw text input and produces a stream of `Token` objects. The tokenizer maintains its internal position state and accumulates tokens in its `tokens` list field. The pipeline coordinator calls `tokenize(text)` and receives either a successful token list or a `TokenizerError` exception. The tokenizer's `Scanner` processes each character exactly once, building tokens that contain the original text value, token type classification, and source position for error reporting.\n\nThe second stage feeds the token stream to the parser, which calls `read_expr(tokens, position, depth)` to build the abstract syntax tree. The parser maintains nesting depth tracking to prevent stack overflow and returns a `LispValue` representing the parsed expression along with the updated position in the token stream. The parser handles quote syntax transformation and validates parenthesis balancing during this phase. Any malformed syntax generates a `ParseError` with specific location information.\n\nThe third stage passes the AST to the evaluator via `evaluate(ast, env)`, where the global environment provides access to all previously defined variables and functions. The evaluator dispatches based on the AST's structure, handling self-evaluating expressions, symbol lookups, special forms, and function applications. The evaluator may recursively call itself for subexpressions and can modify the environment through `define` operations or create new local environments for function calls.\n\n#### Data Transformation Flow\n\nThe data transformation flow demonstrates how information changes form at each pipeline stage. The initial input is a string containing Lisp source code with whitespace, comments, and syntactic structure. The tokenizer transforms this into a sequence of classified tokens, each containing a type indicator from `TokenType`, the literal text value, and source position information.\n\n| Stage | Input Format | Output Format | Key Transformations |\n|-------|-------------|---------------|-------------------|\n| Tokenizer | Raw text string | List of `Token` objects | Text → classified tokens with positions |\n| Parser | Token stream | `LispValue` AST | Tokens → nested data structures |\n| Evaluator | AST + Environment | `LispValue` result | AST → computed values |\n\nThe parser transforms the flat token sequence into nested `LispValue` structures that preserve the hierarchical relationship of the original S-expressions. Numbers become `LispValue` objects with `NUMBER` type and parsed numeric values. Symbols become `LispValue` objects with `SYMBOL` type and string names. Lists become `LispValue` objects with `LIST` type containing arrays of nested `LispValue` elements.\n\nThe evaluator transforms the AST into final computed values by applying Lisp evaluation semantics. Self-evaluating expressions like numbers pass through unchanged. Symbol expressions trigger environment lookups that replace the symbol with its bound value. List expressions undergo function application or special form processing, potentially creating new environments or recursive evaluation calls.\n\n#### Pipeline Coordination Logic\n\nThe pipeline coordinator manages the flow between components and handles the complexity of processing multiple expressions. For single-expression input, the coordinator simply chains the three stages sequentially. For multi-expression input, the coordinator must parse the token stream multiple times, evaluating each expression in sequence while maintaining the same global environment.\n\nThe coordinator implements position threading to track progress through the token stream. After parsing one expression, the parser returns both the AST and the updated position. The coordinator uses this position to continue parsing the next expression from the remaining tokens. This approach allows processing multiple expressions like `(define x 10) (+ x 5)` in a single input string.\n\nThe coordinator also manages the global environment lifecycle. For each new processing session, the coordinator either creates a fresh global environment via `create_global_environment()` or reuses an existing environment from a REPL session. The environment persists across expression evaluations within a session, allowing later expressions to reference variables defined in earlier expressions.\n\n> **Decision: Sequential Expression Processing**\n> - **Context**: Multi-expression input requires deciding whether to parse all expressions first then evaluate, or interleave parsing and evaluation\n> - **Options Considered**: Batch processing (parse all, then evaluate all), interleaved processing (parse one, evaluate one, repeat), hybrid approach\n> - **Decision**: Interleaved processing with position threading\n> - **Rationale**: Allows early error detection, supports REPL-style interaction, enables expressions to reference results of previous expressions in the same input\n> - **Consequences**: Requires careful position tracking but provides better user experience and simpler error handling\n\n#### Error Recovery and Continuation\n\nThe pipeline coordinator implements error recovery strategies that allow processing to continue after recoverable errors. When the tokenizer encounters invalid character sequences, it can skip the problematic characters and continue tokenizing the rest of the input. The parser can recover from unbalanced parentheses by skipping to the next complete expression. The evaluator can catch runtime errors and continue processing subsequent expressions.\n\nThe coordinator distinguishes between fatal errors that halt all processing and recoverable errors that affect only the current expression. Tokenizer errors for invalid string literals or numeric formats are typically recoverable. Parser errors for unbalanced parentheses may be recoverable if the parser can find synchronization points. Evaluator errors for undefined variables or type mismatches are usually recoverable, allowing the REPL to continue after displaying the error.\n\nFor batch processing of multiple expressions, the coordinator collects both successful results and error information. This allows users to see which expressions succeeded and which failed, rather than halting at the first error. The coordinator maintains a processing context that tracks the current expression number and source location for comprehensive error reporting.\n\n### Error Propagation Between Components\n\n![Error Handling Flow](./diagrams/error-flow.svg)\n\n#### Mental Model: Quality Control Checkpoints\n\nThink of error handling like quality control checkpoints in a manufacturing process. Each station (tokenizer, parser, evaluator) has specific quality standards it must enforce. When a defect is detected, the station must decide whether to fix it locally, escalate it to a supervisor (error handler), or halt the entire production line. The error information flows upward through management layers, gaining context at each level until it reaches the user with enough detail to understand and fix the problem.\n\nError propagation ensures that problems detected deep in the interpreter pipeline are properly classified, contextualized, and reported to users in actionable form. The interpreter implements a hierarchical error system where each component can generate specific error types, and higher-level coordinators enrich these errors with additional context before presenting them to users.\n\n#### Error Classification Hierarchy\n\nThe interpreter uses a structured error hierarchy that reflects the pipeline architecture. The base `LispError` class provides common functionality for error messages and source location tracking. Each pipeline component defines specific error subclasses that capture the types of problems that component can detect.\n\n| Error Type | Component | Common Causes | Recovery Strategy |\n|------------|-----------|---------------|-------------------|\n| `TokenizerError` | Tokenizer | Invalid characters, unterminated strings | Skip to next token boundary |\n| `ParseError` | Parser | Unbalanced parens, invalid quote syntax | Skip to next complete expression |\n| `EvaluationError` | Evaluator | Runtime errors, type mismatches | Continue with next expression |\n| `NameError` | Evaluator | Undefined variable access | Variable suggestion, continue |\n| `TypeError` | Evaluator | Wrong argument types | Type hint, continue |\n| `ArityError` | Evaluator | Wrong argument count | Expected vs actual count |\n\nThe tokenizer generates `TokenizerError` exceptions when it encounters character sequences that cannot be classified into valid tokens. These include unterminated string literals, invalid numeric formats, or characters that are not valid in any token context. The tokenizer includes the exact character position where the error occurred to enable precise error reporting.\n\nThe parser generates `ParseError` exceptions when token sequences do not conform to valid S-expression syntax. The most common parse errors involve unbalanced parentheses, but the parser also detects malformed quote expressions and unexpected end-of-file conditions. Parse errors include both the token position and a description of what was expected versus what was found.\n\nThe evaluator generates several types of `EvaluationError` subclasses depending on the specific runtime problem. `NameError` occurs when symbol lookup fails in the environment chain. `TypeError` occurs when functions receive arguments of incorrect types. `ArityError` occurs when functions are called with the wrong number of arguments, and includes both expected and actual argument counts.\n\n#### Error Context Enrichment\n\nAs errors propagate up through the pipeline, each level adds contextual information that helps users understand and fix the problem. The tokenizer provides precise character positions. The parser adds information about the syntactic context and expected constructs. The evaluator adds semantic context about the operation being attempted and the values involved.\n\nThe pipeline coordinator performs the final error enrichment by adding source location mapping that translates internal positions back to line and column numbers in the original source. For REPL environments, the coordinator adds session context that shows the expression number and any relevant previous definitions. For file processing, the coordinator adds filename and surrounding code context.\n\n> **Key Insight: Error Context Accumulation**\n> Each pipeline stage adds its own contextual information to errors without losing the lower-level details. This creates rich error messages that help users understand not just what went wrong, but where and why it happened.\n\nThe error enrichment process preserves the original low-level error information while adding higher-level context. A tokenizer error for an unterminated string includes the exact character position where the string started. The parser adds context about whether the string appeared in a function call or special form. The evaluator adds information about what operation was being attempted when the error occurred.\n\n#### Error Reporting Strategies\n\nThe interpreter implements different error reporting strategies depending on the execution context. Interactive REPL sessions emphasize immediate feedback with suggestions for common mistakes. Batch file processing emphasizes comprehensive error collection with source location mapping. Development environments may include additional debugging information like environment dumps and evaluation traces.\n\nFor tokenizer errors, the interpreter reports the problematic character sequence along with suggestions for common fixes. An unterminated string error shows the string content and suggests adding the closing quote. An invalid number format shows the problematic text and suggests valid numeric formats.\n\nFor parser errors, the interpreter reports the syntactic context and suggests structural fixes. An unbalanced parenthesis error shows the nesting depth and suggests where the missing parenthesis should be added. A malformed quote expression shows the problematic syntax and suggests the correct quote form.\n\nFor evaluator errors, the interpreter reports the semantic context and suggests behavioral fixes. An undefined variable error lists similar variable names that are defined. A type error shows the expected and actual types with examples of correct usage. An arity error shows the function signature and suggests the correct argument pattern.\n\n> **Decision: Structured Error Types vs String Messages**\n> - **Context**: Errors can be represented as simple strings or structured objects with specific fields\n> - **Options Considered**: String messages only, structured error objects, hybrid approach with structured data and formatted messages\n> - **Decision**: Structured error objects with formatting methods\n> - **Rationale**: Enables programmatic error handling, supports multiple output formats, allows error analysis tooling\n> - **Consequences**: More complex error handling code but much better user experience and tooling support\n\n#### Error Recovery Mechanisms\n\nThe interpreter implements several error recovery mechanisms that allow processing to continue after errors occur. The tokenizer can skip invalid characters and continue tokenizing the rest of the input. The parser can synchronize at expression boundaries to recover from syntax errors. The evaluator can catch exceptions and continue with the next expression.\n\nTokenizer recovery works by advancing past invalid character sequences until a valid token boundary is found. When the tokenizer encounters an invalid character in normal text, it skips characters until it finds whitespace or a delimiter. When the tokenizer encounters an unterminated string, it can either skip to the end of the line or search for the likely intended closing quote.\n\nParser recovery works by synchronizing at known safe points in the token stream. When the parser encounters an unbalanced parenthesis, it can skip tokens until it finds a matching delimiter or reaches the end of the current expression. The parser maintains a stack of expected closing delimiters to guide its recovery decisions.\n\nEvaluator recovery works by catching exceptions and determining whether they represent recoverable errors or fatal problems. Undefined variable errors are recoverable because they don't affect the interpreter state. Type errors in function calls are recoverable because they don't modify the environment. However, stack overflow or memory exhaustion errors may require terminating the entire session.\n\n### State Management Across Evaluations\n\n#### Mental Model: Persistent Workspace\n\nThink of state management like a craftsperson's workshop that persists between projects. Each time the craftsperson (evaluator) works on a new piece (expression), they have access to all their tools (built-in functions), materials (defined variables), and custom jigs (user-defined functions) from previous work. The workshop layout (global environment) evolves as new tools are acquired and new storage areas (local environments) are created for specific projects, but the fundamental workspace persists and accumulates knowledge over time.\n\nState management in the interpreter ensures that variable bindings and function definitions persist across multiple expression evaluations while maintaining proper scoping rules and supporting nested execution contexts. The state management system must handle global environment persistence, temporary environment creation for function calls, and proper cleanup when execution contexts end.\n\n#### Global Environment Persistence\n\nThe global environment serves as the persistent state repository that maintains variable bindings and function definitions across expression evaluations. The global environment is created once per interpreter session and continues to accumulate bindings as expressions are evaluated. This persistence enables the fundamental Lisp development pattern where functions and variables are defined incrementally and build upon each other.\n\n| State Component | Persistence Scope | Mutation Rules | Cleanup Strategy |\n|-----------------|-------------------|----------------|------------------|\n| Global Environment | Entire session | Additive bindings via define | Manual reset or session restart |\n| Function Closures | Function lifetime | Immutable after creation | Garbage collected with function |\n| Local Environments | Function call | Temporary bindings only | Automatic cleanup on return |\n| Evaluation Stack | Single expression | Call frame management | Automatic unwinding |\n\nThe global environment contains built-in functions that are installed during interpreter initialization via `create_global_environment()`. These built-ins include arithmetic operators like `builtin_add`, `builtin_subtract`, comparison operators like `builtin_less_than`, and list operations like `builtin_car`, `builtin_cdr`. The built-in functions never change during a session and provide the foundational operations for all computation.\n\nUser-defined variables and functions are added to the global environment through `define` special forms. When the evaluator processes a define expression, it calls the environment's `define(name, value)` method to create a new binding in the global scope. These bindings persist for the entire session and can be referenced by subsequent expressions.\n\nThe global environment implements proper shadowing rules where new definitions can replace previous definitions with the same name. When a variable is redefined via `define`, the new binding replaces the old binding in the global environment. However, any existing closures that captured the old binding continue to reference the old value, maintaining lexical scoping semantics.\n\n> **Decision: Global Environment Mutation Strategy**\n> - **Context**: Global environment needs to support incremental definition while maintaining referential integrity\n> - **Options Considered**: Immutable environment with copy-on-write, mutable environment with binding replacement, hybrid approach with immutable bindings\n> - **Decision**: Mutable environment with binding replacement and closure capture\n> - **Rationale**: Supports natural REPL workflow, matches user expectations for variable redefinition, enables incremental development\n> - **Consequences**: More complex closure semantics but natural user experience for interactive development\n\n#### Environment Chain Management\n\nThe interpreter creates temporary environment chains for function calls and local binding constructs like `let`. These temporary environments are linked to parent environments through the `parent` field, creating a chain that supports lexical scoping lookups. The environment chain management ensures that variable lookups search from the most local scope outward to the global scope.\n\nWhen a user-defined function is called, the evaluator creates a new local environment via the parent environment's `extend()` method. This new environment has its `parent` field pointing to the function's closure environment, not the calling environment. This distinction is crucial for maintaining lexical scoping semantics where variables are resolved based on where functions were defined, not where they are called.\n\nThe local environment receives parameter bindings that map the function's parameter names to the evaluated argument values. These parameter bindings shadow any variables with the same names in parent environments. The function body evaluation occurs in this local environment, with any nested function calls creating additional environment layers.\n\nRecursive function calls receive special handling through the `extend_with_recursion(bindings, name, func)` method. This method creates a local environment where the function name is bound to the function itself, enabling recursive calls. The recursive binding uses a self-referential structure where the function's closure environment includes a binding to the function itself.\n\nEnvironment cleanup occurs automatically when function calls complete. Local environments are eligible for garbage collection when no references remain to them. However, closures may capture references to environments, extending their lifetime beyond the original function call. The environment chain management must support this lifetime extension while avoiding memory leaks.\n\n#### Closure Environment Capture\n\nClosures represent the most complex aspect of state management because they capture references to their defining environment that must persist beyond the original scope. When the evaluator processes a `lambda` expression via `handle_lambda(args, env)`, it creates a `LispFunction` object whose `closure_env` field contains a reference to the current environment.\n\nThe closure environment capture process creates a snapshot of the environment chain at the time the lambda is evaluated. This snapshot includes not just the immediate environment bindings, but also references to parent environments that the lambda might need to access. The captured environment chain remains accessible as long as the function object exists.\n\nClosure environment capture interacts with the global environment persistence in subtle ways. If a lambda captures a reference to the global environment, and the global environment is later modified through new `define` operations, the lambda will see the modified global environment. This behavior matches user expectations that functions can access newly defined global variables.\n\nHowever, closure environment capture for local variables works differently. If a lambda captures a reference to a local environment from an enclosing function call, that local environment persists even after the enclosing function returns. This persistence is essential for closures to maintain access to their captured variables, but it requires careful memory management to avoid leaks.\n\n| Capture Scenario | Environment Source | Persistence Rules | Access Behavior |\n|------------------|-------------------|-------------------|-----------------|\n| Global Variable | Global environment | Session lifetime | Sees updates |\n| Local Variable | Function call environment | Extended by closure | Frozen at capture |\n| Parameter Variable | Function parameter environment | Extended by closure | Frozen at capture |\n| Recursive Reference | Self-referential environment | Extended by closure | Enables recursion |\n\nThe closure environment capture mechanism must handle self-referential functions where a lambda needs to call itself recursively. This requires creating an environment where the function name is bound to the function being defined, but the function is not yet complete. The evaluator resolves this circular dependency by creating the function object first, then updating the environment binding to reference the completed function.\n\n#### State Consistency and Isolation\n\nThe interpreter maintains state consistency by ensuring that environment modifications are atomic and that temporary environments do not interfere with persistent state. Global environment modifications through `define` are immediately visible to all subsequent evaluations. Local environment modifications during function calls remain isolated from both the global environment and other concurrent function calls.\n\nState isolation is particularly important for recursive function calls where multiple invocations of the same function create separate local environments. Each recursive call receives its own parameter bindings and local variable space, preventing interference between recursion levels. The environment chain structure naturally provides this isolation by creating separate environment objects for each call.\n\nThe interpreter handles state consistency during error conditions by ensuring that failed evaluations do not leave the environment in an inconsistent state. If an error occurs during the evaluation of a `define` expression, the global environment should not be modified. If an error occurs during function argument evaluation, the function should not be called and no new environment should be created.\n\n> **Key Insight: Environment Lifetime Management**\n> Environments have complex lifetime semantics where local environments may outlive their creating function calls due to closure capture, but the environment chain structure ensures that lookups always traverse the correct sequence of scopes regardless of timing.\n\nThe state management system supports debugging and introspection by maintaining metadata about environment creation and modification. Each environment can track its creation context, parent relationships, and binding history. This metadata enables debugging tools to display environment chains, track variable modifications, and identify closure capture relationships.\n\n### Implementation Guidance\n\nThis section provides practical guidance for implementing the component interactions and data flow management in your Lisp interpreter.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Error Handling | Exception classes with message strings | Structured error objects with source mapping |\n| State Management | Global dictionary for environment | Environment chain with proper scoping |\n| Pipeline Coordination | Sequential function calls | Pipeline coordinator class with recovery |\n| Error Reporting | Print error messages to stdout | Structured error reporting with context |\n\n#### Recommended File Structure\n\n```\nlisp-interpreter/\n  src/\n    interpreter.py           ← main pipeline coordinator\n    errors.py               ← error class hierarchy\n    environment.py          ← environment and state management\n    pipeline.py             ← component interaction logic\n  tests/\n    test_integration.py     ← end-to-end pipeline tests\n    test_errors.py          ← error propagation tests\n    test_state.py           ← state management tests\n```\n\n#### Pipeline Coordinator Infrastructure (Complete)\n\n```python\nfrom typing import List, Optional, Any, Union\nfrom dataclasses import dataclass\nfrom errors import LispError, TokenizerError, ParseError, EvaluationError\nfrom tokenizer import tokenize, Token\nfrom parser import parse\nfrom evaluator import evaluate, create_global_environment\nfrom environment import Environment\n\n@dataclass\nclass EvaluationResult:\n    \"\"\"Result of evaluating a single expression.\"\"\"\n    value: Optional[Any] = None\n    error: Optional[LispError] = None\n    expression_text: str = \"\"\n    \nclass InterpreterSession:\n    \"\"\"Manages state and coordination for a Lisp interpreter session.\"\"\"\n    \n    def __init__(self):\n        self.global_env = create_global_environment()\n        self.expression_count = 0\n        self.evaluation_history = []\n    \n    def evaluate_text(self, text: str) -> List[EvaluationResult]:\n        \"\"\"Evaluate one or more expressions from text input.\"\"\"\n        if not text.strip():\n            return []\n        \n        results = []\n        try:\n            tokens = tokenize(text)\n            position = 0\n            \n            while position < len(tokens) and tokens[position].type != 'EOF':\n                try:\n                    ast, position = self._parse_single_expression(tokens, position)\n                    result = self._evaluate_single_expression(ast, text)\n                    results.append(result)\n                except (ParseError, EvaluationError) as e:\n                    error_result = EvaluationResult(error=e, expression_text=text)\n                    results.append(error_result)\n                    # Try to recover by skipping to next complete expression\n                    position = self._find_next_expression(tokens, position)\n                \n        except TokenizerError as e:\n            # Tokenizer errors are usually fatal for the entire input\n            error_result = EvaluationResult(error=e, expression_text=text)\n            results.append(error_result)\n        \n        return results\n    \n    def _parse_single_expression(self, tokens: List[Token], position: int):\n        \"\"\"Parse a single expression starting at the given position.\"\"\"\n        # TODO 1: Call read_expr with tokens, position, and depth=0\n        # TODO 2: Return the parsed AST and updated position\n        # TODO 3: Handle ParseError exceptions and add context\n        pass\n    \n    def _evaluate_single_expression(self, ast, original_text: str) -> EvaluationResult:\n        \"\"\"Evaluate a single AST node and return the result.\"\"\"\n        # TODO 1: Call evaluate(ast, self.global_env)\n        # TODO 2: Increment self.expression_count\n        # TODO 3: Add result to self.evaluation_history\n        # TODO 4: Return EvaluationResult with value and metadata\n        # TODO 5: Handle EvaluationError exceptions\n        pass\n    \n    def _find_next_expression(self, tokens: List[Token], error_position: int) -> int:\n        \"\"\"Find the start of the next complete expression after an error.\"\"\"\n        # TODO 1: Skip tokens until finding a safe synchronization point\n        # TODO 2: Look for balanced parentheses or top-level expressions\n        # TODO 3: Return position of next expression or EOF\n        pass\n```\n\n#### Error Class Hierarchy (Complete)\n\n```python\nfrom typing import Optional\n\nclass LispError(Exception):\n    \"\"\"Base class for all Lisp interpreter errors.\"\"\"\n    \n    def __init__(self, message: str, source_location: Optional[int] = None):\n        super().__init__(message)\n        self.message = message\n        self.source_location = source_location\n    \n    def with_context(self, context: str) -> 'LispError':\n        \"\"\"Add additional context to the error message.\"\"\"\n        enhanced_message = f\"{context}: {self.message}\"\n        # Create new instance of the same type with enhanced message\n        return self.__class__(enhanced_message, self.source_location)\n\nclass TokenizerError(LispError):\n    \"\"\"Error during tokenization phase.\"\"\"\n    pass\n\nclass ParseError(LispError):\n    \"\"\"Error during parsing phase.\"\"\"\n    pass\n\nclass EvaluationError(LispError):\n    \"\"\"Base class for evaluation-time errors.\"\"\"\n    pass\n\nclass NameError(EvaluationError):\n    \"\"\"Variable name not found in environment.\"\"\"\n    \n    def __init__(self, name: str, source_location: Optional[int] = None):\n        super().__init__(f\"Undefined variable: {name}\", source_location)\n        self.name = name\n\nclass TypeError(EvaluationError):\n    \"\"\"Type mismatch in operation.\"\"\"\n    \n    def __init__(self, expected: str, actual: str, operation: str, \n                 source_location: Optional[int] = None):\n        message = f\"Type error in {operation}: expected {expected}, got {actual}\"\n        super().__init__(message, source_location)\n        self.expected = expected\n        self.actual = actual\n        self.operation = operation\n\nclass ArityError(EvaluationError):\n    \"\"\"Wrong number of arguments to function.\"\"\"\n    \n    def __init__(self, expected: int, actual: int, function_name: str,\n                 source_location: Optional[int] = None):\n        message = f\"Arity error in {function_name}: expected {expected} arguments, got {actual}\"\n        super().__init__(message, source_location)\n        self.expected = expected\n        self.actual = actual\n        self.function_name = function_name\n```\n\n#### Core Pipeline Logic Skeleton\n\n```python\nclass PipelineCoordinator:\n    \"\"\"Coordinates the three-stage processing pipeline.\"\"\"\n    \n    def __init__(self):\n        self.tokenizer = None  # Will be injected\n        self.parser = None     # Will be injected\n        self.evaluator = None  # Will be injected\n        \n    def process_expression(self, text: str, environment: Environment) -> Any:\n        \"\"\"Process a single expression through the complete pipeline.\"\"\"\n        # TODO 1: Call tokenize(text) and handle TokenizerError\n        # TODO 2: Call parse(tokens) and handle ParseError\n        # TODO 3: Call evaluate(ast, environment) and handle EvaluationError\n        # TODO 4: Add error context at each stage\n        # TODO 5: Return final result or re-raise enriched error\n        pass\n    \n    def enrich_tokenizer_error(self, error: TokenizerError, text: str) -> TokenizerError:\n        \"\"\"Add source context to tokenizer errors.\"\"\"\n        # TODO 1: Extract line and column from error.source_location\n        # TODO 2: Get surrounding context from original text\n        # TODO 3: Create enhanced error message with context\n        # TODO 4: Return new TokenizerError with enhanced message\n        pass\n    \n    def enrich_parser_error(self, error: ParseError, tokens: List[Token]) -> ParseError:\n        \"\"\"Add syntactic context to parser errors.\"\"\"\n        # TODO 1: Identify the token where parsing failed\n        # TODO 2: Determine expected vs actual syntax\n        # TODO 3: Suggest likely fixes (missing parens, etc.)\n        # TODO 4: Return new ParseError with enhanced message\n        pass\n    \n    def enrich_evaluation_error(self, error: EvaluationError, ast: Any) -> EvaluationError:\n        \"\"\"Add semantic context to evaluation errors.\"\"\"\n        # TODO 1: Identify the operation being attempted\n        # TODO 2: Add information about involved values/types\n        # TODO 3: Suggest corrections for common mistakes\n        # TODO 4: Return new EvaluationError with enhanced message\n        pass\n```\n\n#### State Management Core Logic Skeleton\n\n```python\nclass StateManager:\n    \"\"\"Manages interpreter state across multiple evaluations.\"\"\"\n    \n    def __init__(self):\n        self.global_environment = create_global_environment()\n        self.evaluation_count = 0\n        self.debug_mode = False\n        \n    def prepare_evaluation_context(self, ast: Any) -> Environment:\n        \"\"\"Prepare the environment context for evaluating an expression.\"\"\"\n        # TODO 1: Determine if this is a top-level evaluation\n        # TODO 2: Return global_environment for top-level\n        # TODO 3: Handle function call context preparation\n        # TODO 4: Add debugging hooks if debug_mode is enabled\n        pass\n    \n    def finalize_evaluation_context(self, result: Any, environment: Environment):\n        \"\"\"Clean up after evaluation and update persistent state.\"\"\"\n        # TODO 1: Increment evaluation_count\n        # TODO 2: Update global_environment if needed (define operations)\n        # TODO 3: Clean up temporary environments\n        # TODO 4: Record evaluation in history if debugging\n        pass\n    \n    def handle_define_operation(self, name: str, value: Any):\n        \"\"\"Handle global variable definition.\"\"\"\n        # TODO 1: Validate that name is a valid symbol\n        # TODO 2: Call global_environment.define(name, value)\n        # TODO 3: Update any debugging/introspection metadata\n        # TODO 4: Check for redefinition warnings if enabled\n        pass\n```\n\n#### Language-Specific Hints\n\n- Use Python's exception hierarchy naturally - create your error classes as subclasses of the appropriate base exceptions\n- Leverage Python's `dataclasses` for clean data structure definitions with automatic constructors\n- Use `typing` module annotations for better error catching and IDE support\n- Python's `traceback` module can provide source location information for errors\n- Consider using `contextlib.contextmanager` for temporary environment creation\n\n#### Milestone Checkpoint\n\nAfter implementing component interactions:\n\n**Test Command**: `python -m pytest tests/test_integration.py -v`\n\n**Expected Output**: All pipeline coordination tests should pass, showing proper error propagation and state management\n\n**Manual Verification**:\n1. Start your interpreter REPL\n2. Enter `(define x 10)` - should complete without error and remember the binding\n3. Enter `(+ x 5)` - should return 15, showing state persistence\n4. Enter `(undefined-var)` - should show clear error message with suggestions\n5. Enter `(+ 1 2` - should show parse error for unbalanced parentheses\n6. Enter `(+ 1 2 3)` after the error - should recover and return 6\n\n**Signs of Problems**:\n- Errors without useful context messages → improve error enrichment\n- State not persisting between expressions → check environment management\n- Crashes instead of graceful error handling → add more try/catch blocks\n- Inconsistent behavior after errors → implement proper error recovery\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** All milestones (1-4) - error handling is crucial throughout the entire interpreter implementation, from tokenization errors in Milestone 1 to evaluation errors in Milestones 2-4\n\nError handling in a Lisp interpreter presents unique challenges because errors can occur at any of the three pipeline stages, and each stage has different types of failures with different recovery strategies. Unlike simple applications that might crash on error, an interpreter must provide helpful feedback to users debugging their Lisp programs while maintaining system stability. The challenge lies in detecting errors early, preserving enough context to generate meaningful error messages, and determining when to attempt recovery versus when to fail fast.\n\n### Mental Model: The Quality Control Checkpoint System\n\nThink of error handling in the interpreter like a series of quality control checkpoints in a manufacturing pipeline. At each checkpoint (tokenizer, parser, evaluator), inspectors examine the work product and can either pass it to the next station, send it back for repair, or reject it entirely with detailed feedback about what went wrong and where.\n\nJust as quality inspectors need different skills to check raw materials versus assembled components versus finished products, each stage of our interpreter needs specialized error detection appropriate to its inputs and outputs. The tokenizer inspects character sequences for basic validity, the parser examines token arrangements for structural correctness, and the evaluator validates semantic meaning and runtime behavior.\n\nThe key insight is that errors caught early in the pipeline are easier to diagnose and fix than errors that propagate through multiple stages. A malformed string literal detected during tokenization produces a clearer error message than the same problem manifesting as a mysterious evaluation failure several stages later.\n\n### Error Categories and Detection\n\nThe interpreter encounters several distinct categories of errors, each requiring different detection strategies and recovery approaches. Understanding these categories helps design appropriate error handling mechanisms and determines where in the pipeline each type of error should be caught.\n\n**Lexical Errors** occur during tokenization when the scanner encounters character sequences that cannot be converted into valid tokens. These errors happen at the lowest level of processing and typically indicate syntax problems in the source text itself.\n\n| Error Type | Detection Point | Trigger Condition | Example Input | Recovery Strategy |\n|------------|----------------|-------------------|---------------|------------------|\n| Unterminated String | `scan_string()` | EOF reached before closing quote | `\"hello world` | Skip to next token boundary |\n| Invalid Number Format | `scan_number()` | Multiple decimal points or invalid digits | `12.34.56` | Treat as symbol instead |\n| Illegal Character | `scan_all()` | Character not valid in any token type | `@#$%` | Skip character and continue |\n| Unterminated Comment | `scan_comment()` | EOF in multi-line comment block | `/* comment...` | Treat as complete comment |\n\nThe tokenizer detects lexical errors by maintaining state as it scans characters and recognizing when character sequences violate token formation rules. For example, when scanning a string literal, the tokenizer tracks whether it has encountered the opening quote and whether each character until the closing quote is valid or properly escaped.\n\n```python\nclass TokenizerError(LispError):\n    def __init__(self, message, source_location=None, character=None, context=None):\n        super().__init__(message, source_location)\n        self.character = character\n        self.context = context  # surrounding text for context\n```\n\n**Syntactic Errors** occur during parsing when token sequences are structurally invalid according to Lisp grammar rules. The parser detects these errors when token patterns don't match expected S-expression structures.\n\n| Error Type | Detection Point | Trigger Condition | Example Input | Recovery Strategy |\n|------------|----------------|-------------------|---------------|------------------|\n| Unbalanced Parentheses | `read_list()` | EOF with open paren or extra close paren | `(+ 1 2` or `(+ 1 2))` | Skip to next balanced expression |\n| Empty Expression | `parse()` | Empty token stream or only whitespace | `` (empty) | Return special empty value |\n| Malformed Quote | `read_quote_expr()` | Quote followed by EOF | `'` | Treat as symbol literal |\n| Excessive Nesting | `read_expr()` | Nesting depth exceeds maximum | `(((((...))))` | Reject with depth limit error |\n\nThe parser detects syntactic errors by tracking expected tokens based on the current parsing context. When parsing a list, it expects either more expressions or a closing parenthesis. When it encounters EOF or an unexpected token type, it can generate specific error messages about what was expected versus what was found.\n\n```python\nclass ParseError(LispError):\n    def __init__(self, message, source_location=None, expected_token=None, actual_token=None, context_tokens=None):\n        super().__init__(message, source_location)\n        self.expected_token = expected_token\n        self.actual_token = actual_token\n        self.context_tokens = context_tokens  # surrounding tokens for context\n```\n\n**Semantic Errors** occur during evaluation when expressions are syntactically valid but semantically meaningless or violate runtime constraints. The evaluator detects these errors when attempting to perform operations on incompatible types or access undefined variables.\n\n| Error Type | Detection Point | Trigger Condition | Example Input | Recovery Strategy |\n|------------|----------------|-------------------|---------------|------------------|\n| Undefined Variable | `lookup()` | Symbol not found in environment chain | `undefined_var` | Suggest similar names |\n| Type Mismatch | Builtin functions | Operation on incompatible types | `(+ \"hello\" 5)` | Show expected vs actual types |\n| Arity Mismatch | `apply_function()` | Wrong number of arguments | `(+ 1)` for binary + | Show expected vs actual count |\n| Division by Zero | `builtin_divide()` | Zero divisor in arithmetic | `(/ 5 0)` | Return special infinity value |\n| Stack Overflow | `evaluate()` | Recursion depth exceeds limit | Infinite recursion | Detect cycle or depth limit |\n\nSemantic errors are detected by the evaluator and builtin functions as they attempt to perform operations. Each operation has preconditions about the types and values of its arguments, and violations of these preconditions trigger semantic errors.\n\n```python\nclass EvaluationError(LispError):\n    def __init__(self, message, source_location=None, expression=None, environment_context=None):\n        super().__init__(message, source_location)\n        self.expression = expression\n        self.environment_context = environment_context\n\nclass NameError(EvaluationError):\n    def __init__(self, symbol_name, similar_names=None, **kwargs):\n        super().__init__(f\"Undefined variable: {symbol_name}\", **kwargs)\n        self.symbol_name = symbol_name\n        self.similar_names = similar_names or []\n\nclass TypeError(EvaluationError):\n    def __init__(self, operation, expected_type, actual_type, **kwargs):\n        super().__init__(f\"{operation} expected {expected_type}, got {actual_type}\", **kwargs)\n        self.operation = operation\n        self.expected_type = expected_type\n        self.actual_type = actual_type\n\nclass ArityError(EvaluationError):\n    def __init__(self, function_name, expected, actual, **kwargs):\n        super().__init__(f\"{function_name} expects {expected} arguments, got {actual}\", **kwargs)\n        self.function_name = function_name\n        self.expected = expected\n        self.actual = actual\n```\n\n**Runtime Errors** occur during evaluation when operations fail due to resource constraints or system limitations rather than logical errors in the Lisp code. These errors often indicate environmental problems rather than programming mistakes.\n\n| Error Type | Detection Point | Trigger Condition | Example | Recovery Strategy |\n|------------|----------------|-------------------|---------|------------------|\n| Memory Exhaustion | `make_list()` | Insufficient memory for allocation | Huge list creation | Garbage collection trigger |\n| Stack Overflow | `evaluate()` | Call stack exceeds system limits | Deep recursion | Convert to tail call optimization |\n| File I/O Error | File operations | File system access failure | Read nonexistent file | Return error value |\n| Timeout | Long operations | Operation exceeds time limit | Infinite loop detection | Interrupt evaluation |\n\nRuntime errors are detected by monitoring resource usage and system constraints during evaluation. The interpreter can implement safeguards like recursion depth limits, evaluation step counters, and memory usage tracking to detect and prevent resource exhaustion.\n\n> **Key Design Insight**: Error detection should happen as early as possible in the pipeline. A malformed string literal should be caught during tokenization, not discovered later when the evaluator tries to use an invalid token. This principle of \"fail fast\" makes debugging easier because error messages can be more specific about the actual root cause.\n\n### Common Error Detection Pitfalls\n\n⚠️ **Pitfall: Late Error Detection**\nMany interpreter implementations defer error checking until the evaluator, making all errors appear as evaluation failures. This approach loses valuable context about where the error actually originated. For example, detecting an unterminated string literal during evaluation instead of tokenization makes it seem like a semantic error when it's actually a lexical problem.\n\n**Why this is wrong**: Late detection makes error messages confusing and harder to debug. Users see \"evaluation error\" when they have a simple syntax mistake.\n\n**How to fix**: Implement comprehensive error checking at each pipeline stage. The tokenizer should validate all character sequences, the parser should verify structural correctness, and the evaluator should focus on semantic validation.\n\n⚠️ **Pitfall: Generic Error Messages**\nUsing the same error type and message format for all errors makes it difficult for users to understand what went wrong and how to fix it. Generic messages like \"syntax error\" or \"evaluation failed\" provide no actionable information.\n\n**Why this is wrong**: Users need specific information to fix their code. Knowing that a function expects 2 arguments but got 3 is much more helpful than \"function call failed\".\n\n**How to fix**: Create specific error types for different failure modes with detailed context. Include information about what was expected, what was actually found, and suggestions for fixes.\n\n⚠️ **Pitfall: No Error Recovery**\nStopping interpretation after the first error prevents users from discovering multiple problems in their code. This approach is particularly frustrating during development when fixing one error reveals several others.\n\n**Why this is wrong**: Users want to see as many errors as possible in a single run to minimize development iteration cycles.\n\n**How to fix**: Implement error recovery strategies that allow parsing and evaluation to continue after recoverable errors. Skip malformed expressions and attempt to parse the next valid expression.\n\n### User-Friendly Error Reporting\n\nThe primary goal of error reporting is to help users understand what went wrong and how to fix it. This requires translating internal error representations into human-readable messages with sufficient context for debugging. The challenge lies in providing enough information to be helpful without overwhelming users with implementation details.\n\n**Error Message Components** provide the essential information users need to understand and fix errors. Each error message should include several key components arranged in a consistent format that users can learn to interpret quickly.\n\n| Component | Purpose | Example | When to Include |\n|-----------|---------|---------|-----------------|\n| Error Type | Categorizes the kind of problem | `SyntaxError`, `NameError`, `TypeError` | Always |\n| Description | Human-readable explanation of what went wrong | \"Undefined variable 'x'\" | Always |\n| Location | Where in the source code the error occurred | \"Line 5, column 12\" | When source location available |\n| Context | Surrounding code showing the error location | `>>> (+ x 5)` with `x` highlighted | When helpful for disambiguation |\n| Expected vs Actual | What was expected and what was found instead | \"Expected number, got string 'hello'\" | For type and arity errors |\n| Suggestions | Specific recommendations for fixing the error | \"Did you mean 'y'?\" for undefined variable | When applicable |\n\nThe error reporting system builds these components by enriching basic error information as it propagates up through the pipeline stages. Each stage adds context appropriate to its level of processing.\n\n**Error Message Formatting** presents error information in a consistent, scannable format that helps users quickly identify the problem type and location. The format should be familiar to users of other programming languages while accommodating Lisp-specific concepts.\n\n```\nErrorType: Description\n  at expression: (problematic code here)\n  in context: (surrounding code for reference)\n  \n  Expected: (what was expected)\n  Actual: (what was found)\n  \n  Suggestion: (specific recommendation for fixing)\n```\n\nFor example, a type error in arithmetic might appear as:\n\n```\nTypeError: Cannot add string to number\n  at expression: (+ \"hello\" 5)\n  in context: (define result (+ \"hello\" 5))\n  \n  Expected: number for second argument\n  Actual: string \"hello\"\n  \n  Suggestion: Use string concatenation or convert string to number\n```\n\n**Progressive Error Detail** allows users to control how much information they see in error messages. Beginners benefit from verbose explanations while experienced users prefer concise summaries. The interpreter can provide multiple levels of error detail.\n\n| Detail Level | Target Audience | Information Included | Example |\n|-------------|-----------------|---------------------|---------|\n| Concise | Experienced users | Error type and location only | `NameError: 'x' undefined at line 5` |\n| Standard | General users | Type, description, location, context | Full format shown above |\n| Verbose | Beginners | Includes explanation of concepts | Explains what variable binding means |\n| Debug | Developers | Internal state and call stack | Shows environment contents and evaluation steps |\n\n**Error Context Enrichment** adds information as errors flow up through the pipeline stages. Each stage contributes context appropriate to its processing level, building a complete picture of what went wrong and where.\n\nThe tokenizer contributes character-level context:\n- Character position in source text\n- Surrounding characters for context\n- Current tokenizer state when error occurred\n- Partial token being processed\n\nThe parser contributes structural context:\n- Token position in token stream\n- Current parsing context (inside list, after quote, etc.)\n- Partial parse tree built so far\n- Expected token types at error location\n\nThe evaluator contributes semantic context:\n- Expression being evaluated\n- Current environment bindings\n- Call stack for function applications\n- Values of related variables\n\n> **Design Decision: Staged Error Enrichment**\n> - **Context**: Error information needs to be preserved and enhanced as it flows through pipeline stages\n> - **Options Considered**: \n>   1. Collect all context at error detection point\n>   2. Enrich error information at each pipeline stage\n>   3. Defer context collection until error display time\n> - **Decision**: Enrich error information at each pipeline stage\n> - **Rationale**: Each stage has unique context that would be difficult to reconstruct later. Staged enrichment allows each component to contribute its specialized knowledge while preserving information from earlier stages.\n> - **Consequences**: More complex error propagation but much better error messages with complete context from all pipeline stages.\n\n### Error Recovery Strategies\n\nError recovery allows the interpreter to continue processing after encountering errors, enabling users to discover multiple problems in a single run. Different types of errors require different recovery strategies based on their severity and the likelihood of producing meaningful results from continued processing.\n\n**Tokenizer Recovery** handles lexical errors by skipping problematic characters or tokens and attempting to resume normal tokenization. The tokenizer can often recover from localized problems without affecting the rest of the input.\n\n| Error Type | Recovery Strategy | Implementation | Trade-offs |\n|------------|------------------|----------------|------------|\n| Unterminated String | Insert closing quote and continue | Add `\"` token and resume scanning | May misinterpret subsequent text |\n| Invalid Character | Skip character and continue | Advance position and scan next | Character is lost from input |\n| Malformed Number | Treat as symbol instead | Create `SYMBOL` token with full text | May cause later type errors |\n| Invalid Escape | Use literal character | Include backslash in string content | String content may be incorrect |\n\nThe tokenizer implements recovery by detecting error conditions, creating the best possible token representation, and resuming normal scanning from the next character position. Recovery decisions should err on the side of preserving user intent when possible.\n\n**Parser Recovery** handles structural errors by skipping malformed expressions and synchronizing to the next valid parse point. The parser looks for token patterns that indicate expression boundaries and resumes parsing from those points.\n\n| Error Type | Recovery Strategy | Synchronization Points | Result |\n|------------|------------------|----------------------|---------|\n| Unbalanced Parens | Skip to next balanced expression | Top-level expression boundaries | Current expression discarded |\n| Unexpected Token | Skip token and continue | End of current subexpression | Token ignored |\n| Excessive Nesting | Flatten deeply nested structure | Matching closing parentheses | Structure simplified |\n| Malformed Quote | Treat quote as literal symbol | Next complete expression | Quote becomes symbol value |\n\nParser recovery works by maintaining a stack of parsing contexts and using panic mode recovery when errors occur. The parser discards tokens until it finds a synchronization point where it can confidently resume normal parsing.\n\n**Evaluator Recovery** handles semantic errors by providing default values or skipping problematic expressions. Evaluator recovery is more complex because semantic errors often indicate logical problems that affect program correctness.\n\n| Error Type | Recovery Strategy | Default Value | Continuing Evaluation |\n|------------|------------------|---------------|----------------------|\n| Undefined Variable | Use special undefined value | `#<undefined>` | Continue with placeholder |\n| Type Mismatch | Return error value | `#<error>` | Propagate error marker |\n| Arity Error | Use partial application or defaults | Function with remaining params | May produce unexpected results |\n| Division by Zero | Return infinity or NaN | `#<infinity>` | Mathematical convention |\n\nEvaluator recovery must balance the desire to continue processing with the risk of producing meaningless results. Some errors are recoverable (division by zero can return infinity) while others indicate fundamental problems that make continued evaluation unreliable.\n\n> **Key Design Principle**: Recovery strategies should be conservative about correctness. It's better to stop evaluation after a serious semantic error than to continue with potentially incorrect results that might mislead the user about program behavior.\n\n### Edge Case Handling\n\nEdge cases in interpreter design involve boundary conditions, unusual inputs, and resource limitations that can cause unexpected behavior if not handled properly. Robust edge case handling ensures the interpreter behaves predictably across the full range of possible inputs and system conditions.\n\n**Input Boundary Conditions** include empty inputs, extremely large inputs, and inputs at the limits of data type ranges. These conditions test the interpreter's robustness with unusual but valid inputs.\n\n| Edge Case | Detection Point | Handling Strategy | Expected Behavior |\n|-----------|----------------|------------------|-------------------|\n| Empty Source Text | `tokenize()` | Return empty token list | Parse to empty program |\n| Single Character Input | `tokenize()` | Handle as minimal token | Parse to single atom or error |\n| Extremely Long Lines | `scan_all()` | Process incrementally | No memory overflow |\n| Very Deep Nesting | `read_expr()` | Enforce depth limits | Reject beyond threshold |\n| Huge Number Literals | `scan_number()` | Use arbitrary precision or overflow detection | Preserve precision or error |\n| Maximum Length Symbols | `scan_symbol()` | Enforce length limits | Reject or truncate with warning |\n\nThe interpreter handles input boundary conditions by implementing appropriate limits and safeguards. For example, the parser can enforce a maximum nesting depth to prevent stack overflow from deeply nested expressions.\n\n**Numeric Edge Cases** involve arithmetic operations at the boundaries of numeric representation, including overflow, underflow, and special floating-point values.\n\n| Edge Case | Operation | Detection | Handling |\n|-----------|-----------|-----------|----------|\n| Integer Overflow | Addition, multiplication | Result exceeds type limits | Promote to bigger type or arbitrary precision |\n| Division by Zero | Division, modulo | Zero divisor | Return infinity or error value |\n| Negative Zero | Floating-point arithmetic | Sign bit analysis | Preserve IEEE 754 semantics |\n| NaN Propagation | Operations with NaN | NaN input detection | Propagate NaN through calculations |\n| Infinity Arithmetic | Operations with infinity | Infinity input detection | Follow IEEE 754 rules |\n\nNumeric edge cases are handled by implementing proper arithmetic overflow detection and following established conventions for special values. The interpreter can choose between different numeric representations (fixed-precision vs arbitrary-precision) based on its design goals.\n\n**Memory and Resource Limits** protect the interpreter from inputs that could exhaust system resources or cause denial of service. These limits must be high enough for legitimate use while preventing abuse.\n\n| Resource | Limit Type | Threshold | Detection | Action |\n|----------|------------|-----------|-----------|--------|\n| Token Count | Per expression | 10,000 tokens | During tokenization | Reject with error |\n| Parse Tree Depth | Nested expressions | 100 levels | During parsing | Reject with error |\n| Environment Depth | Nested scopes | 1,000 levels | During evaluation | Reject with error |\n| Symbol Table Size | Number of bindings | 100,000 symbols | During definition | Garbage collection |\n| Evaluation Steps | Computation length | 1,000,000 steps | During evaluation | Timeout error |\n| String Length | String literals | 1MB characters | During tokenization | Reject or truncate |\n\nResource limits are implemented by adding counters and checks throughout the interpreter. These limits should be configurable to accommodate different use cases while providing reasonable defaults.\n\n**Concurrent Access Edge Cases** arise when multiple evaluation contexts share mutable state or when the interpreter is used in multi-threaded environments.\n\n| Edge Case | Scenario | Detection | Handling |\n|-----------|----------|-----------|----------|\n| Environment Mutation | Multiple threads modifying global environment | Race condition detection | Synchronization or immutable environments |\n| Shared Function State | Closures with mutable captured variables | Concurrent modification | Copy-on-write or locking |\n| Recursive Environment Access | Function modifying its own closure environment | Cycle detection | Detect and prevent cycles |\n| Resource Contention | Multiple evaluations competing for limited resources | Resource monitoring | Fair scheduling or queueing |\n\nConcurrent access edge cases are handled by careful design of shared data structures and appropriate synchronization mechanisms. Many Lisp interpreters avoid these issues by using immutable data structures and functional programming principles.\n\n### Common Edge Case Pitfalls\n\n⚠️ **Pitfall: Ignoring Numeric Overflow**\nMany interpreter implementations ignore integer overflow, leading to incorrect results for large arithmetic operations. This problem manifests as wrong answers rather than obvious errors, making it particularly dangerous.\n\n**Why this is wrong**: Silent overflow produces incorrect results that users might not notice until they affect program correctness in subtle ways.\n\n**How to fix**: Implement overflow detection in arithmetic operations and either promote to larger numeric types, use arbitrary precision arithmetic, or report overflow errors explicitly.\n\n⚠️ **Pitfall: Unbounded Resource Usage**\nFailing to implement resource limits allows malicious or buggy code to consume unlimited memory, CPU time, or stack space, potentially crashing the interpreter or the entire system.\n\n**Why this is wrong**: Resource exhaustion can make the interpreter unusable and affect other programs on the same system.\n\n**How to fix**: Implement configurable limits on all resource usage: maximum expression depth, evaluation step count, memory allocation, and string lengths. Provide clear error messages when limits are exceeded.\n\n⚠️ **Pitfall: Inconsistent Error Handling**\nDifferent parts of the interpreter handling similar edge cases in different ways creates unpredictable behavior that confuses users and makes debugging difficult.\n\n**Why this is wrong**: Users need consistent behavior to build mental models of how the interpreter works and predict how it will handle unusual situations.\n\n**How to fix**: Establish consistent policies for edge case handling and implement them uniformly across all interpreter components. Document the policies clearly for users.\n\n![Error Handling Flow](./diagrams/error-flow.svg)\n\n### Implementation Guidance\n\nThis subsection provides concrete implementation patterns and code structures for building a robust error handling system in the Lisp interpreter. The focus is on Python-specific approaches that integrate cleanly with the three-stage pipeline architecture.\n\n**Technology Recommendations Table:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Error Types | Python exceptions with inheritance | Custom error hierarchy with structured data |\n| Error Context | String concatenation for messages | Template-based formatting with context objects |\n| Source Location Tracking | Line/column counters | Full source mapping with character ranges |\n| Error Recovery | Basic exception handling | Sophisticated recovery with continuation strategies |\n| Logging | Python logging module | Structured logging with error categorization |\n| User Interface | Plain text error messages | Rich formatting with syntax highlighting |\n\n**Recommended File/Module Structure:**\n\n```\nlisp_interpreter/\n  errors/\n    __init__.py              ← Export all error types\n    base.py                  ← Base error classes and common functionality\n    tokenizer_errors.py      ← Lexical error types and detection\n    parser_errors.py         ← Syntactic error types and recovery\n    evaluator_errors.py      ← Semantic and runtime error types\n    formatting.py            ← Error message formatting and display\n    recovery.py              ← Error recovery strategies\n  tokenizer/\n    scanner.py               ← Integration with error detection\n  parser/\n    parser.py                ← Integration with error recovery\n  evaluator/\n    evaluator.py             ← Integration with semantic error handling\n  utils/\n    source_location.py       ← Source position tracking utilities\n```\n\n**Infrastructure Starter Code (Complete Error Foundation):**\n\n```python\n# errors/base.py - Complete error hierarchy foundation\nfrom typing import Optional, List, Dict, Any\nfrom dataclasses import dataclass\n\n@dataclass\nclass SourceLocation:\n    \"\"\"Tracks position in source text for error reporting.\"\"\"\n    line: int\n    column: int\n    position: int\n    length: int = 1\n    \n    def __str__(self):\n        return f\"line {self.line}, column {self.column}\"\n\nclass LispError(Exception):\n    \"\"\"Base class for all Lisp interpreter errors.\"\"\"\n    def __init__(self, message: str, source_location: Optional[SourceLocation] = None):\n        super().__init__(message)\n        self.message = message\n        self.source_location = source_location\n        self.context_info: Dict[str, Any] = {}\n    \n    def add_context(self, key: str, value: Any) -> 'LispError':\n        \"\"\"Add contextual information to the error.\"\"\"\n        self.context_info[key] = value\n        return self\n    \n    def format_message(self) -> str:\n        \"\"\"Format the complete error message with context.\"\"\"\n        parts = [self.message]\n        \n        if self.source_location:\n            parts.append(f\" at {self.source_location}\")\n        \n        if self.context_info:\n            for key, value in self.context_info.items():\n                parts.append(f\"\\n  {key}: {value}\")\n        \n        return \"\".join(parts)\n\nclass TokenizerError(LispError):\n    \"\"\"Errors occurring during lexical analysis.\"\"\"\n    def __init__(self, message: str, source_location: Optional[SourceLocation] = None, \n                 character: Optional[str] = None, context: Optional[str] = None):\n        super().__init__(message, source_location)\n        self.character = character\n        self.context = context\n\nclass ParseError(LispError):\n    \"\"\"Errors occurring during syntactic analysis.\"\"\"\n    def __init__(self, message: str, source_location: Optional[SourceLocation] = None,\n                 expected_token: Optional[str] = None, actual_token: Optional[str] = None):\n        super().__init__(message, source_location)\n        self.expected_token = expected_token\n        self.actual_token = actual_token\n\nclass EvaluationError(LispError):\n    \"\"\"Errors occurring during semantic evaluation.\"\"\"\n    def __init__(self, message: str, source_location: Optional[SourceLocation] = None,\n                 expression: Optional[Any] = None, environment_context: Optional[Dict] = None):\n        super().__init__(message, source_location)\n        self.expression = expression\n        self.environment_context = environment_context or {}\n\n# Specific evaluation error types\nclass NameError(EvaluationError):\n    \"\"\"Variable or function name not found in environment.\"\"\"\n    def __init__(self, symbol_name: str, similar_names: Optional[List[str]] = None, **kwargs):\n        super().__init__(f\"Undefined variable: {symbol_name}\", **kwargs)\n        self.symbol_name = symbol_name\n        self.similar_names = similar_names or []\n\nclass TypeError(EvaluationError):\n    \"\"\"Type mismatch in operation.\"\"\"\n    def __init__(self, operation: str, expected_type: str, actual_type: str, **kwargs):\n        super().__init__(f\"{operation} expected {expected_type}, got {actual_type}\", **kwargs)\n        self.operation = operation\n        self.expected_type = expected_type\n        self.actual_type = actual_type\n\nclass ArityError(EvaluationError):\n    \"\"\"Function called with wrong number of arguments.\"\"\"\n    def __init__(self, function_name: str, expected: int, actual: int, **kwargs):\n        super().__init__(f\"{function_name} expects {expected} arguments, got {actual}\", **kwargs)\n        self.function_name = function_name\n        self.expected = expected\n        self.actual = actual\n\n# Error recovery utilities\nclass ErrorRecovery:\n    \"\"\"Utilities for error recovery strategies.\"\"\"\n    \n    @staticmethod\n    def skip_to_synchronization_point(tokens: List, position: int, sync_tokens: List[str]) -> int:\n        \"\"\"Skip tokens until reaching a synchronization point.\"\"\"\n        while position < len(tokens) and tokens[position].type not in sync_tokens:\n            position += 1\n        return position\n    \n    @staticmethod\n    def suggest_similar_names(target: str, available_names: List[str], max_suggestions: int = 3) -> List[str]:\n        \"\"\"Suggest similar variable names for undefined variable errors.\"\"\"\n        def edit_distance(s1: str, s2: str) -> int:\n            # Simple Levenshtein distance implementation\n            if len(s1) < len(s2):\n                return edit_distance(s2, s1)\n            \n            distances = range(len(s2) + 1)\n            for i1, c1 in enumerate(s1):\n                new_distances = [i1 + 1]\n                for i2, c2 in enumerate(s2):\n                    if c1 == c2:\n                        new_distances.append(distances[i2])\n                    else:\n                        new_distances.append(1 + min(distances[i2], distances[i2 + 1], new_distances[-1]))\n                distances = new_distances\n            \n            return distances[-1]\n        \n        # Find names with small edit distance\n        candidates = [(name, edit_distance(target, name)) for name in available_names]\n        candidates.sort(key=lambda x: x[1])\n        \n        # Return names within reasonable edit distance\n        suggestions = []\n        for name, distance in candidates[:max_suggestions]:\n            if distance <= max(1, len(target) // 3):  # Allow up to 1/3 character differences\n                suggestions.append(name)\n        \n        return suggestions\n```\n\n**Core Logic Skeleton Code:**\n\n```python\n# errors/formatting.py - Error message formatting (implement the TODOs)\nclass ErrorFormatter:\n    \"\"\"Formats error messages for user-friendly display.\"\"\"\n    \n    def __init__(self, source_text: Optional[str] = None):\n        self.source_text = source_text\n        self.lines = source_text.split('\\n') if source_text else []\n    \n    def format_error(self, error: LispError, detail_level: str = 'standard') -> str:\n        \"\"\"Format a complete error message with appropriate detail level.\n        \n        Args:\n            error: The error to format\n            detail_level: 'concise', 'standard', 'verbose', or 'debug'\n        \n        Returns:\n            Formatted error message string\n        \"\"\"\n        # TODO 1: Create error type header (e.g., \"SyntaxError:\", \"NameError:\")\n        # TODO 2: Add main error description\n        # TODO 3: Add source location if available (line/column)\n        # TODO 4: Add source context (show problematic line with highlighting)\n        # TODO 5: For standard/verbose: add expected vs actual information\n        # TODO 6: For verbose: add explanation of concepts\n        # TODO 7: For debug: add internal state information\n        # TODO 8: Add suggestions for fixing the error\n        # Hint: Use different formatting based on detail_level parameter\n        pass\n    \n    def extract_source_context(self, location: SourceLocation, context_lines: int = 2) -> str:\n        \"\"\"Extract source code context around an error location.\n        \n        Args:\n            location: Source location of the error\n            context_lines: Number of lines before/after to include\n        \n        Returns:\n            Formatted source context with error highlighting\n        \"\"\"\n        # TODO 1: Calculate line range to display (location.line +/- context_lines)\n        # TODO 2: Extract relevant lines from source text\n        # TODO 3: Add line numbers to each line\n        # TODO 4: Highlight the specific error location (underline or arrow)\n        # TODO 5: Format as readable block with consistent indentation\n        # Hint: Use location.column to position the error indicator\n        pass\n    \n    def format_suggestions(self, error: LispError) -> str:\n        \"\"\"Generate helpful suggestions based on error type.\"\"\"\n        # TODO 1: Check error type and provide type-specific suggestions\n        # TODO 2: For NameError: suggest similar variable names\n        # TODO 3: For TypeError: suggest correct types or conversions\n        # TODO 4: For ArityError: show correct function signature\n        # TODO 5: For SyntaxError: suggest common fixes (balanced parens, etc.)\n        # Hint: Use isinstance() to check error types and access specific fields\n        pass\n\n# Integration with tokenizer\nclass SafeScanner:\n    \"\"\"Scanner with integrated error handling and recovery.\"\"\"\n    \n    def __init__(self, text: str):\n        self.text = text\n        self.position = 0\n        self.tokens = []\n        self.errors = []\n    \n    def scan_all(self) -> List[Token]:\n        \"\"\"Main tokenization loop with error recovery.\"\"\"\n        # TODO 1: Initialize position tracking for source locations\n        # TODO 2: Loop through all characters in text\n        # TODO 3: Try to scan next token, catching TokenizerError exceptions\n        # TODO 4: On error: record error, attempt recovery, continue scanning\n        # TODO 5: Add EOF token at end\n        # TODO 6: Return tokens even if errors occurred (for error tolerance)\n        # Hint: Use try/except around individual token scanning operations\n        pass\n    \n    def recover_from_error(self, error: TokenizerError) -> None:\n        \"\"\"Attempt to recover from tokenization error.\"\"\"\n        # TODO 1: Based on error type, choose appropriate recovery strategy\n        # TODO 2: For unterminated string: insert closing quote and continue\n        # TODO 3: For invalid character: skip character and advance position\n        # TODO 4: For malformed number: treat remainder as symbol\n        # TODO 5: Record recovery action for debugging\n        # Hint: Different error types need different recovery strategies\n        pass\n\n# Integration with parser  \nclass SafeParser:\n    \"\"\"Parser with error recovery and synchronization.\"\"\"\n    \n    def __init__(self, max_nesting_depth: int = 100):\n        self.max_nesting_depth = max_nesting_depth\n        self.errors = []\n    \n    def parse(self, tokens: List[Token]) -> Optional[LispValue]:\n        \"\"\"Parse tokens with error recovery.\"\"\"\n        # TODO 1: Try to parse main expression, catching ParseError exceptions\n        # TODO 2: On error: record error, attempt synchronization, continue if possible\n        # TODO 3: Return partial parse results even with errors\n        # TODO 4: Return None only for completely unparseable input\n        # Hint: Use panic mode recovery to skip to next valid expression boundary\n        pass\n    \n    def synchronize_after_error(self, tokens: List[Token], position: int) -> int:\n        \"\"\"Find next synchronization point after parse error.\"\"\"\n        # TODO 1: Define synchronization points (top-level expressions, balanced parens)\n        # TODO 2: Skip tokens until reaching synchronization point\n        # TODO 3: Ensure parentheses are balanced at synchronization point\n        # TODO 4: Return new position to resume parsing\n        # Hint: Look for tokens that clearly start new expressions\n        pass\n\n# Integration with evaluator\nclass SafeEvaluator:\n    \"\"\"Evaluator with comprehensive error handling.\"\"\"\n    \n    def __init__(self):\n        self.evaluation_depth = 0\n        self.max_depth = 1000\n        self.step_count = 0\n        self.max_steps = 1000000\n    \n    def evaluate(self, ast: LispValue, env: Environment) -> LispValue:\n        \"\"\"Evaluate with error detection and resource limits.\"\"\"\n        # TODO 1: Check resource limits (depth, step count) before evaluation\n        # TODO 2: Try evaluation, catching all EvaluationError types\n        # TODO 3: Enrich errors with current evaluation context\n        # TODO 4: For recoverable errors: return error value and continue\n        # TODO 5: For unrecoverable errors: propagate with full context\n        # TODO 6: Update resource usage counters\n        # Hint: Different error types need different handling strategies\n        pass\n    \n    def check_resource_limits(self) -> None:\n        \"\"\"Check if resource limits have been exceeded.\"\"\"\n        # TODO 1: Check current evaluation depth against maximum\n        # TODO 2: Check step count against maximum\n        # TODO 3: Check memory usage if tracking is enabled\n        # TODO 4: Raise appropriate ResourceError if limits exceeded\n        # Hint: Limits should be configurable for different use cases\n        pass\n    \n    def enrich_evaluation_error(self, error: EvaluationError, ast: LispValue, env: Environment) -> EvaluationError:\n        \"\"\"Add evaluation context to error.\"\"\"\n        # TODO 1: Add current expression being evaluated\n        # TODO 2: Add relevant environment bindings\n        # TODO 3: Add call stack information if available\n        # TODO 4: Add suggestions based on error type and context\n        # Hint: Only include context that helps user understand the problem\n        pass\n```\n\n**Milestone Checkpoint:**\n\nAfter implementing error handling:\n\n1. **Test Error Detection**: Run `python -m pytest tests/test_errors.py -v`\n2. **Expected Output**: All error types properly detected and categorized\n3. **Manual Verification**: \n   - Try malformed input: `(+ 1` should show unbalanced parentheses error\n   - Try undefined variable: `undefined_var` should suggest similar names\n   - Try type error: `(+ \"hello\" 5)` should show expected vs actual types\n   - Try arity error: `(+)` should show expected argument count\n\n**Debugging Tips:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|-------------|-----------------|-----|\n| Generic error messages | Using base Exception class | Check error type hierarchy | Use specific error subclasses |\n| Missing error context | Errors not enriched as they propagate | Add logging to error handling paths | Implement context enrichment at each stage |\n| Poor error recovery | Stopping on first error | Check exception handling logic | Implement recovery strategies |\n| Confusing error locations | Source location not tracked properly | Verify position tracking in tokenizer/parser | Fix position threading through pipeline |\n| Resource exhaustion crashes | No resource limits implemented | Monitor memory and stack usage | Add resource limit checks |\n\n\n## Testing Strategy\n\n> **Milestone(s):** All milestones (1-4) - testing strategy provides validation checkpoints for each stage of interpreter development, from tokenization verification in Milestone 1 through complete Lisp program evaluation in Milestone 4\n\n### Mental Model: The Quality Pyramid\n\nThink of interpreter testing as building a **quality pyramid** where each level depends on the stability of the levels below it. At the base, you have unit tests that verify individual components like the tokenizer producing correct tokens from text. In the middle, you have integration tests that verify components work together correctly, like the parser consuming tokenizer output to build proper ASTs. At the top, you have end-to-end tests that validate complete Lisp programs execute with expected results. Just as a pyramid collapses if the foundation is weak, interpreter bugs at lower levels cascade upward and cause confusing failures in higher-level functionality.\n\nThe key insight is that **interpreter testing requires both microscopic precision and telescopic vision**. You need microscopic precision to verify that individual characters become correct tokens, tokens become correct parse trees, and expressions evaluate to correct values. But you also need telescopic vision to verify that complete Lisp programs exhibit the expected computational behavior. Most interpreter bugs manifest as subtle mismatches between expected and actual behavior that only become apparent when you test both the individual components and their orchestrated interactions.\n\nA robust testing strategy for an interpreter must address three fundamental challenges: **component isolation**, **state management across evaluations**, and **error propagation verification**. Component isolation ensures that tokenizer bugs don't mask parser bugs and parser bugs don't mask evaluator bugs. State management testing verifies that variable bindings persist correctly between expressions and that environments maintain proper lexical scoping. Error propagation testing ensures that malformed input produces helpful error messages rather than cryptic crashes or infinite loops.\n\n### Unit Testing by Component\n\nUnit testing for an interpreter requires testing each component of the three-stage pipeline in complete isolation from the others. This isolation is crucial because interpreter components have complex internal logic that can fail in subtle ways, and you need to verify the correctness of each component before testing their interactions.\n\nThe fundamental principle of interpreter unit testing is **property-based verification**: instead of just testing specific inputs and outputs, you verify that each component maintains essential properties that must hold for all valid inputs. For the tokenizer, these properties include position consistency (every token knows its source location), boundary detection (token boundaries align with meaningful text boundaries), and round-trip preservation (concatenating token values reconstructs the original text minus comments and whitespace). For the parser, key properties include structural integrity (parentheses balance correctly), nesting consistency (nested structures have proper depth relationships), and semantic preservation (the AST represents the same computation as the source text). For the evaluator, critical properties include type safety (operations receive arguments of expected types), environment consistency (variable lookups find the correct bindings), and computational correctness (arithmetic and logical operations produce expected results).\n\n#### Tokenizer Unit Testing\n\nTokenizer testing focuses on **boundary detection accuracy** and **token classification correctness**. The tokenizer must correctly identify where tokens begin and end in the source text, classify each token according to its syntactic role, and preserve enough information for error reporting and source location tracking.\n\n**Token Boundary Detection Tests:**\n\n| Test Category | Input Example | Expected Token Sequence | Boundary Challenge |\n|---------------|---------------|------------------------|-------------------|\n| Adjacent Symbols | `abc+def` | `[SYMBOL(\"abc\"), SYMBOL(\"+\"), SYMBOL(\"def\")]` | No whitespace separation |\n| Number-Symbol Boundary | `123abc` | `[NUMBER(123), SYMBOL(\"abc\")]` | Transition from digit to letter |\n| String Literal Boundaries | `\"hello\"world` | `[STRING(\"hello\"), SYMBOL(\"world\")]` | Quote termination |\n| Parenthesis Attachment | `(+ 1 2)` | `[LEFT_PAREN, SYMBOL(\"+\"), NUMBER(1), NUMBER(2), RIGHT_PAREN]` | Parentheses as separate tokens |\n| Quote Shorthand | `'(a b)` | `[QUOTE, LEFT_PAREN, SYMBOL(\"a\"), SYMBOL(\"b\"), RIGHT_PAREN]` | Quote as distinct token |\n\n**Token Classification Tests:**\n\n| Input Pattern | Expected Type | Value Extraction | Classification Rule |\n|---------------|---------------|------------------|-------------------|\n| `42` | `TokenType.NUMBER` | `42` (integer) | All digits |\n| `3.14` | `TokenType.NUMBER` | `3.14` (float) | Digits with decimal point |\n| `-17` | `TokenType.NUMBER` | `-17` (negative integer) | Minus followed by digits |\n| `abc` | `TokenType.SYMBOL` | `\"abc\"` | Letter followed by symbol chars |\n| `+` | `TokenType.SYMBOL` | `\"+\"` | Single operator character |\n| `\"text\"` | `TokenType.STRING` | `\"text\"` | Content between quotes |\n| `(` | `TokenType.LEFT_PAREN` | `\"(\"` | Opening parenthesis |\n| `)` | `TokenType.RIGHT_PAREN` | `\")\"` | Closing parenthesis |\n| `'` | `TokenType.QUOTE` | `\"'\"` | Single quote character |\n\n**Position Tracking Tests:**\n\nPosition tracking verification ensures that every token maintains accurate source location information for error reporting. These tests verify that the `position` field of each `Token` correctly identifies the character offset in the source text where the token begins.\n\n| Source Text | Token | Expected Position | Position Calculation |\n|-------------|-------|------------------|---------------------|\n| `(+ 1 2)` | `LEFT_PAREN` | 0 | First character |\n| `(+ 1 2)` | `SYMBOL(\"+\")` | 1 | After opening paren |\n| `(+ 1 2)` | `NUMBER(1)` | 3 | After space |\n| `  abc` | `SYMBOL(\"abc\")` | 2 | After leading whitespace |\n| `\"hello world\"` | `STRING(\"hello world\")` | 0 | String starts at quote |\n\n**Error Recovery Tests:**\n\nThe tokenizer should handle malformed input gracefully and provide helpful error messages rather than crashing or producing incorrect token sequences.\n\n| Malformed Input | Expected Behavior | Error Type | Recovery Strategy |\n|-----------------|-------------------|------------|------------------|\n| `\"unclosed string` | `TokenizerError` with position | Unterminated string literal | Stop at end of line |\n| `\"bad\\escape\"` | `TokenizerError` with position | Invalid escape sequence | Skip invalid escape |\n| `123.45.67` | `TokenizerError` with position | Invalid number format | Treat as separate tokens |\n| `\\invalid` | `TokenizerError` with position | Invalid character | Skip character, continue |\n\n#### Parser Unit Testing\n\nParser testing focuses on **structural correctness** and **syntactic transformation accuracy**. The parser must correctly build nested data structures from token sequences, handle quote syntax transformation, and detect structural errors like unbalanced parentheses.\n\n**Structural Building Tests:**\n\n| Token Sequence | Expected AST Structure | Structural Challenge |\n|----------------|------------------------|---------------------|\n| `[NUMBER(42)]` | `LispValue(type=NUMBER, value=42)` | Simple atom parsing |\n| `[SYMBOL(\"x\")]` | `LispValue(type=SYMBOL, value=\"x\")` | Symbol atom parsing |\n| `[LEFT_PAREN, RIGHT_PAREN]` | `LispValue(type=LIST, value=[])` | Empty list construction |\n| `[LEFT_PAREN, NUMBER(1), NUMBER(2), RIGHT_PAREN]` | `LispValue(type=LIST, value=[1, 2])` | Simple list construction |\n| `[LEFT_PAREN, LEFT_PAREN, RIGHT_PAREN, RIGHT_PAREN]` | `LispValue(type=LIST, value=[[]])` | Nested list construction |\n\n**Nested Structure Tests:**\n\nTesting deeply nested structures verifies that the recursive descent parser correctly handles arbitrary nesting depths without stack overflow or structural corruption.\n\n| Input Expression | Nesting Depth | Expected Structure | Recursive Challenge |\n|------------------|---------------|-------------------|-------------------|\n| `(((1)))` | 3 | `[[[1]]]` | Triple-nested list |\n| `(a (b (c)))` | 3 | `[a, [b, [c]]]` | Mixed nesting |\n| `((1 2) (3 4))` | 2 | `[[1, 2], [3, 4]]` | Parallel nesting |\n| `(+ (* 2 3) (- 4 1))` | 2 | `[+, [*, 2, 3], [-, 4, 1]]` | Arithmetic nesting |\n\n**Quote Transformation Tests:**\n\nThe parser must correctly transform quote shorthand syntax `'expr` into the expanded form `(quote expr)`.\n\n| Quoted Expression | Expected Transformation | Transformation Rule |\n|-------------------|------------------------|-------------------|\n| `'a` | `(quote a)` | Simple symbol quote |\n| `'(a b)` | `(quote (a b))` | List quote |\n| `'(quote a)` | `(quote (quote a))` | Nested quote |\n| `(f 'x)` | `(f (quote x))` | Quote in function call |\n\n**Parser Error Detection Tests:**\n\nThe parser should detect structural errors and report them with helpful location information.\n\n| Malformed Input | Error Type | Error Message Pattern | Detection Point |\n|-----------------|------------|----------------------|----------------|\n| `(+ 1 2` | `ParseError` | \"Unclosed parenthesis at position X\" | End of token stream |\n| `+ 1 2)` | `ParseError` | \"Unexpected closing parenthesis at position X\" | Unmatched closer |\n| `(())` | Valid | No error | Properly nested |\n| `)` | `ParseError` | \"Unexpected closing parenthesis at position 0\" | Immediate mismatch |\n\n#### Evaluator Unit Testing\n\nEvaluator testing focuses on **semantic correctness** and **type safety**. The evaluator must correctly implement Lisp evaluation rules, maintain environment consistency, and handle both successful computations and error conditions.\n\n**Expression Type Dispatch Tests:**\n\nThe evaluator's main `evaluate` function must correctly identify expression types and dispatch to appropriate handlers.\n\n| Expression | Expression Type | Handler Called | Expected Behavior |\n|------------|----------------|----------------|-------------------|\n| `42` | Self-evaluating number | Direct return | Returns `LispValue(NUMBER, 42)` |\n| `x` | Symbol lookup | Environment lookup | Returns bound value or `NameError` |\n| `(+ 1 2)` | Function call | Function application | Evaluates args, applies function |\n| `(if #t 1 2)` | Special form | Special form handler | Conditional evaluation |\n| `(define x 5)` | Special form | Define handler | Environment binding |\n\n**Arithmetic Operation Tests:**\n\nBuilt-in arithmetic functions must handle various numeric types and argument counts correctly.\n\n| Operation | Arguments | Expected Result | Error Condition |\n|-----------|-----------|----------------|-----------------|\n| `(+ 1 2)` | `[1, 2]` | `3` | None |\n| `(+ 1 2 3)` | `[1, 2, 3]` | `6` | None |\n| `(+)` | `[]` | `0` | None (identity) |\n| `(- 5 2)` | `[5, 2]` | `3` | None |\n| `(-)` | `[]` | `ArityError` | Too few arguments |\n| `(/ 6 2)` | `[6, 2]` | `3` | None |\n| `(/ 1 0)` | `[1, 0]` | `EvaluationError` | Division by zero |\n\n**Comparison Operation Tests:**\n\nComparison functions must handle numeric comparisons and return proper boolean values.\n\n| Comparison | Arguments | Expected Result | Type Requirement |\n|------------|-----------|----------------|------------------|\n| `(< 1 2)` | `[1, 2]` | `LISP_TRUE` | Both numbers |\n| `(> 2 1)` | `[2, 1]` | `LISP_TRUE` | Both numbers |\n| `(= 1 1)` | `[1, 1]` | `LISP_TRUE` | Both numbers |\n| `(< 2 1)` | `[2, 1]` | `LISP_FALSE` | Both numbers |\n| `(< 1 \"x\")` | `[1, \"x\"]` | `TypeError` | Type mismatch |\n\n**Special Form Tests:**\n\nSpecial forms require careful testing because they control evaluation order and environment modification.\n\n| Special Form | Test Input | Expected Behavior | Evaluation Rule |\n|--------------|------------|-------------------|-----------------|\n| `if` | `(if #t 1 2)` | Returns `1` | Evaluates test, then appropriate branch |\n| `if` | `(if #f 1 2)` | Returns `2` | Evaluates test, then appropriate branch |\n| `define` | `(define x 5)` | Binds `x` to `5` | Evaluates value, binds to name |\n| `lambda` | `(lambda (x) x)` | Creates function | Creates closure with parameters |\n| `quote` | `(quote (+ 1 2))` | Returns `(+ 1 2)` unevaluated | No evaluation of argument |\n\n### Integration Testing Strategy\n\nIntegration testing verifies that the tokenizer, parser, and evaluator work correctly together to process complete Lisp expressions from source text to final results. Unlike unit testing, which isolates individual components, integration testing focuses on **component interactions**, **data flow consistency**, and **end-to-end correctness**.\n\nThe core principle of interpreter integration testing is **pipeline validation**: ensuring that data flows correctly through the three-stage pipeline without loss of information or introduction of errors. This requires testing not just that each stage produces correct output, but that the output from each stage serves as correct input to the next stage. For example, the tokenizer must produce tokens that the parser can consume without ambiguity, and the parser must produce AST nodes that the evaluator can process according to Lisp semantics.\n\n#### Pipeline Integration Tests\n\nPipeline integration tests verify the complete flow from source text through tokenization, parsing, and evaluation to final results. These tests ensure that the three components work together seamlessly and that complex expressions evaluate correctly.\n\n**Complete Expression Processing Tests:**\n\n| Source Text | Tokenizer Output | Parser Output | Evaluator Output | Integration Point |\n|-------------|------------------|---------------|------------------|-------------------|\n| `42` | `[NUMBER(42)]` | `LispValue(NUMBER, 42)` | `42` | Simple atom pipeline |\n| `(+ 1 2)` | `[LEFT_PAREN, SYMBOL(\"+\"), NUMBER(1), NUMBER(2), RIGHT_PAREN]` | `[+, 1, 2]` | `3` | Function call pipeline |\n| `'(a b)` | `[QUOTE, LEFT_PAREN, SYMBOL(\"a\"), SYMBOL(\"b\"), RIGHT_PAREN]` | `(quote (a b))` | `(a b)` | Quote transformation pipeline |\n| `(if #t (+ 1 2) 3)` | Token sequence | `[if, #t, [+, 1, 2], 3]` | `3` | Conditional evaluation pipeline |\n\n**Multi-Expression Session Tests:**\n\nThese tests verify that the interpreter maintains consistent state across multiple expression evaluations, particularly for variable definitions and function definitions.\n\n| Expression Sequence | Expected Results | State Changes | Persistence Test |\n|---------------------|------------------|---------------|------------------|\n| `(define x 5)`, `x` | `x`, `5` | `x` bound to `5` | Variable definition persistence |\n| `(define f (lambda (x) (+ x 1)))`, `(f 2)` | `f`, `3` | `f` bound to function | Function definition persistence |\n| `(define x 1)`, `(define x 2)`, `x` | `x`, `x`, `2` | `x` rebound to `2` | Variable redefinition |\n| `(let ((x 1)) x)`, `(define x 2)`, `x` | `1`, `x`, `2` | Local scope, then global | Scope isolation |\n\n**Error Propagation Integration Tests:**\n\nIntegration tests must verify that errors detected at any stage of the pipeline are properly propagated and enriched with contextual information as they move upward through the system.\n\n| Input with Error | Error Source | Expected Error Type | Error Context |\n|------------------|--------------|-------------------|---------------|\n| `\"unclosed` | Tokenizer | `TokenizerError` | Character position in source |\n| `(+ 1 2` | Parser | `ParseError` | Token position and nesting context |\n| `(+ 1 \"x\")` | Evaluator | `TypeError` | Expression context and type info |\n| `undefined_var` | Evaluator | `NameError` | Environment context and suggestions |\n\n#### Environment Integration Tests\n\nEnvironment integration testing verifies that lexical scoping, variable binding, and closure capture work correctly across the complete evaluation pipeline. These tests are crucial because environment management involves complex interactions between the parser (which identifies variable references) and the evaluator (which resolves bindings and creates closures).\n\n**Lexical Scoping Integration Tests:**\n\n| Lisp Program | Expected Result | Scoping Challenge |\n|--------------|----------------|-------------------|\n| `((lambda (x) x) 5)` | `5` | Simple parameter binding |\n| `((lambda (x) ((lambda (y) x) 2)) 1)` | `1` | Nested scope access to outer variable |\n| `(let ((x 1)) (let ((x 2)) x))` | `2` | Variable shadowing |\n| `(let ((x 1)) (let ((y 2)) x))` | `1` | Nested scope access without shadowing |\n\n**Closure Capture Integration Tests:**\n\nThese tests verify that lambda functions correctly capture their lexical environment and can access captured variables even after the defining scope has exited.\n\n| Closure Definition | Usage Context | Expected Behavior | Capture Test |\n|-------------------|---------------|-------------------|--------------|\n| `(let ((x 5)) (lambda () x))` | Call returned function | Returns `5` | Captures local variable |\n| `(let ((x 1)) (let ((x 2)) (lambda () x)))` | Call returned function | Returns `2` | Captures innermost binding |\n| `(define make-adder (lambda (n) (lambda (x) (+ n x))))` | `((make-adder 5) 3)` | Returns `8` | Captures parameter from outer function |\n\n#### State Persistence Integration Tests\n\nState persistence integration tests verify that the global environment correctly maintains variable and function definitions across multiple evaluation cycles, which is essential for REPL-style interaction and building up complex programs incrementally.\n\n**Global Environment Persistence Tests:**\n\n| Evaluation Sequence | Global State After Each Step | Persistence Verification |\n|--------------------|------------------------------|-------------------------|\n| `(define pi 3.14)` | `{pi: 3.14}` | Variable persists |\n| `(define circle-area (lambda (r) (* pi (* r r))))` | `{pi: 3.14, circle-area: <function>}` | Function persists with closure |\n| `(circle-area 2)` | Same as previous | Function application doesn't modify globals |\n\n**Environment Chain Integration Tests:**\n\nThese tests verify that the environment chain correctly supports nested scopes and that variable lookups traverse the chain in the correct order.\n\n| Test Program | Environment Chain Structure | Lookup Path |\n|--------------|----------------------------|-------------|\n| `(let ((x 1)) ((lambda (y) (+ x y)) 2))` | Global → Let → Lambda | `x` found in Let, `y` found in Lambda |\n| `(define x 0) (let ((x 1)) ((lambda () x)))` | Global → Let → Lambda | `x` found in Let (shadows Global) |\n\n### Milestone Validation Checkpoints\n\nMilestone validation checkpoints provide concrete verification criteria for each stage of interpreter development. These checkpoints help learners confirm that their implementation is working correctly before proceeding to the next milestone, preventing the accumulation of bugs that become harder to diagnose in more complex functionality.\n\nEach checkpoint includes **functional tests** (verifying that features work as specified), **regression tests** (ensuring that new features don't break existing functionality), and **integration tests** (confirming that components work together correctly). The checkpoint also includes **debugging guidance** to help learners diagnose common problems that arise at each milestone.\n\n#### Milestone 1 Checkpoint: S-Expression Parser\n\nAfter completing Milestone 1, learners should have a working tokenizer and parser that can convert Lisp source text into nested data structures. The validation checkpoint focuses on structural correctness and error handling.\n\n**Tokenizer Validation Tests:**\n\n| Input Text | Expected Token Stream | Pass/Fail Criteria |\n|------------|----------------------|-------------------|\n| `42` | `[NUMBER(42), EOF]` | Correct number parsing |\n| `hello` | `[SYMBOL(\"hello\"), EOF]` | Correct symbol parsing |\n| `\"world\"` | `[STRING(\"world\"), EOF]` | Correct string parsing |\n| `(+ 1 2)` | `[LEFT_PAREN, SYMBOL(\"+\"), NUMBER(1), NUMBER(2), RIGHT_PAREN, EOF]` | Correct token sequence |\n| `'(a b)` | `[QUOTE, LEFT_PAREN, SYMBOL(\"a\"), SYMBOL(\"b\"), RIGHT_PAREN, EOF]` | Quote handling |\n| `;comment\\n(test)` | `[LEFT_PAREN, SYMBOL(\"test\"), RIGHT_PAREN, EOF]` | Comment removal |\n\n**Parser Validation Tests:**\n\n| Token Stream | Expected AST | Structural Correctness |\n|--------------|--------------|------------------------|\n| `[NUMBER(42), EOF]` | `LispValue(NUMBER, 42)` | Simple atom |\n| `[LEFT_PAREN, RIGHT_PAREN, EOF]` | `LispValue(LIST, [])` | Empty list |\n| `[LEFT_PAREN, NUMBER(1), NUMBER(2), RIGHT_PAREN, EOF]` | `LispValue(LIST, [1, 2])` | Simple list |\n| `[QUOTE, SYMBOL(\"x\"), EOF]` | `LispValue(LIST, [quote, x])` | Quote transformation |\n\n**Error Handling Validation:**\n\n| Malformed Input | Expected Error | Error Quality |\n|-----------------|----------------|---------------|\n| `\"unclosed` | `TokenizerError` with position | Helpful error message |\n| `(unclosed` | `ParseError` with context | Structural error detection |\n| `unexpected)` | `ParseError` with position | Unmatched parenthesis detection |\n\n**Milestone 1 Manual Testing:**\n\n1. Create a simple test program that calls `tokenize()` on various input strings\n2. Verify that each token has the correct type and value\n3. Create a test program that calls `parse()` on token streams\n4. Verify that the resulting AST has the expected nested structure\n5. Test error conditions and verify that helpful error messages are produced\n\n#### Milestone 2 Checkpoint: Basic Evaluation\n\nAfter completing Milestone 2, learners should have a working evaluator that can handle arithmetic operations, comparisons, and conditional expressions. The validation checkpoint focuses on computational correctness and error handling.\n\n**Arithmetic Evaluation Tests:**\n\n| Expression | Expected Result | Correctness Criteria |\n|------------|----------------|----------------------|\n| `42` | `42` | Self-evaluating numbers |\n| `(+ 1 2)` | `3` | Addition operator |\n| `(- 5 2)` | `3` | Subtraction operator |\n| `(* 3 4)` | `12` | Multiplication operator |\n| `(/ 8 2)` | `4` | Division operator |\n| `(+ 1 2 3)` | `6` | Multiple arguments |\n\n**Comparison Evaluation Tests:**\n\n| Expression | Expected Result | Boolean Correctness |\n|------------|----------------|-------------------|\n| `(< 1 2)` | `LISP_TRUE` | Less than comparison |\n| `(> 2 1)` | `LISP_TRUE` | Greater than comparison |\n| `(= 1 1)` | `LISP_TRUE` | Equality comparison |\n| `(< 2 1)` | `LISP_FALSE` | False comparison result |\n\n**Conditional Evaluation Tests:**\n\n| Expression | Expected Result | Control Flow Correctness |\n|------------|----------------|-------------------------|\n| `(if #t 1 2)` | `1` | True branch selection |\n| `(if #f 1 2)` | `2` | False branch selection |\n| `(if (< 1 2) \"yes\" \"no\")` | `\"yes\"` | Computed test condition |\n\n**Milestone 2 Manual Testing:**\n\n1. Create a REPL-style test program that evaluates expressions and prints results\n2. Test all arithmetic operators with various argument patterns\n3. Test all comparison operators with different numeric relationships\n4. Test conditional expressions with both literal and computed test conditions\n5. Verify that type errors produce helpful error messages\n\n#### Milestone 3 Checkpoint: Variables and Functions\n\nAfter completing Milestone 3, learners should have support for variable definitions, lambda functions, and lexical scoping. The validation checkpoint focuses on environment management and closure correctness.\n\n**Variable Definition and Lookup Tests:**\n\n| Expression Sequence | Expected Results | Environment Correctness |\n|--------------------|------------------|------------------------|\n| `(define x 5)`, `x` | `x`, `5` | Variable binding and lookup |\n| `(define x 1)`, `(define x 2)`, `x` | `x`, `x`, `2` | Variable redefinition |\n| `undefined_var` | `NameError` | Undefined variable detection |\n\n**Lambda Function Tests:**\n\n| Expression | Expected Result | Function Correctness |\n|------------|----------------|---------------------|\n| `((lambda (x) x) 5)` | `5` | Identity function |\n| `((lambda (x y) (+ x y)) 1 2)` | `3` | Multi-parameter function |\n| `((lambda () 42))` | `42` | Zero-parameter function |\n\n**Lexical Scoping Tests:**\n\n| Expression | Expected Result | Scoping Correctness |\n|------------|----------------|-------------------|\n| `((lambda (x) ((lambda (y) x) 2)) 1)` | `1` | Closure captures outer variable |\n| `(let ((x 1)) (let ((x 2)) x))` | `2` | Variable shadowing |\n| `(define x 0) ((lambda (x) x) 5)` | `5` | Parameter shadows global |\n\n**Milestone 3 Manual Testing:**\n\n1. Test variable definition and lookup in isolation\n2. Test lambda function creation and application\n3. Test nested function calls with parameter passing\n4. Test closure behavior by creating functions that capture variables\n5. Test let expressions for local variable binding\n\n#### Milestone 4 Checkpoint: List Operations & Recursion\n\nAfter completing Milestone 4, learners should have support for list operations (car, cdr, cons) and recursive function definitions. The validation checkpoint focuses on list manipulation correctness and recursion handling.\n\n**List Primitive Tests:**\n\n| Expression | Expected Result | List Operation Correctness |\n|------------|----------------|---------------------------|\n| `(cons 1 2)` | `(1 . 2)` | Cons cell creation |\n| `(car (cons 1 2))` | `1` | Car extraction |\n| `(cdr (cons 1 2))` | `2` | Cdr extraction |\n| `(list 1 2 3)` | `(1 2 3)` | Proper list construction |\n| `(null? '())` | `LISP_TRUE` | Empty list detection |\n| `(null? '(1))` | `LISP_FALSE` | Non-empty list detection |\n\n**Recursive Function Tests:**\n\n| Function Definition | Test Call | Expected Result | Recursion Correctness |\n|--------------------|-----------|----------------|----------------------|\n| `(define factorial (lambda (n) (if (= n 0) 1 (* n (factorial (- n 1))))))` | `(factorial 5)` | `120` | Basic recursion |\n| `(define length (lambda (lst) (if (null? lst) 0 (+ 1 (length (cdr lst))))))` | `(length '(a b c))` | `3` | List recursion |\n\n**List Processing Integration Tests:**\n\n| Expression | Expected Result | Integration Correctness |\n|------------|----------------|------------------------|\n| `(car '(a b c))` | `a` | Quote and car integration |\n| `(cdr '(a))` | `()` | Single-element list handling |\n| `(cons 'a '(b c))` | `(a b c)` | Cons with proper list |\n\n**Milestone 4 Manual Testing:**\n\n1. Test all list primitives (car, cdr, cons, list, null?) individually\n2. Test recursive function definitions that call themselves\n3. Test list processing functions that combine multiple primitives\n4. Test tail recursion optimization if implemented\n5. Verify that deep recursion doesn't cause stack overflow\n\n### Common Testing Pitfalls\n\n⚠️ **Pitfall: Testing Components in the Wrong Order**\n\nMany learners attempt to test the evaluator before thoroughly testing the tokenizer and parser. This leads to confusing debugging sessions where evaluation bugs mask parsing bugs, and parsing bugs mask tokenization bugs. The symptom is that simple expressions fail to evaluate correctly, but the actual problem is in an earlier pipeline stage.\n\n**Why this is problematic:** Interpreter bugs cascade upward through the pipeline. If the tokenizer produces incorrect tokens, the parser will build incorrect ASTs, and the evaluator will produce incorrect results. Testing the evaluator first means you're debugging three components simultaneously instead of isolating the actual source of the problem.\n\n**How to avoid it:** Always test components in dependency order: tokenizer first, then parser, then evaluator. Don't proceed to integration testing until each component passes its unit tests. Create helper functions that let you inspect intermediate results at each pipeline stage.\n\n⚠️ **Pitfall: Insufficient Edge Case Coverage**\n\nLearners often test only the \"happy path\" scenarios where input is well-formed and operations succeed. They miss edge cases like empty lists, undefined variables, division by zero, deeply nested structures, and malformed input. The symptom is that the interpreter works fine during initial testing but crashes or behaves incorrectly when given unexpected input.\n\n**Why this is problematic:** Real-world Lisp programs contain errors, edge cases, and boundary conditions. An interpreter that only handles perfect input is not robust enough for practical use. Edge case bugs are often the most difficult to diagnose because they manifest in unusual circumstances.\n\n**How to avoid it:** For every feature you implement, create a \"boundary conditions\" test suite that covers empty input, maximum input, malformed input, and type mismatches. Test what happens when operations receive no arguments, too many arguments, or arguments of the wrong type.\n\n⚠️ **Pitfall: Ignoring Error Message Quality**\n\nMany implementations focus on detecting errors correctly but produce cryptic error messages that don't help users understand what went wrong or how to fix it. The symptom is that the interpreter correctly identifies error conditions but users can't diagnose their mistakes from the error output.\n\n**Why this is problematic:** Error messages are part of the user interface. Poor error messages make the interpreter difficult to use and debug, even when the underlying implementation is correct. Users need to understand not just that an error occurred, but where it occurred and how to fix it.\n\n**How to avoid it:** Test error messages as carefully as you test correct behavior. Verify that error messages include source location information, describe what was expected versus what was found, and suggest corrections when possible. Create tests that verify the text content of error messages, not just their error types.\n\n⚠️ **Pitfall: Testing Only Isolated Components**\n\nSome learners thoroughly test individual components but skip integration testing that verifies components work together correctly. The symptom is that individual unit tests pass, but complete expressions fail to evaluate correctly due to data format mismatches or incorrect assumptions about component interfaces.\n\n**Why this is problematic:** Interpreters are complex systems where components must cooperate precisely. The tokenizer must produce tokens in the format the parser expects, and the parser must produce ASTs in the format the evaluator expects. Component interface mismatches only become apparent during integration testing.\n\n**How to avoid it:** After unit testing each component, create integration tests that exercise the complete pipeline from source text to final results. Test that data flows correctly through all three stages and that errors are properly propagated and enriched as they move upward through the system.\n\n### Implementation Guidance\n\nThe testing strategy for a Lisp interpreter requires a structured approach that builds confidence incrementally while providing rapid feedback during development. This implementation guidance provides concrete code structures and testing patterns specifically designed for Python-based interpreter development.\n\n#### Testing Framework Setup\n\n**Testing Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Test Framework | `unittest` (standard library) | `pytest` with fixtures and parameterization |\n| Assertion Library | Built-in `assert` statements | `pytest` assertions with detailed failure output |\n| Test Organization | Single test file per component | Test directory structure with shared fixtures |\n| Coverage Tracking | Manual verification | `coverage.py` with branch coverage reporting |\n| Test Data | Hardcoded strings in tests | External test case files with JSON/YAML |\n\n**Recommended Test Directory Structure:**\n\n```\nlisp-interpreter/\n  src/\n    tokenizer.py      ← Implementation files\n    parser.py\n    evaluator.py\n    environment.py\n    lisp_types.py\n  tests/\n    test_tokenizer.py      ← Unit tests\n    test_parser.py\n    test_evaluator.py\n    test_environment.py\n    test_integration.py    ← Integration tests\n    test_milestones.py     ← Milestone checkpoints\n    fixtures/\n      test_programs.lisp   ← Sample Lisp programs\n      error_cases.json     ← Error test cases\n    helpers/\n      test_utils.py        ← Testing utility functions\n```\n\n#### Unit Testing Infrastructure\n\n**Complete Tokenizer Test Framework:**\n\n```python\nimport unittest\nfrom typing import List\nfrom src.tokenizer import tokenize, Token, TokenType, TokenizerError\n\nclass TokenizerTestCase(unittest.TestCase):\n    \"\"\"Base class providing helper methods for tokenizer testing.\"\"\"\n    \n    def assertTokenSequence(self, text: str, expected_tokens: List[tuple]):\n        \"\"\"Verify that text produces expected token sequence.\n        \n        Args:\n            text: Source text to tokenize\n            expected_tokens: List of (TokenType, value) tuples\n        \"\"\"\n        # TODO 1: Call tokenize(text) and handle any TokenizerError\n        # TODO 2: Compare actual token count with expected count\n        # TODO 3: For each token, verify type and value match expected\n        # TODO 4: Provide detailed failure message showing actual vs expected\n        pass\n    \n    def assertTokenPositions(self, text: str, expected_positions: List[int]):\n        \"\"\"Verify that tokens have correct source positions.\"\"\"\n        # TODO 1: Tokenize the text\n        # TODO 2: Extract position from each token\n        # TODO 3: Compare with expected positions\n        # TODO 4: Account for EOF token position\n        pass\n    \n    def assertTokenizerError(self, text: str, expected_error_pattern: str):\n        \"\"\"Verify that malformed text produces appropriate TokenizerError.\"\"\"\n        # TODO 1: Call tokenize and expect TokenizerError to be raised\n        # TODO 2: Verify error message matches expected pattern\n        # TODO 3: Verify error includes source position information\n        pass\n\nclass TestBasicTokenization(TokenizerTestCase):\n    \"\"\"Test basic token recognition and classification.\"\"\"\n    \n    def test_number_tokens(self):\n        # TODO: Test integer numbers, floating point, negative numbers\n        pass\n    \n    def test_symbol_tokens(self):\n        # TODO: Test identifiers, operators, special symbols\n        pass\n    \n    def test_string_tokens(self):\n        # TODO: Test string literals, escape sequences, unterminated strings\n        pass\n    \n    def test_parenthesis_tokens(self):\n        # TODO: Test left and right parentheses as separate tokens\n        pass\n    \n    def test_quote_tokens(self):\n        # TODO: Test single quote as distinct token\n        pass\n\nclass TestTokenBoundaries(TokenizerTestCase):\n    \"\"\"Test correct identification of token boundaries.\"\"\"\n    \n    def test_adjacent_tokens(self):\n        self.assertTokenSequence(\n            \"abc+def\", \n            [(TokenType.SYMBOL, \"abc\"), (TokenType.SYMBOL, \"+\"), (TokenType.SYMBOL, \"def\")]\n        )\n    \n    def test_whitespace_separation(self):\n        # TODO: Test that whitespace correctly separates tokens\n        pass\n    \n    def test_comment_handling(self):\n        # TODO: Test that comments are ignored and don't appear in token stream\n        pass\n```\n\n**Complete Parser Test Framework:**\n\n```python\nimport unittest\nfrom src.parser import parse, ParseError\nfrom src.lisp_types import LispValue, LispValueType, make_number, make_symbol, make_list\n\nclass ParserTestCase(unittest.TestCase):\n    \"\"\"Base class providing helper methods for parser testing.\"\"\"\n    \n    def assertParseResult(self, text: str, expected_ast: LispValue):\n        \"\"\"Verify that text parses to expected AST structure.\"\"\"\n        # TODO 1: Tokenize the text first\n        # TODO 2: Parse the token stream\n        # TODO 3: Compare AST structure recursively\n        # TODO 4: Handle type differences (numbers, symbols, lists)\n        pass\n    \n    def assertParseError(self, text: str, expected_error_pattern: str):\n        \"\"\"Verify that malformed text produces appropriate ParseError.\"\"\"\n        # TODO 1: Tokenize text and attempt to parse\n        # TODO 2: Expect ParseError to be raised\n        # TODO 3: Verify error message matches pattern\n        # TODO 4: Verify error includes structural context\n        pass\n    \n    def assertASTStructure(self, ast: LispValue, expected_type: LispValueType):\n        \"\"\"Verify AST node has expected type and valid structure.\"\"\"\n        # TODO 1: Check that ast.type matches expected_type\n        # TODO 2: For lists, verify all elements are valid LispValues\n        # TODO 3: For atoms, verify value has correct Python type\n        pass\n\nclass TestBasicParsing(ParserTestCase):\n    \"\"\"Test parsing of basic expression types.\"\"\"\n    \n    def test_atom_parsing(self):\n        self.assertParseResult(\"42\", make_number(42))\n        self.assertParseResult(\"hello\", make_symbol(\"hello\"))\n        # TODO: Add more atom types\n    \n    def test_empty_list_parsing(self):\n        self.assertParseResult(\"()\", make_list([]))\n    \n    def test_simple_list_parsing(self):\n        # TODO: Test lists with atoms, nested lists\n        pass\n    \n    def test_quote_transformation(self):\n        # Expected: 'x becomes (quote x)\n        expected = make_list([make_symbol(\"quote\"), make_symbol(\"x\")])\n        self.assertParseResult(\"'x\", expected)\n\nclass TestNestedParsing(ParserTestCase):\n    \"\"\"Test parsing of deeply nested structures.\"\"\"\n    \n    def test_nested_lists(self):\n        # TODO: Test ((1 2) (3 4)) and similar patterns\n        pass\n    \n    def test_deep_nesting(self):\n        # TODO: Test (((((1))))) type patterns\n        pass\n```\n\n**Complete Evaluator Test Framework:**\n\n```python\nimport unittest\nfrom src.evaluator import evaluate, create_global_environment, EvaluationError\nfrom src.environment import Environment\nfrom src.lisp_types import LispValue, LISP_TRUE, LISP_FALSE\n\nclass EvaluatorTestCase(unittest.TestCase):\n    \"\"\"Base class providing helper methods for evaluator testing.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Create fresh environment for each test.\"\"\"\n        self.env = create_global_environment()\n    \n    def assertEvaluatesTo(self, program: str, expected_result):\n        \"\"\"Verify that program evaluates to expected result.\"\"\"\n        # TODO 1: Parse program text into AST\n        # TODO 2: Evaluate AST in test environment\n        # TODO 3: Compare result with expected value\n        # TODO 4: Handle different result types (numbers, booleans, lists)\n        pass\n    \n    def assertEvaluationError(self, program: str, error_type: type):\n        \"\"\"Verify that program raises expected evaluation error.\"\"\"\n        # TODO 1: Parse program into AST\n        # TODO 2: Attempt evaluation and expect specific error type\n        # TODO 3: Verify error includes helpful context information\n        pass\n    \n    def assertEnvironmentBinding(self, name: str, expected_value):\n        \"\"\"Verify that variable is bound to expected value in environment.\"\"\"\n        # TODO 1: Look up name in current environment\n        # TODO 2: Compare bound value with expected value\n        # TODO 3: Handle case where name is not bound\n        pass\n\nclass TestArithmetic(EvaluatorTestCase):\n    \"\"\"Test arithmetic operator evaluation.\"\"\"\n    \n    def test_addition(self):\n        self.assertEvaluatesTo(\"(+ 1 2)\", 3)\n        self.assertEvaluatesTo(\"(+ 1 2 3)\", 6)\n        # TODO: Test edge cases like (+ ) and (+ 1)\n    \n    def test_subtraction(self):\n        # TODO: Test (- 5 2), (- 10), etc.\n        pass\n    \n    def test_division_by_zero(self):\n        self.assertEvaluationError(\"(/ 1 0)\", EvaluationError)\n\nclass TestVariables(EvaluatorTestCase):\n    \"\"\"Test variable definition and lookup.\"\"\"\n    \n    def test_define_and_lookup(self):\n        # TODO 1: Evaluate (define x 5)\n        # TODO 2: Verify x is bound in environment\n        # TODO 3: Evaluate x and verify it returns 5\n        pass\n    \n    def test_undefined_variable(self):\n        self.assertEvaluationError(\"undefined_var\", NameError)\n\nclass TestFunctions(EvaluatorTestCase):\n    \"\"\"Test lambda functions and application.\"\"\"\n    \n    def test_lambda_creation(self):\n        # TODO: Test that (lambda (x) x) creates function value\n        pass\n    \n    def test_function_application(self):\n        self.assertEvaluatesTo(\"((lambda (x) x) 5)\", 5)\n        # TODO: Test multi-parameter functions\n```\n\n#### Integration Testing Framework\n\n**Complete Pipeline Integration Tests:**\n\n```python\nimport unittest\nfrom src.lisp_interpreter import LispInterpreter, InterpreterSession\n\nclass IntegrationTestCase(unittest.TestCase):\n    \"\"\"Base class for end-to-end interpreter testing.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Create fresh interpreter session for each test.\"\"\"\n        self.interpreter = LispInterpreter()\n        self.session = InterpreterSession()\n    \n    def assertPipelineResult(self, source_text: str, expected_result):\n        \"\"\"Test complete pipeline from source to result.\"\"\"\n        # TODO 1: Process source_text through complete pipeline\n        # TODO 2: Handle tokenization, parsing, and evaluation\n        # TODO 3: Compare final result with expected value\n        # TODO 4: Verify no errors occurred in pipeline\n        pass\n    \n    def assertMultiExpressionSequence(self, expressions: List[str], expected_results: List):\n        \"\"\"Test sequence of expressions with persistent state.\"\"\"\n        # TODO 1: Evaluate each expression in sequence\n        # TODO 2: Verify each result matches expected\n        # TODO 3: Verify state persists between expressions\n        pass\n\nclass TestCompletePrograms(IntegrationTestCase):\n    \"\"\"Test evaluation of complete Lisp programs.\"\"\"\n    \n    def test_arithmetic_programs(self):\n        self.assertPipelineResult(\"(+ (* 2 3) (- 8 3))\", 11)\n        # TODO: Add more complex arithmetic expressions\n    \n    def test_conditional_programs(self):\n        self.assertPipelineResult(\"(if (< 1 2) (+ 1 1) (- 1 1))\", 2)\n        # TODO: Test nested conditionals\n    \n    def test_function_definition_programs(self):\n        program = \"\"\"\n        (define square (lambda (x) (* x x)))\n        (square 4)\n        \"\"\"\n        # TODO: Handle multi-line program evaluation\n        pass\n\nclass TestErrorPropagation(IntegrationTestCase):\n    \"\"\"Test that errors are properly detected and reported.\"\"\"\n    \n    def test_tokenizer_error_propagation(self):\n        # TODO: Test that tokenizer errors include source context\n        pass\n    \n    def test_parser_error_propagation(self):\n        # TODO: Test that parser errors include token context\n        pass\n    \n    def test_evaluator_error_propagation(self):\n        # TODO: Test that evaluation errors include expression context\n        pass\n```\n\n#### Milestone Checkpoint Implementation\n\n**Milestone Validation Test Suite:**\n\n```python\nimport unittest\nfrom tests.helpers.milestone_validator import MilestoneValidator\n\nclass TestMilestone1(unittest.TestCase):\n    \"\"\"Validation tests for Milestone 1: S-Expression Parser.\"\"\"\n    \n    def setUp(self):\n        self.validator = MilestoneValidator(milestone=1)\n    \n    def test_tokenizer_requirements(self):\n        \"\"\"Verify all Milestone 1 tokenizer requirements.\"\"\"\n        test_cases = [\n            (\"42\", \"number parsing\"),\n            (\"hello\", \"symbol parsing\"),\n            ('(+ 1 2)', \"parenthesis and operator parsing\"),\n            (\"'(a b)\", \"quote syntax parsing\"),\n            (\";comment\\n(test)\", \"comment handling\")\n        ]\n        \n        for text, description in test_cases:\n            with self.subTest(text=text, description=description):\n                # TODO: Use validator to check tokenizer output\n                pass\n    \n    def test_parser_requirements(self):\n        \"\"\"Verify all Milestone 1 parser requirements.\"\"\"\n        # TODO: Test nested list construction\n        # TODO: Test quote transformation\n        # TODO: Test error detection for unbalanced parens\n        pass\n    \n    def test_milestone1_integration(self):\n        \"\"\"End-to-end test of complete Milestone 1 functionality.\"\"\"\n        # TODO: Test complete pipeline from text to AST\n        pass\n\nclass TestMilestone2(unittest.TestCase):\n    \"\"\"Validation tests for Milestone 2: Basic Evaluation.\"\"\"\n    \n    def test_arithmetic_evaluation(self):\n        \"\"\"Verify arithmetic operators work correctly.\"\"\"\n        # TODO: Test +, -, *, / operators\n        # TODO: Test multiple arguments\n        # TODO: Test type checking\n        pass\n    \n    def test_comparison_evaluation(self):\n        \"\"\"Verify comparison operators work correctly.\"\"\"\n        # TODO: Test <, >, =, <=, >= operators\n        # TODO: Test boolean result values\n        pass\n    \n    def test_conditional_evaluation(self):\n        \"\"\"Verify if expressions work correctly.\"\"\"\n        # TODO: Test true and false branches\n        # TODO: Test computed test conditions\n        pass\n\n# Similar patterns for Milestone 3 and 4...\n```\n\n**Debugging Helper Implementation:**\n\n```python\ndef debug_pipeline_stages(source_text: str):\n    \"\"\"Debug helper that shows pipeline output at each stage.\"\"\"\n    print(f\"=== Debugging Pipeline for: {source_text} ===\")\n    \n    # Stage 1: Tokenization\n    try:\n        tokens = tokenize(source_text)\n        print(\"Tokens:\", [(t.type, t.value, t.position) for t in tokens])\n    except TokenizerError as e:\n        print(f\"Tokenization failed: {e}\")\n        return\n    \n    # Stage 2: Parsing\n    try:\n        ast = parse(tokens)\n        print(\"AST:\", ast)\n    except ParseError as e:\n        print(f\"Parsing failed: {e}\")\n        return\n    \n    # Stage 3: Evaluation\n    try:\n        env = create_global_environment()\n        result = evaluate(ast, env)\n        print(\"Result:\", result)\n    except EvaluationError as e:\n        print(f\"Evaluation failed: {e}\")\n\ndef validate_milestone_progress(milestone_number: int):\n    \"\"\"Automated validation of milestone completion.\"\"\"\n    # TODO 1: Load test cases for specified milestone\n    # TODO 2: Run all required tests and collect results\n    # TODO 3: Generate pass/fail report with specific feedback\n    # TODO 4: Suggest next steps if tests fail\n    pass\n\n```\n\n\n## Debugging Guide\n\n> **Milestone(s):** All milestones (1-4) - debugging techniques are essential throughout interpreter development, from troubleshooting tokenization issues in Milestone 1 to diagnosing complex evaluation and recursion problems in Milestones 2-4\n\nDebugging interpreters presents unique challenges that differ significantly from debugging typical application software. Unlike traditional programs where you're primarily concerned with business logic and data processing, interpreter debugging requires understanding the meta-level execution: how your code executes other code. This creates a two-layer debugging problem where issues can manifest either in your interpreter's implementation or in the programs being interpreted, and distinguishing between these layers becomes crucial for effective problem resolution.\n\n### Mental Model: The Detective's Multi-Level Investigation\n\nThink of interpreter debugging as a detective investigating a crime scene where the evidence exists on multiple floors of a building. The **surface level** shows symptoms - programs crash, produce wrong results, or hang indefinitely. The **implementation level** reveals how your tokenizer, parser, and evaluator process the problematic code. The **semantic level** exposes whether your interpreter correctly implements Lisp's evaluation rules. A skilled interpreter debugger moves fluidly between these levels, using evidence from one to guide investigation at another, much like a detective who examines physical evidence, witness testimony, and circumstantial patterns to reconstruct what actually happened.\n\nThe fundamental challenge in interpreter debugging is that your primary tool - the debugger - operates on your interpreter's implementation, but the problems you're solving often manifest in the interpreted program's behavior. This requires developing specialized debugging techniques that bridge between the host language (Python) debugger and the interpreted language (Lisp) execution model.\n\n### Interpreter-Specific Debugging Techniques\n\nEffective interpreter debugging requires a toolkit of specialized techniques that provide visibility into the interpretation process itself. Unlike application debugging where you primarily trace data flow and control flow, interpreter debugging demands tracing the **meta-execution**: how your interpreter processes and transforms the input program through each stage of the pipeline.\n\n#### Environment State Inspection\n\nThe environment chain represents the most critical state in your interpreter, as it determines how variables resolve and functions close over their lexical scope. Developing systematic techniques for inspecting environment state transforms debugging from guesswork into methodical investigation.\n\nEnvironment debugging requires understanding that variable lookup failures can occur at multiple points in the environment chain, and the failure location determines both the root cause and the appropriate fix. When a `NameError` occurs, the issue might be an unbound variable, a scoping problem where the variable exists but isn't accessible, or an environment corruption where the chain structure itself is malformed.\n\nThe environment inspection process follows a systematic pattern. First, verify the environment chain structure by tracing parent links from the current environment to the global environment. This reveals whether environments are properly linked and whether the chain terminates correctly at the global environment. Second, examine the bindings at each level to identify where the expected variable should exist and whether it's actually present. Third, trace the variable binding history to understand when and where the variable was defined, and whether subsequent operations might have corrupted or shadowed the binding.\n\n| Environment Debugging Operation | Information Revealed | When to Use |\n|--------------------------------|----------------------|-------------|\n| Chain traversal inspection | Environment linkage correctness | `NameError` with variables that should exist |\n| Binding enumeration at level | What variables exist in specific scope | Scoping problems and shadowing issues |\n| Parent environment verification | Environment creation correctness | Function calls producing wrong scope |\n| Closure environment inspection | Captured environment correctness | Functions accessing wrong variable values |\n| Global environment baseline check | Built-in function availability | Missing or corrupted standard functions |\n\n#### Evaluation Trace Generation\n\nEvaluation tracing provides visibility into how expressions are processed through the evaluation engine, revealing the decision tree that leads to final results or errors. Unlike simple logging, evaluation tracing must capture both the **structural transformation** of expressions and the **contextual changes** in environment state.\n\nThe key insight for evaluation tracing is that every evaluation step involves three components: the **input expression** being evaluated, the **environment context** in which evaluation occurs, and the **evaluation rule** that determines how the expression is processed. Effective tracing captures all three components, allowing you to reconstruct the exact evaluation path that led to any particular result or failure.\n\nEvaluation tracing becomes particularly powerful when it captures the recursive structure of evaluation. Since Lisp evaluation is inherently recursive - evaluating compound expressions requires evaluating their components - your tracing system must handle nested evaluation calls and present them in a way that reveals the hierarchical evaluation structure.\n\n| Trace Information | Purpose | Example Use Case |\n|-------------------|---------|------------------|\n| Expression input structure | Understanding what's being evaluated | Debugging unexpected evaluation results |\n| Environment at entry | Variable resolution context | Diagnosing variable binding problems |\n| Special form vs function call decision | Evaluation path selection | Fixing incorrect special form handling |\n| Argument evaluation sequence | Order-dependent evaluation issues | Finding evaluation order problems |\n| Return value and type | Result verification | Verifying correct evaluation outcomes |\n| Recursive evaluation depth | Stack usage and infinite recursion | Preventing and diagnosing stack overflow |\n\n#### AST Structure Examination\n\nAbstract syntax tree inspection reveals how your parser translates token streams into the internal representation that drives evaluation. AST debugging focuses on verifying that the parsed structure correctly represents the intended program semantics, particularly for nested expressions and special syntax transformations.\n\nThe most common AST debugging scenario involves expressions that evaluate incorrectly due to parsing problems rather than evaluation logic errors. These issues manifest as structurally correct AST nodes that don't represent the intended program structure. For example, quote syntax transformation failures might produce AST structures where `'(a b c)` parses as a symbol named `'(a` followed by separate symbols `b c)` rather than the correct transformation to `(quote (a b c))`.\n\nAST debugging requires understanding the relationship between surface syntax and internal representation. Your parser makes numerous decisions about how to represent different syntactic constructs, and each decision point represents a potential source of structural errors that will cause evaluation problems downstream.\n\n| AST Inspection Focus | Common Problems | Debugging Approach |\n|---------------------|-----------------|-------------------|\n| List structure nesting | Incorrect parenthesis handling | Verify nested list depth matches source |\n| Quote transformation correctness | Quote syntax not expanded properly | Check quote forms become `(quote expr)` |\n| Atom type classification | Numbers parsed as symbols or vice versa | Verify token type mapping to AST nodes |\n| Symbol name preservation | Symbol names corrupted during parsing | Compare AST symbol names to source tokens |\n| Empty list representation | Empty lists parsed as `nil` or other forms | Verify empty list canonical representation |\n\n#### Token Stream Analysis\n\nTokenization debugging focuses on verifying that your tokenizer correctly identifies token boundaries and classifies tokens by type. Since tokenization provides the foundation for all subsequent processing, tokenization errors propagate through the entire pipeline and often manifest as confusing parsing or evaluation failures.\n\nThe primary tokenization debugging challenge is **boundary detection errors** where the tokenizer splits input text at incorrect positions, creating tokens that don't match the intended syntactic units. These errors often occur at the boundaries between different token types - for example, where numbers adjacent to symbols might be tokenized as a single symbol rather than separate number and symbol tokens.\n\nToken stream analysis requires examining both the **token sequence** produced by tokenization and the **position information** that tracks where each token originated in the source text. This dual perspective allows you to verify that tokenization preserves the relationship between source text and token representation.\n\n| Tokenization Issue | Symptoms | Diagnostic Technique |\n|-------------------|----------|---------------------|\n| Boundary detection errors | Parsing fails with unexpected tokens | Compare token boundaries to manual parsing |\n| Token type misclassification | Numbers evaluated as symbols or vice versa | Verify token type matches expected classification |\n| String literal boundary problems | Parsing errors on strings with escapes | Check string token includes entire literal |\n| Comment handling failures | Comments treated as code tokens | Verify comment tokens are filtered from parser input |\n| Whitespace boundary issues | Adjacent tokens incorrectly merged | Examine whitespace handling between tokens |\n\n### Common Bug Patterns\n\nInterpreter debugging follows predictable patterns because the same conceptual errors manifest in similar ways across different implementations. Understanding these patterns transforms debugging from ad-hoc problem solving into systematic pattern recognition, where symptoms guide you directly to likely root causes.\n\n#### Environment Chain Corruption Patterns\n\nEnvironment chain corruption represents one of the most common and difficult-to-diagnose interpreter bug patterns. These issues manifest as variables that should be accessible becoming mysteriously unbound, or variables resolving to incorrect values despite being defined correctly.\n\n**⚠️ Pitfall: Parent Environment Reference Loss**\n\nEnvironment chain corruption most commonly occurs when environment extension operations fail to maintain proper parent references. This happens when the `extend()` method creates a new environment but either doesn't set the parent reference or sets it to the wrong environment object.\n\nThe symptoms appear as `NameError` exceptions for variables that definitely exist in outer scopes. The error is particularly confusing because the variable lookup works correctly in some contexts but fails in others, typically when function calls or `let` expressions create new environment extensions.\n\nThe root cause lies in broken environment chains where child environments lose their connection to parent environments. When `lookup()` traverses the environment chain searching for a variable binding, it stops at the broken link and fails to find variables that exist in parent environments.\n\nTo diagnose this issue, trace the environment chain manually from the current environment to the global environment. If the chain terminates before reaching the global environment, or if any parent reference is `None` when it shouldn't be, you've identified the corruption point.\n\n**⚠️ Pitfall: Environment Sharing Between Closures**\n\nClosure environment capture represents another common corruption pattern where multiple closures incorrectly share the same environment object, causing variable modifications in one closure to unexpectedly affect other closures.\n\nThis occurs when closure creation captures a reference to the same environment object for multiple functions defined in the same scope, rather than each closure capturing its own environment snapshot. The result is that closures behave as if they share local variables, violating lexical scoping rules.\n\nThe bug manifests as functions that modify local variables affecting the behavior of seemingly unrelated functions. This is particularly noticeable when closures are created in loops, where all closures end up sharing the same loop variable environment.\n\n| Environment Corruption Type | Symptom | Root Cause | Fix Strategy |\n|----------------------------|---------|------------|--------------|\n| Broken parent chain | `NameError` for outer scope variables | `extend()` doesn't set parent reference | Verify parent assignment in environment creation |\n| Shared closure environments | Closures interfere with each other | Multiple closures reference same environment | Create environment copies for each closure |\n| Circular environment references | Infinite loops during lookup | Parent references form cycles | Validate parent references prevent cycles |\n| Premature environment garbage collection | Variables disappear unexpectedly | Environment objects collected while still needed | Ensure closures maintain environment references |\n\n#### Special Form Mishandling Patterns\n\nSpecial forms require careful handling because they control evaluation rather than participating in normal function evaluation. The most common special form bugs stem from treating special forms like regular functions, leading to incorrect argument evaluation behavior.\n\n**⚠️ Pitfall: Premature Argument Evaluation**\n\nThe most frequent special form error involves evaluating arguments before processing the special form, violating the evaluation control that defines special forms. This typically occurs when the evaluation dispatch mechanism doesn't properly distinguish between special forms and function calls.\n\nFor example, in an `if` expression like `(if condition then-branch else-branch)`, both branches should not be evaluated - only the branch selected by the condition should be evaluated. If your evaluator mistakenly evaluates all three arguments before processing the `if` special form, both branches execute, causing incorrect side effects and potentially infinite loops in recursive functions.\n\nThe symptoms include functions that should not be called being executed anyway, infinite recursion in conditional logic that should terminate, and side effects occurring when they should be prevented by conditional logic.\n\nThe root cause lies in evaluation dispatch logic that calls `evaluate()` on special form arguments before invoking the special form handler. Special forms must control argument evaluation themselves, receiving unevaluated arguments and deciding which arguments to evaluate based on special form semantics.\n\n**⚠️ Pitfall: Special Form Name Collision**\n\nSpecial form name collisions occur when user-defined functions or variables shadow built-in special form names, causing the interpreter to lose access to essential language constructs. This typically happens when the special form lookup mechanism doesn't take precedence over variable lookup.\n\nThe symptom is that previously working special forms like `if`, `define`, or `lambda` suddenly start behaving like function calls, often producing `TypeError` or `ArityError` exceptions because special forms don't behave like regular functions.\n\n| Special Form Bug Pattern | Symptom | Cause | Solution |\n|-------------------------|---------|--------|---------|\n| Arguments evaluated too early | Infinite recursion in conditionals | Special forms treated as functions | Check special form before evaluating arguments |\n| Special form shadowing | Built-in special forms become inaccessible | Variable bindings override special forms | Special form lookup takes precedence over variables |\n| Incorrect arity checking | Special forms reject valid argument counts | Special forms validated like function arity | Special forms have custom arity validation |\n| Missing environment threading | Special forms can't access local variables | Environment not passed to special form handlers | Thread environment through all special form calls |\n\n#### Function Application Error Patterns\n\nFunction application errors represent complex debugging scenarios because they involve multiple interacting systems: argument evaluation, environment extension, parameter binding, and body evaluation. Errors can occur at any of these stages, and the symptoms often don't clearly indicate which stage failed.\n\n**⚠️ Pitfall: Argument-Parameter Binding Mismatch**\n\nParameter binding errors occur when the function application process incorrectly maps evaluated arguments to function parameters. This typically happens when argument evaluation changes the argument count or when parameter binding logic doesn't handle edge cases like zero-parameter functions or variable-arity functions.\n\nThe symptoms include functions receiving the wrong number of arguments despite being called with the correct number, argument values being assigned to the wrong parameters, or `ArityError` exceptions for functions called with seemingly correct argument counts.\n\nThe root cause often lies in argument evaluation or parameter binding logic that doesn't properly handle the transition from unevaluated argument expressions to evaluated argument values bound to parameter names.\n\n**⚠️ Pitfall: Recursive Function Self-Reference**\n\nRecursive functions require special handling to make the function name available within the function body, allowing the function to call itself. The most common error is creating the function binding after evaluating the function body, meaning the function name isn't available during its own definition.\n\nThis manifests as `NameError` exceptions when recursive functions attempt to call themselves, even though the function appears to be properly defined. The error is confusing because the function exists in the environment after definition completes, but isn't available during the function's own evaluation.\n\n| Function Application Bug | Symptom | Common Cause | Debugging Steps |\n|-------------------------|---------|--------------|-----------------|\n| Wrong argument values in parameters | Function receives incorrect arguments | Argument evaluation order problems | Trace argument evaluation sequence |\n| `NameError` for function self-reference | Recursive calls fail | Function name not bound during evaluation | Check function name availability in function environment |\n| `ArityError` with correct argument count | Function rejects correct arguments | Arity checking logic errors | Verify argument count calculation |\n| Environment corruption in function calls | Variables have wrong values after function calls | Environment extension problems | Inspect environment chain after function application |\n\n#### List Operation Implementation Bugs\n\nList operations like `car`, `cdr`, and `cons` involve careful management of list structure representation and type checking. The most common bugs stem from incorrect assumptions about list structure or improper handling of edge cases like empty lists.\n\n**⚠️ Pitfall: Improper List vs Empty List Handling**\n\nList operation bugs frequently occur at the boundary between non-empty lists and the empty list. Many implementations incorrectly assume that all list values have the same internal structure, failing to handle the empty list as a special case with different structure requirements.\n\nThe symptom is `TypeError` or `AttributeError` exceptions when list operations encounter empty lists, or incorrect results when list operations should produce empty lists. This is particularly common with `cdr` operations that should return empty lists but instead return `None` or malformed values.\n\n**⚠️ Pitfall: Improper List Construction**\n\nList construction bugs occur when `cons` operations don't create proper list structure, or when list construction functions like `list()` don't properly terminate lists with the empty list marker. This creates improper lists that break list traversal operations.\n\nThese bugs manifest as infinite loops during list traversal, incorrect list length calculations, or list operations that work correctly on constructed lists but fail on lists created through `cons` operations.\n\n| List Operation Bug | Symptom | Typical Cause | Fix Approach |\n|-------------------|---------|---------------|-------------|\n| `car` fails on empty list | `TypeError` when accessing car of empty list | Empty list not handled as special case | Check for empty list before structure access |\n| `cdr` returns wrong type | `cdr` returns `None` instead of empty list | Incorrect empty list representation | Ensure `cdr` of single-element list returns empty list |\n| Infinite loops in list traversal | List operations never terminate | Improper list construction creates cycles | Verify list construction terminates with empty list |\n| `cons` creates malformed lists | Lists created by `cons` break other operations | `cons` doesn't create proper list structure | Ensure `cons` result is valid list structure |\n\n### Building Diagnostic Tools\n\nEffective interpreter debugging requires building specialized diagnostic tools that provide visibility into the interpretation process. Unlike general-purpose debugging, interpreter diagnostics must bridge between the host language implementation and the interpreted language behavior, providing views of both levels simultaneously.\n\n#### Evaluation Tracer Implementation\n\nAn evaluation tracer provides step-by-step visibility into how expressions are evaluated, revealing the decision path through your evaluation engine. The tracer must capture not just the final result, but the intermediate steps that led to that result, including environment lookups, special form dispatch decisions, and recursive evaluation calls.\n\nThe key insight for evaluation tracing is that Lisp evaluation follows a recursive pattern where compound expressions are evaluated by evaluating their components and combining the results. Your tracer must capture this recursive structure while presenting the information in a format that reveals the evaluation logic clearly.\n\nThe evaluation tracer works by instrumenting the main `evaluate()` function to log entry and exit information, along with key decision points within the evaluation logic. The tracer maintains a call stack that tracks recursive evaluation calls, allowing it to present the evaluation trace as a nested structure that reflects the expression structure being evaluated.\n\n| Tracer Component | Information Captured | Output Format |\n|------------------|---------------------|---------------|\n| Expression entry logging | Input expression and environment | `EVAL: (+ 1 2) in env@depth-3` |\n| Evaluation dispatch decision | Special form vs function call choice | `DISPATCH: + -> builtin function` |\n| Argument evaluation sequence | Sub-expression evaluation order | `ARG[0]: 1 -> 1, ARG[1]: 2 -> 2` |\n| Environment lookup results | Variable resolution outcomes | `LOOKUP: x in env@depth-2 -> 42` |\n| Function application details | Function call parameter binding | `APPLY: user-func(x=1, y=2) -> ...` |\n| Result value and type | Evaluation outcome | `RESULT: 3 (NUMBER)` |\n\nThe tracer implementation requires careful consideration of output formatting to make complex nested evaluations comprehensible. Deep recursive evaluations can generate overwhelming amounts of trace information, so the tracer should support filtering by expression type, depth limiting, and summary modes that hide routine evaluations while highlighting interesting decision points.\n\n#### Environment Inspector Interface\n\nEnvironment inspection requires tools that make the abstract environment chain concrete and browsable. Since environment problems often involve complex interactions between multiple scopes, the inspector must present environment information in a way that reveals both the structure of individual environments and the relationships between environments in the chain.\n\nThe environment inspector operates by providing multiple views of environment state: a **chain view** that shows the parent-child relationships between environments, a **bindings view** that lists all variables accessible at a particular point, and a **closure view** that shows what environments are captured by function closures.\n\nThe chain view reveals environment structure problems by displaying each environment in the chain with its identity, parent reference, and binding count. This view quickly identifies broken chains, circular references, and unexpected environment structures that indicate environment management bugs.\n\nThe bindings view flattens the environment chain into a single namespace view, showing all variables accessible at a particular point along with their values and the environment where each binding originated. This view helps diagnose variable shadowing issues and confirms that expected variables are accessible with correct values.\n\n| Inspector View | Purpose | Information Displayed |\n|---------------|---------|----------------------|\n| Chain structure | Environment linkage verification | `env@0 -> env@1 -> env@2 -> global` |\n| Bindings at level | Specific environment contents | `{x: 42, y: \"hello\", func: <function>}` |\n| Flattened namespace | All accessible variables | `x: 42@env-2, y: \"hello\"@env-1, +: <builtin>@global` |\n| Closure environments | Captured environment inspection | `function@addr captures env@3 with {a: 1, b: 2}` |\n| Environment lifecycle | Creation and destruction tracking | `env@5 created for function call, destroyed after return` |\n\n#### AST Visualization Tools\n\nAbstract syntax tree visualization transforms the internal tree structure into a format that clearly reveals the parsed program structure. Since AST problems often involve subtle structural differences that are difficult to spot in text representations, visualization tools must present tree structure in a way that makes structural errors obvious.\n\nThe AST visualizer works by traversing the parsed AST and generating a tree representation that shows both the hierarchical structure of expressions and the detailed information at each node. The visualizer must handle the recursive nature of AST structures while presenting the information in a format that makes structural problems immediately apparent.\n\nAST visualization becomes particularly valuable for debugging quote syntax transformation and nested list structure parsing. These features involve complex structural transformations that are difficult to verify through simple inspection of the final AST representation.\n\n| Visualization Component | Structure Revealed | Diagnostic Value |\n|------------------------|-------------------|------------------|\n| Tree hierarchy display | Nested expression structure | Verify parsing preserves intended nesting |\n| Node type annotations | AST node classification | Confirm tokens become correct AST node types |\n| Quote transformation visualization | Quote syntax expansion | Verify `'expr` becomes `(quote expr)` structure |\n| Position tracking display | Source location preservation | Trace AST nodes back to source text positions |\n| List structure validation | Proper vs improper list identification | Ensure list parsing creates valid list structures |\n\n#### Interactive REPL Debugging\n\nThe Read-Eval-Print Loop provides an interactive environment for testing interpreter behavior and exploring edge cases. A well-designed REPL includes debugging features that make it easy to inspect interpreter state, test specific scenarios, and experiment with interpreter behavior.\n\nThe debugging-enabled REPL extends the basic read-eval-print cycle with commands that provide access to internal interpreter state. These commands allow you to inspect the current environment, trace evaluation of specific expressions, and examine the results of tokenization and parsing without writing separate test programs.\n\nREPL debugging commands should be designed to feel natural within the interactive environment while providing powerful diagnostic capabilities. The commands integrate with the normal REPL workflow, allowing you to seamlessly switch between testing program behavior and inspecting interpreter internals.\n\n| REPL Debug Command | Function | Example Usage |\n|-------------------|----------|---------------|\n| `:trace <expr>` | Enable evaluation tracing for expression | `:trace (factorial 5)` |\n| `:env` | Display current environment chain | `:env` |\n| `:parse <expr>` | Show AST for expression | `:parse '(a b c)` |\n| `:tokens <expr>` | Show tokenization of expression | `:tokens \"hello world\"` |\n| `:reset` | Reset interpreter to clean state | `:reset` |\n| `:help` | List available debug commands | `:help` |\n\n### Implementation Guidance\n\nBuilding effective debugging tools for your Lisp interpreter requires integrating diagnostic capabilities throughout your implementation rather than adding them as an afterthought. The most effective approach is to build debugging support into your core data structures and algorithms from the beginning, making diagnostic information naturally available when problems occur.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Logging Framework | Python `logging` module with custom formatters | Structured logging with JSON output |\n| Trace Visualization | Plain text indented output | Rich terminal formatting with colors |\n| Interactive Debugging | Basic print statements | IPython integration with custom magic commands |\n| AST Visualization | Simple tree printing | Graphical tree rendering with SVG output |\n| Performance Profiling | Basic timing measurements | Python `cProfile` integration |\n\n#### Recommended File Structure\n\n```python\nlisp_interpreter/\n  debug/\n    __init__.py              ← debug module exports\n    tracer.py               ← evaluation tracing system\n    environment_inspector.py ← environment debugging tools\n    ast_visualizer.py       ← AST structure visualization\n    repl_debugger.py        ← REPL debugging commands\n  core/\n    evaluator.py            ← instrumented with debug hooks\n    environment.py          ← enhanced with inspection methods\n    parser.py              ← enhanced with debug information\n  tests/\n    debug/\n      test_tracer.py        ← tracer functionality tests\n      test_inspector.py     ← environment inspector tests\n```\n\n#### Evaluation Tracer Infrastructure\n\n```python\n# debug/tracer.py\nfrom typing import List, Optional, Any, Dict\nfrom dataclasses import dataclass\nimport sys\nfrom contextlib import contextmanager\n\n@dataclass\nclass TraceEvent:\n    \"\"\"Represents a single event in the evaluation trace.\"\"\"\n    event_type: str  # 'enter', 'exit', 'lookup', 'apply'\n    expression: Any\n    environment_id: int\n    depth: int\n    result: Optional[Any] = None\n    error: Optional[str] = None\n    timestamp: float = 0.0\n\nclass EvaluationTracer:\n    \"\"\"Provides detailed tracing of expression evaluation.\"\"\"\n    \n    def __init__(self, output_file=None, max_depth=None):\n        self.events: List[TraceEvent] = []\n        self.current_depth = 0\n        self.output_file = output_file or sys.stdout\n        self.max_depth = max_depth\n        self.enabled = True\n    \n    @contextmanager\n    def trace_evaluation(self, expression, environment):\n        \"\"\"Context manager for tracing a single evaluation.\"\"\"\n        # TODO 1: Create enter event with expression and environment info\n        # TODO 2: Increment depth counter and check against max_depth\n        # TODO 3: Yield control to evaluation code\n        # TODO 4: Capture result or exception information\n        # TODO 5: Create exit event with result/error information\n        # TODO 6: Decrement depth counter and log event if enabled\n        pass\n    \n    def log_lookup(self, variable_name, environment, result):\n        \"\"\"Log a variable lookup operation.\"\"\"\n        # TODO 1: Create lookup event with variable name and environment\n        # TODO 2: Record whether lookup succeeded or failed\n        # TODO 3: Include resolved value if lookup succeeded\n        # TODO 4: Add event to trace log\n        pass\n    \n    def format_trace_output(self) -> str:\n        \"\"\"Format collected trace events for display.\"\"\"\n        # TODO 1: Group events by evaluation call (enter/exit pairs)\n        # TODO 2: Format each event with appropriate indentation\n        # TODO 3: Include expression, environment, and result information\n        # TODO 4: Handle error events with clear error indication\n        # TODO 5: Return formatted string representation\n        pass\n```\n\n#### Environment Inspector Implementation\n\n```python\n# debug/environment_inspector.py\nfrom typing import Dict, List, Set, Optional\nfrom ..core.environment import Environment\nfrom ..core.data_model import LispValue\n\nclass EnvironmentInspector:\n    \"\"\"Provides detailed inspection of environment chains and variable bindings.\"\"\"\n    \n    def __init__(self, environment: Environment):\n        self.environment = environment\n        self.inspection_cache: Dict[int, Dict] = {}\n    \n    def inspect_chain(self) -> List[Dict]:\n        \"\"\"Generate detailed information about the entire environment chain.\"\"\"\n        # TODO 1: Start from current environment and traverse to root\n        # TODO 2: For each environment, collect identity, bindings count, parent reference\n        # TODO 3: Detect circular references and broken chains\n        # TODO 4: Return list of environment information dictionaries\n        # TODO 5: Cache results to avoid repeated traversal overhead\n        pass\n    \n    def get_all_accessible_variables(self) -> Dict[str, tuple]:\n        \"\"\"Return all variables accessible from current environment with their sources.\"\"\"\n        # TODO 1: Traverse environment chain from current to global\n        # TODO 2: Collect variable bindings from each level\n        # TODO 3: Handle variable shadowing by keeping first occurrence\n        # TODO 4: Return dict mapping variable names to (value, source_env) tuples\n        # TODO 5: Include metadata about which environment each binding comes from\n        pass\n    \n    def analyze_closure_environments(self, function_value: LispValue) -> Dict:\n        \"\"\"Analyze environment capture in function closures.\"\"\"\n        # TODO 1: Extract closure environment from function value\n        # TODO 2: Traverse closure environment chain\n        # TODO 3: Identify which variables are captured vs inherited\n        # TODO 4: Check for potential memory leaks from captured environments\n        # TODO 5: Return analysis report with captured variables and chain depth\n        pass\n    \n    def diagnose_lookup_failure(self, variable_name: str) -> Dict:\n        \"\"\"Provide detailed diagnosis when variable lookup fails.\"\"\"\n        # TODO 1: Search for variable in each environment level\n        # TODO 2: Check for similar variable names that might indicate typos\n        # TODO 3: Identify if variable exists in inaccessible scopes\n        # TODO 4: Generate suggestions for fixing the lookup failure\n        # TODO 5: Return comprehensive diagnostic report\n        pass\n```\n\n#### AST Visualizer Tools\n\n```python\n# debug/ast_visualizer.py\nfrom typing import Any, List, Dict\nfrom ..core.data_model import LispValue, LispValueType\nimport json\n\nclass ASTVisualizer:\n    \"\"\"Provides visualization and analysis of parsed AST structures.\"\"\"\n    \n    def __init__(self, max_depth=10):\n        self.max_depth = max_depth\n        self.node_counter = 0\n    \n    def visualize_tree(self, ast: LispValue, format='text') -> str:\n        \"\"\"Generate visual representation of AST structure.\"\"\"\n        # TODO 1: Reset node counter and start tree traversal\n        # TODO 2: Handle different node types (atoms, lists, functions)\n        # TODO 3: Generate appropriate representation based on format\n        # TODO 4: Include type information and value details\n        # TODO 5: Apply depth limiting to prevent overwhelming output\n        pass\n    \n    def analyze_structure(self, ast: LispValue) -> Dict:\n        \"\"\"Analyze AST structure and identify potential issues.\"\"\"\n        # TODO 1: Count nodes by type and calculate tree depth\n        # TODO 2: Identify malformed structures (improper lists, etc.)\n        # TODO 3: Check for quote syntax transformation correctness\n        # TODO 4: Validate that list structures are properly terminated\n        # TODO 5: Return analysis report with structure statistics\n        pass\n    \n    def compare_structures(self, ast1: LispValue, ast2: LispValue) -> Dict:\n        \"\"\"Compare two AST structures and highlight differences.\"\"\"\n        # TODO 1: Traverse both trees simultaneously\n        # TODO 2: Identify structural differences (shape, node types)\n        # TODO 3: Highlight value differences in matching nodes\n        # TODO 4: Generate diff report showing specific differences\n        # TODO 5: Suggest likely causes for structural mismatches\n        pass\n```\n\n#### REPL Debug Integration\n\n```python\n# debug/repl_debugger.py\nfrom typing import Dict, Callable, Any\nfrom ..core.evaluator import Evaluator\nfrom ..core.environment import Environment\nfrom .tracer import EvaluationTracer\nfrom .environment_inspector import EnvironmentInspector\nfrom .ast_visualizer import ASTVisualizer\n\nclass REPLDebugger:\n    \"\"\"Provides debugging commands for interactive REPL sessions.\"\"\"\n    \n    def __init__(self, evaluator: Evaluator):\n        self.evaluator = evaluator\n        self.tracer = EvaluationTracer()\n        self.commands: Dict[str, Callable] = {\n            'trace': self.cmd_trace,\n            'env': self.cmd_environment,\n            'parse': self.cmd_parse,\n            'tokens': self.cmd_tokens,\n            'reset': self.cmd_reset,\n            'help': self.cmd_help\n        }\n    \n    def handle_debug_command(self, command_line: str) -> str:\n        \"\"\"Process debug command and return result.\"\"\"\n        # TODO 1: Parse command line to extract command and arguments\n        # TODO 2: Look up command in commands dictionary\n        # TODO 3: Execute command with parsed arguments\n        # TODO 4: Handle command errors gracefully\n        # TODO 5: Return formatted command result\n        pass\n    \n    def cmd_trace(self, expression_text: str) -> str:\n        \"\"\"Enable tracing for expression evaluation.\"\"\"\n        # TODO 1: Parse expression text into AST\n        # TODO 2: Enable tracer and evaluate expression\n        # TODO 3: Format trace output for display\n        # TODO 4: Return formatted trace information\n        pass\n    \n    def cmd_environment(self, args: str = \"\") -> str:\n        \"\"\"Display current environment information.\"\"\"\n        # TODO 1: Create environment inspector for current environment\n        # TODO 2: Generate environment chain analysis\n        # TODO 3: Format environment information for display\n        # TODO 4: Include variable bindings and chain structure\n        pass\n```\n\n#### Milestone Checkpoints\n\nAfter implementing each debugging component, verify functionality with these checkpoints:\n\n**Tracer Verification:**\n- Run `python -c \"from debug.tracer import EvaluationTracer; print('Tracer loaded')\"` to verify imports\n- Trace a simple expression like `(+ 1 2)` and verify output shows evaluation steps\n- Trace a recursive function and verify depth tracking works correctly\n\n**Environment Inspector Verification:**\n- Create nested environments with variable bindings\n- Use inspector to display environment chain and verify structure\n- Test lookup failure diagnosis with undefined variables\n\n**AST Visualizer Verification:**\n- Parse complex nested expressions and visualize tree structure\n- Compare AST structures for similar expressions\n- Verify quote syntax transformation visualization\n\n**REPL Debugger Verification:**\n- Start REPL and test `:help` command shows available debug commands\n- Use `:trace` command to trace expression evaluation\n- Use `:env` command to inspect environment state\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | Diagnostic Steps | Fix Strategy |\n|---------|--------------|------------------|--------------|\n| Tracer shows wrong evaluation order | Evaluation dispatch logic error | Check special form vs function call detection | Fix evaluation dispatch mechanism |\n| Environment inspector shows broken chains | Environment extension problems | Trace environment creation and parent assignment | Verify `extend()` method implementation |\n| AST visualizer shows malformed trees | Parser structural errors | Compare AST to expected structure for sample inputs | Fix recursive parsing logic |\n| Debug commands cause REPL crashes | Exception handling in debug code | Test debug commands with invalid inputs | Add comprehensive error handling |\n| Trace output too verbose | Missing depth limiting | Check tracer depth configuration | Implement trace filtering and depth limits |\n\n\n## Future Extensions\n\n> **Milestone(s):** All milestones (1-4) - future extensions build upon the complete interpreter implementation established through all four milestones, providing pathways for continued learning and system evolution\n\nOnce you have completed the basic Lisp interpreter through all four milestones, you will have built a solid foundation that demonstrates the core principles of language implementation. However, this foundation represents just the beginning of what is possible with programming language design and implementation. The architecture you have constructed is intentionally extensible, designed with clean separation of concerns and modular components that can be enhanced without requiring fundamental restructuring.\n\n### Mental Model: The Expandable Workshop\n\nThink of your completed interpreter as a well-organized workshop with solid foundations, reliable tools, and clear work areas. Just as a carpenter's workshop can be expanded with specialized tools (a router table for fine joinery, a dust collection system for cleaner work, or power tools for increased productivity), your interpreter can be enhanced with additional language features, performance optimizations, and development environment improvements. The key insight is that these extensions build upon your existing infrastructure rather than replacing it - your tokenizer, parser, evaluator, and environment system remain the core tools, but they gain new capabilities and efficiency improvements.\n\nThe extensions fall into three main categories: additional language features that expand what programs can express, performance optimizations that make the interpreter run faster and handle larger programs, and development environment enhancements that improve the programmer experience. Each category offers different learning opportunities and practical benefits, allowing you to choose extensions based on your interests and goals.\n\n### Additional Language Features\n\nThe minimal Lisp you have implemented covers the essential elements of functional programming, but many practical programming tasks benefit from additional language constructs. These extensions introduce new concepts while building on your existing architecture, providing opportunities to deepen your understanding of language design principles and implementation techniques.\n\n#### Macro System Implementation\n\nMacros represent one of Lisp's most powerful and distinctive features - the ability to manipulate code as data before evaluation occurs. Unlike functions, which operate on evaluated arguments, macros receive their arguments as unevaluated S-expressions and return new S-expressions that replace the original macro call. This capability enables programmers to extend the language syntax and create domain-specific languages embedded within Lisp.\n\n> **Decision: Macro System Architecture**\n> - **Context**: Programmers need the ability to define new syntactic constructs and eliminate repetitive code patterns that cannot be abstracted with functions alone\n> - **Options Considered**: \n>   - Compile-time macro expansion with separate expansion phase\n>   - Runtime macro expansion during evaluation\n>   - Template-based macro system with pattern matching\n> - **Decision**: Compile-time expansion with AST transformation phase\n> - **Rationale**: Compile-time expansion provides better performance and error reporting, while AST transformation fits naturally with the existing parser output\n> - **Consequences**: Requires adding a macro expansion phase between parsing and evaluation, but maintains clear separation of concerns and enables powerful metaprogramming\n\nThe macro system requires extending your data model to distinguish between regular functions and macro functions, along with adding a macro expansion phase to your evaluation pipeline. The `LispValue` type needs a new variant for macros, and the evaluator needs logic to recognize macro calls and perform expansion before normal evaluation.\n\n| Macro System Component | Purpose | Integration Point |\n|------------------------|---------|------------------|\n| `MacroFunction` type | Stores macro parameter list and body template | Extends `LispValue` discriminated union |\n| `defmacro` special form | Creates macro binding in environment | Adds new case to special form handler |\n| Macro expansion phase | Transforms macro calls into expanded code | Inserts between parsing and evaluation |\n| Expansion context tracking | Prevents infinite macro expansion loops | Maintains expansion depth counter |\n| Hygienic identifier generation | Avoids variable capture in macro expansions | Generates unique symbols for macro-introduced variables |\n\nThe implementation challenges center around handling variable capture and ensuring that macro-generated code does not accidentally interfere with user variables. A sophisticated macro system includes hygiene mechanisms that automatically rename variables introduced by macros to avoid conflicts.\n\n⚠️ **Pitfall: Variable Capture in Macros**\nMany macro implementations suffer from variable capture problems where macro-generated code accidentally refers to variables in the calling context. For example, a macro that generates a `let` binding with a hardcoded variable name can shadow variables the macro user expects to access. The solution involves either manual variable renaming or automatic hygienic macro expansion that generates unique identifiers for macro-introduced bindings.\n\n#### Advanced Data Types\n\nWhile the basic interpreter handles numbers, symbols, and lists, practical programming often requires additional data types that provide better abstraction and performance for specific use cases. These extensions demonstrate how language implementers balance expressiveness, performance, and implementation complexity.\n\n**String Operations and Text Processing**\n\nString literals exist in your tokenizer, but the evaluator treats them as atomic values without built-in operations. Adding comprehensive string support requires implementing string concatenation, substring extraction, pattern matching, and character manipulation functions. This extension illustrates how built-in operations can provide both convenience and performance benefits over implementing equivalent functionality in user code.\n\n| String Operation | Function Signature | Purpose |\n|------------------|-------------------|---------|\n| `string-append` | `(string-append str1 str2 ...)` | Concatenates multiple strings efficiently |\n| `substring` | `(substring str start end)` | Extracts portion of string by position |\n| `string-length` | `(string-length str)` | Returns character count |\n| `string->list` | `(string->list str)` | Converts string to list of characters |\n| `list->string` | `(list->string chars)` | Converts character list to string |\n| `string=?` | `(string=? str1 str2)` | Tests string equality |\n\n**Vector Data Structure**\n\nLists provide excellent support for recursive algorithms and functional programming patterns, but they offer poor performance for random access and modification operations. Vectors (dynamic arrays) complement lists by providing constant-time indexing and efficient append operations, making them suitable for different algorithmic patterns.\n\nThe vector implementation requires extending the `LispValueType` enumeration and adding vector-specific operations to the built-in function registry. Vectors can share many operations with lists (like `map` and `reduce`) while providing their own access patterns through indexing operations.\n\n| Vector Operation | Function Signature | Time Complexity |\n|------------------|-------------------|-----------------|\n| `make-vector` | `(make-vector size initial-value)` | O(size) |\n| `vector-ref` | `(vector-ref vec index)` | O(1) |\n| `vector-set!` | `(vector-set! vec index value)` | O(1) |\n| `vector-length` | `(vector-length vec)` | O(1) |\n| `vector-append` | `(vector-append vec1 vec2)` | O(n + m) |\n\n**Hash Table Implementation**\n\nHash tables (dictionaries or maps in other languages) provide efficient key-value storage with average constant-time lookup, insertion, and deletion. This data structure enables efficient implementation of algorithms that require fast membership testing or associative storage patterns that would be inefficient with lists.\n\nHash tables introduce interesting implementation challenges around hash function design, collision resolution, and dynamic resizing. The implementation also raises questions about key equality semantics and whether to support mutable or immutable variants.\n\n#### Advanced Control Structures\n\nThe basic interpreter provides conditional evaluation through `if` expressions, but many programming patterns benefit from additional control structures that reduce code duplication and express intent more clearly.\n\n**Pattern Matching with Match Expressions**\n\nPattern matching allows programs to destructure data and dispatch behavior based on data shape in a single construct. Unlike cascaded `if` expressions that test conditions sequentially, pattern matching expresses the programmer's intent to handle different cases of a discriminated union or data structure variant.\n\n```lisp\n(match expression\n  (pattern1 result1)\n  (pattern2 result2)\n  (_ default-result))\n```\n\nPattern matching requires extending the parser to recognize match syntax and implementing pattern compilation that translates match expressions into equivalent conditional and destructuring operations. The implementation involves pattern parsing, binding variable extraction, and generating efficient comparison code.\n\n**Exception Handling System**\n\nError handling in the basic interpreter relies on returning error values or terminating evaluation. A more sophisticated approach involves exception handling that separates error conditions from normal control flow, enabling cleaner error recovery and resource cleanup patterns.\n\nException handling requires new special forms for raising and catching exceptions, along with modifications to the evaluator to maintain an exception handler stack. When an exception occurs, the evaluator unwinds the call stack until it finds an appropriate handler, executing any cleanup code along the way.\n\n| Exception Construct | Syntax | Purpose |\n|--------------------|--------|---------|\n| `throw` | `(throw exception-value)` | Raises exception and begins stack unwinding |\n| `try-catch` | `(try body (catch var handler))` | Establishes exception handler for block |\n| `finally` | `(finally cleanup-code)` | Ensures code runs regardless of exceptions |\n\n### Performance Optimization Opportunities\n\nThe tree-walking interpreter you have built prioritizes implementation simplicity and educational clarity over execution performance. While this approach serves well for learning language implementation concepts, it leaves substantial opportunities for performance improvement that demonstrate advanced compiler and runtime techniques.\n\n#### Bytecode Compilation and Virtual Machine\n\nTree-walking interpretation performs significant overhead for each evaluation step - dispatching on expression types, looking up function implementations, and traversing nested data structures. Bytecode compilation eliminates this overhead by translating the parsed AST into a linear sequence of simple instructions that execute on a specialized virtual machine.\n\n> **Decision: Bytecode Virtual Machine Architecture**\n> - **Context**: Tree-walking interpretation creates substantial per-operation overhead that limits performance for compute-intensive programs\n> - **Options Considered**: \n>   - Stack-based virtual machine with operand stack\n>   - Register-based virtual machine with named registers  \n>   - Direct translation to native machine code\n> - **Decision**: Stack-based virtual machine with instruction stream\n> - **Rationale**: Stack machines map naturally to nested expression evaluation, require simpler instruction encoding, and provide good performance improvement over tree-walking with moderate implementation complexity\n> - **Consequences**: Requires implementing bytecode compiler and VM executor, but provides significant performance gains and serves as foundation for further optimizations\n\nThe bytecode compilation approach transforms your interpreter architecture from a single evaluation phase into a two-phase system: compilation from AST to bytecode, followed by execution on the virtual machine. This transformation introduces new components while preserving your existing tokenizer and parser infrastructure.\n\n| VM Component | Responsibility | Data Structures |\n|--------------|---------------|-----------------|\n| Instruction Set | Defines primitive operations | Opcode enumeration, operand encoding |\n| Bytecode Compiler | Translates AST to instruction sequence | Symbol table, code buffer, label resolution |\n| Virtual Machine | Executes instruction stream | Operand stack, instruction pointer, call stack |\n| Garbage Collector | Manages VM memory allocation | Object heap, root set tracking |\n\nThe instruction set design balances expressiveness with implementation simplicity. A typical instruction set includes stack manipulation (`PUSH`, `POP`), arithmetic operations (`ADD`, `SUB`, `MUL`, `DIV`), control flow (`JUMP`, `JUMP_IF_FALSE`), function operations (`CALL`, `RETURN`), and variable access (`LOAD_GLOBAL`, `STORE_GLOBAL`, `LOAD_LOCAL`, `STORE_LOCAL`).\n\n**Bytecode Instruction Examples**\n\n| Instruction | Operands | Stack Effect | Purpose |\n|-------------|----------|--------------|---------|\n| `PUSH_NUMBER` | number value | → value | Loads numeric literal onto stack |\n| `LOAD_GLOBAL` | symbol index | → value | Loads global variable value |\n| `CALL` | argument count | args, func → result | Calls function with n arguments |\n| `JUMP_IF_FALSE` | instruction offset | value → | Conditional branch based on stack top |\n| `MAKE_FUNCTION` | code address, closure count | closures → function | Creates function object with closures |\n\nThe compilation process traverses the AST and generates corresponding instruction sequences, handling expression evaluation order, variable scoping, and control flow. Functions require special attention as they need code addresses, closure variable capture, and proper calling conventions.\n\n#### Advanced Garbage Collection\n\nThe basic interpreter likely relies on the host language's garbage collector (Python's reference counting or JavaScript's mark-and-sweep), but a production language implementation benefits from garbage collection strategies tuned for specific allocation patterns and performance characteristics.\n\n**Generational Garbage Collection**\n\nMost program values exhibit temporal locality - recently allocated objects are more likely to become garbage quickly than long-lived objects. Generational garbage collection exploits this pattern by segregating objects into generations based on age and collecting younger generations more frequently than older ones.\n\nThe implementation divides the heap into nursery (young generation) and tenured (old generation) spaces. Allocation happens in the nursery, and surviving objects eventually promote to tenured space. Minor collections focus on the nursery and run frequently, while major collections examine the entire heap but run less often.\n\n**Copy Collection for Nursery**\n\nThe nursery can use copy collection that divides the space into \"from\" and \"to\" semi-spaces. During collection, live objects copy from the from-space to the to-space, automatically compacting memory and eliminating fragmentation. This approach works well for short-lived objects with high garbage rates.\n\n#### Optimization Passes and Analysis\n\nBytecode compilation enables sophisticated program analysis and optimization passes that improve performance without changing program semantics. These optimizations demonstrate how compilers balance compilation time against runtime performance improvements.\n\n**Constant Folding and Propagation**\n\nMany programs contain expressions that compute the same values repeatedly or perform arithmetic on compile-time constants. Constant folding evaluates these expressions during compilation, while constant propagation replaces variable references with known constant values throughout the program.\n\nFor example, the expression `(+ 2 3)` can fold to `5` during compilation, eliminating runtime arithmetic. Similarly, if a variable `x` is bound to a constant value `42` and never reassigned, references to `x` can be replaced with `42`.\n\n**Dead Code Elimination**\n\nPrograms often contain unreachable code paths or unused variable bindings that consume memory and compilation time without contributing to program behavior. Dead code elimination identifies and removes these constructs, reducing program size and improving cache locality.\n\nThe analysis requires building a control flow graph that tracks which code paths are reachable from program entry points, then eliminating any unreachable basic blocks. Variable liveness analysis identifies unused bindings that can be eliminated.\n\n**Tail Call Optimization Enhancement**\n\nWhile the basic interpreter includes simple tail call optimization through trampolines, bytecode compilation enables more sophisticated tail call handling. The compiler can identify tail positions more precisely and generate specialized instructions that reuse stack frames directly, eliminating the overhead of continuation objects.\n\n### Development Environment Enhancements\n\nA complete programming language implementation extends beyond the core interpreter to include development tools that improve programmer productivity and debugging experience. These enhancements demonstrate how language tooling builds upon the interpreter infrastructure to provide richer development environments.\n\n#### Advanced REPL Features\n\nThe Read-Eval-Print Loop serves as the primary interface for interactive development, but basic REPL implementations often lack features that programmers expect from modern development environments. Advanced REPL features transform the interpreter from a simple evaluation engine into a comprehensive development tool.\n\n**Command History and Editing**\n\nInteractive development benefits enormously from command history that allows users to recall and modify previous inputs. This feature requires maintaining a persistent history buffer and implementing line editing capabilities that support cursor movement, text insertion, and deletion operations.\n\nThe implementation can integrate with existing line editing libraries (like GNU Readline) or implement basic editing from scratch. Key features include up/down arrow history navigation, left/right cursor movement, backspace deletion, and tab completion for symbol names.\n\n| REPL Command | Function | Implementation |\n|--------------|----------|----------------|\n| `:history` | Display recent commands | Maintains ring buffer of input strings |\n| `:load filename` | Load and evaluate file | Reads file, processes through normal pipeline |\n| `:env` | Show current bindings | Iterates through environment chain |\n| `:trace expr` | Enable evaluation tracing | Wraps evaluator with debugging output |\n| `:reset` | Clear all bindings | Creates fresh global environment |\n\n**Multi-line Input Support**\n\nLisp programs often span multiple lines with complex nested structures, but basic REPLs expect complete expressions on single lines. Multi-line input support allows users to enter partial expressions and continue typing until the expression is syntactically complete.\n\nThe implementation requires extending the tokenizer to detect incomplete expressions (unbalanced parentheses, unterminated strings) and prompting for continuation lines. The REPL maintains a buffer of partial input until it can form a complete expression for evaluation.\n\n**Interactive Debugging Integration**\n\nWhen evaluation errors occur, advanced REPLs provide debugging facilities that allow users to inspect program state, examine variable values, and understand error contexts. This integration transforms error messages from opaque failures into learning opportunities.\n\nThe debugging system can offer stack trace visualization, environment inspection at different call depths, and the ability to evaluate expressions in the context where errors occurred. These features require extending the evaluator to maintain detailed execution context and providing REPL commands to navigate this context.\n\n#### IDE Integration and Language Server\n\nModern programming environments expect language-aware editing support including syntax highlighting, error diagnostics, and code completion. The Language Server Protocol (LSP) provides a standardized way to integrate language intelligence with various editors and IDEs.\n\n**Syntax Analysis for Editors**\n\nEditors need to understand program structure to provide syntax highlighting, parentheses matching, and code folding. This requires exposing your tokenizer and parser through an API that can process partial or invalid programs without failing completely.\n\nThe integration involves implementing incremental parsing that can update syntax trees efficiently as users type, along with error recovery that provides useful information even when programs contain syntax errors. The parser needs to produce partial results and continue processing after encountering errors.\n\n**Semantic Analysis and Error Reporting**\n\nBeyond syntax analysis, editors benefit from semantic analysis that understands variable bindings, function definitions, and type relationships (in typed languages). This analysis enables features like \"go to definition,\" \"find references,\" and intelligent error reporting that considers program semantics.\n\nThe implementation requires extending your evaluator's environment tracking to maintain symbol definition locations and usage sites. Static analysis passes can identify potential errors (undefined variables, arity mismatches) without full program evaluation.\n\n**Code Completion and Documentation**\n\nInteractive editing benefits from code completion that suggests available functions, variables, and language constructs based on the current context. Documentation integration provides inline help for built-in functions and user-defined constructs.\n\nThe completion system requires maintaining a symbol database with function signatures, documentation strings, and usage examples. The implementation can extract this information from your built-in function definitions and user code analysis.\n\n#### Performance Profiling and Analysis Tools\n\nUnderstanding program performance characteristics becomes crucial as Lisp programs grow larger and more complex. Profiling tools help programmers identify performance bottlenecks and optimize critical code paths.\n\n**Execution Time Profiling**\n\nTime profiling measures how much execution time each function consumes, enabling programmers to focus optimization efforts on the most expensive operations. The implementation requires instrumenting function calls to measure entry and exit times, then aggregating statistics across program execution.\n\n| Profiling Metric | Purpose | Collection Method |\n|------------------|---------|------------------|\n| Function call count | Identifies hot functions | Counter increment on each call |\n| Total time per function | Shows where time is spent | Timestamp difference measurement |\n| Self time vs total time | Distinguishes function overhead from callees | Stack-based time attribution |\n| Memory allocation rate | Identifies allocation-heavy functions | Hook into memory allocator |\n\n**Memory Usage Analysis**\n\nMemory profiling helps identify memory leaks, excessive allocation, and opportunities for data structure optimization. The implementation can track allocation sites, object lifetimes, and garbage collection pressure.\n\nMemory profiling requires instrumenting object allocation and deallocation to maintain statistics about memory usage patterns. The profiler can identify functions that allocate large amounts of memory or create many short-lived objects that stress the garbage collector.\n\n**Execution Trace Analysis**\n\nDetailed execution traces show the sequence of function calls, variable accesses, and control flow decisions that occur during program execution. This information helps programmers understand program behavior and identify unexpected execution patterns.\n\nTrace analysis generates large amounts of data, so the implementation needs efficient storage and filtering mechanisms. Interactive trace browsers allow programmers to navigate execution history and correlate program behavior with source code locations.\n\n### Implementation Considerations and Architecture Evolution\n\nThese extensions build upon your existing interpreter architecture while introducing new components and capabilities. The modular design you established through the four milestones provides a solid foundation that can accommodate these enhancements without requiring fundamental restructuring.\n\n#### Maintaining Backward Compatibility\n\nAs you add new language features and optimizations, maintaining compatibility with existing programs becomes increasingly important. This requires careful attention to language semantics and implementation details that programs might depend on.\n\nLanguage extensions should preserve existing evaluation semantics while adding new capabilities. For example, adding vectors should not change how lists behave, and bytecode compilation should produce identical results to tree-walking interpretation. Automated testing helps ensure that enhancements do not introduce regressions.\n\n#### Incremental Implementation Strategy\n\nThese extensions represent substantial development efforts that are best approached incrementally. Each enhancement can be implemented and tested independently, allowing you to gain experience with different aspects of language implementation without overwhelming complexity.\n\nThe recommended implementation order prioritizes foundational capabilities that enable subsequent enhancements:\n1. Additional data types (strings, vectors) that extend the core value system\n2. Advanced control structures that build on existing evaluation infrastructure  \n3. Macro system that introduces metaprogramming capabilities\n4. Bytecode compilation that provides performance improvements\n5. Development environment tools that improve programmer experience\n\n#### Performance vs Complexity Trade-offs\n\nEach performance optimization introduces implementation complexity that must be weighed against the benefits provided. Bytecode compilation provides significant performance improvements but requires substantial implementation effort. Advanced garbage collection offers better memory management but introduces algorithmic complexity.\n\nThe decision criteria should consider your goals: educational exploration, practical programming language development, or performance optimization learning. Different objectives justify different trade-offs between implementation complexity and performance benefits.\n\n### Implementation Guidance\n\nThe extensions described above represent significant undertakings that build upon your interpreter foundation in different directions. Each category offers unique learning opportunities and practical benefits, allowing you to explore advanced language implementation topics based on your interests and goals.\n\n#### Technology Recommendations\n\n| Extension Category | Simple Approach | Advanced Approach |\n|-------------------|----------------|-------------------|\n| Macro System | AST template substitution | Hygienic macro expansion with syntax objects |\n| String Operations | Python string methods wrapping | Custom string type with copy-on-write optimization |\n| Hash Tables | Python dict wrapping | Custom hash table with open addressing |\n| Bytecode VM | List-based instruction storage | Packed binary instruction format |\n| Garbage Collection | Reference counting with cycle detection | Generational copying collector |\n| REPL Enhancement | Python cmd module integration | Custom line editing with termios/curses |\n| IDE Integration | JSON-RPC language server | Full LSP implementation with incremental parsing |\n\n#### Recommended Implementation Structure\n\nThese extensions can be integrated into your existing project structure while maintaining clear module boundaries:\n\n```\ninterpreter-project/\n  src/\n    tokenizer.py           # Existing tokenizer (unchanged)\n    parser.py              # Existing parser (unchanged)  \n    evaluator.py           # Enhanced with macro expansion\n    environment.py         # Existing environment (unchanged)\n    values.py              # Extended with new data types\n    \n    # New extension modules\n    macros/\n      macro_expander.py    # Macro expansion engine\n      builtin_macros.py    # Standard macro library\n      \n    bytecode/\n      compiler.py          # AST to bytecode compiler\n      vm.py               # Virtual machine implementation\n      instructions.py      # Instruction set definition\n      \n    data_types/\n      strings.py           # String operations and methods\n      vectors.py           # Vector data type implementation  \n      hash_tables.py       # Hash table implementation\n      \n    tools/\n      repl_advanced.py     # Enhanced REPL with history/editing\n      profiler.py          # Performance profiling tools\n      debugger.py          # Interactive debugging support\n      \n    lsp/\n      server.py            # Language server implementation\n      protocol.py          # LSP message handling\n      analysis.py          # Semantic analysis for IDE features\n```\n\n#### Macro System Implementation Skeleton\n\n```python\n# macros/macro_expander.py\n\nclass MacroExpander:\n    \"\"\"Handles macro definition and expansion in the AST.\"\"\"\n    \n    def __init__(self, environment):\n        self.macro_environment = environment\n        self.expansion_depth = 0\n        self.max_expansion_depth = 100\n    \n    def expand_macros(self, ast):\n        \"\"\"\n        Recursively expand all macros in the AST.\n        Returns new AST with macros expanded.\n        \"\"\"\n        # TODO 1: Check if AST is a macro call (list starting with macro symbol)\n        # TODO 2: If macro call, retrieve macro function and expand\n        # TODO 3: If not macro call but list, recursively expand elements\n        # TODO 4: If atom, return unchanged\n        # TODO 5: Track expansion depth to prevent infinite loops\n        pass\n    \n    def expand_macro_call(self, macro_func, args):\n        \"\"\"\n        Expand a single macro call by applying macro to arguments.\n        \"\"\"\n        # TODO 1: Create temporary environment for macro expansion\n        # TODO 2: Bind macro parameters to unevaluated arguments\n        # TODO 3: Evaluate macro body in temporary environment\n        # TODO 4: Return resulting AST for further processing\n        # TODO 5: Increment expansion depth counter\n        pass\n    \n    def define_macro(self, name, parameters, body):\n        \"\"\"Define a new macro in the macro environment.\"\"\"\n        # TODO 1: Create macro function object with parameters and body\n        # TODO 2: Store in macro environment separate from regular functions\n        # TODO 3: Validate parameter list structure\n        pass\n\n# Integration with existing evaluator\ndef evaluate_with_macros(ast, env, macro_expander):\n    \"\"\"Enhanced evaluate that handles macro expansion.\"\"\"\n    # TODO 1: Expand macros in AST before evaluation\n    # TODO 2: Handle defmacro special form for macro definition  \n    # TODO 3: Pass expanded AST to regular evaluator\n    pass\n```\n\n#### Bytecode Virtual Machine Skeleton\n\n```python\n# bytecode/vm.py\n\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom typing import List, Any\n\nclass OpCode(Enum):\n    PUSH_NUMBER = 1\n    PUSH_SYMBOL = 2\n    LOAD_GLOBAL = 3\n    STORE_GLOBAL = 4\n    LOAD_LOCAL = 5\n    STORE_LOCAL = 6\n    CALL = 7\n    RETURN = 8\n    JUMP = 9\n    JUMP_IF_FALSE = 10\n    ADD = 11\n    SUBTRACT = 12\n    MULTIPLY = 13\n    DIVIDE = 14\n\n@dataclass\nclass Instruction:\n    opcode: OpCode\n    operand: Any = None\n\nclass VirtualMachine:\n    \"\"\"Stack-based virtual machine for executing Lisp bytecode.\"\"\"\n    \n    def __init__(self):\n        self.stack = []\n        self.call_stack = []\n        self.globals = {}\n        self.instruction_pointer = 0\n        self.instructions = []\n    \n    def execute(self, instructions):\n        \"\"\"Execute a sequence of bytecode instructions.\"\"\"\n        self.instructions = instructions\n        self.instruction_pointer = 0\n        \n        # TODO 1: Main execution loop - fetch, decode, execute\n        # TODO 2: Dispatch on instruction opcode\n        # TODO 3: Handle stack operations (push, pop, peek)\n        # TODO 4: Manage call stack for function calls\n        # TODO 5: Update instruction pointer for jumps and calls\n        \n        while self.instruction_pointer < len(self.instructions):\n            instruction = self.instructions[self.instruction_pointer]\n            self.execute_instruction(instruction)\n            \n    def execute_instruction(self, instruction):\n        \"\"\"Execute a single bytecode instruction.\"\"\"\n        # TODO 1: Match on instruction opcode\n        # TODO 2: Implement each instruction's stack effects\n        # TODO 3: Update instruction pointer appropriately\n        # TODO 4: Handle function calls and returns\n        # TODO 5: Manage local variable access\n        pass\n    \n    def push(self, value):\n        \"\"\"Push value onto operand stack.\"\"\"\n        self.stack.append(value)\n    \n    def pop(self):\n        \"\"\"Pop value from operand stack.\"\"\"\n        if not self.stack:\n            raise RuntimeError(\"Stack underflow\")\n        return self.stack.pop()\n```\n\n#### Performance Profiling Implementation\n\n```python\n# tools/profiler.py\n\nimport time\nfrom collections import defaultdict\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\n\n@dataclass\nclass ProfileData:\n    function_name: str\n    call_count: int = 0\n    total_time: float = 0.0\n    self_time: float = 0.0\n    memory_allocated: int = 0\n\nclass Profiler:\n    \"\"\"Performance profiler for Lisp interpreter execution.\"\"\"\n    \n    def __init__(self):\n        self.enabled = False\n        self.profile_data: Dict[str, ProfileData] = defaultdict(ProfileData)\n        self.call_stack: List[tuple] = []  # (function_name, start_time)\n        self.total_allocations = 0\n    \n    def enable(self):\n        \"\"\"Enable profiling data collection.\"\"\"\n        self.enabled = True\n        self.profile_data.clear()\n        self.call_stack.clear()\n    \n    def disable(self):\n        \"\"\"Disable profiling and generate report.\"\"\"\n        self.enabled = False\n        return self.generate_report()\n    \n    def enter_function(self, function_name):\n        \"\"\"Record function entry for timing.\"\"\"\n        if not self.enabled:\n            return\n            \n        # TODO 1: Record current timestamp\n        # TODO 2: Push function and timestamp onto call stack\n        # TODO 3: Initialize profile data if first call\n        start_time = time.perf_counter()\n        self.call_stack.append((function_name, start_time))\n    \n    def exit_function(self, function_name):\n        \"\"\"Record function exit and update timing data.\"\"\"\n        if not self.enabled or not self.call_stack:\n            return\n            \n        # TODO 1: Pop call stack and verify function name matches\n        # TODO 2: Calculate elapsed time for this call\n        # TODO 3: Update total time and call count\n        # TODO 4: Update self time (exclude time spent in callees)\n        end_time = time.perf_counter()\n        stack_name, start_time = self.call_stack.pop()\n        elapsed = end_time - start_time\n        \n        profile = self.profile_data[function_name]\n        profile.call_count += 1\n        profile.total_time += elapsed\n    \n    def generate_report(self) -> str:\n        \"\"\"Generate human-readable profiling report.\"\"\"\n        # TODO 1: Sort functions by total time descending\n        # TODO 2: Format table with function names, call counts, times\n        # TODO 3: Include percentage of total execution time\n        # TODO 4: Add memory allocation statistics if available\n        pass\n```\n\n#### Milestone Checkpoints for Extensions\n\n**Macro System Milestone:**\n- Implement `defmacro` special form that defines new macros\n- Create macro expansion phase that runs before evaluation  \n- Test with simple macros like `(defmacro unless (test body) (list 'if (list 'not test) body))`\n- Verify macro calls expand correctly: `(unless (> x 0) (print \"negative\"))` becomes `(if (not (> x 0)) (print \"negative\"))`\n- Ensure macro expansion happens at appropriate time (before evaluation, not during)\n\n**Data Type Extension Milestone:**\n- Add string operations: concatenation, substring, length, character access\n- Implement vector type with indexing and modification operations\n- Create hash table type with key-value storage and retrieval\n- Test interoperability between new types and existing list operations\n- Verify garbage collection works correctly with new data structures\n\n**Bytecode Compilation Milestone:**  \n- Implement basic instruction set covering arithmetic, variables, function calls\n- Create compiler that translates AST to bytecode instruction stream\n- Build virtual machine that executes bytecode with operand stack\n- Verify bytecode execution produces same results as tree-walking interpreter\n- Measure performance improvement on computation-heavy programs\n\n#### Debugging Tips for Extensions\n\n| Issue | Symptom | Likely Cause | Diagnosis | Fix |\n|-------|---------|--------------|-----------|-----|\n| Macro expansion loops | Stack overflow during expansion | Recursive macro definition | Check macro expansion depth counter | Add maximum expansion depth limit |\n| Bytecode execution errors | Wrong results or crashes | Instruction encoding/decoding mismatch | Compare bytecode output to expected | Verify instruction operand types match |\n| Memory leaks in new data types | Growing memory usage over time | Missing garbage collection integration | Profile memory allocation patterns | Ensure new types participate in GC |\n| Performance regression | Extensions slower than expected | Overhead in hot code paths | Profile execution with and without extensions | Optimize critical path operations |\n| IDE integration failures | Language server crashes or hangs | Incomplete error handling in LSP | Test with malformed input programs | Add comprehensive error recovery |\n\nThese extensions provide substantial opportunities for continued learning in programming language implementation, compiler optimization, and development tooling. Each enhancement demonstrates different aspects of language design and implementation, from the theoretical foundations of macro systems to the practical engineering of bytecode virtual machines and development environment integration.\n\n\n## Glossary\n\n> **Milestone(s):** All milestones (1-4) - this glossary provides essential vocabulary and terminology used throughout the entire interpreter implementation\n\nBuilding a programming language interpreter introduces numerous specialized terms from computer science, functional programming, and language design. This glossary serves as the definitive reference for all technical terminology, data structures, functions, and concepts used throughout the Lisp interpreter design document. Understanding these terms precisely is crucial for implementing a correct and maintainable interpreter.\n\n### Mental Model: The Interpreter's Dictionary\n\nThink of this glossary as the interpreter's comprehensive dictionary - just as human languages have dictionaries that define words, establish correct usage, and clarify subtle distinctions, our interpreter project has its own specialized vocabulary. Each term represents a precise concept with specific meaning in the context of language implementation. Like a good dictionary, this glossary not only defines terms but explains relationships between concepts, common usage patterns, and potential areas of confusion.\n\nThe terminology is organized into logical categories that mirror the architecture and development progression of the interpreter. This organization helps developers understand not just individual terms, but how concepts relate to each other and fit into the larger system design.\n\n### Core Data Structures and Types\n\nThe interpreter's type system forms the foundation for representing all Lisp values and system components. These types enforce correctness through the type system and provide clear interfaces between components.\n\n| Type Name | Fields | Purpose | Usage Notes |\n|-----------|--------|---------|-------------|\n| `LispValue` | `value: Any, type: LispValueType` | Universal container for all Lisp runtime values | Discriminated union pattern - check type field before accessing value |\n| `LispValueType` | enum: `NUMBER, SYMBOL, LIST, FUNCTION, BUILTIN` | Type tag for runtime value discrimination | Used with LispValue to implement tagged union pattern |\n| `Token` | `type: str, value: str, position: int` | Single lexical unit from source text | Position enables source location tracking for error messages |\n| `Environment` | `bindings: Dict[str, LispValue], parent: Optional[Environment]` | Variable name to value mapping with lexical scope chain | Parent reference implements lexical scoping through environment chain |\n| `LispFunction` | `parameters: List[str], body: LispValue, closure_env: Environment, name: Optional[str]` | User-defined function with closure environment | Closure_env captures lexical environment at function definition time |\n| `BuiltinFunction` | `implementation: Callable, name: str, arity: Optional[int]` | Built-in primitive function implementation | Arity None indicates variadic function (accepts any number of arguments) |\n| `Scanner` | `text: str, position: int, tokens: List[Token]` | Stateful tokenizer that converts text to token stream | Position tracks current character index during scanning |\n| `Parser` | `max_nesting_depth: int` | Recursive descent parser with depth limit protection | Prevents stack overflow from deeply nested expressions |\n| `SourceLocation` | `line: int, column: int, position: int, length: int` | Source code position information for error reporting | Enables precise error location reporting to users |\n\n### Error Hierarchy and Exception Types\n\nThe interpreter uses a structured error hierarchy that provides specific error types for different failure modes. This hierarchy enables precise error handling and informative error messages.\n\n| Error Type | Inheritance | Fields | When Thrown |\n|------------|-------------|--------|-------------|\n| `LispError` | Base class | `message: str, source_location: Optional[SourceLocation]` | Base for all interpreter errors |\n| `TokenizerError` | Inherits from `LispError` | Inherited fields only | Malformed tokens, unterminated strings, invalid characters |\n| `ParseError` | Inherits from `LispError` | Inherited fields only | Unbalanced parentheses, unexpected tokens, invalid syntax |\n| `EvaluationError` | Base evaluation error | `message: str, source_location: Optional[int]` | Base class for runtime evaluation errors |\n| `NameError` | Inherits from `EvaluationError` | Inherited fields only | Undefined variable reference, unbound symbol lookup |\n| `TypeError` | Inherits from `EvaluationError` | Inherited fields only | Type mismatch, invalid operation on type |\n| `ArityError` | Specific arity mismatch | `expected: int, actual: int, function_name: str` | Wrong number of arguments to function call |\n\n### Token Classification System\n\nThe tokenizer classifies input text into distinct token types that represent different syntactic elements. This classification drives parser behavior and enables syntax highlighting.\n\n| Token Type | Symbol | Recognition Pattern | Semantic Role |\n|------------|--------|-------------------|---------------|\n| `TokenType.LEFT_PAREN` | `(` | Single character `(` | Begins list or function call expression |\n| `TokenType.RIGHT_PAREN` | `)` | Single character `)` | Ends list or function call expression |\n| `TokenType.NUMBER` | numeric literals | Digits with optional decimal point and sign | Self-evaluating numeric value |\n| `TokenType.SYMBOL` | identifiers/operators | Letter/symbol chars not in strings or parens | Variable names, function names, operators |\n| `TokenType.STRING` | string literals | Text between double quotes with escape support | Self-evaluating string value |\n| `TokenType.QUOTE` | `'` | Single quote character | Shorthand for quote special form |\n| `TokenType.COMMENT` | comments | Semicolon to end of line | Ignored during parsing - documentation only |\n| `TokenType.WHITESPACE` | whitespace | Spaces, tabs, newlines | Token separator - ignored during parsing |\n| `TokenType.EOF` | end of file | End of input stream | Signals completion of token stream |\n\n### Core Evaluation Functions\n\nThe evaluator implements the semantic rules of Lisp through a dispatch mechanism that routes different expression types to appropriate handlers. These functions form the heart of the interpreter.\n\n| Function Signature | Purpose | Implementation Notes |\n|-------------------|---------|---------------------|\n| `evaluate(ast, env) returns LispValue` | Main evaluation dispatch | Routes to specific handlers based on AST node type |\n| `apply_function(func, args, env) returns LispValue` | Function application with argument binding | Creates new environment with parameter bindings |\n| `is_truthy(value) returns bool` | Lisp truthiness evaluation | Only false and empty list are falsy in Lisp |\n| `make_number(value) returns LispValue` | Numeric value constructor | Validates numeric type and creates LispValue wrapper |\n| `make_symbol(name) returns LispValue` | Symbol value constructor | Creates symbol LispValue for identifiers and operators |\n| `make_list(elements) returns LispValue` | List value constructor | Builds proper list from element sequence |\n| `is_number(value) returns bool` | Number type predicate | Type guard for numeric operations |\n| `is_symbol(value) returns bool` | Symbol type predicate | Type guard for symbol operations |\n| `is_list(value) returns bool` | List type predicate | Type guard for list operations |\n\n### Tokenization and Scanning Operations\n\nThe tokenizer converts raw text into a structured stream of tokens through character-by-character scanning with lookahead capabilities.\n\n| Function Signature | Purpose | State Management |\n|-------------------|---------|------------------|\n| `scan_all() returns List[Token]` | Main tokenization loop | Processes entire input text to completion |\n| `current_char() returns Optional[str]` | Current character access | Returns None at end of input |\n| `advance() returns None` | Position advancement | Moves to next character, updates line/column |\n| `skip_whitespace() returns None` | Whitespace consumption | Advances past spaces, tabs, newlines |\n| `scan_string() returns Token` | String literal scanning | Handles escape sequences within quotes |\n| `scan_number() returns Token` | Numeric literal scanning | Supports integers and floating point |\n| `scan_symbol() returns Token` | Symbol/identifier scanning | Continues until delimiter or whitespace |\n| `scan_comment() returns Token` | Comment scanning | Consumes from semicolon to end of line |\n| `make_single_char_token(type) returns Token` | Single character token creation | For parentheses and quote characters |\n\n### Parsing and Structure Building\n\nThe parser transforms the linear token stream into nested tree structures that represent the hierarchical structure of Lisp expressions.\n\n| Function Signature | Purpose | Recursion Handling |\n|-------------------|---------|-------------------|\n| `parse(tokens) returns LispValue` | Main parser entry point | Initiates recursive descent parsing |\n| `read_expr(tokens, position, depth) returns (LispValue, int)` | Single expression parsing | Returns parsed expression and next position |\n| `read_list(tokens, position, depth) returns (LispValue, int)` | Parenthesized list parsing | Recursively parses nested list contents |\n| `read_quote_expr(tokens, position, depth) returns (LispValue, int)` | Quote syntax transformation | Transforms 'expr into (quote expr) |\n| `is_at_end(tokens, position) returns bool` | End of stream detection | Prevents reading beyond token array bounds |\n| `current_token(tokens, position) returns Token` | Safe token access | Returns EOF token beyond array bounds |\n\n### Environment and Scope Management\n\nEnvironments implement lexical scoping through a chain of variable binding mappings. Each environment links to its parent scope, creating a lookup hierarchy.\n\n| Function Signature | Purpose | Scope Behavior |\n|-------------------|---------|----------------|\n| `lookup(name) returns LispValue` | Variable resolution | Searches current environment then parent chain |\n| `define(name, value) returns None` | Variable binding | Creates binding in current environment only |\n| `extend(new_bindings) returns Environment` | Child environment creation | Creates new environment with current as parent |\n| `depth() returns int` | Scope depth calculation | Returns number of environments in parent chain |\n| `all_names() returns set[str]` | Accessible variable enumeration | Returns all variables accessible from current scope |\n| `create_global_environment() returns Environment` | Bootstrap environment creation | Creates root environment with built-in functions |\n\n### Function System Implementation\n\nThe function system supports both user-defined lambda functions and built-in primitive functions with proper closure environment capture.\n\n| Function Signature | Purpose | Closure Handling |\n|-------------------|---------|-----------------|\n| `make_function(parameters, body, closure_env, name) returns LispValue` | User function creation | Captures defining environment in closure |\n| `make_builtin(implementation, name, arity) returns LispValue` | Built-in function creation | No closure needed for built-ins |\n| `is_function(value) returns bool` | Function type predicate | True for both user and built-in functions |\n| `is_user_function(value) returns bool` | User function type guard | Distinguishes user-defined from built-in functions |\n| `is_builtin_function(value) returns bool` | Built-in function type guard | Identifies primitive function implementations |\n| `apply_function(func, args, current_env) returns LispValue` | Function application | Handles both user and built-in function calls |\n\n### List Processing Primitives\n\nList operations implement the fundamental Lisp data structure manipulation primitives: cons, car, cdr, and list construction.\n\n| Function Signature | Purpose | List Structure |\n|-------------------|---------|----------------|\n| `builtin_car(args) returns LispValue` | First element extraction | Returns head of cons cell or list |\n| `builtin_cdr(args) returns LispValue` | Rest extraction | Returns tail of cons cell or list |\n| `builtin_cons(args) returns LispValue` | Pair construction | Creates new cons cell with head and tail |\n| `builtin_list(args) returns LispValue` | List construction | Builds proper nil-terminated list |\n| `builtin_null_p(args) returns LispValue` | Empty list predicate | Tests for empty list (nil) |\n\n### Arithmetic and Comparison Operations\n\nBuilt-in arithmetic and comparison functions implement the mathematical operations that form the computational core of Lisp expressions.\n\n| Function Signature | Purpose | Numeric Handling |\n|-------------------|---------|------------------|\n| `builtin_add(args) returns LispValue` | Addition operation | Sums all arguments, supports multiple operands |\n| `builtin_subtract(args) returns LispValue` | Subtraction operation | Negation with one arg, subtraction with multiple |\n| `builtin_multiply(args) returns LispValue` | Multiplication operation | Product of all arguments |\n| `builtin_divide(args) returns LispValue` | Division operation | Reciprocal with one arg, division with multiple |\n| `builtin_less_than(args) returns LispValue` | Less than comparison | Returns boolean result of numeric comparison |\n\n### Special Form Handlers\n\nSpecial forms control evaluation behavior and cannot be implemented as regular functions because they require custom argument evaluation semantics.\n\n| Function Signature | Purpose | Evaluation Control |\n|-------------------|---------|-------------------|\n| `handle_if(args, env) returns LispValue` | Conditional expression | Evaluates test, then either consequent or alternative |\n| `handle_define(args, env) returns LispValue` | Variable definition | Evaluates value, binds to name in current environment |\n| `handle_lambda(args, env) returns LispValue` | Function definition | Creates function value capturing current environment |\n| `is_special_form(symbol_name) returns bool` | Special form detection | Identifies symbols that require special evaluation |\n\n### Recursion and Tail Call Support\n\nRecursion support enables functions to call themselves, with tail call optimization preventing stack overflow in tail-recursive functions.\n\n| Function Signature | Purpose | Optimization Strategy |\n|-------------------|---------|---------------------|\n| `extend_with_recursion(bindings, name, func) returns Environment` | Recursive function binding | Allows function to reference itself by name |\n| `create_tail_call(func, args, env) returns TailCall` | Tail call continuation | Creates continuation for tail position calls |\n| `execute_trampoline(initial_call) returns LispValue` | Tail call execution | Iteratively executes tail calls without stack growth |\n\n### Pipeline Coordination and Data Flow\n\nThe interpreter coordinates data flow between tokenizer, parser, and evaluator components through a structured pipeline architecture.\n\n| Function Signature | Purpose | Component Integration |\n|-------------------|---------|---------------------|\n| `process_expression(text, environment) returns LispValue` | Complete pipeline execution | Coordinates tokenization, parsing, and evaluation |\n| `evaluate_text(text) returns LispValue` | Multi-expression evaluation | Processes multiple expressions from text input |\n| `prepare_evaluation_context(ast) returns Environment` | Evaluation setup | Prepares environment for expression evaluation |\n| `finalize_evaluation_context(result, env) returns None` | Evaluation cleanup | Handles post-evaluation state management |\n\n### Error Handling and Recovery\n\nError handling provides user-friendly error messages with source context and supports graceful recovery from certain error conditions.\n\n| Function Signature | Purpose | Recovery Strategy |\n|-------------------|---------|------------------|\n| `format_error(error, detail_level) returns str` | Error message formatting | Creates user-readable error descriptions |\n| `extract_source_context(location, context_lines) returns str` | Source context extraction | Shows relevant source lines around error |\n| `format_suggestions(error) returns str` | Error correction suggestions | Provides helpful hints for fixing errors |\n| `recover_from_error(error) returns None` | Error recovery | Attempts to continue processing after recoverable errors |\n| `synchronize_after_error(tokens, position) returns int` | Parser synchronization | Finds next valid parse position after error |\n\n### Testing and Validation Framework\n\nThe testing framework provides structured validation of interpreter components and milestone progress tracking.\n\n| Function Signature | Purpose | Validation Scope |\n|-------------------|---------|------------------|\n| `assertTokenSequence(text, expected_tokens)` | Tokenization validation | Verifies tokenizer produces expected token sequence |\n| `assertParseResult(text, expected_ast)` | Parsing validation | Verifies parser produces expected AST structure |\n| `assertEvaluatesTo(program, expected_result)` | Evaluation validation | Verifies program evaluation produces expected result |\n| `assertTokenizerError(text, pattern)` | Tokenizer error validation | Verifies tokenizer detects expected error conditions |\n| `assertParseError(text, pattern)` | Parser error validation | Verifies parser detects expected syntax errors |\n| `assertEvaluationError(program, error_type)` | Evaluation error validation | Verifies evaluator detects expected runtime errors |\n| `validate_milestone_progress(milestone_number)` | Milestone validation | Automated verification of milestone completion |\n\n### Debugging and Introspection Tools\n\nDebugging tools provide visibility into interpreter internals and help developers understand evaluation behavior and diagnose problems.\n\n| Type/Function | Purpose | Debugging Capability |\n|---------------|---------|---------------------|\n| `TraceEvent` | `event_type: str, expression: Any, environment_id: int, depth: int, result: Optional[Any], error: Optional[str], timestamp: float` | Single evaluation step record |\n| `EvaluationTracer` | `events: List[TraceEvent], current_depth: int, output_file, max_depth, enabled: bool` | Evaluation tracing system |\n| `EnvironmentInspector` | `environment: Environment, inspection_cache: Dict[int, Dict]` | Environment introspection |\n| `trace_evaluation(expression, environment)` | Trace single evaluation | Context manager for detailed evaluation tracing |\n| `log_lookup(variable_name, environment, result)` | Variable lookup logging | Records variable resolution process |\n| `format_trace_output() returns str` | Trace formatting | Human-readable trace output generation |\n| `inspect_chain() returns Dict` | Environment chain inspection | Analysis of entire environment scope chain |\n| `diagnose_lookup_failure(variable_name) returns str` | Lookup failure diagnosis | Explains why variable lookup failed |\n\n### AST Analysis and Visualization\n\nAbstract syntax tree analysis tools help developers understand program structure and identify potential issues in parsed expressions.\n\n| Function Signature | Purpose | Analysis Capability |\n|-------------------|---------|-------------------|\n| `visualize_tree(ast, format) returns str` | AST visualization | Generates visual representation of syntax tree |\n| `analyze_structure(ast) returns Dict` | Structure analysis | Identifies structural properties and potential issues |\n| `compare_structures(ast1, ast2) returns Dict` | Structure comparison | Highlights differences between two ASTs |\n\n### REPL and Interactive Debugging\n\nThe Read-Eval-Print Loop provides interactive development capabilities with integrated debugging commands.\n\n| Type/Function | Purpose | Interactive Capability |\n|---------------|---------|----------------------|\n| `REPLDebugger` | `evaluator: Evaluator, tracer: EvaluationTracer, commands: Dict[str, Callable]` | Interactive debugging interface |\n| `handle_debug_command(command_line) returns str` | Debug command processing | Processes and executes debug commands |\n| `cmd_trace(expression_text) returns str` | Trace command | Enables evaluation tracing for specific expression |\n| `cmd_environment(args) returns str` | Environment command | Displays current environment information |\n\n### Constants and Predefined Values\n\nThe interpreter defines several important constants that represent special values and configuration parameters.\n\n| Constant Name | Value/Type | Purpose | Usage Context |\n|---------------|------------|---------|---------------|\n| `LISP_TRUE` | Boolean true value | Represents truth in Lisp expressions | Returned by comparison and logical operations |\n| `LISP_FALSE` | Boolean false value | Represents falsehood in Lisp expressions | Only LISP_FALSE and EMPTY_LIST are falsy |\n| `EMPTY_LIST` | Empty list representation | Represents nil/empty list | Terminates proper lists, falsy in conditionals |\n| `QUOTE_SYMBOL` | String 'quote' | Symbol name for quote special form | Used in quote syntax transformation |\n| `BUILTIN_FUNCTIONS` | Dictionary mapping | Registry of built-in function implementations | Populated during global environment creation |\n| `SPECIAL_FORMS` | Dictionary mapping | Registry of special form handlers | Maps special form names to handler functions |\n| `ESCAPE_SEQUENCES` | Character mapping | Maps escape sequences to actual characters | Used during string literal tokenization |\n\n### Session and State Management\n\nSession management maintains interpreter state across multiple evaluations and provides coordination between interactive sessions.\n\n| Type/Function | Purpose | State Persistence |\n|---------------|---------|------------------|\n| `InterpreterSession` | `global_env: Environment, expression_count: int` | Persistent interpreter session |\n| `PipelineCoordinator` | `tokenizer, parser, evaluator` components | Pipeline component coordination |\n| `StateManager` | `global_environment: Environment, evaluation_count: int` | Global state management |\n| `with_context(context)` | Error context management | Adds contextual information to errors |\n| `handle_define_operation(name, value)` | Global definition processing | Updates persistent global environment |\n\n### Key Architectural Concepts\n\nUnderstanding these fundamental concepts is crucial for implementing and extending the interpreter correctly.\n\n**S-expression**: The fundamental syntactic structure of Lisp, where both code and data are represented as symbolic expressions using a uniform parenthesized syntax. S-expressions enable homoiconicity - the property that code and data share the same representation.\n\n**Tree-walking interpreter**: An interpretation strategy that directly evaluates abstract syntax tree nodes through recursive function calls, as opposed to compiling to bytecode or machine code first.\n\n**Lexical scoping**: Variable resolution based on where variables are defined in the source code (lexically), not where they are used. Variables are resolved by searching the environment chain from innermost to outermost scope.\n\n**Closure**: A function that captures and retains access to variables from its defining lexical environment, even when called from a different scope. Closures enable first-class functions and proper lexical scoping.\n\n**Environment chain**: The linked sequence of nested environments that implements lexical scoping. Variable lookup traverses this chain from current environment toward root until finding a binding.\n\n**Homoiconicity**: The property where code and data have the same syntactic representation. In Lisp, program source code is written as S-expressions, which are also the primary data structure.\n\n**Special forms**: Language constructs like `if`, `define`, and `lambda` that control evaluation behavior and cannot be implemented as regular functions because they require custom argument evaluation semantics.\n\n**Eager evaluation**: The evaluation strategy where all function arguments are fully evaluated before the function is called, as opposed to lazy evaluation where arguments are evaluated only when needed.\n\n**Recursive descent parsing**: A parsing technique where the parser is structured as a set of mutually recursive functions, each responsible for parsing a particular grammatical construct.\n\n**Tail call optimization**: An optimization technique that converts tail-recursive function calls into loops to prevent stack overflow, allowing efficient recursive algorithms.\n\n### Common Implementation Pitfalls\n\nUnderstanding these common mistakes helps developers avoid frequently encountered problems during interpreter implementation.\n\n⚠️ **Pitfall: Treating Special Forms as Functions**\nSpecial forms like `if`, `define`, and `lambda` control evaluation behavior and must be handled before normal function application. If treated as regular functions, their arguments will be evaluated eagerly, breaking the intended semantics. For example, `(if false (error \"boom\") 42)` should return 42, but if `if` were a function, the error would be evaluated before `if` could choose which branch to take.\n\n⚠️ **Pitfall: Broken Environment Chain References**\nEnvironment parent references must form a proper chain without cycles. If parent references are incorrectly assigned or mutated, variable lookup can fail or enter infinite loops. Always ensure parent references point upward in the scope hierarchy and are never modified after creation.\n\n⚠️ **Pitfall: Closure Environment Capture Errors**\nLambda functions must capture the environment where they are defined, not where they are called. A common mistake is passing the call-site environment instead of the definition-site environment, breaking lexical scoping and making closures behave like dynamic scoping.\n\n⚠️ **Pitfall: Improper List Structure Handling**\nLisp lists must be properly terminated with the empty list marker. Improper lists (not nil-terminated) can cause infinite loops in recursive list processing functions. Always check for proper list termination when implementing car, cdr, and list traversal operations.\n\n⚠️ **Pitfall: Tokenization Boundary Detection Errors**\nThe tokenizer must correctly identify token boundaries, especially with numbers, symbols, and string literals. Common errors include failing to handle negative numbers, not properly escaping string literals, or incorrectly splitting compound tokens.\n\n⚠️ **Pitfall: Parser Stack Overflow on Deep Nesting**\nDeeply nested expressions can cause stack overflow in recursive descent parsers. Implement maximum depth limits and provide helpful error messages when nesting limits are exceeded rather than allowing silent crashes.\n\n⚠️ **Pitfall: Incorrect Arity Checking**\nFunctions must validate that they receive the correct number of arguments. Built-in functions should check argument count before processing, and user-defined functions should verify that the number of arguments matches the number of parameters.\n\n### Future Extension Terminology\n\nThese terms relate to potential enhancements that could be added to the basic interpreter architecture.\n\n**Macro system**: A metaprogramming facility that allows manipulation of code as data before evaluation, enabling domain-specific languages and syntactic extensions.\n\n**Bytecode compilation**: An alternative implementation strategy where the AST is compiled into a linear sequence of simple instructions that are executed by a virtual machine.\n\n**Virtual machine**: A specialized execution engine optimized for running bytecode instructions, typically using a stack-based architecture for expression evaluation.\n\n**Hygienic macros**: A macro system that automatically prevents variable capture problems by ensuring macro-generated identifiers don't accidentally clash with user variables.\n\n**Generational garbage collection**: A memory management strategy that segregates objects by age, collecting short-lived objects more frequently than long-lived ones.\n\n**Language server protocol**: A standardized communication protocol for integrating language intelligence features like autocomplete, error checking, and refactoring with text editors and IDEs.\n\n### Implementation Guidance\n\nThe implementation of the Lisp interpreter requires careful attention to naming conventions and consistent terminology throughout the codebase. This guidance provides the foundation for maintainable and extensible code.\n\n#### Recommended Type System Structure\n\nThe core type system should establish clear discriminated unions and maintain type safety through careful interface design:\n\n```python\nfrom enum import Enum\nfrom typing import Dict, List, Optional, Any, Callable, Union\nfrom dataclasses import dataclass\n\nclass LispValueType(Enum):\n    NUMBER = \"number\"\n    SYMBOL = \"symbol\" \n    LIST = \"list\"\n    FUNCTION = \"function\"\n    BUILTIN = \"builtin\"\n\n@dataclass\nclass LispValue:\n    value: Any\n    type: LispValueType\n    \n    def __post_init__(self):\n        # TODO: Add value type validation based on LispValueType\n        # TODO: Ensure value matches expected type constraints\n        # TODO: Add helpful error messages for type mismatches\n        pass\n\nclass TokenType(Enum):\n    LEFT_PAREN = \"(\"\n    RIGHT_PAREN = \")\"\n    NUMBER = \"number\"\n    SYMBOL = \"symbol\"\n    STRING = \"string\"\n    QUOTE = \"'\"\n    COMMENT = \"comment\"\n    WHITESPACE = \"whitespace\"\n    EOF = \"eof\"\n\n@dataclass\nclass Token:\n    type: str  # Should be TokenType enum value\n    value: str\n    position: int\n```\n\n#### Error Hierarchy Implementation\n\nThe error system provides structured exception handling with rich context information:\n\n```python\n@dataclass\nclass SourceLocation:\n    line: int\n    column: int\n    position: int\n    length: int\n\nclass LispError(Exception):\n    def __init__(self, message: str, source_location: Optional[SourceLocation] = None):\n        self.message = message\n        self.source_location = source_location\n        super().__init__(message)\n\nclass TokenizerError(LispError):\n    pass\n\nclass ParseError(LispError):\n    pass\n\nclass EvaluationError(LispError):\n    def __init__(self, message: str, source_location: Optional[int] = None):\n        # TODO: Extend to include evaluation context\n        # TODO: Add stack trace information\n        # TODO: Include expression that caused the error\n        super().__init__(message)\n\nclass NameError(EvaluationError):\n    pass\n\nclass TypeError(EvaluationError):\n    pass\n\n@dataclass\nclass ArityError(Exception):\n    expected: int\n    actual: int\n    function_name: str\n    \n    def __str__(self):\n        return f\"{self.function_name} expects {self.expected} arguments, got {self.actual}\"\n```\n\n#### Environment Implementation Framework\n\nThe environment system implements lexical scoping through parent chain linking:\n\n```python\n@dataclass\nclass Environment:\n    bindings: Dict[str, LispValue]\n    parent: Optional['Environment'] = None\n    \n    def lookup(self, name: str) -> LispValue:\n        # TODO: Search current environment bindings first\n        # TODO: If not found, recursively search parent chain\n        # TODO: If not found in any environment, raise NameError\n        # TODO: Include helpful suggestion for similar names\n        pass\n    \n    def define(self, name: str, value: LispValue) -> None:\n        # TODO: Add binding to current environment only\n        # TODO: Validate that name is valid identifier\n        # TODO: Consider whether to allow redefinition\n        pass\n    \n    def extend(self, new_bindings: Optional[Dict[str, LispValue]] = None) -> 'Environment':\n        # TODO: Create new environment with self as parent\n        # TODO: Add new_bindings to child environment if provided\n        # TODO: Return child environment for method chaining\n        pass\n```\n\n#### Function System Structure\n\nThe function system supports both user-defined and built-in functions with unified application:\n\n```python\n@dataclass\nclass LispFunction:\n    parameters: List[str]\n    body: LispValue\n    closure_env: Environment\n    name: Optional[str] = None\n\n@dataclass  \nclass BuiltinFunction:\n    implementation: Callable\n    name: str\n    arity: Optional[int] = None  # None indicates variadic\n\ndef make_function(parameters: List[str], body: LispValue, \n                 closure_env: Environment, name: Optional[str] = None) -> LispValue:\n    # TODO: Validate parameter list (no duplicates, valid identifiers)\n    # TODO: Create LispFunction object with provided parameters\n    # TODO: Wrap in LispValue with FUNCTION type\n    # TODO: Return wrapped function value\n    pass\n\ndef make_builtin(implementation: Callable, name: str, \n                arity: Optional[int] = None) -> LispValue:\n    # TODO: Create BuiltinFunction object\n    # TODO: Wrap in LispValue with BUILTIN type  \n    # TODO: Add to global builtin registry\n    # TODO: Return wrapped builtin value\n    pass\n```\n\n#### Debugging and Tracing Infrastructure\n\nThe debugging system provides comprehensive visibility into interpreter execution:\n\n```python\n@dataclass\nclass TraceEvent:\n    event_type: str\n    expression: Any\n    environment_id: int\n    depth: int\n    result: Optional[Any] = None\n    error: Optional[str] = None\n    timestamp: float = 0.0\n\n@dataclass\nclass EvaluationTracer:\n    events: List[TraceEvent]\n    current_depth: int\n    output_file: Optional[str] = None\n    max_depth: int = 100\n    enabled: bool = False\n    \n    def trace_evaluation(self, expression: Any, environment: Environment):\n        # TODO: Create context manager for tracing evaluation\n        # TODO: Record entry and exit events\n        # TODO: Handle exceptions and record error events\n        # TODO: Respect max_depth and enabled settings\n        pass\n\n@dataclass\nclass EnvironmentInspector:\n    environment: Environment\n    inspection_cache: Dict[int, Dict]\n    \n    def inspect_chain(self) -> Dict:\n        # TODO: Walk entire environment chain\n        # TODO: Collect all bindings with scope information\n        # TODO: Identify variable shadowing situations\n        # TODO: Cache results for performance\n        pass\n```\n\n#### Milestone Validation Framework\n\nEach milestone requires specific validation to ensure correct implementation progress:\n\n```python\nclass MilestoneValidator:\n    def __init__(self, interpreter_instance):\n        self.interpreter = interpreter_instance\n    \n    def validate_milestone_1(self):\n        \"\"\"Validate S-Expression Parser completion\"\"\"\n        # TODO: Test tokenization of various input forms\n        # TODO: Verify parsing of nested list structures\n        # TODO: Check quote syntax transformation\n        # TODO: Validate error handling for malformed input\n        pass\n    \n    def validate_milestone_2(self):\n        \"\"\"Validate Basic Evaluation completion\"\"\"  \n        # TODO: Test arithmetic operations with various operands\n        # TODO: Verify conditional evaluation (if statements)\n        # TODO: Check comparison operations return boolean values\n        # TODO: Validate error handling for type mismatches\n        pass\n    \n    def validate_milestone_3(self):\n        \"\"\"Validate Variables and Functions completion\"\"\"\n        # TODO: Test variable definition and lookup\n        # TODO: Verify lambda function creation and application\n        # TODO: Check lexical scoping behavior with nested functions\n        # TODO: Validate closure environment capture\n        pass\n    \n    def validate_milestone_4(self):\n        \"\"\"Validate List Operations & Recursion completion\"\"\"\n        # TODO: Test car, cdr, cons operations\n        # TODO: Verify recursive function definitions work\n        # TODO: Check tail call optimization if implemented\n        # TODO: Validate proper vs improper list handling\n        pass\n```\n\n#### Testing Assertion Framework\n\nThe testing framework provides structured assertions for validating interpreter behavior:\n\n```python\ndef assertTokenSequence(text: str, expected_tokens: List[tuple]) -> None:\n    \"\"\"Verify tokenization produces expected sequence\"\"\"\n    # TODO: Tokenize input text\n    # TODO: Compare resulting tokens with expected sequence\n    # TODO: Check token types, values, and positions\n    # TODO: Provide detailed failure messages\n    pass\n\ndef assertParseResult(text: str, expected_ast: Any) -> None:\n    \"\"\"Verify parsing produces expected AST\"\"\"\n    # TODO: Parse input text through full pipeline\n    # TODO: Compare resulting AST with expected structure\n    # TODO: Handle nested structure comparison recursively\n    # TODO: Provide tree diff on failure\n    pass\n\ndef assertEvaluatesTo(program: str, expected_result: Any) -> None:\n    \"\"\"Verify evaluation produces expected result\"\"\"\n    # TODO: Run program through complete interpreter pipeline\n    # TODO: Compare result with expected value\n    # TODO: Handle different LispValue types appropriately\n    # TODO: Provide context on evaluation failure\n    pass\n```\n\nThis glossary establishes the complete vocabulary and conceptual framework necessary for implementing a correct and maintainable Lisp interpreter. Each term represents a precise concept with specific meaning in the context of language implementation, and understanding these relationships is crucial for successful interpreter development.\n"}