{"html":"<h1 id=\"markdown-renderer-design-document\">Markdown Renderer: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>A Markdown to HTML converter that transforms markdown text into semantic HTML through a multi-stage parsing pipeline. The key architectural challenge is handling the recursive nature of nested elements while maintaining proper precedence between block-level and inline elements.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation</p>\n</blockquote>\n<p>At its core, building a markdown renderer means solving a <strong>document transformation problem</strong> — converting human-friendly lightweight markup into structured HTML that browsers can render. This challenge sits at the intersection of text processing, formal language parsing, and document structure understanding. The fundamental difficulty lies in the fact that markdown&#39;s informal, human-readable syntax must be transformed into HTML&#39;s strict, nested tag structure while preserving semantic meaning and handling edge cases gracefully.</p>\n<p>The markdown parsing problem exemplifies what makes text processing both fascinating and challenging for software engineers. Unlike parsing structured data formats like JSON or XML, markdown parsing must handle ambiguous syntax, context-dependent interpretation, and the inherent messiness of human-authored content. A single line of text might be a heading, the start of a paragraph, part of a code block, or a list item — the parser must examine surrounding context, indentation patterns, and delimiter sequences to make the correct determination.</p>\n<p>This design document addresses the architectural decisions needed to build a robust markdown renderer that can handle the full spectrum of CommonMark syntax while remaining maintainable and extensible. We focus on the critical parsing pipeline design, the intermediate representations that enable correct transformation, and the error handling strategies that ensure graceful degradation when encountering malformed input.</p>\n<h3 id=\"the-document-transformation-mental-model\">The Document Transformation Mental Model</h3>\n<p>Think of markdown parsing like <strong>translating between two human languages with fundamentally different grammatical structures</strong>. Imagine you&#39;re translating from a language that uses word order and context to convey meaning (like English) into a language that uses explicit grammatical particles and nested structures (like Japanese or Latin). The translator doesn&#39;t just substitute words — they must understand the semantic intent of entire phrases and restructure them according to the target language&#39;s rules.</p>\n<p>In markdown parsing, the &quot;source language&quot; is markdown&#39;s lightweight, context-dependent syntax where meaning emerges from patterns like indentation, blank lines, and special character sequences. The &quot;target language&quot; is HTML&#39;s explicit, hierarchically nested tag structure where every element has clear boundaries and relationships. Just as a human translator must understand context and implied meaning, a markdown parser must infer document structure from visual patterns and formatting conventions.</p>\n<p>Consider this concrete example of the transformation challenge:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code># Getting Started\n\nHere's a simple example:\n\n    def hello():\n        print(&quot;world&quot;)\n\nThis shows basic **Python** syntax.</code></pre></div>\n\n<p>The human reader immediately recognizes this as a heading, followed by introductory text, then a code block, and finally a concluding paragraph with emphasis. However, the parser must systematically analyze each line to make these determinations. The heading is identified by the <code>#</code> prefix pattern. The blank lines signal paragraph boundaries. The consistent four-space indentation indicates a code block. The <code>**</code> delimiters mark inline emphasis within the final paragraph.</p>\n<p>The parser must handle this analysis in a way that mirrors how humans process the document — first identifying the overall block structure (heading, paragraph, code block, paragraph), then processing inline formatting within each block. This two-phase approach reflects how we naturally read documents: we first perceive the layout and major sections, then focus on detailed formatting within each section.</p>\n<p>The translation analogy extends to error handling as well. When a human translator encounters ambiguous or incorrect source text, they make reasonable assumptions about intent and produce the most sensible translation possible. Similarly, markdown parsers must handle malformed input gracefully — treating unmatched delimiters as literal text, continuing parsing after encountering invalid syntax, and producing reasonable HTML output even from imperfect markdown input.</p>\n<p>This mental model of <strong>progressive structural interpretation</strong> guides our architectural decisions. Like a translator working with complex nested clauses, our parser must maintain context about its current position in the document structure while making local decisions about individual elements. It must handle both the forest (overall document organization) and the trees (individual formatting elements) in a coordinated fashion.</p>\n<h3 id=\"existing-parsing-approaches\">Existing Parsing Approaches</h3>\n<p>The markdown parsing landscape offers three primary architectural approaches, each representing different trade-offs between implementation complexity, parsing accuracy, and maintainability. Understanding these approaches provides crucial context for our design decisions and helps illuminate why certain architectural patterns emerge as best practices.</p>\n<blockquote>\n<p><strong>Decision: Two-Phase Parsing Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Markdown syntax exhibits both block-level structure (paragraphs, headings, lists) and inline formatting (emphasis, links, code spans). These two levels interact in complex ways that require different parsing strategies.</li>\n<li><strong>Options Considered</strong>: Regex-only approach, recursive descent parser, two-phase block-then-inline parser</li>\n<li><strong>Decision</strong>: Implement a two-phase parser that handles block structure first, then processes inline elements within each block</li>\n<li><strong>Rationale</strong>: Block structure provides the fundamental document skeleton and is largely context-independent, while inline parsing requires understanding of the containing block type. Separating these concerns simplifies both parsing phases and aligns with how humans read documents.</li>\n<li><strong>Consequences</strong>: Enables simpler, more maintainable parsing logic at the cost of requiring two complete passes through the document content.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Implementation Complexity</th>\n<th>Parsing Accuracy</th>\n<th>Performance</th>\n<th>Maintainability</th>\n<th>Error Recovery</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Regex-Only</td>\n<td>Low</td>\n<td>Poor</td>\n<td>High</td>\n<td>Poor</td>\n<td>Poor</td>\n</tr>\n<tr>\n<td>Recursive Descent</td>\n<td>High</td>\n<td>High</td>\n<td>Medium</td>\n<td>Medium</td>\n<td>Good</td>\n</tr>\n<tr>\n<td>Two-Phase (Block + Inline)</td>\n<td>Medium</td>\n<td>High</td>\n<td>Medium</td>\n<td>Good</td>\n<td>Good</td>\n</tr>\n</tbody></table>\n<p><strong>The Regex-Only Approach</strong> represents the most straightforward implementation strategy, where each markdown construct maps to a regular expression pattern. A heading parser might use <code>^(#{1,6})\\s+(.+)$</code> to match ATX-style headings, while emphasis detection could employ <code>\\*\\*([^*]+)\\*\\*</code> for bold text. This approach feels natural to developers familiar with text processing and offers immediate gratification — you can have basic markdown rendering working in under 100 lines of code.</p>\n<p>However, the regex-only approach quickly encounters fundamental limitations that stem from markdown&#39;s context-sensitive nature. Consider the challenge of parsing emphasis correctly: the pattern <code>_underscore_emphasis_</code> should render as <code>&lt;em&gt;underscore_emphasis&lt;/em&gt;</code> because underscores in the middle of words don&#39;t trigger emphasis according to CommonMark rules. A simple regex cannot encode this contextual understanding without becoming prohibitively complex. Additionally, nested structures like lists containing code blocks or blockquotes containing emphasis require sophisticated lookahead and backtracking that pushes regular expressions beyond their effective limits.</p>\n<p>The error recovery characteristics of regex-based parsing prove particularly problematic. When a regular expression fails to match, the parser has little context about why the failure occurred or how to proceed. This leads to either silent failures (where malformed markdown disappears from output) or catastrophic failures (where a single syntax error breaks the entire parsing process). Real-world markdown documents contain numerous edge cases and minor syntax errors that require graceful handling.</p>\n<p><strong>The Recursive Descent Approach</strong> treats markdown as a formal grammar and builds a traditional recursive descent parser with productions for each syntactic construct. This approach offers excellent theoretical foundations and can handle arbitrarily complex nested structures with proper precedence handling. Parser generators or hand-written recursive functions naturally express the hierarchical relationships between markdown elements.</p>\n<p>Recursive descent parsers excel at error recovery because they maintain rich context about the current parsing position and can implement sophisticated backtracking strategies. When parsing fails at one level, the parser can unwind to a previous state and attempt alternative interpretations. This leads to robust handling of malformed input and better diagnostic error messages.</p>\n<p>The primary challenge with recursive descent parsing lies in markdown&#39;s inherent ambiguity and lookahead requirements. Unlike programming languages with unambiguous grammars, markdown often requires examining multiple lines ahead to make parsing decisions. Setext-style headings (where the heading text is followed by a line of <code>===</code> or <code>---</code> characters) exemplify this challenge — the parser cannot definitively identify a heading until it reads the following line. This lookahead requirement complicates the recursive descent approach and can lead to significant backtracking overhead.</p>\n<p><strong>The Two-Phase Parsing Approach</strong> emerged from the CommonMark specification&#39;s recognition that block-level and inline parsing represent fundamentally different challenges requiring different strategies. This approach first processes the entire document to identify block-level structures (paragraphs, headings, lists, code blocks, blockquotes), building an intermediate representation that captures the document&#39;s hierarchical organization. The second phase processes inline elements within each block, handling emphasis, links, images, and code spans according to rules specific to each block type.</p>\n<p>The key insight driving two-phase parsing is that <strong>block structure provides semantic context for inline parsing</strong>. Code blocks disable all inline processing, preserving literal text exactly as written. List items require special handling of line breaks and continuation. Headings process inline elements but ignore certain constructs like line breaks. By establishing block structure first, the inline parser operates with clear context about how to interpret formatting within each container.</p>\n<p>Two-phase parsing also enables superior error handling through <strong>graceful degradation</strong>. If block parsing encounters malformed syntax, it can fall back to treating questionable content as paragraph text, allowing inline parsing to proceed normally. If inline parsing fails to match emphasis delimiters correctly, it can render them as literal text without affecting the overall document structure. This resilience mirrors how humans read documents — we can extract meaning even from imperfectly formatted text.</p>\n<p>The intermediate representation between parsing phases provides a natural extension point for custom functionality. Additional block types, custom renderers, and syntax validation can all hook into the AST structure without modifying the core parsing logic. This architectural flexibility proves crucial for long-term maintainability and feature enhancement.</p>\n<table>\n<thead>\n<tr>\n<th>Parsing Phase</th>\n<th>Input Format</th>\n<th>Processing Strategy</th>\n<th>Output Format</th>\n<th>Error Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Block Parsing</td>\n<td>Raw markdown text</td>\n<td>Line-by-line state machine</td>\n<td>Block-structured AST</td>\n<td>Fallback to paragraph blocks</td>\n</tr>\n<tr>\n<td>Inline Parsing</td>\n<td>Text content from AST blocks</td>\n<td>Delimiter-based pattern matching</td>\n<td>Fully populated AST</td>\n<td>Render unmatched delimiters as literal text</td>\n</tr>\n<tr>\n<td>HTML Generation</td>\n<td>Complete AST structure</td>\n<td>Tree traversal with node-specific renderers</td>\n<td>Valid HTML output</td>\n<td>Escape invalid content, continue processing</td>\n</tr>\n</tbody></table>\n<p>The two-phase approach does introduce some complexity overhead compared to simpler alternatives. The parser must maintain sophisticated state between phases, and certain edge cases require coordination between block and inline processing. However, this complexity remains localized within well-defined architectural boundaries, making it manageable compared to the sprawling complexity that emerges from trying to handle all parsing concerns simultaneously.</p>\n<blockquote>\n<p><strong>The critical architectural insight is that document structure emerges at different levels of granularity, and each level requires specialized parsing strategies that align with how humans naturally process written content.</strong></p>\n</blockquote>\n<p>Understanding these parsing approaches provides the foundation for our detailed design decisions in subsequent sections. The two-phase architecture shapes everything from our data model design to our error handling strategies, and recognizing the trade-offs involved helps explain why certain implementation choices emerge as architectural necessities rather than arbitrary preferences.</p>\n<p>⚠️ <strong>Pitfall: Attempting Single-Pass Parsing</strong>\nMany developers initially attempt to parse both block structure and inline formatting in a single pass through the markdown text. This approach seems more efficient and simpler to implement. However, it quickly leads to complex, brittle code that struggles with context-dependent parsing rules. For example, determining whether <code>*</code> characters represent list bullets, emphasis markers, or literal text requires understanding the surrounding block context. Single-pass parsers either make incorrect parsing decisions or require extensive backtracking that negates any performance benefits. The two-phase approach, while requiring two passes through the content, results in significantly cleaner, more maintainable code that handles edge cases correctly.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Our implementation strategy focuses on building a robust foundation that can grow with your understanding while providing immediate feedback on progress. The technology choices prioritize clarity and debuggability over performance optimization, recognizing that correct implementation comes before efficient implementation.</p>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Text Processing</td>\n<td>String manipulation with <code>str.split()</code> and <code>str.strip()</code></td>\n<td>Regular expressions with <code>re</code> module</td>\n<td>Start simple, add regex patterns as needed</td>\n</tr>\n<tr>\n<td>Data Structures</td>\n<td>Dictionaries and lists for AST nodes</td>\n<td>Custom classes with type hints</td>\n<td>Dictionaries are easier to debug and inspect</td>\n</tr>\n<tr>\n<td>Input/Output</td>\n<td>File reading with <code>open()</code> and string returns</td>\n<td>Streaming with generators for large files</td>\n<td>File-based I/O suffices for learning projects</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td><code>assert</code> statements with sample inputs</td>\n<td><code>unittest</code> or <code>pytest</code> framework</td>\n<td>Simple assertions provide immediate feedback</td>\n</tr>\n<tr>\n<td>HTML Generation</td>\n<td>String concatenation and <code>.format()</code></td>\n<td>Template engines like <code>jinja2</code></td>\n<td>String operations keep dependencies minimal</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>markdown-renderer/\n├── src/\n│   ├── __init__.py\n│   ├── lexer.py              ← Text tokenization utilities\n│   ├── block_parser.py       ← Block-level element parsing\n│   ├── inline_parser.py      ← Inline formatting parsing  \n│   ├── list_parser.py        ← List-specific parsing logic\n│   ├── html_generator.py     ← AST to HTML conversion\n│   └── ast_nodes.py          ← Data structures for parsed content\n├── tests/\n│   ├── __init__.py\n│   ├── test_block_parser.py  ← Block parsing verification\n│   ├── test_inline_parser.py ← Inline parsing verification\n│   ├── test_integration.py   ← End-to-end parsing tests\n│   └── fixtures/             ← Sample markdown files\n│       ├── basic.md\n│       ├── complex.md\n│       └── edge_cases.md\n├── examples/\n│   ├── simple_example.py     ← Basic usage demonstration\n│   └── sample_documents/     ← Test markdown files\n└── main.py                   ← Command-line interface</code></pre></div>\n\n<p>This structure separates concerns clearly while keeping the project manageable. Each parsing phase gets its own module, making it easy to test components independently and understand their responsibilities. The <code>ast_nodes.py</code> module provides shared data structures, while <code>lexer.py</code> contains utilities used across multiple parsing phases.</p>\n<p><strong>Infrastructure Starter Code:</strong></p>\n<p>The following complete utility functions handle common text processing tasks that aren&#39;t central to learning parsing concepts but are necessary for implementation:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/lexer.py - Complete utility functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> normalize_line_endings</span><span style=\"color:#E1E4E8\">(text):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert all line endings to Unix-style </span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\"> characters.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> text.replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">).replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> split_into_lines</span><span style=\"color:#E1E4E8\">(text):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Split text into lines, preserving information about blank lines.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> normalize_line_endings(text).split(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> [(i, line) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i, line </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(lines)]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_blank_line</span><span style=\"color:#E1E4E8\">(line):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if a line contains only whitespace characters.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(line.strip()) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> get_indentation_level</span><span style=\"color:#E1E4E8\">(line):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Calculate the number of leading spaces in a line.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(line) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(line.lstrip(</span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> remove_leading_spaces</span><span style=\"color:#E1E4E8\">(line, num_spaces):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Remove up to num_spaces leading spaces from line.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    spaces_to_remove </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> min</span><span style=\"color:#E1E4E8\">(num_spaces, get_indentation_level(line))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> line[spaces_to_remove:]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># src/html_generator.py - HTML escaping utilities</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">HTML_ESCAPE_TABLE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x26;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;amp;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x3C;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;lt;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '>'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;gt;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '\"'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;quot;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"'\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;#x27;'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> escape_html</span><span style=\"color:#E1E4E8\">(text):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Escape special HTML characters to prevent injection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> char, escape </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> HTML_ESCAPE_TABLE</span><span style=\"color:#E1E4E8\">.items():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> result.replace(char, escape)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> pretty_print_html</span><span style=\"color:#E1E4E8\">(html, indent_size</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Add indentation to HTML for readable output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indent_level </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> line </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> html.split(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        line </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> line.strip()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> line:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> line.startswith(</span><span style=\"color:#9ECBFF\">'&#x3C;/'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            indent_level </span><span style=\"color:#F97583\">-=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines.append(</span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> (indent_level </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> indent_size) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> line)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> line.startswith(</span><span style=\"color:#9ECBFF\">'&#x3C;'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> line.startswith(</span><span style=\"color:#9ECBFF\">'&#x3C;/'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> line.endswith(</span><span style=\"color:#9ECBFF\">'/>'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            indent_level </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">.join(lines)</span></span></code></pre></div>\n\n<p><strong>Core Parsing Infrastructure Skeleton:</strong></p>\n<p>The main parsing coordinator provides the overall structure while leaving the core logic for you to implement:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># src/markdown_parser.py - Main parsing coordinator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MarkdownParser</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Coordinates the two-phase parsing process from markdown to HTML.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.block_parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BlockParser()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.inline_parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> InlineParser()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.html_generator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> HTMLGenerator()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_to_html</span><span style=\"color:#E1E4E8\">(self, markdown_text):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Convert markdown text to HTML through two-phase parsing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            markdown_text (str): Raw markdown content</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            str: Valid HTML output</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Use lexer utilities to split text into lines and normalize formatting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Pass lines to block parser to build initial AST structure  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Pass block AST to inline parser to process formatting within blocks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Pass complete AST to HTML generator for final output</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return escaped, properly formatted HTML</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_file</span><span style=\"color:#E1E4E8\">(self, file_path):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Parse a markdown file and return HTML output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Open file and read contents with proper encoding handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call parse_to_html with file contents</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle file reading errors gracefully</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># src/ast_nodes.py - Data structure skeletons</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ASTNode</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all AST nodes in the parsing tree.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, node_type):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Define common fields needed by all AST nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: node_type, children, parent, line_number are useful</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BlockNode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ASTNode</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for block-level elements like paragraphs and headings.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, block_type):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Initialize base class and add block-specific fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Block nodes contain inline content and have block-specific attributes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InlineNode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ASTNode</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for inline elements like emphasis and links.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, inline_type):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Initialize base class and add inline-specific fields  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Inline nodes often have text content and formatting attributes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Language-Specific Implementation Hints:</strong></p>\n<p>Python&#39;s string processing capabilities make it an excellent choice for text parsing projects. Key language features that simplify markdown parsing include:</p>\n<ul>\n<li><strong>String slicing</strong>: Use <code>line[2:]</code> to remove leading <code>## </code> from headings, <code>text[start:end]</code> for extracting content between delimiters</li>\n<li><strong>String methods</strong>: <code>str.startswith()</code> for prefix detection, <code>str.strip()</code> for whitespace removal, <code>str.count()</code> for delimiter counting</li>\n<li><strong>List comprehensions</strong>: <code>[line for line in lines if not is_blank_line(line)]</code> for filtering, <code>[get_indentation_level(line) for line in block]</code> for indentation analysis</li>\n<li><strong>Regular expressions</strong>: Import <code>re</code> module for complex pattern matching, use <code>re.compile()</code> to precompile frequently used patterns for better performance</li>\n<li><strong>Dictionary-based state machines</strong>: Use dictionaries to map states to handler functions, enabling clean state machine implementation without complex if-elif chains</li>\n</ul>\n<p>When implementing the parsing logic, prefer explicit state tracking over implicit assumptions. Maintain variables like <code>current_block_type</code>, <code>indentation_stack</code>, and <code>delimiter_stack</code> to make parsing decisions transparent and debuggable. Use descriptive variable names like <code>heading_level</code> instead of <code>level</code>, <code>emphasis_delimiter</code> instead of <code>delim</code> — the extra verbosity pays dividends when debugging complex parsing edge cases.</p>\n<p><strong>Debugging and Verification Strategies:</strong></p>\n<p>Since markdown parsing involves complex text transformations, robust debugging capabilities are essential. Build debugging support into your parser from the beginning:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Debug utilities to include in your implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> debug_print_ast</span><span style=\"color:#E1E4E8\">(node, indent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Print AST structure with indentation showing hierarchy.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement tree traversal that shows node types and content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # This helps verify that parsing creates the expected structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> debug_print_parsing_steps</span><span style=\"color:#E1E4E8\">(parser, text):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Show step-by-step parsing decisions for debugging.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add logging to show which parsing rules match each line</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # This helps identify where parsing goes wrong on malformed input</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_html_output</span><span style=\"color:#E1E4E8\">(html):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Basic validation that generated HTML is well-formed.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check that all opening tags have matching closing tags</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify that special characters are properly escaped</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # This catches common HTML generation errors before manual testing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p>The key to successful markdown parser implementation is building incrementally with constant verification. After implementing each parsing component, test it thoroughly with both valid and malformed input before moving to the next component. The two-phase architecture makes this incremental approach natural — you can verify block parsing completely before touching inline parsing, then verify inline parsing before implementing HTML generation.</p>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation</p>\n</blockquote>\n<h3 id=\"the-scope-definition-mental-model\">The Scope Definition Mental Model</h3>\n<p>Think of building a markdown renderer like planning a house construction project. Just as a house contractor must clearly define what&#39;s included in the base contract versus what constitutes expensive custom work, we must establish precise boundaries for our markdown renderer. Without clear scope boundaries, feature creep will transform a beginner-friendly learning project into an overwhelming enterprise-grade parsing system. The goals and non-goals serve as our project contract, protecting both the implementation timeline and the learning experience.</p>\n<p>Every markdown renderer exists within a spectrum of complexity. On one end lie minimal parsers that handle basic formatting with simple regular expressions. On the other end sit full-featured systems like GitHub&#39;s markdown processor that support dozens of extensions, custom syntax highlighting, mathematical notation, and complex table formatting. Our markdown renderer intentionally positions itself as a comprehensive but focused implementation that teaches core parsing principles without drowning learners in edge cases and rarely-used features.</p>\n<p>The key insight is that markdown parsing involves two distinct types of complexity: <strong>structural complexity</strong> (how we parse and represent markdown) and <strong>feature complexity</strong> (what markdown syntax we support). Our goals maximize structural complexity to teach essential parsing concepts while carefully limiting feature complexity to maintain project feasibility. This approach ensures learners experience the full architectural challenges of building a document transformer without getting lost in specification minutiae.</p>\n<h3 id=\"primary-goals\">Primary Goals</h3>\n<p>The markdown renderer has four primary objectives that directly align with the core learning outcomes for building document transformation systems.</p>\n<p><strong>Goal 1: Implement Core CommonMark Block Elements</strong></p>\n<p>Our renderer will support the fundamental block-level structures that form the backbone of structured documents. This includes ATX-style headings (hash-prefixed), paragraphs with proper line handling, fenced and indented code blocks, horizontal rules, and blockquotes with nesting support. These elements teach the essential concept of <strong>block-level parsing</strong>, where we must identify document structure by analyzing line patterns and maintaining parsing state across multiple lines.</p>\n<p>The structural learning value comes from implementing the state machine logic needed to distinguish between different block types, handle multi-line content correctly, and manage the transition between parsing phases. Code blocks, for example, require different parsing rules than regular paragraphs—content inside code blocks must be preserved literally without further markdown processing.</p>\n<p><strong>Goal 2: Implement Essential Inline Formatting Elements</strong></p>\n<p>Within the content of block elements, our renderer will parse inline formatting including emphasis (bold and italic using asterisks and underscores), inline code spans with backtick delimiters, hyperlinks using bracket-parenthesis syntax, and images using the exclamation-bracket-parenthesis pattern. These elements introduce the critical challenge of <strong>nested parsing</strong>, where formatting elements can contain other formatting elements with proper precedence rules.</p>\n<p>The key learning objective is mastering <strong>delimiter matching</strong>—the algorithm for finding pairs of formatting markers while handling mismatched delimiters, escaped characters, and nested structures correctly. This teaches pattern recognition, state management, and the recursive nature of text processing.</p>\n<p><strong>Goal 3: Implement Hierarchical List Structures</strong></p>\n<p>Both ordered and unordered lists with full nesting support represent one of the most complex structural parsing challenges in markdown. Lists require tracking indentation levels, distinguishing between list continuation and new list items, handling mixed content within list items, and building proper tree structures for nested lists. This goal teaches <strong>recursive parsing</strong> and <strong>indentation-based structure detection</strong>.</p>\n<p>Lists also introduce the concept of <strong>context-dependent parsing</strong>, where the meaning of a line depends on its position relative to other elements. A line starting with <code>1.</code> might begin an ordered list, continue an existing list, or simply be regular paragraph content, depending on indentation and surrounding context.</p>\n<p><strong>Goal 4: Generate Valid, Well-Formed HTML Output</strong></p>\n<p>The final parsing phase converts our internal AST representation into semantic HTML5. This includes proper HTML entity escaping for special characters, correct nesting of HTML elements, and optionally formatted output with consistent indentation. This goal teaches <strong>tree traversal algorithms</strong>, <strong>character encoding safety</strong>, and the principles of generating structured output from internal representations.</p>\n<p>HTML generation also introduces the concept of <strong>separation of concerns</strong> between parsing and rendering. The same AST could theoretically generate different output formats (HTML, XML, plain text) with different renderer implementations.</p>\n<table>\n<thead>\n<tr>\n<th>Core Goal</th>\n<th>Primary Learning Concept</th>\n<th>Key Implementation Challenge</th>\n<th>Success Metric</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Block Elements</td>\n<td>State machine parsing</td>\n<td>Line-by-line content classification</td>\n<td>Correctly parse mixed block types in sequence</td>\n</tr>\n<tr>\n<td>Inline Formatting</td>\n<td>Delimiter matching and nesting</td>\n<td>Handling nested emphasis and mismatched delimiters</td>\n<td>Bold text can contain italic text and vice versa</td>\n</tr>\n<tr>\n<td>Hierarchical Lists</td>\n<td>Recursive structure building</td>\n<td>Indentation tracking and list continuation</td>\n<td>Three-level nested lists render correctly</td>\n</tr>\n<tr>\n<td>HTML Generation</td>\n<td>Tree traversal and escaping</td>\n<td>Safe character encoding and valid markup</td>\n<td>Output passes W3C HTML5 validation</td>\n</tr>\n</tbody></table>\n<h3 id=\"secondary-goals\">Secondary Goals</h3>\n<p>Beyond the core parsing functionality, our markdown renderer includes several secondary objectives that enhance the learning experience and prepare for real-world usage scenarios.</p>\n<p><strong>Comprehensive Error Handling and Recovery</strong></p>\n<p>Rather than failing on malformed input, our renderer implements <strong>graceful degradation</strong> strategies that produce reasonable output even from invalid markdown. When encountering mismatched emphasis delimiters like <code>**bold text*</code>, the renderer should treat the unmatched markers as literal text rather than crashing or producing invalid HTML. This teaches defensive programming and the importance of robust parsers in production systems.</p>\n<p>Error recovery also includes handling edge cases like empty inputs, files with only whitespace, unclosed code blocks, and deeply nested structures. Each error scenario provides learning opportunities about input validation and parser resilience.</p>\n<p><strong>Extensible Architecture with Plugin Points</strong></p>\n<p>The renderer design includes well-defined interfaces that allow customization of HTML output without modifying core parsing logic. This might include custom CSS class injection, alternative HTML element choices, or specialized rendering for code blocks with syntax highlighting hooks. This secondary goal teaches <strong>interface design</strong> and <strong>extensibility patterns</strong> common in larger software systems.</p>\n<p>The plugin architecture demonstrates how to build systems that support customization while maintaining a stable core. Even if learners don&#39;t implement custom renderers, understanding the extension points teaches valuable lessons about API design.</p>\n<p><strong>Performance-Conscious Implementation</strong></p>\n<p>While performance is not the primary objective, our implementation avoids obviously inefficient patterns that would make the renderer unusable on moderately-sized documents. This means single-pass parsing where possible, avoiding excessive string copying, and using appropriate data structures for different operations. This goal teaches <strong>algorithmic efficiency</strong> awareness without requiring advanced optimization techniques.</p>\n<p>Performance consciousness also includes memory usage patterns—building AST nodes incrementally rather than storing entire document content in memory simultaneously, and cleaning up intermediate parsing state appropriately.</p>\n<h3 id=\"explicit-non-goals\">Explicit Non-Goals</h3>\n<p>Understanding what we will NOT implement is equally important for maintaining project scope and completion timeline. These non-goals represent features that would significantly increase implementation complexity without proportional learning value for a beginner-level project.</p>\n<p><strong>Advanced CommonMark Extensions</strong></p>\n<p>We will not implement tables, strikethrough text, task lists, footnotes, definition lists, or mathematical notation. While these features appear in many markdown flavors, they introduce substantial parsing complexity without teaching fundamentally new concepts. Tables alone require multi-pass parsing, column alignment algorithms, and complex HTML generation logic that could double the project timeline.</p>\n<p>The decision to exclude extensions focuses learning energy on mastering the core parsing patterns rather than memorizing specification details for rarely-used syntax features.</p>\n<p><strong>Custom Syntax Extensions</strong></p>\n<p>Unlike some markdown processors, our renderer will not support custom syntax through configuration or plugins. Features like custom block types, alternative link syntax, or embed codes for external content fall outside our scope. Supporting custom syntax requires building a parser generator or macro system, which represents a completely different architectural challenge.</p>\n<p>This boundary keeps the project focused on understanding markdown parsing specifically rather than general-purpose language processing.</p>\n<p><strong>Advanced HTML Features and Customization</strong></p>\n<p>We will not generate custom CSS classes, support HTML attributes in markdown syntax, or provide extensive HTML customization options. The HTML output will be clean, semantic HTML5 without styling concerns. While some markdown processors allow syntax like <code>{.css-class}</code> to add attributes, this feature adds parsing complexity without teaching core document transformation concepts.</p>\n<p>Similarly, we won&#39;t support inline HTML pass-through beyond basic safety (HTML tags in markdown content should be escaped, not rendered). Supporting mixed HTML/markdown requires a much more sophisticated parser that can switch between parsing modes dynamically.</p>\n<p><strong>Performance Optimization and Streaming</strong></p>\n<p>Our implementation will not focus on streaming large documents, incremental parsing, or memory optimization for massive files. While production markdown processors often implement these features, they require advanced techniques like lazy evaluation, parser combinators, or custom memory management that would obscure the fundamental parsing algorithms we&#39;re trying to teach.</p>\n<p>The renderer should handle documents up to several hundred kilobytes efficiently, which covers the vast majority of real-world markdown files without requiring optimization complexity.</p>\n<p><strong>Specification Compliance Edge Cases</strong></p>\n<p>We will not implement every edge case detail from the CommonMark specification, particularly around whitespace handling, Unicode normalization, or obscure delimiter precedence rules. For example, the exact behavior of emphasis markers inside words (<code>middle_of_word</code> should not trigger emphasis) is important for production systems but adds implementation complexity that doesn&#39;t teach new concepts.</p>\n<p>Our approach prioritizes implementing the common usage patterns correctly rather than achieving 100% specification compliance on edge cases that rarely appear in real documents.</p>\n<table>\n<thead>\n<tr>\n<th>Non-Goal Category</th>\n<th>Specific Excluded Features</th>\n<th>Rationale</th>\n<th>Alternative Learning Path</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Advanced Extensions</td>\n<td>Tables, footnotes, math notation</td>\n<td>Doubles complexity without new parsing concepts</td>\n<td>Separate advanced project after completing core renderer</td>\n</tr>\n<tr>\n<td>Custom Syntax</td>\n<td>Plugin-based syntax, custom blocks</td>\n<td>Requires parser generator architecture</td>\n<td>Study existing parser frameworks like ANTLR</td>\n</tr>\n<tr>\n<td>HTML Customization</td>\n<td>CSS injection, attribute syntax</td>\n<td>HTML generation becomes dominant complexity</td>\n<td>Separate CSS/styling project</td>\n</tr>\n<tr>\n<td>Performance</td>\n<td>Streaming, memory optimization</td>\n<td>Obscures fundamental algorithms</td>\n<td>Performance engineering course after mastering basics</td>\n</tr>\n<tr>\n<td>Specification Compliance</td>\n<td>Unicode edge cases, obscure precedence</td>\n<td>Implementation detail memorization vs. concept learning</td>\n<td>Read CommonMark spec for completeness understanding</td>\n</tr>\n</tbody></table>\n<h3 id=\"success-criteria-and-acceptance-boundaries\">Success Criteria and Acceptance Boundaries</h3>\n<p>To maintain clear project scope, we define specific success criteria that distinguish between acceptable implementation variations and scope creep that violates our goals.</p>\n<p><strong>Functional Success Criteria</strong></p>\n<p>A successful markdown renderer implementation must correctly parse and render a representative test document containing all supported elements in various combinations. This includes nested lists with inline formatting, code blocks adjacent to headings, blockquotes containing emphasis and links, and proper paragraph separation throughout.</p>\n<p>The renderer must also handle empty inputs gracefully, process files with different line ending conventions (Unix, Windows, Mac), and generate HTML that validates against W3C standards without warnings or errors.</p>\n<p><strong>Quality Success Criteria</strong></p>\n<p>Beyond functional correctness, successful implementations demonstrate clean separation between parsing phases, readable code organization that follows the recommended file structure, and error handling that provides meaningful feedback rather than cryptic failure messages.</p>\n<p>The AST structure should be inspectable for debugging, with utility functions that can pretty-print the parsed tree structure. This requirement ensures learners understand their parser&#39;s internal state, which is crucial for debugging and validation.</p>\n<p><strong>Learning Objective Success Criteria</strong></p>\n<p>Most importantly, successful implementations demonstrate that the learner understands the core concepts rather than just copying working code. This means they can explain why the two-phase parsing approach (block then inline) is necessary, how delimiter matching algorithms handle nested formatting, and what trade-offs their architectural decisions introduce.</p>\n<p>Learners should be able to extend their implementation with simple new features (like supporting <code>~~strikethrough~~</code> syntax) without requiring major architectural changes. This demonstrates they&#39;ve internalized the parsing patterns rather than just implementing specific features.</p>\n<blockquote>\n<p><strong>Key Design Principle</strong>: Scope boundaries serve learning objectives, not feature completeness. Every included feature must teach a distinct parsing concept, while excluded features should be omittable without compromising the educational value of core implementation challenges.</p>\n</blockquote>\n<p>The tension between scope and learning occurs when interesting features (like tables) would teach valuable lessons (like multi-pass parsing) but at the cost of project complexity that overwhelms beginners. Our goals resolve this tension by prioritizing depth in core concepts over breadth in supported features. Learners who master our focused implementation will be well-prepared to tackle extensions and advanced features in subsequent projects.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The goals and non-goals translate into specific technology choices and project organization strategies that support successful implementation while maintaining educational focus.</p>\n<p><strong>A. Technology Recommendations Table:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Text Processing</td>\n<td>Built-in string methods + basic regex</td>\n<td>Full regex engines with lookahead/lookbehind</td>\n</tr>\n<tr>\n<td>Data Structures</td>\n<td>Lists and dictionaries for AST nodes</td>\n<td>Custom tree classes with traversal methods</td>\n</tr>\n<tr>\n<td>HTML Generation</td>\n<td>String concatenation with escaping</td>\n<td>Template engines or HTML builder libraries</td>\n</tr>\n<tr>\n<td>File I/O</td>\n<td>Read entire file into memory</td>\n<td>Streaming/chunked file processing</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>Built-in unittest/assert modules</td>\n<td>Property-based testing frameworks</td>\n</tr>\n<tr>\n<td>Code Organization</td>\n<td>Single module with classes</td>\n<td>Multi-package architecture with interfaces</td>\n</tr>\n</tbody></table>\n<p>For beginners, the simple options provide immediate productivity without requiring mastery of complex libraries. Advanced options become attractive once the core concepts are solid.</p>\n<p><strong>B. Recommended File/Module Structure:</strong></p>\n<p>The file organization should reflect the parsing pipeline and make the architectural boundaries clear:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>markdown-renderer/\n├── main.py                    # CLI entry point and file I/O\n├── parser.py                  # MarkdownParser class and parse_to_html()\n├── lexer.py                   # Line processing and normalization utilities  \n├── blocks.py                  # Block-level parsing (BlockNode classes)\n├── inlines.py                 # Inline parsing (InlineNode classes)\n├── lists.py                   # List parsing (separate due to complexity)\n├── ast_nodes.py               # ASTNode, BlockNode, InlineNode definitions\n├── html_generator.py          # HTML output generation and escaping\n├── utils.py                   # Helper functions (debug_print_ast, etc.)\n├── test_samples/              # Sample markdown files for testing\n│   ├── basic_elements.md      # Simple test cases for each element\n│   ├── nested_structures.md   # Complex combinations and nesting\n│   └── edge_cases.md          # Error conditions and malformed input\n└── tests/                     # Unit tests organized by component\n    ├── test_blocks.py\n    ├── test_inlines.py \n    ├── test_lists.py\n    └── test_integration.py</code></pre></div>\n\n<p>This structure separates concerns while keeping related functionality together. The <code>test_samples/</code> directory provides immediate feedback during development.</p>\n<p><strong>C. Infrastructure Starter Code (COMPLETE, ready to use):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># utils.py - Complete utility functions for debugging and line processing</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">HTML_ESCAPE_TABLE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x26;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;amp;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x3C;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;lt;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '>'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;gt;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '\"'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;quot;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"'\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;#39;'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> normalize_line_endings</span><span style=\"color:#E1E4E8\">(text):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert all line endings to Unix format (</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> text.replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">).replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> split_into_lines</span><span style=\"color:#E1E4E8\">(text):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Split text into lines, preserving empty lines and tracking line numbers.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text.split(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> [(i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, line) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> i, line </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(lines)]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_blank_line</span><span style=\"color:#E1E4E8\">(line):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if line contains only whitespace characters.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(line.strip()) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> get_indentation_level</span><span style=\"color:#E1E4E8\">(line):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Count leading spaces in line. Tabs count as 4 spaces.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> line:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> ' '</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> count</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> escape_html</span><span style=\"color:#E1E4E8\">(text):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Escape special HTML characters to prevent injection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> text:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> char, escape </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> HTML_ESCAPE_TABLE</span><span style=\"color:#E1E4E8\">.items():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> result.replace(char, escape)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> debug_print_ast</span><span style=\"color:#E1E4E8\">(node, indent</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Print AST structure for debugging purposes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    prefix </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"  \"</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> indent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'node_type'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">prefix</span><span style=\"color:#79B8FF\">}{</span><span style=\"color:#E1E4E8\">node.node_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{getattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'text_content'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">)[:</span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'children'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> node.children:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            debug_print_ast(child, indent </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code (signature + TODOs only):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># parser.py - Main parser class skeleton</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MarkdownParser</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Main markdown parser coordinating block and inline parsing phases.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize block_parser, inline_parser, html_generator components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Set up shared state like current line number, parsing context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_to_html</span><span style=\"color:#E1E4E8\">(self, markdown_text):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Convert markdown text to HTML through two-phase parsing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            markdown_text (str): Raw markdown input</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            str: Generated HTML output</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Normalize line endings using normalize_line_endings()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Split into lines with split_into_lines() </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Pass lines to block parser to build initial AST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Pass block AST to inline parser to process formatting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Pass complete AST to HTML generator for output</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return final HTML string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_file</span><span style=\"color:#E1E4E8\">(self, file_path):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Parse markdown file and return HTML.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Open and read file content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call parse_to_html() with file content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle file I/O errors gracefully</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints:</strong></p>\n<p>For Python implementation:</p>\n<ul>\n<li>Use <code>re.compile()</code> to pre-compile frequently used regex patterns for better performance</li>\n<li>List comprehensions are excellent for filtering and transforming line collections</li>\n<li>The <code>enumerate()</code> function simplifies line number tracking during parsing</li>\n<li>Consider using <code>dataclasses</code> for AST node definitions to reduce boilerplate</li>\n<li>The <code>textwrap.dedent()</code> function helps with processing indented code blocks</li>\n<li>Use <code>isinstance()</code> checks rather than string comparisons for node type detection</li>\n</ul>\n<p><strong>F. Milestone Checkpoint:</strong></p>\n<p>After establishing goals and non-goals, verify your project setup:</p>\n<p><strong>Setup Verification Steps:</strong></p>\n<ol>\n<li>Create the recommended file structure with empty Python files</li>\n<li>Copy the complete utility functions into <code>utils.py</code></li>\n<li>Run <code>python -c &quot;from utils import normalize_line_endings; print(&#39;Setup OK&#39;)&quot;</code> to verify imports work</li>\n<li>Create a simple test file <code>test_samples/basic.md</code> with a heading and paragraph</li>\n<li>Verify you can read the test file and print its content</li>\n</ol>\n<p><strong>Expected Behavior:</strong></p>\n<ul>\n<li>All imports should work without errors</li>\n<li>The utility functions should handle basic text processing correctly</li>\n<li>You should be able to process line endings and count indentation accurately</li>\n<li>File I/O should work for reading test markdown samples</li>\n</ul>\n<p><strong>Signs Something Is Wrong:</strong></p>\n<ul>\n<li>Import errors suggest file structure problems or missing <code>__init__.py</code> files</li>\n<li>Utility functions failing indicates issues with the starter code setup</li>\n<li>File reading problems suggest path or permission issues</li>\n</ul>\n<p><strong>What to Check:</strong></p>\n<ul>\n<li>Verify Python environment has required standard library modules</li>\n<li>Ensure all files are in the correct directory structure</li>\n<li>Check that test sample files use the line ending format your system expects</li>\n<li>Confirm utility functions produce expected output on sample inputs</li>\n</ul>\n<p>This milestone checkpoint ensures learners have a solid foundation before beginning the actual parsing implementation in subsequent milestones.</p>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation</p>\n</blockquote>\n<h3 id=\"the-document-pipeline-mental-model\">The Document Pipeline Mental Model</h3>\n<p>Think of markdown parsing like a factory assembly line for translating documents. Raw markdown text enters one end, and polished HTML emerges from the other. The key insight is that this transformation happens in distinct phases, each with specialized workers who understand different aspects of the document structure.</p>\n<p>Imagine you&#39;re translating a complex technical document from one language to another. You wouldn&#39;t try to translate every word simultaneously while also formatting paragraphs and checking grammar. Instead, you&#39;d first identify the major sections (chapters, headings, paragraphs), then work on the detailed sentence structure within each section, and finally apply the target language&#39;s formatting conventions. This is exactly how our <strong>two-phase parsing</strong> approach works.</p>\n<p>The first phase identifies the document&#39;s skeleton - the major structural elements like headings, paragraphs, code blocks, and lists. These are <strong>block-level elements</strong> that define the document&#39;s overall organization. The second phase focuses on the details within each block - the <strong>inline elements</strong> like bold text, links, and inline code that provide formatting and semantic meaning within the content.</p>\n<p>This separation is crucial because block and inline elements follow different parsing rules. A heading can contain italic text, but italic text cannot contain a heading. By parsing blocks first and then processing inline content within those blocks, we maintain proper precedence and avoid complex interdependencies.</p>\n<p><img src=\"/api/project/markdown-renderer/architecture-doc/asset?path=diagrams%2Fsystem-components.svg\" alt=\"System Component Architecture\"></p>\n<h3 id=\"component-overview\">Component Overview</h3>\n<p>The markdown renderer follows a <strong>four-component architecture</strong> where each component has a clearly defined responsibility in the document transformation pipeline. This separation of concerns makes the system easier to understand, test, and extend while ensuring that each component can focus on its specific parsing challenges.</p>\n<h4 id=\"input-preprocessor-and-lexer\">Input Preprocessor and Lexer</h4>\n<p>The <strong>Input Preprocessor</strong> serves as the system&#39;s entry point, handling the messy realities of text input before any parsing begins. Think of it as a document sanitizer that ensures all components downstream can make consistent assumptions about the input format.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Input</th>\n<th>Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Line Ending Normalization</td>\n<td>Convert Windows CRLF and classic Mac CR to Unix LF</td>\n<td>Raw markdown text</td>\n<td>Normalized text</td>\n</tr>\n<tr>\n<td>Line Splitting</td>\n<td>Break text into individual lines while preserving line numbers</td>\n<td>Normalized text</td>\n<td>List of lines with metadata</td>\n</tr>\n<tr>\n<td>Blank Line Detection</td>\n<td>Identify whitespace-only lines for block boundary detection</td>\n<td>Individual lines</td>\n<td>Boolean classification</td>\n</tr>\n<tr>\n<td>Indentation Analysis</td>\n<td>Measure leading whitespace for list and code block processing</td>\n<td>Individual lines</td>\n<td>Indentation levels</td>\n</tr>\n</tbody></table>\n<p>The preprocessor doesn&#39;t make parsing decisions - it simply ensures that subsequent components receive clean, predictable input. This includes normalizing different line ending conventions, preserving empty lines that serve as block separators, and calculating indentation levels that will be crucial for list parsing.</p>\n<blockquote>\n<p><strong>Key Design Insight</strong>: The preprocessor eliminates platform-specific text handling concerns from the core parsing logic. Without this component, every parser would need to handle Windows CRLF, Unix LF, and classic Mac CR line endings, significantly complicating the parsing state machines.</p>\n</blockquote>\n<h4 id=\"block-parser\">Block Parser</h4>\n<p>The <strong>Block Parser</strong> is responsible for identifying and parsing the document&#39;s structural skeleton. It processes the input line-by-line, maintaining state to recognize multi-line constructs and building the first level of the document&#39;s <strong>Abstract Syntax Tree</strong>.</p>\n<table>\n<thead>\n<tr>\n<th>Block Type</th>\n<th>Recognition Pattern</th>\n<th>State Requirements</th>\n<th>Output Node Type</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ATX Headings</td>\n<td>Lines starting with 1-6 <code>#</code> characters</td>\n<td>Single-line, immediate recognition</td>\n<td><code>BlockNode</code> with <code>block_type=&quot;heading&quot;</code></td>\n</tr>\n<tr>\n<td>Paragraphs</td>\n<td>Consecutive non-blank lines not matching other patterns</td>\n<td>Multi-line accumulation state</td>\n<td><code>BlockNode</code> with <code>block_type=&quot;paragraph&quot;</code></td>\n</tr>\n<tr>\n<td>Fenced Code Blocks</td>\n<td>Lines between triple backticks</td>\n<td>Start/end delimiter matching</td>\n<td><code>BlockNode</code> with <code>block_type=&quot;code_block&quot;</code></td>\n</tr>\n<tr>\n<td>Indented Code Blocks</td>\n<td>Lines indented by 4+ spaces</td>\n<td>Consecutive indentation tracking</td>\n<td><code>BlockNode</code> with <code>block_type=&quot;code_block&quot;</code></td>\n</tr>\n<tr>\n<td>Blockquotes</td>\n<td>Lines starting with <code>&gt;</code> character</td>\n<td>Nested depth tracking</td>\n<td><code>BlockNode</code> with <code>block_type=&quot;blockquote&quot;</code></td>\n</tr>\n<tr>\n<td>Horizontal Rules</td>\n<td>Lines with 3+ dashes or asterisks</td>\n<td>Pattern matching with spacing rules</td>\n<td><code>BlockNode</code> with <code>block_type=&quot;horizontal_rule&quot;</code></td>\n</tr>\n</tbody></table>\n<p>The block parser operates as a <strong>state machine</strong> where each line can potentially trigger a state transition. For example, when processing a paragraph, encountering a blank line transitions to a &quot;seeking next block&quot; state, while encountering an ATX heading immediately closes the paragraph and starts processing the heading.</p>\n<blockquote>\n<p><strong>Architecture Decision: Line-by-Line State Machine vs Regex Chunking</strong></p>\n<ul>\n<li><strong>Context</strong>: Block parsing requires handling multi-line constructs like paragraphs and code blocks</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Process entire input with complex regex patterns</li>\n<li>Line-by-line state machine</li>\n<li>Recursive descent parser</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Line-by-line state machine</li>\n<li><strong>Rationale</strong>: Regex becomes unwieldy for nested constructs and lookahead requirements. Recursive descent adds complexity for what is fundamentally a sequential process. State machine provides clear separation of concerns and easier debugging.</li>\n<li><strong>Consequences</strong>: Enables incremental processing, simplifies testing of individual block types, but requires careful state transition management.</li>\n</ul>\n</blockquote>\n<h4 id=\"inline-parser\">Inline Parser</h4>\n<p>The <strong>Inline Parser</strong> processes the text content within each block element, identifying and parsing formatting elements like emphasis, links, images, and inline code. This component operates on a fundamentally different principle than the block parser - it must handle <strong>nested and overlapping constructs</strong> within a single line or text span.</p>\n<table>\n<thead>\n<tr>\n<th>Inline Type</th>\n<th>Delimiter Pattern</th>\n<th>Nesting Rules</th>\n<th>Special Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Strong (Bold)</td>\n<td><code>**text**</code> or <code>__text__</code></td>\n<td>Can contain emphasis</td>\n<td>Cannot cross word boundaries for underscores</td>\n</tr>\n<tr>\n<td>Emphasis (Italic)</td>\n<td><code>*text*</code> or <code>_text_</code></td>\n<td>Can be nested in strong</td>\n<td>Cannot cross word boundaries for underscores</td>\n</tr>\n<tr>\n<td>Inline Code</td>\n<td><code>code</code></td>\n<td>Cannot contain other formatting</td>\n<td>Preserves literal content, including backticks</td>\n</tr>\n<tr>\n<td>Links</td>\n<td><code>[text](url)</code></td>\n<td>Text portion can contain formatting</td>\n<td>URL portion is literal</td>\n</tr>\n<tr>\n<td>Images</td>\n<td><code>![alt](url)</code></td>\n<td>Alt text can contain formatting</td>\n<td>URL portion is literal</td>\n</tr>\n<tr>\n<td>Autolinks</td>\n<td><code>&lt;url&gt;</code> or <code>&lt;email&gt;</code></td>\n<td>No nested formatting</td>\n<td>Automatic protocol detection</td>\n</tr>\n</tbody></table>\n<p>The inline parser uses a <strong>delimiter matching algorithm</strong> that maintains a stack of opening delimiters and matches them with closing delimiters according to CommonMark precedence rules. This is significantly more complex than block parsing because inline elements can be nested (bold text containing italic text) and can have complex interaction rules.</p>\n<blockquote>\n<p><strong>Key Design Insight</strong>: Inline parsing cannot be solved with simple regex patterns because of the nesting requirements and context-dependent rules. For example, underscores in the middle of words should not trigger emphasis, and unmatched delimiters should be treated as literal text.</p>\n</blockquote>\n<h4 id=\"html-generator\">HTML Generator</h4>\n<p>The <strong>HTML Generator</strong> traverses the completed AST and produces valid HTML output. This component is responsible for <strong>character escaping</strong>, <strong>proper tag nesting</strong>, and <strong>output formatting</strong>. Think of it as the final assembly worker who takes the structured document representation and produces the final deliverable.</p>\n<table>\n<thead>\n<tr>\n<th>Generation Phase</th>\n<th>Input</th>\n<th>Process</th>\n<th>Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tree Traversal</td>\n<td>Complete AST</td>\n<td>Depth-first traversal of nodes</td>\n<td>Sequential processing order</td>\n</tr>\n<tr>\n<td>Character Escaping</td>\n<td>Text content</td>\n<td>Convert <code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&quot;</code> to HTML entities</td>\n<td>Escaped text safe for HTML</td>\n</tr>\n<tr>\n<td>Tag Generation</td>\n<td>AST nodes with types</td>\n<td>Map node types to HTML elements</td>\n<td>Opening and closing tags</td>\n</tr>\n<tr>\n<td>Attribute Handling</td>\n<td>Node attributes (links, images, headings)</td>\n<td>Generate HTML attributes</td>\n<td><code>href</code>, <code>src</code>, <code>alt</code>, <code>id</code> attributes</td>\n</tr>\n<tr>\n<td>Pretty Printing</td>\n<td>Generated HTML</td>\n<td>Add indentation and line breaks</td>\n<td>Human-readable formatted output</td>\n</tr>\n</tbody></table>\n<p>The generator must handle <strong>self-closing tags</strong> correctly (like <code>&lt;hr&gt;</code> for horizontal rules), ensure proper <strong>tag nesting</strong> (no unclosed or incorrectly ordered tags), and provide <strong>extensibility</strong> for custom renderers that might want to generate different output formats.</p>\n<blockquote>\n<p><strong>Architecture Decision: Early vs Late Character Escaping</strong></p>\n<ul>\n<li><strong>Context</strong>: HTML special characters must be escaped, but timing affects complexity</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Escape during initial input processing</li>\n<li>Escape during inline parsing</li>\n<li>Escape during HTML generation</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Escape during HTML generation</li>\n<li><strong>Rationale</strong>: Early escaping interferes with parsing logic that needs to recognize literal characters. Late escaping ensures we only escape content that will be output as text, not structural markup.</li>\n<li><strong>Consequences</strong>: Cleaner parsing logic, but requires careful tracking of what content needs escaping vs what is already HTML.</li>\n</ul>\n</blockquote>\n<h4 id=\"component-interaction-and-data-flow\">Component Interaction and Data Flow</h4>\n<p>The components form a <strong>pipeline architecture</strong> where data flows unidirectionally from input to output, with each component transforming the data into a more structured representation.</p>\n<table>\n<thead>\n<tr>\n<th>Data Flow Stage</th>\n<th>Data Format</th>\n<th>Component</th>\n<th>Key Transformations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Raw Input</td>\n<td>String with mixed line endings</td>\n<td>Input Preprocessor</td>\n<td>Normalization and line splitting</td>\n</tr>\n<tr>\n<td>Normalized Lines</td>\n<td>List of strings with metadata</td>\n<td>Block Parser</td>\n<td>Structure identification and AST building</td>\n</tr>\n<tr>\n<td>Block AST</td>\n<td>Tree of <code>BlockNode</code> objects</td>\n<td>Inline Parser</td>\n<td>Text content parsing and inline AST integration</td>\n</tr>\n<tr>\n<td>Complete AST</td>\n<td>Mixed tree of <code>BlockNode</code> and <code>InlineNode</code> objects</td>\n<td>HTML Generator</td>\n<td>HTML element generation and formatting</td>\n</tr>\n<tr>\n<td>HTML Output</td>\n<td>Valid HTML string</td>\n<td>External consumer</td>\n<td>Ready for browser or file output</td>\n</tr>\n</tbody></table>\n<p>Each component maintains <strong>clear interface boundaries</strong> with well-defined input and output contracts. The block parser doesn&#39;t need to understand inline formatting, and the HTML generator doesn&#39;t need to understand markdown syntax. This separation enables independent testing, development, and potential replacement of individual components.</p>\n<blockquote>\n<p><strong>Critical Design Principle</strong>: Each component operates on a higher level of abstraction than its predecessor. The preprocessor works with raw text, the block parser works with lines and structure, the inline parser works with text spans and formatting, and the HTML generator works with semantic document elements.</p>\n</blockquote>\n<h3 id=\"recommended-file-structure\">Recommended File Structure</h3>\n<p>The file organization follows the principle of <strong>component isolation</strong> with clear separation between parsing logic, data structures, and utilities. This structure supports incremental development where each milestone can be implemented and tested independently.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>markdown_renderer/\n├── __init__.py                    # Main package interface\n├── main.py                        # CLI entry point and file processing\n├── parser.py                      # MarkdownParser class and main API\n├── data_model.py                  # AST node definitions and data structures\n├── preprocessor.py                # Input normalization and line processing\n├── block_parser.py                # Block-level element parsing\n├── inline_parser.py               # Inline formatting parsing\n├── list_parser.py                 # Specialized list parsing logic\n├── html_generator.py              # AST to HTML conversion\n├── utils.py                       # Shared utilities and constants\n├── tests/                         # Test suite organization\n│   ├── __init__.py\n│   ├── test_preprocessor.py       # Input processing tests\n│   ├── test_block_parser.py       # Block parsing tests\n│   ├── test_inline_parser.py      # Inline parsing tests\n│   ├── test_list_parser.py        # List parsing tests\n│   ├── test_html_generator.py     # HTML generation tests\n│   ├── test_integration.py        # End-to-end pipeline tests\n│   └── fixtures/                  # Test data files\n│       ├── markdown_samples/      # Sample markdown inputs\n│       └── expected_html/         # Expected HTML outputs\n└── examples/                      # Usage examples and demos\n    ├── basic_usage.py             # Simple API demonstration\n    ├── custom_renderer.py         # Plugin interface example\n    └── sample_documents/          # Example markdown files</code></pre></div>\n\n<p>This structure reflects several important architectural decisions:</p>\n<p><strong>Separation of Parsing Phases</strong>: Each major parsing component gets its own module (<code>block_parser.py</code>, <code>inline_parser.py</code>, <code>list_parser.py</code>). This makes it easy to work on one parsing phase without being distracted by others and enables focused unit testing.</p>\n<p><strong>Centralized Data Model</strong>: All AST node definitions live in <code>data_model.py</code>. This prevents circular imports and provides a single location for understanding the system&#39;s data structures. Any component that needs to create or manipulate AST nodes imports from this central module.</p>\n<p><strong>Utilities and Constants</strong>: Shared functionality like HTML escaping, indentation detection, and debug printing is centralized in <code>utils.py</code>. This prevents code duplication and ensures consistent behavior across components.</p>\n<p><strong>Comprehensive Testing</strong>: The test structure mirrors the module structure, with dedicated test files for each component plus integration tests that verify the complete pipeline. Fixture files separate test data from test logic, making tests easier to read and maintain.</p>\n<blockquote>\n<p><strong>Implementation Strategy</strong>: Start by implementing <code>data_model.py</code> with basic AST node structures, then implement <code>preprocessor.py</code> and <code>utils.py</code> to establish the foundation. This enables incremental development where each subsequent milestone can build on solid, tested infrastructure.</p>\n</blockquote>\n<p>The file organization also supports the <strong>plugin architecture</strong> mentioned in future extensions. Custom renderers can import the AST data model and implement alternative HTML generators without modifying the core parsing logic.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Text Processing</td>\n<td>Built-in <code>str</code> methods and <code>re</code> module</td>\n<td><code>regex</code> library with advanced features</td>\n<td>Standard library sufficient for CommonMark compliance</td>\n</tr>\n<tr>\n<td>Data Structures</td>\n<td>Built-in <code>list</code> and <code>dict</code></td>\n<td><code>collections.deque</code> for parser stacks</td>\n<td>Standard containers handle AST and delimiter stacks adequately</td>\n</tr>\n<tr>\n<td>File I/O</td>\n<td>Built-in <code>open()</code> and text mode</td>\n<td><code>pathlib</code> for path handling</td>\n<td>Simple file reading adequate, <code>pathlib</code> improves cross-platform compatibility</td>\n</tr>\n<tr>\n<td>Testing Framework</td>\n<td>Built-in <code>unittest</code></td>\n<td><code>pytest</code> with fixtures</td>\n<td><code>pytest</code> provides cleaner test organization and better fixture support</td>\n</tr>\n<tr>\n<td>CLI Interface</td>\n<td><code>argparse</code> for command-line parsing</td>\n<td><code>click</code> for advanced CLI features</td>\n<td><code>argparse</code> sufficient for basic file processing interface</td>\n</tr>\n<tr>\n<td>Output Formatting</td>\n<td>String concatenation and <code>join()</code></td>\n<td>Template engines like <code>jinja2</code></td>\n<td>String operations adequate for HTML generation, templates add complexity</td>\n</tr>\n</tbody></table>\n<p>For this beginner-level project, the <strong>simple options</strong> are strongly recommended. The standard library provides all necessary functionality, and additional dependencies would complicate the learning experience without providing significant benefits.</p>\n<h4 id=\"core-infrastructure-starter-code\">Core Infrastructure Starter Code</h4>\n<p><strong>File: <code>utils.py</code> - Complete utility functions</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Shared utilities and constants for markdown parsing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides text processing utilities, HTML escaping, and debugging helpers.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Dict, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># HTML character escaping table</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">HTML_ESCAPE_TABLE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x26;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;amp;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x3C;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;lt;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '>'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;gt;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '\"'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;quot;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"'\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;#x27;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> normalize_line_endings</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert all line endings to Unix format (LF only).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Replace Windows CRLF first, then Mac CR</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> text.replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">).replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> split_into_lines</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Split text into lines, preserving empty lines.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> text.split(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_blank_line</span><span style=\"color:#E1E4E8\">(line: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if line contains only whitespace characters.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(line.strip()) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> get_indentation_level</span><span style=\"color:#E1E4E8\">(line: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Count leading spaces in line. Tabs count as 4 spaces.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> line:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> ' '</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            indent </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            indent </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> indent</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> escape_html</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Escape HTML special characters in text content.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> char, entity </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> HTML_ESCAPE_TABLE</span><span style=\"color:#E1E4E8\">.items():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> result.replace(char, entity)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> debug_print_ast</span><span style=\"color:#E1E4E8\">(node: Any, indent: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Print AST structure for debugging. Recursively shows node hierarchy.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    prefix </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"  \"</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> indent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node.node_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'block_type'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        node_info </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\" (</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node.block_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'inline_type'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        node_info </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\" (</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node.inline_type</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'text_content'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> node.text_content:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Truncate long text for readability</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        text </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node.text_content[:</span><span style=\"color:#79B8FF\">30</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> \"...\"</span><span style=\"color:#F97583\"> if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(node.text_content) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#F97583\"> else</span><span style=\"color:#E1E4E8\"> node.text_content</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        node_info </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">' \"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">text</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">prefix</span><span style=\"color:#79B8FF\">}{</span><span style=\"color:#E1E4E8\">node_info</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Recursively print children</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'children'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> node.children:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> node.children:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            debug_print_ast(child, indent </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>File: <code>data_model.py</code> - Complete AST node definitions</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Abstract Syntax Tree node definitions for markdown document structure.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Defines the core data model used throughout the parsing pipeline.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Dict, Any, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> NodeType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Enumeration of all AST node types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DOCUMENT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"document\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BLOCK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"block\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INLINE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"inline\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TEXT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"text\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BlockType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Enumeration of block-level element types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PARAGRAPH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"paragraph\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HEADING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"heading\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CODE_BLOCK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"code_block\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BLOCKQUOTE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"blockquote\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HORIZONTAL_RULE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"horizontal_rule\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LIST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"list\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LIST_ITEM</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"list_item\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InlineType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Enumeration of inline element types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    STRONG</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"strong\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EMPHASIS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"emphasis\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CODE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"code\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LINK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"link\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    IMAGE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"image\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LINE_BREAK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"line_break\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ASTNode</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all AST nodes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, node_type: NodeType, line_number: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.node_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node_type</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.children: List[</span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parent: Optional[</span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.line_number </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> line_number</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_child</span><span style=\"color:#E1E4E8\">(self, child: </span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add a child node and set its parent reference.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        child.parent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.children.append(child)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> remove_child</span><span style=\"color:#E1E4E8\">(self, child: </span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Remove a child node and clear its parent reference.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.children:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            child.parent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.children.remove(child)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BlockNode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ASTNode</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"AST node for block-level elements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, block_type: BlockType, line_number: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(NodeType.</span><span style=\"color:#79B8FF\">BLOCK</span><span style=\"color:#E1E4E8\">, line_number)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.block_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block_type</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.inline_content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.block_attributes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> set_content</span><span style=\"color:#E1E4E8\">(self, content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set the raw text content for this block.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.inline_content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> content</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> set_attribute</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set a block-specific attribute (e.g., heading level, language).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.block_attributes[key] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_attribute</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, default: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get a block-specific attribute with optional default.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.block_attributes.get(key, default)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InlineNode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ASTNode</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"AST node for inline formatting elements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, inline_type: InlineType, line_number: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(NodeType.</span><span style=\"color:#79B8FF\">INLINE</span><span style=\"color:#E1E4E8\">, line_number)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.inline_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inline_type</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.text_content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.formatting_attributes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> set_text</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set the text content for this inline element.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.text_content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> set_attribute</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set an inline-specific attribute (e.g., URL, alt text).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.formatting_attributes[key] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_attribute</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, default: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get an inline-specific attribute with optional default.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.formatting_attributes.get(key, default)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TextNode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ASTNode</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"AST node for plain text content.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, line_number: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(NodeType.</span><span style=\"color:#79B8FF\">TEXT</span><span style=\"color:#E1E4E8\">, line_number)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.text_content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> set_text</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set the text content.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.text_content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text</span></span></code></pre></div>\n\n<h4 id=\"core-parsing-logic-skeletons\">Core Parsing Logic Skeletons</h4>\n<p><strong>File: <code>parser.py</code> - Main parser class skeleton</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Main MarkdownParser class that coordinates the parsing pipeline.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">This is the primary public interface for the markdown renderer.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ASTNode, BlockNode, NodeType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .preprocessor </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Preprocessor</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .block_parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BlockParser  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .inline_parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> InlineParser</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .html_generator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> HTMLGenerator</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MarkdownParser</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Main parser that coordinates the two-phase parsing pipeline.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.block_parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BlockParser()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.inline_parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> InlineParser() </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.html_generator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> HTMLGenerator()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_to_html</span><span style=\"color:#E1E4E8\">(self, markdown_text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Main parsing entry point. Converts markdown text to HTML.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            markdown_text: Raw markdown input string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Valid HTML string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Use normalize_line_endings to standardize input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Use split_into_lines to break into line list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Call block_parser.parse(lines) to get block AST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Call inline_parser.parse(block_ast) to add inline elements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Call html_generator.generate(complete_ast) to produce HTML</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return the final HTML string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_file</span><span style=\"color:#E1E4E8\">(self, file_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Parse markdown from a file path.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            file_path: Path to markdown file</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            HTML string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Open and read file content with UTF-8 encoding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call parse_to_html with file content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle FileNotFoundError and UnicodeDecodeError appropriately</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>File: <code>preprocessor.py</code> - Input processing skeleton</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Input preprocessing for markdown text.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Handles normalization and basic text processing before parsing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .utils </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> normalize_line_endings, split_into_lines, is_blank_line, get_indentation_level</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LineInfo</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Metadata about a single line of input.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, line_number: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, is_blank: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">, indent_level: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> content</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.line_number </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> line_number</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.is_blank </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> is_blank</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.indent_level </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> indent_level</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.stripped_content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> content.strip()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Preprocessor</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Handles input normalization and line-level analysis.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_input</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[LineInfo]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Process raw markdown input into analyzed lines.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            text: Raw markdown text</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            List of LineInfo objects with metadata</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Call normalize_line_endings on input text</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call split_into_lines to get line list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create LineInfo object for each line with:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - content (original line)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - line_number (1-based)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - is_blank (use is_blank_line utility)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - indent_level (use get_indentation_level utility)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return list of LineInfo objects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After implementing the basic infrastructure (utils.py, data_model.py, parser.py):</strong></p>\n<p>Run the following verification:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Test basic infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> markdown_renderer.utils </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> escape_html, normalize_line_endings</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> markdown_renderer.data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BlockNode, BlockType</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify HTML escaping</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">test_text </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'Hello &#x26; &#x3C;world> \"test\"'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">escaped </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> escape_html(test_text)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> escaped </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'Hello &#x26;amp; &#x26;lt;world&#x26;gt; &#x26;quot;test&#x26;quot;'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify line ending normalization  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">test_input </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"Line 1</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">Line 2</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">Line 3</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">normalized </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> normalize_line_endings(test_input)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> normalized </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"Line 1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">Line 2</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">Line 3</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify AST node creation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">heading </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BlockNode(BlockType.</span><span style=\"color:#79B8FF\">HEADING</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">heading.set_attribute(</span><span style=\"color:#9ECBFF\">\"level\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">heading.set_content(</span><span style=\"color:#9ECBFF\">\"Test Heading\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">assert</span><span style=\"color:#E1E4E8\"> heading.get_attribute(</span><span style=\"color:#9ECBFF\">\"level\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✓ Basic infrastructure working correctly\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Expected behavior</strong>: All assertions should pass, demonstrating that the utility functions handle text processing correctly and AST nodes can store block-level content and attributes.</p>\n<p><strong>Signs something is wrong</strong>: If escaping doesn&#39;t handle all characters, check the <code>HTML_ESCAPE_TABLE</code> mapping. If line ending normalization fails, ensure Windows CRLF is processed before Mac CR. If AST node tests fail, verify the parent-child relationship management in <code>add_child</code>.</p>\n<h4 id=\"language-specific-implementation-hints\">Language-Specific Implementation Hints</h4>\n<p><strong>Python Text Processing Tips:</strong></p>\n<ul>\n<li>Use <code>str.strip()</code> for whitespace removal, but remember it removes all whitespace characters including tabs and newlines</li>\n<li><code>str.split(&#39;\\n&#39;)</code> preserves empty strings for blank lines, which is essential for block boundary detection</li>\n<li>Regular expressions with <code>re.finditer()</code> provide both match content and position information useful for parsing</li>\n<li>List comprehensions with conditionals help filter lines: <code>[line for line in lines if not is_blank_line(line)]</code></li>\n</ul>\n<p><strong>AST Manipulation Patterns:</strong></p>\n<ul>\n<li>Always set parent references when adding children to enable upward traversal</li>\n<li>Use <code>isinstance(node, BlockNode)</code> for type checking instead of string comparison on <code>node_type</code></li>\n<li>Consider using <code>collections.deque</code> for parser stacks if you need frequent insertion/removal at both ends</li>\n<li>Store line numbers in nodes during parsing - they&#39;re invaluable for error reporting and debugging</li>\n</ul>\n<p><strong>Error Handling Strategy:</strong></p>\n<ul>\n<li>Catch <code>UnicodeDecodeError</code> when reading files and provide helpful error messages</li>\n<li>Use <code>try/except</code> around file operations but let parsing errors propagate for debugging</li>\n<li>Consider using <code>logging</code> module for debug output rather than print statements</li>\n<li>Validate AST structure with assertions during development, but remove them for production</li>\n</ul>\n<blockquote>\n<p><strong>Development Workflow Tip</strong>: Implement and test each utility function independently before building the parser components. Use <code>python -m pytest tests/test_utils.py -v</code> to verify individual functions work correctly before integrating them into the larger parsing pipeline.</p>\n</blockquote>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation</p>\n</blockquote>\n<h3 id=\"the-document-tree-mental-model\">The Document Tree Mental Model</h3>\n<p>Think of a markdown document as a family tree where each person (element) knows their role in the family hierarchy. Just as a family tree has generations—grandparents, parents, children—a markdown document has structural levels. The document root is like the family patriarch, containing major sections (headings, paragraphs, lists) as its children, which in turn contain their own children (bold text, links, images within paragraphs).</p>\n<p>Unlike a flat text file where everything is just characters in sequence, our parsed representation maintains these relationships explicitly. Each node in the tree knows its parent (the element that contains it), its children (the elements it contains), and its siblings (elements at the same level). This hierarchical structure makes it straightforward to apply consistent formatting rules, validate nesting constraints, and generate properly structured HTML output.</p>\n<p>The key insight is that markdown parsing transforms linear text into a structured tree where semantic relationships are explicit rather than implicit. A paragraph doesn&#39;t just contain the text &quot;This is <strong>bold</strong> text&quot;—it contains a sequence of child elements: a text node &quot;This is &quot;, a strong emphasis node containing &quot;bold&quot;, and another text node &quot; text&quot;. This explicitness enables precise control over HTML generation and makes complex transformations tractable.</p>\n<h3 id=\"abstract-syntax-tree-nodes\">Abstract Syntax Tree Nodes</h3>\n<p>The Abstract Syntax Tree (AST) serves as the central data structure throughout our parsing pipeline. Every element in the markdown document, from the document root down to individual words, is represented as a node in this tree. The AST captures not just the content of each element but its semantic meaning, formatting attributes, and relationship to other elements.</p>\n<p><img src=\"/api/project/markdown-renderer/architecture-doc/asset?path=diagrams%2Fast-data-model.svg\" alt=\"Abstract Syntax Tree Data Model\"></p>\n<h4 id=\"base-ast-node-structure\">Base AST Node Structure</h4>\n<p>The foundation of our AST is the <code>ASTNode</code> base type, which provides the common interface and shared properties that all document elements require. Every node in the tree, regardless of its specific type or content, inherits these fundamental characteristics.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>node_type</code></td>\n<td><code>NodeType</code></td>\n<td>Enum value identifying the general category of this node (DOCUMENT, BLOCK, INLINE, TEXT)</td>\n</tr>\n<tr>\n<td><code>children</code></td>\n<td><code>List[ASTNode]</code></td>\n<td>Ordered list of child nodes contained within this element</td>\n</tr>\n<tr>\n<td><code>parent</code></td>\n<td><code>ASTNode</code></td>\n<td>Reference to the parent node containing this element (None for document root)</td>\n</tr>\n<tr>\n<td><code>line_number</code></td>\n<td><code>int</code></td>\n<td>Source line number where this element begins in the original markdown text</td>\n</tr>\n</tbody></table>\n<p>The <code>node_type</code> field enables type-safe traversal and processing—when the HTML generator encounters a node, it can immediately dispatch to the appropriate rendering logic without expensive type checking. The <code>children</code> list maintains document order, which is crucial for elements like paragraphs where the sequence of text and formatting matters. The <code>parent</code> reference enables bidirectional tree navigation, supporting operations like &quot;find the containing list to determine nesting level&quot; or &quot;check if this emphasis is inside a link&quot;.</p>\n<p>Line number tracking serves multiple purposes beyond debugging. During error reporting, we can provide precise source locations for malformed elements. During incremental parsing (a future extension), we can map document edits back to specific AST subtrees for efficient re-parsing.</p>\n<h4 id=\"block-level-node-structure\">Block-Level Node Structure</h4>\n<p>Block-level elements represent the document&#39;s structural backbone—paragraphs, headings, code blocks, lists, and other elements that establish the document&#39;s major sections. These elements typically span multiple lines and cannot appear inside other block elements (with specific exceptions like list items containing paragraphs).</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>block_type</code></td>\n<td><code>BlockType</code></td>\n<td>Specific type of block element (PARAGRAPH, HEADING, CODE_BLOCK, etc.)</td>\n</tr>\n<tr>\n<td><code>inline_content</code></td>\n<td><code>str</code></td>\n<td>Raw text content before inline parsing (e.g., &quot;This is <strong>bold</strong> text&quot;)</td>\n</tr>\n<tr>\n<td><code>block_attributes</code></td>\n<td><code>Dict[str, Any]</code></td>\n<td>Element-specific metadata (heading level, code language, list type)</td>\n</tr>\n</tbody></table>\n<p>The <code>BlockNode</code> extends <code>ASTNode</code> with block-specific functionality. The <code>inline_content</code> field stores the raw text before inline parsing occurs—this supports our two-phase parsing approach where we first identify block structure, then parse inline formatting within each block. For a heading, this might be &quot;# Chapter <strong>One</strong>: Introduction&quot; before we parse the emphasis within the heading text.</p>\n<p>The <code>block_attributes</code> dictionary provides flexibility for element-specific properties without requiring separate node types for every variation. A heading node stores its level (1-6) as <code>{&quot;level&quot;: 2}</code>, while a code block stores its language hint as <code>{&quot;language&quot;: &quot;python&quot;, &quot;is_fenced&quot;: true}</code>. This approach maintains type safety while avoiding an explosion of specialized node classes.</p>\n<blockquote>\n<p><strong>Key Design Insight</strong>: Separating block structure from inline content enables parallel processing in future extensions—we could parse multiple blocks&#39; inline content concurrently once the document structure is established.</p>\n</blockquote>\n<h4 id=\"inline-element-node-structure\">Inline Element Node Structure</h4>\n<p>Inline elements provide formatting and semantic markup within block-level containers. Unlike block elements, inline elements can nest arbitrarily—emphasis can contain links, links can contain code spans (with restrictions), and complex combinations create rich text formatting.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>inline_type</code></td>\n<td><code>InlineType</code></td>\n<td>Specific type of inline element (STRONG, EMPHASIS, CODE, LINK, IMAGE, LINE_BREAK)</td>\n</tr>\n<tr>\n<td><code>text_content</code></td>\n<td><code>str</code></td>\n<td>The actual text content for this inline element</td>\n</tr>\n<tr>\n<td><code>formatting_attributes</code></td>\n<td><code>Dict[str, Any]</code></td>\n<td>Element-specific properties (URL for links, alt text for images)</td>\n</tr>\n</tbody></table>\n<p>The <code>InlineNode</code> specializes <code>ASTNode</code> for inline formatting elements. The <code>text_content</code> field holds the processed text—for emphasis, this is the text between the markers (&quot;bold&quot; from &quot;<strong>bold</strong>&quot;). For links, this is the link text, while the URL is stored in <code>formatting_attributes</code> as <code>{&quot;url&quot;: &quot;https://example.com&quot;, &quot;title&quot;: &quot;Optional title&quot;}</code>.</p>\n<p>This separation between content and attributes proves crucial during HTML generation. The generator can apply consistent escaping to all text content while handling attributes according to their specific requirements (URLs need different escaping than alt text).</p>\n<h4 id=\"text-node-structure\">Text Node Structure</h4>\n<p>Text nodes represent the leaves of our AST—the actual words, punctuation, and whitespace that form the document&#39;s readable content. These nodes contain no child elements and require minimal metadata.</p>\n<p>Text nodes inherit the base <code>ASTNode</code> structure but typically have empty <code>children</code> lists and use the <code>text_content</code> for their actual content. While we could define a specialized <code>TextNode</code> type, the base <code>ASTNode</code> with <code>node_type = TEXT</code> provides sufficient functionality while maintaining interface consistency.</p>\n<h4 id=\"node-type-enumerations\">Node Type Enumerations</h4>\n<p>The type system uses enumerations to provide compile-time safety and clear semantic boundaries between different element categories.</p>\n<p><strong>NodeType Enumeration:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Value</th>\n<th>Purpose</th>\n<th>Examples</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DOCUMENT</code></td>\n<td>Root container for entire document</td>\n<td>Document root node</td>\n</tr>\n<tr>\n<td><code>BLOCK</code></td>\n<td>Block-level structural elements</td>\n<td>Paragraphs, headings, code blocks</td>\n</tr>\n<tr>\n<td><code>INLINE</code></td>\n<td>Inline formatting elements</td>\n<td>Emphasis, links, inline code</td>\n</tr>\n<tr>\n<td><code>TEXT</code></td>\n<td>Leaf nodes containing actual text</td>\n<td>Word sequences, punctuation</td>\n</tr>\n</tbody></table>\n<p><strong>BlockType Enumeration:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Value</th>\n<th>Purpose</th>\n<th>Attributes Used</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PARAGRAPH</code></td>\n<td>Regular paragraph text</td>\n<td>None</td>\n</tr>\n<tr>\n<td><code>HEADING</code></td>\n<td>Section headings</td>\n<td><code>level</code> (1-6)</td>\n</tr>\n<tr>\n<td><code>CODE_BLOCK</code></td>\n<td>Preformatted code</td>\n<td><code>language</code>, <code>is_fenced</code></td>\n</tr>\n<tr>\n<td><code>BLOCKQUOTE</code></td>\n<td>Quoted text sections</td>\n<td><code>nesting_level</code></td>\n</tr>\n<tr>\n<td><code>HORIZONTAL_RULE</code></td>\n<td>Section dividers</td>\n<td>None</td>\n</tr>\n<tr>\n<td><code>LIST</code></td>\n<td>Ordered/unordered lists</td>\n<td><code>list_type</code> (ordered/unordered), <code>start_number</code></td>\n</tr>\n<tr>\n<td><code>LIST_ITEM</code></td>\n<td>Individual list items</td>\n<td><code>marker_type</code>, <code>is_tight</code></td>\n</tr>\n</tbody></table>\n<p><strong>InlineType Enumeration:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Value</th>\n<th>Purpose</th>\n<th>Attributes Used</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>STRONG</code></td>\n<td>Bold/strong emphasis</td>\n<td>None</td>\n</tr>\n<tr>\n<td><code>EMPHASIS</code></td>\n<td>Italic/emphasis</td>\n<td>None</td>\n</tr>\n<tr>\n<td><code>CODE</code></td>\n<td>Inline code spans</td>\n<td>None</td>\n</tr>\n<tr>\n<td><code>LINK</code></td>\n<td>Hyperlinks</td>\n<td><code>url</code>, <code>title</code></td>\n</tr>\n<tr>\n<td><code>IMAGE</code></td>\n<td>Embedded images</td>\n<td><code>url</code>, <code>alt_text</code>, <code>title</code></td>\n</tr>\n<tr>\n<td><code>LINE_BREAK</code></td>\n<td>Hard line breaks</td>\n<td><code>break_type</code> (soft/hard)</td>\n</tr>\n</tbody></table>\n<h3 id=\"parser-context-and-state\">Parser Context and State</h3>\n<p>The parsing process requires sophisticated state management to handle markdown&#39;s context-sensitive rules and maintain consistency across the two-phase parsing pipeline. Our state structures capture both the current parsing context and the accumulated results as parsing progresses.</p>\n<h4 id=\"primary-parser-state\">Primary Parser State</h4>\n<p>The main parser coordinates the overall parsing process and maintains references to specialized parsers for different document elements. This centralized state enables consistent behavior and shared utility functions across parsing phases.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>block_parser</code></td>\n<td><code>BlockParser</code></td>\n<td>Specialized parser for block-level elements</td>\n</tr>\n<tr>\n<td><code>inline_parser</code></td>\n<td><code>InlineParser</code></td>\n<td>Specialized parser for inline formatting elements</td>\n</tr>\n<tr>\n<td><code>html_generator</code></td>\n<td><code>HTMLGenerator</code></td>\n<td>Component responsible for AST-to-HTML conversion</td>\n</tr>\n</tbody></table>\n<p>The <code>MarkdownParser</code> serves as the facade for the entire parsing system, orchestrating the flow from raw markdown text through block parsing, inline parsing, and final HTML generation. This design enables clean separation of concerns while providing a simple external interface.</p>\n<h4 id=\"line-processing-context\">Line Processing Context</h4>\n<p>Before any structural parsing begins, the raw markdown text undergoes preprocessing to normalize line endings, analyze indentation, and identify blank lines. The <code>LineInfo</code> structure captures this analysis for each source line.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>content</code></td>\n<td><code>str</code></td>\n<td>The line&#39;s text content with normalized whitespace handling</td>\n</tr>\n<tr>\n<td><code>line_number</code></td>\n<td><code>int</code></td>\n<td>One-based line number in the original source document</td>\n</tr>\n<tr>\n<td><code>is_blank</code></td>\n<td><code>bool</code></td>\n<td>True if the line contains only whitespace characters</td>\n</tr>\n<tr>\n<td><code>indent_level</code></td>\n<td><code>int</code></td>\n<td>Number of leading spaces (tabs converted to spaces)</td>\n</tr>\n</tbody></table>\n<p>The preprocessing phase transforms raw input into a list of <code>LineInfo</code> objects that subsequent parsing phases consume. This preprocessing handles cross-platform compatibility (normalizing Windows/Mac line endings), establishes consistent indentation measurement, and pre-identifies blank lines that serve as block separators.</p>\n<p>The <code>indent_level</code> calculation converts tabs to spaces using a configurable tab width (typically 4 spaces) and handles mixed indentation consistently. This preprocessing eliminates platform-specific edge cases from the core parsing logic.</p>\n<h4 id=\"block-parser-state\">Block Parser State</h4>\n<p>During block-level parsing, the parser maintains state about the current parsing context, including nesting levels for elements like blockquotes and lists, and accumulated content for multi-line elements like paragraphs.</p>\n<p>Block parser state includes several key components that track the parsing progress and accumulated results. The parser maintains a stack of open block elements to handle nested structures like blockquotes containing lists. It tracks the current line position within the input and maintains buffers for accumulating multi-line content.</p>\n<p>The block parser uses a state machine approach where each line can trigger transitions between parsing modes. When processing a paragraph, each subsequent non-blank line accumulates into the paragraph content until a blank line or new block element triggers paragraph closure and inline parsing of the accumulated content.</p>\n<p>For list processing, the block parser maintains additional state tracking current list nesting levels, list types at each level, and tight versus loose list formatting. This state enables proper handling of complex nested list structures while maintaining CommonMark compliance.</p>\n<h4 id=\"inline-parser-state\">Inline Parser State</h4>\n<p>Inline parsing requires sophisticated state management to handle nested elements and delimiter matching. The inline parser maintains a delimiter stack to track opening markers (asterisks, underscores, backticks) and match them with corresponding closing markers according to CommonMark precedence rules.</p>\n<p>The delimiter stack tracks not just the marker characters but their positions, surrounding context, and nesting relationships. When processing text like &quot;<strong>bold <em>italic</em> text</strong>&quot;, the parser must correctly identify that the asterisks for italic are nested within the asterisks for bold, requiring careful stack management.</p>\n<p>The inline parser also maintains context about whether it&#39;s currently inside certain elements that restrict further nesting. For example, code spans cannot contain other inline formatting, so the parser suppresses emphasis processing while inside backtick-delimited code.</p>\n<p>Link parsing requires special state management because link text can contain other inline formatting, but the URL portion cannot. The parser tracks whether it&#39;s currently inside link text versus link URLs and adjusts its behavior accordingly.</p>\n<blockquote>\n<p><strong>Architecture Decision: Stateful vs Stateless Parsing</strong></p>\n<ul>\n<li><strong>Context</strong>: Choose between maintaining parser state versus pure functional parsing</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Stateful parsers with mutable context objects</li>\n<li>Pure functional parsers passing immutable state</li>\n<li>Hybrid approach with immutable state but mutable result accumulation</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Stateful parsers with carefully controlled mutable state</li>\n<li><strong>Rationale</strong>: Markdown&#39;s context-sensitive rules (especially for lists and emphasis) create complex state dependencies that are clearer to express with mutable state. Functional approaches would require threading complex state through every parsing function.</li>\n<li><strong>Consequences</strong>: Enables more readable parsing logic and better performance, but requires careful state management to avoid bugs from unexpected mutations.</li>\n</ul>\n</blockquote>\n<h3 id=\"ast-construction-and-manipulation\">AST Construction and Manipulation</h3>\n<p>The AST provides a comprehensive interface for constructing and manipulating the document tree during parsing. These operations maintain tree invariants and provide safe access to the hierarchical structure.</p>\n<h4 id=\"node-construction-interface\">Node Construction Interface</h4>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>add_child</code></td>\n<td><code>child: ASTNode</code></td>\n<td><code>None</code></td>\n<td>Appends child node and sets its parent reference</td>\n</tr>\n<tr>\n<td><code>set_content</code></td>\n<td><code>content: str</code></td>\n<td><code>None</code></td>\n<td>Sets the text content for leaf nodes</td>\n</tr>\n<tr>\n<td><code>set_attribute</code></td>\n<td><code>key: str, value: Any</code></td>\n<td><code>None</code></td>\n<td>Stores element-specific attribute</td>\n</tr>\n<tr>\n<td><code>get_attribute</code></td>\n<td><code>key: str, default: Any</code></td>\n<td><code>Any</code></td>\n<td>Retrieves attribute value or default</td>\n</tr>\n</tbody></table>\n<p>The <code>add_child</code> method maintains bidirectional parent-child relationships automatically. When a child is added to a parent, the child&#39;s parent reference is updated, and if the child was previously attached to a different parent, it&#39;s removed from the old parent&#39;s children list. This ensures tree consistency without manual reference management.</p>\n<p>The attribute methods provide type-safe access to element-specific properties. Rather than exposing the attribute dictionary directly, these methods enable validation and default value handling. For example, <code>get_attribute(&quot;level&quot;, 1)</code> retrieves a heading&#39;s level with a sensible default.</p>\n<h4 id=\"tree-traversal-interface\">Tree Traversal Interface</h4>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>depth_first_walk</code></td>\n<td><code>visitor: function</code></td>\n<td><code>None</code></td>\n<td>Visits all nodes in depth-first order</td>\n</tr>\n<tr>\n<td><code>find_nodes_by_type</code></td>\n<td><code>node_type: NodeType</code></td>\n<td><code>List[ASTNode]</code></td>\n<td>Returns all descendant nodes of specified type</td>\n</tr>\n<tr>\n<td><code>get_text_content</code></td>\n<td>None</td>\n<td><code>str</code></td>\n<td>Returns concatenated text from all descendant text nodes</td>\n</tr>\n</tbody></table>\n<p>Tree traversal methods support common operations needed during HTML generation and analysis. The <code>depth_first_walk</code> method accepts a visitor function that&#39;s called for each node, enabling custom processing without exposing tree structure details.</p>\n<p>The <code>get_text_content</code> method provides a convenient way to extract all text from a subtree, useful for generating alt text, computing heading anchor text, or extracting link text for processing.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Circular Parent References</strong>\nWhen manually constructing AST nodes, developers sometimes create circular references by setting parent pointers incorrectly. This leads to infinite loops during tree traversal. Always use the <code>add_child</code> method rather than setting parent/children references manually—it maintains consistency automatically.</p>\n<p>⚠️ <strong>Pitfall: Modifying Children During Traversal</strong>\nModifying a node&#39;s children list while iterating over it (for example, during tree transformation) can skip nodes or cause index errors. Create a copy of the children list before iteration, or use reverse iteration when removing nodes.</p>\n<p>⚠️ <strong>Pitfall: Inconsistent Node Types</strong>\nSetting a node&#39;s <code>node_type</code> to <code>BLOCK</code> but using <code>InlineType</code> values in type-specific fields creates confusion during processing. The type hierarchy must be consistent—<code>BlockNode</code> instances should only use <code>BlockType</code> values, and the base <code>node_type</code> should match the specialized type field.</p>\n<p>⚠️ <strong>Pitfall: Missing Line Number Tracking</strong>\nFailing to set line numbers during parsing makes debugging extremely difficult. Users report &quot;the heading is malformed&quot; but without line numbers, finding the problem in large documents becomes painful. Always propagate line numbers from <code>LineInfo</code> to AST nodes.</p>\n<p>⚠️ <strong>Pitfall: Deep Copying Node References</strong>\nWhen cloning or serializing AST nodes, naive deep copying creates duplicate parent/child references that break tree structure. Implement custom cloning that reconstructs relationships rather than copying references directly.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The AST implementation requires careful attention to memory management, type safety, and tree consistency. The following guidance provides practical approaches for implementing the data model in Python.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Node Classes</td>\n<td>Python dataclasses with inheritance</td>\n<td>Custom classes with <code>__slots__</code> for memory efficiency</td>\n</tr>\n<tr>\n<td>Type Safety</td>\n<td>Python enums for node types</td>\n<td>Python typing with Union types and type guards</td>\n</tr>\n<tr>\n<td>Tree Operations</td>\n<td>Recursive methods with explicit stack management</td>\n<td>Generator-based traversal to avoid stack overflow</td>\n</tr>\n<tr>\n<td>Attribute Storage</td>\n<td>Simple dictionaries</td>\n<td>Typed attribute classes for validation</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>markdown_renderer/\n  ast/\n    __init__.py              ← Export public AST interface\n    nodes.py                 ← Core node class definitions\n    traversal.py             ← Tree traversal utilities\n    builder.py               ← High-level AST construction helpers\n  parser/\n    context.py               ← Parser state and context classes\n    line_info.py             ← Line preprocessing utilities</code></pre></div>\n\n<p>This structure separates AST data structures from parsing logic while keeping related functionality grouped. The <code>ast</code> package can be imported independently for applications that work with pre-built trees.</p>\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete LineInfo Processing (<code>parser/line_info.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LineInfo</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    content: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line_number: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_blank: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indent_level: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Preprocessor</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TAB_WIDTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> normalize_line_endings</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert all line endings to Unix format (</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> text.replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">).replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> split_into_lines</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Split text into lines, preserving empty lines.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> text.split(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_blank_line</span><span style=\"color:#E1E4E8\">(self, line: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if line contains only whitespace.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(line.strip()) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_indentation_level</span><span style=\"color:#E1E4E8\">(self, line: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Count leading spaces, converting tabs to spaces.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        indent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> line:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> ' '</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                indent </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            elif</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                indent </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">TAB_WIDTH</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> indent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_input</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[LineInfo]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert raw markdown text into analyzed line information.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        normalized </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.normalize_line_endings(text)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.split_into_lines(normalized)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        line_infos </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i, line </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(lines):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            line_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LineInfo(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                content</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">line,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                line_number</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                is_blank</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.is_blank_line(line),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                indent_level</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.get_indentation_level(line)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            line_infos.append(line_info)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> line_infos</span></span></code></pre></div>\n\n<p><strong>HTML Escaping Utilities (<code>ast/nodes.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># HTML character escaping table for safe output generation</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">HTML_ESCAPE_TABLE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x26;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;amp;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x3C;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;lt;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '>'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;gt;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '\"'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;quot;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"'\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;#x27;'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> escape_html</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Escape HTML special characters to prevent XSS and ensure valid output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> char, entity </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> HTML_ESCAPE_TABLE</span><span style=\"color:#E1E4E8\">.items():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        text </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text.replace(char, entity)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> text</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Base AST Node Implementation (<code>ast/nodes.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Any, Dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> NodeType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DOCUMENT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"document\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BLOCK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"block\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INLINE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"inline\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TEXT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"text\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BlockType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PARAGRAPH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"paragraph\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HEADING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"heading\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CODE_BLOCK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"code_block\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BLOCKQUOTE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"blockquote\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HORIZONTAL_RULE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"horizontal_rule\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LIST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"list\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LIST_ITEM</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"list_item\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InlineType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    STRONG</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"strong\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EMPHASIS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"emphasis\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CODE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"code\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LINK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"link\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    IMAGE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"image\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LINE_BREAK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"line_break\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ASTNode</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node_type: NodeType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    children: List[</span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parent: Optional[</span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line_number: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_child</span><span style=\"color:#E1E4E8\">(self, child: </span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add child node and maintain bidirectional parent-child relationship.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Remove child from its current parent if it has one</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add child to this node's children list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Set child's parent reference to this node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Check if child.parent exists before removing from old parent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> set_content</span><span style=\"color:#E1E4E8\">(self, content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set text content for leaf nodes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Store content in appropriate field based on node type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For text nodes, content goes directly in text field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For block nodes, content goes in inline_content for later inline parsing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: This method should behave differently for different node types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> set_attribute</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set element-specific attribute.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Ensure attributes dictionary exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Store key-value pair in appropriate attributes field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle validation for known attribute keys if desired</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_attribute</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, default: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get element-specific attribute with optional default.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if attributes dictionary exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return attribute value if key exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return default value if key doesn't exist</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BlockNode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ASTNode</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block_type: BlockType </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BlockType.</span><span style=\"color:#79B8FF\">PARAGRAPH</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inline_content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    block_attributes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Ensure node_type is consistent with being a block node</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.node_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> NodeType.</span><span style=\"color:#79B8FF\">BLOCK</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InlineNode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ASTNode</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inline_type: InlineType </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> InlineType.</span><span style=\"color:#79B8FF\">EMPHASIS</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    text_content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    formatting_attributes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Ensure node_type is consistent with being an inline node  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.node_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> NodeType.</span><span style=\"color:#79B8FF\">INLINE</span></span></code></pre></div>\n\n<p><strong>AST Traversal Utilities (<code>ast/traversal.py</code>):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Callable, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .nodes </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ASTNode, NodeType</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> debug_print_ast</span><span style=\"color:#E1E4E8\">(node: ASTNode, indent: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Print AST structure for debugging purposes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Print current node with indentation showing tree depth</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Include node type, line number, and key attributes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Recursively print all child nodes with increased indentation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For text nodes, show truncated content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: For block/inline nodes, show their specific type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Use \" \" * indent for indentation, truncate long content</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> depth_first_walk</span><span style=\"color:#E1E4E8\">(node: ASTNode, visitor: Callable[[ASTNode], </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Visit all nodes in depth-first order.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Call visitor function on current node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Recursively walk all child nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle any exceptions from visitor gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hint: Visit parent before children for depth-first pre-order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> find_nodes_by_type</span><span style=\"color:#E1E4E8\">(root: ASTNode, target_type: NodeType) -> List[ASTNode]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Find all descendant nodes of specified type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> collector</span><span style=\"color:#E1E4E8\">(node: ASTNode) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if current node matches target_type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add matching nodes to results list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Use depth_first_walk with collector function</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return accumulated results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> results</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> get_text_content</span><span style=\"color:#E1E4E8\">(node: ASTNode) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Extract all text content from node and descendants.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    text_parts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> text_collector</span><span style=\"color:#E1E4E8\">(node: ASTNode) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: If node is text type, add its content to text_parts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For other node types, extract text from appropriate fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle inline nodes with text_content field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle block nodes with inline_content field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Walk tree collecting text</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Join all text parts and return</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> \"\"</span></span></code></pre></div>\n\n<h4 id=\"language-specific-implementation-notes\">Language-Specific Implementation Notes</h4>\n<p><strong>Memory Efficiency in Python:</strong></p>\n<ul>\n<li>Use <code>__slots__</code> in node classes if memory usage becomes an issue with large documents</li>\n<li>Consider <code>weakref</code> for parent references to avoid circular reference memory leaks</li>\n<li>Use generators for tree traversal to avoid building large intermediate lists</li>\n</ul>\n<p><strong>Type Safety:</strong></p>\n<ul>\n<li>Use <code>typing.Union</code> to create precise type hints for methods that accept multiple node types  </li>\n<li>Consider using <code>typing.Protocol</code> to define interfaces rather than concrete inheritance</li>\n<li>Use <code>isinstance()</code> checks with enum values for type-safe node processing</li>\n</ul>\n<p><strong>Performance Considerations:</strong></p>\n<ul>\n<li>Cache frequently-accessed attributes like text content extraction</li>\n<li>Use iterative traversal instead of recursion for very deep document trees</li>\n<li>Consider lazy evaluation for expensive operations like full-text search</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the AST data model, verify functionality with these tests:</p>\n<ol>\n<li><strong>Node Construction Test</strong>: Create nodes of each type and verify all fields are properly initialized</li>\n<li><strong>Parent-Child Relationship Test</strong>: Add children to parents and verify bidirectional references</li>\n<li><strong>Tree Traversal Test</strong>: Build a small tree and verify depth-first traversal visits nodes in correct order</li>\n<li><strong>Attribute Management Test</strong>: Set and retrieve attributes on different node types</li>\n<li><strong>Line Processing Test</strong>: Process sample markdown text and verify <code>LineInfo</code> objects have correct properties</li>\n</ol>\n<p><strong>Expected Behavior:</strong></p>\n<ul>\n<li><code>debug_print_ast()</code> should show proper tree structure with indentation</li>\n<li>Parent-child relationships should be consistent after <code>add_child()</code> calls</li>\n<li>Line preprocessing should correctly identify blank lines and indentation levels</li>\n<li>HTML escaping should convert <code>&lt;script&gt;</code> to <code>&amp;lt;script&amp;gt;</code></li>\n</ul>\n<p><strong>Common Issues to Check:</strong></p>\n<ul>\n<li>Circular references causing infinite loops in traversal</li>\n<li>Missing line numbers making debugging difficult  </li>\n<li>Inconsistent node types between base and specialized fields</li>\n<li>Memory leaks from strong reference cycles in parent-child relationships</li>\n</ul>\n<h2 id=\"block-parser-design\">Block Parser Design</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1: Block Elements</p>\n</blockquote>\n<h3 id=\"the-building-blocks-mental-model\">The Building Blocks Mental Model</h3>\n<p>Think of block parsing like organizing a messy stack of papers into clearly labeled folders. When you process a pile of documents, you first separate them into major categories—reports go in one folder, memos in another, code printouts in a third. You don&#39;t worry about the formatting within each document (bold text, underlined words) until after you&#39;ve sorted them into the right folders. Block parsing works the same way: it takes the raw lines of markdown text and groups them into structural containers like headings, paragraphs, code blocks, and blockquotes. Each block becomes a clearly defined section that can later be filled with inline formatting details.</p>\n<p>The key insight is that block-level structure provides the skeleton of the document, while inline elements provide the flesh. You must build the skeleton first before you can properly attach the details. This two-phase approach prevents the parser from getting confused when it encounters complex nested structures like a bold link inside a blockquote within a list item.</p>\n<p><img src=\"/api/project/markdown-renderer/architecture-doc/asset?path=diagrams%2Fblock-parsing-states.svg\" alt=\"Block Parser State Machine\"></p>\n<h3 id=\"block-parsing-algorithm\">Block Parsing Algorithm</h3>\n<p>The block parsing algorithm operates as a <strong>state machine</strong> that processes the markdown text line by line, maintaining context about what type of block is currently being built. The parser must handle the fact that some blocks span multiple lines (paragraphs, code blocks) while others are determined by a single line (headings, horizontal rules). Additionally, some blocks require lookahead to determine their type (distinguishing between a paragraph and a heading with Setext underlines).</p>\n<p>The algorithm follows this sequential process:</p>\n<ol>\n<li><p><strong>Input Preprocessing</strong>: The raw markdown text is normalized by converting all line endings to Unix format (<code>\\n</code>) and splitting into individual lines while preserving line numbers for error reporting. Each line is wrapped in a <code>LineInfo</code> object that captures the original content, line number, whether it&#39;s blank, and its indentation level.</p>\n</li>\n<li><p><strong>Block Detection Loop</strong>: The parser iterates through the processed lines, maintaining a current parsing state. For each line, it first checks if the current block type can continue (for multi-line blocks like paragraphs or code blocks). If the current block cannot continue, it finalizes the current block and attempts to start a new block based on the line&#39;s characteristics.</p>\n</li>\n<li><p><strong>Block Type Recognition</strong>: The parser uses a priority-ordered sequence of pattern matching to determine block types. Headings are checked first (both ATX-style with <code>#</code> prefixes and potential Setext-style with underline lookahead), followed by code blocks (both fenced with triple backticks and indented), then blockquotes (lines starting with <code>&gt;</code>), horizontal rules (three or more dashes or asterisks), and finally defaulting to paragraph blocks.</p>\n</li>\n<li><p><strong>Multi-line Block Handling</strong>: For blocks that span multiple lines, the parser maintains state about the current block being constructed. Paragraph blocks accumulate consecutive non-blank lines until encountering a blank line or a line that starts a new block type. Code blocks have different continuation rules depending on whether they&#39;re fenced (continue until closing fence) or indented (continue while indentation is maintained).</p>\n</li>\n<li><p><strong>Blank Line Processing</strong>: Blank lines serve as block separators in most contexts, but their handling depends on the current block type. They terminate paragraph blocks and separate loose list items, but are preserved within fenced code blocks and ignored within indented code blocks after the required indentation is stripped.</p>\n</li>\n<li><p><strong>Block Finalization</strong>: When a block is completed (either by encountering a new block type or reaching the end of input), the parser creates a <code>BlockNode</code> with the appropriate <code>BlockType</code>, stores the raw content that will later be processed for inline elements, and adds it to the growing AST.</p>\n</li>\n<li><p><strong>Lookahead Handling</strong>: Some block types require examining subsequent lines to make parsing decisions. Setext headings are the primary example—a line of text followed by a line of equals signs or dashes indicates a heading, not two separate paragraphs. The parser implements limited lookahead by peeking at the next line when the current line could potentially be part of a Setext heading.</p>\n</li>\n<li><p><strong>Context Preservation</strong>: Throughout parsing, the algorithm maintains context about nesting levels (important for lists and blockquotes), indentation tracking, and the parent-child relationships needed to build the hierarchical AST structure.</p>\n</li>\n</ol>\n<p>The parser uses this state machine approach rather than attempting to parse all block types simultaneously with complex regular expressions. This provides better error recovery, clearer debugging, and easier extension to support additional block types.</p>\n<h3 id=\"block-parser-architecture-decisions\">Block Parser Architecture Decisions</h3>\n<p>The block parser must make several critical architectural choices that significantly impact both the implementation complexity and the system&#39;s extensibility. Each decision involves trade-offs between parsing accuracy, performance, and maintainability.</p>\n<blockquote>\n<p><strong>Decision: State Machine vs. Regular Expression Matching</strong></p>\n<ul>\n<li><strong>Context</strong>: Block parsing can be implemented either as a state machine that tracks parsing context across lines, or as a collection of regular expressions that pattern-match individual lines</li>\n<li><strong>Options Considered</strong>: Stateful line-by-line processing, regex-based pattern matching, hybrid approach with regex patterns within state machine</li>\n<li><strong>Decision</strong>: State machine with regex patterns for individual line recognition</li>\n<li><strong>Rationale</strong>: State machines provide better context tracking for multi-line blocks and cleaner error recovery, while regex patterns excel at recognizing specific line formats like headings and horizontal rules</li>\n<li><strong>Consequences</strong>: Enables robust handling of complex cases like nested blockquotes and provides clear extension points for new block types, but requires more complex state management</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Pure State Machine</td>\n<td>Clean context tracking, excellent error recovery, easy debugging</td>\n<td>Complex state transitions, harder to modify individual patterns</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Pure Regex</td>\n<td>Simple pattern matching, easy to modify individual rules</td>\n<td>No context between lines, poor error handling, brittle</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Hybrid State Machine + Regex</td>\n<td>Context tracking + flexible patterns, maintainable</td>\n<td>Moderate complexity in state management</td>\n<td>Yes</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Lookahead Strategy for Setext Headings</strong></p>\n<ul>\n<li><strong>Context</strong>: Setext headings require examining the next line to determine if a text line should become a heading, but lookahead complicates the single-pass parsing algorithm</li>\n<li><strong>Options Considered</strong>: Single-line lookahead buffer, two-pass preprocessing, ignore Setext headings entirely</li>\n<li><strong>Decision</strong>: Limited single-line lookahead with buffering</li>\n<li><strong>Rationale</strong>: Setext headings are common enough to support, but full two-pass parsing adds unnecessary complexity for this single use case</li>\n<li><strong>Consequences</strong>: Requires maintaining a one-line buffer and special handling in the main parsing loop, but keeps the parser mostly single-pass</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Lookahead Strategy</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>No Lookahead</td>\n<td>Simplest parsing, single-pass</td>\n<td>Cannot handle Setext headings</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Single-line Buffer</td>\n<td>Handles Setext headings, mostly single-pass</td>\n<td>Slightly more complex state</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Full Two-pass</td>\n<td>Handles all complex cases</td>\n<td>Much more complex, performance overhead</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Block Content Storage Format</strong></p>\n<ul>\n<li><strong>Context</strong>: Blocks need to store their raw content for later inline processing, but the storage format affects both memory usage and inline parsing complexity</li>\n<li><strong>Options Considered</strong>: Store as single concatenated string, maintain array of original lines, store preprocessed text with whitespace normalized</li>\n<li><strong>Decision</strong>: Store as array of original line strings with metadata</li>\n<li><strong>Rationale</strong>: Preserves original formatting for accurate inline parsing while maintaining line-level information needed for error reporting and debugging</li>\n<li><strong>Consequences</strong>: Higher memory usage but better debugging information and more accurate inline parsing, especially for code blocks where whitespace is significant</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Storage Format</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single String</td>\n<td>Low memory, simple</td>\n<td>Loses line boundaries, poor debugging</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Line Array</td>\n<td>Preserves formatting, good debugging</td>\n<td>Higher memory usage</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Preprocessed</td>\n<td>Normalized format</td>\n<td>May lose important whitespace</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Error Recovery Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: When encountering malformed block syntax, the parser must decide whether to fail, skip the problematic content, or attempt graceful recovery</li>\n<li><strong>Options Considered</strong>: Fail on any syntax error, skip malformed blocks entirely, treat unrecognized syntax as paragraph text</li>\n<li><strong>Decision</strong>: Graceful degradation by treating unrecognized blocks as paragraphs</li>\n<li><strong>Rationale</strong>: Markdown philosophy emphasizes readability even when formatting is imperfect, so the parser should produce reasonable output from imperfect input</li>\n<li><strong>Consequences</strong>: Users get output even from malformed input, but may not notice formatting errors that should be corrected</li>\n</ul>\n</blockquote>\n<p>The block parser implements these decisions through a <code>BlockParser</code> class that maintains parsing state and delegates to specialized recognition functions for each block type. The state machine tracks the current block being built, while individual regex patterns handle line-level recognition within the appropriate state context.</p>\n<h3 id=\"block-parsing-common-pitfalls\">Block Parsing Common Pitfalls</h3>\n<p>Block parsing presents several subtle challenges that frequently trip up developers implementing their first markdown parser. These pitfalls often stem from the interaction between line-level pattern matching and multi-line context tracking.</p>\n<p>⚠️ <strong>Pitfall: Forgetting Setext Heading Lookahead</strong></p>\n<p>Many developers implement ATX headings (lines starting with <code>#</code>) correctly but forget that Setext headings require examining the following line. They parse each line independently and end up treating &quot;Title\\n====&quot; as a paragraph containing &quot;Title&quot; followed by another paragraph containing &quot;====&quot;, instead of recognizing it as a level-1 heading.</p>\n<p>The issue occurs because single-line parsing cannot distinguish between a standalone line of text and the first line of a Setext heading. The parser must peek at the next line to check for underline characters (<code>=</code> for h1, <code>-</code> for h2) before deciding how to classify the current line.</p>\n<p>To avoid this, implement a one-line lookahead buffer in your main parsing loop. When you encounter a non-blank line that could be a heading, check if the next line consists entirely of <code>=</code> or <code>-</code> characters. Only commit to creating a paragraph block after confirming the next line is not a Setext underline.</p>\n<p>⚠️ <strong>Pitfall: Incorrect Indented Code Block Detection</strong></p>\n<p>Indented code blocks require exactly four spaces of indentation, but many parsers incorrectly handle mixed tabs and spaces or fail to distinguish between indented code and normal paragraph continuation. A common mistake is treating any indented line as code, which breaks when users indent regular paragraphs for visual formatting.</p>\n<p>The problem is compounded by the fact that indented code blocks must be preceded by a blank line (or start of document) to distinguish them from indented continuation of previous blocks like list items or blockquotes. Without this check, indented text within lists gets incorrectly parsed as code blocks.</p>\n<p>Implement precise indentation checking by normalizing tabs to spaces early in preprocessing, then checking for exactly four spaces (or one tab) at the line start. Additionally, verify that indented code blocks are preceded by blank lines or other block boundaries, not continuation of existing blocks.</p>\n<p>⚠️ <strong>Pitfall: Fenced Code Block Language Hints</strong></p>\n<p>Fenced code blocks can specify a language identifier immediately after the opening triple backticks (e.g., &quot;```python&quot;), but many parsers either ignore this information entirely or fail to handle edge cases like languages with special characters or extra whitespace.</p>\n<p>The language hint affects HTML generation because it should be included in the CSS class of the generated <code>&lt;code&gt;</code> element, but parsers often store only the content between the fences without preserving the language metadata. This breaks syntax highlighting and other language-specific processing.</p>\n<p>Extract the language hint during fenced code block parsing by capturing everything after the opening fence until the first whitespace or newline. Store this as a block attribute that the HTML generator can access later. Handle the case where no language is specified by storing an empty string rather than null.</p>\n<p>⚠️ <strong>Pitfall: Blockquote Nesting and Lazy Continuation</strong></p>\n<p>Blockquote parsing has two subtle complications: nested blockquotes (lines with multiple <code>&gt;</code> prefixes) and lazy continuation (subsequent lines without <code>&gt;</code> that continue the blockquote content). Many parsers handle only simple single-level blockquotes.</p>\n<p>Nested blockquotes require tracking the depth of <code>&gt;</code> characters and building a hierarchical structure of blockquote nodes. Lazy continuation means that once a blockquote starts, subsequent non-blank lines continue the blockquote even without <code>&gt;</code> prefixes, until a blank line or new block type is encountered.</p>\n<p>Implement blockquote parsing by counting the number of <code>&gt;</code> characters at the start of each line to determine nesting depth. Maintain a stack of active blockquote levels, creating new nested blockquotes when depth increases and closing blockquotes when depth decreases. For lazy continuation, allow lines without <code>&gt;</code> prefixes to continue the current blockquote level.</p>\n<p>⚠️ <strong>Pitfall: Horizontal Rule False Positives</strong></p>\n<p>Horizontal rules are created by lines containing only three or more dashes, asterisks, or underscores, with optional whitespace. However, many parsers create false positives by not properly checking for other content on the line or by conflicting with Setext heading underlines.</p>\n<p>A line like &quot;--- some text&quot; should not create a horizontal rule, and a line with three dashes under text should be checked for Setext heading interpretation before considering it a horizontal rule. Additionally, the characters must all be the same type—mixing dashes and asterisks should not create a rule.</p>\n<p>Implement horizontal rule detection with a regex that anchors to the start and end of the line, ensures all characters are the same type, and requires at least three repetitions. Check for horizontal rules only after ruling out Setext headings to avoid conflicts.</p>\n<p>⚠️ <strong>Pitfall: Block Boundary Detection</strong></p>\n<p>Determining where one block ends and another begins is more complex than simply looking for blank lines. Different block types have different termination rules, and some blocks (like paragraphs) can be interrupted by other block types even without blank line separators.</p>\n<p>For example, a paragraph can be immediately followed by a heading without a blank line separator, but a paragraph cannot be immediately followed by another paragraph. Similarly, fenced code blocks ignore all content until their closing fence, including lines that would normally start new block types.</p>\n<p>Create a clear hierarchy of block interruption rules. Headings and horizontal rules can interrupt paragraphs immediately. Code blocks have their own continuation rules that override normal block detection. Use a state machine that tracks the current block type and consults type-specific continuation rules before attempting to start new blocks.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The block parser forms the foundation of the entire markdown parsing pipeline, so robust implementation is crucial for the system&#39;s overall reliability. The following guidance provides both infrastructure components and core parsing logic to support all the block types required in Milestone 1.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Line Processing</td>\n<td>Basic string splitting with manual parsing</td>\n<td>Regular expression engine with compiled patterns</td>\n</tr>\n<tr>\n<td>State Management</td>\n<td>Simple enum states with switch statements</td>\n<td>State pattern with polymorphic state objects</td>\n</tr>\n<tr>\n<td>AST Construction</td>\n<td>Direct node creation with manual tree building</td>\n<td>Builder pattern with fluent interface</td>\n</tr>\n<tr>\n<td>Lookahead Buffer</td>\n<td>Single-element peek buffer</td>\n<td>Buffered reader with arbitrary lookahead</td>\n</tr>\n<tr>\n<td>Block Recognition</td>\n<td>Hardcoded if-else chains for each block type</td>\n<td>Strategy pattern with pluggable block recognizers</td>\n</tr>\n</tbody></table>\n<p>For a beginner implementation, the simple options provide clear, debuggable code. The advanced options become valuable when extending the parser with custom block types or optimizing performance for large documents.</p>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  src/\n    markdown_parser/\n      __init__.py                    ← main parse_to_html() entry point\n      preprocessor.py                ← line processing and normalization\n      block_parser.py                ← core block parsing logic (implement this)\n      inline_parser.py               ← inline element parsing (future milestone)\n      ast_nodes.py                   ← AST node classes and enums\n      html_generator.py              ← HTML output generation (future milestone)\n      utils.py                       ← shared utilities and constants\n    tests/\n      test_block_parser.py           ← block parsing unit tests\n      test_integration.py            ← end-to-end parsing tests\n      fixtures/                      ← markdown test files\n        block_elements.md\n        edge_cases.md</code></pre></div>\n\n<p>This structure separates concerns cleanly while keeping related functionality together. The <code>block_parser.py</code> module contains the core logic you&#39;ll implement, while infrastructure components provide support functionality.</p>\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>File: <code>src/markdown_parser/ast_nodes.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Dict, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> NodeType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DOCUMENT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"document\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BLOCK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"block\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INLINE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"inline\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TEXT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"text\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BlockType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PARAGRAPH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"paragraph\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HEADING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"heading\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CODE_BLOCK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"code_block\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BLOCKQUOTE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"blockquote\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    HORIZONTAL_RULE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"horizontal_rule\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LIST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"list\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LIST_ITEM</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"list_item\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InlineType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    STRONG</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"strong\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EMPHASIS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"emphasis\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CODE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"code\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LINK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"link\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    IMAGE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"image\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LINE_BREAK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"line_break\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ASTNode</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for all AST nodes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, node_type: NodeType, line_number: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.node_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node_type</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.children: List[</span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parent: Optional[</span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.line_number </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> line_number</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_child</span><span style=\"color:#E1E4E8\">(self, child: </span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add child node and set parent relationship.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        child.parent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.children.append(child)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> find_nodes_by_type</span><span style=\"color:#E1E4E8\">(self, target_type) -> List[</span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Find all descendant nodes of specified type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.node_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> target_type:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            results.append(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.children:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            results.extend(child.find_nodes_by_type(target_type))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> results</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BlockNode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ASTNode</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents a block-level element like paragraph, heading, or code block.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, block_type: BlockType, line_number: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(NodeType.</span><span style=\"color:#79B8FF\">BLOCK</span><span style=\"color:#E1E4E8\">, line_number)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.block_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> block_type</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.inline_content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.block_attributes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> set_content</span><span style=\"color:#E1E4E8\">(self, content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set raw text content for block.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.inline_content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> content</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> set_attribute</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set element-specific attribute.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.block_attributes[key] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_attribute</span><span style=\"color:#E1E4E8\">(self, key: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, default: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get element-specific attribute.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.block_attributes.get(key, default)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InlineNode</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ASTNode</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents an inline element like emphasis, link, or code span.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, inline_type: InlineType, line_number: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(NodeType.</span><span style=\"color:#79B8FF\">INLINE</span><span style=\"color:#E1E4E8\">, line_number)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.inline_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> inline_type</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.text_content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.formatting_attributes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span></code></pre></div>\n\n<p><strong>File: <code>src/markdown_parser/preprocessor.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LineInfo</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Information about a single line of markdown input.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    content: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line_number: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_blank: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    indent_level: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Preprocessor</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Handles input normalization and line-level analysis.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> normalize_line_endings</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert all line endings to Unix format.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> text.replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">).replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> split_into_lines</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Split text preserving line numbers.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> text.split(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_blank_line</span><span style=\"color:#E1E4E8\">(self, line: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check for whitespace-only lines.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(line.strip()) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_indentation_level</span><span style=\"color:#E1E4E8\">(self, line: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Count leading spaces (tabs count as 4 spaces).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        indent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> line:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> ' '</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                indent </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            elif</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                indent </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 4</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                break</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> indent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_input</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[LineInfo]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Process raw markdown into analyzed lines.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        normalized </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.normalize_line_endings(text)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.split_into_lines(normalized)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i, line </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(lines):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            line_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LineInfo(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                content</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">line,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                line_number</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                is_blank</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.is_blank_line(line),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                indent_level</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.get_indentation_level(line)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result.append(line_info)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span></code></pre></div>\n\n<p><strong>File: <code>src/markdown_parser/utils.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># HTML entity escaping table</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">HTML_ESCAPE_TABLE</span><span style=\"color:#E1E4E8\">: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x26;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;amp;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x3C;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;lt;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '>'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;gt;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '\"'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;quot;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"'\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;#x27;'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> escape_html</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Escape HTML special characters.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> char, entity </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> HTML_ESCAPE_TABLE</span><span style=\"color:#E1E4E8\">.items():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        text </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text.replace(char, entity)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> debug_print_ast</span><span style=\"color:#E1E4E8\">(node, indent: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Display AST structure for debugging.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    prefix </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"  \"</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> indent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">prefix</span><span style=\"color:#79B8FF\">}{</span><span style=\"color:#E1E4E8\">node.node_type.value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'block_type'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        node_info </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\" (</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node.block_type.value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'inline_type'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        node_info </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\" (</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node.inline_type.value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'inline_content'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> node.inline_content:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        content_preview </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node.inline_content[:</span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">].replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\\\</span><span style=\"color:#9ECBFF\">n'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        node_info </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">': \"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">content_preview</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(node_info)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> node.children:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        debug_print_ast(child, indent </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Compiled regex patterns for block recognition</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ATX_HEADING_PATTERN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">^(</span><span style=\"color:#DBEDFF\">#</span><span style=\"color:#F97583\">{1,6}</span><span style=\"color:#79B8FF\">)\\s</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">(.</span><span style=\"color:#F97583\">*?</span><span style=\"color:#79B8FF\">)(?:\\s</span><span style=\"color:#F97583\">+</span><span style=\"color:#DBEDFF\">#</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">)</span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\">$</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">SETEXT_H1_UNDERLINE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">^</span><span style=\"color:#DBEDFF\">=</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">\\s</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">$</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">SETEXT_H2_UNDERLINE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">^</span><span style=\"color:#DBEDFF\">-</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">\\s</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">$</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">FENCED_CODE_START</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">^</span><span style=\"color:#DBEDFF\">```</span><span style=\"color:#79B8FF\">(\\w</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">)\\s</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">$</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">FENCED_CODE_END</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">^</span><span style=\"color:#DBEDFF\">```</span><span style=\"color:#79B8FF\">\\s</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">$</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">HORIZONTAL_RULE_PATTERN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">^(</span><span style=\"color:#85E89D;font-weight:bold\">\\*</span><span style=\"color:#F97583\">{3,}|</span><span style=\"color:#DBEDFF\">-</span><span style=\"color:#F97583\">{3,}|</span><span style=\"color:#DBEDFF\">_</span><span style=\"color:#F97583\">{3,}</span><span style=\"color:#79B8FF\">)\\s</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">$</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">BLOCKQUOTE_PATTERN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">^</span><span style=\"color:#DBEDFF\">></span><span style=\"color:#79B8FF\">\\s</span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\">(.</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">)</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>File: <code>src/markdown_parser/block_parser.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Iterator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .ast_nodes </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ASTNode, BlockNode, BlockType, NodeType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .preprocessor </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LineInfo, Preprocessor</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .utils </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">ATX_HEADING_PATTERN</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SETEXT_H1_UNDERLINE</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SETEXT_H2_UNDERLINE</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    FENCED_CODE_START</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">FENCED_CODE_END</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">HORIZONTAL_RULE_PATTERN</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    BLOCKQUOTE_PATTERN</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BlockParserState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Current state of the block parser.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LOOKING_FOR_BLOCK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"looking_for_block\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    IN_PARAGRAPH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"in_paragraph\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    IN_FENCED_CODE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"in_fenced_code\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    IN_INDENTED_CODE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"in_indented_code\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    IN_BLOCKQUOTE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"in_blockquote\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BlockParser</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Parses block-level markdown elements into an AST.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.preprocessor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Preprocessor()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BlockParserState.</span><span style=\"color:#79B8FF\">LOOKING_FOR_BLOCK</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_block: Optional[BlockNode] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.root_document: Optional[ASTNode] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.line_buffer: List[LineInfo] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_line_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_blocks</span><span style=\"color:#E1E4E8\">(self, markdown_text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> ASTNode:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Main entry point for block parsing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns the root document node containing all parsed blocks.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Use preprocessor to convert text into LineInfo objects</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create root document node to hold all blocks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Initialize parsing state and line buffer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Process all lines through the main parsing loop</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Finalize any incomplete block at end of input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return the completed document AST</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_line_sequence</span><span style=\"color:#E1E4E8\">(self, lines: List[LineInfo]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Process a sequence of lines through the block parser state machine.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        This is the main parsing loop that handles state transitions and</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        delegates to specific block type handlers.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Set up line iteration with lookahead capability</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each line, check if current block can continue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If current block cannot continue, finalize it</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Attempt to start new block based on line characteristics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If no specific block type matches, default to paragraph</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle end-of-input by finalizing any active block</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> peek_next_line</span><span style=\"color:#E1E4E8\">(self) -> Optional[LineInfo]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Look ahead at the next line without consuming it.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Used for Setext heading detection and other lookahead needs.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if there are more lines available</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return the next line without advancing current position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return None if at end of input</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> can_current_block_continue</span><span style=\"color:#E1E4E8\">(self, line: LineInfo) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if the current block can accept this line as continuation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Different block types have different continuation rules.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check current parser state and block type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For paragraphs, continue unless blank line or new block starts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For fenced code, continue until closing fence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For indented code, continue while indentation is maintained</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: For blockquotes, handle both > prefixed and lazy continuation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return False if current block should terminate</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> try_start_heading_block</span><span style=\"color:#E1E4E8\">(self, line: LineInfo) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Attempt to start an ATX or Setext heading block.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns True if heading was successfully started.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Try ATX heading pattern (# through ######)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract heading level and content from ATX match</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Try Setext heading by looking ahead to next line</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For Setext, check if next line is all = or - characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create BlockNode with HEADING type and appropriate attributes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Set heading level (1-6) and content in block attributes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> try_start_code_block</span><span style=\"color:#E1E4E8\">(self, line: LineInfo) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Attempt to start a fenced or indented code block.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns True if code block was successfully started.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check for fenced code block start (triple backticks)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract language hint if present after opening fence</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Set parser state to IN_FENCED_CODE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check for indented code block (4+ spaces, after blank line)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Verify indented code is preceded by block boundary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Create CODE_BLOCK node with appropriate attributes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> try_start_blockquote</span><span style=\"color:#E1E4E8\">(self, line: LineInfo) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Attempt to start a blockquote block.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns True if blockquote was successfully started.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check for > prefix at start of line</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract content after > marker (handling optional space)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle nested blockquotes by counting > characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create BLOCKQUOTE node with nesting level attribute</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Set parser state to IN_BLOCKQUOTE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Store first line of blockquote content</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> try_start_horizontal_rule</span><span style=\"color:#E1E4E8\">(self, line: LineInfo) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Attempt to create a horizontal rule block.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns True if horizontal rule was successfully created.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check for horizontal rule pattern (3+ dashes, stars, or underscores)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Ensure all characters are the same type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify line contains only rule characters and whitespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create HORIZONTAL_RULE node (no content needed)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Add completed block to document immediately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Reset state to LOOKING_FOR_BLOCK</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> start_paragraph_block</span><span style=\"color:#E1E4E8\">(self, line: LineInfo) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Start a new paragraph block with the given line.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        This is the default block type when no other pattern matches.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create new BlockNode with PARAGRAPH type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Set the line content as initial paragraph content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Set parser state to IN_PARAGRAPH</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Store line number for error reporting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> continue_current_block</span><span style=\"color:#E1E4E8\">(self, line: LineInfo) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add the current line to the active block being built.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Handling varies by block type and parser state.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check current parser state to determine continuation behavior</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For paragraphs, append line content with proper spacing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For fenced code, check for closing fence before appending</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For indented code, strip required indentation before appending</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: For blockquotes, handle > prefix removal and lazy continuation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Update block content while preserving line structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> finalize_current_block</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Complete the current block and add it to the document.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Performs any cleanup needed based on block type.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if there is an active block to finalize</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Trim trailing whitespace from block content if appropriate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add completed block as child of root document</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Clear current block reference and reset state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle any block-type-specific finalization (e.g., code language)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the block parser, verify correct functionality with these specific tests:</p>\n<p><strong>Test Command</strong>: <code>python -m pytest tests/test_block_parser.py -v</code></p>\n<p><strong>Expected Behavior</strong>:</p>\n<ul>\n<li>ATX headings from <code>#</code> through <code>######</code> create heading blocks with correct levels</li>\n<li>Setext headings with <code>===</code> and <code>---</code> underlines create h1 and h2 blocks</li>\n<li>Fenced code blocks preserve content exactly and capture language hints</li>\n<li>Indented code blocks handle 4-space indentation correctly</li>\n<li>Blockquotes handle both <code>&gt;</code> prefixed and lazy continuation lines</li>\n<li>Paragraphs group consecutive lines and terminate at blank lines</li>\n<li>Horizontal rules recognize <code>---</code>, <code>***</code>, and <code>___</code> patterns</li>\n</ul>\n<p><strong>Manual Verification</strong>: Create a test file with this content:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">markdown</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF;font-weight:bold\"># Main Title</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">This is a paragraph with</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">multiple lines of text.</span></span></code></pre></div>\n\n<h2 id=\"subsection\">Subsection</h2>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> hello</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"world\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<blockquote>\n<p>This is a blockquote\nwith multiple lines.</p>\n</blockquote>\n<hr>\n<p>Final paragraph.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>\nRun your parser and verify the AST contains 6 blocks: heading, paragraph, heading, code_block, blockquote, horizontal_rule, and paragraph.\n\n**Debugging Signs**:\n- If headings aren't recognized, check ATX pattern regex and heading level extraction\n- If paragraphs merge incorrectly, verify blank line handling in `can_current_block_continue`\n- If code blocks lose content, check fence detection and content preservation logic\n- If blockquotes don't handle continuation, verify lazy continuation rules</code></pre></div>\n\n\n<h2 id=\"inline-parser-design\">Inline Parser Design</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2: Inline Elements</p>\n</blockquote>\n<h3 id=\"the-text-surgery-mental-model\">The Text Surgery Mental Model</h3>\n<p>Think of inline parsing like performing precise surgery on a sentence. You have a paragraph of text that looks normal on the surface, but hidden within are formatting markers that need to be carefully extracted and transformed. Just as a surgeon must navigate around vital organs while removing a tumor, the inline parser must navigate around nested formatting while preserving the structure of the surrounding text. </p>\n<p>Consider the text: <code>This **bold text contains *nested italic* formatting** here.</code> The parser must recognize that the asterisks aren&#39;t just characters—they&#39;re surgical markers indicating where to make precise cuts. The double asterisks mark the boundaries of bold formatting, but within that region, single asterisks mark italic formatting. The parser must track the nesting depth, ensuring that when it closes the italic formatting, it doesn&#39;t accidentally close the bold formatting too early.</p>\n<p>Unlike block parsing, which deals with entire lines and clear structural boundaries, inline parsing operates at the character level within continuous text. It&#39;s context-dependent parsing where the meaning of a character depends on what came before it and what surrounds it. An underscore in the middle of a word like <code>snake_case</code> should be treated as literal text, but underscores at word boundaries like <code>_emphasis_</code> should trigger formatting.</p>\n<h3 id=\"inline-parsing-algorithm\">Inline Parsing Algorithm</h3>\n<p>The inline parser operates on text content that has already been extracted from block elements by the block parser. This two-phase approach allows the inline parser to focus purely on formatting markers without worrying about structural boundaries like paragraph breaks or code block delimiters.</p>\n<p><img src=\"/api/project/markdown-renderer/architecture-doc/asset?path=diagrams%2Finline-parsing-sequence.svg\" alt=\"Inline Element Parsing Sequence\"></p>\n<p>The core algorithm uses a <strong>delimiter stack approach</strong> combined with <strong>left-to-right scanning</strong>. This handles the fundamental challenge of nested formatting where delimiters must be matched correctly even when they overlap or contain each other.</p>\n<h4 id=\"primary-algorithm-steps\">Primary Algorithm Steps</h4>\n<p>The inline parsing algorithm processes text through several coordinated phases:</p>\n<ol>\n<li><p><strong>Character-by-character scanning</strong>: The parser maintains a current position index and examines each character in the input text. This allows it to detect delimiter sequences that might span multiple characters, such as <code>**</code> for strong emphasis or <code>![</code> for image syntax.</p>\n</li>\n<li><p><strong>Delimiter detection and classification</strong>: When the parser encounters a potential delimiter character (asterisk, underscore, backtick, square bracket), it must determine whether this character should be treated as a formatting marker or literal text. This involves checking the surrounding context, including whitespace, word boundaries, and escape sequences.</p>\n</li>\n<li><p><strong>Delimiter stack management</strong>: Valid formatting delimiters are pushed onto a stack structure that tracks their position, type, and nesting level. The stack enables proper matching of opening and closing delimiters even when they&#39;re separated by other nested formatting.</p>\n</li>\n<li><p><strong>Content extraction</strong>: Between matched delimiters, the parser recursively processes the contained text to handle nested formatting. This creates a tree structure where parent formatting elements contain child formatting elements.</p>\n</li>\n<li><p><strong>AST node creation</strong>: Successfully matched delimiter pairs result in the creation of <code>InlineNode</code> instances with the appropriate <code>InlineType</code> values. These nodes are inserted into the AST with their text content and any formatting attributes.</p>\n</li>\n<li><p><strong>Escape sequence processing</strong>: Throughout scanning, the parser must handle escape sequences where a backslash makes the following character literal. This prevents formatting markers from being processed when they&#39;re explicitly escaped by the author.</p>\n</li>\n</ol>\n<p>The algorithm handles several challenging cases that make inline parsing complex:</p>\n<p><strong>Emphasis delimiter precedence</strong>: When both asterisks and underscores are present, or when single and double delimiters compete, the parser must apply CommonMark precedence rules. Longer delimiter sequences (like <code>**</code>) generally take precedence over shorter ones (like <code>*</code>), and delimiters that are closer together are matched before those that are farther apart.</p>\n<p><strong>Intraword underscore handling</strong>: Underscores within words like <code>snake_case_variable</code> must not trigger emphasis formatting, while underscores at word boundaries should. The parser detects word boundaries by examining adjacent characters for alphanumeric content and Unicode word character properties.</p>\n<p><strong>Link and image parsing</strong>: These elements use complex syntax like <code>[link text](URL &quot;title&quot;)</code> that requires careful parsing of multiple components. The parser must handle nested square brackets in link text, optional title attributes in quotes, and URL validation.</p>\n<p><strong>Inline code span precedence</strong>: Code spans delimited by backticks have special precedence—nothing inside them should be processed for other formatting. The parser must recognize code span boundaries first and treat their content as literal text for subsequent parsing phases.</p>\n<h4 id=\"delimiter-stack-data-structures\">Delimiter Stack Data Structures</h4>\n<p>The delimiter stack uses specialized data structures to track formatting state:</p>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>delimiter_type</code></td>\n<td><code>str</code></td>\n<td>The delimiter character(s): &#39;*&#39;, &#39;**&#39;, &#39;_&#39;, &#39;__&#39;, &#39;`&#39;, &#39;[&#39;, &#39;![&#39;</td>\n</tr>\n<tr>\n<td><code>position</code></td>\n<td><code>int</code></td>\n<td>Character index in the source text where delimiter was found</td>\n</tr>\n<tr>\n<td><code>can_open</code></td>\n<td><code>bool</code></td>\n<td>Whether this delimiter can open formatting based on surrounding context</td>\n</tr>\n<tr>\n<td><code>can_close</code></td>\n<td><code>bool</code></td>\n<td>Whether this delimiter can close formatting based on surrounding context</td>\n</tr>\n<tr>\n<td><code>is_active</code></td>\n<td><code>bool</code></td>\n<td>Whether this delimiter is still available for matching</td>\n</tr>\n<tr>\n<td><code>delimiter_length</code></td>\n<td><code>int</code></td>\n<td>Length of the delimiter sequence (1 for <code>*</code>, 2 for <code>**</code>)</td>\n</tr>\n<tr>\n<td><code>original_stack_position</code></td>\n<td><code>int</code></td>\n<td>Position in delimiter stack for tracking nesting relationships</td>\n</tr>\n</tbody></table>\n<p>The stack enables several critical operations:</p>\n<p><strong>Push delimiter</strong>: When a potential opening delimiter is encountered, it&#39;s pushed onto the stack with context information about whether it can legitimately open formatting based on the surrounding whitespace and characters.</p>\n<p><strong>Match and pop</strong>: When a potential closing delimiter is found, the parser searches backward through the stack to find a matching opening delimiter of the same type. Intermediate delimiters may be deactivated if they interfere with the match.</p>\n<p><strong>Precedence resolution</strong>: When multiple valid matches are possible, the parser applies CommonMark precedence rules to determine which delimiters should be paired together.</p>\n<h3 id=\"inline-parser-architecture-decisions\">Inline Parser Architecture Decisions</h3>\n<p>The inline parser design requires several critical architectural decisions that significantly impact both correctness and performance.</p>\n<blockquote>\n<p><strong>Decision: Delimiter Stack vs Regular Expression Matching</strong></p>\n<ul>\n<li><strong>Context</strong>: Inline formatting can be nested arbitrarily deep and must handle complex precedence rules between different delimiter types</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Pure regex approach with complex patterns for each formatting type</li>\n<li>Delimiter stack with explicit delimiter matching logic  </li>\n<li>Recursive descent parser with separate functions for each inline element type</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Delimiter stack with explicit matching logic</li>\n<li><strong>Rationale</strong>: Regular expressions cannot handle arbitrary nesting depths due to their finite state nature, and complex regex patterns become unmaintainable. Recursive descent works but struggles with delimiter precedence when multiple formatting types interact. The delimiter stack approach directly models CommonMark&#39;s emphasis algorithm and handles both nesting and precedence correctly.</li>\n<li><strong>Consequences</strong>: More complex implementation than regex but handles all edge cases correctly. Stack management adds some performance overhead but enables proper handling of malformed input.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Regex Only</td>\n<td>Simple implementation, fast for basic cases</td>\n<td>Cannot handle nested formatting, complex patterns unmaintainable</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Delimiter Stack</td>\n<td>Handles nesting correctly, follows CommonMark spec exactly</td>\n<td>More complex implementation, requires careful state management</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Recursive Descent</td>\n<td>Natural tree structure, easy to extend</td>\n<td>Struggles with delimiter precedence, harder to handle malformed input</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Two-Phase vs Single-Phase Inline Processing</strong></p>\n<ul>\n<li><strong>Context</strong>: Inline elements like code spans should take precedence over emphasis formatting, but links can contain emphasis in their text</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Single pass processing all inline elements simultaneously</li>\n<li>Two-phase approach: first pass for code spans and links, second pass for emphasis</li>\n<li>Multi-phase approach with separate pass for each element type</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Two-phase approach with code spans processed first</li>\n<li><strong>Rationale</strong>: Code spans must be processed before emphasis because nothing inside a code span should be formatted. Links need special handling because they can contain emphasis in their link text. Two phases balance correctness with implementation complexity.</li>\n<li><strong>Consequences</strong>: Requires multiple passes over text but ensures correct precedence. Code spans properly mask their content from further processing.</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>Decision: Escape Sequence Processing Timing</strong></p>\n<ul>\n<li><strong>Context</strong>: Backslash escape sequences can appear anywhere and must prevent following characters from being interpreted as formatting</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Process escapes during initial scanning before delimiter detection</li>\n<li>Process escapes during delimiter matching after detection</li>\n<li>Process escapes during HTML generation as final step</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Process escapes during initial scanning</li>\n<li><strong>Rationale</strong>: Escaped characters should never be considered as potential delimiters, so escape processing must happen first. This prevents escaped asterisks from being pushed onto the delimiter stack at all.</li>\n<li><strong>Consequences</strong>: Simplifies delimiter detection logic but requires careful handling of backslashes that aren&#39;t valid escape sequences.</li>\n</ul>\n</blockquote>\n<h4 id=\"emphasis-delimiter-precedence-rules\">Emphasis Delimiter Precedence Rules</h4>\n<p>The CommonMark specification defines complex precedence rules for emphasis delimiters that the parser must implement correctly:</p>\n<table>\n<thead>\n<tr>\n<th>Precedence Level</th>\n<th>Rule</th>\n<th>Example</th>\n<th>Result</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Longer delimiter sequences take precedence</td>\n<td><code>***text***</code></td>\n<td><code>&lt;strong&gt;&lt;em&gt;text&lt;/em&gt;&lt;/strong&gt;</code></td>\n</tr>\n<tr>\n<td>2</td>\n<td>Closer delimiter pairs are matched first</td>\n<td><code>*a **b* c**</code></td>\n<td><code>&lt;em&gt;a **b&lt;/em&gt; c**</code> (malformed)</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Left-to-right processing for equal precedence</td>\n<td><code>*a* *b*</code></td>\n<td><code>&lt;em&gt;a&lt;/em&gt; &lt;em&gt;b&lt;/em&gt;</code></td>\n</tr>\n<tr>\n<td>4</td>\n<td>Intraword underscores are disabled</td>\n<td><code>snake_case_var</code></td>\n<td>No formatting applied</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Asterisks work anywhere</td>\n<td><code>a*b*c</code></td>\n<td><code>a&lt;em&gt;b&lt;/em&gt;c</code></td>\n</tr>\n</tbody></table>\n<p>These precedence rules require the delimiter stack to implement sophisticated matching logic that goes beyond simple stack operations.</p>\n<h4 id=\"context-dependent-delimiter-rules\">Context-Dependent Delimiter Rules</h4>\n<p>The parser must implement context-dependent rules for determining when characters can function as opening or closing delimiters:</p>\n<table>\n<thead>\n<tr>\n<th>Context Check</th>\n<th>Applies To</th>\n<th>Rule</th>\n<th>Example Valid</th>\n<th>Example Invalid</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Left-flanking</td>\n<td>Opening delimiters</td>\n<td>Not preceded by Unicode whitespace, not followed by punctuation unless preceded by whitespace/punctuation</td>\n<td><code>*emphasis*</code></td>\n<td><code>* not emphasis</code></td>\n</tr>\n<tr>\n<td>Right-flanking</td>\n<td>Closing delimiters</td>\n<td>Not followed by Unicode whitespace, not preceded by punctuation unless followed by whitespace/punctuation</td>\n<td><code>*emphasis*</code></td>\n<td><code>not emphasis *</code></td>\n</tr>\n<tr>\n<td>Intraword underscore</td>\n<td>Underscores only</td>\n<td>Cannot open/close if flanked by alphanumeric characters</td>\n<td><code>_start_</code></td>\n<td><code>snake_case</code></td>\n</tr>\n<tr>\n<td>Code span priority</td>\n<td>All delimiters</td>\n<td>Cannot open/close inside code spans</td>\n<td><code>`*literal*`</code></td>\n<td>N/A</td>\n</tr>\n</tbody></table>\n<h3 id=\"inline-parsing-common-pitfalls\">Inline Parsing Common Pitfalls</h3>\n<p>Inline parsing presents several challenging edge cases that frequently trip up implementers. Understanding these pitfalls helps avoid subtle bugs that can be difficult to debug.</p>\n<p>⚠️ <strong>Pitfall: Underscore Intraword Handling</strong></p>\n<p>Many implementations incorrectly handle underscores within words, either formatting when they shouldn&#39;t or failing to format when they should. The CommonMark specification has specific rules: underscores cannot open or close emphasis if they&#39;re flanked by alphanumeric characters.</p>\n<p>Consider <code>snake_case_variable</code> versus <code>_emphasis_word</code>. In the first case, both underscores are flanked by letters, so no emphasis should be applied. In the second case, the first underscore is preceded by whitespace (can open) and the second is followed by whitespace (can close), so emphasis should be applied.</p>\n<p>The fix requires implementing proper flanking detection that checks the Unicode character classes of adjacent characters, not just simple whitespace detection. The parser must examine the character before the underscore and after to determine if they&#39;re alphanumeric.</p>\n<p>⚠️ <strong>Pitfall: Delimiter Matching Precedence Errors</strong></p>\n<p>Implementers often use greedy matching that doesn&#39;t follow CommonMark precedence rules, leading to incorrect parsing of overlapping emphasis. For example, <code>***bold italic***</code> should parse as <code>&lt;strong&gt;&lt;em&gt;bold italic&lt;/em&gt;&lt;/strong&gt;</code> (double asterisk matched first, then single), not <code>&lt;em&gt;&lt;strong&gt;bold italic&lt;/strong&gt;&lt;/em&gt;</code>.</p>\n<p>The issue occurs when parsers match the first opening delimiter they find with the first closing delimiter, rather than applying proper precedence rules. The CommonMark algorithm specifically handles this by processing longer delimiter sequences first and implementing complex matching logic.</p>\n<p>The fix requires implementing the full CommonMark emphasis algorithm with proper precedence handling, not just simple stack matching.</p>\n<p>⚠️ <strong>Pitfall: Escape Sequence Processing Order</strong></p>\n<p>Processing escape sequences at the wrong time leads to either double-escaping or failure to escape properly. If escapes are processed during HTML generation, then <code>\\*</code> might be treated as a delimiter during parsing and incorrectly formatted.</p>\n<p>The correct approach processes escapes during the initial scanning phase, converting <code>\\*</code> to a literal asterisk before any delimiter detection occurs. This ensures that escaped characters are never considered as formatting markers.</p>\n<p>⚠️ <strong>Pitfall: Code Span Precedence Violations</strong></p>\n<p>Many parsers incorrectly process emphasis formatting inside code spans, violating the rule that code spans take precedence over all other inline formatting. Text like <code>`*literal asterisks*`</code> should render with literal asterisks, not emphasis.</p>\n<p>This happens when parsers don&#39;t implement proper two-phase processing or when they detect code spans incorrectly. The fix requires processing code spans first and marking their content as literal text that should be skipped during emphasis processing.</p>\n<p>⚠️ <strong>Pitfall: Link Parsing Bracket Matching</strong></p>\n<p>Link syntax parsing often fails on nested brackets or complex URLs. Text like <code>[link with [nested] brackets](URL)</code> requires careful bracket counting to determine where the link text ends and the URL begins.</p>\n<p>Simple regex patterns fail on this input because they can&#39;t handle the nested structure. The fix requires implementing proper bracket counting that tracks nesting depth and handles escape sequences within the link text.</p>\n<p>⚠️ <strong>Pitfall: Malformed Input Recovery</strong></p>\n<p>Many parsers fail catastrophically on malformed input like unmatched delimiters or incomplete link syntax. Input like <code>**unmatched emphasis</code> should render with literal asterisks, not cause a parser error.</p>\n<p>The correct approach implements graceful degradation where unmatched delimiters are left as literal text. This requires careful cleanup of the delimiter stack when processing completes, converting any unmatched delimiters back to literal characters.</p>\n<h4 id=\"delimiter-stack-state-management-issues\">Delimiter Stack State Management Issues</h4>\n<p>Several common issues arise from improper delimiter stack management:</p>\n<table>\n<thead>\n<tr>\n<th>Issue</th>\n<th>Symptom</th>\n<th>Cause</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Stack overflow on deeply nested input</td>\n<td>Parser crashes or hangs</td>\n<td>No depth limit on delimiter nesting</td>\n<td>Implement maximum nesting depth limit</td>\n</tr>\n<tr>\n<td>Memory leak on malformed input</td>\n<td>Memory usage grows unbounded</td>\n<td>Unmatched delimiters never removed from stack</td>\n<td>Clean up unmatched delimiters at text boundaries</td>\n</tr>\n<tr>\n<td>Incorrect precedence handling</td>\n<td>Wrong emphasis nesting in output</td>\n<td>Matching first available delimiter instead of highest precedence</td>\n<td>Implement proper precedence search in stack</td>\n</tr>\n<tr>\n<td>Performance degradation on long text</td>\n<td>Parsing becomes very slow</td>\n<td>O(n²) behavior from excessive stack scanning</td>\n<td>Optimize delimiter matching with better data structures</td>\n</tr>\n</tbody></table>\n<h4 id=\"context-detection-edge-cases\">Context Detection Edge Cases</h4>\n<p>Context-dependent parsing creates several edge cases that are easy to get wrong:</p>\n<table>\n<thead>\n<tr>\n<th>Input</th>\n<th>Expected Result</th>\n<th>Common Wrong Result</th>\n<th>Issue</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>a_b_c</code></td>\n<td><code>a_b_c</code> (no formatting)</td>\n<td><code>a&lt;em&gt;b&lt;/em&gt;c</code></td>\n<td>Intraword underscore rule not implemented</td>\n</tr>\n<tr>\n<td><code>_a_b_</code></td>\n<td><code>&lt;em&gt;a_b&lt;/em&gt;</code></td>\n<td><code>_a&lt;em&gt;b&lt;/em&gt;_</code></td>\n<td>First underscore not recognized as opener</td>\n</tr>\n<tr>\n<td><code>**a*b**</code></td>\n<td><code>&lt;strong&gt;a*b&lt;/strong&gt;</code></td>\n<td><code>**a&lt;em&gt;b&lt;/em&gt;*</code></td>\n<td>Inner asterisk shouldn&#39;t close outer emphasis</td>\n</tr>\n<tr>\n<td><code>*a**b*c**</code></td>\n<td><code>&lt;em&gt;a**b&lt;/em&gt;c**</code></td>\n<td>Various incorrect parsings</td>\n<td>Complex precedence interaction</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The inline parser implementation requires careful attention to character-level processing and state management. The following guidance provides both infrastructure components and core parsing logic to help implement a correct inline parser.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Regex Engine</td>\n<td>Built-in <code>re</code> module</td>\n<td>Third-party <code>regex</code> module with Unicode support</td>\n</tr>\n<tr>\n<td>Character Classification</td>\n<td>Manual ASCII checks</td>\n<td><code>unicodedata</code> module for proper Unicode handling</td>\n</tr>\n<tr>\n<td>Stack Implementation</td>\n<td>Python <code>list</code> with append/pop</td>\n<td>Custom stack class with additional metadata</td>\n</tr>\n<tr>\n<td>String Building</td>\n<td>String concatenation</td>\n<td><code>io.StringIO</code> for efficient building</td>\n</tr>\n<tr>\n<td>Delimiter Detection</td>\n<td>Character-by-character scanning</td>\n<td>Compiled regex patterns for common delimiters</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">markdown_parser</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  parsers</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inline_parser.py           ← main inline parsing logic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    delimiter_stack.py         ← delimiter stack implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inline_elements.py         ← specific element parsers (links, emphasis)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    escape_processor.py        ← escape sequence handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ast</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    inline_nodes.py           ← InlineNode </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> InlineType definitions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  utils</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    text_utils.py             ← character classification </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> flanking detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  tests</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    test_inline_parser.py     ← comprehensive inline parsing tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    test_emphasis_precedence.py ← specific emphasis precedence tests</span></span></code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete Delimiter Stack Implementation (delimiter_stack.py):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DelimiterType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ASTERISK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"asterisk\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UNDERSCORE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"underscore\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BACKTICK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"backtick\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LEFT_BRACKET</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"left_bracket\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    EXCLAMATION_BRACKET</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"exclamation_bracket\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> Delimiter</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    delimiter_type: DelimiterType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    char: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    position: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    length: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    can_open: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    can_close: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_active: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    original_length: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.original_length </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.original_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.length</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DelimiterStack</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.stack: List[Delimiter] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> push</span><span style=\"color:#E1E4E8\">(self, delimiter: Delimiter) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add a delimiter to the stack.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.stack.append(delimiter)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> find_matching_opener</span><span style=\"color:#E1E4E8\">(self, closer: Delimiter) -> Optional[Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Delimiter]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Find the most recent matching opener for the given closer.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.stack) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            opener </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.stack[i]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> (opener.is_active </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                opener.can_open </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                opener.delimiter_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> closer.delimiter_type </span><span style=\"color:#F97583\">and</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                opener.char </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> closer.char):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> i, opener</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> deactivate_between</span><span style=\"color:#E1E4E8\">(self, start_idx: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, end_idx: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Deactivate delimiters between two positions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(start_idx </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">, end_idx):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.stack):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.stack[i].is_active </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> clear_to_position</span><span style=\"color:#E1E4E8\">(self, position: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Remove delimiters up to a specific text position.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [d </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> d </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.stack </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> d.position </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> position]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_unmatched_delimiters</span><span style=\"color:#E1E4E8\">(self) -> List[Delimiter]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get all unmatched delimiters for literal text conversion.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> [d </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> d </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.stack </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> d.is_active]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> detect_flanking_properties</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, pos: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, delimiter_len: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Detect if delimiter can open/close based on flanking rules.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> unicodedata</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Get characters before and after delimiter</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    before_char </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text[pos </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> pos </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#F97583\"> else</span><span style=\"color:#9ECBFF\"> ' '</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    after_char </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text[pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> delimiter_len] </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> pos </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> delimiter_len </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(text) </span><span style=\"color:#F97583\">else</span><span style=\"color:#9ECBFF\"> ' '</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Unicode character classification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    before_whitespace </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> before_char.isspace()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    after_whitespace </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> after_char.isspace()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    before_punctuation </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> unicodedata.category(before_char).startswith(</span><span style=\"color:#9ECBFF\">'P'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    after_punctuation </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> unicodedata.category(after_char).startswith(</span><span style=\"color:#9ECBFF\">'P'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Left-flanking: not followed by whitespace, and either</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # not followed by punctuation or preceded by whitespace/punctuation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    left_flanking </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">not</span><span style=\"color:#E1E4E8\"> after_whitespace </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    (</span><span style=\"color:#F97583\">not</span><span style=\"color:#E1E4E8\"> after_punctuation </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> before_whitespace </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> before_punctuation))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Right-flanking: not preceded by whitespace, and either</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # not preceded by punctuation or followed by whitespace/punctuation  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    right_flanking </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">not</span><span style=\"color:#E1E4E8\"> before_whitespace </span><span style=\"color:#F97583\">and</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     (</span><span style=\"color:#F97583\">not</span><span style=\"color:#E1E4E8\"> before_punctuation </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> after_whitespace </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> after_punctuation))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> left_flanking, right_flanking</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> can_open_emphasis</span><span style=\"color:#E1E4E8\">(char: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, left_flanking: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">, right_flanking: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     before_char: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, after_char: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Determine if delimiter can open emphasis.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '*'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> left_flanking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '_'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> left_flanking </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">not</span><span style=\"color:#E1E4E8\"> right_flanking </span><span style=\"color:#F97583\">or</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> after_char.isalnum())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> can_close_emphasis</span><span style=\"color:#E1E4E8\">(char: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, left_flanking: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">, right_flanking: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                      before_char: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, after_char: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Determine if delimiter can close emphasis.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '*'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> right_flanking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '_'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> right_flanking </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">not</span><span style=\"color:#E1E4E8\"> left_flanking </span><span style=\"color:#F97583\">or</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> before_char.isalnum())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> False</span></span></code></pre></div>\n\n<p><strong>Complete Escape Processor (escape_processor.py):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Tuple</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Characters that can be escaped in CommonMark</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ESCAPABLE_CHARS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#DBEDFF\">!\"#</span><span style=\"color:#79B8FF\">$</span><span style=\"color:#DBEDFF\">%&#x26;</span><span style=\"color:#85E89D;font-weight:bold\">\\'</span><span style=\"color:#79B8FF\">()</span><span style=\"color:#F97583\">*+</span><span style=\"color:#DBEDFF\">,</span><span style=\"color:#85E89D;font-weight:bold\">\\-</span><span style=\"color:#79B8FF\">.</span><span style=\"color:#DBEDFF\">/:;&#x3C;=></span><span style=\"color:#F97583\">?</span><span style=\"color:#DBEDFF\">@</span><span style=\"color:#79B8FF\">[</span><span style=\"color:#85E89D;font-weight:bold\">\\\\\\]</span><span style=\"color:#79B8FF\">^_`{|}~</span><span style=\"color:#9ECBFF\">'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EscapeProcessor</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.escape_pattern </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#85E89D;font-weight:bold\">\\\\</span><span style=\"color:#79B8FF\">(.)</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_escapes</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Process escape sequences and return processed text with escape positions.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Tuple of (processed_text, list of positions that were escaped)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        escaped_positions </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(text):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> text[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\\\</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> and</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> &#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(text):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                next_char </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> text[i </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> next_char </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> ESCAPABLE_CHARS</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Valid escape sequence</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    result.append(next_char)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    escaped_positions.append(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(result) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Invalid escape, keep backslash</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    result.append(text[i])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                result.append(text[i])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                i </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> ''</span><span style=\"color:#E1E4E8\">.join(result), escaped_positions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_escaped</span><span style=\"color:#E1E4E8\">(self, position: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, escaped_positions: List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if a character at given position was escaped.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> position </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> escaped_positions</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Main Inline Parser (inline_parser.py):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .delimiter_stack </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> DelimiterStack, Delimiter, DelimiterType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .escape_processor </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> EscapeProcessor</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..ast.inline_nodes </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> InlineNode, InlineType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..ast.ast_nodes </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ASTNode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InlineParser</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.delimiter_stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DelimiterStack()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.escape_processor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> EscapeProcessor()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_inline_elements</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[InlineNode]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Main entry point for parsing inline elements from text.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns list of InlineNode objects representing the parsed content.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Process escape sequences first to handle \\* and other escapes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: First pass - process code spans (highest precedence)  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Second pass - process links and images</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Third pass - process emphasis (asterisks and underscores)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Convert any remaining text to text nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return list of inline nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _process_code_spans</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, escaped_positions: List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]) -> List[InlineNode]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Process inline code spans delimited by backticks.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Code spans have highest precedence and mask their content.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Scan for backtick sequences, ignoring escaped backticks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Match opening and closing backtick sequences of same length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Extract code content and normalize whitespace per CommonMark rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create InlineNode with InlineType.CODE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Mark code span regions as processed for subsequent passes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _process_emphasis</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, escaped_positions: List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                         processed_regions: List[Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]]) -> List[InlineNode]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Process emphasis (bold and italic) using delimiter matching algorithm.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.delimiter_stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> DelimiterStack()  </span><span style=\"color:#6A737D\"># Reset for each text segment</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Scan character by character for emphasis delimiters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each potential delimiter, check flanking properties</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Push valid opening delimiters onto stack</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For closing delimiters, find matching opener with precedence rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create InlineNode for matched delimiter pairs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle unmatched delimiters as literal text</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Recursively process content within emphasis nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _scan_emphasis_delimiters</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, pos: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Optional[Delimiter]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Scan for emphasis delimiters at current position.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns Delimiter object if valid delimiter found, None otherwise.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check for asterisk or underscore at current position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Count consecutive delimiter characters (*, **, ***, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Determine flanking properties using detect_flanking_properties</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Apply emphasis opening/closing rules based on delimiter type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return Delimiter object with all properties set</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _process_links_and_images</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, escaped_positions: List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                 processed_regions: List[Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]]) -> List[InlineNode]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Process link and image syntax: [text](url) and ![alt](url)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Scan for opening brackets [ and image syntax ![</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle nested brackets in link text by counting bracket depth</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Look for closing bracket followed by opening parenthesis</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Parse URL and optional title in parentheses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create InlineNode with InlineType.LINK or InlineType.IMAGE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Recursively process inline formatting in link text</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Handle malformed links as literal text</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _match_emphasis_delimiters</span><span style=\"color:#E1E4E8\">(self, closer: Delimiter) -> Optional[Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, Delimiter]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Find matching opener for emphasis closer using CommonMark precedence.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Search delimiter stack backward for matching opener</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Apply precedence rules - longer sequences first</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check delimiter type compatibility (asterisk vs underscore)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Ensure opener can open and closer can close</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return stack index and opener delimiter if found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _create_emphasis_node</span><span style=\"color:#E1E4E8\">(self, opener: Delimiter, closer: Delimiter, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            inner_content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> InlineNode:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create emphasis node based on delimiter length and type.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Determine emphasis type based on delimiter length (1=em, 2=strong)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create InlineNode with appropriate InlineType</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Recursively parse inner content for nested formatting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Set text_content and formatting_attributes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return completed InlineNode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Link and Image Parser (inline_elements.py):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Tuple, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..ast.inline_nodes </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> InlineNode, InlineType</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LinkImageParser</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Regex patterns for URL and title parsing</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.url_pattern </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">^[</span><span style=\"color:#F97583\">^</span><span style=\"color:#79B8FF\">\\s&#x3C;>]</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">(?:\\s</span><span style=\"color:#F97583\">+</span><span style=\"color:#DBEDFF\">\"</span><span style=\"color:#79B8FF\">[</span><span style=\"color:#F97583\">^</span><span style=\"color:#79B8FF\">\"]</span><span style=\"color:#F97583\">*</span><span style=\"color:#DBEDFF\">\"</span><span style=\"color:#79B8FF\">)</span><span style=\"color:#F97583\">?</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.title_pattern </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\s</span><span style=\"color:#F97583\">+</span><span style=\"color:#DBEDFF\">\"</span><span style=\"color:#79B8FF\">([</span><span style=\"color:#F97583\">^</span><span style=\"color:#79B8FF\">\"]</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">)</span><span style=\"color:#DBEDFF\">\"</span><span style=\"color:#79B8FF\">$</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_link_or_image</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, start_pos: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           is_image: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">) -> Optional[Tuple[InlineNode, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Parse link or image syntax starting at given position.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Tuple of (InlineNode, end_position) if successful, None if malformed</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Skip opening marker ([ or ![) and find link text</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle nested brackets in link text with bracket counting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify closing bracket followed by opening parenthesis</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Parse URL and optional title from parentheses</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create InlineNode with InlineType.LINK or InlineType.IMAGE</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return node and position after closing parenthesis</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _find_link_text_end</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, start_pos: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Find the end of link text, handling nested brackets.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Track bracket nesting depth starting from 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Scan character by character, ignoring escaped brackets</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Increment depth on '[', decrement on ']'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return position when depth reaches 0</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return None if no matching bracket found</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _parse_url_and_title</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Parse URL and optional title from parentheses content.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Apply regex to extract URL portion</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check for optional title in quotes after URL</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle angle-bracket enclosed URLs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return tuple of (url, title) where title may be None</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After completing emphasis parsing:</strong></p>\n<ul>\n<li>Test command: <code>python -m pytest tests/test_inline_parser.py::test_emphasis -v</code></li>\n<li>Expected behavior: <code>**bold**</code> becomes <code>&lt;strong&gt;bold&lt;/strong&gt;</code>, <code>*italic*</code> becomes <code>&lt;em&gt;italic&lt;/em&gt;</code></li>\n<li>Manual verification: Create test file with <code>**bold *nested* text**</code> and verify nested structure</li>\n<li>Debug check: Print delimiter stack contents to verify proper delimiter matching</li>\n</ul>\n<p><strong>After completing link parsing:</strong>  </p>\n<ul>\n<li>Test command: <code>python -m pytest tests/test_inline_parser.py::test_links -v</code></li>\n<li>Expected behavior: <code>[text](url)</code> becomes <code>&lt;a href=&quot;url&quot;&gt;text&lt;/a&gt;</code></li>\n<li>Manual verification: Test nested brackets <code>[link [with] brackets](url)</code> parses correctly</li>\n<li>Debug check: Verify bracket counting logic handles nested cases</li>\n</ul>\n<p><strong>After completing code spans:</strong></p>\n<ul>\n<li>Test command: <code>python -m pytest tests/test_inline_parser.py::test_code_spans -v</code>  </li>\n<li>Expected behavior: <code>`code`</code> becomes <code>&lt;code&gt;code&lt;/code&gt;</code>, content is literal</li>\n<li>Manual verification: <code>`*not emphasis*`</code> should not format the asterisks</li>\n<li>Debug check: Confirm code spans are processed before emphasis in pipeline</li>\n</ul>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Emphasis not nested correctly</td>\n<td>Wrong delimiter precedence</td>\n<td>Print delimiter stack during matching</td>\n<td>Implement proper precedence rules in <code>_match_emphasis_delimiters</code></td>\n</tr>\n<tr>\n<td>Underscores in words get formatted</td>\n<td>Missing intraword underscore check</td>\n<td>Test with <code>snake_case</code> input</td>\n<td>Add alphanumeric flanking check to <code>can_open_emphasis</code></td>\n</tr>\n<tr>\n<td>Links with brackets don&#39;t parse</td>\n<td>Bracket counting bug</td>\n<td>Log bracket depth during parsing</td>\n<td>Fix bracket nesting logic in <code>_find_link_text_end</code></td>\n</tr>\n<tr>\n<td>Code spans don&#39;t mask emphasis</td>\n<td>Processing order wrong</td>\n<td>Check if code spans processed first</td>\n<td>Move code span processing to first pass</td>\n</tr>\n<tr>\n<td>Escaped characters still format</td>\n<td>Escape processing timing</td>\n<td>Verify escaped positions list</td>\n<td>Process escapes before delimiter detection</td>\n</tr>\n<tr>\n<td>Memory usage grows on long text</td>\n<td>Delimiter stack not cleaned</td>\n<td>Monitor stack size during parsing</td>\n<td>Clear stack between text segments</td>\n</tr>\n</tbody></table>\n<h2 id=\"list-parser-design\">List Parser Design</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3: Lists</p>\n</blockquote>\n<h3 id=\"the-document-hierarchy-mental-model\">The Document Hierarchy Mental Model</h3>\n<p>Think of list parsing like organizing a company&#39;s org chart from a messy pile of business cards. Each business card has a person&#39;s name and shows their reporting level through indentation - the CEO has no indentation, VPs have one level, directors have two levels, and so on. Your job is to reconstruct the proper hierarchical tree structure by carefully tracking indentation levels and understanding who reports to whom.</p>\n<p>Just like how a person can&#39;t report to someone at a lower level in the hierarchy, markdown list items follow strict nesting rules based on indentation. A list item indented 4 spaces can only be a child of an item indented 0-3 spaces, never a sibling or parent. The challenge is that unlike a clean org chart, the &quot;business cards&quot; (markdown lines) arrive in sequential order, and you must build the hierarchy incrementally while handling edge cases like missing intermediate levels or inconsistent indentation.</p>\n<p>The fundamental insight is that <strong>list parsing is inherently recursive and stateful</strong> - each list item&#39;s position in the hierarchy depends not just on its own indentation, but on the context of all previous items and the current nesting stack. This requires maintaining a sophisticated understanding of the document&#39;s hierarchical state as parsing progresses.</p>\n<h3 id=\"list-parsing-algorithm\">List Parsing Algorithm</h3>\n<p>The list parsing algorithm operates as a <strong>stateful hierarchy builder</strong> that maintains a stack of active list contexts while processing lines sequentially. The core challenge is correctly interpreting indentation levels and determining when to create new nested lists versus continuing existing ones.</p>\n<p><img src=\"/api/project/markdown-renderer/architecture-doc/asset?path=diagrams%2Flist-nesting-structure.svg\" alt=\"List Nesting and Indentation Handling\"></p>\n<h4 id=\"phase-1-list-item-detection-and-classification\">Phase 1: List Item Detection and Classification</h4>\n<p>The algorithm begins by identifying potential list items through marker detection. This phase involves examining each line to determine if it represents a list item and, if so, what type of list it belongs to.</p>\n<ol>\n<li><p><strong>Line Analysis</strong>: Extract the line&#39;s leading whitespace to calculate the base indentation level using <code>get_indentation_level()</code>. Remove leading whitespace to examine the content that follows.</p>\n</li>\n<li><p><strong>Marker Detection</strong>: Check if the line begins with a valid list marker. For unordered lists, look for dash (<code>-</code>), asterisk (<code>*</code>), or plus (<code>+</code>) followed by at least one space. For ordered lists, look for a sequence of 1-9 digits followed by either a period (<code>.</code>) or closing parenthesis (<code>)</code>) and at least one space.</p>\n</li>\n<li><p><strong>Marker Validation</strong>: Verify that the marker is properly formatted. The marker must be followed by at least one space or tab, or be at the end of the line (creating an empty list item). Calculate the marker&#39;s consumed width to determine the content indentation.</p>\n</li>\n<li><p><strong>Content Indentation Calculation</strong>: Determine the indentation level for list item content by adding the base indentation to the marker width plus following spaces. This becomes the reference indentation for continuation lines.</p>\n</li>\n<li><p><strong>List Type Determination</strong>: Based on the marker type, classify the item as either ordered or unordered. For ordered lists, extract the starting number, though CommonMark specifies that the actual numbering in output starts from the first item&#39;s number.</p>\n</li>\n</ol>\n<h4 id=\"phase-2-hierarchy-management-and-nesting\">Phase 2: Hierarchy Management and Nesting</h4>\n<p>Once a list item is detected, the algorithm must determine its position in the document hierarchy and manage the nesting stack appropriately.</p>\n<ol>\n<li><p><strong>Context Stack Evaluation</strong>: Compare the current item&#39;s indentation with the indentation levels stored in the active context stack. The context stack maintains information about currently open lists and their indentation levels.</p>\n</li>\n<li><p><strong>Stack Unwinding</strong>: If the current item&#39;s indentation is less than or equal to any level in the stack, unwind the stack by finalizing and closing list contexts until reaching an appropriate parent level. This handles cases where the nesting level decreases.</p>\n</li>\n<li><p><strong>Sibling vs Child Determination</strong>: If the indentation matches an existing level in the stack, create a sibling item at that level. If the indentation is greater than all existing levels but within valid nesting bounds, create a new child list.</p>\n</li>\n<li><p><strong>New List Creation</strong>: When starting a new nested level, create a new <code>BlockNode</code> with <code>block_type</code> set to <code>LIST</code>. Set the list type attribute (ordered/unordered) and add it as a child to the current list item. Push this new context onto the stack.</p>\n</li>\n<li><p><strong>List Item Creation</strong>: Create a <code>BlockNode</code> with <code>block_type</code> set to <code>LIST_ITEM</code>. Set the raw content as the text following the marker. Add this item to the current list context and mark it as the active item for potential continuation lines.</p>\n</li>\n</ol>\n<h4 id=\"phase-3-content-processing-and-continuation\">Phase 3: Content Processing and Continuation</h4>\n<p>List items can contain multiple lines of content, including nested paragraphs, code blocks, and other structural elements. The algorithm must handle these continuation patterns correctly.</p>\n<ol>\n<li><p><strong>Continuation Line Detection</strong>: For each subsequent line, determine if it continues the current list item, starts a new list item, or terminates the list structure. This requires checking indentation against the current list item&#39;s content indentation level.</p>\n</li>\n<li><p><strong>Content Type Classification</strong>: Continuation lines may be simple paragraph text, blank lines (which affect tight vs loose list determination), or the beginning of nested block elements like code blocks or nested lists.</p>\n</li>\n<li><p><strong>Lazy Continuation Handling</strong>: CommonMark allows &quot;lazy continuation&quot; where continuation lines may have less indentation than required, as long as they don&#39;t start a new block element. Implement this by checking if under-indented lines could plausibly continue the current list item.</p>\n</li>\n<li><p><strong>Nested Block Processing</strong>: When continuation lines indicate nested block elements (like indented code blocks or nested blockquotes), delegate parsing to the appropriate block parser while maintaining the list context.</p>\n</li>\n<li><p><strong>Tight vs Loose List Determination</strong>: Track whether blank lines appear between list items or within list items. Lists containing blank lines become &quot;loose&quot; lists, which affects HTML output (loose lists wrap content in paragraph tags).</p>\n</li>\n</ol>\n<h3 id=\"list-parser-architecture-decisions\">List Parser Architecture Decisions</h3>\n<p>The list parser&#39;s design involves several critical architectural decisions that affect both correctness and implementation complexity. Each decision involves trade-offs between parsing accuracy, implementation simplicity, and performance.</p>\n<blockquote>\n<p><strong>Decision: Indentation Tracking Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: List nesting requires precise indentation tracking, but markdown allows various indentation styles and lazy continuation. The parser needs to handle both strict CommonMark compliance and graceful degradation for malformed input.</li>\n<li><strong>Options Considered</strong>: Character-level position tracking, space-count normalization, tab-expansion with configurable width</li>\n<li><strong>Decision</strong>: Normalize tabs to spaces using 4-space tab stops, then track indentation as space counts with a tolerance mechanism for minor variations</li>\n<li><strong>Rationale</strong>: Tab normalization eliminates ambiguity in mixed-indentation documents. Space counting provides precise nesting level determination. Tolerance allows graceful handling of minor indentation inconsistencies common in hand-written markdown.</li>\n<li><strong>Consequences</strong>: Enables reliable nesting detection and CommonMark compliance. Requires upfront tab normalization. May mask some user errors that strict parsers would reject.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Indentation Strategy</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Character Position Tracking</td>\n<td>Exact position preservation, handles mixed tabs/spaces</td>\n<td>Complex logic, fragile with copy/paste</td>\n</tr>\n<tr>\n<td>Space Count Normalization</td>\n<td>Simple integer arithmetic, robust</td>\n<td>Loses original formatting intent</td>\n</tr>\n<tr>\n<td>Tab Expansion + Space Count</td>\n<td>CommonMark compliant, predictable</td>\n<td>Requires configuration, upfront processing</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: List Context Stack Management</strong></p>\n<ul>\n<li><strong>Context</strong>: Nested lists require maintaining multiple active contexts simultaneously. The parser must track which lists are open, their types, indentation levels, and current state for proper nesting and termination.</li>\n<li><strong>Options Considered</strong>: Recursive descent parsing, explicit context stack, state machine with embedded stack</li>\n<li><strong>Decision</strong>: Explicit context stack with list metadata including indentation level, list type, tight/loose status, and parent references</li>\n<li><strong>Rationale</strong>: Explicit stack provides clear visibility into nesting state for debugging. Metadata tracking enables correct CommonMark compliance for tight/loose lists. Parent references enable proper AST construction.</li>\n<li><strong>Consequences</strong>: Simplifies nesting logic and makes state transitions explicit. Requires careful stack management and cleanup. Enables comprehensive error reporting with context.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Context Management</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Recursive Descent</td>\n<td>Natural nesting representation, clean code</td>\n<td>Stack overflow risk, complex backtracking</td>\n</tr>\n<tr>\n<td>Explicit Context Stack</td>\n<td>Clear state visibility, controlled memory usage</td>\n<td>Manual stack management, more bookkeeping</td>\n</tr>\n<tr>\n<td>State Machine + Stack</td>\n<td>Systematic state handling, good error recovery</td>\n<td>Complex state explosion, harder to debug</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Tight vs Loose List Handling</strong></p>\n<ul>\n<li><strong>Context</strong>: CommonMark distinguishes between tight lists (no blank lines) and loose lists (containing blank lines), which affects HTML output. Tight lists don&#39;t wrap content in paragraph tags, while loose lists do.</li>\n<li><strong>Options Considered</strong>: Post-processing analysis, incremental tracking during parsing, defer decision to HTML generator</li>\n<li><strong>Decision</strong>: Incremental tracking during parsing with list-level and item-level blank line flags stored in block attributes</li>\n<li><strong>Rationale</strong>: Incremental tracking avoids expensive post-processing passes. List-level flags enable correct handling of mixed scenarios. Early determination enables better error messages and debugging.</li>\n<li><strong>Consequences</strong>: Enables correct CommonMark-compliant output generation. Requires careful blank line tracking. Complicates list item processing logic slightly.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Tight/Loose Strategy</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Post-processing Analysis</td>\n<td>Clean separation of concerns, simple parsing</td>\n<td>Extra traversal pass, complex analysis logic</td>\n</tr>\n<tr>\n<td>Incremental Tracking</td>\n<td>Single-pass efficiency, immediate feedback</td>\n<td>Distributed logic, more state tracking</td>\n</tr>\n<tr>\n<td>HTML Generator Decision</td>\n<td>Deferred complexity, flexible output control</td>\n<td>Generator complexity, limited error reporting</td>\n</tr>\n</tbody></table>\n<h4 id=\"list-type-consistency-and-mixed-lists\">List Type Consistency and Mixed Lists</h4>\n<p>The parser must handle scenarios where list markers change within what appears to be a single list. CommonMark specifies that different marker types or ordered/unordered mixing creates separate lists.</p>\n<blockquote>\n<p><strong>Decision: Mixed List Marker Handling</strong></p>\n<ul>\n<li><strong>Context</strong>: Users sometimes mix different list markers (<code>-</code>, <code>*</code>, <code>+</code>) or combine ordered and unordered items, expecting them to be part of the same list. CommonMark treats different markers as separate lists.</li>\n<li><strong>Options Considered</strong>: Strict CommonMark compliance (separate lists), marker normalization (treat all as same), user configuration option</li>\n<li><strong>Decision</strong>: Strict CommonMark compliance with clear error reporting when marker types change</li>\n<li><strong>Rationale</strong>: Ensures predictable output consistent with other CommonMark parsers. Encourages consistent markdown authoring. Avoids ambiguity in complex nested scenarios.</li>\n<li><strong>Consequences</strong>: May surprise users expecting mixed markers to work. Enables reliable round-trip parsing. Simplifies nesting logic significantly.</li>\n</ul>\n</blockquote>\n<h4 id=\"continuation-line-processing-strategy\">Continuation Line Processing Strategy</h4>\n<p>List items can contain multiple paragraphs, code blocks, and other complex content. The parser must distinguish between content that belongs to the current list item versus content that terminates the list.</p>\n<blockquote>\n<p><strong>Decision: Continuation Line Classification</strong></p>\n<ul>\n<li><strong>Context</strong>: Lines following list items may be continuation content, lazy continuation (under-indented but still belonging to the item), new list items, or content that terminates the list entirely.</li>\n<li><strong>Options Considered</strong>: Strict indentation matching, lazy continuation support, lookahead-based classification</li>\n<li><strong>Decision</strong>: Support lazy continuation with lookahead to distinguish from new block elements, using content indentation thresholds</li>\n<li><strong>Rationale</strong>: Lazy continuation is part of CommonMark spec and matches user expectations. Lookahead prevents false positives where under-indented lines start new blocks. Thresholds provide clear rules for classification.</li>\n<li><strong>Consequences</strong>: Enables natural authoring patterns users expect. Requires more complex line classification logic. May accept some ambiguous input that strict parsers reject.</li>\n</ul>\n</blockquote>\n<h3 id=\"list-parsing-common-pitfalls\">List Parsing Common Pitfalls</h3>\n<p>List parsing involves several subtle edge cases that frequently cause implementation errors. Understanding these pitfalls helps build robust parsers that handle real-world markdown correctly.</p>\n<p>⚠️ <strong>Pitfall: Incorrect Indentation Calculation</strong></p>\n<p>Many implementations incorrectly calculate the indentation required for list item continuation by only considering the marker width, ignoring the base indentation of the list item itself. This leads to incorrect nesting decisions and malformed output.</p>\n<p>For example, consider this markdown:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">markdown</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#FFAB70\">  -</span><span style=\"color:#E1E4E8\"> Item with base indentation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    Continuation line</span></span></code></pre></div>\n\n<p>The continuation line requires 4 spaces total: 2 for the base indentation plus 2 for the marker and space. Implementations that only check for 2 spaces of indentation will incorrectly treat the continuation as a new paragraph outside the list.</p>\n<p><strong>Fix</strong>: Always calculate continuation indentation as <code>base_indentation + marker_width + min_space_requirement</code>. Store this value when creating each list item and use it consistently for all continuation line checks.</p>\n<p>⚠️ <strong>Pitfall: Mixed List Type Confusion</strong></p>\n<p>Implementations often incorrectly handle scenarios where ordered and unordered list markers appear at the same indentation level, either by treating them as the same list or by not properly closing the previous list before starting the new one.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">markdown</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#FFAB70\">1.</span><span style=\"color:#E1E4E8\"> First ordered item</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">-</span><span style=\"color:#E1E4E8\"> First unordered item</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">2.</span><span style=\"color:#E1E4E8\"> Second ordered item?</span></span></code></pre></div>\n\n<p>The unordered item should start a new list, and the final line should start yet another ordered list, not continue the first one.</p>\n<p><strong>Fix</strong>: Track the list type (ordered/unordered) and marker style for each list context. When a different type or marker style is encountered at the same indentation level, finalize the current list and start a new one. Store list type in the context stack along with indentation information.</p>\n<p>⚠️ <strong>Pitfall: Loose List Detection Errors</strong></p>\n<p>Incorrect handling of blank lines leads to wrong tight/loose list classification, causing HTML output that doesn&#39;t match CommonMark specification. The most common error is not distinguishing between blank lines that separate list items versus blank lines within list items.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">markdown</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#FFAB70\">1.</span><span style=\"color:#E1E4E8\"> First item</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">2.</span><span style=\"color:#E1E4E8\"> Second item</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   With continuation paragraph</span></span></code></pre></div>\n\n<p>This should be a loose list because of the blank line between items, and the continuation paragraph should be wrapped in <code>&lt;p&gt;</code> tags.</p>\n<p><strong>Fix</strong>: Track blank lines at both the list level and item level. Set the loose flag when blank lines appear between list items or when any individual item contains blank lines. Propagate loose status to parent lists when nested loose lists are encountered.</p>\n<p>⚠️ <strong>Pitfall: Lazy Continuation Boundary Errors</strong></p>\n<p>Implementations often incorrectly handle lazy continuation by either being too permissive (allowing continuation that should start new blocks) or too restrictive (requiring strict indentation that CommonMark doesn&#39;t mandate).</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">markdown</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#FFAB70\">-</span><span style=\"color:#E1E4E8\"> List item</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">This should continue the item</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  -</span><span style=\"color:#E1E4E8\"> But this starts a nested list</span></span></code></pre></div>\n\n<p>The middle line is lazy continuation, but the final line starts a nested list despite being more indented than the continuation.</p>\n<p><strong>Fix</strong>: Implement lookahead to check if under-indented lines could start new block elements. Use the <code>can_current_block_continue()</code> method to test if a line belongs to the current list item before accepting it as lazy continuation.</p>\n<p>⚠️ <strong>Pitfall: Nested List Context Cleanup</strong></p>\n<p>Failing to properly clean up list contexts when nesting levels decrease leads to memory leaks and incorrect parent-child relationships in the AST. This often manifests as lists that never properly close or items that appear in the wrong parent list.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">markdown</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#FFAB70\">-</span><span style=\"color:#E1E4E8\"> Level 1</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">  -</span><span style=\"color:#E1E4E8\"> Level 2</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">    -</span><span style=\"color:#E1E4E8\"> Level 3</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">-</span><span style=\"color:#E1E4E8\"> Back to level 1</span></span></code></pre></div>\n\n<p>The final item should close all nested contexts and return to the top level.</p>\n<p><strong>Fix</strong>: Implement proper stack unwinding when indentation decreases. Use the <code>finalize_current_block()</code> method to close contexts and ensure proper parent-child relationships. Maintain parent references to enable correct AST construction.</p>\n<p>⚠️ <strong>Pitfall: Empty List Item Handling</strong></p>\n<p>Empty list items (markers followed by blank lines or end of input) often break parsing logic that assumes list items always have content. This leads to null pointer exceptions or malformed AST nodes.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">markdown</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#FFAB70\">-</span><span style=\"color:#E1E4E8\"> First item</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">-</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">-</span><span style=\"color:#E1E4E8\"> Third item</span></span></code></pre></div>\n\n<p>The middle item is empty but valid according to CommonMark.</p>\n<p><strong>Fix</strong>: Create list item nodes even for empty items, using empty string content. Handle empty content gracefully in continuation processing and HTML generation. Set appropriate attributes to distinguish truly empty items from items with whitespace-only content.</p>\n<p>⚠️ <strong>Pitfall: Ordered List Starting Number Confusion</strong></p>\n<p>Many implementations either ignore ordered list starting numbers entirely or incorrectly propagate them to nested lists. CommonMark specifies that ordered lists should start from the number specified in the first item, but nested lists always start from 1.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">markdown</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#FFAB70\">3.</span><span style=\"color:#E1E4E8\"> Starting from three</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">4.</span><span style=\"color:#E1E4E8\"> Next item</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">   1.</span><span style=\"color:#E1E4E8\"> Nested starts from one</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">   2.</span><span style=\"color:#E1E4E8\"> Continues normally</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">5.</span><span style=\"color:#E1E4E8\"> Back to main sequence</span></span></code></pre></div>\n\n<p><strong>Fix</strong>: Store the starting number from the first item in each ordered list context using <code>set_attribute(&#39;start_number&#39;, num)</code>. Reset to 1 for nested ordered lists. Pass starting numbers to the HTML generator for proper <code>&lt;ol start=&quot;3&quot;&gt;</code> attribute generation.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The list parser implementation requires careful coordination between indentation tracking, context management, and content processing. The following guidance provides practical patterns and utilities for building a robust list parser.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Indentation Tracking</td>\n<td>String splitting + len() counting</td>\n<td>Regular expressions with capture groups</td>\n</tr>\n<tr>\n<td>Context Stack</td>\n<td>Python list with dict contexts</td>\n<td>Custom ListContext class with methods</td>\n</tr>\n<tr>\n<td>Marker Detection</td>\n<td>String startswith() + manual parsing</td>\n<td>Compiled regex patterns with named groups</td>\n</tr>\n<tr>\n<td>Content Processing</td>\n<td>Line-by-line state machine</td>\n<td>Recursive descent with backtracking</td>\n</tr>\n<tr>\n<td>Tight/Loose Tracking</td>\n<td>Boolean flags in context dict</td>\n<td>Enumerated state with validation rules</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  src/\n    markdown_parser/\n      __init__.py                ← main parser interface\n      preprocessor.py            ← line normalization and analysis\n      block_parser/\n        __init__.py             ← block parser interface\n        block_parser.py         ← main block parsing logic\n        list_parser.py          ← list-specific parsing logic (this component)\n        list_context.py         ← list context stack management\n        list_utils.py           ← indentation and marker utilities\n      ast_nodes.py              ← AST node definitions\n      common/\n        line_info.py            ← LineInfo and related utilities\n        patterns.py             ← regex patterns and constants</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code-complete-and-ready-to-use\">Infrastructure Starter Code (Complete and Ready to Use)</h4>\n<p><strong>list_utils.py</strong> - Indentation and marker detection utilities:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Tuple, NamedTuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MarkerType</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UNORDERED_DASH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"-\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UNORDERED_ASTERISK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"*\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UNORDERED_PLUS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"+\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ORDERED_PERIOD</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \".\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ORDERED_PAREN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \")\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ListMarkerInfo</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">NamedTuple</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    marker_type: MarkerType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_ordered: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    marker_width: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    content_indent: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start_number: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Regex patterns for list marker detection</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">UNORDERED_MARKER_PATTERN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">^(</span><span style=\"color:#F97583\"> {0,3}</span><span style=\"color:#79B8FF\">)([-*+])(</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\">)</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ORDERED_MARKER_PATTERN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">^(</span><span style=\"color:#F97583\"> {0,3}</span><span style=\"color:#79B8FF\">)([1-9][0-9]</span><span style=\"color:#F97583\">{0,8}</span><span style=\"color:#79B8FF\">)([.)])(</span><span style=\"color:#F97583\"> +</span><span style=\"color:#79B8FF\">)</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> normalize_line_endings</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convert all line endings to Unix format.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> text.replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">).replace(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> expand_tabs_to_spaces</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, tab_width: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Expand tabs to spaces using specified tab width.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    column </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> text:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            spaces_to_add </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tab_width </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> (column </span><span style=\"color:#F97583\">%</span><span style=\"color:#E1E4E8\"> tab_width)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result.append(</span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> spaces_to_add)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            column </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> spaces_to_add</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result.append(char)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                column </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                column </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#9ECBFF\"> ''</span><span style=\"color:#E1E4E8\">.join(result)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> get_indentation_level</span><span style=\"color:#E1E4E8\">(line: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Count leading spaces in a line.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> line:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> char </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> ' '</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            break</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> count</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> detect_list_marker</span><span style=\"color:#E1E4E8\">(line: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[ListMarkerInfo]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Detect and parse list marker information from a line.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Try unordered markers first</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    match </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> UNORDERED_MARKER_PATTERN</span><span style=\"color:#E1E4E8\">.match(line)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> match:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        base_indent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(match.group(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        marker_char </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> match.group(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        spaces_after </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(match.group(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        marker_type_map </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            '-'</span><span style=\"color:#E1E4E8\">: MarkerType.</span><span style=\"color:#79B8FF\">UNORDERED_DASH</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            '*'</span><span style=\"color:#E1E4E8\">: MarkerType.</span><span style=\"color:#79B8FF\">UNORDERED_ASTERISK</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            '+'</span><span style=\"color:#E1E4E8\">: MarkerType.</span><span style=\"color:#79B8FF\">UNORDERED_PLUS</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        marker_width </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> spaces_after</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        content_indent </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> base_indent </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> marker_width</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ListMarkerInfo(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            marker_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">marker_type_map[marker_char],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            is_ordered</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            marker_width</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">marker_width,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            content_indent</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">content_indent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Try ordered markers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    match </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> ORDERED_MARKER_PATTERN</span><span style=\"color:#E1E4E8\">.match(line)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> match:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        base_indent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(match.group(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        number_str </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> match.group(</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        delimiter </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> match.group(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        spaces_after </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(match.group(</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        marker_type </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> MarkerType.</span><span style=\"color:#79B8FF\">ORDERED_PERIOD</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> delimiter </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '.'</span><span style=\"color:#F97583\"> else</span><span style=\"color:#E1E4E8\"> MarkerType.</span><span style=\"color:#79B8FF\">ORDERED_PAREN</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        marker_width </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(number_str) </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> +</span><span style=\"color:#E1E4E8\"> spaces_after</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        content_indent </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> base_indent </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> marker_width</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ListMarkerInfo(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            marker_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">marker_type,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            is_ordered</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            marker_width</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">marker_width,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            content_indent</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">content_indent,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            start_number</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">(number_str)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> is_blank_line</span><span style=\"color:#E1E4E8\">(line: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if line contains only whitespace.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(line.strip()) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> can_lazy_continue</span><span style=\"color:#E1E4E8\">(line: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, required_indent: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Check if a line can be lazy continuation of a list item.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> is_blank_line(line):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    actual_indent </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> get_indentation_level(line)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Allow lazy continuation if not starting a new block element</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> actual_indent </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> required_indent:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check if line could start a new list item</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> detect_list_marker(line) </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check for other block elements (simplified check)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stripped </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> line.lstrip()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (stripped.startswith(</span><span style=\"color:#9ECBFF\">'#'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            stripped.startswith(</span><span style=\"color:#9ECBFF\">'>'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            stripped.startswith(</span><span style=\"color:#9ECBFF\">'```'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">or</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            stripped.startswith(</span><span style=\"color:#9ECBFF\">'---'</span><span style=\"color:#E1E4E8\">)):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> True</span></span></code></pre></div>\n\n<p><strong>list_context.py</strong> - Context stack management:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..ast_nodes </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ASTNode, BlockNode, BlockType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .list_utils </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> MarkerType</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ListState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TIGHT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"tight\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LOOSE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"loose\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UNDETERMINED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"undetermined\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ListContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Context information for an active list.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    list_node: BlockNode</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    marker_type: MarkerType</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    base_indentation: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    content_indentation: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_ordered: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state: ListState </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ListState.</span><span style=\"color:#79B8FF\">UNDETERMINED</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    start_number: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    item_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_item: Optional[BlockNode] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    has_blank_lines: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_item</span><span style=\"color:#E1E4E8\">(self, item_node: BlockNode) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add a new list item to this list.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.list_node.add_child(item_node)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_item </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> item_node</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.item_count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> mark_loose</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Mark this list as loose (containing blank lines).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ListState.</span><span style=\"color:#79B8FF\">LOOSE</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.list_node.set_attribute(</span><span style=\"color:#9ECBFF\">'tight'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> finalize</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Finalize list state when parsing is complete.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ListState.</span><span style=\"color:#79B8FF\">UNDETERMINED</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ListState.</span><span style=\"color:#79B8FF\">TIGHT</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.list_node.set_attribute(</span><span style=\"color:#9ECBFF\">'tight'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.is_ordered </span><span style=\"color:#F97583\">and</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.start_number </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.list_node.set_attribute(</span><span style=\"color:#9ECBFF\">'start'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.start_number)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ListContextStack</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages the stack of active list contexts.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.contexts: List[ListContext] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> current_context</span><span style=\"color:#E1E4E8\">(self) -> Optional[ListContext]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get the current (top) list context.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.contexts[</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.contexts </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> push_context</span><span style=\"color:#E1E4E8\">(self, context: ListContext) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Push a new list context onto the stack.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.contexts.append(context)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> pop_context</span><span style=\"color:#E1E4E8\">(self) -> Optional[ListContext]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Pop and finalize the top context.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.contexts:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            context </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.contexts.pop()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            context.finalize()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> unwind_to_indentation</span><span style=\"color:#E1E4E8\">(self, target_indent: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> List[ListContext]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Unwind contexts until reaching target indentation level.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        finalized </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.contexts </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">               self</span><span style=\"color:#E1E4E8\">.contexts[</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].base_indentation </span><span style=\"color:#F97583\">>=</span><span style=\"color:#E1E4E8\"> target_indent):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            finalized.append(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.pop_context())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> finalized</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> find_context_for_indentation</span><span style=\"color:#E1E4E8\">(self, indent: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Optional[ListContext]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Find the context that should contain an item at given indentation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> context </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> reversed</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.contexts):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> context.base_indentation </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> indent:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> mark_all_loose</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Mark all contexts as loose (blank lines affect all levels).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> context </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.contexts:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            context.mark_loose()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> clear</span><span style=\"color:#E1E4E8\">(self) -> List[ListContext]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Clear all contexts and return them finalized.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        finalized </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.contexts:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            finalized.append(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.pop_context())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> finalized</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>list_parser.py</strong> - Main list parsing logic:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Iterator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..ast_nodes </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ASTNode, BlockNode, BlockType, NodeType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..common.line_info </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LineInfo</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .list_context </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ListContextStack, ListContext, ListState</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .list_utils </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    detect_list_marker, get_indentation_level, is_blank_line,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    can_lazy_continue, MarkerType, ListMarkerInfo</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ListParser</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Handles parsing of ordered and unordered lists with nesting.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.context_stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ListContextStack()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_line_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.lines: List[LineInfo] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_list_sequence</span><span style=\"color:#E1E4E8\">(self, lines: List[LineInfo], start_index: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> tuple[List[BlockNode], </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Parse a sequence of list items starting at the given index.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns (list_nodes, next_index) where next_index is the first line</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        that doesn't belong to any list.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize parsing state with lines and starting index</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Process lines sequentially until no more list content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle context stack cleanup and finalization</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return completed list nodes and next line index</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use process_line_for_lists() for each line</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_line_for_lists</span><span style=\"color:#E1E4E8\">(self, line: LineInfo) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Process a single line in the context of list parsing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns True if the line was consumed by list parsing, False otherwise.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if line is blank and handle loose list marking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Try to detect list marker using detect_list_marker()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If marker found, handle as new list item with handle_list_item()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If no marker, try continuation with try_list_continuation()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If neither works, finalize contexts and return False</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Blank lines between items mark lists as loose</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_list_item</span><span style=\"color:#E1E4E8\">(self, line: LineInfo, marker_info: ListMarkerInfo) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Handle a line that contains a list marker.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Creates appropriate list structures and adds the item.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate base indentation from line and marker info</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Determine if this starts new list or continues existing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Unwind context stack if indentation decreased</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create new list context if needed with create_list_context()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create list item node and add to current list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Extract item content after marker and set content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use context_stack.find_context_for_indentation() to find parent</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> try_list_continuation</span><span style=\"color:#E1E4E8\">(self, line: LineInfo) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Try to continue the current list item with this line.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns True if line was consumed as continuation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if any list contexts are active</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Get current context and required indentation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check if line meets continuation requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Use can_lazy_continue() to allow lazy continuation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Append line content to current item if valid continuation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle blank lines within items (mark loose if needed)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Continuation requires indentation >= context.content_indentation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_list_context</span><span style=\"color:#E1E4E8\">(self, marker_info: ListMarkerInfo, base_indent: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> ListContext:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create a new list context for the given marker and indentation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create BlockNode with LIST block_type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Set list attributes (ordered/unordered, marker type)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If ordered list, set start number from marker_info</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create ListContext with all required parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Add list node to parent context if nesting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return the new context for pushing to stack</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Check if this is a nested list and attach to current item</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> check_marker_compatibility</span><span style=\"color:#E1E4E8\">(self, current_marker: MarkerType, new_marker: MarkerType) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Check if a new marker is compatible with the current list type.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Different markers or ordered/unordered mixing starts new lists.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract ordered/unordered status from both markers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return False if mixing ordered and unordered</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For ordered lists, check delimiter compatibility (. vs ))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For unordered lists, allow any unordered marker mix</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return True if markers can be in same list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: CommonMark allows mixing -, *, + but not ordered/unordered</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> extract_item_content</span><span style=\"color:#E1E4E8\">(self, line: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, marker_info: ListMarkerInfo) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Extract the content portion of a list item line after the marker.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate total prefix length (indentation + marker + spaces)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Slice line content after the prefix</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle case where line ends immediately after marker</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Strip trailing whitespace but preserve internal spacing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return cleaned content string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: marker_info.content_indent tells you where content starts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> finalize_all_contexts</span><span style=\"color:#E1E4E8\">(self) -> List[BlockNode]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Finalize all remaining list contexts and return root list nodes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get all contexts from stack using context_stack.clear()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Finalize each context to set tight/loose attributes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Collect root list nodes (those not nested in other lists)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return list of root nodes for adding to document</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Root nodes are those whose parent is not a list item</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_blank_line_in_lists</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Handle blank lines that appear within list structures.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Marks lists as loose according to CommonMark rules.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if we're currently in any list context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Mark current context as having blank lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Apply loose marking rules (blank between items vs within items)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Use context_stack.mark_all_loose() if between items</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Blank lines between items make all parent lists loose</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>Python Implementation Tips:</strong></p>\n<ul>\n<li>Use <code>str.lstrip()</code> and <code>str.rstrip()</code> for whitespace handling, but be careful about internal spacing preservation</li>\n<li>The <code>re</code> module&#39;s named groups (<code>(?P&lt;name&gt;...)</code>) make marker parsing more readable</li>\n<li>List comprehensions can simplify context stack filtering: <code>[ctx for ctx in contexts if ctx.base_indentation &lt; target]</code></li>\n<li>Use <code>dataclasses.dataclass</code> for context objects to get automatic <code>__init__</code> and <code>__repr__</code> methods</li>\n<li>Python&#39;s <code>enumerate()</code> function helps track line numbers during processing</li>\n<li>Use <code>collections.deque</code> if you need efficient line lookahead with <code>peek_next_line()</code> functionality</li>\n</ul>\n<p><strong>Regex Pattern Optimization:</strong></p>\n<ul>\n<li>Compile regex patterns once at module level rather than recreating them for each line</li>\n<li>Use raw strings (<code>r&quot;...&quot;</code>) for regex patterns to avoid double-escaping backslashes</li>\n<li>Named capture groups improve code readability: <code>r&quot;^(?P&lt;indent&gt; {0,3})(?P&lt;marker&gt;[-*+])(?P&lt;space&gt; +)&quot;</code></li>\n<li>Consider using <code>re.VERBOSE</code> flag for complex patterns to allow comments and formatting</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the list parser component, verify correct functionality with these specific tests:</p>\n<p><strong>Test Command</strong>: <code>python -m pytest tests/test_list_parser.py -v</code></p>\n<p><strong>Expected Behaviors to Verify:</strong></p>\n<ol>\n<li><strong>Simple List Parsing</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   markdown </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"- Item 1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">- Item 2</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">- Item 3\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should produce ul with 3 li elements</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Nested List Structure</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   markdown </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"1. First</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">   - Nested</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">   - Items</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">2. Second\"</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should produce ol containing li with nested ul</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Tight vs Loose Lists</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   tight </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"- Item 1</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">- Item 2\"</span><span style=\"color:#6A737D\">  # No blank lines</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">   loose </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"- Item 1</span><span style=\"color:#79B8FF\">\\n\\n</span><span style=\"color:#9ECBFF\">- Item 2\"</span><span style=\"color:#6A737D\">  # Blank line between</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Tight should have tight=True, loose should have tight=False</span></span></code></pre></div>\n\n<ol start=\"4\">\n<li><strong>Mixed Indentation Handling</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">   markdown </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"  - Indented list</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">    - Nested item</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">  - Back to level 1\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">   # Should correctly track indentation levels and nesting</span></span></code></pre></div>\n\n<p><strong>Manual Verification Steps:</strong></p>\n<ol>\n<li>Run <code>python -c &quot;from markdown_parser import parse_to_html; print(parse_to_html(&#39;- Test\\n  - Nested&#39;))&quot;</code></li>\n<li>Check that nested lists produce proper <code>&lt;ul&gt;&lt;li&gt;</code> structures with correct nesting</li>\n<li>Verify that ordered lists use <code>&lt;ol start=&quot;N&quot;&gt;</code> when starting number is not 1</li>\n<li>Confirm that loose lists wrap item content in <code>&lt;p&gt;</code> tags while tight lists don&#39;t</li>\n</ol>\n<p><strong>Common Issues and Diagnostics:</strong></p>\n<ul>\n<li><strong>Lists not nesting</strong>: Check indentation calculation in <code>get_indentation_level()</code> and context stack management</li>\n<li><strong>Wrong tight/loose detection</strong>: Verify blank line tracking in <code>handle_blank_line_in_lists()</code></li>\n<li><strong>Mixed list problems</strong>: Check <code>check_marker_compatibility()</code> logic for ordered/unordered mixing</li>\n<li><strong>Content not continuing</strong>: Debug <code>can_lazy_continue()</code> and continuation indentation requirements</li>\n</ul>\n<p><strong>Debug Output Helpers:</strong>\nUse <code>debug_print_ast()</code> to visualize the parsed AST structure and verify correct parent-child relationships in nested lists. The output should show clear hierarchical structure with proper list and list-item nesting.</p>\n<h2 id=\"html-generator-design\">HTML Generator Design</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 4: HTML Generation</p>\n</blockquote>\n<h3 id=\"the-document-assembly-mental-model\">The Document Assembly Mental Model</h3>\n<p>Think of HTML generation like assembling a piece of furniture from parsed instruction components. You have all the individual pieces (your AST nodes) with their specifications and relationships clearly defined, and now you need to transform them into the final assembled product (valid HTML) following precise construction rules. Just as furniture assembly requires the right tools (HTML escaping), the correct order of operations (depth-first traversal), and attention to detail (proper nesting and formatting), HTML generation requires systematic conversion of each AST component into its corresponding HTML representation while maintaining structural integrity.</p>\n<p>The key insight is that HTML generation is fundamentally a <strong>translation process</strong> - you&#39;re converting from one structured representation (AST) to another (HTML markup) while preserving all the semantic meaning and relationships. This is different from parsing, which discovers structure from unstructured text. Here, the structure already exists and must be faithfully represented in a different format.</p>\n<p><img src=\"/api/project/markdown-renderer/architecture-doc/asset?path=diagrams%2Fhtml-generation-traversal.svg\" alt=\"HTML Generation Tree Traversal\"></p>\n<h2 id=\"html-generation-algorithm\">HTML Generation Algorithm</h2>\n<p>The HTML generation process follows a systematic <strong>depth-first tree traversal</strong> pattern where each AST node is visited exactly once and converted to its corresponding HTML representation. This approach ensures that nested structures are properly handled and that parent-child relationships in the AST translate correctly to HTML element nesting.</p>\n<p>The core algorithm operates through a <strong>visitor pattern</strong> where different node types trigger different rendering behaviors. This design allows for extensible rendering where new node types can be added without modifying the core traversal logic, and custom renderers can override specific element generation while preserving the overall structure.</p>\n<h3 id=\"tree-traversal-algorithm-steps\">Tree Traversal Algorithm Steps</h3>\n<p>The HTML generation follows these sequential steps for each node in the AST:</p>\n<ol>\n<li><p><strong>Node Type Identification</strong>: Examine the current node&#39;s <code>node_type</code> and <code>block_type</code> or <code>inline_type</code> to determine the appropriate HTML element to generate. This dispatch mechanism routes each node to its specialized rendering logic.</p>\n</li>\n<li><p><strong>Pre-processing Content Escaping</strong>: Before generating any HTML tags, process the node&#39;s text content through the HTML escaping system. This step must occur before any inline parsing results are incorporated to avoid double-escaping scenarios.</p>\n</li>\n<li><p><strong>Opening Tag Generation</strong>: Create the appropriate opening HTML tag based on the node type. For block elements like headings, this involves tags like <code>&lt;h1&gt;</code> through <code>&lt;h6&gt;</code>. For inline elements, this includes tags like <code>&lt;strong&gt;</code>, <code>&lt;em&gt;</code>, or <code>&lt;code&gt;</code>. Self-closing elements like <code>&lt;hr&gt;</code> and <code>&lt;img&gt;</code> require special handling.</p>\n</li>\n<li><p><strong>Attribute Application</strong>: Apply any attributes stored in the node&#39;s <code>formatting_attributes</code> or <code>block_attributes</code> dictionaries. This includes <code>href</code> attributes for links, <code>src</code> and <code>alt</code> attributes for images, <code>class</code> attributes for code blocks with language specifications, and any custom attributes defined by extensions.</p>\n</li>\n<li><p><strong>Child Node Recursive Processing</strong>: For nodes with children in their <code>children</code> list, recursively invoke the HTML generation algorithm on each child node in order. This step maintains the depth-first traversal pattern and ensures proper nesting of HTML elements.</p>\n</li>\n<li><p><strong>Content Integration</strong>: Combine the processed child content with any direct text content from the current node. For leaf nodes, this involves directly including the escaped text content. For container nodes, this involves wrapping the child HTML with the current node&#39;s tags.</p>\n</li>\n<li><p><strong>Closing Tag Generation</strong>: Generate the appropriate closing HTML tag to match the opening tag created in step 3. Self-closing elements skip this step. Proper tag matching is critical for valid HTML output.</p>\n</li>\n<li><p><strong>Output Formatting</strong>: Apply consistent indentation and line breaks according to the configured pretty-printing rules. This step enhances human readability without affecting the semantic meaning of the generated HTML.</p>\n</li>\n</ol>\n<h3 id=\"node-type-rendering-mappings\">Node Type Rendering Mappings</h3>\n<p>The following table defines how each AST node type maps to HTML elements:</p>\n<table>\n<thead>\n<tr>\n<th>AST Node Type</th>\n<th>HTML Element</th>\n<th>Attributes</th>\n<th>Special Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DOCUMENT</code></td>\n<td><code>html</code> with <code>head</code>/<code>body</code></td>\n<td><code>lang</code> from document attributes</td>\n<td>Wrapper template generation</td>\n</tr>\n<tr>\n<td><code>PARAGRAPH</code></td>\n<td><code>p</code></td>\n<td>Standard block attributes</td>\n<td>Tight list detection affects wrapping</td>\n</tr>\n<tr>\n<td><code>HEADING</code></td>\n<td><code>h1</code> through <code>h6</code></td>\n<td><code>id</code> from heading text slug</td>\n<td>Level determined by heading depth</td>\n</tr>\n<tr>\n<td><code>CODE_BLOCK</code></td>\n<td><code>pre</code> containing <code>code</code></td>\n<td><code>class</code> for language hint</td>\n<td>Preserve exact whitespace and line breaks</td>\n</tr>\n<tr>\n<td><code>BLOCKQUOTE</code></td>\n<td><code>blockquote</code></td>\n<td>Citation attributes if present</td>\n<td>Recursive processing for nested quotes</td>\n</tr>\n<tr>\n<td><code>HORIZONTAL_RULE</code></td>\n<td><code>hr</code></td>\n<td>None (self-closing)</td>\n<td>No content or children</td>\n</tr>\n<tr>\n<td><code>LIST</code></td>\n<td><code>ul</code> or <code>ol</code></td>\n<td><code>start</code> attribute for ordered lists</td>\n<td>Tight vs loose list content handling</td>\n</tr>\n<tr>\n<td><code>LIST_ITEM</code></td>\n<td><code>li</code></td>\n<td>Task list attributes for checkboxes</td>\n<td>Paragraph wrapping based on list tightness</td>\n</tr>\n<tr>\n<td><code>STRONG</code></td>\n<td><code>strong</code></td>\n<td>None</td>\n<td>Inline element with nested content</td>\n</tr>\n<tr>\n<td><code>EMPHASIS</code></td>\n<td><code>em</code></td>\n<td>None</td>\n<td>Inline element with nested content</td>\n</tr>\n<tr>\n<td><code>CODE</code></td>\n<td><code>code</code></td>\n<td>None</td>\n<td>Preserve inner whitespace exactly</td>\n</tr>\n<tr>\n<td><code>LINK</code></td>\n<td><code>a</code></td>\n<td><code>href</code>, optional <code>title</code></td>\n<td>URL escaping and validation</td>\n</tr>\n<tr>\n<td><code>IMAGE</code></td>\n<td><code>img</code></td>\n<td><code>src</code>, <code>alt</code>, optional <code>title</code></td>\n<td>Self-closing with required attributes</td>\n</tr>\n<tr>\n<td><code>LINE_BREAK</code></td>\n<td><code>br</code></td>\n<td>None (self-closing)</td>\n<td>Hard line break representation</td>\n</tr>\n<tr>\n<td><code>TEXT</code></td>\n<td>Raw text content</td>\n<td>None</td>\n<td>HTML entity escaping only</td>\n</tr>\n</tbody></table>\n<h3 id=\"content-processing-pipeline\">Content Processing Pipeline</h3>\n<p>Each node&#39;s content undergoes a multi-stage processing pipeline before becoming final HTML:</p>\n<ol>\n<li><p><strong>Raw Content Extraction</strong>: Extract the <code>text_content</code> or <code>inline_content</code> from the node, handling None values gracefully by treating them as empty strings.</p>\n</li>\n<li><p><strong>HTML Entity Escaping</strong>: Apply HTML entity encoding to special characters using the <code>HTML_ESCAPE_TABLE</code> mapping. This prevents HTML injection and ensures proper display of literal angle brackets, ampersands, and quotes.</p>\n</li>\n<li><p><strong>Whitespace Preservation</strong>: For code blocks and inline code elements, preserve all whitespace exactly as it appears in the source. For other elements, normalize whitespace according to HTML conventions while respecting intentional line breaks.</p>\n</li>\n<li><p><strong>URL Processing</strong>: For link and image elements, validate and potentially transform URLs. This includes relative URL resolution, protocol validation, and optional URL rewriting for security or functionality purposes.</p>\n</li>\n<li><p><strong>Inline Content Integration</strong>: Combine processed text content with the HTML generated from child inline elements, maintaining the correct order and nesting relationships established during inline parsing.</p>\n</li>\n</ol>\n<h2 id=\"html-generator-architecture-decisions\">HTML Generator Architecture Decisions</h2>\n<p>The HTML generator design involves several critical architectural decisions that affect correctness, performance, and extensibility. Each decision represents a trade-off between competing concerns and establishes patterns that influence the entire generation system.</p>\n<blockquote>\n<p><strong>Decision: HTML Escaping Timing</strong></p>\n<ul>\n<li><strong>Context</strong>: HTML special characters (&amp;, &lt;, &gt;, &quot;, &#39;) must be escaped to prevent malformed output and security vulnerabilities, but escaping must occur at the right time to avoid double-escaping or interference with legitimate HTML tags.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Escape during initial text parsing before AST construction</li>\n<li>Escape during HTML generation at the leaf node level</li>\n<li>Escape at the very end after all HTML is generated</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Escape during HTML generation at the leaf node level when processing text content</li>\n<li><strong>Rationale</strong>: This timing ensures that all text content is properly escaped while allowing legitimate HTML tags generated by the renderer to remain unescaped. Early escaping would interfere with inline parsing delimiter detection, while late escaping would risk missing content or double-escaping already-processed elements.</li>\n<li><strong>Consequences</strong>: Enables safe handling of user content while maintaining clean separation between content and markup. Requires careful implementation to ensure all text paths go through escaping logic.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Escape during parsing</td>\n<td>Simple, happens once</td>\n<td>Interferes with delimiter detection</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Escape during generation</td>\n<td>Clean separation, no double-escaping</td>\n<td>Must be applied consistently</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Escape after generation</td>\n<td>Handles all content uniformly</td>\n<td>Risk of escaping legitimate HTML tags</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Self-Closing Tag Handling</strong></p>\n<ul>\n<li><strong>Context</strong>: HTML5 has specific rules for self-closing tags like <code>&lt;hr&gt;</code>, <code>&lt;br&gt;</code>, and <code>&lt;img&gt;</code> that should not have closing tags, while container tags like <code>&lt;p&gt;</code> and <code>&lt;div&gt;</code> must have matching closing tags.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Always generate closing tags and let browsers handle invalid combinations</li>\n<li>Maintain a list of self-closing tag names and handle them specially</li>\n<li>Use XHTML-style self-closing syntax (<code>&lt;br /&gt;</code>) for all self-closing elements</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Maintain a list of self-closing tag names and generate HTML5-compliant output</li>\n<li><strong>Rationale</strong>: Produces the most correct and standards-compliant HTML output. Modern validation tools and accessibility checkers expect proper self-closing tag usage. XHTML syntax is unnecessarily verbose for HTML5 output.</li>\n<li><strong>Consequences</strong>: Requires maintaining an accurate list of self-closing tags but produces the highest quality output. Enables proper validation and compatibility with HTML processing tools.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Always generate closing tags</td>\n<td>Simple implementation</td>\n<td>Invalid HTML for self-closing elements</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Special handling by tag name</td>\n<td>Correct HTML5 output</td>\n<td>Requires tag name knowledge</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>XHTML-style syntax</td>\n<td>Valid in both HTML and XHTML</td>\n<td>Unnecessarily verbose</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Extensible Rendering Interface</strong></p>\n<ul>\n<li><strong>Context</strong>: Users may want to customize HTML output for specific node types, add custom attributes, or integrate with template systems while maintaining the core generation logic.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Hard-coded rendering with no customization options</li>\n<li>Callback-based system where users can override specific node type rendering</li>\n<li>Template-based system where HTML generation uses external templates</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Callback-based system with a renderer plugin interface</li>\n<li><strong>Rationale</strong>: Provides flexibility for customization while maintaining performance and simplicity. Templates would add complexity and external dependencies, while hard-coded rendering would limit extensibility for advanced users.</li>\n<li><strong>Consequences</strong>: Enables custom output formats and integration with existing systems. Requires careful interface design to maintain backward compatibility and performance.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Hard-coded rendering</td>\n<td>Simple, fast, predictable</td>\n<td>No customization possible</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Callback-based plugins</td>\n<td>Flexible, maintains performance</td>\n<td>Interface complexity</td>\n<td><strong>Yes</strong></td>\n</tr>\n<tr>\n<td>Template-based system</td>\n<td>Very flexible, familiar pattern</td>\n<td>External dependencies, complexity</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Pretty Printing Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Generated HTML can be output as minified (single line) for efficiency or pretty-printed (indented, multi-line) for human readability, with implications for file size, debugging, and processing speed.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Always generate minified output for smallest size</li>\n<li>Always generate pretty-printed output for readability</li>\n<li>Configurable option with default to pretty-printed</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Configurable option with default to pretty-printed output</li>\n<li><strong>Rationale</strong>: Development and debugging benefit significantly from readable HTML output, while production systems can opt for minified output when needed. The size difference is typically negligible for markdown-generated content compared to other web assets.</li>\n<li><strong>Consequences</strong>: Adds slight complexity to the generator but provides significant developer experience benefits. Pretty-printing logic must be carefully implemented to avoid introducing semantic whitespace changes.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Always minified</td>\n<td>Smallest output, fastest generation</td>\n<td>Difficult to debug</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Always pretty-printed</td>\n<td>Easy debugging, readable output</td>\n<td>Slightly larger files</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Configurable with pretty default</td>\n<td>Best of both worlds</td>\n<td>Additional complexity</td>\n<td><strong>Yes</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"html-generation-component-responsibilities\">HTML Generation Component Responsibilities</h3>\n<p>The HTML generator consists of several specialized components, each with clearly defined responsibilities:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Responsibilities</th>\n<th>Dependencies</th>\n<th>Output</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>HtmlRenderer</code></td>\n<td>Orchestrates overall generation process</td>\n<td>AST root node, configuration</td>\n<td>Complete HTML document string</td>\n</tr>\n<tr>\n<td><code>NodeVisitor</code></td>\n<td>Implements depth-first tree traversal</td>\n<td>AST node structure</td>\n<td>Visits each node exactly once</td>\n</tr>\n<tr>\n<td><code>TagGenerator</code></td>\n<td>Creates opening and closing HTML tags</td>\n<td>Node type mappings, attributes</td>\n<td>Individual HTML tags with attributes</td>\n</tr>\n<tr>\n<td><code>ContentEscaper</code></td>\n<td>Applies HTML entity escaping to text</td>\n<td>Escape mapping table</td>\n<td>Safely escaped text content</td>\n</tr>\n<tr>\n<td><code>AttributeProcessor</code></td>\n<td>Converts node attributes to HTML attributes</td>\n<td>Node attribute dictionaries</td>\n<td>Formatted attribute strings</td>\n</tr>\n<tr>\n<td><code>PrettyPrinter</code></td>\n<td>Applies consistent formatting and indentation</td>\n<td>Generated HTML string, formatting rules</td>\n<td>Formatted HTML output</td>\n</tr>\n<tr>\n<td><code>RendererPlugin</code></td>\n<td>Provides extensibility for custom output</td>\n<td>Plugin interface, node context</td>\n<td>Custom HTML for specific nodes</td>\n</tr>\n</tbody></table>\n<h2 id=\"html-generation-common-pitfalls\">HTML Generation Common Pitfalls</h2>\n<p>HTML generation involves several subtle issues that can produce incorrect output or security vulnerabilities. Understanding these pitfalls is crucial for implementing a robust and secure markdown renderer.</p>\n<p>⚠️ <strong>Pitfall: Double-Escaping HTML Entities</strong></p>\n<p>The most common mistake in HTML generation is applying HTML entity escaping multiple times to the same content, resulting in output like <code>&amp;amp;lt;</code> instead of <code>&amp;lt;</code>. This occurs when text is escaped during parsing and then escaped again during HTML generation, or when already-escaped content from child nodes is re-escaped by parent nodes.</p>\n<p><strong>Why it&#39;s wrong</strong>: Double-escaped content displays incorrectly to users. For example, the HTML entity <code>&amp;lt;</code> should render as the <code>&lt;</code> character, but <code>&amp;amp;lt;</code> renders as the literal text <code>&amp;lt;</code>.</p>\n<p><strong>How to avoid</strong>: Implement escaping exactly once during HTML generation when processing leaf text nodes. Ensure that content returned by child node processing is already properly escaped and should not be re-escaped. Use clear data flow contracts where escaped and unescaped content are never mixed without explicit conversion.</p>\n<p>⚠️ <strong>Pitfall: Incorrect Self-Closing Tag Syntax</strong></p>\n<p>Many implementations generate invalid HTML by either adding closing tags to self-closing elements (<code>&lt;hr&gt;&lt;/hr&gt;</code>) or forgetting closing tags for container elements. This produces HTML that may render inconsistently across browsers and fails validation.</p>\n<p><strong>Why it&#39;s wrong</strong>: Invalid HTML can cause rendering differences between browsers, accessibility issues, and problems with HTML processing tools. Some browsers attempt to fix invalid markup automatically, leading to unpredictable results.</p>\n<p><strong>How to avoid</strong>: Maintain an accurate list of HTML5 self-closing elements (<code>hr</code>, <code>br</code>, <code>img</code>, <code>input</code>, <code>area</code>, <code>base</code>, <code>col</code>, <code>embed</code>, <code>link</code>, <code>meta</code>, <code>source</code>, <code>track</code>, <code>wbr</code>) and handle them specially in tag generation logic. Use a clear distinction in code between self-closing and container element generation.</p>\n<p>⚠️ <strong>Pitfall: Whitespace Semantic Changes</strong></p>\n<p>Pretty-printing logic can inadvertently introduce or remove whitespace that has semantic meaning in HTML, particularly around inline elements where spaces between tags affect text layout and rendering.</p>\n<p><strong>Why it&#39;s wrong</strong>: Adding or removing spaces between inline elements changes how text flows and displays. For example, <code>&lt;strong&gt;bold&lt;/strong&gt; &lt;em&gt;italic&lt;/em&gt;</code> renders differently than <code>&lt;strong&gt;bold&lt;/strong&gt;&lt;em&gt;italic&lt;/em&gt;</code> - the first has a space between &quot;bold&quot; and &quot;italic&quot; while the second does not.</p>\n<p><strong>How to avoid</strong>: Apply pretty-printing indentation only at block-level boundaries where whitespace is not semantically significant. Preserve exact spacing within and between inline elements. Test pretty-printed output against minified output to ensure semantic equivalence.</p>\n<p>⚠️ <strong>Pitfall: Improper Attribute Value Escaping</strong></p>\n<p>HTML attributes have different escaping requirements than HTML content. Attribute values must escape quotes appropriately for the quote style used, and certain characters like newlines may need special handling or replacement.</p>\n<p><strong>Why it&#39;s wrong</strong>: Unescaped quotes in attribute values can break HTML parsing by prematurely terminating the attribute value. This can lead to HTML injection vulnerabilities or malformed output.</p>\n<p><strong>How to avoid</strong>: Use different escaping logic for attribute values than for HTML content. When using double quotes for attribute values, escape internal double quotes as <code>&amp;quot;</code>. When using single quotes, escape internal single quotes as <code>&amp;#39;</code>. Consider using double quotes consistently for all attributes to simplify escaping logic.</p>\n<p>⚠️ <strong>Pitfall: Missing URL Validation and Escaping</strong></p>\n<p>Links and images require special handling for their URL attributes, including proper percent-encoding and validation to prevent malformed URLs or potential security issues with javascript: or data: URLs.</p>\n<p><strong>Why it&#39;s wrong</strong>: Invalid URLs can break page functionality or create security vulnerabilities. Unescaped special characters in URLs can cause parsing errors or unexpected behavior.</p>\n<p><strong>How to avoid</strong>: Implement URL-specific validation and encoding for <code>href</code> and <code>src</code> attributes. Consider implementing configurable URL scheme filtering to block potentially dangerous protocols. Apply proper percent-encoding to URL components while preserving valid URL structure.</p>\n<p>⚠️ <strong>Pitfall: Inconsistent List Handling</strong></p>\n<p>Lists have complex rules around tight versus loose formatting, where tight lists render list items without paragraph tags while loose lists wrap list item content in paragraphs. Inconsistent handling produces incorrect HTML structure.</p>\n<p><strong>Why it&#39;s wrong</strong>: Incorrect list formatting affects both visual appearance and semantic meaning. Screen readers and other assistive technologies rely on proper list structure for navigation and content understanding.</p>\n<p><strong>How to avoid</strong>: Implement clear logic for determining list tightness based on blank lines between list items during parsing. Consistently apply paragraph wrapping rules based on the list&#39;s tight/loose status. Test with nested lists to ensure proper handling of mixed tight/loose scenarios.</p>\n<p>⚠️ <strong>Pitfall: Plugin Interface State Pollution</strong></p>\n<p>When implementing extensible rendering through plugins, state sharing between the main renderer and plugins can cause unexpected interactions or side effects that affect subsequent rendering operations.</p>\n<p><strong>Why it&#39;s wrong</strong>: State pollution can cause rendering inconsistencies, memory leaks, or unexpected behavior when plugins modify shared state. This makes the system unreliable and difficult to debug.</p>\n<p><strong>How to avoid</strong>: Design plugin interfaces to be stateless where possible. Pass all necessary context as parameters rather than sharing mutable state. If state is required, use immutable data structures or clear ownership patterns where plugins cannot affect the main renderer&#39;s state.</p>\n<h2 id=\"implementation-guidance\">Implementation Guidance</h2>\n<p>The HTML generation system requires careful coordination between several components while maintaining clean separation of concerns. The implementation focuses on correctness, security, and extensibility while providing clear debugging capabilities.</p>\n<h3 id=\"technology-recommendations\">Technology Recommendations</h3>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTML Escaping</td>\n<td>Built-in string replacement with escape table</td>\n<td><code>html</code> module with <code>html.escape()</code> function</td>\n</tr>\n<tr>\n<td>Tree Traversal</td>\n<td>Recursive function with node type dispatch</td>\n<td>Visitor pattern with abstract base classes</td>\n</tr>\n<tr>\n<td>Template System</td>\n<td>String formatting with f-strings</td>\n<td><code>jinja2</code> or similar template engine</td>\n</tr>\n<tr>\n<td>Pretty Printing</td>\n<td>Manual indentation tracking with string building</td>\n<td><code>xml.dom.minidom</code> for structured formatting</td>\n</tr>\n<tr>\n<td>Plugin System</td>\n<td>Simple callback dictionary</td>\n<td>Full plugin architecture with registration</td>\n</tr>\n<tr>\n<td>URL Validation</td>\n<td>Basic regex pattern matching</td>\n<td><code>urllib.parse</code> with comprehensive validation</td>\n</tr>\n</tbody></table>\n<h3 id=\"recommended-file-structure\">Recommended File Structure</h3>\n<p>The HTML generator integrates into the overall project structure as the final stage of the parsing pipeline:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  src/\n    markdown_renderer/\n      core/\n        ast_nodes.py              ← AST node definitions (from Data Model)\n        parser.py                 ← Main parser orchestration\n      parsers/\n        block_parser.py           ← Block-level parsing logic\n        inline_parser.py          ← Inline element parsing logic\n        list_parser.py            ← List parsing logic\n      generators/\n        html_generator.py         ← Main HTML generation logic (THIS COMPONENT)\n        html_escaper.py           ← HTML entity escaping utilities\n        tag_generator.py          ← HTML tag creation logic\n        pretty_printer.py         ← Output formatting utilities\n        renderer_plugins.py       ← Extensible rendering interface\n      utils/\n        html_utils.py             ← HTML-specific utility functions\n        url_validator.py          ← URL validation and encoding\n  tests/\n    test_html_generation.py       ← HTML generator test suite\n    test_escaping.py             ← Entity escaping test cases\n    test_plugins.py              ← Plugin system test cases\n  examples/\n    basic_usage.py               ← Simple HTML generation examples\n    custom_renderer.py           ← Plugin usage examples</code></pre></div>\n\n<h3 id=\"html-escaping-infrastructure-complete-starter-code\">HTML Escaping Infrastructure (Complete Starter Code)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"HTML entity escaping utilities for safe content rendering.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Complete mapping of characters that must be escaped in HTML content</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">HTML_ESCAPE_TABLE</span><span style=\"color:#E1E4E8\">: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x26;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;amp;'</span><span style=\"color:#E1E4E8\">,    </span><span style=\"color:#6A737D\"># Must be first to avoid double-escaping</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x3C;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;lt;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '>'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;gt;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '\"'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;quot;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"'\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;#x27;'</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#6A737D\"># More compatible than &#x26;apos;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Separate mapping for HTML attribute values</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ATTRIBUTE_ESCAPE_TABLE</span><span style=\"color:#E1E4E8\">: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x26;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;amp;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x3C;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;lt;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '>'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;gt;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '\"'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;quot;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"'\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;#x27;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;#10;'</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#6A737D\"># Newlines in attributes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;#13;'</span><span style=\"color:#E1E4E8\">,   </span><span style=\"color:#6A737D\"># Carriage returns in attributes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;#9;'</span><span style=\"color:#E1E4E8\">,    </span><span style=\"color:#6A737D\"># Tabs in attributes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HtmlEscaper</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Handles HTML entity escaping for content and attributes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Pre-compile regex patterns for performance</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._content_pattern </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#9ECBFF\">'(['</span><span style=\"color:#F97583\"> +</span><span style=\"color:#9ECBFF\"> ''</span><span style=\"color:#E1E4E8\">.join(</span><span style=\"color:#79B8FF\">HTML_ESCAPE_TABLE</span><span style=\"color:#E1E4E8\">.keys()) </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> '])'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._attr_pattern </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#9ECBFF\">'(['</span><span style=\"color:#F97583\"> +</span><span style=\"color:#9ECBFF\"> ''</span><span style=\"color:#E1E4E8\">.join(</span><span style=\"color:#79B8FF\">ATTRIBUTE_ESCAPE_TABLE</span><span style=\"color:#E1E4E8\">.keys()) </span><span style=\"color:#F97583\">+</span><span style=\"color:#9ECBFF\"> '])'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> escape_content</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Escape text content for safe inclusion in HTML.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> text:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> text</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        def</span><span style=\"color:#B392F0\"> replace_char</span><span style=\"color:#E1E4E8\">(match):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> HTML_ESCAPE_TABLE</span><span style=\"color:#E1E4E8\">[match.group(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._content_pattern.sub(replace_char, text)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> escape_attribute</span><span style=\"color:#E1E4E8\">(self, value: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Escape attribute value for safe inclusion in HTML attributes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> value:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        def</span><span style=\"color:#B392F0\"> replace_char</span><span style=\"color:#E1E4E8\">(match):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> ATTRIBUTE_ESCAPE_TABLE</span><span style=\"color:#E1E4E8\">[match.group(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._attr_pattern.sub(replace_char, value)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_safe_url_scheme</span><span style=\"color:#E1E4E8\">(self, url: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if URL uses a safe scheme for links and images.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        safe_schemes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">'http'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'https'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'ftp'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'mailto'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'tel'</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#9ECBFF\"> ':'</span><span style=\"color:#F97583\"> not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> url:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#6A737D\">  # Relative URLs are safe</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        scheme </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> url.split(</span><span style=\"color:#9ECBFF\">':'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">].lower()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> scheme </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> safe_schemes</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Global escaper instance for convenience</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">html_escaper </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> HtmlEscaper()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> escape_html</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convenience function for HTML content escaping.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> html_escaper.escape_content(text)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> escape_html_attribute</span><span style=\"color:#E1E4E8\">(value: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convenience function for HTML attribute escaping.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> html_escaper.escape_attribute(value)</span></span></code></pre></div>\n\n<h3 id=\"pretty-printing-utilities-complete-starter-code\">Pretty Printing Utilities (Complete Starter Code)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Pretty printing utilities for formatted HTML output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HtmlPrettyPrinter</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Formats HTML output with consistent indentation and line breaks.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, indent_size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">, max_line_length: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.indent_size </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> indent_size</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.max_line_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> max_line_length</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Elements that should have their content on the same line</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.inline_elements </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'a'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'abbr'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'b'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'bdi'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'bdo'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'br'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'button'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'cite'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'code'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'dfn'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'em'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'i'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'kbd'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'mark'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'q'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'s'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'samp'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'small'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'span'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'strong'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'sub'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'sup'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'time'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'u'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'var'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Self-closing elements that don't have content</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.void_elements </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'area'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'base'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'br'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'col'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'embed'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'hr'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'img'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'input'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'link'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'meta'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'source'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'track'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'wbr'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_html</span><span style=\"color:#E1E4E8\">(self, html: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, start_indent: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Format HTML string with proper indentation and line breaks.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> html.strip():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> html</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_indent </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> start_indent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(html):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> html[i] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> '&#x3C;'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Find the end of this tag</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                tag_end </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> html.find(</span><span style=\"color:#9ECBFF\">'>'</span><span style=\"color:#E1E4E8\">, i)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> tag_end </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Malformed HTML - just add the rest as-is</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    lines.append(</span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> (current_indent </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.indent_size) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> html[i:])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                tag_content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> html[i:tag_end </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Determine if this is a closing tag, self-closing tag, or opening tag</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> tag_content.startswith(</span><span style=\"color:#9ECBFF\">'&#x3C;/'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Closing tag - decrease indent before adding</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    current_indent </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> max</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, current_indent </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    lines.append(</span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> (current_indent </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.indent_size) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> tag_content)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                elif</span><span style=\"color:#E1E4E8\"> tag_content.endswith(</span><span style=\"color:#9ECBFF\">'/>'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">or</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._is_void_element(tag_content):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Self-closing or void element - no indent change</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    lines.append(</span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> (current_indent </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.indent_size) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> tag_content)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Opening tag - add then increase indent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    lines.append(</span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> (current_indent </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.indent_size) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> tag_content)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._is_inline_element(tag_content):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        current_indent </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                i </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tag_end </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Text content - find the next tag or end of string</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                next_tag </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> html.find(</span><span style=\"color:#9ECBFF\">'&#x3C;'</span><span style=\"color:#E1E4E8\">, i)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> next_tag </span><span style=\"color:#F97583\">==</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    text_content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> html[i:].strip()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    text_content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> html[i:next_tag].strip()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> text_content:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    lines.append(</span><span style=\"color:#9ECBFF\">' '</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> (current_indent </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.indent_size) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> text_content)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                i </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> next_tag </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> next_tag </span><span style=\"color:#F97583\">!=</span><span style=\"color:#F97583\"> -</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#F97583\"> else</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(html)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">.join(lines)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _extract_tag_name</span><span style=\"color:#E1E4E8\">(self, tag_content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Extract tag name from tag content like '&#x3C;div class=\"foo\">' -> 'div'.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Remove &#x3C; and > brackets</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tag_inner </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tag_content[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].strip()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> tag_inner.startswith(</span><span style=\"color:#9ECBFF\">'/'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            tag_inner </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> tag_inner[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">:]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Split on whitespace to get just the tag name</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> tag_inner.split()[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> tag_inner </span><span style=\"color:#F97583\">else</span><span style=\"color:#9ECBFF\"> ''</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _is_inline_element</span><span style=\"color:#E1E4E8\">(self, tag_content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if tag represents an inline element.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tag_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._extract_tag_name(tag_content)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> tag_name </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.inline_elements</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _is_void_element</span><span style=\"color:#E1E4E8\">(self, tag_content: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if tag represents a void (self-closing) element.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        tag_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._extract_tag_name(tag_content)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> tag_name </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.void_elements</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Global pretty printer instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">html_pretty_printer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> HtmlPrettyPrinter()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> format_html</span><span style=\"color:#E1E4E8\">(html: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, indent_size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convenience function for HTML pretty printing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    printer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> HtmlPrettyPrinter(indent_size)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> printer.format_html(html)</span></span></code></pre></div>\n\n<h3 id=\"core-html-generation-logic-skeleton-with-todos\">Core HTML Generation Logic (Skeleton with TODOs)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Core HTML generation logic for converting AST to HTML.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, List, Optional, Callable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span><span style=\"color:#E1E4E8\">, abstractmethod</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.ast_nodes </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ASTNode, NodeType, BlockType, InlineType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .html_escaper </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> html_escaper</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .pretty_printer </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> html_pretty_printer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HtmlRenderer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Main HTML generation class that converts AST to HTML output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, pretty_print: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">, custom_renderers: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Callable]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.pretty_print </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pretty_print</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.custom_renderers </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> custom_renderers </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.escaper </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> html_escaper</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.pretty_printer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> html_pretty_printer </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> pretty_print </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> render_to_html</span><span style=\"color:#E1E4E8\">(self, ast_root: ASTNode) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert AST to complete HTML document string.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if ast_root is None or empty and return appropriate default</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call render_node on the root to get the body content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If pretty_print is enabled, format the output using pretty_printer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the final HTML string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Consider whether to wrap in full HTML document or just return content</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> render_node</span><span style=\"color:#E1E4E8\">(self, node: ASTNode) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Render a single AST node and all its children to HTML.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if there's a custom renderer for this node type in self.custom_renderers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If custom renderer exists, call it with the node and return result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Dispatch to appropriate rendering method based on node.node_type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: If node_type is BLOCK, call render_block_node(node)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If node_type is INLINE, call render_inline_node(node) </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If node_type is TEXT, call render_text_node(node)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Handle unknown node types with graceful degradation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use a dispatch dictionary to map node types to methods</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> render_block_node</span><span style=\"color:#E1E4E8\">(self, node: ASTNode) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Render block-level elements like paragraphs, headings, lists.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract block_type from node (it should be a BlockNode)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Dispatch based on block_type using if/elif or dictionary lookup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For PARAGRAPH: wrap children in &#x3C;p> tags</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For HEADING: determine level and wrap in &#x3C;h1>-&#x3C;h6> tags  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: For CODE_BLOCK: wrap in &#x3C;pre>&#x3C;code> with language class if present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: For BLOCKQUOTE: wrap in &#x3C;blockquote> tags</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: For HORIZONTAL_RULE: return &#x3C;hr> (self-closing)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: For LIST: determine if ordered/unordered and wrap in &#x3C;ol>/&#x3C;ul></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: For LIST_ITEM: wrap in &#x3C;li> tags, handle tight/loose list formatting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 10: Render all children and combine with appropriate wrapping</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use get_attribute() to access block-specific data like heading level</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> render_inline_node</span><span style=\"color:#E1E4E8\">(self, node: ASTNode) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Render inline elements like emphasis, links, code spans.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract inline_type from node (it should be an InlineNode)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Dispatch based on inline_type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For STRONG: wrap children in &#x3C;strong> tags</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For EMPHASIS: wrap children in &#x3C;em> tags  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: For CODE: wrap text_content in &#x3C;code> tags, preserve whitespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: For LINK: create &#x3C;a> tag with href attribute, render children as link text</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: For IMAGE: create &#x3C;img> tag with src and alt attributes (self-closing)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: For LINE_BREAK: return &#x3C;br> (self-closing)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Apply HTML escaping to text content but not to child HTML</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 10: Handle missing or invalid attributes gracefully</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use formatting_attributes dictionary for link URLs, image sources, etc.</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> render_text_node</span><span style=\"color:#E1E4E8\">(self, node: ASTNode) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Render plain text nodes with proper HTML escaping.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract text_content from the node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Handle None or empty text content by returning empty string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Apply HTML entity escaping using self.escaper.escape_content()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return the escaped text (no HTML tags for text nodes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: This is where HTML injection prevention happens</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> render_children</span><span style=\"color:#E1E4E8\">(self, node: ASTNode) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Render all child nodes and concatenate their HTML.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if node has children attribute and it's not None</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If no children, return empty string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Iterate through node.children list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Call render_node() recursively on each child</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Concatenate all child HTML strings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return the combined result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Maintain the order of children as they appear in the list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_tag</span><span style=\"color:#E1E4E8\">(self, tag_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, attributes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    self_closing: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">) -> tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate opening and closing HTML tags with attributes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Start building opening tag with '&#x3C;' + tag_name</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If attributes provided, iterate through them</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For each attribute, escape the value using escaper.escape_attribute()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add each attribute as ' key=\"escaped_value\"' to opening tag</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Close opening tag with '>' or '/>' if self_closing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If self_closing, return (opening_tag, '') for empty closing tag</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: If not self_closing, generate closing tag as '&#x3C;/' + tag_name + '>'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Return tuple of (opening_tag, closing_tag)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Check VOID_ELEMENTS list to determine if tag should be self-closing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># List of HTML void elements that should not have closing tags</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">VOID_ELEMENTS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'area'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'base'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'br'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'col'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'embed'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'hr'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'img'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'input'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'link'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'meta'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'source'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'track'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'wbr'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> render_ast_to_html</span><span style=\"color:#E1E4E8\">(ast_root: ASTNode, pretty_print: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convenience function for rendering AST to HTML.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    renderer </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> HtmlRenderer(</span><span style=\"color:#FFAB70\">pretty_print</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">pretty_print)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> renderer.render_to_html(ast_root)</span></span></code></pre></div>\n\n<h3 id=\"plugin-interface-implementation-complete-starter-code\">Plugin Interface Implementation (Complete Starter Code)</h3>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Extensible rendering interface for custom HTML output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Protocol, Dict, Any, Optional, Callable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span><span style=\"color:#E1E4E8\">, abstractmethod</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.ast_nodes </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ASTNode</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> NodeRenderer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Protocol</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Protocol for custom node renderers.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> render</span><span style=\"color:#E1E4E8\">(self, node: ASTNode, default_renderer: Callable[[ASTNode], </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Render a node with access to the default rendering logic.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        ...</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RendererPlugin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base class for renderer plugins.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_supported_types</span><span style=\"color:#E1E4E8\">(self) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return list of node types this plugin can render.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> render_node</span><span style=\"color:#E1E4E8\">(self, node: ASTNode, context: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Render the given node type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PluginManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages registration and execution of renderer plugins.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.plugins: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, RendererPlugin] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.node_renderers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, NodeRenderer] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register_plugin</span><span style=\"color:#E1E4E8\">(self, plugin: RendererPlugin):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register a plugin for specific node types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> plugin.get_supported_types():</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.plugins[node_type] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> plugin</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register_node_renderer</span><span style=\"color:#E1E4E8\">(self, node_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, renderer: NodeRenderer):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register a simple node renderer function.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.node_renderers[node_type] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> renderer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> has_renderer</span><span style=\"color:#E1E4E8\">(self, node_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if a custom renderer exists for the node type.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.plugins </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.node_renderers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> render_node</span><span style=\"color:#E1E4E8\">(self, node_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, node: ASTNode, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   context: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any], default_renderer: Callable) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Render node using custom renderer if available.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.node_renderers:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.node_renderers[node_type].render(node, default_renderer)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> node_type </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.plugins:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.plugins[node_type].render_node(node, context)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> default_renderer(node)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Example custom renderer for code blocks with syntax highlighting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SyntaxHighlightRenderer</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">RendererPlugin</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Example plugin that adds syntax highlighting to code blocks.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_supported_types</span><span style=\"color:#E1E4E8\">(self) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">'CODE_BLOCK'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> render_node</span><span style=\"color:#E1E4E8\">(self, node: ASTNode, context: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # This is a simplified example - real syntax highlighting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # would integrate with libraries like Pygments</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        language </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> node.get_attribute(</span><span style=\"color:#9ECBFF\">'language'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        content </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.escape_html(node.get_attribute(</span><span style=\"color:#9ECBFF\">'content'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">''</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> language:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">'&#x3C;pre>&#x3C;code class=\"language-</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">language</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> highlighted\"></span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">content</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">&#x3C;/code>&#x3C;/pre>'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">'&#x3C;pre>&#x3C;code class=\"highlighted\"></span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">content</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">&#x3C;/code>&#x3C;/pre>'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> escape_html</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Simple HTML escaping for code content.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (text.replace(</span><span style=\"color:#9ECBFF\">'&#x26;'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'&#x26;amp;'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   .replace(</span><span style=\"color:#9ECBFF\">'&#x3C;'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'&#x26;lt;'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   .replace(</span><span style=\"color:#9ECBFF\">'>'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'&#x26;gt;'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   .replace(</span><span style=\"color:#9ECBFF\">'\"'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'&#x26;quot;'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                   .replace(</span><span style=\"color:#9ECBFF\">\"'\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'&#x26;#x27;'</span><span style=\"color:#E1E4E8\">))</span></span></code></pre></div>\n\n<h3 id=\"milestone-checkpoint\">Milestone Checkpoint</h3>\n<p>After implementing the HTML generator, verify your implementation with these checkpoints:</p>\n<ol>\n<li><p><strong>Basic HTML Generation Test</strong>: Create a simple AST with a paragraph containing text and verify it generates <code>&lt;p&gt;escaped text content&lt;/p&gt;</code>.</p>\n</li>\n<li><p><strong>Escaping Verification</strong>: Test that input containing <code>&lt;script&gt;</code> and other HTML special characters are properly escaped in the output.</p>\n</li>\n<li><p><strong>Self-Closing Tags Test</strong>: Verify that <code>&lt;hr&gt;</code> elements are generated without closing tags and <code>&lt;img&gt;</code> elements have proper <code>src</code> and <code>alt</code> attributes.</p>\n</li>\n<li><p><strong>Pretty Printing Test</strong>: Generate HTML with pretty printing enabled and verify consistent indentation and line breaks.</p>\n</li>\n<li><p><strong>Plugin System Test</strong>: Register a custom renderer for headings and verify it&#39;s called instead of the default renderer.</p>\n</li>\n</ol>\n<p>Expected output for a basic test case:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">html</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#85E89D\">h1</span><span style=\"color:#E1E4E8\">>Test Heading&#x3C;/</span><span style=\"color:#85E89D\">h1</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#85E89D\">p</span><span style=\"color:#E1E4E8\">>This is a paragraph with &#x3C;</span><span style=\"color:#85E89D\">strong</span><span style=\"color:#E1E4E8\">>bold text&#x3C;/</span><span style=\"color:#85E89D\">strong</span><span style=\"color:#E1E4E8\">> and a &#x3C;</span><span style=\"color:#85E89D\">a</span><span style=\"color:#B392F0\"> href</span><span style=\"color:#E1E4E8\">=</span><span style=\"color:#9ECBFF\">\"http://example.com\"</span><span style=\"color:#E1E4E8\">>link&#x3C;/</span><span style=\"color:#85E89D\">a</span><span style=\"color:#E1E4E8\">>.&#x3C;/</span><span style=\"color:#85E89D\">p</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#85E89D\">hr</span><span style=\"color:#E1E4E8\">></span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">&#x3C;</span><span style=\"color:#85E89D\">pre</span><span style=\"color:#E1E4E8\">>&#x3C;</span><span style=\"color:#85E89D\">code</span><span style=\"color:#B392F0\"> class</span><span style=\"color:#E1E4E8\">=</span><span style=\"color:#9ECBFF\">\"language-python\"</span><span style=\"color:#E1E4E8\">>print(\"Hello, world!\")&#x3C;/</span><span style=\"color:#85E89D\">code</span><span style=\"color:#E1E4E8\">>&#x3C;/</span><span style=\"color:#85E89D\">pre</span><span style=\"color:#E1E4E8\">></span></span></code></pre></div>\n\n<h3 id=\"debugging-tips\">Debugging Tips</h3>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Output contains <code>&amp;amp;lt;</code> instead of <code>&amp;lt;</code></td>\n<td>Double-escaping of content</td>\n<td>Check if content is escaped multiple times</td>\n<td>Apply escaping only once during HTML generation</td>\n</tr>\n<tr>\n<td>Invalid HTML with <code>&lt;hr&gt;&lt;/hr&gt;</code> tags</td>\n<td>Self-closing elements getting closing tags</td>\n<td>Verify void element list and tag generation logic</td>\n<td>Add proper self-closing tag detection</td>\n</tr>\n<tr>\n<td>Missing spaces between inline elements</td>\n<td>Pretty printer removing semantic whitespace</td>\n<td>Compare pretty-printed vs minified output</td>\n<td>Preserve whitespace around inline boundaries</td>\n</tr>\n<tr>\n<td>Links or images not working</td>\n<td>Unescaped or invalid URLs in attributes</td>\n<td>Inspect generated <code>href</code> and <code>src</code> attributes</td>\n<td>Apply proper URL validation and attribute escaping</td>\n</tr>\n<tr>\n<td>Plugin not being called</td>\n<td>Registration or dispatch logic issues</td>\n<td>Add debug logging to plugin manager</td>\n<td>Verify plugin registration and node type matching</td>\n</tr>\n<tr>\n<td>Malformed nested HTML</td>\n<td>Incorrect tree traversal or tag matching</td>\n<td>Print AST structure and trace rendering order</td>\n<td>Fix recursive child rendering and tag pairing</td>\n</tr>\n</tbody></table>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation</p>\n</blockquote>\n<h3 id=\"the-orchestra-conductor-mental-model\">The Orchestra Conductor Mental Model</h3>\n<p>Think of the markdown parsing pipeline like a symphony orchestra performing a complex piece. Each component—the block parser, inline parser, and HTML generator—is like a different section of the orchestra (strings, woodwinds, brass). The <code>MarkdownParser</code> acts as the conductor, coordinating when each section plays and ensuring the data flows smoothly from one to the next. Just as the conductor ensures the violins finish their phrase before the trumpets begin, the parser ensures each phase completes and passes clean, well-structured data to the next phase. The AST serves as the musical score—a shared representation that all components can read and contribute to.</p>\n<p>The beauty of this orchestrated approach is that each component can focus on its specialized task without worrying about the complexities of other phases. The block parser doesn&#39;t need to understand emphasis rules, just as the first violin doesn&#39;t need to know the tuba part. But through careful coordination and clear interfaces, they work together to create something beautiful and coherent.</p>\n<h3 id=\"complete-parsing-pipeline\">Complete Parsing Pipeline</h3>\n<p>The markdown parsing pipeline transforms raw text through four distinct phases, each building upon the work of the previous phase. This sequential approach mirrors how humans naturally process documents—first identifying the major structural elements, then focusing on the formatting details within those structures.</p>\n<h4 id=\"pipeline-phase-overview\">Pipeline Phase Overview</h4>\n<p>The complete transformation follows this sequence:</p>\n<ol>\n<li><strong>Preprocessing Phase</strong>: Raw markdown text undergoes normalization to ensure consistent line endings, tab expansion, and basic structural analysis</li>\n<li><strong>Block Parsing Phase</strong>: Normalized text is analyzed line-by-line to identify and construct block-level elements like headings, paragraphs, and code blocks</li>\n<li><strong>Inline Parsing Phase</strong>: Text content within block elements is processed to identify and construct inline formatting like emphasis, links, and inline code</li>\n<li><strong>HTML Generation Phase</strong>: The completed AST is traversed to generate clean, properly escaped HTML output</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Phase</th>\n<th>Input Format</th>\n<th>Output Format</th>\n<th>Primary Responsibility</th>\n<th>State Maintained</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Preprocessing</td>\n<td>Raw string</td>\n<td>List of <code>LineInfo</code> objects</td>\n<td>Text normalization, line analysis</td>\n<td>None (stateless)</td>\n</tr>\n<tr>\n<td>Block Parsing</td>\n<td><code>LineInfo</code> objects</td>\n<td>AST with block structure</td>\n<td>Block element identification</td>\n<td><code>BlockParserState</code>, current block context</td>\n</tr>\n<tr>\n<td>Inline Parsing</td>\n<td>Block nodes with raw text</td>\n<td>AST with inline elements</td>\n<td>Inline formatting identification</td>\n<td><code>DelimiterStack</code>, escape processing state</td>\n</tr>\n<tr>\n<td>HTML Generation</td>\n<td>Complete AST</td>\n<td>HTML string</td>\n<td>Tree traversal and HTML generation</td>\n<td>Rendering context, indentation state</td>\n</tr>\n</tbody></table>\n<h4 id=\"detailed-pipeline-flow\">Detailed Pipeline Flow</h4>\n<p><strong>Preprocessing Phase</strong>: The <code>Preprocessor</code> receives the raw markdown text and performs essential normalization operations. It calls <code>normalize_line_endings()</code> to convert all line endings to Unix format, ensuring consistent behavior across platforms. The <code>split_into_lines()</code> function then breaks the text into individual lines while preserving line number information for error reporting. Each line is analyzed using <code>is_blank_line()</code> and <code>get_indentation_level()</code> to create rich <code>LineInfo</code> objects that carry both content and metadata.</p>\n<blockquote>\n<p>The preprocessing phase is crucial because it establishes the foundation for all subsequent parsing. By normalizing text encoding and capturing structural metadata early, we prevent countless edge cases that would otherwise plague the parsing phases.</p>\n</blockquote>\n<p><strong>Block Parsing Phase</strong>: The block parser processes the <code>LineInfo</code> sequence through a state machine that identifies block-level structures. It maintains a <code>BlockParserState</code> that tracks whether it&#39;s currently inside a paragraph, code block, blockquote, or looking for a new block to start. The parser calls <code>peek_next_line()</code> to look ahead when necessary, particularly for Setext headings that require examining the following line. Each line triggers either <code>can_current_block_continue()</code> to extend the current block or one of the <code>try_start_*_block()</code> methods to begin a new block type.</p>\n<p>The block parser builds the AST incrementally, creating <code>BlockNode</code> instances and establishing parent-child relationships through the <code>add_child()</code> method. When a block is complete, <code>finalize_current_block()</code> processes any remaining content and adds the block to the document tree.</p>\n<p><strong>Inline Parsing Phase</strong>: Once the block structure is established, the inline parser processes the text content within each block element. It operates on individual text spans, typically paragraph content or heading text, using <code>parse_inline_elements()</code> as the main entry point. The parser maintains a <code>DelimiterStack</code> to track potential formatting markers as it scans through the text character by character.</p>\n<p>When the parser encounters potential delimiters like asterisks or underscores, it uses <code>detect_flanking_properties()</code> to determine whether the delimiter can open or close emphasis. The <code>find_matching_opener()</code> function searches back through the delimiter stack to find valid emphasis pairs. Links and images are handled through the <code>LinkImageParser</code>, which uses specialized regex patterns to extract URLs and alt text.</p>\n<p><strong>HTML Generation Phase</strong>: The final phase traverses the complete AST using depth-first traversal to generate HTML output. The <code>HtmlRenderer</code> calls <code>render_node()</code> for each AST node, which delegates to specialized methods like <code>render_block_node()</code> and <code>render_inline_node()</code> based on the node type. The <code>HtmlEscaper</code> ensures all text content is properly escaped using <code>escape_html()</code>, while <code>generate_tag()</code> creates well-formed HTML elements with appropriate attributes.</p>\n<h4 id=\"pipeline-error-handling-and-recovery\">Pipeline Error Handling and Recovery</h4>\n<p>Each phase implements graceful degradation when encountering malformed input. The preprocessing phase handles unusual line ending combinations and encoding issues by falling back to best-effort normalization. The block parser implements error recovery by treating unrecognized input as plain paragraph content. The inline parser handles mismatched delimiters by treating them as literal text. The HTML generator ensures output is always valid HTML, even when the AST contains unexpected structures.</p>\n<table>\n<thead>\n<tr>\n<th>Error Scenario</th>\n<th>Detection Phase</th>\n<th>Recovery Strategy</th>\n<th>Output Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Invalid UTF-8 sequences</td>\n<td>Preprocessing</td>\n<td>Replace with Unicode replacement character</td>\n<td>Minimal - content preserved</td>\n</tr>\n<tr>\n<td>Unclosed code fences</td>\n<td>Block parsing</td>\n<td>Treat as paragraph content</td>\n<td>Moderate - formatting lost but readable</td>\n</tr>\n<tr>\n<td>Mismatched emphasis delimiters</td>\n<td>Inline parsing</td>\n<td>Render delimiters as literal text</td>\n<td>Minimal - content fully preserved</td>\n</tr>\n<tr>\n<td>Malformed link syntax</td>\n<td>Inline parsing</td>\n<td>Render as plain text</td>\n<td>Minimal - text content preserved</td>\n</tr>\n<tr>\n<td>Missing AST node types</td>\n<td>HTML generation</td>\n<td>Render as plain text with warning</td>\n<td>Low - graceful fallback</td>\n</tr>\n</tbody></table>\n<h4 id=\"data-flow-contracts-between-phases\">Data Flow Contracts Between Phases</h4>\n<p>Each pipeline phase establishes clear contracts for the data it receives and produces. These contracts ensure that phases can evolve independently while maintaining system integrity.</p>\n<p><strong>Preprocessing → Block Parsing Contract</strong>: The preprocessor guarantees that line endings are normalized, tab characters are expanded to spaces using <code>expand_tabs_to_spaces()</code>, and each <code>LineInfo</code> object contains accurate <code>line_number</code>, <code>content</code>, <code>is_blank</code>, and <code>indent_level</code> fields. The block parser can rely on this normalized format and doesn&#39;t need to handle platform-specific text variations.</p>\n<p><strong>Block Parsing → Inline Parsing Contract</strong>: The block parser guarantees that the AST contains a valid tree structure with proper parent-child relationships established through <code>add_child()</code> calls. Each <code>BlockNode</code> contains raw text content in its <code>inline_content</code> field that represents the content to be processed for inline elements. List items, headings, and paragraph blocks all provide their text content in a consistent format that the inline parser can process uniformly.</p>\n<p><strong>Inline Parsing → HTML Generation Contract</strong>: The inline parser guarantees that all text content within block elements has been fully processed for inline formatting. The AST contains a complete representation of the document structure, with <code>InlineNode</code> instances properly nested within their containing blocks. The HTML generator can traverse this tree without needing to understand markdown syntax, focusing purely on HTML generation concerns.</p>\n<h3 id=\"component-interface-contracts\">Component Interface Contracts</h3>\n<p>The parsing pipeline depends on well-defined interfaces between components to maintain modularity and enable independent testing. These contracts specify not just method signatures but also preconditions, postconditions, and behavioral guarantees.</p>\n<h4 id=\"markdownparser-primary-interface\">MarkdownParser Primary Interface</h4>\n<p>The <code>MarkdownParser</code> serves as the main orchestrator, providing the primary entry points that applications use to transform markdown text into HTML.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n<th>Preconditions</th>\n<th>Postconditions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>parse_to_html</code></td>\n<td><code>markdown_text: str</code></td>\n<td><code>str</code></td>\n<td>Complete markdown to HTML transformation</td>\n<td>Text must be valid Unicode string</td>\n<td>Returns valid HTML5 document fragment</td>\n</tr>\n<tr>\n<td><code>parse_file</code></td>\n<td><code>file_path: str</code></td>\n<td><code>str</code></td>\n<td>File-based parsing with error handling</td>\n<td>File must exist and be readable</td>\n<td>Returns HTML or raises IOException</td>\n</tr>\n<tr>\n<td><code>debug_print_ast</code></td>\n<td><code>node: ASTNode, indent: int</code></td>\n<td><code>None</code></td>\n<td>Display AST structure for debugging</td>\n<td>Node must be valid AST structure</td>\n<td>Prints tree to stdout</td>\n</tr>\n</tbody></table>\n<p>The <code>parse_to_html()</code> method orchestrates the entire pipeline. It first calls the preprocessor&#39;s <code>process_input()</code> method to normalize the input text. The resulting <code>LineInfo</code> objects are passed to the block parser&#39;s <code>parse_blocks()</code> method, which returns an AST with block structure. Each block node&#39;s text content is then processed by the inline parser&#39;s <code>parse_inline_elements()</code> method. Finally, the complete AST is passed to the HTML generator&#39;s <code>render_to_html()</code> method.</p>\n<blockquote>\n<p><strong>Decision: Sequential Pipeline Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: We need to coordinate multiple parsing phases that have dependencies on each other&#39;s output</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Monolithic parser that handles all concerns simultaneously</li>\n<li>Sequential pipeline with clear phase boundaries</li>\n<li>Concurrent pipeline with synchronization points</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Sequential pipeline with clear phase boundaries</li>\n<li><strong>Rationale</strong>: Block parsing must complete before inline parsing can begin, since inline parsing depends on knowing the block context. This natural dependency makes sequential processing the most straightforward approach. The overhead of multiple passes is minimal compared to the complexity savings.</li>\n<li><strong>Consequences</strong>: Enables clear separation of concerns and independent testing of each phase, but requires multiple passes through the document structure</li>\n</ul>\n</blockquote>\n<h4 id=\"preprocessor-interface-contract\">Preprocessor Interface Contract</h4>\n<p>The <code>Preprocessor</code> provides text normalization services that prepare raw markdown for block parsing. This component handles platform differences and encoding issues that would otherwise complicate the parsing phases.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n<th>Guarantees</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>process_input</code></td>\n<td><code>text: str</code></td>\n<td><code>List[LineInfo]</code></td>\n<td>Convert raw text to analyzed lines</td>\n<td>Line endings normalized, indentation calculated</td>\n</tr>\n<tr>\n<td><code>normalize_line_endings</code></td>\n<td><code>text: str</code></td>\n<td><code>str</code></td>\n<td>Convert all line endings to Unix format</td>\n<td>Only \\n line endings in output</td>\n</tr>\n<tr>\n<td><code>split_into_lines</code></td>\n<td><code>text: str</code></td>\n<td><code>List[str]</code></td>\n<td>Split text preserving empty lines</td>\n<td>Line count preserved, no content lost</td>\n</tr>\n<tr>\n<td><code>expand_tabs_to_spaces</code></td>\n<td><code>text: str, tab_width: int</code></td>\n<td><code>str</code></td>\n<td>Convert tabs to spaces</td>\n<td>Tab stops respect CommonMark spec</td>\n</tr>\n</tbody></table>\n<p>The <code>process_input()</code> method serves as the main entry point, combining all normalization operations into a single call. It ensures that downstream components receive consistent, well-formed input regardless of the original text encoding or platform conventions.</p>\n<h4 id=\"block-parser-interface-contract\">Block Parser Interface Contract</h4>\n<p>The block parser transforms normalized text into an AST representing the document&#39;s block structure. This component implements the most complex parsing logic, handling state transitions and lookahead requirements.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n<th>State Changes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>parse_blocks</code></td>\n<td><code>markdown_text: str</code></td>\n<td><code>ASTNode</code></td>\n<td>Main block parsing entry point</td>\n<td>Creates new parser state</td>\n</tr>\n<tr>\n<td><code>process_line_sequence</code></td>\n<td><code>lines: List[LineInfo]</code></td>\n<td><code>None</code></td>\n<td>Process lines through state machine</td>\n<td>Updates <code>BlockParserState</code></td>\n</tr>\n<tr>\n<td><code>peek_next_line</code></td>\n<td>None</td>\n<td><code>Optional[LineInfo]</code></td>\n<td>Look ahead without consuming</td>\n<td>No state changes</td>\n</tr>\n<tr>\n<td><code>can_current_block_continue</code></td>\n<td><code>line: LineInfo</code></td>\n<td><code>bool</code></td>\n<td>Check if line extends current block</td>\n<td>No state changes</td>\n</tr>\n<tr>\n<td><code>try_start_heading_block</code></td>\n<td><code>line: LineInfo</code></td>\n<td><code>bool</code></td>\n<td>Attempt to create heading block</td>\n<td>May create new block</td>\n</tr>\n<tr>\n<td><code>try_start_code_block</code></td>\n<td><code>line: LineInfo</code></td>\n<td><code>bool</code></td>\n<td>Attempt to create code block</td>\n<td>May create new block</td>\n</tr>\n<tr>\n<td><code>try_start_blockquote</code></td>\n<td><code>line: LineInfo</code></td>\n<td><code>bool</code></td>\n<td>Attempt to create blockquote</td>\n<td>May create new block</td>\n</tr>\n<tr>\n<td><code>try_start_horizontal_rule</code></td>\n<td><code>line: LineInfo</code></td>\n<td><code>bool</code></td>\n<td>Attempt to create horizontal rule</td>\n<td>May create new block</td>\n</tr>\n<tr>\n<td><code>start_paragraph_block</code></td>\n<td><code>line: LineInfo</code></td>\n<td><code>None</code></td>\n<td>Start paragraph with given line</td>\n<td>Creates paragraph block</td>\n</tr>\n<tr>\n<td><code>continue_current_block</code></td>\n<td><code>line: LineInfo</code></td>\n<td><code>None</code></td>\n<td>Add line to active block</td>\n<td>Updates current block content</td>\n</tr>\n<tr>\n<td><code>finalize_current_block</code></td>\n<td>None</td>\n<td><code>None</code></td>\n<td>Complete current block</td>\n<td>Adds block to AST, resets state</td>\n</tr>\n</tbody></table>\n<p>The block parser maintains internal state through the <code>BlockParserState</code> enum, which tracks whether the parser is looking for a new block, continuing a paragraph, or inside a specialized block like a code block or blockquote. The <code>try_start_*_block()</code> methods implement the block recognition logic, checking line patterns against the various block type signatures defined in the CommonMark specification.</p>\n<blockquote>\n<p>The block parser&#39;s lookahead capability through <code>peek_next_line()</code> is essential for handling Setext headings, where a line&#39;s meaning depends on the following line. This lookahead is implemented without consuming the line from the input stream, allowing the parser to make decisions while preserving the sequential processing model.</p>\n</blockquote>\n<h4 id=\"inline-parser-interface-contract\">Inline Parser Interface Contract</h4>\n<p>The inline parser processes text content within block elements to identify and construct inline formatting elements. This component handles the complex delimiter matching required for nested emphasis and link parsing.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n<th>State Management</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>parse_inline_elements</code></td>\n<td><code>text: str</code></td>\n<td><code>List[InlineNode]</code></td>\n<td>Main inline parsing entry point</td>\n<td>Creates fresh delimiter stack</td>\n</tr>\n<tr>\n<td><code>process_escapes</code></td>\n<td><code>text: str</code></td>\n<td><code>Tuple[str, List[int]]</code></td>\n<td>Process escape sequences</td>\n<td>Returns processed text and positions</td>\n</tr>\n<tr>\n<td><code>detect_flanking_properties</code></td>\n<td><code>text: str, pos: int, delimiter_len: int</code></td>\n<td><code>Tuple[bool, bool]</code></td>\n<td>Detect opener/closer capability</td>\n<td>No state changes</td>\n</tr>\n<tr>\n<td><code>find_matching_opener</code></td>\n<td><code>closer: Delimiter</code></td>\n<td><code>Optional[Tuple[int, Delimiter]]</code></td>\n<td>Find matching emphasis opener</td>\n<td>Searches delimiter stack</td>\n</tr>\n<tr>\n<td><code>can_open_emphasis</code></td>\n<td><code>char: str, left_flanking: bool, right_flanking: bool, before_char: str, after_char: str</code></td>\n<td><code>bool</code></td>\n<td>Check if delimiter can open</td>\n<td>Uses flanking detection rules</td>\n</tr>\n<tr>\n<td><code>can_close_emphasis</code></td>\n<td><code>char: str, left_flanking: bool, right_flanking: bool, before_char: str, after_char: str</code></td>\n<td><code>bool</code></td>\n<td>Check if delimiter can close</td>\n<td>Uses flanking detection rules</td>\n</tr>\n</tbody></table>\n<p>The inline parser uses a <code>DelimiterStack</code> to track potential formatting markers as it processes text character by character. When it encounters asterisks, underscores, or other delimiter characters, it pushes them onto the stack with metadata about their flanking properties. When it finds potential closing delimiters, it searches backward through the stack to find matching openers.</p>\n<p>The <code>LinkImageParser</code> component handles the complex regular expression matching required for link and image syntax. It maintains compiled patterns for URL detection and title extraction, ensuring efficient processing of link-heavy documents.</p>\n<h4 id=\"html-generator-interface-contract\">HTML Generator Interface Contract</h4>\n<p>The HTML generator traverses the completed AST to produce clean, well-formatted HTML output. This component handles HTML escaping, tag generation, and pretty printing concerns.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n<th>Output Guarantees</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>render_to_html</code></td>\n<td><code>ast_root: ASTNode</code></td>\n<td><code>str</code></td>\n<td>Main HTML generation entry point</td>\n<td>Valid HTML5 fragment</td>\n</tr>\n<tr>\n<td><code>render_node</code></td>\n<td><code>node: ASTNode</code></td>\n<td><code>str</code></td>\n<td>Render single AST node</td>\n<td>Properly escaped HTML</td>\n</tr>\n<tr>\n<td><code>render_block_node</code></td>\n<td><code>node: BlockNode</code></td>\n<td><code>str</code></td>\n<td>Render block-level elements</td>\n<td>Block-level HTML tags</td>\n</tr>\n<tr>\n<td><code>render_inline_node</code></td>\n<td><code>node: InlineNode</code></td>\n<td><code>str</code></td>\n<td>Render inline elements</td>\n<td>Inline HTML tags</td>\n</tr>\n<tr>\n<td><code>render_text_node</code></td>\n<td><code>node: ASTNode</code></td>\n<td><code>str</code></td>\n<td>Render plain text with escaping</td>\n<td>HTML entity escaped text</td>\n</tr>\n<tr>\n<td><code>render_children</code></td>\n<td><code>node: ASTNode</code></td>\n<td><code>str</code></td>\n<td>Render all child nodes</td>\n<td>Concatenated child HTML</td>\n</tr>\n<tr>\n<td><code>generate_tag</code></td>\n<td><code>tag_name: str, attributes: dict, self_closing: bool</code></td>\n<td><code>Tuple[str, str]</code></td>\n<td>Create HTML tag pair</td>\n<td>Well-formed opening/closing tags</td>\n</tr>\n<tr>\n<td><code>escape_html</code></td>\n<td><code>text: str</code></td>\n<td><code>str</code></td>\n<td>Escape special characters</td>\n<td>HTML entity escaped output</td>\n</tr>\n<tr>\n<td><code>escape_html_attribute</code></td>\n<td><code>value: str</code></td>\n<td><code>str</code></td>\n<td>Escape attribute values</td>\n<td>Attribute-safe escaped text</td>\n</tr>\n<tr>\n<td><code>format_html</code></td>\n<td><code>html: str, indent_size: int</code></td>\n<td><code>str</code></td>\n<td>Pretty print HTML output</td>\n<td>Indented, formatted HTML</td>\n</tr>\n</tbody></table>\n<p>The HTML generator implements the visitor pattern for tree traversal, calling the appropriate <code>render_*_node()</code> method based on each node&#39;s type. The <code>HtmlEscaper</code> component handles the critical security concern of properly escaping user content to prevent HTML injection attacks.</p>\n<blockquote>\n<p><strong>Decision: Visitor Pattern for HTML Generation</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to traverse an AST with multiple node types and generate appropriate HTML for each type</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Switch statement based on node type in single method</li>\n<li>Visitor pattern with specialized methods for each node type</li>\n<li>Node-specific render methods on each AST node class</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Visitor pattern with specialized render methods</li>\n<li><strong>Rationale</strong>: Keeps rendering logic centralized in the HTML generator while allowing easy extension for new node types. Avoids polluting AST nodes with rendering concerns.</li>\n<li><strong>Consequences</strong>: Clear separation of concerns and easy testing, but requires coordinated changes when adding new node types</li>\n</ul>\n</blockquote>\n<h4 id=\"plugin-and-extension-interface\">Plugin and Extension Interface</h4>\n<p>The HTML generator supports customization through a plugin interface that allows users to override rendering behavior for specific node types.</p>\n<table>\n<thead>\n<tr>\n<th>Method Name</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n<th>Extension Point</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>register_plugin</code></td>\n<td><code>plugin: RendererPlugin</code></td>\n<td><code>None</code></td>\n<td>Register custom renderer plugin</td>\n<td>Adds to plugin registry</td>\n</tr>\n<tr>\n<td><code>register_node_renderer</code></td>\n<td><code>node_type: str, renderer: NodeRenderer</code></td>\n<td><code>None</code></td>\n<td>Register simple node renderer</td>\n<td>Overrides default rendering</td>\n</tr>\n<tr>\n<td><code>has_renderer</code></td>\n<td><code>node_type: str</code></td>\n<td><code>bool</code></td>\n<td>Check for custom renderer</td>\n<td>Query capability</td>\n</tr>\n</tbody></table>\n<p>The <code>PluginManager</code> maintains a registry of custom renderers that can override the default HTML generation for specific node types. This allows applications to customize output format (e.g., generating LaTeX instead of HTML) or add special handling for domain-specific markdown extensions.</p>\n<h4 id=\"error-propagation-and-recovery-contracts\">Error Propagation and Recovery Contracts</h4>\n<p>Each component defines clear error handling contracts that specify when errors are recoverable versus when they should propagate to the caller.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Recoverable Errors</th>\n<th>Non-Recoverable Errors</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Preprocessor</td>\n<td>Unusual line endings, mixed encodings</td>\n<td>Invalid UTF-8, null input</td>\n<td>Best-effort normalization</td>\n</tr>\n<tr>\n<td>Block Parser</td>\n<td>Unclosed blocks, invalid syntax</td>\n<td>Null input, corrupted AST</td>\n<td>Treat as paragraph content</td>\n</tr>\n<tr>\n<td>Inline Parser</td>\n<td>Mismatched delimiters, malformed links</td>\n<td>Null text, invalid AST nodes</td>\n<td>Render as literal text</td>\n</tr>\n<tr>\n<td>HTML Generator</td>\n<td>Unknown node types, missing attributes</td>\n<td>Null AST, circular references</td>\n<td>Default rendering with warnings</td>\n</tr>\n</tbody></table>\n<p>This error handling strategy ensures that the parser exhibits graceful degradation—it always produces some meaningful output, even when the input contains syntax errors or unexpected constructs.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Implementation</th>\n<th>Advanced Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Main Parser</td>\n<td>Single class with delegation methods</td>\n<td>Factory pattern with dependency injection</td>\n</tr>\n<tr>\n<td>AST Representation</td>\n<td>Simple dataclass/struct with lists</td>\n<td>Immutable nodes with persistent data structures</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Exception propagation with try/catch</td>\n<td>Result/Either types with error accumulation</td>\n</tr>\n<tr>\n<td>Plugin System</td>\n<td>Dictionary of callable functions</td>\n<td>Full plugin architecture with lifecycle management</td>\n</tr>\n<tr>\n<td>Testing Infrastructure</td>\n<td>unittest with manual test data</td>\n<td>Property-based testing with generated inputs</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>markdown_renderer/\n  __init__.py                    ← Public API exports\n  parser.py                      ← Main MarkdownParser class\n  preprocessor.py                ← Text normalization utilities\n  ast_nodes.py                   ← AST node type definitions\n  block_parser.py               ← Block parsing implementation\n  inline_parser.py              ← Inline parsing implementation\n  html_generator.py             ← HTML generation and rendering\n  plugins/\n    __init__.py                 ← Plugin interface definitions\n    base_plugin.py              ← Abstract base classes\n  utils/\n    __init__.py\n    line_info.py                ← LineInfo and text utilities\n    html_escaping.py            ← HTML escaping utilities\n    constants.py                ← Regex patterns and constants\n  tests/\n    test_integration.py         ← End-to-end pipeline tests\n    test_parser_orchestration.py ← Component interaction tests\n    test_error_handling.py      ← Error recovery tests</code></pre></div>\n\n<h4 id=\"main-parser-infrastructure-code\">Main Parser Infrastructure Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># parser.py - Complete main orchestrator implementation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, List, Union, Protocol</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .preprocessor </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Preprocessor</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .block_parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BlockParser</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .inline_parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> InlineParser</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .html_generator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> HtmlRenderer</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .ast_nodes </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ASTNode, NodeType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .utils.line_info </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LineInfo</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MarkdownParser</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Main parser that orchestrates the complete markdown to HTML pipeline.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 pretty_print: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 enable_plugins: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Initialize the markdown parser with component dependencies.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            pretty_print: Whether to format HTML output with indentation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            enable_plugins: Whether to load and enable plugin system</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.preprocessor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Preprocessor()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.block_parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BlockParser()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.inline_parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> InlineParser()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.html_generator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> HtmlRenderer(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            pretty_print</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">pretty_print,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            custom_renderers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{} </span><span style=\"color:#F97583\">if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> enable_plugins </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_to_html</span><span style=\"color:#E1E4E8\">(self, markdown_text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Transform markdown text to HTML through complete pipeline.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            markdown_text: Raw markdown content as Unicode string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Valid HTML5 document fragment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ValueError: If input is None or contains invalid UTF-8</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> markdown_text </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Markdown text cannot be None\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Phase 1: Preprocess and normalize input</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            line_info_list </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.preprocessor.process_input(markdown_text)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Phase 2: Parse block structure</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ast_root </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.block_parser.parse_blocks(line_info_list)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Phase 3: Parse inline elements within blocks</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._process_inline_content(ast_root)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Phase 4: Generate HTML output</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.html_generator.render_to_html(ast_root)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Log error and attempt graceful degradation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"&#x3C;p>Error processing markdown: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">._escape_error_message(</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(e))</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">&#x3C;/p>\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_file</span><span style=\"color:#E1E4E8\">(self, file_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Parse markdown file and return HTML.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            file_path: Path to markdown file</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            HTML string or error message</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            IOError: If file cannot be read</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(file_path, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">encoding</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                content </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> f.read()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.parse_to_html(content)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> IOError</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> IOError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Cannot read file </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">file_path</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> debug_print_ast</span><span style=\"color:#E1E4E8\">(self, node: ASTNode, indent: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Print AST structure for debugging purposes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node: Root node to print</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            indent: Current indentation level</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        indent_str </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"  \"</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> indent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        node_info </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node.node_type.value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'block_type'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            node_info </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\" (</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node.block_type.value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'inline_type'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            node_info </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\" (</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">node.inline_type.value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">)\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">indent_str</span><span style=\"color:#79B8FF\">}{</span><span style=\"color:#E1E4E8\">node_info</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> node.children:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.debug_print_ast(child, indent </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _process_inline_content</span><span style=\"color:#E1E4E8\">(self, ast_root: ASTNode) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Process inline content for all applicable block nodes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Traverse AST using depth_first_walk with inline processing visitor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each block node, check if it contains inline content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Call inline_parser.parse_inline_elements on block's text content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Replace block's text content with parsed inline node children</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle error cases where inline parsing fails</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _escape_error_message</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Escape error message for safe HTML inclusion.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> (message.replace(</span><span style=\"color:#9ECBFF\">'&#x26;'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'&#x26;amp;'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                      .replace(</span><span style=\"color:#9ECBFF\">'&#x3C;'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'&#x26;lt;'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                      .replace(</span><span style=\"color:#9ECBFF\">'>'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'&#x26;gt;'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                      .replace(</span><span style=\"color:#9ECBFF\">'\"'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'&#x26;quot;'</span><span style=\"color:#E1E4E8\">))</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Public API convenience functions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse_to_html</span><span style=\"color:#E1E4E8\">(markdown_text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, pretty_print: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convenience function for simple markdown to HTML conversion.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> MarkdownParser(</span><span style=\"color:#FFAB70\">pretty_print</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">pretty_print)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> parser.parse_to_html(markdown_text)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parse_file</span><span style=\"color:#E1E4E8\">(file_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, pretty_print: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Convenience function for file-based markdown conversion.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> MarkdownParser(</span><span style=\"color:#FFAB70\">pretty_print</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">pretty_print)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> parser.parse_file(file_path)</span></span></code></pre></div>\n\n<p><img src=\"/api/project/markdown-renderer/architecture-doc/asset?path=diagrams%2Fsystem-components.svg\" alt=\"System Component Architecture\"></p>\n<h4 id=\"pipeline-orchestration-skeleton\">Pipeline Orchestration Skeleton</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># pipeline.py - Core pipeline coordination logic (implement this)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Iterator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .ast_nodes </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ASTNode, BlockNode, NodeType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .utils.line_info </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LineInfo</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PipelineOrchestrator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Coordinates the flow of data between parsing phases.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> execute_complete_pipeline</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                 raw_text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                 preprocessor,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                 block_parser,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                 inline_parser,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                 html_generator) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute complete parsing pipeline with error recovery.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        This is the core implementation you need to complete.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate input text is not None/empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call preprocessor.process_input() to get LineInfo list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Call block_parser.parse_blocks() with LineInfo list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Walk through AST calling process_block_inline_content()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Call html_generator.render_to_html() on completed AST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Handle any exceptions with graceful degradation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return final HTML string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> process_block_inline_content</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                   block_node: BlockNode, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                   inline_parser) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Process inline content within a single block node.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if block_node has inline_content field</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Skip processing if content is empty or None</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Call inline_parser.parse_inline_elements() on content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add returned InlineNode objects as children to block_node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Clear the inline_content field since it's now parsed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Recursively process any child blocks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_pipeline_state</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               ast_root: ASTNode) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate AST structure before HTML generation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check that ast_root is not None and has valid node_type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Verify all BlockNode objects have either children or content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify all parent-child relationships are bidirectional</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check for circular references in AST structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return list of validation errors (empty list if valid)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><img src=\"/api/project/markdown-renderer/architecture-doc/asset?path=diagrams%2Fparsing-pipeline-flow.svg\" alt=\"Complete Parsing Pipeline Flow\"></p>\n<h4 id=\"error-recovery-infrastructure\">Error Recovery Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># error_recovery.py - Complete error handling utilities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Any, List, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorSeverity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WARNING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"warning\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"error\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CRITICAL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"critical\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Structured representation of parsing errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 line_number: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 column: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 severity: ErrorSeverity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ErrorSeverity.</span><span style=\"color:#79B8FF\">ERROR</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.line_number </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> line_number</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.column </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> column</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.severity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> severity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __str__</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        location </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.line_number </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            location </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\" at line </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.line_number</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.column </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                location </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\", column </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.column</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.severity.value.upper()</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.message</span><span style=\"color:#79B8FF\">}{</span><span style=\"color:#E1E4E8\">location</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorCollector</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Collects and manages parsing errors during pipeline execution.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.errors: List[ParseError] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_error</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  line_number: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  column: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  severity: ErrorSeverity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ErrorSeverity.</span><span style=\"color:#79B8FF\">ERROR</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add a parsing error to the collection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        error </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ParseError(message, line_number, column, severity)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.errors.append(error)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.logger.log(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._severity_to_log_level(severity), </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(error))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> has_critical_errors</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if any critical errors were collected.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> any</span><span style=\"color:#E1E4E8\">(error.severity </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> ErrorSeverity.</span><span style=\"color:#79B8FF\">CRITICAL</span><span style=\"color:#F97583\"> for</span><span style=\"color:#E1E4E8\"> error </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.errors)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_error_summary</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate human-readable error summary.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.errors:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#9ECBFF\"> \"No errors\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        summary </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Found </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.errors)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> parsing issues:</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> error </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.errors:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            summary </span><span style=\"color:#F97583\">+=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"  - </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">error</span><span style=\"color:#79B8FF\">}\\n</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> summary</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _severity_to_log_level</span><span style=\"color:#E1E4E8\">(self, severity: ErrorSeverity) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert error severity to logging level.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        mapping </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ErrorSeverity.</span><span style=\"color:#79B8FF\">WARNING</span><span style=\"color:#E1E4E8\">: logging.</span><span style=\"color:#79B8FF\">WARNING</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ErrorSeverity.</span><span style=\"color:#79B8FF\">ERROR</span><span style=\"color:#E1E4E8\">: logging.</span><span style=\"color:#79B8FF\">ERROR</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ErrorSeverity.</span><span style=\"color:#79B8FF\">CRITICAL</span><span style=\"color:#E1E4E8\">: logging.</span><span style=\"color:#79B8FF\">CRITICAL</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> mapping[severity]</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After Milestone 1 (Block Elements):</strong></p>\n<ul>\n<li>Run: <code>python -c &quot;from markdown_renderer import parse_to_html; print(parse_to_html(&#39;# Hello\\n\\nWorld&#39;))&quot;</code></li>\n<li>Expected: <code>&lt;h1&gt;Hello&lt;/h1&gt;\\n&lt;p&gt;World&lt;/p&gt;</code></li>\n<li>Verify: AST contains HEADING and PARAGRAPH nodes with correct hierarchy</li>\n</ul>\n<p><strong>After Milestone 2 (Inline Elements):</strong></p>\n<ul>\n<li>Run: <code>python -c &quot;from markdown_renderer import parse_to_html; print(parse_to_html(&#39;**bold** and *italic*&#39;))&quot;</code></li>\n<li>Expected: <code>&lt;p&gt;&lt;strong&gt;bold&lt;/strong&gt; and &lt;em&gt;italic&lt;/em&gt;&lt;/p&gt;</code></li>\n<li>Verify: Inline nodes are properly nested within block nodes</li>\n</ul>\n<p><strong>After Milestone 3 (Lists):</strong></p>\n<ul>\n<li>Run: <code>python -c &quot;from markdown_renderer import parse_to_html; print(parse_to_html(&#39;- Item 1\\n  - Nested&#39;))&quot;</code></li>\n<li>Expected: <code>&lt;ul&gt;&lt;li&gt;Item 1&lt;ul&gt;&lt;li&gt;Nested&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</code></li>\n<li>Verify: Nested list structures render with proper HTML nesting</li>\n</ul>\n<p><strong>After Milestone 4 (HTML Generation):</strong></p>\n<ul>\n<li>Run full integration test with complex document containing all element types</li>\n<li>Expected: Valid HTML5 that passes W3C validation</li>\n<li>Verify: All special characters properly escaped, no malformed tags</li>\n</ul>\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation</p>\n</blockquote>\n<h3 id=\"the-graceful-degradation-mental-model\">The Graceful Degradation Mental Model</h3>\n<p>Think of error handling in markdown parsing like being a helpful teacher grading a student&#39;s essay written in a second language. When you encounter grammatical errors or unclear sentences, you don&#39;t throw the entire essay in the trash — instead, you make reasonable interpretations, provide the best possible understanding of what the student meant, and continue reading. Similarly, when your markdown parser encounters malformed syntax or ambiguous input, it should make sensible assumptions, produce the most reasonable HTML output possible, and continue processing the rest of the document.</p>\n<p>This graceful degradation approach is fundamental to markdown parsing because markdown exists in a messy, real-world context. Users type markdown in text editors without syntax highlighting, copy-paste content from various sources, and often mix valid markdown with informal text patterns. A parser that fails completely on the first syntax error would be virtually unusable. Instead, your parser should embody the principle of &quot;be liberal in what you accept&quot; — interpret ambiguous input charitably while still maintaining predictable behavior.</p>\n<p>The key insight is that markdown parsing errors fall into two categories: recoverable inconsistencies where you can make reasonable assumptions about user intent, and structural corruption where continuing could produce misleading output. Your error handling strategy must distinguish between these cases and respond appropriately to each.</p>\n<h3 id=\"parser-error-recovery\">Parser Error Recovery</h3>\n<p>Parser error recovery represents the strategies your markdown renderer uses when it encounters input that doesn&#39;t conform to valid markdown syntax. The recovery approach differs significantly between the block parsing phase and the inline parsing phase because these phases have different error characteristics and different consequences for getting the interpretation wrong.</p>\n<p>During block parsing, most errors involve ambiguous line classification or incomplete block structures. For example, a user might start a fenced code block with triple backticks but forget to close it, or they might create what looks like a heading but with invalid syntax. These errors are typically local to specific lines or line sequences, making recovery relatively straightforward. The parser can make reasonable assumptions about user intent and continue processing subsequent lines.</p>\n<p>During inline parsing, errors more commonly involve mismatched delimiters or ambiguous emphasis markers. A user might write <code>**bold text without closing</code> or create nested emphasis that violates CommonMark precedence rules. These errors affect text spans within blocks, and recovery involves deciding how to interpret the malformed delimiters while preserving as much of the intended formatting as possible.</p>\n<h4 id=\"block-parser-error-recovery-strategy\">Block Parser Error Recovery Strategy</h4>\n<p>The block parser uses a <strong>continuation-based recovery</strong> approach where errors in one block don&#39;t prevent parsing of subsequent blocks. When the parser encounters malformed block syntax, it applies a hierarchy of fallback interpretations designed to preserve user intent whenever possible.</p>\n<p>The recovery strategy follows this decision sequence:</p>\n<ol>\n<li><strong>Attempt completion</strong>: If the current block is incomplete (like an unclosed fenced code block), attempt to complete it using document boundaries or other structural clues</li>\n<li><strong>Graceful degradation</strong>: If completion isn&#39;t possible, degrade the block to a simpler, valid form (like converting a malformed heading to a paragraph)</li>\n<li><strong>Content preservation</strong>: Ensure that all text content appears somewhere in the output, even if the formatting is lost</li>\n<li><strong>Error isolation</strong>: Prevent errors in one block from affecting the interpretation of subsequent blocks</li>\n<li><strong>Resume normal parsing</strong>: Continue with the standard parsing algorithm for the next line sequence</li>\n</ol>\n<p>For example, consider an unclosed fenced code block where the user writes:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Some paragraph text.\n\n```python\ndef hello():\n    print(&quot;world&quot;)\n\nMore paragraph text continues here.</code></pre></div>\n\n<p>The parser detects that the code block starting with triple backticks never encounters a closing fence. Rather than treating the entire rest of the document as code content, the recovery strategy recognizes that the user likely intended to close the code block before the next paragraph. The parser closes the code block implicitly at the next blank line followed by non-indented text, preserving both the code formatting and the subsequent paragraph content.</p>\n<p>The block parser maintains an <code>ErrorCollector</code> that records recovery decisions without interrupting the parsing process. This allows the parser to complete successfully while still providing feedback about ambiguous input interpretation.</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n<th>Fallback Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unclosed fenced code</td>\n<td>End of document reached while in fenced code state</td>\n<td>Close code block at document end</td>\n<td>Preserve all content as code</td>\n</tr>\n<tr>\n<td>Malformed ATX heading</td>\n<td>Hash characters without following space or text</td>\n<td>Convert to paragraph</td>\n<td>Treat hash characters as literal text</td>\n</tr>\n<tr>\n<td>Invalid Setext underline</td>\n<td>Underline length doesn&#39;t match heading text</td>\n<td>Treat as separate paragraph</td>\n<td>Keep both lines as paragraph content</td>\n</tr>\n<tr>\n<td>Incomplete blockquote</td>\n<td>Lines start with <code>&gt;</code> but have inconsistent spacing</td>\n<td>Normalize spacing and continue</td>\n<td>Remove <code>&gt;</code> markers and treat as paragraph</td>\n</tr>\n<tr>\n<td>Broken horizontal rule</td>\n<td>Line has some dashes/asterisks but not enough</td>\n<td>Convert to paragraph</td>\n<td>Preserve characters as literal text</td>\n</tr>\n<tr>\n<td>Mixed indentation in code</td>\n<td>Some lines indented with spaces, others with tabs</td>\n<td>Normalize to consistent indentation</td>\n<td>Convert tabs to spaces using standard width</td>\n</tr>\n</tbody></table>\n<h4 id=\"inline-parser-error-recovery-strategy\">Inline Parser Error Recovery Strategy</h4>\n<p>The inline parser uses a <strong>delimiter balancing recovery</strong> approach that attempts to create the most reasonable interpretation of mismatched or ambiguous formatting markers. Because inline formatting can be nested and overlapping, the recovery strategy must maintain consistency with CommonMark&#39;s emphasis precedence rules while handling cases those rules don&#39;t cover.</p>\n<p>The delimiter stack mechanism provides the foundation for error recovery. When the parser completes processing all text in a block but still has unmatched openers in the <code>DelimiterStack</code>, it applies recovery rules to determine how to handle the orphaned delimiters.</p>\n<p>The recovery process follows this sequence:</p>\n<ol>\n<li><strong>Attempt delayed matching</strong>: Look for potential closers that were initially rejected due to precedence rules</li>\n<li><strong>Pair partial matches</strong>: Match delimiters even if they don&#39;t follow strict flanking rules, prioritizing user intent over specification compliance</li>\n<li><strong>Convert to literal text</strong>: Transform unmatched delimiters into regular text characters</li>\n<li><strong>Preserve content</strong>: Ensure all text content appears in the output with as much formatting as can be reasonably inferred</li>\n<li><strong>Maintain consistency</strong>: Apply the same recovery rules consistently across similar situations</li>\n</ol>\n<p>For example, consider the text <code>**bold text with *italic inside</code> where the user forgot to close both the italic and bold formatting. The parser&#39;s delimiter stack contains an unmatched asterisk (for italic) and an unmatched double-asterisk (for bold). The recovery strategy recognizes that the user likely intended some formatting and converts the text to <code>**bold text with *italic inside**</code> by treating the entire span as bold text containing a literal asterisk character.</p>\n<p>The inline parser also handles <strong>intraword underscore</strong> issues by implementing recovery rules that distinguish between intended emphasis and underscores that happen to appear within words. When the parser encounters underscores in positions where they could technically match according to basic delimiter rules but violate the intraword prohibition, it converts them to literal characters rather than attempting to create emphasis spans.</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n<th>Fallback Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unmatched emphasis opener</td>\n<td>Delimiter stack not empty after processing text</td>\n<td>Convert to literal characters</td>\n<td>Remove delimiter properties, keep as text</td>\n</tr>\n<tr>\n<td>Mismatched emphasis types</td>\n<td>Asterisk opener with underscore closer</td>\n<td>Match delimiters of same type only</td>\n<td>Leave unmatched delimiters as literals</td>\n</tr>\n<tr>\n<td>Invalid nesting</td>\n<td>Strong inside emphasis when emphasis can&#39;t contain strong</td>\n<td>Allow nesting but adjust precedence</td>\n<td>Follow CommonMark precedence rules</td>\n</tr>\n<tr>\n<td>Broken link syntax</td>\n<td>Opening bracket without closing bracket or parentheses</td>\n<td>Treat brackets as literal text</td>\n<td>Preserve all text including brackets</td>\n</tr>\n<tr>\n<td>Incomplete image syntax</td>\n<td>Exclamation mark with broken link syntax</td>\n<td>Remove exclamation, apply link recovery</td>\n<td>Fall back to link parsing rules</td>\n</tr>\n<tr>\n<td>Unclosed inline code</td>\n<td>Backtick without matching closing backtick</td>\n<td>Close at end of current block</td>\n<td>Treat remaining text as code content</td>\n</tr>\n</tbody></table>\n<h3 id=\"edge-case-handling\">Edge Case Handling</h3>\n<p>Edge cases in markdown parsing represent input patterns that are technically valid according to the specification but create ambiguous or counterintuitive results. Unlike errors, which involve clearly malformed syntax, edge cases require the parser to choose between multiple valid interpretations or handle boundary conditions that don&#39;t have obvious correct answers.</p>\n<p>The markdown specification itself contains numerous edge cases because it attempts to codify the behavior of existing markdown implementations that evolved organically. Many of these edge cases arise from the interaction between different markdown features or from the need to handle whitespace, line breaks, and character sequences that have special meaning in some contexts but not others.</p>\n<p>Your parser&#39;s edge case handling strategy should prioritize <strong>consistent behavior</strong> and <strong>predictable results</strong> over trying to guess user intent. When faced with ambiguous input, the parser should always make the same interpretation choice, even if that choice might not match what the user intended in every specific case.</p>\n<p><img src=\"/api/project/markdown-renderer/architecture-doc/asset?path=diagrams%2Ferror-recovery-flow.svg\" alt=\"Error Recovery Decision Flow\"></p>\n<h4 id=\"whitespace-and-line-break-edge-cases\">Whitespace and Line Break Edge Cases</h4>\n<p>Whitespace handling represents one of the most complex categories of edge cases because markdown gives semantic meaning to certain whitespace patterns while treating others as insignificant. The parser must distinguish between whitespace that affects document structure, whitespace that affects formatting, and whitespace that should be preserved in the output.</p>\n<p><strong>Trailing whitespace on lines</strong> creates edge cases because two or more trailing spaces at the end of a line create a hard line break in the output, but a single trailing space is typically insignificant. However, users often have editors that automatically trim trailing whitespace, or they copy-paste content that loses trailing spaces. The parser must decide whether to preserve these line breaks strictly according to the input or to apply some normalization.</p>\n<p>The recommended approach is to implement <strong>semantic whitespace preservation</strong> where the parser preserves trailing spaces that clearly indicate intentional line breaks (two or more spaces) but normalizes accidental single trailing spaces. This requires the parser to track the original whitespace patterns during the preprocessing phase and apply consistent rules during HTML generation.</p>\n<p><strong>Mixed line endings</strong> create edge cases when documents contain a mixture of Unix (<code>\\n</code>), Windows (<code>\\r\\n</code>), and legacy Mac (<code>\\r</code>) line endings. While the <code>normalize_line_endings</code> function converts everything to Unix format, the parser must handle cases where the mixed line endings create unexpected blank lines or affect block boundary detection.</p>\n<p><strong>Tab expansion</strong> creates edge cases in indentation-sensitive contexts like code blocks and lists. The CommonMark specification requires tabs to be expanded to the next multiple of 4 spaces, but this can create counterintuitive results when users mix tabs and spaces or use different tab width assumptions. The <code>expand_tabs_to_spaces</code> function must handle these cases consistently while preserving the visual alignment that users intended.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Input Pattern</th>\n<th>Expected Behavior</th>\n<th>Implementation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Single trailing space</td>\n<td><code>Line content \\n</code></td>\n<td>Ignore trailing space</td>\n<td>Normalize during preprocessing</td>\n</tr>\n<tr>\n<td>Double trailing space</td>\n<td><code>Line content  \\n</code></td>\n<td>Create hard line break</td>\n<td>Preserve and convert to <code>&lt;br&gt;</code> tag</td>\n</tr>\n<tr>\n<td>Mixed tabs and spaces</td>\n<td><code>\\t  some text</code></td>\n<td>Normalize to consistent spacing</td>\n<td>Expand tabs first, then calculate indentation</td>\n</tr>\n<tr>\n<td>Empty lines with spaces</td>\n<td><code>   \\n</code></td>\n<td>Treat as blank line</td>\n<td>Trim whitespace before blank line detection</td>\n</tr>\n<tr>\n<td>CRLF followed by LF</td>\n<td><code>text\\r\\n\\nmore</code></td>\n<td>Single paragraph break</td>\n<td>Normalize line endings before processing</td>\n</tr>\n<tr>\n<td>Unicode whitespace</td>\n<td><code>text\\u00A0more</code></td>\n<td>Preserve non-breaking space</td>\n<td>Only normalize ASCII whitespace characters</td>\n</tr>\n</tbody></table>\n<h4 id=\"delimiter-precedence-edge-cases\">Delimiter Precedence Edge Cases</h4>\n<p>Delimiter precedence edge cases arise when multiple emphasis markers compete for the same text spans or when nested formatting creates ambiguous parsing situations. The CommonMark specification defines precedence rules for these cases, but implementing them correctly requires careful attention to delimiter matching order and flanking detection.</p>\n<p><strong>Overlapping emphasis spans</strong> occur when delimiter pairs would create emphasis spans that partially overlap rather than being properly nested. For example, the text <code>*emphasis **strong* text**</code> contains asterisks that would create overlapping emphasis if matched naively. The parser must apply precedence rules that ensure valid HTML nesting while producing predictable results.</p>\n<p>The precedence algorithm processes delimiters in a specific order: shorter emphasis spans (single asterisks/underscores) are resolved before longer ones (double asterisks/underscores), and delimiters are matched from left to right within each precedence level. When conflicts arise, the earlier delimiter takes precedence and later conflicting delimiters are treated as literal text.</p>\n<p><strong>Intraword underscore handling</strong> creates edge cases when underscores appear within words in contexts where they could technically form valid emphasis according to basic flanking rules. The specification prohibits intraword underscore emphasis, but determining what constitutes a &quot;word&quot; requires understanding Unicode character classes and handling edge cases with punctuation, numbers, and non-Latin scripts.</p>\n<p>The <code>can_open_emphasis</code> and <code>can_close_emphasis</code> functions implement flanking detection that considers the characters immediately before and after each delimiter. For underscores, additional logic checks whether both the delimiter and its potential match are surrounded by word characters, which would violate the intraword prohibition.</p>\n<p><strong>Emphasis delimiter length matching</strong> creates edge cases when the parser encounters sequences of emphasis markers with different lengths. For example, <code>***text***</code> could be interpreted as strong emphasis (<code>**text**</code>) with an extra literal asterisk, or as emphasis (<code>*text*</code>) with extra literal asterisks, or as a combination of both emphasis and strong emphasis. The specification defines rules for these cases, but implementing them requires careful tracking of available delimiter lengths.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Input Pattern</th>\n<th>CommonMark Interpretation</th>\n<th>Implementation Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Overlapping emphasis</td>\n<td><code>*em **strong* text**</code></td>\n<td><code>&lt;em&gt;em **strong&lt;/em&gt; text**</code></td>\n<td>Earlier delimiter wins, later becomes literal</td>\n</tr>\n<tr>\n<td>Intraword underscore</td>\n<td><code>snake_case_variable</code></td>\n<td><code>snake_case_variable</code> (no emphasis)</td>\n<td>Check word character boundaries for underscores</td>\n</tr>\n<tr>\n<td>Triple asterisk</td>\n<td><code>***text***</code></td>\n<td><code>&lt;em&gt;&lt;strong&gt;text&lt;/strong&gt;&lt;/em&gt;</code></td>\n<td>Parse as nested emphasis and strong</td>\n</tr>\n<tr>\n<td>Mixed delimiter types</td>\n<td><code>*emphasis with __strong* text__</code></td>\n<td><code>&lt;em&gt;emphasis with __strong&lt;/em&gt; text__</code></td>\n<td>Don&#39;t match asterisks with underscores</td>\n</tr>\n<tr>\n<td>Adjacent delimiters</td>\n<td><code>** **bold** **</code></td>\n<td><code>** &lt;strong&gt;bold&lt;/strong&gt; **</code></td>\n<td>Middle pair matches, outer delimiters are literals</td>\n</tr>\n<tr>\n<td>Escaped delimiters</td>\n<td><code>\\*not emphasis\\*</code></td>\n<td><code>*not emphasis*</code></td>\n<td>Process escapes before delimiter detection</td>\n</tr>\n</tbody></table>\n<h4 id=\"list-structure-edge-cases\">List Structure Edge Cases</h4>\n<p>List structure edge cases arise from the complexity of list continuation rules, indentation handling, and the interaction between lists and other block elements. These edge cases often involve determining whether a line continues an existing list item, starts a new list item, or ends the list entirely.</p>\n<p><strong>Lazy continuation</strong> represents one of the most subtle edge cases in list parsing. The CommonMark specification allows certain types of content to continue list items without requiring the full indentation that would normally be needed. This means a line that appears to be a regular paragraph might actually be a continuation of a preceding list item, depending on context.</p>\n<p>The lazy continuation rules apply differently to different types of content. Paragraph content can be lazily continued, but other block types like headings, code blocks, and blockquotes cannot. This creates edge cases where the same indentation level might continue a list in some contexts but not others.</p>\n<p><strong>Blank lines in lists</strong> affect whether lists are considered &quot;tight&quot; or &quot;loose,&quot; which changes the HTML output by determining whether list item content is wrapped in paragraph tags. A single blank line within a list can change the formatting of the entire list, creating edge cases where small whitespace changes have large effects on the output.</p>\n<p><strong>List marker changes</strong> create edge cases when a sequence of list items uses inconsistent markers. For ordered lists, different numbering patterns or punctuation styles might indicate separate lists. For unordered lists, mixing different bullet characters (<code>-</code>, <code>*</code>, <code>+</code>) should create separate lists according to the specification, but users often mix them unintentionally.</p>\n<p>The <code>ListContext</code> and <code>ListContextStack</code> classes handle these edge cases by tracking the specific marker types and indentation patterns for each nested list level. When the parser encounters a potential list item that doesn&#39;t match the current context, it must decide whether to end the current list and start a new one, or treat the line as non-list content.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Input Pattern</th>\n<th>Expected Behavior</th>\n<th>Implementation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Lazy continuation</td>\n<td>List item followed by unindented text</td>\n<td>Continue list item if paragraph content</td>\n<td>Check content type and previous context</td>\n</tr>\n<tr>\n<td>Blank line in tight list</td>\n<td>List items with single blank line between</td>\n<td>Convert entire list to loose formatting</td>\n<td>Track blank line presence across all items</td>\n</tr>\n<tr>\n<td>Mixed ordered markers</td>\n<td><code>1. item</code> followed by <code>1) item</code></td>\n<td>Create separate lists</td>\n<td>Compare marker punctuation styles</td>\n</tr>\n<tr>\n<td>Mixed unordered markers</td>\n<td><code>- item</code> followed by <code>* item</code></td>\n<td>Create separate lists</td>\n<td>Compare bullet character types</td>\n</tr>\n<tr>\n<td>Insufficient continuation indent</td>\n<td>List item with under-indented continuation</td>\n<td>End list, start new paragraph</td>\n<td>Calculate required indentation precisely</td>\n</tr>\n<tr>\n<td>List followed by code block</td>\n<td>Indented code after list without blank line</td>\n<td>Continue list vs. start code block</td>\n<td>Require blank line before code block</td>\n</tr>\n</tbody></table>\n<h4 id=\"link-and-image-edge-cases\">Link and Image Edge Cases</h4>\n<p>Link and image parsing creates edge cases around URL validation, title extraction, and the interaction between link syntax and other markdown features. These edge cases often involve determining whether character sequences that look like links should be interpreted as links or treated as literal text.</p>\n<p><strong>Nested brackets</strong> in link text create parsing challenges because the link syntax uses brackets to delimit the link text, but the link text itself might contain brackets for other purposes. The parser must track bracket nesting levels and determine which closing bracket corresponds to the link text versus brackets that are part of the content.</p>\n<p><strong>URL validation</strong> creates edge cases because the parser must decide which character sequences constitute valid URLs without implementing a full URL parser. The specification allows a wide range of URL formats, including relative URLs, fragment identifiers, and URLs with unusual schemes. The parser must balance accepting valid URLs against avoiding false positives where parentheses or other punctuation accidentally close link syntax.</p>\n<p><strong>Link titles with quotes</strong> create edge cases when the title text contains the same quote characters used to delimit the title. The parser must handle escaped quotes within titles and determine which quotes are delimiters versus content.</p>\n<p>The <code>LinkImageParser</code> class handles these edge cases through careful delimiter matching and context tracking. The parser maintains separate state for bracket nesting, parenthesis matching, and quote handling to ensure that complex link syntax is parsed correctly even when it contains characters that have special meaning in other contexts.</p>\n<table>\n<thead>\n<tr>\n<th>Edge Case</th>\n<th>Input Pattern</th>\n<th>Expected Behavior</th>\n<th>Implementation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Nested brackets in text</td>\n<td><code>[link [with brackets]](url)</code></td>\n<td>Include brackets in link text</td>\n<td>Track bracket nesting depth</td>\n</tr>\n<tr>\n<td>URL with parentheses</td>\n<td><code>[text](url(with)parens)</code></td>\n<td>Include parentheses in URL</td>\n<td>Balance parentheses in URL</td>\n</tr>\n<tr>\n<td>Link title with quotes</td>\n<td><code>[text](url &quot;title with \\&quot;quotes\\&quot;&quot;)</code></td>\n<td>Handle escaped quotes in title</td>\n<td>Process escapes within quoted strings</td>\n</tr>\n<tr>\n<td>Image vs link precedence</td>\n<td><code>[![image](img.png)](link.html)</code></td>\n<td>Image inside link</td>\n<td>Parse inner image first, then outer link</td>\n</tr>\n<tr>\n<td>Malformed URL</td>\n<td><code>[text](not a url)</code></td>\n<td>Treat as literal text</td>\n<td>Validate basic URL structure</td>\n</tr>\n<tr>\n<td>Missing link URL</td>\n<td><code>[text]()</code></td>\n<td>Create link with empty href</td>\n<td>Allow empty URLs but create valid HTML</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Key Insight</strong>: Edge case handling is not about guessing user intent — it&#39;s about providing consistent, predictable behavior that users can learn and rely on. When faced with ambiguous input, always choose the interpretation that produces valid HTML and maintains consistency with the CommonMark specification.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The error handling and edge case management system requires careful coordination between all parsing phases to ensure consistent behavior and comprehensive error recovery. The implementation focuses on building robust error collection and recovery mechanisms that don&#39;t interrupt the parsing pipeline while providing detailed information about how ambiguous input was interpreted.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Error Collection</td>\n<td>List of error messages with line numbers</td>\n<td>Structured error objects with severity levels and recovery suggestions</td>\n</tr>\n<tr>\n<td>Recovery Strategy</td>\n<td>Fixed fallback rules hardcoded in parser</td>\n<td>Configurable recovery policies with user-defined handlers</td>\n</tr>\n<tr>\n<td>Edge Case Testing</td>\n<td>Manual test cases for known edge cases</td>\n<td>Property-based testing with random input generation</td>\n</tr>\n<tr>\n<td>Validation</td>\n<td>Basic HTML structure validation</td>\n<td>Full CommonMark specification compliance testing</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>The error handling system integrates across all parsing components:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>markdown_renderer/\n  src/\n    parser/\n      error_handling.py      ← ErrorCollector, ParseError classes\n      recovery_strategies.py ← Recovery algorithms for each parser phase\n      edge_cases.py         ← Edge case detection and handling utilities\n    block_parser/\n      block_parser.py       ← Modified to use ErrorCollector\n      block_recovery.py     ← Block-specific recovery strategies\n    inline_parser/\n      inline_parser.py      ← Modified to use ErrorCollector  \n      delimiter_recovery.py ← Delimiter matching recovery\n    list_parser/\n      list_parser.py        ← Modified to use ErrorCollector\n      list_recovery.py      ← List structure recovery\n    html_generator/\n      html_generator.py     ← Modified to validate output\n      validation.py         ← HTML structure validation utilities\n    tests/\n      error_cases/          ← Test files for error scenarios\n      edge_cases/           ← Test files for edge case handling\n      recovery_tests.py     ← Tests for recovery behavior</code></pre></div>\n\n<h4 id=\"error-collection-infrastructure\">Error Collection Infrastructure</h4>\n<p>The error handling system begins with a comprehensive error collection mechanism that captures parsing issues without interrupting the parsing process. This infrastructure provides the foundation for both immediate recovery and post-processing analysis of parsing decisions.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Any, Dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorSeverity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Severity levels for parsing errors and edge cases.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WARNING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"warning\"</span><span style=\"color:#6A737D\">      # Ambiguous input with reasonable interpretation</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"error\"</span><span style=\"color:#6A737D\">          # Invalid syntax with fallback behavior</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CRITICAL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"critical\"</span><span style=\"color:#6A737D\">    # Structural problems affecting output quality</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParseError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Structured representation of parsing errors and recovery decisions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    line_number: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    column: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    severity: ErrorSeverity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    error_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    message: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    original_text: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recovery_action: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    suggested_fix: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    context: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.context </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorCollector</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Collects and manages parsing errors during markdown processing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.errors: List[ParseError] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.max_errors: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#6A737D\">  # Prevent excessive error collection</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.collect_warnings: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_error</span><span style=\"color:#E1E4E8\">(self, line_number: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, error_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  original_text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, recovery_action: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  severity: ErrorSeverity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ErrorSeverity.</span><span style=\"color:#79B8FF\">ERROR</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  column: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                  suggested_fix: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                  **</span><span style=\"color:#E1E4E8\">context) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add a parsing error with recovery information.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if max_errors limit reached, skip if exceeded</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create ParseError instance with all provided parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Set context dictionary from **context kwargs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Append error to self.errors list</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If severity is WARNING and collect_warnings is False, skip adding</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> has_errors</span><span style=\"color:#E1E4E8\">(self, min_severity: ErrorSeverity </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ErrorSeverity.</span><span style=\"color:#79B8FF\">ERROR</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if any errors of specified severity or higher exist.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Iterate through self.errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Compare each error's severity to min_severity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return True if any error meets severity threshold</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_errors_by_line</span><span style=\"color:#E1E4E8\">(self, line_number: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> List[ParseError]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get all errors that occurred on a specific line.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Filter self.errors where error.line_number == line_number</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return filtered list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> format_error_report</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate human-readable error report.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Group errors by severity level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Format each error with line number, message, and recovery action</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Include suggested fixes when available</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return formatted report string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"block-parser-recovery-implementation\">Block Parser Recovery Implementation</h4>\n<p>The block parser recovery system handles incomplete or malformed block structures by maintaining recovery state alongside the normal parsing state machine. This allows the parser to detect error conditions and apply appropriate fallback strategies without losing document content.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, List, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RecoveryStrategy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Recovery strategies for different types of block parsing errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    COMPLETE_BLOCK</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"complete_block\"</span><span style=\"color:#6A737D\">      # Try to complete incomplete block</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CONVERT_TO_PARAGRAPH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"convert_to_paragraph\"</span><span style=\"color:#6A737D\">  # Fallback to paragraph</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PRESERVE_CONTENT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"preserve_content\"</span><span style=\"color:#6A737D\">   # Keep content, lose formatting</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SKIP_MALFORMED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"skip_malformed\"</span><span style=\"color:#6A737D\">      # Skip line, continue parsing</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BlockRecoveryContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Context information for block-level error recovery.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    current_block_type: Optional[BlockType]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    lines_in_block: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected_closing: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    fallback_strategy: RecoveryStrategy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> recover_incomplete_fenced_code</span><span style=\"color:#E1E4E8\">(block_node: BlockNode, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                   error_collector: ErrorCollector,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                   line_number: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Recover from unclosed fenced code block at end of document.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Add error to collector about unclosed fenced code block</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Set block's closing fence implicitly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Mark block as complete in block attributes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Log recovery action taken</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> recover_malformed_atx_heading</span><span style=\"color:#E1E4E8\">(line: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, line_number: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  error_collector: ErrorCollector) -> BlockNode:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Recover from invalid ATX heading syntax by converting to paragraph.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Detect specific malformation (no space after #, too many #, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add error to collector with specific issue description</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create paragraph block node with original line content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Set recovery information in block attributes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return paragraph block node</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> recover_inconsistent_blockquote</span><span style=\"color:#E1E4E8\">(lines: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], line_numbers: List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                    error_collector: ErrorCollector) -> BlockNode:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Recover from blockquote with inconsistent > prefixes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Identify lines with missing or malformed > prefixes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Add warning for each inconsistent line</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Normalize all lines to have consistent > prefix</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create blockquote block with normalized content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Record normalization actions in block attributes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"inline-parser-recovery-implementation\">Inline Parser Recovery Implementation</h4>\n<p>The inline parser recovery system focuses on delimiter matching issues and emphasis precedence conflicts. The recovery strategies maintain the delimiter stack integrity while providing reasonable interpretations of malformed inline formatting.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Tuple, Dict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DelimiterRecoveryInfo</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Information about delimiter recovery actions.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    original_position: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    delimiter_char: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recovery_action: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    matched_with: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    converted_to_literal: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> recover_unmatched_delimiters</span><span style=\"color:#E1E4E8\">(delimiter_stack: DelimiterStack,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                error_collector: ErrorCollector) -> List[DelimiterRecoveryInfo]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Recover from unmatched emphasis delimiters in delimiter stack.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Iterate through remaining delimiters in stack</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each delimiter, determine if partial matching is possible</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Apply recovery strategy (convert to literal, force match, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add error/warning to collector for each recovery action</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create DelimiterRecoveryInfo for each action taken</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Clear delimiter stack after recovery</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return list of recovery actions taken</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> handle_intraword_underscore_conflict</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, start_pos: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, end_pos: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                        error_collector: ErrorCollector) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Handle underscore emphasis that would violate intraword rules.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract the text span between start_pos and end_pos</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check if both delimiter positions are within words</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If intraword violation detected, add warning to collector</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Convert delimiter characters to literal underscores</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return text with delimiters converted to literals</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> recover_broken_link_syntax</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, bracket_pos: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              error_collector: ErrorCollector) -> Tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Recover from malformed link syntax by treating as literal text.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Analyze link syntax starting at bracket_pos</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Identify specific malformation (missing closing bracket, invalid URL, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add error to collector with specific issue</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Convert link syntax characters to literal text</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return tuple of (recovered_text, recovery_applied)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"edge-case-detection-and-handling\">Edge Case Detection and Handling</h4>\n<p>The edge case handling system provides consistent behavior for ambiguous input patterns that are technically valid but could be interpreted multiple ways. The implementation focuses on predictable rule application rather than trying to guess user intent.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Tuple, Optional, Dict, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Edge case detection patterns</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MIXED_LINE_ENDING_PATTERN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#85E89D;font-weight:bold\">\\r\\n</span><span style=\"color:#F97583\">|</span><span style=\"color:#85E89D;font-weight:bold\">\\r</span><span style=\"color:#F97583\">|</span><span style=\"color:#85E89D;font-weight:bold\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">TRAILING_WHITESPACE_PATTERN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">[ </span><span style=\"color:#85E89D;font-weight:bold\">\\t</span><span style=\"color:#79B8FF\">]</span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\">$</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">, re.</span><span style=\"color:#79B8FF\">MULTILINE</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">UNICODE_WHITESPACE_PATTERN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">[\\u00A0\\u1680\\u2000-\\u200B\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> normalize_edge_case_whitespace</span><span style=\"color:#E1E4E8\">(text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  preserve_semantic_breaks: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Normalize whitespace while handling edge cases consistently.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Track normalization actions taken for reporting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Convert all line endings to Unix format (\\n)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle trailing whitespace - preserve semantic line breaks (2+ spaces)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Expand tabs to spaces using 4-space tab width</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Normalize Unicode whitespace to ASCII equivalents where appropriate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Remove trailing whitespace from blank lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return tuple of (normalized_text, list_of_actions_taken)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> detect_emphasis_precedence_conflict</span><span style=\"color:#E1E4E8\">(delimiters: List[Delimiter]) -> List[Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Detect potential emphasis delimiter precedence conflicts.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Sort delimiters by position</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check for overlapping emphasis spans</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Identify conflicts between asterisk and underscore delimiters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Find cases where delimiter length precedence applies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return list of (start_pos, end_pos, conflict_type) tuples</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> handle_list_marker_inconsistency</span><span style=\"color:#E1E4E8\">(current_marker: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, new_marker: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                    context: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> Tuple[</span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Handle inconsistent list markers according to CommonMark rules.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Parse marker types (ordered vs unordered, specific characters)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check if markers are compatible (same list vs separate lists)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: For ordered lists, check numbering continuity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: For unordered lists, check bullet character consistency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return tuple of (should_continue_list, explanation)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"comprehensive-error-testing-framework\">Comprehensive Error Testing Framework</h4>\n<p>The error handling system requires extensive testing to ensure consistent behavior across all edge cases and recovery scenarios. The testing framework validates both the recovery actions taken and the quality of the final output.</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorTestCase</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test case for error handling and recovery behavior.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    markdown_input: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected_html: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected_errors: List[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recovery_actions: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    edge_case_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> create_error_test_cases</span><span style=\"color:#E1E4E8\">() -> List[ErrorTestCase]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Create comprehensive test cases for error handling scenarios.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ErrorTestCase(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"unclosed_fenced_code_block\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            markdown_input</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"```python</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">def test():</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">    pass</span><span style=\"color:#79B8FF\">\\n\\n</span><span style=\"color:#9ECBFF\">More text here.\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            expected_html</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"&#x3C;pre>&#x3C;code class=</span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">language-python</span><span style=\"color:#79B8FF\">\\\"</span><span style=\"color:#9ECBFF\">>def test():</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">    pass</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">&#x3C;/code>&#x3C;/pre></span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">&#x3C;p>More text here.&#x3C;/p>\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            expected_errors</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"error_type\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"unclosed_fenced_code\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"severity\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"ERROR\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"recovery_action\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"closed_at_next_paragraph\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            recovery_actions</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">[</span><span style=\"color:#9ECBFF\">\"close_code_block_at_paragraph_break\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            edge_case_type</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"block_structure\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ),</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add test cases for:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Malformed ATX headings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Unmatched emphasis delimiters  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Intraword underscore conflicts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Broken link syntax</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Mixed list markers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Whitespace edge cases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Nested delimiter conflicts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # - Unicode edge cases</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_error_recovery_consistency</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test that error recovery produces consistent results.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Load error test cases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: For each test case, parse markdown with error collection enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify that expected errors were collected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify that recovery actions match expectations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Verify that HTML output matches expected result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Test that parsing same input twice produces identical results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_edge_case_predictability</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test that edge cases produce predictable, consistent behavior.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create variations of edge case inputs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Parse each variation multiple times</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify identical output across all parsing attempts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify that similar edge cases produce similar handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Test that edge case handling follows CommonMark specification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"debugging-error-handling-issues\">Debugging Error Handling Issues</h4>\n<p>The error handling system includes comprehensive debugging support to help identify why specific recovery actions were taken and how to adjust the behavior if needed.</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Parser silently ignores malformed input</td>\n<td>Recovery strategy too aggressive</td>\n<td>Enable error collection, check error report</td>\n<td>Adjust recovery strategy to be more conservative</td>\n</tr>\n<tr>\n<td>Parser fails on minor syntax issues</td>\n<td>Recovery strategy too strict</td>\n<td>Check ErrorCollector for excessive ERROR level issues</td>\n<td>Add more WARNING-level recoveries for minor issues</td>\n</tr>\n<tr>\n<td>Inconsistent output for similar inputs</td>\n<td>Edge case handling not standardized</td>\n<td>Test with variations of problematic input</td>\n<td>Implement consistent rule application</td>\n</tr>\n<tr>\n<td>Valid markdown parsed incorrectly</td>\n<td>Edge case detector too aggressive</td>\n<td>Check for false positive edge case detection</td>\n<td>Refine detection patterns to be more specific</td>\n</tr>\n<tr>\n<td>HTML output contains formatting errors</td>\n<td>Recovery created invalid nesting</td>\n<td>Validate HTML structure after recovery</td>\n<td>Add HTML validation step after recovery actions</td>\n</tr>\n<tr>\n<td>Error messages not helpful</td>\n<td>ParseError lacks context information</td>\n<td>Check ParseError.context field population</td>\n<td>Add more contextual information during error creation</td>\n</tr>\n</tbody></table>\n<p>The error handling and edge case management system provides the foundation for a robust markdown parser that handles real-world input gracefully while maintaining predictable behavior. The combination of structured error collection, consistent recovery strategies, and comprehensive edge case handling ensures that users receive useful output even when their markdown input contains syntax errors or ambiguous patterns.</p>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation</p>\n</blockquote>\n<h3 id=\"the-quality-assurance-mental-model\">The Quality Assurance Mental Model</h3>\n<p>Think of testing a markdown renderer like quality control in a translation service. You have documents coming in one language (markdown) and going out in another (HTML), and you need to verify that the meaning, structure, and formatting are preserved accurately across this transformation. Just as a translation service would test with simple phrases, complex literary works, edge cases like idioms, and even malformed input, your markdown renderer needs systematic verification at every level.</p>\n<p>The testing strategy serves as both a safety net and a learning accelerator. Each test category validates different properties of correctness, from basic functionality to edge case resilience. The systematic approach ensures that as you build each milestone, you can confidently rely on previously implemented components while adding new functionality.</p>\n<h3 id=\"test-categories-and-properties\">Test Categories and Properties</h3>\n<p>Testing a markdown renderer requires validating multiple dimensions of correctness simultaneously. Unlike simple algorithmic problems where you test input-output pairs, document transformation involves structural correctness, semantic preservation, and format compliance. Each test category validates specific properties and catches different classes of errors.</p>\n<h4 id=\"unit-test-categories\">Unit Test Categories</h4>\n<p><strong>Block Parser Unit Tests</strong> verify that individual block-level elements are recognized and parsed correctly in isolation. These tests focus on the <code>BlockParser</code> component and validate that each block type handler correctly identifies, extracts, and structures content.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Property Validated</th>\n<th>Example Test Case</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ATX Heading Recognition</td>\n<td>Heading level detection accuracy</td>\n<td><code>### Hello World</code></td>\n<td>Creates <code>BlockNode</code> with <code>block_type=HEADING</code>, level 3, content &quot;Hello World&quot;</td>\n</tr>\n<tr>\n<td>Paragraph Boundary Detection</td>\n<td>Text grouping correctness</td>\n<td>Two lines separated by blank line</td>\n<td>Creates two separate <code>BlockNode</code> instances with <code>block_type=PARAGRAPH</code></td>\n</tr>\n<tr>\n<td>Fenced Code Block Parsing</td>\n<td>Content preservation with metadata</td>\n<td>Triple backticks with language hint</td>\n<td>Preserves exact whitespace, extracts language identifier</td>\n</tr>\n<tr>\n<td>Blockquote Nesting</td>\n<td>Hierarchical structure building</td>\n<td>Multiple <code>&gt;</code> levels</td>\n<td>Creates nested <code>BlockNode</code> tree with proper parent-child relationships</td>\n</tr>\n<tr>\n<td>Horizontal Rule Recognition</td>\n<td>Pattern matching precision</td>\n<td>Various <code>---</code>, <code>***</code>, <code>___</code> patterns</td>\n<td>Distinguishes valid rules from similar-looking text</td>\n</tr>\n</tbody></table>\n<p><strong>Inline Parser Unit Tests</strong> validate that formatting elements within text are correctly identified, paired, and nested. These tests exercise the <code>DelimiterStack</code> and emphasis matching algorithms.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Property Validated</th>\n<th>Example Test Case</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Emphasis Delimiter Matching</td>\n<td>Proper opener-closer pairing</td>\n<td><code>**bold** and *italic*</code></td>\n<td>Matches delimiters correctly, doesn&#39;t cross-pair</td>\n</tr>\n<tr>\n<td>Intraword Underscore Handling</td>\n<td>Context-sensitive formatting</td>\n<td><code>snake_case_variable</code></td>\n<td>Doesn&#39;t apply emphasis to underscores within words</td>\n</tr>\n<tr>\n<td>Nested Formatting</td>\n<td>Hierarchical inline structure</td>\n<td><code>**bold with *italic* inside**</code></td>\n<td>Creates proper AST nesting without conflicts</td>\n</tr>\n<tr>\n<td>Link Syntax Parsing</td>\n<td>URL and title extraction</td>\n<td><code>[text](url &quot;title&quot;)</code></td>\n<td>Extracts all components with proper escaping</td>\n</tr>\n<tr>\n<td>Escape Sequence Processing</td>\n<td>Literal character handling</td>\n<td><code>\\*not emphasis\\*</code></td>\n<td>Converts escape sequences to literal characters</td>\n</tr>\n</tbody></table>\n<p><strong>List Parser Unit Tests</strong> verify the complex indentation tracking and nesting logic that handles one of markdown&#39;s most challenging parsing scenarios.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Property Validated</th>\n<th>Example Test Case</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Marker Type Consistency</td>\n<td>List type enforcement</td>\n<td>Mixed <code>-</code> and <code>*</code> markers</td>\n<td>Treats as separate lists per CommonMark rules</td>\n</tr>\n<tr>\n<td>Indentation Level Tracking</td>\n<td>Nesting depth calculation</td>\n<td>Various indentation patterns</td>\n<td>Builds correct hierarchical structure</td>\n</tr>\n<tr>\n<td>Lazy Continuation</td>\n<td>Content flow rules</td>\n<td>Multi-line items without markers</td>\n<td>Properly continues items without requiring markers</td>\n</tr>\n<tr>\n<td>Tight vs Loose Lists</td>\n<td>Spacing semantics</td>\n<td>Lists with/without blank lines</td>\n<td>Sets appropriate formatting flags for HTML generation</td>\n</tr>\n<tr>\n<td>List Item Content Parsing</td>\n<td>Multi-paragraph item handling</td>\n<td>Items containing multiple blocks</td>\n<td>Nests paragraphs, code blocks within list items</td>\n</tr>\n</tbody></table>\n<h4 id=\"integration-test-categories\">Integration Test Categories</h4>\n<p><strong>Parser Pipeline Integration Tests</strong> validate that the complete parsing pipeline produces coherent results when components work together. These tests catch interaction bugs that unit tests miss.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Property Validated</th>\n<th>Example Test Case</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Block-Inline Coordination</td>\n<td>Proper processing order</td>\n<td>Paragraph with emphasis</td>\n<td>Block parser creates paragraph, inline parser processes emphasis within</td>\n</tr>\n<tr>\n<td>List-Inline Integration</td>\n<td>Complex nested parsing</td>\n<td>List items with links and emphasis</td>\n<td>Maintains both list structure and inline formatting</td>\n</tr>\n<tr>\n<td>Escape Context Preservation</td>\n<td>Consistent escape handling</td>\n<td>Escapes in different contexts</td>\n<td>Escapes work consistently across block and inline contexts</td>\n</tr>\n<tr>\n<td>AST Structure Integrity</td>\n<td>Tree validity</td>\n<td>Complex nested documents</td>\n<td>Produces well-formed AST with proper parent-child links</td>\n</tr>\n<tr>\n<td>State Machine Transitions</td>\n<td>Parser state consistency</td>\n<td>Mixed block types</td>\n<td>State transitions don&#39;t leave parser in inconsistent state</td>\n</tr>\n</tbody></table>\n<p><strong>HTML Generation Integration Tests</strong> ensure that the parsed AST converts to valid, semantically correct HTML that preserves the original document&#39;s intent.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Property Validated</th>\n<th>Example Test Case</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTML Validity</td>\n<td>Standards compliance</td>\n<td>Complex nested structures</td>\n<td>Produces HTML5-compliant output that passes validation</td>\n</tr>\n<tr>\n<td>Character Escaping</td>\n<td>Security and correctness</td>\n<td>Special characters in various contexts</td>\n<td>Properly escapes content vs attribute contexts</td>\n</tr>\n<tr>\n<td>Semantic Preservation</td>\n<td>Meaning conservation</td>\n<td>Complex formatting combinations</td>\n<td>HTML conveys same semantic meaning as original markdown</td>\n</tr>\n<tr>\n<td>Pretty Printing</td>\n<td>Output readability</td>\n<td>Nested block structures</td>\n<td>Produces properly indented, human-readable HTML</td>\n</tr>\n<tr>\n<td>Custom Renderer Integration</td>\n<td>Extensibility verification</td>\n<td>Documents using custom renderers</td>\n<td>Plugin system works without breaking core functionality</td>\n</tr>\n</tbody></table>\n<h4 id=\"property-based-test-categories\">Property-Based Test Categories</h4>\n<p>Property-based tests validate system behaviors that should hold regardless of specific input content. These tests are particularly valuable for catching edge cases and ensuring robust error handling.</p>\n<table>\n<thead>\n<tr>\n<th>Property Category</th>\n<th>Invariant Tested</th>\n<th>Test Approach</th>\n<th>Validation Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Roundtrip Stability</td>\n<td><code>parse(markdown).to_text() ≈ original</code></td>\n<td>Generate varied markdown inputs</td>\n<td>Compare semantic equivalence</td>\n</tr>\n<tr>\n<td>Parsing Determinism</td>\n<td>Same input always produces same AST</td>\n<td>Repeat parsing with identical input</td>\n<td>Verify AST structure matches exactly</td>\n</tr>\n<tr>\n<td>Error Recovery Bounds</td>\n<td>Malformed input produces valid output</td>\n<td>Inject syntax errors systematically</td>\n<td>Check output is still valid HTML</td>\n</tr>\n<tr>\n<td>Memory Safety</td>\n<td>No resource leaks during parsing</td>\n<td>Parse large documents repeatedly</td>\n<td>Monitor memory usage patterns</td>\n</tr>\n<tr>\n<td>Performance Linearity</td>\n<td>Parse time scales reasonably</td>\n<td>Vary document size systematically</td>\n<td>Verify no exponential behavior</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The key insight in testing document transformation is that you&#39;re validating not just correctness, but also consistency across different contexts. A delimiter that works in paragraphs must also work in list items, blockquotes, and other nested contexts.</p>\n</blockquote>\n<h4 id=\"error-handling-test-categories\">Error Handling Test Categories</h4>\n<p>Error handling tests ensure graceful degradation when encountering malformed or edge-case input. These tests validate the <code>ErrorCollector</code> and recovery mechanisms described in the Error Handling section.</p>\n<table>\n<thead>\n<tr>\n<th>Error Category</th>\n<th>Failure Mode</th>\n<th>Test Case</th>\n<th>Expected Recovery</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unclosed Fenced Code</td>\n<td>EOF before closing fence</td>\n<td>Code block without <code>&#39;&#39;&#39;</code> end</td>\n<td>Convert to indented code block</td>\n</tr>\n<tr>\n<td>Malformed Links</td>\n<td>Invalid URL or missing parts</td>\n<td><code>[text](invalid</code></td>\n<td>Render as literal text</td>\n</tr>\n<tr>\n<td>Unmatched Emphasis</td>\n<td>Mismatched delimiters</td>\n<td><code>**bold *italic**</code></td>\n<td>Handle precedence correctly</td>\n</tr>\n<tr>\n<td>Invalid List Structure</td>\n<td>Inconsistent indentation</td>\n<td>Mixed tabs and spaces</td>\n<td>Normalize to consistent spacing</td>\n</tr>\n<tr>\n<td>Mixed Line Endings</td>\n<td>Platform inconsistencies</td>\n<td>Mix of <code>\\n</code>, <code>\\r\\n</code>, <code>\\r</code></td>\n<td>Normalize to consistent format</td>\n</tr>\n</tbody></table>\n<p><strong>Architecture Decision: Test Organization Strategy</strong></p>\n<blockquote>\n<p><strong>Decision: Hierarchical Test Organization with Component Isolation</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to balance comprehensive coverage with maintainable test suite organization, while supporting incremental milestone development</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Single large test file with all cases</li>\n<li>Test files mirroring source code structure exactly  </li>\n<li>Hierarchical organization by test type and milestone</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Hierarchical organization with separate directories for unit, integration, and property-based tests</li>\n<li><strong>Rationale</strong>: Allows learners to focus on relevant tests during each milestone while maintaining clear separation between test categories. Supports both incremental development and comprehensive validation.</li>\n<li><strong>Consequences</strong>: Requires more initial setup but provides better long-term maintainability and learning progression</li>\n</ul>\n</blockquote>\n<h3 id=\"milestone-verification-checkpoints\">Milestone Verification Checkpoints</h3>\n<p>Each milestone represents a significant capability milestone that should be thoroughly verified before proceeding. The verification checkpoints provide concrete, measurable criteria for determining when a milestone is complete and the foundation is solid for the next phase.</p>\n<h4 id=\"milestone-1-block-elements-verification\">Milestone 1: Block Elements Verification</h4>\n<p><strong>Functional Verification Criteria</strong> for the block parsing infrastructure ensure that the foundational parsing capabilities work correctly across all supported block types.</p>\n<table>\n<thead>\n<tr>\n<th>Block Type</th>\n<th>Verification Test</th>\n<th>Input Example</th>\n<th>Expected Output Structure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ATX Headings</td>\n<td>All heading levels parse correctly</td>\n<td><code># H1\\n## H2\\n### H3\\n#### H4\\n##### H5\\n###### H6</code></td>\n<td>Six <code>BlockNode</code> instances with correct levels 1-6</td>\n</tr>\n<tr>\n<td>Setext Headings</td>\n<td>Underline styles recognized</td>\n<td><code>Heading 1\\n========\\nHeading 2\\n--------</code></td>\n<td>Two <code>BlockNode</code> instances with levels 1 and 2</td>\n</tr>\n<tr>\n<td>Paragraphs</td>\n<td>Text grouping with blank line separation</td>\n<td><code>Para 1\\n\\nPara 2\\n\\nPara 3</code></td>\n<td>Three separate <code>BlockNode</code> instances with <code>block_type=PARAGRAPH</code></td>\n</tr>\n<tr>\n<td>Fenced Code</td>\n<td>Language hints and content preservation</td>\n<td>````python\\nprint(&quot;hello&quot;)\\n```</td>\n<td><code>BlockNode</code> with language=&quot;python&quot;, exact content preservation</td>\n</tr>\n<tr>\n<td>Indented Code</td>\n<td>Four-space rule compliance</td>\n<td><code>    code line 1\\n    code line 2</code></td>\n<td>Single code <code>BlockNode</code> with preserved indentation</td>\n</tr>\n<tr>\n<td>Blockquotes</td>\n<td>Simple and nested structures</td>\n<td><code>&gt; Quote\\n&gt;&gt; Nested\\n&gt; Back to level 1</code></td>\n<td>Nested <code>BlockNode</code> tree with proper hierarchy</td>\n</tr>\n<tr>\n<td>Horizontal Rules</td>\n<td>Various marker patterns</td>\n<td><code>---\\n***\\n___</code></td>\n<td>Three <code>BlockNode</code> instances with <code>block_type=HORIZONTAL_RULE</code></td>\n</tr>\n</tbody></table>\n<p><strong>State Machine Verification</strong> ensures that the <code>BlockParserState</code> transitions work correctly and don&#39;t leave the parser in inconsistent states.</p>\n<table>\n<thead>\n<tr>\n<th>State Transition</th>\n<th>Test Scenario</th>\n<th>Expected Behavior</th>\n<th>Error Detection</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>LOOKING_FOR_BLOCK</code> → <code>IN_PARAGRAPH</code></td>\n<td>Regular text line encountered</td>\n<td>Creates new paragraph block, transitions state</td>\n<td>Should not remain in looking state</td>\n</tr>\n<tr>\n<td><code>IN_PARAGRAPH</code> → <code>LOOKING_FOR_BLOCK</code></td>\n<td>Blank line encountered</td>\n<td>Finalizes paragraph, resets state</td>\n<td>Paragraph should be added to document</td>\n</tr>\n<tr>\n<td><code>IN_FENCED_CODE</code> → <code>LOOKING_FOR_BLOCK</code></td>\n<td>Matching closing fence</td>\n<td>Finalizes code block with preserved content</td>\n<td>Missing closure should be detected</td>\n</tr>\n<tr>\n<td>Mixed block transitions</td>\n<td>Complex document with all block types</td>\n<td>All blocks parsed correctly in sequence</td>\n<td>No state machine confusion</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification Steps</strong> provide concrete actions to verify milestone completion:</p>\n<ol>\n<li><strong>Create comprehensive test document</strong> containing all supported block types in various combinations</li>\n<li><strong>Run block parser</strong> on the test document and examine the generated AST structure</li>\n<li><strong>Verify AST node count</strong> matches expected number of blocks (use <code>debug_print_ast</code> function)</li>\n<li><strong>Check block type assignment</strong> - each block should have correct <code>block_type</code> value</li>\n<li><strong>Validate content extraction</strong> - block content should match original text with proper whitespace handling</li>\n<li><strong>Test edge cases</strong> - empty blocks, blocks at document boundaries, maximum nesting levels</li>\n</ol>\n<p><strong>Milestone 1 Checkpoint Command Sequence</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run comprehensive block parser tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/unit/block_parser/</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Run milestone 1 integration tests</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/integration/milestone1/</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Manual verification with debug output</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from markdown_parser import MarkdownParser</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">parser = MarkdownParser()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">ast = parser.parse_blocks(open('test_documents/milestone1_comprehensive.md').read())</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">parser.debug_print_ast(ast, 0)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<h4 id=\"milestone-2-inline-elements-verification\">Milestone 2: Inline Elements Verification</h4>\n<p><strong>Delimiter Matching Verification</strong> ensures that the <code>DelimiterStack</code> correctly handles all emphasis and formatting patterns.</p>\n<table>\n<thead>\n<tr>\n<th>Formatting Type</th>\n<th>Test Pattern</th>\n<th>Expected Result</th>\n<th>Common Failure Mode</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Bold (asterisk)</td>\n<td><code>**bold text**</code></td>\n<td><code>InlineNode</code> with <code>inline_type=STRONG</code></td>\n<td>Fails to match across line breaks</td>\n</tr>\n<tr>\n<td>Bold (underscore)</td>\n<td><code>__bold text__</code></td>\n<td><code>InlineNode</code> with <code>inline_type=STRONG</code></td>\n<td>Incorrectly matches intraword</td>\n</tr>\n<tr>\n<td>Italic (asterisk)</td>\n<td><code>*italic text*</code></td>\n<td><code>InlineNode</code> with <code>inline_type=EMPHASIS</code></td>\n<td>Conflicts with list markers</td>\n</tr>\n<tr>\n<td>Italic (underscore)</td>\n<td><code>_italic text_</code></td>\n<td><code>InlineNode</code> with <code>inline_type=EMPHASIS</code></td>\n<td>Triggers on snake_case variables</td>\n</tr>\n<tr>\n<td>Nested emphasis</td>\n<td><code>**bold with *italic* inside**</code></td>\n<td>Properly nested <code>InlineNode</code> tree</td>\n<td>Incorrect precedence resolution</td>\n</tr>\n<tr>\n<td>Inline code</td>\n<td><code>`code span`</code></td>\n<td><code>InlineNode</code> with <code>inline_type=CODE</code></td>\n<td>Doesn&#39;t preserve internal formatting</td>\n</tr>\n<tr>\n<td>Links</td>\n<td><code>[text](url)</code></td>\n<td><code>InlineNode</code> with URL and text extracted</td>\n<td>Fails on nested brackets</td>\n</tr>\n<tr>\n<td>Images</td>\n<td><code>![alt](url)</code></td>\n<td><code>InlineNode</code> with alt text and URL</td>\n<td>Confuses with link syntax</td>\n</tr>\n</tbody></table>\n<p><strong>Flanking Detection Verification</strong> validates the complex rules for when delimiters can open or close emphasis spans.</p>\n<table>\n<thead>\n<tr>\n<th>Flanking Scenario</th>\n<th>Test Case</th>\n<th>Expected Behavior</th>\n<th>Rule Applied</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Left-flanking asterisk</td>\n<td><code>*emphasis</code> at word start</td>\n<td>Can open emphasis</td>\n<td>Preceded by whitespace or punctuation</td>\n</tr>\n<tr>\n<td>Right-flanking asterisk</td>\n<td><code>emphasis*</code> at word end</td>\n<td>Can close emphasis</td>\n<td>Followed by whitespace or punctuation</td>\n</tr>\n<tr>\n<td>Non-flanking underscore</td>\n<td><code>snake_case_var</code></td>\n<td>Cannot open/close</td>\n<td>Surrounded by alphanumeric characters</td>\n</tr>\n<tr>\n<td>Punctuation flanking</td>\n<td><code>&quot;*quoted emphasis*&quot;</code></td>\n<td>Can open and close</td>\n<td>Punctuation counts as whitespace</td>\n</tr>\n<tr>\n<td>Mixed flanking</td>\n<td><code>*emphasis* and **bold**</code></td>\n<td>Correct delimiter pairing</td>\n<td>Doesn&#39;t cross-match different types</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification Steps</strong> for inline parsing:</p>\n<ol>\n<li><strong>Create inline formatting test suite</strong> with all supported inline elements</li>\n<li><strong>Verify delimiter stack behavior</strong> by adding debug output to delimiter matching</li>\n<li><strong>Test precedence rules</strong> with complex nested formatting combinations</li>\n<li><strong>Validate escape sequence handling</strong> - escaped delimiters should render literally</li>\n<li><strong>Check URL parsing accuracy</strong> for links and images with various URL formats</li>\n</ol>\n<h4 id=\"milestone-3-lists-verification\">Milestone 3: Lists Verification</h4>\n<p><strong>List Structure Verification</strong> validates the complex indentation tracking and nesting logic implemented in the <code>ListContext</code> system.</p>\n<table>\n<thead>\n<tr>\n<th>List Type</th>\n<th>Test Pattern</th>\n<th>Expected Structure</th>\n<th>Nesting Validation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Simple unordered</td>\n<td><code>- Item 1\\n- Item 2</code></td>\n<td>Single <code>BlockNode</code> list with two items</td>\n<td>Flat structure, no nesting</td>\n</tr>\n<tr>\n<td>Simple ordered</td>\n<td><code>1. First\\n2. Second</code></td>\n<td>Single ordered list with sequential numbering</td>\n<td>Preserves start numbers</td>\n</tr>\n<tr>\n<td>Nested unordered</td>\n<td><code>- Parent\\n  - Child\\n- Sibling</code></td>\n<td>Nested list structure</td>\n<td>Child list within first item</td>\n</tr>\n<tr>\n<td>Mixed nesting</td>\n<td><code>1. Ordered\\n   - Unordered child\\n2. Next</code></td>\n<td>Mixed list types in hierarchy</td>\n<td>Proper type preservation</td>\n</tr>\n<tr>\n<td>Multi-paragraph items</td>\n<td><code>- Para 1\\n\\n  Para 2\\n- Next item</code></td>\n<td>Items containing multiple blocks</td>\n<td>Paragraph nesting within items</td>\n</tr>\n</tbody></table>\n<p><strong>Indentation Tracking Verification</strong> ensures that the <code>ListContext</code> and indentation calculation work correctly across different scenarios.</p>\n<table>\n<thead>\n<tr>\n<th>Indentation Scenario</th>\n<th>Test Case</th>\n<th>Expected Behavior</th>\n<th>Error Detection</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Consistent spaces</td>\n<td>All items use 2-space indent</td>\n<td>Proper nesting levels calculated</td>\n<td>Should build clean hierarchy</td>\n</tr>\n<tr>\n<td>Tab vs space mixing</td>\n<td>Some items use tabs, others spaces</td>\n<td>Normalized to consistent spacing</td>\n<td>Should detect and handle gracefully</td>\n</tr>\n<tr>\n<td>Lazy continuation</td>\n<td>Multi-line items without full indent</td>\n<td>Content correctly attributed to items</td>\n<td>Should not break item boundaries</td>\n</tr>\n<tr>\n<td>Over-indentation</td>\n<td>Items indented more than required</td>\n<td>Treated as code blocks within items</td>\n<td>Should preserve extra indentation</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Verification Steps</strong> for list parsing:</p>\n<ol>\n<li><strong>Test complex nesting scenarios</strong> with multiple levels and mixed types</li>\n<li><strong>Verify tight vs loose list detection</strong> by checking spacing between items</li>\n<li><strong>Validate continuation line handling</strong> for items spanning multiple lines</li>\n<li><strong>Test list boundary detection</strong> - where lists end and other blocks begin</li>\n<li><strong>Check marker consistency enforcement</strong> within single lists</li>\n</ol>\n<h4 id=\"milestone-4-html-generation-verification\">Milestone 4: HTML Generation Verification</h4>\n<p><strong>HTML Validity Verification</strong> ensures that the generated HTML is standards-compliant and semantically correct.</p>\n<table>\n<thead>\n<tr>\n<th>Validity Aspect</th>\n<th>Verification Method</th>\n<th>Expected Result</th>\n<th>Validation Tool</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTML5 Compliance</td>\n<td>W3C validator on generated output</td>\n<td>Zero validation errors</td>\n<td>Nu HTML Checker</td>\n</tr>\n<tr>\n<td>Character Escaping</td>\n<td>Special characters in various contexts</td>\n<td>Proper entity encoding</td>\n<td>Manual inspection + validation</td>\n</tr>\n<tr>\n<td>Tag Nesting</td>\n<td>Complex nested structures</td>\n<td>Properly closed and nested tags</td>\n<td>HTML parser verification</td>\n</tr>\n<tr>\n<td>Attribute Formatting</td>\n<td>Links, images with various attributes</td>\n<td>Quoted, escaped attribute values</td>\n<td>Attribute syntax validation</td>\n</tr>\n<tr>\n<td>Semantic Correctness</td>\n<td>Markdown meaning preserved in HTML</td>\n<td>Equivalent semantic meaning</td>\n<td>Manual comparison</td>\n</tr>\n</tbody></table>\n<p><strong>Pretty Printing Verification</strong> validates that the optional formatting produces readable, well-structured HTML output.</p>\n<table>\n<thead>\n<tr>\n<th>Formatting Aspect</th>\n<th>Test Case</th>\n<th>Expected Output</th>\n<th>Quality Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Consistent Indentation</td>\n<td>Nested block structures</td>\n<td>Each nesting level properly indented</td>\n<td>2-space increments</td>\n</tr>\n<tr>\n<td>Line Breaking</td>\n<td>Long documents</td>\n<td>Appropriate line breaks between blocks</td>\n<td>Readable structure</td>\n</tr>\n<tr>\n<td>Inline Element Handling</td>\n<td>Mixed block and inline content</td>\n<td>Inline elements on same line as parents</td>\n<td>No unnecessary breaks</td>\n</tr>\n<tr>\n<td>Whitespace Preservation</td>\n<td>Code blocks and preformatted text</td>\n<td>Exact whitespace preservation where needed</td>\n<td>Content fidelity</td>\n</tr>\n</tbody></table>\n<p><strong>End-to-End Integration Verification</strong> tests the complete pipeline from markdown input to HTML output.</p>\n<table>\n<thead>\n<tr>\n<th>Integration Test</th>\n<th>Input Document Type</th>\n<th>Validation Criteria</th>\n<th>Success Metric</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CommonMark Specification Examples</td>\n<td>Official CommonMark test suite</td>\n<td>Matches expected HTML output</td>\n<td>100% spec compliance</td>\n</tr>\n<tr>\n<td>Real-world Documents</td>\n<td>GitHub README files, documentation</td>\n<td>Produces usable, readable HTML</td>\n<td>Visual inspection passes</td>\n</tr>\n<tr>\n<td>Stress Testing</td>\n<td>Large documents (1000+ lines)</td>\n<td>Completes without errors or crashes</td>\n<td>Performance within bounds</td>\n</tr>\n<tr>\n<td>Malformed Input Recovery</td>\n<td>Documents with syntax errors</td>\n<td>Produces valid HTML despite errors</td>\n<td>Graceful degradation</td>\n</tr>\n</tbody></table>\n<p><strong>Final Verification Command Sequence</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Run complete test suite</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/</span><span style=\"color:#79B8FF\"> -v</span><span style=\"color:#79B8FF\"> --cov=markdown_parser</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Validate against CommonMark spec examples</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> scripts/run_spec_tests.py</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Generate HTML from sample documents</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from markdown_parser import MarkdownParser</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">parser = MarkdownParser()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">html = parser.parse_to_html(open('samples/comprehensive_test.md').read())</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">print(html)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> ></span><span style=\"color:#9ECBFF\"> output.html</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Validate generated HTML</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">curl</span><span style=\"color:#79B8FF\"> -X</span><span style=\"color:#9ECBFF\"> POST</span><span style=\"color:#79B8FF\"> -F</span><span style=\"color:#9ECBFF\"> \"file=@output.html\"</span><span style=\"color:#9ECBFF\"> https://validator.w3.org/nu/</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Performance baseline test</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">time</span><span style=\"color:#E1E4E8\"> python -c </span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from markdown_parser import MarkdownParser</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">parser = MarkdownParser()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">html = parser.parse_to_html(open('samples/large_document.md').read())</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<blockquote>\n<p>The verification checkpoints serve as both quality gates and confidence builders. Each checkpoint confirms that the implementation is solid before adding complexity in the next milestone. This systematic approach prevents the common trap of building on unstable foundations.</p>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete tools and approaches for implementing a comprehensive testing strategy that supports both learning and quality assurance throughout the markdown renderer development process.</p>\n<h4 id=\"technology-recommendations-table\">Technology Recommendations Table</h4>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unit Testing Framework</td>\n<td><code>unittest</code> (Python standard library)</td>\n<td><code>pytest</code> with fixtures and parametrization</td>\n</tr>\n<tr>\n<td>Test Data Management</td>\n<td>Inline strings in test methods</td>\n<td>External test files with YAML/JSON metadata</td>\n</tr>\n<tr>\n<td>Property-Based Testing</td>\n<td>Manual edge case enumeration</td>\n<td><code>hypothesis</code> library for automated input generation</td>\n</tr>\n<tr>\n<td>HTML Validation</td>\n<td>Manual inspection with browser</td>\n<td>Automated W3C validator API integration</td>\n</tr>\n<tr>\n<td>Performance Testing</td>\n<td>Simple timing with <code>time</code> module</td>\n<td><code>pytest-benchmark</code> with statistical analysis</td>\n</tr>\n<tr>\n<td>Coverage Analysis</td>\n<td>Visual code inspection</td>\n<td><code>coverage.py</code> with branch coverage reporting</td>\n</tr>\n<tr>\n<td>Test Organization</td>\n<td>Single test directory</td>\n<td>Structured hierarchy with milestone-based organization</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>The testing infrastructure should mirror the component architecture while supporting milestone-based development progression:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>markdown_parser/\n├── tests/\n│   ├── __init__.py\n│   ├── conftest.py                    ← pytest configuration and shared fixtures\n│   ├── test_data/                     ← shared test documents and expected outputs\n│   │   ├── milestone1_blocks.md       ← comprehensive block parsing test cases\n│   │   ├── milestone2_inline.md       ← inline formatting test cases\n│   │   ├── milestone3_lists.md        ← list parsing test cases\n│   │   ├── milestone4_complete.md     ← full integration test document\n│   │   ├── expected_outputs/          ← expected HTML outputs for integration tests\n│   │   └── malformed_inputs/          ← error handling test cases\n│   ├── unit/                          ← component-level tests\n│   │   ├── __init__.py\n│   │   ├── test_preprocessor.py       ← line processing and normalization tests\n│   │   ├── test_block_parser.py       ← block parsing unit tests\n│   │   ├── test_inline_parser.py      ← inline parsing unit tests\n│   │   ├── test_list_parser.py        ← list parsing unit tests\n│   │   ├── test_html_generator.py     ← HTML generation unit tests\n│   │   └── test_ast_nodes.py          ← AST data structure tests\n│   ├── integration/                   ← multi-component interaction tests\n│   │   ├── __init__.py\n│   │   ├── test_milestone1.py         ← block parsing integration tests\n│   │   ├── test_milestone2.py         ← inline parsing integration tests\n│   │   ├── test_milestone3.py         ← list parsing integration tests\n│   │   ├── test_milestone4.py         ← complete pipeline integration tests\n│   │   └── test_pipeline.py           ← end-to-end pipeline tests\n│   ├── property/                      ← property-based and generative tests\n│   │   ├── __init__.py\n│   │   ├── test_roundtrip.py          ← roundtrip stability tests\n│   │   ├── test_performance.py        ← performance and scalability tests\n│   │   └── test_error_recovery.py     ← error handling property tests\n│   ├── spec_compliance/               ← CommonMark specification compliance\n│   │   ├── __init__.py\n│   │   ├── test_commonmark_spec.py    ← official spec test runner\n│   │   └── commonmark_examples.json   ← spec examples in JSON format\n│   └── manual/                        ← manual testing scripts and tools\n│       ├── debug_ast_viewer.py        ← interactive AST exploration tool\n│       ├── html_validator.py          ← HTML validation utility\n│       └── performance_profiler.py    ← performance analysis tool\n├── scripts/                           ← testing automation scripts\n│   ├── run_milestone_tests.py         ← milestone-specific test runner\n│   ├── generate_coverage_report.py    ← coverage analysis automation\n│   └── validate_html_output.py        ← batch HTML validation</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete Test Configuration Setup</strong> (<code>tests/conftest.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Pytest configuration and shared test fixtures for markdown parser testing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides common test utilities and data that can be reused across test modules.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> yaml</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> markdown_parser.core </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> MarkdownParser</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> markdown_parser.ast_nodes </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ASTNode, BlockNode, InlineNode</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> markdown_parser.html_generator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> HtmlRenderer</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test data directory path</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">TEST_DATA_DIR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Path(</span><span style=\"color:#79B8FF\">__file__</span><span style=\"color:#E1E4E8\">).parent </span><span style=\"color:#F97583\">/</span><span style=\"color:#9ECBFF\"> \"test_data\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> parser</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provides a fresh MarkdownParser instance for each test.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> MarkdownParser()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> html_renderer</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provides an HtmlRenderer instance with default settings.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> HtmlRenderer(</span><span style=\"color:#FFAB70\">pretty_print</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> sample_documents</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Loads all sample documents from test_data directory.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    documents </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> md_file </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> TEST_DATA_DIR</span><span style=\"color:#E1E4E8\">.glob(</span><span style=\"color:#9ECBFF\">\"*.md\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(md_file, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">encoding</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            documents[md_file.stem] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> f.read()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> documents</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> expected_outputs</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Loads expected HTML outputs for integration testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    outputs </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected_dir </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> TEST_DATA_DIR</span><span style=\"color:#F97583\"> /</span><span style=\"color:#9ECBFF\"> \"expected_outputs\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> html_file </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> expected_dir.glob(</span><span style=\"color:#9ECBFF\">\"*.html\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(html_file, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">encoding</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            outputs[html_file.stem] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> f.read().strip()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> outputs</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> commonmark_examples</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Loads CommonMark specification examples for compliance testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    spec_file </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> TEST_DATA_DIR</span><span style=\"color:#E1E4E8\">.parent </span><span style=\"color:#F97583\">/</span><span style=\"color:#9ECBFF\"> \"spec_compliance\"</span><span style=\"color:#F97583\"> /</span><span style=\"color:#9ECBFF\"> \"commonmark_examples.json\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> spec_file.exists():</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        with</span><span style=\"color:#79B8FF\"> open</span><span style=\"color:#E1E4E8\">(spec_file, </span><span style=\"color:#9ECBFF\">'r'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">encoding</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> f:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> json.load(f)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ASTTestHelpers</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Helper methods for testing AST structure and content.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> count_nodes_by_type</span><span style=\"color:#E1E4E8\">(root: ASTNode, node_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Count all nodes of specified type in AST tree.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(root, </span><span style=\"color:#9ECBFF\">'node_type'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> root.node_type.name </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> node_type:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> getattr</span><span style=\"color:#E1E4E8\">(root, </span><span style=\"color:#9ECBFF\">'children'</span><span style=\"color:#E1E4E8\">, []):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> ASTTestHelpers.count_nodes_by_type(child, node_type)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> extract_text_content</span><span style=\"color:#E1E4E8\">(node: ASTNode) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Extract all text content from node and descendants.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        text_parts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'text_content'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> node.text_content:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            text_parts.append(node.text_content)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> hasattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'inline_content'</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> node.inline_content:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            text_parts.append(node.inline_content)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> getattr</span><span style=\"color:#E1E4E8\">(node, </span><span style=\"color:#9ECBFF\">'children'</span><span style=\"color:#E1E4E8\">, []):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            text_parts.append(ASTTestHelpers.extract_text_content(child))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> ''</span><span style=\"color:#E1E4E8\">.join(text_parts)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> find_nodes_with_content</span><span style=\"color:#E1E4E8\">(root: ASTNode, content_substring: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[ASTNode]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Find all nodes containing specified text content.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        matches </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        node_text </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ASTTestHelpers.extract_text_content(root)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> content_substring </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> node_text:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            matches.append(root)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> child </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> getattr</span><span style=\"color:#E1E4E8\">(root, </span><span style=\"color:#9ECBFF\">'children'</span><span style=\"color:#E1E4E8\">, []):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            matches.extend(ASTTestHelpers.find_nodes_with_content(child, content_substring))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> matches</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> ast_helpers</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provides AST testing helper methods.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> ASTTestHelpers()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HTMLValidationHelpers</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Helper methods for validating generated HTML output.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_html_structure</span><span style=\"color:#E1E4E8\">(html: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Basic HTML structure validation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        from</span><span style=\"color:#E1E4E8\"> html.parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> HTMLParser</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        class</span><span style=\"color:#B392F0\"> ValidationParser</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">HTMLParser</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.tag_stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.warnings </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            def</span><span style=\"color:#B392F0\"> handle_starttag</span><span style=\"color:#E1E4E8\">(self, tag, attrs):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> tag </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">'br'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'hr'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'img'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'input'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'meta'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'link'</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">.tag_stack.append(tag)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            def</span><span style=\"color:#B392F0\"> handle_endtag</span><span style=\"color:#E1E4E8\">(self, tag):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.tag_stack </span><span style=\"color:#F97583\">and</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.tag_stack[</span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> tag:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">.tag_stack.pop()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">.errors.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Mismatched closing tag: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">tag</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            def</span><span style=\"color:#B392F0\"> error</span><span style=\"color:#E1E4E8\">(self, message):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.errors.append(message)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ValidationParser()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            parser.feed(html)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'valid'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(parser.errors) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'errors'</span><span style=\"color:#E1E4E8\">: parser.errors,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'warnings'</span><span style=\"color:#E1E4E8\">: parser.warnings,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'unclosed_tags'</span><span style=\"color:#E1E4E8\">: parser.tag_stack</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'valid'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'errors'</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Parse error: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'warnings'</span><span style=\"color:#E1E4E8\">: [],</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'unclosed_tags'</span><span style=\"color:#E1E4E8\">: []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> check_character_escaping</span><span style=\"color:#E1E4E8\">(html: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify that special characters are properly escaped.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check for unescaped special characters in content (not attributes)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        content_pattern </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#DBEDFF\">></span><span style=\"color:#79B8FF\">([</span><span style=\"color:#F97583\">^</span><span style=\"color:#79B8FF\">&#x3C;]</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">)</span><span style=\"color:#DBEDFF\">&#x3C;</span><span style=\"color:#9ECBFF\">'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        content_matches </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> re.findall(content_pattern, html)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'ampersands_escaped'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">all</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'&#x26;'</span><span style=\"color:#F97583\"> not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> content </span><span style=\"color:#F97583\">or</span><span style=\"color:#9ECBFF\"> '&#x26;amp;'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> content </span><span style=\"color:#F97583\">or</span><span style=\"color:#9ECBFF\"> '&#x26;lt;'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> content </span><span style=\"color:#F97583\">or</span><span style=\"color:#9ECBFF\"> '&#x26;gt;'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> content </span><span style=\"color:#F97583\">or</span><span style=\"color:#9ECBFF\"> '&#x26;quot;'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> content </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> content </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> content_matches),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'less_than_escaped'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">all</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'&#x3C;'</span><span style=\"color:#F97583\"> not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> content </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> content </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> content_matches),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'greater_than_escaped'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">all</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'>'</span><span style=\"color:#F97583\"> not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> content </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> content </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> content_matches),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'quotes_handled'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">True</span><span style=\"color:#6A737D\">  # More complex check needed for attribute contexts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> results</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> html_helpers</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provides HTML validation helper methods.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> HTMLValidationHelpers()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Performance testing utilities</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@pytest.fixture</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> performance_tracker</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Provides performance tracking utilities for tests.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> psutil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    class</span><span style=\"color:#B392F0\"> PerformanceTracker</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.process </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> psutil.Process(os.getpid())</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.start_memory </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        def</span><span style=\"color:#B392F0\"> start_tracking</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.start_memory </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.process.memory_info().rss</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        def</span><span style=\"color:#B392F0\"> stop_tracking</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            end_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            end_memory </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.process.memory_info().rss</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'duration_seconds'</span><span style=\"color:#E1E4E8\">: end_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.start_time,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'memory_delta_bytes'</span><span style=\"color:#E1E4E8\">: end_memory </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.start_memory,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'final_memory_mb'</span><span style=\"color:#E1E4E8\">: end_memory </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">1024</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> PerformanceTracker()</span></span></code></pre></div>\n\n<p><strong>Complete Test Data Generator</strong> (<code>scripts/generate_test_cases.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Generates comprehensive test cases for all markdown parser components.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Creates both positive test cases and negative/edge case scenarios.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Dict, Any, Tuple</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> generate_block_test_cases</span><span style=\"color:#E1E4E8\">() -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Generate comprehensive block parsing test cases.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    test_cases </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'milestone1_blocks'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"\"\"# Top Level Heading</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">This is a regular paragraph with some text that spans</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">multiple lines but should be grouped together.</span></span></code></pre></div>\n\n<h2 id=\"second-level-heading\">Second Level Heading</h2>\n<p>Another paragraph here.</p>\n<h3 id=\"third-level-heading\">Third Level Heading</h3>\n<pre><code>This is indented code block\nwith multiple lines\nand preserved spacing\n</code></pre>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># This is fenced code block</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> hello_world</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Hello, World!\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Plain fenced code without language</code></pre></div>\n\n<blockquote>\n<p>This is a blockquote\nthat spans multiple lines\nand maintains formatting</p>\n</blockquote>\n<blockquote>\n<h2 id=\"heading-in-blockquote\">Heading in blockquote</h2>\n<p>Paragraph in blockquote with blank lines around it.</p>\n</blockquote>\n<hr>\n<p>Horizontal rule above.</p>\n<hr>\n<p>Another horizontal rule.</p>\n<hr>\n<p>Third horizontal rule style.</p>\n<h4 id=\"nested-blockquotes\">Nested Blockquotes</h4>\n<blockquote>\n<p>Level 1 quote</p>\n<blockquote>\n<p>Level 2 nested quote<br>Still level 2\nBack to level 1</p>\n</blockquote>\n</blockquote>\n<h5 id=\"mixed-block-types\">Mixed Block Types</h5>\n<p>Regular paragraph followed by:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Code block</code></pre></div>\n\n<blockquote>\n<p>Quote block</p>\n</blockquote>\n<p>More regular text.</p>\n<h6 id=\"edge-cases\">Edge Cases</h6>\n<h1 id=\"heading-with-extra-spaces\">Heading with extra spaces</h1>\n<h2 id=\"heading-with-leading-spaces\">Heading with leading spaces</h2>\n<p>#No space after hash</p>\n<h1 id=\"\"></h1>\n<p>Empty heading content above.</p>\n<p>####### Invalid - too many hashes</p>\n<h1 id=\"setext-heading-level-1\">Setext Heading Level 1</h1>\n<h2 id=\"setext-heading-level-2\">Setext Heading Level 2</h2>\n<p>Not a setext heading\n---regular text continues---\n&quot;&quot;&quot;,</p>\n<pre><code>    &#39;edge_cases_blocks&#39;: &quot;&quot;&quot;\n</code></pre>\n<p>Document starting with blank lines.</p>\n<h1 id=\"heading-immediately-after-blanks\">Heading immediately after blanks</h1>\n<p>Paragraph with trailing spaces.   </p>\n<pre><code>Indented code with trailing spaces    \nSecond line of code  \n</code></pre>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">javascript</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Fenced code with empty lines</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">);</span></span></code></pre></div>\n\n<blockquote>\n<p>Blockquote with trailing spaces<br>Second line  </p>\n</blockquote>\n<hr>\n<p>Text immediately after horizontal rule.</p>\n<p>Mixed line endings test case would be handled by test runner.</p>\n<p>Last paragraph without trailing newline.&quot;&quot;&quot;\n    }</p>\n<pre><code>return test_cases\n</code></pre>\n<p>def generate_inline_test_cases() -&gt; Dict[str, str]:\n    &quot;&quot;&quot;Generate comprehensive inline parsing test cases.&quot;&quot;&quot;</p>\n<pre><code>test_cases = {\n    &#39;milestone2_inline&#39;: &quot;&quot;&quot;# Inline Formatting Tests\n</code></pre>\n<h2 id=\"basic-emphasis\">Basic Emphasis</h2>\n<p>This paragraph contains <strong>bold text</strong> and <em>italic text</em> for testing.</p>\n<p>Also testing <strong>bold with underscores</strong> and <em>italic with underscores</em>.</p>\n<h2 id=\"nested-formatting\">Nested Formatting</h2>\n<p>Here is <strong>bold text with <em>italic inside</em> it</strong> for testing nesting.</p>\n<p>And here is <em>italic text with <strong>bold inside</strong> it</em> for reverse nesting.</p>\n<h2 id=\"code-spans\">Code Spans</h2>\n<p>Here is <code>inline code</code> within a sentence.</p>\n<p>Here is <code>code with **bold** inside</code> where the bold should not render.</p>\n<h2 id=\"links-and-images\">Links and Images</h2>\n<p>This is a <a href=\"http://example.com\">simple link</a> in text.</p>\n<p>This is a <a href=\"http://example.com\" title=\"Example Title\">link with title</a> including title.</p>\n<p>Here is an image: <img src=\"http://example.com/image.jpg\" alt=\"Alt text\"></p>\n<p>And an image with title: <img src=\"http://example.com/image.jpg\" alt=\"Alt text\" title=\"Image Title\"></p>\n<h2 id=\"complex-link-cases\">Complex Link Cases</h2>\n<p><a href=\"http://example.com\">Link with <em>emphasis</em> in text</a></p>\n<p><a href=\"http://example.com\">Link with <code>code</code> in text</a></p>\n<h2 id=\"edge-cases-for-emphasis\">Edge Cases for Emphasis</h2>\n<p>This has <em>emphasis at start</em> of sentence.</p>\n<p>This has emphasis <em>at the end</em>.</p>\n<p><em>Emphasis at paragraph start</em> looks like this.</p>\n<p>Words with under_scores_inside should not be emphasized.</p>\n<p>But <em>this should be emphasized</em> because it has word boundaries.</p>\n<h2 id=\"escape-sequences\">Escape Sequences</h2>\n<p>This has \\<em>escaped asterisks\\</em> that should not format.</p>\n<p>And \\<code>escaped backticks\\\\</code> that should not format.</p>\n<p>Also \\[escaped brackets\\] and \\! exclamation points.</p>\n<h2 id=\"complex-combinations\">Complex Combinations</h2>\n<p><strong>Bold text with <a href=\"http://example.com\">a link</a> inside</strong>.</p>\n<p><em>Italic text with <code>code</code> and <a href=\"http://example.com\">link</a> inside</em>.</p>\n<p><a href=\"http://example.com\">Link with <strong>bold</strong> and <em>italic</em> text</a></p>\n<h2 id=\"delimiter-matching-edge-cases\">Delimiter Matching Edge Cases</h2>\n<p><strong>This is bold</strong> but <strong>this</strong> is also <strong>bold</strong>.</p>\n<p><em>Single</em> and <em>multiple</em> and <em>italic</em> spans.</p>\n<p>**Unmatched bold at end</p>\n<p>*Unmatched italic at end</p>\n<p><em><em>Bold with <em>italic inside</em></em> and back to normal</em>.</p>\n<p>Mismatched delimiters: *<em>bold</em> should not work.</p>\n<h2 id=\"url-edge-cases\">URL Edge Cases</h2>\n<p>[Link with spaces in URL](<a href=\"http://example.com/path\">http://example.com/path</a> with spaces)</p>\n<p><a href=\"http://example.com/path?param=value&other=value2\">Link with special chars</a></p>\n<p><a href=\"http://autolink.example.com\">http://autolink.example.com</a></p>\n<p><a href=\"mailto:autolink@email.com\">autolink@email.com</a>\n&quot;&quot;&quot;,</p>\n<pre><code>    &#39;delimiter_edge_cases&#39;: &quot;&quot;&quot;**bold**normal*italic*normal**bold**\n</code></pre>\n<p><em><strong>bold italic</strong></em> combined</p>\n<p><strong>bold <em>italic in bold</em> bold</strong></p>\n<p><em>italic <strong>bold in italic</strong> italic</em></p>\n<p>snake_case_variable_name</p>\n<p><em>emphasis_with_underscores</em></p>\n<p><strong>double__underscore__test</strong></p>\n<p><em>emphasis</em> and <strong>bold</strong> and <code>code</code></p>\n<p><a href=\"url\">link</a><em>italic</em><a href=\"url\">link</a></p>\n<p><img src=\"url\" alt=\"image\"><strong>bold</strong><img src=\"url\" alt=\"image\"></p>\n<p><code>code with *emphasis* inside</code></p>\n<p><code>code</code> and <em>emphasis</em> and <code>code</code></p>\n<p><strong>bold\nacross\nlines</strong></p>\n<p><em>italic\nacross<br>lines</em></p>\n<hr>\n<p>This is <strong>bold and <a href=\"http://example.com\">link</a> and <code>code</code></strong> together.</p>\n<p><em>This is italic with <img src=\"image.jpg\" alt=\"image\"> inside.</em></p>\n<hr>\n<p>Edge case: ** (empty emphasis)</p>\n<p>Edge case: __ (empty emphasis)</p>\n<p>Edge case: ` (single backtick)</p>\n<p>Edge case: ```</p>\n<p>[](empty link)</p>\n<p>![](empty image)\n&quot;&quot;&quot;\n    }</p>\n<pre><code>return test_cases\n</code></pre>\n<p>def generate_list_test_cases() -&gt; Dict[str, str]:\n    &quot;&quot;&quot;Generate comprehensive list parsing test cases.&quot;&quot;&quot;</p>\n<pre><code>test_cases = {\n    &#39;milestone3_lists&#39;: &quot;&quot;&quot;# List Parsing Tests\n</code></pre>\n<h2 id=\"simple-unordered-lists\">Simple Unordered Lists</h2>\n<ul>\n<li>First item</li>\n<li>Second item</li>\n<li>Third item</li>\n</ul>\n<ul>\n<li>Alternative bullet style</li>\n<li>Second item with asterisk</li>\n<li>Third item</li>\n</ul>\n<ul>\n<li>Plus sign bullets</li>\n<li>Second item with plus</li>\n<li>Third item</li>\n</ul>\n<h2 id=\"simple-ordered-lists\">Simple Ordered Lists</h2>\n<ol>\n<li>First numbered item</li>\n<li>Second numbered item</li>\n<li>Third numbered item</li>\n</ol>\n<ol>\n<li>Alternative parenthesis style</li>\n<li>Second item with parenthesis</li>\n<li>Third item</li>\n</ol>\n<h2 id=\"nested-lists\">Nested Lists</h2>\n<ul>\n<li>Top level item<ul>\n<li>Nested item level 2</li>\n<li>Another nested item<ul>\n<li>Deeper nesting level 3</li>\n<li>More deep content</li>\n</ul>\n</li>\n<li>Back to level 2</li>\n</ul>\n</li>\n<li>Back to top level</li>\n</ul>\n<h2 id=\"mixed-list-types\">Mixed List Types</h2>\n<ol>\n<li>Ordered parent<ul>\n<li>Unordered child</li>\n<li>Another unordered child<ol>\n<li>Ordered grandchild</li>\n<li>Another ordered grandchild</li>\n</ol>\n</li>\n<li>Back to unordered child level</li>\n</ul>\n</li>\n<li>Second ordered parent</li>\n</ol>\n<h2 id=\"multi-paragraph-list-items\">Multi-paragraph List Items</h2>\n<ul>\n<li><p>First item with single paragraph</p>\n</li>\n<li><p>Second item with multiple paragraphs</p>\n<p>This is the second paragraph of the second item.\nIt continues here.</p>\n<p>And this is a third paragraph in the same item.</p>\n</li>\n<li><p>Third item back to single paragraph</p>\n</li>\n</ul>\n<h2 id=\"lists-with-code-blocks\">Lists with Code Blocks</h2>\n<ol>\n<li><p>Item with indented code block:</p>\n<pre><code>def example_function():\n    return &quot;Hello World&quot;\n</code></pre>\n</li>\n<li><p>Item with fenced code block:</p>\n</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">   def</span><span style=\"color:#B392F0\"> another_example</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">       print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"In a list!\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li>Regular item after code</li>\n</ol>\n<h2 id=\"lists-with-blockquotes\">Lists with Blockquotes</h2>\n<ul>\n<li><p>Item with blockquote:</p>\n<blockquote>\n<p>This is a quote inside a list item.\nIt continues on multiple lines.</p>\n</blockquote>\n</li>\n<li><p>Another regular item</p>\n</li>\n</ul>\n<h2 id=\"tight-vs-loose-lists\">Tight vs Loose Lists</h2>\n<p>Tight list (no blank lines):</p>\n<ul>\n<li>Item 1</li>\n<li>Item 2</li>\n<li>Item 3</li>\n</ul>\n<p>Loose list (blank lines between items):</p>\n<ul>\n<li><p>Item 1</p>\n</li>\n<li><p>Item 2</p>\n</li>\n<li><p>Item 3</p>\n</li>\n</ul>\n<h2 id=\"complex-nesting-with-mixed-content\">Complex Nesting with Mixed Content</h2>\n<ol>\n<li><p>First ordered item</p>\n<p>This item has a paragraph.</p>\n<ul>\n<li><p>Nested unordered list</p>\n</li>\n<li><p>With multiple items</p>\n<ol>\n<li><p>And further nesting</p>\n</li>\n<li><p>With ordered list</p>\n<blockquote>\n<p>And even blockquotes\nInside nested items</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ul>\n<p>Back to paragraph in first item.</p>\n</li>\n<li><p>Second ordered item with <code>inline code</code></p>\n</li>\n</ol>\n<h2 id=\"edge-cases\">Edge Cases</h2>\n<ul>\n<li>Item with <em>emphasis</em> and <strong>bold</strong> and <a href=\"http://example.com\">links</a></li>\n<li>Item with <code>inline code</code> formatting</li>\n<li>Item ending with colon:</li>\n<li>Item with trailing spaces<br>-Item without space after marker\n-Nested without proper spacing\n  -Deep nesting spacing issues</li>\n</ul>\n<h2 id=\"lazy-continuation\">Lazy Continuation</h2>\n<ul>\n<li><p>This is a lazy continuation\nwhere the second line doesn&#39;t have\nproper indentation but should still\nbe part of the same item.</p>\n<ul>\n<li>Nested item</li>\n</ul>\n</li>\n</ul>\n<p>with lazy continuation\nthat continues without indentation.</p>\n<h2 id=\"list-marker-consistency\">List Marker Consistency</h2>\n<ul>\n<li>First item with dash</li>\n<li>Second item with dash</li>\n</ul>\n<ul>\n<li>This starts a new list with asterisk</li>\n<li>Because marker changed</li>\n</ul>\n<ol>\n<li>Ordered list</li>\n<li>Continues with same marker</li>\n</ol>\n<ol>\n<li>This starts new list with different marker</li>\n<li>Because marker style changed</li>\n</ol>\n<h2 id=\"lists-at-document-boundaries\">Lists at Document Boundaries</h2>\n<p>First paragraph.</p>\n<ul>\n<li>List immediately after paragraph</li>\n<li>Without blank line</li>\n</ul>\n<p>Last list at end of document:</p>\n<ul>\n<li><p>Item 1</p>\n</li>\n<li><p>Item 2&quot;&quot;&quot;,</p>\n<pre><code>  &#39;list_edge_cases&#39;: &quot;&quot;&quot;1.No space after period\n</code></pre>\n</li>\n</ul>\n<ol start=\"2\">\n<li>Item with proper space</li>\n</ol>\n<p>-No space after dash</p>\n<ul>\n<li>Item with proper space</li>\n</ul>\n<ol>\n<li>Multiple spaces after period</li>\n</ol>\n<ul>\n<li>Multiple spaces after dash</li>\n</ul>\n<ol>\n<li>Indented ordered list</li>\n<li>Second indented item</li>\n</ol>\n<ul>\n<li><p>List with lots of content</p>\n<p>Multiple paragraphs in item.</p>\n<blockquote>\n<p>Blockquote in item</p>\n</blockquote>\n<pre><code>Code in item\n</code></pre>\n<p>More text.</p>\n</li>\n<li><p>Next item</p>\n</li>\n</ul>\n<ol start=\"15\">\n<li><p>List starting with large number</p>\n</li>\n<li><p>Continues correctly</p>\n</li>\n<li><p>List starting with zero</p>\n</li>\n<li><p>Next item</p>\n</li>\n</ol>\n<p>-1. Invalid negative number (should be paragraph)</p>\n<ol>\n<li>Item</li>\n<li>Invalid nesting (different marker continuation)</li>\n</ol>\n<p>1.Item without space\n 2. Item with wrong indentation</p>\n<p>Text</p>\n<ol>\n<li>List after text without blank line</li>\n<li>Should still work per CommonMark</li>\n</ol>\n<p>Paragraph</p>\n<ul>\n<li>Unordered after paragraph</li>\n<li>Also works</li>\n</ul>\n<p>Mixed indentation:\n\t1. Tab indented\n    2. Space indented (may cause issues)</p>\n<h2 id=\"empty-items\">Empty items:</h2>\n<ul>\n<li>Item after empty</li>\n<li></li>\n</ul>\n<p>Trailing content:</p>\n<ol>\n<li><p>Item with trailing content...</p>\n</li>\n<li><p>...continues here\n&quot;&quot;&quot;\n }</p>\n<p> return test_cases</p>\n</li>\n</ol>\n<p>def generate_html_output_test_cases() -&gt; Dict[str, str]:\n    &quot;&quot;&quot;Generate expected HTML outputs for integration testing.&quot;&quot;&quot;</p>\n<pre><code>expected_outputs = {\n    &#39;simple_blocks&#39;: &quot;&quot;&quot;&lt;!DOCTYPE html&gt;\n</code></pre>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Generated HTML</title>\n</head>\n<body>\n  <h1 id=\"main-heading\">Main Heading</h1>\n  <p>This is a simple paragraph with some text.</p>\n  <h2 id=\"subheading\">Subheading</h2>\n  <p>Another paragraph here.</p>\n  <pre><code>Code block content\nwith multiple lines</code></pre>\n  <blockquote>\n    <p>This is a quote block.</p>\n  </blockquote>\n  <hr>\n</body>\n</html>\"\"\",\n        \n<pre><code>    &#39;inline_formatting&#39;: &quot;&quot;&quot;&lt;h1&gt;Inline Tests&lt;/h1&gt;\n</code></pre>\n<p>This has <strong>bold</strong> and <em>italic</em> text.</p>\n<p>Also <code>inline code</code> and <a href=\"http://example.com\">links</a>.</p>\n<p>Complex: <strong>bold with <em>italic</em> inside</strong>.</p>\"\"\",\n        \n<pre><code>    &#39;nested_lists&#39;: &quot;&quot;&quot;&lt;ol&gt;\n</code></pre>\n  <li>\n    <p>First item</p>\n    <ul>\n      <li>Nested item</li>\n      <li>Another nested</li>\n    </ul>\n  </li>\n  <li>Second item</li>\n</ol>\"\"\"\n    }\n    \n<pre><code>return expected_outputs\n</code></pre>\n<p>def create_test_data_files():\n    &quot;&quot;&quot;Create all test data files in the appropriate directory structure.&quot;&quot;&quot;</p>\n<pre><code># Create directory structure\nbase_dir = Path(&quot;tests/test_data&quot;)\nbase_dir.mkdir(parents=True, exist_ok=True)\n\nexpected_dir = base_dir / &quot;expected_outputs&quot;\nexpected_dir.mkdir(exist_ok=True)\n\nmalformed_dir = base_dir / &quot;malformed_inputs&quot;\nmalformed_dir.mkdir(exist_ok=True)\n\n# Generate and write block test cases\nblock_cases = generate_block_test_cases()\nfor name, content in block_cases.items():\n    with open(base_dir / f&quot;{name}.md&quot;, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:\n        f.write(content)\n\n# Generate and write inline test cases\ninline_cases = generate_inline_test_cases()\nfor name, content in inline_cases.items():\n    with open(base_dir / f&quot;{name}.md&quot;, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:\n        f.write(content)\n\n# Generate and write list test cases\nlist_cases = generate_list_test_cases()\nfor name, content in list_cases.items():\n    with open(base_dir / f&quot;{name}.md&quot;, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:\n        f.write(content)\n\n# Generate and write expected HTML outputs\nhtml_outputs = generate_html_output_test_cases()\nfor name, content in html_outputs.items():\n    with open(expected_dir / f&quot;{name}.html&quot;, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:\n        f.write(content)\n\nprint(f&quot;Generated test data files in {base_dir}&quot;)\n</code></pre>\n<p>if <strong>name</strong> == &quot;<strong>main</strong>&quot;:\n    create_test_data_files()</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Block Parser Test Template</strong> (<code>tests/unit/test_block_parser.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Unit tests for block-level element parsing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Tests each block type in isolation to verify correct parsing behavior.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> pytest</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> markdown_parser.block_parser </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BlockParser, BlockParserState</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> markdown_parser.ast_nodes </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BlockNode, NodeType, BlockType</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> markdown_parser.preprocessor </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> LineInfo</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestBlockParserCore</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test core block parser functionality.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_parser_initialization</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify parser initializes with correct default state.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parser </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BlockParser()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert parser state is LOOKING_FOR_BLOCK</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert document root is created with correct type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Assert line buffer is empty</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_line_processing_basic</span><span style=\"color:#E1E4E8\">(self, parser):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test basic line processing without specific block types.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"Regular text\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"More text\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Process line sequence through parser</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify correct number of blocks created</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check that blank lines separate blocks appropriately</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate final parser state</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestATXHeadings</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test ATX-style heading parsing (#, ##, ###, etc.).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @pytest.mark.parametrize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"level,markdown,expected_text\"</span><span style=\"color:#E1E4E8\">, [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"# Heading 1\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Heading 1\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"## Heading 2\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Heading 2\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"### Heading 3\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Heading 3\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"#### Heading 4\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Heading 4\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"##### Heading 5\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Heading 5\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        (</span><span style=\"color:#79B8FF\">6</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"###### Heading 6\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Heading 6\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_atx_heading_levels</span><span style=\"color:#E1E4E8\">(self, parser, level, markdown, expected_text):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test all valid ATX heading levels parse correctly.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        line </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LineInfo(markdown, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Process line through parser</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify BlockNode created with block_type=HEADING</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check heading level attribute matches expected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify text content matches expected_text</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure no child nodes created for simple heading</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_atx_heading_with_trailing_hashes</span><span style=\"color:#E1E4E8\">(self, parser):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test ATX headings with optional trailing hash marks.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        test_cases </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#9ECBFF\">\"# Heading #\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Heading\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#9ECBFF\">\"## Heading ##\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Heading\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#9ECBFF\">\"### Heading ###\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Heading\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#9ECBFF\">\"# Heading ####\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Heading\"</span><span style=\"color:#E1E4E8\">),  </span><span style=\"color:#6A737D\"># Mismatched trailing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> markdown, expected_text </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> test_cases:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Parse each test case</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify trailing hashes are stripped correctly</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check that mismatched trailing hashes are handled</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_atx_heading_edge_cases</span><span style=\"color:#E1E4E8\">(self, parser):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test edge cases for ATX heading parsing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        edge_cases </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#9ECBFF\">\"#No space\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">),  </span><span style=\"color:#6A737D\"># Should not be heading</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#9ECBFF\">\"# \"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">),          </span><span style=\"color:#6A737D\"># Empty heading content</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#9ECBFF\">\"#######\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">),    </span><span style=\"color:#6A737D\"># Too many hashes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (</span><span style=\"color:#9ECBFF\">\"  # Indented\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">), </span><span style=\"color:#6A737D\"># Indented headings invalid</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> markdown, should_be_heading </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> edge_cases:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Process each edge case</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify heading detection matches expected</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: For non-headings, ensure treated as paragraph</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: For invalid cases, check error recovery</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestSetextHeadings</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test Setext-style heading parsing (underlined headings).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_setext_h1_detection</span><span style=\"color:#E1E4E8\">(self, parser):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test detection of H1 Setext headings with = underlines.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        markdown_lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"Main Heading\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"============\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Process both lines through parser</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify single BlockNode created with HEADING type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check heading level is 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify text content is \"Main Heading\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure underline is not included in content</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_setext_h2_detection</span><span style=\"color:#E1E4E8\">(self, parser):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test detection of H2 Setext headings with - underlines.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Similar test structure as H1 but with dashes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify heading level is 2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test various dash lengths and patterns</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_setext_invalid_cases</span><span style=\"color:#E1E4E8\">(self, parser):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test cases that look like Setext but should not be headings.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        invalid_cases </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Blank line before underline breaks Setext</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            [</span><span style=\"color:#9ECBFF\">\"Text\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"===\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Mixed underline characters</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            [</span><span style=\"color:#9ECBFF\">\"Text\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"=-=\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Underline without preceding text</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            [</span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"===\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test each invalid case</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify they are treated as separate paragraphs/blocks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check no heading nodes are created</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestParagraphs</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test paragraph detection and grouping.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_simple_paragraph</span><span style=\"color:#E1E4E8\">(self, parser):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test basic paragraph creation from consecutive lines.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"First line of paragraph.\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"Second line continues paragraph.\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"Third line also continues.\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Process lines through parser</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify single BlockNode created with PARAGRAPH type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check all lines are included in paragraph content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify line breaks are preserved appropriately</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_paragraph_separation</span><span style=\"color:#E1E4E8\">(self, parser):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test that blank lines separate paragraphs correctly.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"First paragraph.\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"Second paragraph.\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"Third paragraph.\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Process all lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify three separate BlockNode instances created</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check each has PARAGRAPH type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure content separation is correct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify no blank line content in paragraphs</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestCodeBlocks</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test both fenced and indented code block parsing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_fenced_code_basic</span><span style=\"color:#E1E4E8\">(self, parser):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test basic fenced code block parsing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"```\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"code line 1\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"code line 2\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"```\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Process lines through parser</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify BlockNode created with CODE_BLOCK type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check exact content preservation including whitespace</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure fence markers are not included in content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify parser state transitions correctly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_fenced_code_with_language</span><span style=\"color:#E1E4E8\">(self, parser):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test fenced code blocks with language identifiers.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"```python\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"def hello():\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"    print('Hello')\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"```\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Parse and verify language attribute is set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check that language info doesn't appear in content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify code content is preserved exactly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_indented_code_block</span><span style=\"color:#E1E4E8\">(self, parser):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test indented code block parsing (4+ spaces).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"    code line 1\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"    code line 2\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"        more indented\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">8</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"    back to base\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Process indented lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify CODE_BLOCK type created</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check that base indentation is removed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure relative indentation is preserved</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test transition out of code block state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_code_block_edge_cases</span><span style=\"color:#E1E4E8\">(self, parser):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test edge cases for code block parsing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test unclosed fenced code blocks (EOF)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test empty code blocks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test mixed indentation in code blocks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test fence markers inside code content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test language identifiers with spaces/special chars</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestBlockquotes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test blockquote parsing including nested blockquotes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_simple_blockquote</span><span style=\"color:#E1E4E8\">(self, parser):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test basic blockquote parsing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"> This is a quote\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"> It continues here\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Process blockquote lines</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify BLOCKQUOTE type BlockNode created</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check that > markers are stripped from content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure content is preserved correctly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_nested_blockquotes</span><span style=\"color:#E1E4E8\">(self, parser):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test nested blockquote structures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"> Level 1\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\">> Level 2\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\">>> Level 3\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\">> Back to Level 2\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            LineInfo(</span><span style=\"color:#9ECBFF\">\"> Back to Level 1\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Parse nested structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify proper nesting hierarchy in AST</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check parent-child relationships are correct</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure content at each level is accurate</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TestHorizontalRules</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test horizontal rule parsing with different marker styles.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @pytest.mark.parametrize</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"marker_line\"</span><span style=\"color:#E1E4E8\">, [</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"---\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"***\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"___\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"----\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"*****\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"_____\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"- - -\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"* * *\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"_ _ _\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ])</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_horizontal_rule_variants</span><span style=\"color:#E1E4E8\">(self, parser, marker_line):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test all valid horizontal rule patterns.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        line </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> LineInfo(marker_line, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Process horizontal rule line</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify HORIZONTAL_RULE type BlockNode created</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check that content is empty or minimal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure parser state resets correctly after rule</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_horizontal_rule_invalid</span><span style=\"color:#E1E4E8\">(self, parser):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test patterns that look like HR but should not be.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        invalid_patterns </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"--\"</span><span style=\"color:#E1E4E8\">,      </span><span style=\"color:#6A737D\"># Too short</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"- -\"</span><span style=\"color:#E1E4E8\">,     </span><span style=\"color:#6A737D\"># Too short</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"-- -\"</span><span style=\"color:#E1E4E8\">,    </span><span style=\"color:#6A737D\"># Mixed patterns</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"***text\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\"># Text after markers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> pattern </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> invalid_patterns:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Process each invalid pattern</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify NO horizontal rule is created</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check that line is treated as paragraph instead</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add comprehensive integration tests that combine multiple block types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add state machine transition tests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add error recovery tests for malformed blocks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add performance tests with large documents</span></span></code></pre></div>\n\n<p><strong>Milestone Checkpoint Implementation</strong> (<code>scripts/run_milestone_tests.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Automated milestone verification script.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Runs appropriate test suites for each milestone and provides clear pass/fail feedback.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> subprocess</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> pathlib </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Path</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MilestoneTestRunner</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Coordinates milestone-specific testing and validation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, project_root: Path):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.project_root </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> project_root</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.test_results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> run_milestone_1_tests</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Run all tests required for Milestone 1: Block Elements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"🧪 Running Milestone 1: Block Elements Tests\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'milestone'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'description'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Block Elements'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'test_categories'</span><span style=\"color:#E1E4E8\">: {},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'overall_status'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'pending'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Run block parser unit tests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Command: pytest tests/unit/test_block_parser.py -v</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Capture output and parse results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check for specific test method completions</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Run block parsing integration tests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Command: pytest tests/integration/test_milestone1.py -v</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify AST structure correctness</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Run manual verification steps</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Parse comprehensive test document</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate AST node counts and types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check for proper block detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate summary report</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Set overall_status based on all test results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return detailed results dictionary</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> run_milestone_2_tests</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Run all tests required for Milestone 2: Inline Elements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"🧪 Running Milestone 2: Inline Elements Tests\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Similar structure to milestone 1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Focus on inline parser unit tests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test delimiter stack functionality</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify emphasis and link parsing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check escape sequence handling</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">'milestone'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'status'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'not_implemented'</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> run_milestone_3_tests</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Run all tests required for Milestone 3: Lists.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"🧪 Running Milestone 3: Lists Tests\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: List parser unit tests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Indentation tracking verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Nested list structure validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Tight vs loose list detection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">'milestone'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'status'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'not_implemented'</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> run_milestone_4_tests</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Run all tests required for Milestone 4: HTML Generation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"🧪 Running Milestone 4: HTML Generation Tests\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: HTML generator unit tests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: End-to-end integration tests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: HTML validity verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Character escaping validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Performance benchmarking</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">'milestone'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'status'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'not_implemented'</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify_milestone_completion</span><span style=\"color:#E1E4E8\">(self, milestone: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify that a specific milestone meets all completion criteria.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        verification_methods </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            1</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._verify_milestone_1,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            2</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._verify_milestone_2,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            3</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._verify_milestone_3,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            4</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._verify_milestone_4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> milestone </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> verification_methods:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> verification_methods[milestone]()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"❌ Unknown milestone: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">milestone</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _verify_milestone_1</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify Milestone 1 completion criteria.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"✅ Verifying Milestone 1 completion...\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check that all required block types are implemented</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify AST structure correctness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test state machine transitions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate error handling for malformed blocks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        required_block_types </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">'HEADING'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'PARAGRAPH'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'CODE_BLOCK'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'BLOCKQUOTE'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'HORIZONTAL_RULE'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: For each block type:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">:   - Create test input</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">:   - Parse through block parser</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">:   - Verify correct BlockNode type created</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">:   - Check content extraction accuracy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#6A737D\">  # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Replace with actual verification logic</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _verify_milestone_2</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify Milestone 2 completion criteria.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test all inline formatting types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify delimiter stack functionality</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check emphasis precedence rules</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test link and image parsing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _verify_milestone_3</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify Milestone 3 completion criteria.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test list parsing accuracy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify nesting level calculations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check marker consistency enforcement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test lazy continuation handling</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _verify_milestone_4</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify Milestone 4 completion criteria.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test complete pipeline functionality</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify HTML validity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check character escaping</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test performance requirements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> run_comprehensive_test_suite</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Run all tests across all milestones.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"🚀 Running Comprehensive Test Suite\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        all_results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'timestamp'</span><span style=\"color:#E1E4E8\">: time.time(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'milestones'</span><span style=\"color:#E1E4E8\">: {},</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'overall_summary'</span><span style=\"color:#E1E4E8\">: {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Run each milestone's tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        milestone_runners </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.run_milestone_1_tests,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.run_milestone_2_tests,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.run_milestone_3_tests,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.run_milestone_4_tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i, runner </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> enumerate</span><span style=\"color:#E1E4E8\">(milestone_runners, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> runner()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                all_results[</span><span style=\"color:#9ECBFF\">'milestones'</span><span style=\"color:#E1E4E8\">][i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> results</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"✅ Milestone </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">results.get(</span><span style=\"color:#9ECBFF\">'overall_status'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'unknown'</span><span style=\"color:#E1E4E8\">)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"❌ Milestone </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">i</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> failed: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                all_results[</span><span style=\"color:#9ECBFF\">'milestones'</span><span style=\"color:#E1E4E8\">][i] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'milestone'</span><span style=\"color:#E1E4E8\">: i,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'overall_status'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'error'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                    'error'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(e)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate overall summary statistics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Identify which milestones are complete</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate recommendations for next steps</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> all_results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_test_report</span><span style=\"color:#E1E4E8\">(self, results: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate human-readable test report.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        report_lines </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"# Markdown Renderer Test Report\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            f</span><span style=\"color:#9ECBFF\">\"Generated: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">time.ctime(results[</span><span style=\"color:#9ECBFF\">'timestamp'</span><span style=\"color:#E1E4E8\">])</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"## Milestone Summary\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> milestone_num, milestone_results </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> results[</span><span style=\"color:#9ECBFF\">'milestones'</span><span style=\"color:#E1E4E8\">].items():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            status </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> milestone_results.get(</span><span style=\"color:#9ECBFF\">'overall_status'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'unknown'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            description </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> milestone_results.get(</span><span style=\"color:#9ECBFF\">'description'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">'Milestone </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">milestone_num</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            status_emoji </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'passed'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'✅'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'failed'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'❌'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'partial'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'⚠️'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'not_implemented'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'⏳'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'error'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'🔥'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }.get(status, </span><span style=\"color:#9ECBFF\">'❓'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            report_lines.extend([</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                f</span><span style=\"color:#9ECBFF\">\"### </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">status_emoji</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> Milestone </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">milestone_num</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">description</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                f</span><span style=\"color:#9ECBFF\">\"Status: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">status.title()</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            ])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add detailed test category results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Include specific failure information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add recommendations for fixing issues</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add overall recommendations section</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Include next steps guidance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add debugging tips for common failures</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#9ECBFF\"> \"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">.join(report_lines)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> main</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Main entry point for milestone testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(sys.argv) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Usage: python run_milestone_tests.py &#x3C;milestone_number|all>\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Example: python run_milestone_tests.py 1\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Example: python run_milestone_tests.py all\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sys.exit(</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    project_root </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Path(</span><span style=\"color:#79B8FF\">__file__</span><span style=\"color:#E1E4E8\">).parent.parent</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    runner </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> MilestoneTestRunner(project_root)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    target </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sys.argv[</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">].lower()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> target </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'all'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> runner.run_comprehensive_test_suite()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        report </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> runner.generate_test_report(results)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#F97583\"> +</span><span style=\"color:#9ECBFF\"> \"=\"</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        print</span><span style=\"color:#E1E4E8\">(report)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#E1E4E8\"> target.isdigit():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        milestone_num </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(target)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> &#x3C;=</span><span style=\"color:#E1E4E8\"> milestone_num </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#79B8FF\"> 4</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            success </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> runner.verify_milestone_completion(milestone_num)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> success:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"🎉 Milestone </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">milestone_num</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> is complete!\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"❌ Milestone </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">milestone_num</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> needs more work.\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                sys</span></span></code></pre></div>\n\n\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation</p>\n</blockquote>\n<h3 id=\"the-detective-work-mental-model\">The Detective Work Mental Model</h3>\n<p>Think of debugging a markdown parser like being a detective at a crime scene where the &quot;crime&quot; is incorrect HTML output. You have evidence (the wrong output), witnesses (intermediate parsing states), and forensic tools (debugging utilities). Just as a detective systematically examines evidence and follows leads, debugging text parsing requires systematic examination of each transformation stage to identify where the parsing pipeline diverged from expected behavior.</p>\n<p>The key insight is that text parsing bugs often manifest far from their source. A missing paragraph tag might be caused by incorrect line splitting in preprocessing, a malformed list structure might stem from indentation calculation errors, and broken emphasis formatting could result from delimiter stack corruption. Effective debugging requires understanding these cause-and-effect relationships and knowing where to look for root causes.</p>\n<h3 id=\"symptom-based-debugging-table\">Symptom-Based Debugging Table</h3>\n<p>The following comprehensive table maps common symptoms learners encounter to their likely root causes, specific diagnostic approaches, and targeted fixes. This systematic approach helps developers identify and resolve issues efficiently rather than randomly trying different solutions.</p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Root Cause</th>\n<th>Diagnostic Steps</th>\n<th>Specific Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Headings render as plain paragraphs</td>\n<td>ATX heading regex not matching or incorrect heading detection</td>\n<td>1. Print raw line content before heading detection 2. Test <code>ATX_HEADING_PATTERN</code> regex against failing line 3. Check if line has unexpected characters or encoding issues</td>\n<td>Fix regex pattern to handle edge cases like trailing spaces, or add line content normalization before pattern matching</td>\n</tr>\n<tr>\n<td>Code blocks appear as regular paragraphs</td>\n<td>Fenced code detection failing or state machine not transitioning</td>\n<td>1. Print current <code>BlockParserState</code> when processing code fence lines 2. Verify fence marker counting (minimum 3 backticks) 3. Check if closing fence detection is working</td>\n<td>Ensure <code>FENCED_CODE_START</code> pattern matches opening fence, verify state transitions to <code>IN_FENCED_CODE</code>, fix closing fence detection logic</td>\n</tr>\n<tr>\n<td>Emphasis markers show as literal text</td>\n<td>Delimiter stack not processing or flanking detection broken</td>\n<td>1. Print delimiter stack contents after each character 2. Check flanking detection results for failing delimiters 3. Verify <code>can_open_emphasis</code> and <code>can_close_emphasis</code> logic</td>\n<td>Fix flanking detection algorithm, ensure delimiters are properly added to stack, verify opener-closer matching logic</td>\n</tr>\n<tr>\n<td>Nested emphasis produces malformed HTML</td>\n<td>Incorrect emphasis delimiter precedence or double processing</td>\n<td>1. Trace delimiter matching decisions step by step 2. Check if same text being processed multiple times 3. Verify delimiter precedence rules implementation</td>\n<td>Implement proper emphasis precedence (** before *, length-based matching), ensure single-pass processing of inline content</td>\n</tr>\n<tr>\n<td>Lists render as separate paragraphs</td>\n<td>List marker detection failing or indentation calculation wrong</td>\n<td>1. Print detected marker info for each line 2. Verify indentation level calculations 3. Check <code>ListMarkerInfo</code> extraction results</td>\n<td>Fix marker detection regex patterns, correct indentation calculation (handle tabs vs spaces), ensure marker width calculation includes trailing space</td>\n</tr>\n<tr>\n<td>List items lose indentation structure</td>\n<td>Context stack management broken or continuation logic wrong</td>\n<td>1. Print <code>ListContextStack</code> state changes 2. Trace context creation and finalization 3. Check continuation line indentation requirements</td>\n<td>Fix context stack push/pop logic, correct continuation indentation requirements, ensure proper context nesting</td>\n</tr>\n<tr>\n<td>Blockquotes miss nested levels</td>\n<td>Blockquote prefix detection or nesting logic incorrect</td>\n<td>1. Count <code>&gt;</code> characters manually vs detection results 2. Check recursive blockquote parsing 3. Verify nested content processing</td>\n<td>Fix blockquote prefix counting, ensure recursive parsing for nested quotes, handle mixed content properly</td>\n</tr>\n<tr>\n<td>Links become literal text</td>\n<td>Link syntax regex not matching or URL extraction failing</td>\n<td>1. Test link patterns against failing input 2. Check bracket-parenthesis pairing 3. Verify URL extraction logic</td>\n<td>Fix link detection regex, ensure proper bracket matching, handle edge cases like nested brackets and special characters</td>\n</tr>\n<tr>\n<td>HTML contains unescaped characters</td>\n<td>Character escaping missing or applied at wrong stage</td>\n<td>1. Check when <code>escape_html</code> is called in pipeline 2. Verify all content paths include escaping 3. Look for double-escaping issues</td>\n<td>Apply escaping consistently before HTML generation, avoid double-escaping already processed content</td>\n</tr>\n<tr>\n<td>HTML tags are malformed or unclosed</td>\n<td>Tag generation logic broken or self-closing tag confusion</td>\n<td>1. Check <code>generate_tag</code> output for specific elements 2. Verify self-closing vs container tag logic 3. Check tag nesting in output</td>\n<td>Fix tag generation for self-closing elements, ensure proper opening/closing tag pairing, correct void element handling</td>\n</tr>\n<tr>\n<td>Output HTML lacks proper indentation</td>\n<td>Pretty printing disabled or indentation logic broken</td>\n<td>1. Verify <code>pretty_print</code> flag is enabled 2. Check indentation level tracking 3. Test with simple nested structure</td>\n<td>Enable pretty printing in renderer, fix indentation calculation logic, ensure consistent indentation increment</td>\n</tr>\n<tr>\n<td>Parser crashes on empty input</td>\n<td>Null/empty string handling missing in pipeline stages</td>\n<td>1. Test each component with empty input 2. Check bounds checking in line processing 3. Verify null checks in parsers</td>\n<td>Add empty input validation at pipeline entry, ensure all components handle empty/null gracefully</td>\n</tr>\n<tr>\n<td>Infinite loops during parsing</td>\n<td>State machine stuck or incorrect termination conditions</td>\n<td>1. Add loop counters and limits 2. Print state transitions 3. Check termination conditions in parsing loops</td>\n<td>Fix state transition logic, add loop guards with maximum iteration limits, ensure all parsing loops have proper exit conditions</td>\n</tr>\n<tr>\n<td>Memory usage grows unbounded</td>\n<td>AST nodes not properly linked or circular references created</td>\n<td>1. Check parent-child relationships in AST 2. Look for reference cycles 3. Monitor node creation vs finalization</td>\n<td>Fix parent pointer management, break circular references, ensure nodes are properly finalized and released</td>\n</tr>\n<tr>\n<td>Parsing becomes extremely slow on large documents</td>\n<td>Inefficient regex patterns or quadratic algorithm behavior</td>\n<td>1. Profile parsing with large inputs 2. Check regex backtracking 3. Identify nested loop structures</td>\n<td>Optimize regex patterns to avoid backtracking, replace quadratic algorithms with linear alternatives, add early termination optimizations</td>\n</tr>\n<tr>\n<td>Inconsistent output across multiple runs</td>\n<td>Race conditions in parser state or shared mutable state</td>\n<td>1. Check for shared state between parser instances 2. Look for static/global variables 3. Test with concurrent parsing</td>\n<td>Eliminate shared mutable state, ensure each parser instance is independent, make parsing functions pure</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Insight</strong>: Most parsing bugs are actually data structure bugs in disguise. When emphasis doesn&#39;t work, it&#39;s usually because the delimiter stack isn&#39;t managed correctly. When lists break, it&#39;s because the context stack or indentation tracking has bugs. Always examine the underlying data structures first.</p>\n</blockquote>\n<h3 id=\"advanced-diagnostic-techniques\">Advanced Diagnostic Techniques</h3>\n<p>Beyond basic symptom diagnosis, effective markdown parser debugging requires specialized techniques tailored to text processing and document transformation challenges.</p>\n<h4 id=\"ast-structure-inspection\">AST Structure Inspection</h4>\n<p>The most powerful debugging tool for markdown parsing is systematic AST inspection. The <code>debug_print_ast</code> function should be your first resort when output doesn&#39;t match expectations. This function performs depth-first traversal of the parsed tree and displays the complete structure with proper indentation.</p>\n<p>When using AST inspection, look for these common structural problems: missing parent-child relationships indicating incomplete tree construction, incorrect node types suggesting classification errors during parsing, unexpected nesting levels pointing to state machine bugs, and missing or extra child nodes revealing content processing issues.</p>\n<p>The debugging workflow involves first printing the AST after block parsing to verify block-level structure is correct, then printing again after inline parsing to check inline element nesting, and finally examining the tree structure before HTML generation to ensure all content is properly represented.</p>\n<h4 id=\"pipeline-stage-isolation\">Pipeline Stage Isolation</h4>\n<p>Effective debugging requires isolating which stage of the parsing pipeline introduces errors. This systematic approach involves testing each component independently with controlled inputs.</p>\n<p>Start by feeding known-good input to the preprocessor and verifying line splitting, normalization, and metadata extraction. Then pass preprocessor output to the block parser and examine the resulting block-level AST structure. Next, take known-good block nodes and test inline parsing in isolation. Finally, provide known-good AST structures to the HTML generator and verify output correctness.</p>\n<p>This isolation technique quickly narrows the problem scope and prevents you from debugging the wrong component. Most developers waste time examining the HTML generator when the real bug is in block parsing or preprocessor normalization.</p>\n<h4 id=\"state-machine-debugging\">State Machine Debugging</h4>\n<p>Block and list parsing both use state machines that can be challenging to debug when they malfunction. The key is systematic state transition logging combined with input correlation.</p>\n<p>For block parsing state machine issues, log every state transition with the triggering input line, current block type, and any relevant context. Create a state transition trace that shows the complete sequence of states for failing input. Look for incorrect transitions (moving to wrong state), missing transitions (staying in state when should change), or impossible states (reaching states that shouldn&#39;t be reachable with given input).</p>\n<p>List parsing state machine debugging requires additional attention to the context stack. Log context creation, modification, and destruction events. Track indentation calculations and marker compatibility checks. The most common bugs involve incorrect context nesting or failure to properly close contexts when list structures end.</p>\n<h4 id=\"regular-expression-testing-and-optimization\">Regular Expression Testing and Optimization</h4>\n<p>Many parsing bugs stem from incorrect regular expressions that work for simple cases but fail on edge cases or complex input. Systematic regex debugging involves creating comprehensive test cases and analyzing pattern behavior.</p>\n<p>Test each regex pattern in isolation with boundary cases: empty strings, maximum length inputs, inputs with special characters, inputs with mixed whitespace types, and inputs with unusual but valid markdown syntax. Use regex debugging tools to visualize pattern matching and identify backtracking issues that cause performance problems.</p>\n<p>Common regex pitfalls include greedy quantifiers causing over-matching, insufficient escaping of special characters, patterns that don&#39;t account for all valid whitespace types, and patterns that fail on Unicode content or non-ASCII characters.</p>\n<h3 id=\"domain-specific-debugging-techniques\">Domain-Specific Debugging Techniques</h3>\n<p>Text parsing and document transformation introduce unique debugging challenges that require specialized approaches beyond general software debugging techniques.</p>\n<h4 id=\"whitespace-and-character-encoding-issues\">Whitespace and Character Encoding Issues</h4>\n<p>Invisible characters are a frequent source of parsing bugs that are extremely difficult to diagnose without proper techniques. Develop the habit of inspecting raw character codes rather than relying on visual inspection of text content.</p>\n<p>Create debugging utilities that display whitespace visually by replacing spaces with <code>·</code>, tabs with <code>→</code>, and line endings with <code>↵</code>. This makes invisible formatting immediately apparent. Use hexadecimal dumps to inspect raw byte sequences when dealing with encoding issues or unusual whitespace characters.</p>\n<p>Pay special attention to mixed line endings (mixing <code>\\n</code> and <code>\\r\\n</code> in the same document), trailing whitespace that affects block boundary detection, tabs versus spaces in indentation calculations, and Unicode whitespace characters that don&#39;t match standard space patterns.</p>\n<p>The <code>normalize_edge_case_whitespace</code> function should be instrumented with detailed logging showing before and after content along with explanations of what normalization was applied and why.</p>\n<h4 id=\"context-dependency-debugging\">Context Dependency Debugging</h4>\n<p>Markdown parsing is highly context-dependent, meaning the same character sequence can have different meanings depending on surrounding content. Debugging context-dependent parsing requires understanding these dependencies and systematically testing context variations.</p>\n<p>For emphasis parsing, the same asterisk character can be a literal character, an opening delimiter, or a closing delimiter depending on flanking context. Debug emphasis issues by creating minimal test cases that isolate specific flanking scenarios. Test emphasis with various surrounding character types: punctuation, whitespace, alphanumeric, and Unicode characters.</p>\n<p>List parsing context dependencies involve indentation relationships between lines, marker type consistency within lists, and lazy continuation rules that allow certain lines to be included in list items without full indentation. Debug list issues by creating test cases that systematically vary indentation levels and marker combinations.</p>\n<p>Blockquote context dependencies involve prefix detection and nested blockquote handling. Debug blockquote issues by testing various combinations of <code>&gt;</code> characters, spaces, and content types.</p>\n<h4 id=\"delimiter-balance-and-nesting-debugging\">Delimiter Balance and Nesting Debugging</h4>\n<p>Inline formatting relies on proper delimiter balancing that can become complex with nested emphasis, code spans that prevent emphasis processing, and multiple competing delimiter types in the same text span.</p>\n<p>Use delimiter stack visualization to understand how delimiters are being processed. Create debugging output that shows the stack state after each character is processed, including delimiter position, type, and open/close capabilities. This visualization quickly reveals delimiter matching errors and precedence issues.</p>\n<p>Test delimiter edge cases systematically: unmatched openers (emphasis that never closes), unmatched closers (closing emphasis without opener), overlapping delimiters of different types, delimiters inside code spans that should be treated as literal text, and complex nesting scenarios with multiple emphasis levels.</p>\n<p>The <code>detect_emphasis_precedence_conflict</code> function should be used extensively during debugging to identify potential conflicts before they cause rendering issues.</p>\n<h4 id=\"tree-structure-and-parent-child-relationship-debugging\">Tree Structure and Parent-Child Relationship Debugging</h4>\n<p>AST construction bugs often manifest as incorrect parent-child relationships, missing links between nodes, or malformed tree structures that cause HTML generation to fail or produce incorrect nesting.</p>\n<p>Implement comprehensive tree validation that checks for common structural problems: nodes with missing parent pointers, parents that don&#39;t include children in their child lists, circular references that could cause infinite loops during traversal, and orphaned nodes that exist in memory but aren&#39;t reachable from the document root.</p>\n<p>Use tree visualization tools that display the complete AST structure with clear parent-child relationships. This visualization should include node types, content summaries, and relationship indicators that make structural problems immediately apparent.</p>\n<p>The <code>validate_pipeline_state</code> function should be called between each major parsing phase to catch structural problems early before they propagate to later stages.</p>\n<h4 id=\"performance-debugging-for-large-documents\">Performance Debugging for Large Documents</h4>\n<p>Markdown parsers can exhibit performance problems that only appear with large documents or complex nesting structures. These performance issues require specialized debugging approaches focused on algorithmic complexity and resource usage.</p>\n<p>Profile parsing performance with documents of varying sizes to identify quadratic or exponential behavior. Common performance pitfalls include nested loops in list processing, backtracking regex patterns, repeated AST traversals, and inefficient string manipulation that creates many temporary objects.</p>\n<p>Use algorithmic analysis to verify that parsing algorithms are linear in input size. Implement monitoring for excessive memory allocation, particularly in delimiter processing and AST construction. Monitor parsing time per input size to identify performance regressions.</p>\n<p>Create performance test cases with pathological inputs that stress-test worst-case behavior: deeply nested lists, very long lines with many delimiters, documents with thousands of emphasis markers, and complex mixed formatting that exercises all parser components simultaneously.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The debugging infrastructure for a markdown parser requires specialized tools and techniques tailored to text processing and document transformation challenges.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AST Debugging</td>\n<td>Print statements with manual formatting</td>\n<td>Rich tree visualization library (anytree for Python)</td>\n</tr>\n<tr>\n<td>Regex Testing</td>\n<td>Online regex testers and manual verification</td>\n<td>Integrated regex profiler with backtrack analysis</td>\n</tr>\n<tr>\n<td>State Logging</td>\n<td>File-based logging with manual analysis</td>\n<td>Structured logging with real-time analysis dashboard</td>\n</tr>\n<tr>\n<td>Performance Profiling</td>\n<td>Manual timing with print statements</td>\n<td>Professional profiler (cProfile for Python, pprof for Go)</td>\n</tr>\n<tr>\n<td>Memory Analysis</td>\n<td>Basic memory monitoring</td>\n<td>Memory profiler with object lifecycle tracking</td>\n</tr>\n</tbody></table>\n<h4 id=\"debugging-infrastructure-setup\">Debugging Infrastructure Setup</h4>\n<p>The debugging infrastructure should be built into the parser from the beginning rather than added after problems appear. This proactive approach makes debugging much more efficient when issues inevitably arise.</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>markdown_renderer/\n  debug/\n    __init__.py\n    ast_inspector.py        ← AST visualization and validation\n    pipeline_tracer.py      ← Stage-by-stage execution tracking\n    regex_tester.py         ← Pattern testing and validation\n    performance_monitor.py  ← Timing and memory analysis\n    test_case_generator.py  ← Systematic edge case creation\n  tests/\n    debug/\n      test_debugging_tools.py  ← Verify debugging infrastructure\n      edge_cases/              ← Systematic edge case test files\n        malformed_emphasis.md\n        broken_list_nesting.md\n        invalid_link_syntax.md\n  src/\n    parser/\n      block_parser.py      ← Include debug hooks in implementation\n      inline_parser.py     ← Include debug hooks in implementation</code></pre></div>\n\n<h4 id=\"ast-inspector-implementation\">AST Inspector Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">AST debugging and validation utilities for markdown parser development.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides comprehensive tree inspection, validation, and visualization tools.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> sys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional, Set, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents an AST structural validation error.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    node_id: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    error_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    description: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    severity: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    suggested_fix: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ASTValidator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validates AST structure for common construction errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.visited_nodes </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.node_ids </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_tree</span><span style=\"color:#E1E4E8\">(self, root: </span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">) -> List[ValidationError]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Perform comprehensive AST validation checking for structural problems.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns list of validation errors found during inspection.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Clear validation state for new validation run</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Assign unique IDs to all nodes for error reporting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check for circular references using depth-first traversal</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate parent-child relationship consistency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Check for orphaned nodes not reachable from root</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Verify node type constraints and content validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Check for missing required attributes in block/inline nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Validate proper nesting according to CommonMark rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> check_parent_child_consistency</span><span style=\"color:#E1E4E8\">(self, node: </span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify bidirectional parent-child relationships are correct.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: For each child, verify child.parent points to this node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Verify all children in child list are unique</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check that parent's child list includes this node</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Recursively validate all descendant nodes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> debug_print_ast</span><span style=\"color:#E1E4E8\">(node: </span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">, indent: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Print comprehensive AST structure with detailed node information.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Shows node types, content, attributes, and relationships clearly.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Print node basic information (type, line number, content summary)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Print node-specific attributes (block_type, inline_type, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Print relationship information (parent type, child count)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Print content preview (first 50 chars of text content)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Recursively print all children with increased indentation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Add visual indicators for tree structure (├── └──)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> find_parsing_divergence</span><span style=\"color:#E1E4E8\">(expected_ast: </span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">, actual_ast: </span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Compare expected vs actual AST structures and identify differences.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Useful for test failure analysis and regression debugging.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Compare node types at each level of tree structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Compare content and attributes for matching nodes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Identify missing, extra, or differently typed children</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Generate detailed difference report with specific locations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Suggest likely causes for each identified difference</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"pipeline-state-tracer\">Pipeline State Tracer</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Pipeline execution tracing for step-by-step parsing analysis.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Tracks data flow through all parsing stages with detailed state capture.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Dict, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PipelineEvent</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Records a single event in the parsing pipeline execution.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timestamp: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    stage: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    event_type: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    input_summary: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    output_summary: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    state_changes: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    performance_metrics: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    debug_context: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PipelineTracer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Traces complete parsing pipeline execution for debugging analysis.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, enable_detailed_tracing: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.events </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.detailed_tracing </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> enable_detailed_tracing</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.stage_timers </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> trace_stage_entry</span><span style=\"color:#E1E4E8\">(self, stage_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, input_data: Any, initial_state: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record entry into a parsing stage with input and initial state.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Record stage entry timestamp and input characteristics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Capture initial state snapshot for comparison</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Start performance timer for this stage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create stage context for subsequent event tracking</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> trace_state_change</span><span style=\"color:#E1E4E8\">(self, stage_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, change_description: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                          old_state: Any, new_state: Any, triggering_input: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Record significant state changes during parsing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Compare old and new state to identify specific changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Record triggering input that caused the state change</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate and record timing since last state change</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Add contextual information about why change occurred</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_execution_report</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate comprehensive report of pipeline execution for analysis.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Summarize overall pipeline execution timing and stages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Identify performance bottlenecks and slow operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Highlight unusual state transitions or unexpected events</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Provide recommendations for performance or correctness improvements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"regex-pattern-tester\">Regex Pattern Tester</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Regular expression testing and validation utilities for markdown parsing patterns.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides comprehensive pattern testing with edge case generation and performance analysis.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Tuple, Dict, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RegexTestCase</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Test case for regex pattern validation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    input_text: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    should_match: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected_groups: Optional[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    expected_span: Optional[Tuple[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    edge_case_category: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"normal\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MarkdownRegexTester</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Comprehensive testing framework for markdown parsing regex patterns.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.test_cases </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.pattern_performance </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> test_pattern_comprehensive</span><span style=\"color:#E1E4E8\">(self, pattern: re.Pattern, pattern_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Test regex pattern against comprehensive set of edge cases.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns detailed analysis of pattern behavior and potential issues.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate systematic edge case test inputs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Test pattern against each case and record results</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Identify false positives and false negatives</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Analyze pattern performance with various input sizes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Check for catastrophic backtracking scenarios</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Generate detailed test report with recommendations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_emphasis_edge_cases</span><span style=\"color:#E1E4E8\">(self) -> List[RegexTestCase]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create comprehensive edge cases for emphasis delimiter testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create intraword underscore test cases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create nested emphasis combinations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create delimiter precedence conflict cases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create flanking detection boundary cases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create Unicode and special character cases</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_list_marker_edge_cases</span><span style=\"color:#E1E4E8\">(self) -> List[RegexTestCase]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create comprehensive edge cases for list marker detection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create various whitespace combinations after markers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create invalid marker combinations that should not match</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create nested indentation and continuation scenarios</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create mixed ordered/unordered marker test cases</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"performance-and-memory-profiler\">Performance and Memory Profiler</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Performance monitoring and memory analysis for markdown parser optimization.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Tracks parsing performance across document sizes and complexity levels.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> tracemalloc</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Any, Optional, Callable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> collections </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> defaultdict</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PerformanceMetrics</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Performance measurements for parsing operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    operation_name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    execution_time: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    memory_peak: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    memory_current: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    input_size: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    complexity_factors: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MarkdownParserProfiler</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Comprehensive performance profiling for markdown parser components.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, enable_memory_tracking: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.metrics </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.memory_tracking </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> enable_memory_tracking</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.operation_counters </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> defaultdict(</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.timing_stack </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> profile_parsing_operation</span><span style=\"color:#E1E4E8\">(self, operation_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, operation_func: Callable, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                input_data: Any, complexity_factors: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Profile a parsing operation with comprehensive performance measurement.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns operation result along with detailed performance metrics.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Start memory tracking if enabled</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Record operation start time and input characteristics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Execute operation while monitoring resource usage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Record final memory usage and execution time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Calculate performance characteristics and complexity metrics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Store metrics for later analysis and reporting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_performance_report</span><span style=\"color:#E1E4E8\">(self, min_operation_time: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.001</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate comprehensive performance analysis report.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Analyze performance trends across input sizes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Identify operations with quadratic or worse complexity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Highlight memory usage patterns and potential leaks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Compare performance across different input characteristics</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Provide optimization recommendations based on profiling data</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_performance_test_suite</span><span style=\"color:#E1E4E8\">(self) -> List[Tuple[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Create systematic performance test cases with varying complexity.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create documents with varying sizes (small to very large)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create documents with different nesting complexity levels</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create documents with varying density of formatting elements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create pathological cases that stress-test worst-case behavior</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-debugging-checkpoints\">Milestone Debugging Checkpoints</h4>\n<p>After completing each milestone, verify parsing correctness using these systematic checkpoints:</p>\n<p><strong>Milestone 1 (Block Elements) Debugging Checkpoint:</strong></p>\n<ol>\n<li>Run <code>python -m debug.ast_inspector tests/milestone1_blocks.md</code> and verify AST structure matches expected block hierarchy</li>\n<li>Test edge cases: headings with trailing spaces, code blocks with unusual fencing, blockquotes with inconsistent prefixes</li>\n<li>Check state machine transitions using <code>PipelineTracer</code> - verify clean transitions between block types</li>\n<li>Expected behavior: All block-level structures parse correctly, no content is lost or misclassified</li>\n</ol>\n<p><strong>Milestone 2 (Inline Elements) Debugging Checkpoint:</strong></p>\n<ol>\n<li>Run delimiter stack visualization on complex emphasis examples to verify proper matching</li>\n<li>Test flanking detection with edge cases using <code>MarkdownRegexTester</code></li>\n<li>Verify inline parsing doesn&#39;t interfere with block structure using AST comparison</li>\n<li>Expected behavior: Emphasis, links, and inline code render correctly without breaking block structure</li>\n</ol>\n<p><strong>Milestone 3 (Lists) Debugging Checkpoint:</strong></p>\n<ol>\n<li>Use <code>debug_print_ast</code> to verify nested list structures are properly represented</li>\n<li>Test indentation edge cases with mixed tabs/spaces and various nesting levels</li>\n<li>Verify context stack management using pipeline tracer during complex list parsing</li>\n<li>Expected behavior: All list nesting levels are correct, no items are lost or misplaced</li>\n</ol>\n<p><strong>Milestone 4 (HTML Generation) Debugging Checkpoint:</strong></p>\n<ol>\n<li>Validate generated HTML using W3C validator or similar tool</li>\n<li>Check HTML entity escaping completeness using systematic character testing</li>\n<li>Verify pretty printing produces properly indented, human-readable output</li>\n<li>Expected behavior: Valid HTML5 output with proper escaping and formatting</li>\n</ol>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Builds upon all milestones - Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation</p>\n</blockquote>\n<h3 id=\"the-evolution-framework-mental-model\">The Evolution Framework Mental Model</h3>\n<p>Think of extending the markdown renderer like upgrading a modular kitchen. The core appliances (block parser, inline parser, HTML generator) are already in place and working perfectly. Now you want to add specialty equipment - perhaps a pasta machine for tables, a bread maker for math expressions, or modular attachments that let third-party manufacturers create custom tools. The key insight is that these extensions should plug into the existing infrastructure without requiring you to rewire the entire kitchen. A well-designed extension system feels like adding new capabilities that were always meant to be there, rather than awkward bolt-ons that compromise the original design.</p>\n<p>The architectural challenge with markdown extensions lies in maintaining the elegant simplicity of the core parsing pipeline while accommodating the complexity that advanced features inevitably introduce. Each extension potentially touches multiple components - new syntax requires lexer changes, new block types need parser modifications, new output formats demand renderer updates. The goal is to create extension points that feel natural and maintain the clean separation of concerns established in the base system.</p>\n<h3 id=\"commonmark-extensions\">CommonMark Extensions</h3>\n<p>The CommonMark specification intentionally focuses on a stable, well-defined core that captures the essence of markdown while leaving room for extensions. These extensions represent commonly requested features that build logically on the existing parsing infrastructure. Understanding how to add these extensions reveals the flexibility and robustness of the two-phase parsing architecture.</p>\n<h4 id=\"table-extension-architecture\">Table Extension Architecture</h4>\n<p>Tables represent one of the most requested markdown extensions, transforming the simple grid-like syntax into structured HTML table elements. The table extension demonstrates how complex block-level structures can be parsed using the existing block parser infrastructure with minimal modifications to the core architecture.</p>\n<p>The table parsing process follows a recognition pattern similar to existing block elements. The block parser identifies potential table structures by detecting pipe characters (<code>|</code>) that suggest columnar organization. However, unlike simple blocks like paragraphs or headings, tables require sophisticated parsing of internal structure to extract headers, alignment specifications, and cell content.</p>\n<p>Consider how a table integrates into the existing parsing pipeline. During block parsing, the system encounters lines that contain pipe characters in positions that suggest table structure. The table parser examines consecutive lines to determine if they form a valid table structure - a header row, a delimiter row specifying column alignments, and one or more data rows. This multi-line analysis fits naturally into the block parser&#39;s lookahead capabilities.</p>\n<p><strong>Table Structure Recognition Algorithm:</strong></p>\n<ol>\n<li><strong>Initial Detection</strong>: During block parsing, when encountering a line containing pipe characters, examine if this could be a table header row</li>\n<li><strong>Delimiter Row Validation</strong>: Look ahead to the next line to check for a valid delimiter row with alignment specifications (<code>:---</code>, <code>:---:</code>, <code>---:</code>)</li>\n<li><strong>Structure Confirmation</strong>: Verify that header and delimiter rows have compatible column counts and valid separator patterns</li>\n<li><strong>Row Collection</strong>: Continue consuming lines that match the established table structure until encountering a line that breaks the pattern</li>\n<li><strong>Cell Content Extraction</strong>: Parse individual cell content, trimming whitespace and preparing for inline element processing</li>\n<li><strong>Alignment Processing</strong>: Extract column alignment information from the delimiter row and store as table metadata</li>\n<li><strong>AST Node Creation</strong>: Create a table <code>BlockNode</code> with child nodes representing rows and cells, preserving alignment specifications</li>\n</ol>\n<p>The table extension introduces new node types that integrate seamlessly with the existing AST structure:</p>\n<table>\n<thead>\n<tr>\n<th>Node Type</th>\n<th>Parent Node</th>\n<th>Child Nodes</th>\n<th>Special Attributes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>TABLE</code></td>\n<td>Document or container block</td>\n<td><code>TABLE_HEADER</code>, <code>TABLE_BODY</code></td>\n<td>column_count, alignment_specs</td>\n</tr>\n<tr>\n<td><code>TABLE_HEADER</code></td>\n<td><code>TABLE</code></td>\n<td><code>TABLE_ROW</code></td>\n<td>none</td>\n</tr>\n<tr>\n<td><code>TABLE_BODY</code></td>\n<td><code>TABLE</code></td>\n<td><code>TABLE_ROW</code></td>\n<td>none</td>\n</tr>\n<tr>\n<td><code>TABLE_ROW</code></td>\n<td><code>TABLE_HEADER</code> or <code>TABLE_BODY</code></td>\n<td><code>TABLE_CELL</code></td>\n<td>row_type</td>\n</tr>\n<tr>\n<td><code>TABLE_CELL</code></td>\n<td><code>TABLE_ROW</code></td>\n<td>Inline elements</td>\n<td>alignment, is_header</td>\n</tr>\n</tbody></table>\n<p>The inline parsing phase processes table cell content normally, applying emphasis, links, and other inline formatting within cell boundaries. This demonstrates the power of the two-phase parsing architecture - table structure is resolved during block parsing, while cell formatting is handled during inline parsing without requiring specialized logic.</p>\n<blockquote>\n<p><strong>Design Insight</strong>: Tables showcase how complex extensions can leverage the existing parsing infrastructure. The block parser handles structure recognition and AST construction, while the inline parser processes cell content using existing mechanisms. No modifications to the core inline parsing logic are required.</p>\n</blockquote>\n<h4 id=\"math-expression-extension\">Math Expression Extension</h4>\n<p>Mathematical expressions represent a different category of extension that introduces domain-specific syntax requiring specialized rendering. Math extensions typically support both inline math (delimited by single dollar signs) and display math (delimited by double dollar signs or fenced blocks). This extension demonstrates how to handle content that requires pass-through processing rather than standard markdown parsing.</p>\n<p>The math extension introduces the concept of <strong>verbatim content blocks</strong> - regions where normal markdown parsing is suspended in favor of preserving exact content for specialized processors. This is similar to how code blocks preserve content literally, but math blocks may require additional processing by mathematical typesetting systems.</p>\n<p><strong>Math Block Recognition Process:</strong></p>\n<ol>\n<li><strong>Inline Math Detection</strong>: During inline parsing, detect single dollar sign delimiters that enclose mathematical expressions</li>\n<li><strong>Display Math Block Detection</strong>: During block parsing, detect double dollar signs or fenced math blocks (````math<code>or</code>$$`)</li>\n<li><strong>Content Preservation</strong>: Extract math content without applying normal markdown parsing rules - preserve all characters literally</li>\n<li><strong>Metadata Extraction</strong>: Identify the math notation type (LaTeX, MathML, etc.) from fences or context</li>\n<li><strong>AST Integration</strong>: Create specialized math nodes that carry the unparsed mathematical content and notation metadata</li>\n<li><strong>Renderer Integration</strong>: Pass math content to specialized renderers (MathJax, KaTeX) while handling the HTML integration</li>\n</ol>\n<p>Math extensions typically require coordination with client-side rendering libraries or server-side mathematical typesetting systems. The markdown renderer&#39;s responsibility is to preserve the mathematical content accurately and provide the necessary HTML structure for math rendering libraries to process.</p>\n<table>\n<thead>\n<tr>\n<th>Extension Feature</th>\n<th>Block Level</th>\n<th>Inline Level</th>\n<th>Processing Phase</th>\n<th>Special Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Table Structure</td>\n<td>Yes</td>\n<td>Cell content only</td>\n<td>Block then inline</td>\n<td>Column alignment, row grouping</td>\n</tr>\n<tr>\n<td>Math Expressions</td>\n<td>Display math</td>\n<td>Inline math</td>\n<td>Content preservation</td>\n<td>External renderer integration</td>\n</tr>\n<tr>\n<td>Footnotes</td>\n<td>Reference definitions</td>\n<td>Reference markers</td>\n<td>Cross-document linking</td>\n<td>Link resolution, numbering</td>\n</tr>\n<tr>\n<td>Task Lists</td>\n<td>Special list items</td>\n<td>Checkbox indicators</td>\n<td>List parsing extension</td>\n<td>Interactive element generation</td>\n</tr>\n<tr>\n<td>Definition Lists</td>\n<td>Term/definition pairs</td>\n<td>Term highlighting</td>\n<td>Block parsing extension</td>\n<td>Semantic HTML generation</td>\n</tr>\n</tbody></table>\n<h4 id=\"task-list-extension\">Task List Extension</h4>\n<p>Task lists extend the existing list parsing infrastructure to support interactive checkbox elements. This extension demonstrates how existing parsing components can be enhanced without disrupting their core functionality. Task lists use a special syntax within list items (<code>- [ ]</code> for unchecked, <code>- [x]</code> for checked) that the list parser can recognize and process.</p>\n<p>The task list extension modifies list item recognition to detect checkbox patterns at the beginning of list item content. When such patterns are found, the list parser extracts the checkbox state and marks the list item with task list attributes. During HTML generation, these attributes trigger the creation of interactive checkbox input elements.</p>\n<blockquote>\n<p><strong>Design Principle</strong>: Extensions should enhance existing functionality rather than replace it. Task lists build on the standard list parsing infrastructure, adding recognition patterns and output modifications while preserving all existing list behaviors.</p>\n</blockquote>\n<h4 id=\"architecture-decision-extension-integration-strategy\">Architecture Decision: Extension Integration Strategy</h4>\n<blockquote>\n<p><strong>Decision: Compositional Extension Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Extensions need to add functionality without modifying core parsing logic or breaking backward compatibility</li>\n<li><strong>Options Considered</strong>: <ol>\n<li><strong>Inheritance-based extensions</strong>: Subclass core parsers and override methods</li>\n<li><strong>Plugin system</strong>: Load extensions dynamically with registration hooks</li>\n<li><strong>Compositional extensions</strong>: Extend parsers through composition and configuration</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement compositional extensions with registration-based integration</li>\n<li><strong>Rationale</strong>: Composition preserves the stability of core parsing logic while allowing extensions to add new parsing rules and output formats. Registration-based integration provides clear extension points without requiring dynamic loading complexity</li>\n<li><strong>Consequences</strong>: Extensions integrate cleanly with minimal core modifications, but advanced extensions may require multiple registration points across different parsing phases</li>\n</ul>\n</blockquote>\n<h3 id=\"plugin-and-extension-architecture\">Plugin and Extension Architecture</h3>\n<p>The plugin architecture provides a systematic framework for extending the markdown renderer beyond the built-in CommonMark extensions. This architecture must balance flexibility with simplicity, allowing powerful customizations without compromising the performance or reliability of the core parsing pipeline.</p>\n<h4 id=\"the-extension-point-mental-model\">The Extension Point Mental Model</h4>\n<p>Think of extension points like electrical outlets in a building. The building&#39;s wiring (core parsing pipeline) provides standardized connection points where different appliances (extensions) can plug in safely. Each outlet type (extension point) provides specific electrical characteristics (data formats, calling conventions, lifecycle management) that appliances must respect. Well-designed extension points mean that new appliances can be added without rewiring the building, and multiple appliances can coexist without interference.</p>\n<p>The markdown renderer provides several natural extension points corresponding to the major phases of document processing. Each extension point offers different capabilities and operates on different data representations, allowing extensions to target the most appropriate level of abstraction for their functionality.</p>\n<h4 id=\"extension-point-architecture\">Extension Point Architecture</h4>\n<p>The plugin system defines multiple extension points that correspond to different phases of the parsing pipeline. Each extension point operates on specific data structures and provides well-defined hooks for custom functionality.</p>\n<table>\n<thead>\n<tr>\n<th>Extension Point</th>\n<th>Input Data</th>\n<th>Output Data</th>\n<th>Timing</th>\n<th>Use Cases</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Preprocessor Plugins</td>\n<td>Raw markdown text</td>\n<td>Modified text</td>\n<td>Before any parsing</td>\n<td>Text normalization, macro expansion</td>\n</tr>\n<tr>\n<td>Block Parser Plugins</td>\n<td><code>LineInfo</code> sequences</td>\n<td>Additional <code>BlockNode</code> types</td>\n<td>During block parsing</td>\n<td>Custom block syntax</td>\n</tr>\n<tr>\n<td>Inline Parser Plugins</td>\n<td>Text spans within blocks</td>\n<td>Additional <code>InlineNode</code> types</td>\n<td>During inline parsing</td>\n<td>Custom inline formatting</td>\n</tr>\n<tr>\n<td>Renderer Plugins</td>\n<td><code>ASTNode</code> instances</td>\n<td>HTML fragments</td>\n<td>During HTML generation</td>\n<td>Custom output formats</td>\n</tr>\n<tr>\n<td>Post-processor Plugins</td>\n<td>Complete HTML</td>\n<td>Modified HTML</td>\n<td>After rendering</td>\n<td>Document-wide transformations</td>\n</tr>\n</tbody></table>\n<p>The <code>PluginManager</code> coordinates plugin registration and execution, ensuring that plugins are invoked at appropriate points in the parsing pipeline. The manager maintains plugin registries for each extension point and provides the interface for plugins to declare their capabilities and requirements.</p>\n<h4 id=\"plugin-interface-design\">Plugin Interface Design</h4>\n<p>Each plugin type implements a specific interface that defines its interaction with the parsing pipeline. These interfaces are designed to be minimal yet powerful, allowing plugins to integrate seamlessly while maintaining clear separation of concerns.</p>\n<p><strong>Renderer Plugin Interface:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>get_supported_types()</code></td>\n<td>None</td>\n<td><code>List[NodeType]</code></td>\n<td>Declare which AST node types this plugin handles</td>\n</tr>\n<tr>\n<td><code>render_node(node, context)</code></td>\n<td><code>ASTNode</code>, <code>RenderContext</code></td>\n<td><code>str</code></td>\n<td>Convert AST node to output format</td>\n</tr>\n<tr>\n<td><code>get_priority()</code></td>\n<td>None</td>\n<td><code>int</code></td>\n<td>Determine plugin precedence for overlapping capabilities</td>\n</tr>\n<tr>\n<td><code>initialize(config)</code></td>\n<td><code>Dict[str, Any]</code></td>\n<td><code>bool</code></td>\n<td>Perform plugin initialization with configuration</td>\n</tr>\n<tr>\n<td><code>finalize()</code></td>\n<td>None</td>\n<td><code>None</code></td>\n<td>Clean up plugin resources</td>\n</tr>\n</tbody></table>\n<p>The <code>RenderContext</code> provides plugins with access to the rendering environment, including the parent renderer, configuration options, and utility functions for common tasks like HTML escaping and indentation management.</p>\n<p><strong>Block Parser Plugin Interface:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>can_handle_block(line)</code></td>\n<td><code>LineInfo</code></td>\n<td><code>bool</code></td>\n<td>Determine if plugin can parse a block starting with this line</td>\n</tr>\n<tr>\n<td><code>parse_block(lines, start_index)</code></td>\n<td><code>List[LineInfo]</code>, <code>int</code></td>\n<td><code>Tuple[BlockNode, int]</code></td>\n<td>Parse block and return consumed line count</td>\n</tr>\n<tr>\n<td><code>get_block_precedence()</code></td>\n<td>None</td>\n<td><code>int</code></td>\n<td>Priority for block recognition conflicts</td>\n</tr>\n</tbody></table>\n<h4 id=\"plugin-configuration-and-lifecycle\">Plugin Configuration and Lifecycle</h4>\n<p>The plugin system supports both built-in extensions that ship with the renderer and external plugins loaded dynamically. Plugin configuration allows users to enable, disable, and configure individual plugins without modifying core code.</p>\n<p><strong>Plugin Configuration Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Plugin Configuration:\n  - plugin_name: str (unique identifier)\n  - enabled: bool (activation status)\n  - priority: int (execution order)\n  - config: Dict[str, Any] (plugin-specific settings)\n  - dependencies: List[str] (required plugins)\n  - conflicts: List[str] (incompatible plugins)</code></pre></div>\n\n<p>The <code>PluginManager</code> handles plugin lifecycle management, ensuring that plugins are loaded in dependency order, initialized with appropriate configuration, and cleaned up properly when the renderer shuts down.</p>\n<p><strong>Plugin Lifecycle States:</strong></p>\n<table>\n<thead>\n<tr>\n<th>State</th>\n<th>Description</th>\n<th>Allowed Transitions</th>\n<th>Cleanup Required</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>UNLOADED</code></td>\n<td>Plugin not yet loaded</td>\n<td>→ <code>LOADING</code></td>\n<td>No</td>\n</tr>\n<tr>\n<td><code>LOADING</code></td>\n<td>Plugin being initialized</td>\n<td>→ <code>LOADED</code>, <code>ERROR</code></td>\n<td>Partial</td>\n</tr>\n<tr>\n<td><code>LOADED</code></td>\n<td>Plugin ready for use</td>\n<td>→ <code>ACTIVE</code>, <code>UNLOADING</code></td>\n<td>No</td>\n</tr>\n<tr>\n<td><code>ACTIVE</code></td>\n<td>Plugin currently processing</td>\n<td>→ <code>LOADED</code></td>\n<td>No</td>\n</tr>\n<tr>\n<td><code>ERROR</code></td>\n<td>Plugin failed to load/initialize</td>\n<td>→ <code>UNLOADING</code></td>\n<td>Yes</td>\n</tr>\n<tr>\n<td><code>UNLOADING</code></td>\n<td>Plugin being shut down</td>\n<td>→ <code>UNLOADED</code></td>\n<td>Yes</td>\n</tr>\n</tbody></table>\n<h4 id=\"custom-renderer-development\">Custom Renderer Development</h4>\n<p>Custom renderers demonstrate the most common and powerful use of the plugin architecture. Rather than generating HTML, custom renderers can produce LaTeX for academic papers, plain text for accessibility, or structured data formats like JSON or XML.</p>\n<p>A LaTeX renderer plugin illustrates how specialized output formats leverage the existing AST structure while producing completely different markup. The LaTeX renderer traverses the same AST generated by the standard parsing pipeline but emits LaTeX commands instead of HTML tags.</p>\n<p><strong>LaTeX Renderer Example Mapping:</strong></p>\n<table>\n<thead>\n<tr>\n<th>AST Node Type</th>\n<th>HTML Output</th>\n<th>LaTeX Output</th>\n<th>Special Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>HEADING</code> (level 1)</td>\n<td><code>&lt;h1&gt;title&lt;/h1&gt;</code></td>\n<td><code>\\section{title}</code></td>\n<td>Convert heading levels to LaTeX sectioning</td>\n</tr>\n<tr>\n<td><code>STRONG</code></td>\n<td><code>&lt;strong&gt;text&lt;/strong&gt;</code></td>\n<td><code>\\textbf{text}</code></td>\n<td>Handle nested emphasis</td>\n</tr>\n<tr>\n<td><code>EMPHASIS</code></td>\n<td><code>&lt;em&gt;text&lt;/em&gt;</code></td>\n<td><code>\\textit{text}</code></td>\n<td>Handle nested emphasis</td>\n</tr>\n<tr>\n<td><code>CODE_BLOCK</code></td>\n<td><code>&lt;pre&gt;&lt;code&gt;content&lt;/code&gt;&lt;/pre&gt;</code></td>\n<td><code>\\begin{verbatim}content\\end{verbatim}</code></td>\n<td>Preserve exact formatting</td>\n</tr>\n<tr>\n<td><code>LINK</code></td>\n<td><code>&lt;a href=&quot;url&quot;&gt;text&lt;/a&gt;</code></td>\n<td><code>\\href{url}{text}</code></td>\n<td>URL validation for LaTeX</td>\n</tr>\n</tbody></table>\n<p>Custom renderers must handle the tree traversal logic and maintain proper nesting of their output format. The plugin interface provides helper methods for common tasks, but complex renderers may need sophisticated state management to produce well-formed output.</p>\n<h4 id=\"extension-development-best-practices\">Extension Development Best Practices</h4>\n<p>Effective plugin development requires understanding both the markdown renderer&#39;s architecture and the specific requirements of the extension&#39;s domain. Successful plugins follow several key principles that ensure reliable integration and good performance.</p>\n<p><strong>Plugin Development Principles:</strong></p>\n<ol>\n<li><strong>Minimal Surface Area</strong>: Plugins should interact with the core system through well-defined interfaces, avoiding dependencies on internal implementation details</li>\n<li><strong>Error Isolation</strong>: Plugin errors should not crash the entire parsing pipeline - implement proper error handling and graceful degradation</li>\n<li><strong>Performance Awareness</strong>: Plugins operate within the parsing pipeline and can impact overall performance - optimize for common cases and avoid expensive operations in hot paths</li>\n<li><strong>Configuration Validation</strong>: Validate plugin configuration early and provide clear error messages for misconfigurations</li>\n<li><strong>Documentation Standards</strong>: Provide clear documentation of supported syntax, configuration options, and interaction with other plugins</li>\n</ol>\n<blockquote>\n<p><strong>Architecture Insight</strong>: The plugin architecture&#39;s power comes from operating on the AST representation rather than raw text. This means plugins can focus on their specific functionality without reimplementing text parsing logic, and multiple plugins can collaborate by operating on the same standardized data structures.</p>\n</blockquote>\n<h4 id=\"extension-ecosystem-considerations\">Extension Ecosystem Considerations</h4>\n<p>As the plugin ecosystem grows, certain patterns emerge for managing plugin interactions and maintaining system stability. The plugin architecture must accommodate both simple single-purpose plugins and complex multi-feature extensions.</p>\n<p><strong>Plugin Interaction Patterns:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n<th>Benefits</th>\n<th>Challenges</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Independent Plugins</strong></td>\n<td>Plugins operate on disjoint node types</td>\n<td>No conflicts, simple testing</td>\n<td>Limited collaboration possibilities</td>\n</tr>\n<tr>\n<td><strong>Layered Processing</strong></td>\n<td>Plugins process in defined order with dependencies</td>\n<td>Powerful compositions, clear data flow</td>\n<td>Complex dependency management</td>\n</tr>\n<tr>\n<td><strong>Collaborative Plugins</strong></td>\n<td>Plugins share state or coordinate through APIs</td>\n<td>Rich feature interactions</td>\n<td>Increased coupling, harder debugging</td>\n</tr>\n<tr>\n<td><strong>Override Plugins</strong></td>\n<td>Later plugins can replace earlier plugin output</td>\n<td>Flexible customization</td>\n<td>Potential conflicts, unclear precedence</td>\n</tr>\n</tbody></table>\n<p>The plugin manager implements sophisticated conflict detection and resolution to handle cases where multiple plugins claim to handle the same node types or syntax patterns. Priority systems and explicit conflict declarations help users configure complex plugin combinations successfully.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Implementation</th>\n<th>Advanced Implementation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Extension Registry</td>\n<td>Dictionary-based lookup with static registration</td>\n<td>Dynamic loading with dependency resolution</td>\n</tr>\n<tr>\n<td>Plugin Interface</td>\n<td>Duck-typed protocols</td>\n<td>Abstract base classes with type checking</td>\n</tr>\n<tr>\n<td>Configuration Management</td>\n<td>JSON/YAML files with manual validation</td>\n<td>Schema validation with automatic documentation</td>\n</tr>\n<tr>\n<td>Plugin Discovery</td>\n<td>Explicit registration in main module</td>\n<td>Automatic discovery via entry points</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Try-catch around plugin calls</td>\n<td>Circuit breaker pattern with fallback strategies</td>\n</tr>\n</tbody></table>\n<h4 id=\"file-structure-for-extensions\">File Structure for Extensions</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  core/\n    parser.py           ← Core parsing logic\n    ast_nodes.py        ← AST node definitions\n    html_renderer.py    ← Base HTML renderer\n  \n  extensions/\n    __init__.py         ← Extension registry\n    tables.py           ← Table extension\n    math.py             ← Math expression extension\n    task_lists.py       ← Task list extension\n    \n  plugins/\n    __init__.py         ← Plugin manager and interfaces\n    base_plugin.py      ← Abstract plugin base classes\n    renderer_plugins.py ← Renderer plugin interfaces\n    parser_plugins.py   ← Parser plugin interfaces\n    \n  renderers/\n    latex_renderer.py   ← LaTeX output renderer\n    json_renderer.py    ← JSON AST serializer\n    plain_text.py       ← Accessibility text renderer</code></pre></div>\n\n<h4 id=\"plugin-manager-infrastructure\">Plugin Manager Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span><span style=\"color:#E1E4E8\">, abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Any, Optional, Protocol</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PluginState</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UNLOADED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"unloaded\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LOADING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"loading\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    LOADED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"loaded\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ACTIVE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"active\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"error\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    UNLOADING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"unloading\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RendererPlugin</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Abstract base class for custom renderer plugins.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Renderers transform AST nodes into output formats.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_supported_types</span><span style=\"color:#E1E4E8\">(self) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return list of NodeType enum values this plugin handles.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return NodeType values this renderer supports</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> render_node</span><span style=\"color:#E1E4E8\">(self, node: </span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">, context: </span><span style=\"color:#9ECBFF\">'RenderContext'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Render a single AST node to output format.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node: AST node to render</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            context: Rendering context with utilities and state</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            String representation in target format</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement node-specific rendering logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle child node rendering via context.render_children()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Apply any node-specific formatting or escaping</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_priority</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return priority for plugin precedence (higher = more priority).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> initialize</span><span style=\"color:#E1E4E8\">(self, config: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Initialize plugin with configuration. Return True if successful.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate configuration parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Set up any required resources or connections</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return False if initialization fails</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> finalize</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Clean up plugin resources.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Close any open files, connections, or resources</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Save any persistent state if needed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PluginManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Manages plugin registration, lifecycle, and execution.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Coordinates between core parser and extension plugins.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.plugins: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, RendererPlugin] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.node_renderers: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, List[RendererPlugin]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.plugin_states: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, PluginState] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.plugin_configs: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register_plugin</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, plugin: RendererPlugin, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       config: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Register a renderer plugin with the manager.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            name: Unique plugin identifier</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            plugin: Plugin instance implementing RendererPlugin</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            config: Optional configuration dictionary</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if registration successful, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check if plugin name already exists</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate plugin implements required interface</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Store plugin with UNLOADED state</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Initialize plugin with provided config</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Update node_renderers mapping for supported types</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle initialization errors gracefully</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_renderer</span><span style=\"color:#E1E4E8\">(self, node_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[RendererPlugin]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Get the best renderer for a given node type.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node_type: NodeType enum value as string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Highest priority renderer for node type, or None</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Look up renderers for node_type in node_renderers</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return highest priority renderer from available options</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle case where no renderer is available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> render_with_fallback</span><span style=\"color:#E1E4E8\">(self, node: </span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           context: </span><span style=\"color:#9ECBFF\">'RenderContext'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Render node with automatic fallback to default renderer.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node: AST node to render</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            context: Rendering context</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Rendered output with fallback if plugin fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Get best renderer for node.node_type</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Attempt rendering with primary renderer</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Catch and log any plugin errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Fall back to default renderer if plugin fails</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return rendered output or error placeholder</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RenderContext</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Provides rendering utilities and state management for plugins.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Passed to renderer plugins during node processing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, plugin_manager: PluginManager, config: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.plugin_manager </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> plugin_manager</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.config </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> config</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.depth </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.current_list_context: Optional[</span><span style=\"color:#9ECBFF\">'ListContext'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.html_escaper </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> HtmlEscaper()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> render_children</span><span style=\"color:#E1E4E8\">(self, node: </span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Render all child nodes of the given node.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            node: Parent node whose children should be rendered</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Concatenated rendering of all child nodes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Iterate through node.children</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Render each child using plugin_manager.render_with_fallback</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Concatenate results and return combined output</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> escape_for_format</span><span style=\"color:#E1E4E8\">(self, text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, format_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"html\"</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Escape text for target output format.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            text: Raw text to escape</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            format_type: Target format (\"html\", \"latex\", \"xml\", etc.)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Properly escaped text for target format</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement format-specific escaping logic</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle HTML entities, LaTeX special chars, etc.</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return escaped text appropriate for format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"table-extension-implementation\">Table Extension Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Optional, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TableAlignment</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Represents column alignment specification from table delimiter row.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    left: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    right: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    center: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_delimiter</span><span style=\"color:#E1E4E8\">(cls, delimiter: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'TableAlignment'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Parse alignment from delimiter cell like ':---:', '---:', ':---'\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check for leading colon (left alignment)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check for trailing colon (right alignment) </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Determine center alignment (both colons present)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return TableAlignment instance with appropriate flags</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TableExtension</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Extension for parsing GitHub Flavored Markdown tables.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Integrates with block parser to recognize and process table syntax.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Regex patterns for table recognition</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TABLE_ROW_PATTERN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">^\\s</span><span style=\"color:#F97583\">*</span><span style=\"color:#85E89D;font-weight:bold\">\\|</span><span style=\"color:#79B8FF\">.</span><span style=\"color:#F97583\">*</span><span style=\"color:#85E89D;font-weight:bold\">\\|</span><span style=\"color:#79B8FF\">\\s</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">$</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DELIMITER_ROW_PATTERN</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> re.compile(</span><span style=\"color:#F97583\">r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">^\\s</span><span style=\"color:#F97583\">*</span><span style=\"color:#85E89D;font-weight:bold\">\\|</span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\">\\s</span><span style=\"color:#F97583\">*</span><span style=\"color:#DBEDFF\">:</span><span style=\"color:#F97583\">?</span><span style=\"color:#DBEDFF\">-</span><span style=\"color:#F97583\">+</span><span style=\"color:#DBEDFF\">:</span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\">\\s</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">(</span><span style=\"color:#85E89D;font-weight:bold\">\\|</span><span style=\"color:#79B8FF\">\\s</span><span style=\"color:#F97583\">*</span><span style=\"color:#DBEDFF\">:</span><span style=\"color:#F97583\">?</span><span style=\"color:#DBEDFF\">-</span><span style=\"color:#F97583\">+</span><span style=\"color:#DBEDFF\">:</span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\">\\s</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">)</span><span style=\"color:#F97583\">*</span><span style=\"color:#85E89D;font-weight:bold\">\\|</span><span style=\"color:#F97583\">?</span><span style=\"color:#79B8FF\">\\s</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">$</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> can_start_table</span><span style=\"color:#E1E4E8\">(self, current_line: </span><span style=\"color:#9ECBFF\">'LineInfo'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       next_line: Optional[</span><span style=\"color:#9ECBFF\">'LineInfo'</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Determine if current line could start a table.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            current_line: Potential table header line</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            next_line: Potential delimiter row (must be present)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if these lines form valid table start</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check current_line matches TABLE_ROW_PATTERN</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check next_line exists and matches DELIMITER_ROW_PATTERN  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify column count compatibility between header and delimiter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return True only if valid table structure detected</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_table_block</span><span style=\"color:#E1E4E8\">(self, lines: List[</span><span style=\"color:#9ECBFF\">'LineInfo'</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                         start_index: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Tuple[</span><span style=\"color:#9ECBFF\">'BlockNode'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Parse complete table from line sequence.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            lines: Full document line sequence</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            start_index: Index of table header line</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Tuple of (table BlockNode, number of lines consumed)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Parse header row and extract cell content</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Parse delimiter row and extract alignment specifications</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Continue parsing data rows until table structure breaks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create table BlockNode with appropriate child structure</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Set table attributes (column_count, alignments)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return table node and consumed line count</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> parse_table_row</span><span style=\"color:#E1E4E8\">(self, line: </span><span style=\"color:#9ECBFF\">'LineInfo'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       expected_columns: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Parse a single table row into cell contents.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            line: Line containing table row</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            expected_columns: Expected number of columns</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            List of cell contents (trimmed strings)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Split line on pipe characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Handle escaped pipes (\\|) that should not split</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Trim whitespace from each cell</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Pad or truncate to match expected_columns</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return list of cell content strings</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> extract_alignments</span><span style=\"color:#E1E4E8\">(self, delimiter_line: </span><span style=\"color:#9ECBFF\">'LineInfo'</span><span style=\"color:#E1E4E8\">) -> List[TableAlignment]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Extract column alignment specifications from delimiter row.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            delimiter_line: Table delimiter row like '|:---|---:|:---:|'</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            List of TableAlignment objects for each column</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Split delimiter line on pipe characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Parse each delimiter cell for colon positions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Create TableAlignment objects based on colon placement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return list of alignments matching column order</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Extension Integration Checkpoint:</strong>\nAfter implementing the basic plugin architecture:</p>\n<ol>\n<li><strong>Plugin Registration Test</strong>: Create a simple test plugin and verify it registers correctly</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_plugin_manager.py::test_plugin_registration</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><strong>Table Extension Test</strong>: Test table parsing with various alignment combinations</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">   echo</span><span style=\"color:#9ECBFF\"> \"| Header 1 | Header 2 | Header 3 |</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   |:---------|:--------:|---------:|</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">   | Left     | Center   | Right    |\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> markdown_renderer</span><span style=\"color:#79B8FF\"> --extension</span><span style=\"color:#9ECBFF\"> tables</span></span></code></pre></div>\n\n<ol start=\"3\">\n<li><strong>Custom Renderer Test</strong>: Implement a simple JSON renderer and verify AST serialization</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">   echo</span><span style=\"color:#9ECBFF\"> \"# Test heading\\n\\nSome **bold** text\"</span><span style=\"color:#F97583\"> |</span><span style=\"color:#B392F0\"> python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> markdown_renderer</span><span style=\"color:#79B8FF\"> --renderer</span><span style=\"color:#9ECBFF\"> json</span></span></code></pre></div>\n\n<p><strong>Plugin Development Checkpoint:</strong>\nExpected plugin development workflow:</p>\n<ol>\n<li><strong>Interface Implementation</strong>: Plugin implements required abstract methods without errors</li>\n<li><strong>Registration Success</strong>: Plugin registers with manager and appears in plugin list</li>\n<li><strong>Node Processing</strong>: Plugin correctly processes assigned node types</li>\n<li><strong>Error Handling</strong>: Plugin failures don&#39;t crash the parser pipeline</li>\n<li><strong>Configuration Loading</strong>: Plugin accepts and validates configuration parameters</li>\n</ol>\n<p><strong>Common Plugin Issues:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Plugin not found</td>\n<td>Registration failed</td>\n<td>Check plugin manager logs</td>\n<td>Verify plugin registration call</td>\n</tr>\n<tr>\n<td>Node not processed</td>\n<td>Type mapping incorrect</td>\n<td>Check get_supported_types()</td>\n<td>Fix node type constants</td>\n</tr>\n<tr>\n<td>Rendering errors</td>\n<td>Missing context usage</td>\n<td>Test render_node() directly</td>\n<td>Use context.render_children()</td>\n</tr>\n<tr>\n<td>Performance slow</td>\n<td>Inefficient traversal</td>\n<td>Profile plugin execution</td>\n<td>Optimize hot path operations</td>\n</tr>\n<tr>\n<td>Config errors</td>\n<td>Validation missing</td>\n<td>Check initialize() return</td>\n<td>Add config parameter validation</td>\n</tr>\n</tbody></table>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation</p>\n</blockquote>\n<h3 id=\"the-reference-manual-mental-model\">The Reference Manual Mental Model</h3>\n<p>Think of this glossary as a reference manual for a complex piece of machinery - the markdown renderer. Just as a mechanic needs to understand the precise terminology for each engine component to diagnose problems and communicate solutions, developers working with markdown parsers need a shared vocabulary of technical terms, parsing concepts, and architectural patterns. Each term in this glossary represents a specific concept with precise meaning within the context of document transformation systems.</p>\n<p>The glossary serves multiple purposes beyond simple definition lookup. It establishes consistent terminology across the entire system, prevents confusion between similar concepts (like &quot;block-level elements&quot; versus &quot;block nodes&quot;), and provides the conceptual foundation for understanding complex interactions between parser components. When debugging a delimiter matching issue or discussing extension architecture, having precise terminology eliminates ambiguity and accelerates problem resolution.</p>\n<p>This reference organizes terminology into logical categories that mirror the system architecture: core parsing concepts, data structures and types, algorithms and processes, architectural patterns, error handling terminology, testing and debugging vocabulary, and extensibility concepts. Each category builds upon previous ones, creating a coherent knowledge framework for the entire markdown rendering domain.</p>\n<h3 id=\"core-parsing-concepts\">Core Parsing Concepts</h3>\n<p>These fundamental concepts form the theoretical foundation for understanding how markdown parsers transform textual input into structured output. Each concept represents a key insight about the nature of document transformation that influences architectural decisions throughout the system.</p>\n<p><strong>Abstract Syntax Tree (AST)</strong>: A hierarchical tree data structure that represents the parsed structure of a markdown document, where each node corresponds to a markdown element (paragraph, heading, emphasis, link, etc.) and the tree relationships capture the nesting and containment relationships between elements. The AST serves as the intermediate representation that decouples parsing logic from HTML generation, enabling different output formats and transformation passes.</p>\n<p><strong>Block-level elements</strong>: Structural markdown elements that define document layout and organization, including paragraphs, headings, lists, code blocks, blockquotes, and horizontal rules. Block-level elements typically span multiple lines, can contain other block elements or inline elements, and establish the primary document structure that determines reading flow and semantic meaning.</p>\n<p><strong>Inline elements</strong>: Formatting markdown elements that exist within block-level elements and modify text appearance or behavior, including emphasis (bold and italic), inline code spans, links, images, and line breaks. Inline elements cannot contain block-level elements and typically span portions of a single line, though they can contain other inline elements through nesting.</p>\n<p><strong>Two-phase parsing</strong>: A parsing architecture that separates document processing into distinct block parsing and inline parsing phases, where block parsing first identifies and structures document-level elements, then inline parsing processes formatting within each block&#39;s content. This separation simplifies parsing logic, enables context-dependent inline processing, and allows independent optimization of each parsing phase.</p>\n<p><strong>CommonMark</strong>: The standardized specification for markdown syntax that defines precise parsing rules, handles edge cases consistently, and provides a reference implementation for validation. CommonMark eliminates ambiguities in original markdown specifications and serves as the authoritative source for parsing behavior in complex scenarios.</p>\n<p><strong>Context-dependent parsing</strong>: Parsing rules that change behavior based on surrounding content, document state, or position within other elements. Examples include emphasis delimiters that behave differently at word boundaries, list markers that require specific indentation contexts, and inline code that disables other formatting rules within its boundaries.</p>\n<p><strong>State machine</strong>: A parsing approach that models the parser as having distinct internal states (like &quot;looking for block,&quot; &quot;in paragraph,&quot; &quot;in code block&quot;) with defined transitions between states triggered by specific input patterns. State machines provide predictable parsing behavior, simplify handling of complex multi-line constructs, and enable systematic testing of parser logic.</p>\n<p><strong>Lookahead</strong>: The technique of examining upcoming input characters or lines without consuming them from the input stream, enabling the parser to make decisions based on future context. Lookahead is essential for handling Setext headings (which require examining the following line), determining block continuation, and resolving parsing ambiguities.</p>\n<h3 id=\"markdown-syntax-terminology\">Markdown Syntax Terminology</h3>\n<p>These terms describe specific markdown syntactic constructs and their parsing requirements, providing precise vocabulary for discussing parsing challenges and implementation strategies.</p>\n<p><strong>ATX headings</strong>: Hash-prefix style headings that use one to six <code>#</code> characters at the beginning of a line to indicate heading levels, such as <code># Heading 1</code> or <code>### Heading 3</code>. ATX headings are self-contained on a single line and can be identified immediately without lookahead.</p>\n<p><strong>Setext headings</strong>: Underline-style headings that use lines of <code>=</code> characters (for level 1) or <code>-</code> characters (for level 2) underneath the heading text. Setext headings require lookahead parsing since the heading text appears first, followed by the underline marker on the next line.</p>\n<p><strong>Fenced code blocks</strong>: Multi-line code blocks delimited by lines containing three or more backticks (<code>```</code>) or tildes (<code>~~~</code>), optionally followed by a language identifier for syntax highlighting. Fenced code blocks preserve all internal content literally, including markdown syntax that would otherwise be parsed.</p>\n<p><strong>Indented code blocks</strong>: Multi-line code blocks created by indenting every line by at least four spaces or one tab character. Indented code blocks end when a line is encountered that is not indented sufficiently or when the document ends.</p>\n<p><strong>Lazy continuation</strong>: The CommonMark rule allowing certain block elements (like blockquotes and list items) to continue on subsequent lines even when those lines don&#39;t include the expected prefix markers, as long as the content would otherwise be part of a paragraph.</p>\n<p><strong>Intraword underscore</strong>: Underscore characters that appear within a word (like <code>snake_case_variable</code>) and should not trigger emphasis formatting according to CommonMark rules. Detecting intraword underscores requires examining characters before and after potential emphasis delimiters.</p>\n<h3 id=\"parsing-algorithm-terminology\">Parsing Algorithm Terminology</h3>\n<p>These terms describe the specific algorithms and techniques used throughout the parsing pipeline, providing precise vocabulary for discussing implementation strategies and optimization approaches.</p>\n<p><strong>Delimiter matching</strong>: The algorithm for finding pairs of formatting markers (like <code>**</code> for bold or <code>[</code> and <code>]</code> for links) that define the boundaries of inline formatting. Delimiter matching must handle nesting, precedence rules, and various edge cases like unmatched or overlapping delimiters.</p>\n<p><strong>Delimiter stack</strong>: A data structure that tracks unmatched opening delimiters during inline parsing, enabling proper nesting and precedence handling for emphasis, strong emphasis, and other delimiter-based formatting. The delimiter stack is processed using specific algorithms defined in the CommonMark specification.</p>\n<p><strong>Flanking detection</strong>: The algorithm for determining whether emphasis delimiters (asterisks and underscores) can open or close emphasis based on the characters immediately before and after the delimiter sequence. Flanking rules prevent emphasis in contexts like <code>a*b*c</code> where the asterisks are surrounded by alphanumeric characters.</p>\n<p><strong>Emphasis delimiter precedence</strong>: The rules for resolving conflicts when multiple emphasis delimiters could match the same text span, such as in <code>***bold and italic***</code> where delimiters must be matched according to specific precedence rules to produce consistent output.</p>\n<p><strong>Depth-first traversal</strong>: The tree traversal algorithm used during HTML generation to visit AST nodes, where each node is processed before its siblings, and all descendants are visited before moving to the next sibling. This traversal pattern ensures proper HTML nesting and content ordering.</p>\n<p><strong>HTML entity escaping</strong>: The process of converting special characters (like <code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code>, and quotes) to their corresponding HTML entities (<code>&amp;lt;</code>, <code>&amp;gt;</code>, <code>&amp;amp;</code>, etc.) to prevent HTML injection and ensure proper display of literal characters.</p>\n<p><strong>Pretty printing</strong>: The process of formatting HTML output with consistent indentation, line breaks, and spacing to make the generated HTML human-readable for debugging and development purposes.</p>\n<h3 id=\"data-structure-and-type-terminology\">Data Structure and Type Terminology</h3>\n<p>These terms describe the specific data structures, types, and interfaces used throughout the system, providing precise vocabulary for discussing implementation details and component interactions.</p>\n<p><strong>AST node types</strong>: The enumerated categories of nodes in the abstract syntax tree, including <code>DOCUMENT</code> (root node), <code>BLOCK</code> (block-level elements), <code>INLINE</code> (inline formatting elements), and <code>TEXT</code> (literal text content). Each node type determines processing behavior and available operations.</p>\n<p><strong>Block types</strong>: The specific categories of block-level elements, including <code>PARAGRAPH</code>, <code>HEADING</code>, <code>CODE_BLOCK</code>, <code>BLOCKQUOTE</code>, <code>HORIZONTAL_RULE</code>, <code>LIST</code>, <code>LIST_ITEM</code>, and extended types like <code>TABLE</code> components. Block types determine parsing rules, HTML output generation, and containment relationships.</p>\n<p><strong>Inline types</strong>: The specific categories of inline formatting elements, including <code>STRONG</code> (bold), <code>EMPHASIS</code> (italic), <code>CODE</code> (inline code), <code>LINK</code>, <code>IMAGE</code>, and <code>LINE_BREAK</code>. Inline types determine delimiter matching rules, nesting behavior, and HTML generation logic.</p>\n<p><strong>Parser state enumeration</strong>: The defined states for the block parsing state machine, including <code>LOOKING_FOR_BLOCK</code>, <code>IN_PARAGRAPH</code>, <code>IN_FENCED_CODE</code>, <code>IN_INDENTED_CODE</code>, and <code>IN_BLOCKQUOTE</code>. These states determine how input lines are processed and when state transitions occur.</p>\n<p><strong>Delimiter types</strong>: The categories of characters that can act as formatting delimiters, including <code>ASTERISK</code>, <code>UNDERSCORE</code>, <code>BACKTICK</code>, <code>LEFT_BRACKET</code>, and <code>EXCLAMATION_BRACKET</code>. Each delimiter type has specific rules for opening and closing formatting spans.</p>\n<p><strong>List marker types</strong>: The categories of list markers, including <code>UNORDERED_DASH</code>, <code>UNORDERED_ASTERISK</code>, <code>UNORDERED_PLUS</code> for unordered lists, and <code>ORDERED_PERIOD</code>, <code>ORDERED_PAREN</code> for ordered lists. Marker types determine list compatibility and nesting rules.</p>\n<p><strong>List state enumeration</strong>: The states that track whether lists should have tight or loose formatting, including <code>TIGHT</code> (no blank lines between items), <code>LOOSE</code> (blank lines create paragraph wrapping), and <code>UNDETERMINED</code> (final state not yet decided based on input).</p>\n<h3 id=\"error-handling-and-recovery-terminology\">Error Handling and Recovery Terminology</h3>\n<p>These terms describe the systematic approach to handling malformed input, parsing errors, and recovery strategies that maintain system stability while providing useful feedback to users.</p>\n<p><strong>Parser error recovery</strong>: The comprehensive strategy for handling invalid markdown syntax while continuing to parse subsequent content, including detection of errors, classification by severity, application of recovery strategies, and collection of diagnostic information for user feedback.</p>\n<p><strong>Graceful degradation</strong>: The design principle where parser failures in one component or with one piece of input do not prevent processing of other components or content, ensuring the system produces useful output even when encountering unexpected input patterns.</p>\n<p><strong>Recovery strategies</strong>: The defined approaches for handling specific types of parsing errors, including <code>COMPLETE_BLOCK</code> (finish current block and continue), <code>CONVERT_TO_PARAGRAPH</code> (treat malformed syntax as regular text), <code>PRESERVE_CONTENT</code> (maintain content while fixing structure), and <code>SKIP_MALFORMED</code> (ignore invalid sections entirely).</p>\n<p><strong>Error severity levels</strong>: The classification system for parsing errors, including <code>WARNING</code> (non-critical issues that don&#39;t prevent processing), <code>ERROR</code> (significant problems that require recovery), and <code>CRITICAL</code> (failures that prevent further processing of affected sections).</p>\n<p><strong>Continuation-based recovery</strong>: The recovery approach where errors in parsing one block element do not prevent successful parsing of subsequent blocks, maintaining document-level processing even when individual elements contain syntax errors.</p>\n<p><strong>Delimiter balancing recovery</strong>: The specialized recovery strategy for handling unmatched or incorrectly nested emphasis delimiters, including conversion to literal characters, automatic closing of unmatched openers, and precedence-based resolution of conflicting matches.</p>\n<p><strong>Semantic whitespace preservation</strong>: The recovery technique that preserves whitespace characters that affect document meaning and display while normalizing insignificant whitespace, ensuring consistent output regardless of input formatting variations.</p>\n<h3 id=\"testing-and-debugging-terminology\">Testing and Debugging Terminology</h3>\n<p>These terms describe the specialized vocabulary for systematic testing and debugging of parser components, providing precise language for discussing quality assurance approaches and problem diagnosis techniques.</p>\n<p><strong>State machine debugging</strong>: The systematic debugging approach for parser state transitions, including verification of state consistency, validation of transition triggers, identification of unreachable states, and detection of infinite loops or incorrect state changes.</p>\n<p><strong>Pipeline stage isolation</strong>: The debugging technique that tests individual parsing components in isolation from the complete pipeline, enabling precise identification of issues within specific transformation stages without interference from other components.</p>\n<p><strong>Delimiter balance and nesting debugging</strong>: The specialized debugging approach for inline formatting issues, focusing on delimiter stack state, matching algorithms, precedence resolution, and the interaction between different types of emphasis delimiters.</p>\n<p><strong>Tree structure validation</strong>: The comprehensive checking of AST parent-child relationships, node type consistency, content validation, and structural integrity to ensure the parsed tree accurately represents the intended document structure.</p>\n<p><strong>Performance debugging</strong>: The specialized debugging focused on algorithmic complexity, resource usage patterns, memory allocation behavior, and execution time analysis to identify and resolve performance bottlenecks in parsing operations.</p>\n<p><strong>Context dependency debugging</strong>: The debugging approach for parser rules that depend on surrounding content, document state, or position within other elements, requiring careful analysis of parsing context and state propagation.</p>\n<p><strong>Edge case handling</strong>: The systematic approach to defining consistent behavior for ambiguous input patterns, unusual syntax combinations, and boundary conditions that may not be explicitly covered by the CommonMark specification.</p>\n<h3 id=\"architecture-and-extension-terminology\">Architecture and Extension Terminology</h3>\n<p>These terms describe the extensibility mechanisms, architectural patterns, and design approaches that enable customization and enhancement of the core markdown renderer while maintaining system integrity.</p>\n<p><strong>Plugin architecture</strong>: The extensibility system that allows custom functionality to be added to the markdown renderer without modifying core components, including plugin registration, lifecycle management, and integration points for custom behavior.</p>\n<p><strong>Extension points</strong>: The defined integration interfaces where plugins can hook into the parsing or rendering pipeline, including custom block parsers, inline element handlers, HTML renderers, and output format generators.</p>\n<p><strong>Renderer plugins</strong>: The specific type of plugin that generates custom output formats or modifies HTML generation behavior for specific node types, enabling support for different target formats while reusing the parsing pipeline.</p>\n<p><strong>Plugin lifecycle</strong>: The managed states and transitions for plugin loading and cleanup, including <code>UNLOADED</code>, <code>LOADING</code>, <code>LOADED</code>, <code>ACTIVE</code>, <code>ERROR</code>, and <code>UNLOADING</code> states with defined transitions and error handling.</p>\n<p><strong>Compositional extensions</strong>: The design approach where new functionality is added through composition of existing components rather than inheritance or modification of core classes, enabling flexible customization while maintaining system stability.</p>\n<p><strong>CommonMark extensions</strong>: The standardized additions to the base CommonMark specification, including tables, task lists, strikethrough text, and other commonly supported features that extend basic markdown capabilities.</p>\n<p><strong>Pipeline architecture</strong>: The unidirectional data flow design where input is transformed through a sequence of processing stages, with each stage having well-defined inputs, outputs, and responsibilities that enable component isolation and testing.</p>\n<p><strong>Component isolation</strong>: The design principle ensuring clear separation between parsing logic components, with minimal dependencies and well-defined interfaces that enable independent development, testing, and modification of system parts.</p>\n<h3 id=\"regular-expression-and-pattern-matching-terminology\">Regular Expression and Pattern Matching Terminology</h3>\n<p>These terms describe the specific patterns, matching techniques, and regex-based parsing approaches used throughout the system for recognizing markdown syntax and extracting structured information.</p>\n<p><strong>ATX_HEADING_PATTERN</strong>: The regular expression pattern for matching hash-prefix headings, typically <code>^(#{1,6})\\s+(.+?)(?:\\s+#+)?$</code>, which captures the heading level through hash count and the heading text while allowing optional trailing hashes.</p>\n<p><strong>SETEXT_H1_UNDERLINE</strong> and <strong>SETEXT_H2_UNDERLINE</strong>: Regular expression patterns for matching Setext heading underlines, using patterns like <code>^=+$</code> for level 1 headings and <code>^-+$</code> for level 2 headings, requiring coordination with the previous line&#39;s content.</p>\n<p><strong>FENCED_CODE_START</strong> and <strong>FENCED_CODE_END</strong>: Patterns for matching the opening and closing delimiters of fenced code blocks, typically <code>^```(\\w*)$</code> or <code>^~~~(\\w*)$</code> for opening (with optional language specification) and corresponding closing patterns.</p>\n<p><strong>HORIZONTAL_RULE_PATTERN</strong>: The pattern for matching horizontal rules, such as <code>^(?:(?:\\* *){3,}|(?:- *){3,}|(?:_ *){3,})$</code>, which recognizes three or more asterisks, dashes, or underscores with optional spacing.</p>\n<p><strong>BLOCKQUOTE_PATTERN</strong>: The pattern for matching blockquote lines, typically <code>^&gt; ?(.*)$</code>, which captures the content after the blockquote marker while allowing for optional space after the greater-than symbol.</p>\n<p><strong>UNORDERED_MARKER_PATTERN</strong> and <strong>ORDERED_MARKER_PATTERN</strong>: Patterns for detecting list markers, such as <code>^( *)([*+-]) +(.*)$</code> for unordered lists and <code>^( *)(\\d{1,9})[.)] +(.*)$</code> for ordered lists, capturing indentation, marker, and content.</p>\n<h3 id=\"html-generation-and-output-terminology\">HTML Generation and Output Terminology</h3>\n<p>These terms describe the specific concepts, techniques, and standards used when converting the parsed AST into HTML output, including escaping, formatting, and validation considerations.</p>\n<p><strong>HTML_ESCAPE_TABLE</strong>: The mapping data structure that defines character-to-entity conversions for HTML escaping, typically including <code>&amp;</code> → <code>&amp;amp;</code>, <code>&lt;</code> → <code>&amp;lt;</code>, <code>&gt;</code> → <code>&amp;gt;</code>, <code>&quot;</code> → <code>&amp;quot;</code>, and <code>&#39;</code> → <code>&amp;#39;</code>.</p>\n<p><strong>ATTRIBUTE_ESCAPE_TABLE</strong>: The specialized character mapping for escaping HTML attribute values, which may have different escaping requirements than HTML content, particularly for quote characters and attribute-specific special characters.</p>\n<p><strong>VOID_ELEMENTS</strong>: The set of HTML5 element names that cannot have content or closing tags, including <code>area</code>, <code>base</code>, <code>br</code>, <code>col</code>, <code>embed</code>, <code>hr</code>, <code>img</code>, <code>input</code>, <code>link</code>, <code>meta</code>, <code>param</code>, <code>source</code>, <code>track</code>, and <code>wbr</code>.</p>\n<p><strong>Self-closing tags</strong>: HTML elements that don&#39;t have separate closing tags and are written as single tags like <code>&lt;hr&gt;</code> or <code>&lt;img src=&quot;...&quot; alt=&quot;...&quot;&gt;</code>, requiring special handling during HTML generation to avoid generating incorrect closing tags.</p>\n<p><strong>Double-escaping</strong>: The error condition where HTML special characters are escaped multiple times, resulting in output like <code>&amp;amp;lt;</code> instead of <code>&amp;lt;</code>, typically caused by applying escaping at multiple stages of the processing pipeline.</p>\n<p><strong>Attribute value escaping</strong>: The specialized escaping rules for content within HTML attribute values, which must handle quote characters appropriately and may require different escape sequences than general HTML content escaping.</p>\n<p><strong>Visitor pattern</strong>: The design pattern used for traversing and operating on AST trees, where different node types accept visitor objects that implement specific operations, enabling separation of tree structure from processing algorithms.</p>\n<h3 id=\"performance-and-optimization-terminology\">Performance and Optimization Terminology</h3>\n<p>These terms describe the concepts and techniques related to parser performance, resource usage optimization, and scalability considerations in document processing systems.</p>\n<p><strong>Verbatim content blocks</strong>: Regions of the document (like code blocks) where content is preserved exactly as written without any markdown parsing, requiring specialized handling to avoid unnecessary processing while maintaining exact character preservation.</p>\n<p><strong>Algorithmic complexity</strong>: The analysis of parser operations in terms of time and space complexity, particularly important for operations like delimiter matching, list nesting resolution, and AST traversal that can exhibit quadratic or worse behavior on pathological input.</p>\n<p><strong>Memory allocation patterns</strong>: The analysis of object creation and memory usage during parsing, including strategies for reducing garbage collection pressure, reusing temporary objects, and managing memory-intensive operations like large document processing.</p>\n<p><strong>Pipeline optimization</strong>: The techniques for improving performance across the entire parsing pipeline, including lazy evaluation, early termination conditions, and optimization of data structure choices for specific access patterns.</p>\n<p><strong>Input size scaling</strong>: The analysis of how parser performance changes with document size, including identification of operations that scale poorly and implementation of strategies to maintain reasonable performance on large documents.</p>\n<p>This comprehensive glossary provides the terminological foundation for understanding, implementing, and extending markdown parsing systems. Each term represents a specific concept with precise meaning within the domain of document transformation, enabling clear communication about complex parsing algorithms and architectural decisions. The terminology spans from fundamental parsing concepts through specific implementation details to advanced extensibility patterns, supporting developers at all levels of expertise in building robust and maintainable markdown rendering systems.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The terminology and concepts defined in this glossary should be implemented through consistent naming conventions and clear documentation standards throughout the codebase. This implementation guidance provides practical approaches for maintaining terminological consistency and supporting developer understanding.</p>\n<h4 id=\"technology-recommendations-for-documentation\">Technology Recommendations for Documentation</h4>\n<table>\n<thead>\n<tr>\n<th>Aspect</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Code Documentation</td>\n<td>Inline comments with term definitions</td>\n<td>Sphinx/godoc with cross-references</td>\n</tr>\n<tr>\n<td>API Documentation</td>\n<td>README with terminology section</td>\n<td>OpenAPI specs with consistent terminology</td>\n</tr>\n<tr>\n<td>Type Documentation</td>\n<td>Docstrings using exact term names</td>\n<td>Generated docs with glossary integration</td>\n</tr>\n<tr>\n<td>Error Messages</td>\n<td>Clear messages using standard terms</td>\n<td>Structured errors with terminology links</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-documentation-structure\">Recommended Documentation Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  docs/\n    glossary.md              ← this comprehensive glossary\n    api-reference.md         ← API docs using consistent terms\n    architecture-guide.md    ← high-level concepts with term links\n  src/\n    types.py                 ← type definitions with docstring references\n    constants.py             ← all named constants from glossary\n    exceptions.py            ← error types with standard terminology\n    utils/\n      validation.py          ← terminology validation utilities</code></pre></div>\n\n<h4 id=\"terminology-validation-utilities\">Terminology Validation Utilities</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Complete terminology validation infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TerminologyValidator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validates that code uses consistent terminology from the glossary.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, glossary_terms: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.glossary_terms </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> glossary_terms</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.deprecated_terms </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'markdown_node'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'ASTNode'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'text_element'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'InlineNode'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'block_element'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'BlockNode'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_variable_names</span><span style=\"color:#E1E4E8\">(self, source_code: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate that variable names use standard terminology.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Parse source code and extract variable names</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check against glossary_terms dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Flag usage of deprecated_terms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Suggest corrections for non-standard terminology</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return list of validation errors with line numbers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_function_signatures</span><span style=\"color:#E1E4E8\">(self, module) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate that function names and parameters use standard terms.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Inspect module functions using reflection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check parameter names against standard terminology</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate return type annotations use correct type names</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Flag functions that don't follow naming conventions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Standard constants with exact names from glossary</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">HTML_ESCAPE_TABLE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x26;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;amp;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x3C;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;lt;'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '>'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;gt;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '\"'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;quot;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"'\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;#39;'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ATTRIBUTE_ESCAPE_TABLE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x26;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;amp;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '&#x3C;'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;lt;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '>'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;gt;'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '\"'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;quot;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"'\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;#39;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;#10;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '</span><span style=\"color:#79B8FF\">\\r</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;#13;'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    '</span><span style=\"color:#79B8FF\">\\t</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'&#x26;#9;'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">VOID_ELEMENTS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'area'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'base'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'br'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'col'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'embed'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'hr'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'img'</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    'input'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'link'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'meta'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'param'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'source'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'track'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'wbr'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ESCAPABLE_CHARS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> '</span><span style=\"color:#79B8FF\">\\\\</span><span style=\"color:#9ECBFF\">`*_</span><span style=\"color:#79B8FF\">{}</span><span style=\"color:#9ECBFF\">[]()#+-.!|~'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">EMPHASIS_DELIMITER_CHARS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">'*'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'_'</span><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<h4 id=\"core-terminology-integration\">Core Terminology Integration</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_ast_terminology</span><span style=\"color:#E1E4E8\">(root: ASTNode) -> List[ValidationError]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validate AST structure uses standard terminology and relationships.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check that node_type values match NodeType enum</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Verify block_type values match BlockType enum  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate inline_type values match InlineType enum</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure parent-child relationships are properly established</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check that node attributes use standard attribute names</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return comprehensive validation errors with fix suggestions</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> generate_terminology_report</span><span style=\"color:#E1E4E8\">(codebase_path: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Generate report on terminology usage consistency across codebase.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Scan all Python files in codebase_path</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Extract type names, variable names, function names</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Compare against standard terminology from glossary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Identify inconsistencies and deprecated usage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate formatted report with recommendations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Include metrics on terminology compliance percentage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"language-specific-terminology-hints\">Language-Specific Terminology Hints</h4>\n<p>For Python implementation:</p>\n<ul>\n<li>Use exact enum names from glossary: <code>NodeType.DOCUMENT</code>, <code>BlockType.PARAGRAPH</code>, <code>InlineType.STRONG</code></li>\n<li>Follow PEP 8 naming: <code>parse_blocks()</code>, <code>render_to_html()</code>, <code>escape_html()</code></li>\n<li>Use descriptive variable names: <code>ast_root</code> not <code>root</code>, <code>block_node</code> not <code>node</code></li>\n<li>Include type hints with exact type names: <code>def parse_blocks(text: str) -&gt; ASTNode</code></li>\n</ul>\n<p>For error messages:</p>\n<ul>\n<li>Use standard terminology: &quot;Failed to parse ATX heading&quot; not &quot;Failed to parse hash heading&quot;</li>\n<li>Reference specific types: &quot;Expected BlockType.HEADING&quot; not &quot;Expected heading type&quot;</li>\n<li>Include glossary term definitions in extended error messages for learning</li>\n</ul>\n<h4 id=\"milestone-checkpoint-terminology-consistency\">Milestone Checkpoint: Terminology Consistency</h4>\n<p>After implementing terminology standards:</p>\n<ul>\n<li>Run <code>python -m terminology_validator src/</code> to check naming consistency</li>\n<li>Verify all type definitions match glossary exactly: <code>NodeType</code>, <code>BlockType</code>, <code>InlineType</code></li>\n<li>Confirm error messages use standard terms from glossary</li>\n<li>Test that API documentation uses consistent terminology throughout</li>\n<li>Validate that code comments reference correct technical terms</li>\n</ul>\n<p>Signs of terminology problems:</p>\n<ul>\n<li>Mixed naming conventions (some camelCase, some snake_case for same concepts)</li>\n<li>Error messages using informal terms not in glossary</li>\n<li>Type names that don&#39;t match the standard definitions</li>\n<li>Function parameters with non-standard names like <code>md_text</code> instead of <code>markdown_text</code></li>\n</ul>\n<h4 id=\"debugging-terminology-issues\">Debugging Terminology Issues</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Confusing error messages</td>\n<td>Inconsistent terminology usage</td>\n<td>Check error message text against glossary</td>\n<td>Update messages to use standard terms</td>\n</tr>\n<tr>\n<td>Hard to navigate codebase</td>\n<td>Non-standard naming conventions</td>\n<td>Audit variable/function names</td>\n<td>Rename to match glossary conventions</td>\n</tr>\n<tr>\n<td>Documentation inconsistencies</td>\n<td>Multiple terms for same concept</td>\n<td>Cross-reference docs with glossary</td>\n<td>Standardize on single term per concept</td>\n</tr>\n<tr>\n<td>Integration problems</td>\n<td>Different components use different terms</td>\n<td>Check inter-component interfaces</td>\n<td>Align all interfaces to standard terminology</td>\n</tr>\n</tbody></table>\n<p>This implementation guidance ensures that the comprehensive terminology defined in the glossary is consistently applied throughout the codebase, enabling clear communication, easier maintenance, and better developer experience when working with the markdown renderer system.</p>\n","toc":[{"level":1,"text":"Markdown Renderer: Design Document","id":"markdown-renderer-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"The Document Transformation Mental Model","id":"the-document-transformation-mental-model"},{"level":3,"text":"Existing Parsing Approaches","id":"existing-parsing-approaches"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"The Scope Definition Mental Model","id":"the-scope-definition-mental-model"},{"level":3,"text":"Primary Goals","id":"primary-goals"},{"level":3,"text":"Secondary Goals","id":"secondary-goals"},{"level":3,"text":"Explicit Non-Goals","id":"explicit-non-goals"},{"level":3,"text":"Success Criteria and Acceptance Boundaries","id":"success-criteria-and-acceptance-boundaries"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"The Document Pipeline Mental Model","id":"the-document-pipeline-mental-model"},{"level":3,"text":"Component Overview","id":"component-overview"},{"level":4,"text":"Input Preprocessor and Lexer","id":"input-preprocessor-and-lexer"},{"level":4,"text":"Block Parser","id":"block-parser"},{"level":4,"text":"Inline Parser","id":"inline-parser"},{"level":4,"text":"HTML Generator","id":"html-generator"},{"level":4,"text":"Component Interaction and Data Flow","id":"component-interaction-and-data-flow"},{"level":3,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Core Infrastructure Starter Code","id":"core-infrastructure-starter-code"},{"level":4,"text":"Core Parsing Logic Skeletons","id":"core-parsing-logic-skeletons"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Language-Specific Implementation Hints","id":"language-specific-implementation-hints"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"The Document Tree Mental Model","id":"the-document-tree-mental-model"},{"level":3,"text":"Abstract Syntax Tree Nodes","id":"abstract-syntax-tree-nodes"},{"level":4,"text":"Base AST Node Structure","id":"base-ast-node-structure"},{"level":4,"text":"Block-Level Node Structure","id":"block-level-node-structure"},{"level":4,"text":"Inline Element Node Structure","id":"inline-element-node-structure"},{"level":4,"text":"Text Node Structure","id":"text-node-structure"},{"level":4,"text":"Node Type Enumerations","id":"node-type-enumerations"},{"level":3,"text":"Parser Context and State","id":"parser-context-and-state"},{"level":4,"text":"Primary Parser State","id":"primary-parser-state"},{"level":4,"text":"Line Processing Context","id":"line-processing-context"},{"level":4,"text":"Block Parser State","id":"block-parser-state"},{"level":4,"text":"Inline Parser State","id":"inline-parser-state"},{"level":3,"text":"AST Construction and Manipulation","id":"ast-construction-and-manipulation"},{"level":4,"text":"Node Construction Interface","id":"node-construction-interface"},{"level":4,"text":"Tree Traversal Interface","id":"tree-traversal-interface"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Implementation Notes","id":"language-specific-implementation-notes"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Block Parser Design","id":"block-parser-design"},{"level":3,"text":"The Building Blocks Mental Model","id":"the-building-blocks-mental-model"},{"level":3,"text":"Block Parsing Algorithm","id":"block-parsing-algorithm"},{"level":3,"text":"Block Parser Architecture Decisions","id":"block-parser-architecture-decisions"},{"level":3,"text":"Block Parsing Common Pitfalls","id":"block-parsing-common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Subsection","id":"subsection"},{"level":2,"text":"Inline Parser Design","id":"inline-parser-design"},{"level":3,"text":"The Text Surgery Mental Model","id":"the-text-surgery-mental-model"},{"level":3,"text":"Inline Parsing Algorithm","id":"inline-parsing-algorithm"},{"level":4,"text":"Primary Algorithm Steps","id":"primary-algorithm-steps"},{"level":4,"text":"Delimiter Stack Data Structures","id":"delimiter-stack-data-structures"},{"level":3,"text":"Inline Parser Architecture Decisions","id":"inline-parser-architecture-decisions"},{"level":4,"text":"Emphasis Delimiter Precedence Rules","id":"emphasis-delimiter-precedence-rules"},{"level":4,"text":"Context-Dependent Delimiter Rules","id":"context-dependent-delimiter-rules"},{"level":3,"text":"Inline Parsing Common Pitfalls","id":"inline-parsing-common-pitfalls"},{"level":4,"text":"Delimiter Stack State Management Issues","id":"delimiter-stack-state-management-issues"},{"level":4,"text":"Context Detection Edge Cases","id":"context-detection-edge-cases"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"List Parser Design","id":"list-parser-design"},{"level":3,"text":"The Document Hierarchy Mental Model","id":"the-document-hierarchy-mental-model"},{"level":3,"text":"List Parsing Algorithm","id":"list-parsing-algorithm"},{"level":4,"text":"Phase 1: List Item Detection and Classification","id":"phase-1-list-item-detection-and-classification"},{"level":4,"text":"Phase 2: Hierarchy Management and Nesting","id":"phase-2-hierarchy-management-and-nesting"},{"level":4,"text":"Phase 3: Content Processing and Continuation","id":"phase-3-content-processing-and-continuation"},{"level":3,"text":"List Parser Architecture Decisions","id":"list-parser-architecture-decisions"},{"level":4,"text":"List Type Consistency and Mixed Lists","id":"list-type-consistency-and-mixed-lists"},{"level":4,"text":"Continuation Line Processing Strategy","id":"continuation-line-processing-strategy"},{"level":3,"text":"List Parsing Common Pitfalls","id":"list-parsing-common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code (Complete and Ready to Use)","id":"infrastructure-starter-code-complete-and-ready-to-use"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"HTML Generator Design","id":"html-generator-design"},{"level":3,"text":"The Document Assembly Mental Model","id":"the-document-assembly-mental-model"},{"level":2,"text":"HTML Generation Algorithm","id":"html-generation-algorithm"},{"level":3,"text":"Tree Traversal Algorithm Steps","id":"tree-traversal-algorithm-steps"},{"level":3,"text":"Node Type Rendering Mappings","id":"node-type-rendering-mappings"},{"level":3,"text":"Content Processing Pipeline","id":"content-processing-pipeline"},{"level":2,"text":"HTML Generator Architecture Decisions","id":"html-generator-architecture-decisions"},{"level":3,"text":"HTML Generation Component Responsibilities","id":"html-generation-component-responsibilities"},{"level":2,"text":"HTML Generation Common Pitfalls","id":"html-generation-common-pitfalls"},{"level":2,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":3,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":3,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":3,"text":"HTML Escaping Infrastructure (Complete Starter Code)","id":"html-escaping-infrastructure-complete-starter-code"},{"level":3,"text":"Pretty Printing Utilities (Complete Starter Code)","id":"pretty-printing-utilities-complete-starter-code"},{"level":3,"text":"Core HTML Generation Logic (Skeleton with TODOs)","id":"core-html-generation-logic-skeleton-with-todos"},{"level":3,"text":"Plugin Interface Implementation (Complete Starter Code)","id":"plugin-interface-implementation-complete-starter-code"},{"level":3,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":3,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"The Orchestra Conductor Mental Model","id":"the-orchestra-conductor-mental-model"},{"level":3,"text":"Complete Parsing Pipeline","id":"complete-parsing-pipeline"},{"level":4,"text":"Pipeline Phase Overview","id":"pipeline-phase-overview"},{"level":4,"text":"Detailed Pipeline Flow","id":"detailed-pipeline-flow"},{"level":4,"text":"Pipeline Error Handling and Recovery","id":"pipeline-error-handling-and-recovery"},{"level":4,"text":"Data Flow Contracts Between Phases","id":"data-flow-contracts-between-phases"},{"level":3,"text":"Component Interface Contracts","id":"component-interface-contracts"},{"level":4,"text":"MarkdownParser Primary Interface","id":"markdownparser-primary-interface"},{"level":4,"text":"Preprocessor Interface Contract","id":"preprocessor-interface-contract"},{"level":4,"text":"Block Parser Interface Contract","id":"block-parser-interface-contract"},{"level":4,"text":"Inline Parser Interface Contract","id":"inline-parser-interface-contract"},{"level":4,"text":"HTML Generator Interface Contract","id":"html-generator-interface-contract"},{"level":4,"text":"Plugin and Extension Interface","id":"plugin-and-extension-interface"},{"level":4,"text":"Error Propagation and Recovery Contracts","id":"error-propagation-and-recovery-contracts"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Main Parser Infrastructure Code","id":"main-parser-infrastructure-code"},{"level":4,"text":"Pipeline Orchestration Skeleton","id":"pipeline-orchestration-skeleton"},{"level":4,"text":"Error Recovery Infrastructure","id":"error-recovery-infrastructure"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"The Graceful Degradation Mental Model","id":"the-graceful-degradation-mental-model"},{"level":3,"text":"Parser Error Recovery","id":"parser-error-recovery"},{"level":4,"text":"Block Parser Error Recovery Strategy","id":"block-parser-error-recovery-strategy"},{"level":4,"text":"Inline Parser Error Recovery Strategy","id":"inline-parser-error-recovery-strategy"},{"level":3,"text":"Edge Case Handling","id":"edge-case-handling"},{"level":4,"text":"Whitespace and Line Break Edge Cases","id":"whitespace-and-line-break-edge-cases"},{"level":4,"text":"Delimiter Precedence Edge Cases","id":"delimiter-precedence-edge-cases"},{"level":4,"text":"List Structure Edge Cases","id":"list-structure-edge-cases"},{"level":4,"text":"Link and Image Edge Cases","id":"link-and-image-edge-cases"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Error Collection Infrastructure","id":"error-collection-infrastructure"},{"level":4,"text":"Block Parser Recovery Implementation","id":"block-parser-recovery-implementation"},{"level":4,"text":"Inline Parser Recovery Implementation","id":"inline-parser-recovery-implementation"},{"level":4,"text":"Edge Case Detection and Handling","id":"edge-case-detection-and-handling"},{"level":4,"text":"Comprehensive Error Testing Framework","id":"comprehensive-error-testing-framework"},{"level":4,"text":"Debugging Error Handling Issues","id":"debugging-error-handling-issues"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"The Quality Assurance Mental Model","id":"the-quality-assurance-mental-model"},{"level":3,"text":"Test Categories and Properties","id":"test-categories-and-properties"},{"level":4,"text":"Unit Test Categories","id":"unit-test-categories"},{"level":4,"text":"Integration Test Categories","id":"integration-test-categories"},{"level":4,"text":"Property-Based Test Categories","id":"property-based-test-categories"},{"level":4,"text":"Error Handling Test Categories","id":"error-handling-test-categories"},{"level":3,"text":"Milestone Verification Checkpoints","id":"milestone-verification-checkpoints"},{"level":4,"text":"Milestone 1: Block Elements Verification","id":"milestone-1-block-elements-verification"},{"level":4,"text":"Milestone 2: Inline Elements Verification","id":"milestone-2-inline-elements-verification"},{"level":4,"text":"Milestone 3: Lists Verification","id":"milestone-3-lists-verification"},{"level":4,"text":"Milestone 4: HTML Generation Verification","id":"milestone-4-html-generation-verification"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations Table","id":"technology-recommendations-table"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":2,"text":"Second Level Heading","id":"second-level-heading"},{"level":3,"text":"Third Level Heading","id":"third-level-heading"},{"level":2,"text":"Heading in blockquote","id":"heading-in-blockquote"},{"level":4,"text":"Nested Blockquotes","id":"nested-blockquotes"},{"level":5,"text":"Mixed Block Types","id":"mixed-block-types"},{"level":6,"text":"Edge Cases","id":"edge-cases"},{"level":1,"text":"Heading with extra spaces","id":"heading-with-extra-spaces"},{"level":2,"text":"Heading with leading spaces","id":"heading-with-leading-spaces"},{"level":1,"text":"","id":""},{"level":1,"text":"Setext Heading Level 1","id":"setext-heading-level-1"},{"level":2,"text":"Setext Heading Level 2","id":"setext-heading-level-2"},{"level":1,"text":"Heading immediately after blanks","id":"heading-immediately-after-blanks"},{"level":2,"text":"Basic Emphasis","id":"basic-emphasis"},{"level":2,"text":"Nested Formatting","id":"nested-formatting"},{"level":2,"text":"Code Spans","id":"code-spans"},{"level":2,"text":"Links and Images","id":"links-and-images"},{"level":2,"text":"Complex Link Cases","id":"complex-link-cases"},{"level":2,"text":"Edge Cases for Emphasis","id":"edge-cases-for-emphasis"},{"level":2,"text":"Escape Sequences","id":"escape-sequences"},{"level":2,"text":"Complex Combinations","id":"complex-combinations"},{"level":2,"text":"Delimiter Matching Edge Cases","id":"delimiter-matching-edge-cases"},{"level":2,"text":"URL Edge Cases","id":"url-edge-cases"},{"level":2,"text":"Simple Unordered Lists","id":"simple-unordered-lists"},{"level":2,"text":"Simple Ordered Lists","id":"simple-ordered-lists"},{"level":2,"text":"Nested Lists","id":"nested-lists"},{"level":2,"text":"Mixed List Types","id":"mixed-list-types"},{"level":2,"text":"Multi-paragraph List Items","id":"multi-paragraph-list-items"},{"level":2,"text":"Lists with Code Blocks","id":"lists-with-code-blocks"},{"level":2,"text":"Lists with Blockquotes","id":"lists-with-blockquotes"},{"level":2,"text":"Tight vs Loose Lists","id":"tight-vs-loose-lists"},{"level":2,"text":"Complex Nesting with Mixed Content","id":"complex-nesting-with-mixed-content"},{"level":2,"text":"Edge Cases","id":"edge-cases"},{"level":2,"text":"Lazy Continuation","id":"lazy-continuation"},{"level":2,"text":"List Marker Consistency","id":"list-marker-consistency"},{"level":2,"text":"Lists at Document Boundaries","id":"lists-at-document-boundaries"},{"level":2,"text":"Empty items:","id":"empty-items"},{"level":1,"text":"Main Heading","id":"main-heading"},{"level":2,"text":"Subheading","id":"subheading"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"The Detective Work Mental Model","id":"the-detective-work-mental-model"},{"level":3,"text":"Symptom-Based Debugging Table","id":"symptom-based-debugging-table"},{"level":3,"text":"Advanced Diagnostic Techniques","id":"advanced-diagnostic-techniques"},{"level":4,"text":"AST Structure Inspection","id":"ast-structure-inspection"},{"level":4,"text":"Pipeline Stage Isolation","id":"pipeline-stage-isolation"},{"level":4,"text":"State Machine Debugging","id":"state-machine-debugging"},{"level":4,"text":"Regular Expression Testing and Optimization","id":"regular-expression-testing-and-optimization"},{"level":3,"text":"Domain-Specific Debugging Techniques","id":"domain-specific-debugging-techniques"},{"level":4,"text":"Whitespace and Character Encoding Issues","id":"whitespace-and-character-encoding-issues"},{"level":4,"text":"Context Dependency Debugging","id":"context-dependency-debugging"},{"level":4,"text":"Delimiter Balance and Nesting Debugging","id":"delimiter-balance-and-nesting-debugging"},{"level":4,"text":"Tree Structure and Parent-Child Relationship Debugging","id":"tree-structure-and-parent-child-relationship-debugging"},{"level":4,"text":"Performance Debugging for Large Documents","id":"performance-debugging-for-large-documents"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Debugging Infrastructure Setup","id":"debugging-infrastructure-setup"},{"level":4,"text":"AST Inspector Implementation","id":"ast-inspector-implementation"},{"level":4,"text":"Pipeline State Tracer","id":"pipeline-state-tracer"},{"level":4,"text":"Regex Pattern Tester","id":"regex-pattern-tester"},{"level":4,"text":"Performance and Memory Profiler","id":"performance-and-memory-profiler"},{"level":4,"text":"Milestone Debugging Checkpoints","id":"milestone-debugging-checkpoints"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"The Evolution Framework Mental Model","id":"the-evolution-framework-mental-model"},{"level":3,"text":"CommonMark Extensions","id":"commonmark-extensions"},{"level":4,"text":"Table Extension Architecture","id":"table-extension-architecture"},{"level":4,"text":"Math Expression Extension","id":"math-expression-extension"},{"level":4,"text":"Task List Extension","id":"task-list-extension"},{"level":4,"text":"Architecture Decision: Extension Integration Strategy","id":"architecture-decision-extension-integration-strategy"},{"level":3,"text":"Plugin and Extension Architecture","id":"plugin-and-extension-architecture"},{"level":4,"text":"The Extension Point Mental Model","id":"the-extension-point-mental-model"},{"level":4,"text":"Extension Point Architecture","id":"extension-point-architecture"},{"level":4,"text":"Plugin Interface Design","id":"plugin-interface-design"},{"level":4,"text":"Plugin Configuration and Lifecycle","id":"plugin-configuration-and-lifecycle"},{"level":4,"text":"Custom Renderer Development","id":"custom-renderer-development"},{"level":4,"text":"Extension Development Best Practices","id":"extension-development-best-practices"},{"level":4,"text":"Extension Ecosystem Considerations","id":"extension-ecosystem-considerations"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"File Structure for Extensions","id":"file-structure-for-extensions"},{"level":4,"text":"Plugin Manager Infrastructure","id":"plugin-manager-infrastructure"},{"level":4,"text":"Table Extension Implementation","id":"table-extension-implementation"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"The Reference Manual Mental Model","id":"the-reference-manual-mental-model"},{"level":3,"text":"Core Parsing Concepts","id":"core-parsing-concepts"},{"level":3,"text":"Markdown Syntax Terminology","id":"markdown-syntax-terminology"},{"level":3,"text":"Parsing Algorithm Terminology","id":"parsing-algorithm-terminology"},{"level":3,"text":"Data Structure and Type Terminology","id":"data-structure-and-type-terminology"},{"level":3,"text":"Error Handling and Recovery Terminology","id":"error-handling-and-recovery-terminology"},{"level":3,"text":"Testing and Debugging Terminology","id":"testing-and-debugging-terminology"},{"level":3,"text":"Architecture and Extension Terminology","id":"architecture-and-extension-terminology"},{"level":3,"text":"Regular Expression and Pattern Matching Terminology","id":"regular-expression-and-pattern-matching-terminology"},{"level":3,"text":"HTML Generation and Output Terminology","id":"html-generation-and-output-terminology"},{"level":3,"text":"Performance and Optimization Terminology","id":"performance-and-optimization-terminology"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations for Documentation","id":"technology-recommendations-for-documentation"},{"level":4,"text":"Recommended Documentation Structure","id":"recommended-documentation-structure"},{"level":4,"text":"Terminology Validation Utilities","id":"terminology-validation-utilities"},{"level":4,"text":"Core Terminology Integration","id":"core-terminology-integration"},{"level":4,"text":"Language-Specific Terminology Hints","id":"language-specific-terminology-hints"},{"level":4,"text":"Milestone Checkpoint: Terminology Consistency","id":"milestone-checkpoint-terminology-consistency"},{"level":4,"text":"Debugging Terminology Issues","id":"debugging-terminology-issues"}],"title":"Markdown Renderer: Design Document","markdown":"# Markdown Renderer: Design Document\n\n\n## Overview\n\nA Markdown to HTML converter that transforms markdown text into semantic HTML through a multi-stage parsing pipeline. The key architectural challenge is handling the recursive nature of nested elements while maintaining proper precedence between block-level and inline elements.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation\n\nAt its core, building a markdown renderer means solving a **document transformation problem** — converting human-friendly lightweight markup into structured HTML that browsers can render. This challenge sits at the intersection of text processing, formal language parsing, and document structure understanding. The fundamental difficulty lies in the fact that markdown's informal, human-readable syntax must be transformed into HTML's strict, nested tag structure while preserving semantic meaning and handling edge cases gracefully.\n\nThe markdown parsing problem exemplifies what makes text processing both fascinating and challenging for software engineers. Unlike parsing structured data formats like JSON or XML, markdown parsing must handle ambiguous syntax, context-dependent interpretation, and the inherent messiness of human-authored content. A single line of text might be a heading, the start of a paragraph, part of a code block, or a list item — the parser must examine surrounding context, indentation patterns, and delimiter sequences to make the correct determination.\n\nThis design document addresses the architectural decisions needed to build a robust markdown renderer that can handle the full spectrum of CommonMark syntax while remaining maintainable and extensible. We focus on the critical parsing pipeline design, the intermediate representations that enable correct transformation, and the error handling strategies that ensure graceful degradation when encountering malformed input.\n\n### The Document Transformation Mental Model\n\nThink of markdown parsing like **translating between two human languages with fundamentally different grammatical structures**. Imagine you're translating from a language that uses word order and context to convey meaning (like English) into a language that uses explicit grammatical particles and nested structures (like Japanese or Latin). The translator doesn't just substitute words — they must understand the semantic intent of entire phrases and restructure them according to the target language's rules.\n\nIn markdown parsing, the \"source language\" is markdown's lightweight, context-dependent syntax where meaning emerges from patterns like indentation, blank lines, and special character sequences. The \"target language\" is HTML's explicit, hierarchically nested tag structure where every element has clear boundaries and relationships. Just as a human translator must understand context and implied meaning, a markdown parser must infer document structure from visual patterns and formatting conventions.\n\nConsider this concrete example of the transformation challenge:\n\n```\n# Getting Started\n\nHere's a simple example:\n\n    def hello():\n        print(\"world\")\n\nThis shows basic **Python** syntax.\n```\n\nThe human reader immediately recognizes this as a heading, followed by introductory text, then a code block, and finally a concluding paragraph with emphasis. However, the parser must systematically analyze each line to make these determinations. The heading is identified by the `#` prefix pattern. The blank lines signal paragraph boundaries. The consistent four-space indentation indicates a code block. The `**` delimiters mark inline emphasis within the final paragraph.\n\nThe parser must handle this analysis in a way that mirrors how humans process the document — first identifying the overall block structure (heading, paragraph, code block, paragraph), then processing inline formatting within each block. This two-phase approach reflects how we naturally read documents: we first perceive the layout and major sections, then focus on detailed formatting within each section.\n\nThe translation analogy extends to error handling as well. When a human translator encounters ambiguous or incorrect source text, they make reasonable assumptions about intent and produce the most sensible translation possible. Similarly, markdown parsers must handle malformed input gracefully — treating unmatched delimiters as literal text, continuing parsing after encountering invalid syntax, and producing reasonable HTML output even from imperfect markdown input.\n\nThis mental model of **progressive structural interpretation** guides our architectural decisions. Like a translator working with complex nested clauses, our parser must maintain context about its current position in the document structure while making local decisions about individual elements. It must handle both the forest (overall document organization) and the trees (individual formatting elements) in a coordinated fashion.\n\n### Existing Parsing Approaches\n\nThe markdown parsing landscape offers three primary architectural approaches, each representing different trade-offs between implementation complexity, parsing accuracy, and maintainability. Understanding these approaches provides crucial context for our design decisions and helps illuminate why certain architectural patterns emerge as best practices.\n\n> **Decision: Two-Phase Parsing Architecture**\n> - **Context**: Markdown syntax exhibits both block-level structure (paragraphs, headings, lists) and inline formatting (emphasis, links, code spans). These two levels interact in complex ways that require different parsing strategies.\n> - **Options Considered**: Regex-only approach, recursive descent parser, two-phase block-then-inline parser\n> - **Decision**: Implement a two-phase parser that handles block structure first, then processes inline elements within each block\n> - **Rationale**: Block structure provides the fundamental document skeleton and is largely context-independent, while inline parsing requires understanding of the containing block type. Separating these concerns simplifies both parsing phases and aligns with how humans read documents.\n> - **Consequences**: Enables simpler, more maintainable parsing logic at the cost of requiring two complete passes through the document content.\n\n| Approach | Implementation Complexity | Parsing Accuracy | Performance | Maintainability | Error Recovery |\n|----------|-------------------------|-----------------|-------------|----------------|----------------|\n| Regex-Only | Low | Poor | High | Poor | Poor |\n| Recursive Descent | High | High | Medium | Medium | Good |\n| Two-Phase (Block + Inline) | Medium | High | Medium | Good | Good |\n\n**The Regex-Only Approach** represents the most straightforward implementation strategy, where each markdown construct maps to a regular expression pattern. A heading parser might use `^(#{1,6})\\s+(.+)$` to match ATX-style headings, while emphasis detection could employ `\\*\\*([^*]+)\\*\\*` for bold text. This approach feels natural to developers familiar with text processing and offers immediate gratification — you can have basic markdown rendering working in under 100 lines of code.\n\nHowever, the regex-only approach quickly encounters fundamental limitations that stem from markdown's context-sensitive nature. Consider the challenge of parsing emphasis correctly: the pattern `_underscore_emphasis_` should render as `<em>underscore_emphasis</em>` because underscores in the middle of words don't trigger emphasis according to CommonMark rules. A simple regex cannot encode this contextual understanding without becoming prohibitively complex. Additionally, nested structures like lists containing code blocks or blockquotes containing emphasis require sophisticated lookahead and backtracking that pushes regular expressions beyond their effective limits.\n\nThe error recovery characteristics of regex-based parsing prove particularly problematic. When a regular expression fails to match, the parser has little context about why the failure occurred or how to proceed. This leads to either silent failures (where malformed markdown disappears from output) or catastrophic failures (where a single syntax error breaks the entire parsing process). Real-world markdown documents contain numerous edge cases and minor syntax errors that require graceful handling.\n\n**The Recursive Descent Approach** treats markdown as a formal grammar and builds a traditional recursive descent parser with productions for each syntactic construct. This approach offers excellent theoretical foundations and can handle arbitrarily complex nested structures with proper precedence handling. Parser generators or hand-written recursive functions naturally express the hierarchical relationships between markdown elements.\n\nRecursive descent parsers excel at error recovery because they maintain rich context about the current parsing position and can implement sophisticated backtracking strategies. When parsing fails at one level, the parser can unwind to a previous state and attempt alternative interpretations. This leads to robust handling of malformed input and better diagnostic error messages.\n\nThe primary challenge with recursive descent parsing lies in markdown's inherent ambiguity and lookahead requirements. Unlike programming languages with unambiguous grammars, markdown often requires examining multiple lines ahead to make parsing decisions. Setext-style headings (where the heading text is followed by a line of `===` or `---` characters) exemplify this challenge — the parser cannot definitively identify a heading until it reads the following line. This lookahead requirement complicates the recursive descent approach and can lead to significant backtracking overhead.\n\n**The Two-Phase Parsing Approach** emerged from the CommonMark specification's recognition that block-level and inline parsing represent fundamentally different challenges requiring different strategies. This approach first processes the entire document to identify block-level structures (paragraphs, headings, lists, code blocks, blockquotes), building an intermediate representation that captures the document's hierarchical organization. The second phase processes inline elements within each block, handling emphasis, links, images, and code spans according to rules specific to each block type.\n\nThe key insight driving two-phase parsing is that **block structure provides semantic context for inline parsing**. Code blocks disable all inline processing, preserving literal text exactly as written. List items require special handling of line breaks and continuation. Headings process inline elements but ignore certain constructs like line breaks. By establishing block structure first, the inline parser operates with clear context about how to interpret formatting within each container.\n\nTwo-phase parsing also enables superior error handling through **graceful degradation**. If block parsing encounters malformed syntax, it can fall back to treating questionable content as paragraph text, allowing inline parsing to proceed normally. If inline parsing fails to match emphasis delimiters correctly, it can render them as literal text without affecting the overall document structure. This resilience mirrors how humans read documents — we can extract meaning even from imperfectly formatted text.\n\nThe intermediate representation between parsing phases provides a natural extension point for custom functionality. Additional block types, custom renderers, and syntax validation can all hook into the AST structure without modifying the core parsing logic. This architectural flexibility proves crucial for long-term maintainability and feature enhancement.\n\n| Parsing Phase | Input Format | Processing Strategy | Output Format | Error Handling |\n|--------------|--------------|-------------------|---------------|----------------|\n| Block Parsing | Raw markdown text | Line-by-line state machine | Block-structured AST | Fallback to paragraph blocks |\n| Inline Parsing | Text content from AST blocks | Delimiter-based pattern matching | Fully populated AST | Render unmatched delimiters as literal text |\n| HTML Generation | Complete AST structure | Tree traversal with node-specific renderers | Valid HTML output | Escape invalid content, continue processing |\n\nThe two-phase approach does introduce some complexity overhead compared to simpler alternatives. The parser must maintain sophisticated state between phases, and certain edge cases require coordination between block and inline processing. However, this complexity remains localized within well-defined architectural boundaries, making it manageable compared to the sprawling complexity that emerges from trying to handle all parsing concerns simultaneously.\n\n> **The critical architectural insight is that document structure emerges at different levels of granularity, and each level requires specialized parsing strategies that align with how humans naturally process written content.**\n\nUnderstanding these parsing approaches provides the foundation for our detailed design decisions in subsequent sections. The two-phase architecture shapes everything from our data model design to our error handling strategies, and recognizing the trade-offs involved helps explain why certain implementation choices emerge as architectural necessities rather than arbitrary preferences.\n\n⚠️ **Pitfall: Attempting Single-Pass Parsing**\nMany developers initially attempt to parse both block structure and inline formatting in a single pass through the markdown text. This approach seems more efficient and simpler to implement. However, it quickly leads to complex, brittle code that struggles with context-dependent parsing rules. For example, determining whether `*` characters represent list bullets, emphasis markers, or literal text requires understanding the surrounding block context. Single-pass parsers either make incorrect parsing decisions or require extensive backtracking that negates any performance benefits. The two-phase approach, while requiring two passes through the content, results in significantly cleaner, more maintainable code that handles edge cases correctly.\n\n### Implementation Guidance\n\nOur implementation strategy focuses on building a robust foundation that can grow with your understanding while providing immediate feedback on progress. The technology choices prioritize clarity and debuggability over performance optimization, recognizing that correct implementation comes before efficient implementation.\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option | Rationale |\n|-----------|--------------|-----------------|-----------|\n| Text Processing | String manipulation with `str.split()` and `str.strip()` | Regular expressions with `re` module | Start simple, add regex patterns as needed |\n| Data Structures | Dictionaries and lists for AST nodes | Custom classes with type hints | Dictionaries are easier to debug and inspect |\n| Input/Output | File reading with `open()` and string returns | Streaming with generators for large files | File-based I/O suffices for learning projects |\n| Testing | `assert` statements with sample inputs | `unittest` or `pytest` framework | Simple assertions provide immediate feedback |\n| HTML Generation | String concatenation and `.format()` | Template engines like `jinja2` | String operations keep dependencies minimal |\n\n**Recommended File Structure:**\n\n```\nmarkdown-renderer/\n├── src/\n│   ├── __init__.py\n│   ├── lexer.py              ← Text tokenization utilities\n│   ├── block_parser.py       ← Block-level element parsing\n│   ├── inline_parser.py      ← Inline formatting parsing  \n│   ├── list_parser.py        ← List-specific parsing logic\n│   ├── html_generator.py     ← AST to HTML conversion\n│   └── ast_nodes.py          ← Data structures for parsed content\n├── tests/\n│   ├── __init__.py\n│   ├── test_block_parser.py  ← Block parsing verification\n│   ├── test_inline_parser.py ← Inline parsing verification\n│   ├── test_integration.py   ← End-to-end parsing tests\n│   └── fixtures/             ← Sample markdown files\n│       ├── basic.md\n│       ├── complex.md\n│       └── edge_cases.md\n├── examples/\n│   ├── simple_example.py     ← Basic usage demonstration\n│   └── sample_documents/     ← Test markdown files\n└── main.py                   ← Command-line interface\n```\n\nThis structure separates concerns clearly while keeping the project manageable. Each parsing phase gets its own module, making it easy to test components independently and understand their responsibilities. The `ast_nodes.py` module provides shared data structures, while `lexer.py` contains utilities used across multiple parsing phases.\n\n**Infrastructure Starter Code:**\n\nThe following complete utility functions handle common text processing tasks that aren't central to learning parsing concepts but are necessary for implementation:\n\n```python\n# src/lexer.py - Complete utility functions\ndef normalize_line_endings(text):\n    \"\"\"Convert all line endings to Unix-style \\n characters.\"\"\"\n    return text.replace('\\r\\n', '\\n').replace('\\r', '\\n')\n\ndef split_into_lines(text):\n    \"\"\"Split text into lines, preserving information about blank lines.\"\"\"\n    lines = normalize_line_endings(text).split('\\n')\n    return [(i, line) for i, line in enumerate(lines)]\n\ndef is_blank_line(line):\n    \"\"\"Check if a line contains only whitespace characters.\"\"\"\n    return len(line.strip()) == 0\n\ndef get_indentation_level(line):\n    \"\"\"Calculate the number of leading spaces in a line.\"\"\"\n    return len(line) - len(line.lstrip(' '))\n\ndef remove_leading_spaces(line, num_spaces):\n    \"\"\"Remove up to num_spaces leading spaces from line.\"\"\"\n    spaces_to_remove = min(num_spaces, get_indentation_level(line))\n    return line[spaces_to_remove:]\n\n# src/html_generator.py - HTML escaping utilities\nHTML_ESCAPE_TABLE = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;'\n}\n\ndef escape_html(text):\n    \"\"\"Escape special HTML characters to prevent injection.\"\"\"\n    result = text\n    for char, escape in HTML_ESCAPE_TABLE.items():\n        result = result.replace(char, escape)\n    return result\n\ndef pretty_print_html(html, indent_size=2):\n    \"\"\"Add indentation to HTML for readable output.\"\"\"\n    lines = []\n    indent_level = 0\n    \n    for line in html.split('\\n'):\n        line = line.strip()\n        if not line:\n            continue\n            \n        if line.startswith('</'):\n            indent_level -= 1\n            \n        lines.append(' ' * (indent_level * indent_size) + line)\n        \n        if line.startswith('<') and not line.startswith('</') and not line.endswith('/>'):\n            indent_level += 1\n    \n    return '\\n'.join(lines)\n```\n\n**Core Parsing Infrastructure Skeleton:**\n\nThe main parsing coordinator provides the overall structure while leaving the core logic for you to implement:\n\n```python\n# src/markdown_parser.py - Main parsing coordinator\nclass MarkdownParser:\n    \"\"\"Coordinates the two-phase parsing process from markdown to HTML.\"\"\"\n    \n    def __init__(self):\n        self.block_parser = BlockParser()\n        self.inline_parser = InlineParser()\n        self.html_generator = HTMLGenerator()\n    \n    def parse_to_html(self, markdown_text):\n        \"\"\"\n        Convert markdown text to HTML through two-phase parsing.\n        \n        Args:\n            markdown_text (str): Raw markdown content\n            \n        Returns:\n            str: Valid HTML output\n        \"\"\"\n        # TODO 1: Use lexer utilities to split text into lines and normalize formatting\n        # TODO 2: Pass lines to block parser to build initial AST structure  \n        # TODO 3: Pass block AST to inline parser to process formatting within blocks\n        # TODO 4: Pass complete AST to HTML generator for final output\n        # TODO 5: Return escaped, properly formatted HTML\n        pass\n    \n    def parse_file(self, file_path):\n        \"\"\"Parse a markdown file and return HTML output.\"\"\"\n        # TODO 1: Open file and read contents with proper encoding handling\n        # TODO 2: Call parse_to_html with file contents\n        # TODO 3: Handle file reading errors gracefully\n        pass\n\n# src/ast_nodes.py - Data structure skeletons\nclass ASTNode:\n    \"\"\"Base class for all AST nodes in the parsing tree.\"\"\"\n    \n    def __init__(self, node_type):\n        # TODO: Define common fields needed by all AST nodes\n        # Hint: node_type, children, parent, line_number are useful\n        pass\n\nclass BlockNode(ASTNode):\n    \"\"\"Base class for block-level elements like paragraphs and headings.\"\"\"\n    \n    def __init__(self, block_type):\n        # TODO: Initialize base class and add block-specific fields\n        # Hint: Block nodes contain inline content and have block-specific attributes\n        pass\n\nclass InlineNode(ASTNode):\n    \"\"\"Base class for inline elements like emphasis and links.\"\"\"\n    \n    def __init__(self, inline_type):\n        # TODO: Initialize base class and add inline-specific fields  \n        # Hint: Inline nodes often have text content and formatting attributes\n        pass\n```\n\n**Language-Specific Implementation Hints:**\n\nPython's string processing capabilities make it an excellent choice for text parsing projects. Key language features that simplify markdown parsing include:\n\n- **String slicing**: Use `line[2:]` to remove leading `## ` from headings, `text[start:end]` for extracting content between delimiters\n- **String methods**: `str.startswith()` for prefix detection, `str.strip()` for whitespace removal, `str.count()` for delimiter counting\n- **List comprehensions**: `[line for line in lines if not is_blank_line(line)]` for filtering, `[get_indentation_level(line) for line in block]` for indentation analysis\n- **Regular expressions**: Import `re` module for complex pattern matching, use `re.compile()` to precompile frequently used patterns for better performance\n- **Dictionary-based state machines**: Use dictionaries to map states to handler functions, enabling clean state machine implementation without complex if-elif chains\n\nWhen implementing the parsing logic, prefer explicit state tracking over implicit assumptions. Maintain variables like `current_block_type`, `indentation_stack`, and `delimiter_stack` to make parsing decisions transparent and debuggable. Use descriptive variable names like `heading_level` instead of `level`, `emphasis_delimiter` instead of `delim` — the extra verbosity pays dividends when debugging complex parsing edge cases.\n\n**Debugging and Verification Strategies:**\n\nSince markdown parsing involves complex text transformations, robust debugging capabilities are essential. Build debugging support into your parser from the beginning:\n\n```python\n# Debug utilities to include in your implementation\ndef debug_print_ast(node, indent=0):\n    \"\"\"Print AST structure with indentation showing hierarchy.\"\"\"\n    # TODO: Implement tree traversal that shows node types and content\n    # This helps verify that parsing creates the expected structure\n    pass\n\ndef debug_print_parsing_steps(parser, text):\n    \"\"\"Show step-by-step parsing decisions for debugging.\"\"\"\n    # TODO: Add logging to show which parsing rules match each line\n    # This helps identify where parsing goes wrong on malformed input\n    pass\n\ndef validate_html_output(html):\n    \"\"\"Basic validation that generated HTML is well-formed.\"\"\"\n    # TODO: Check that all opening tags have matching closing tags\n    # TODO: Verify that special characters are properly escaped\n    # This catches common HTML generation errors before manual testing\n    pass\n```\n\nThe key to successful markdown parser implementation is building incrementally with constant verification. After implementing each parsing component, test it thoroughly with both valid and malformed input before moving to the next component. The two-phase architecture makes this incremental approach natural — you can verify block parsing completely before touching inline parsing, then verify inline parsing before implementing HTML generation.\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation\n\n### The Scope Definition Mental Model\n\nThink of building a markdown renderer like planning a house construction project. Just as a house contractor must clearly define what's included in the base contract versus what constitutes expensive custom work, we must establish precise boundaries for our markdown renderer. Without clear scope boundaries, feature creep will transform a beginner-friendly learning project into an overwhelming enterprise-grade parsing system. The goals and non-goals serve as our project contract, protecting both the implementation timeline and the learning experience.\n\nEvery markdown renderer exists within a spectrum of complexity. On one end lie minimal parsers that handle basic formatting with simple regular expressions. On the other end sit full-featured systems like GitHub's markdown processor that support dozens of extensions, custom syntax highlighting, mathematical notation, and complex table formatting. Our markdown renderer intentionally positions itself as a comprehensive but focused implementation that teaches core parsing principles without drowning learners in edge cases and rarely-used features.\n\nThe key insight is that markdown parsing involves two distinct types of complexity: **structural complexity** (how we parse and represent markdown) and **feature complexity** (what markdown syntax we support). Our goals maximize structural complexity to teach essential parsing concepts while carefully limiting feature complexity to maintain project feasibility. This approach ensures learners experience the full architectural challenges of building a document transformer without getting lost in specification minutiae.\n\n### Primary Goals\n\nThe markdown renderer has four primary objectives that directly align with the core learning outcomes for building document transformation systems.\n\n**Goal 1: Implement Core CommonMark Block Elements**\n\nOur renderer will support the fundamental block-level structures that form the backbone of structured documents. This includes ATX-style headings (hash-prefixed), paragraphs with proper line handling, fenced and indented code blocks, horizontal rules, and blockquotes with nesting support. These elements teach the essential concept of **block-level parsing**, where we must identify document structure by analyzing line patterns and maintaining parsing state across multiple lines.\n\nThe structural learning value comes from implementing the state machine logic needed to distinguish between different block types, handle multi-line content correctly, and manage the transition between parsing phases. Code blocks, for example, require different parsing rules than regular paragraphs—content inside code blocks must be preserved literally without further markdown processing.\n\n**Goal 2: Implement Essential Inline Formatting Elements**\n\nWithin the content of block elements, our renderer will parse inline formatting including emphasis (bold and italic using asterisks and underscores), inline code spans with backtick delimiters, hyperlinks using bracket-parenthesis syntax, and images using the exclamation-bracket-parenthesis pattern. These elements introduce the critical challenge of **nested parsing**, where formatting elements can contain other formatting elements with proper precedence rules.\n\nThe key learning objective is mastering **delimiter matching**—the algorithm for finding pairs of formatting markers while handling mismatched delimiters, escaped characters, and nested structures correctly. This teaches pattern recognition, state management, and the recursive nature of text processing.\n\n**Goal 3: Implement Hierarchical List Structures**\n\nBoth ordered and unordered lists with full nesting support represent one of the most complex structural parsing challenges in markdown. Lists require tracking indentation levels, distinguishing between list continuation and new list items, handling mixed content within list items, and building proper tree structures for nested lists. This goal teaches **recursive parsing** and **indentation-based structure detection**.\n\nLists also introduce the concept of **context-dependent parsing**, where the meaning of a line depends on its position relative to other elements. A line starting with `1.` might begin an ordered list, continue an existing list, or simply be regular paragraph content, depending on indentation and surrounding context.\n\n**Goal 4: Generate Valid, Well-Formed HTML Output**\n\nThe final parsing phase converts our internal AST representation into semantic HTML5. This includes proper HTML entity escaping for special characters, correct nesting of HTML elements, and optionally formatted output with consistent indentation. This goal teaches **tree traversal algorithms**, **character encoding safety**, and the principles of generating structured output from internal representations.\n\nHTML generation also introduces the concept of **separation of concerns** between parsing and rendering. The same AST could theoretically generate different output formats (HTML, XML, plain text) with different renderer implementations.\n\n| Core Goal | Primary Learning Concept | Key Implementation Challenge | Success Metric |\n|-----------|-------------------------|------------------------------|----------------|\n| Block Elements | State machine parsing | Line-by-line content classification | Correctly parse mixed block types in sequence |\n| Inline Formatting | Delimiter matching and nesting | Handling nested emphasis and mismatched delimiters | Bold text can contain italic text and vice versa |\n| Hierarchical Lists | Recursive structure building | Indentation tracking and list continuation | Three-level nested lists render correctly |\n| HTML Generation | Tree traversal and escaping | Safe character encoding and valid markup | Output passes W3C HTML5 validation |\n\n### Secondary Goals\n\nBeyond the core parsing functionality, our markdown renderer includes several secondary objectives that enhance the learning experience and prepare for real-world usage scenarios.\n\n**Comprehensive Error Handling and Recovery**\n\nRather than failing on malformed input, our renderer implements **graceful degradation** strategies that produce reasonable output even from invalid markdown. When encountering mismatched emphasis delimiters like `**bold text*`, the renderer should treat the unmatched markers as literal text rather than crashing or producing invalid HTML. This teaches defensive programming and the importance of robust parsers in production systems.\n\nError recovery also includes handling edge cases like empty inputs, files with only whitespace, unclosed code blocks, and deeply nested structures. Each error scenario provides learning opportunities about input validation and parser resilience.\n\n**Extensible Architecture with Plugin Points**\n\nThe renderer design includes well-defined interfaces that allow customization of HTML output without modifying core parsing logic. This might include custom CSS class injection, alternative HTML element choices, or specialized rendering for code blocks with syntax highlighting hooks. This secondary goal teaches **interface design** and **extensibility patterns** common in larger software systems.\n\nThe plugin architecture demonstrates how to build systems that support customization while maintaining a stable core. Even if learners don't implement custom renderers, understanding the extension points teaches valuable lessons about API design.\n\n**Performance-Conscious Implementation**\n\nWhile performance is not the primary objective, our implementation avoids obviously inefficient patterns that would make the renderer unusable on moderately-sized documents. This means single-pass parsing where possible, avoiding excessive string copying, and using appropriate data structures for different operations. This goal teaches **algorithmic efficiency** awareness without requiring advanced optimization techniques.\n\nPerformance consciousness also includes memory usage patterns—building AST nodes incrementally rather than storing entire document content in memory simultaneously, and cleaning up intermediate parsing state appropriately.\n\n### Explicit Non-Goals\n\nUnderstanding what we will NOT implement is equally important for maintaining project scope and completion timeline. These non-goals represent features that would significantly increase implementation complexity without proportional learning value for a beginner-level project.\n\n**Advanced CommonMark Extensions**\n\nWe will not implement tables, strikethrough text, task lists, footnotes, definition lists, or mathematical notation. While these features appear in many markdown flavors, they introduce substantial parsing complexity without teaching fundamentally new concepts. Tables alone require multi-pass parsing, column alignment algorithms, and complex HTML generation logic that could double the project timeline.\n\nThe decision to exclude extensions focuses learning energy on mastering the core parsing patterns rather than memorizing specification details for rarely-used syntax features.\n\n**Custom Syntax Extensions**\n\nUnlike some markdown processors, our renderer will not support custom syntax through configuration or plugins. Features like custom block types, alternative link syntax, or embed codes for external content fall outside our scope. Supporting custom syntax requires building a parser generator or macro system, which represents a completely different architectural challenge.\n\nThis boundary keeps the project focused on understanding markdown parsing specifically rather than general-purpose language processing.\n\n**Advanced HTML Features and Customization**\n\nWe will not generate custom CSS classes, support HTML attributes in markdown syntax, or provide extensive HTML customization options. The HTML output will be clean, semantic HTML5 without styling concerns. While some markdown processors allow syntax like `{.css-class}` to add attributes, this feature adds parsing complexity without teaching core document transformation concepts.\n\nSimilarly, we won't support inline HTML pass-through beyond basic safety (HTML tags in markdown content should be escaped, not rendered). Supporting mixed HTML/markdown requires a much more sophisticated parser that can switch between parsing modes dynamically.\n\n**Performance Optimization and Streaming**\n\nOur implementation will not focus on streaming large documents, incremental parsing, or memory optimization for massive files. While production markdown processors often implement these features, they require advanced techniques like lazy evaluation, parser combinators, or custom memory management that would obscure the fundamental parsing algorithms we're trying to teach.\n\nThe renderer should handle documents up to several hundred kilobytes efficiently, which covers the vast majority of real-world markdown files without requiring optimization complexity.\n\n**Specification Compliance Edge Cases**\n\nWe will not implement every edge case detail from the CommonMark specification, particularly around whitespace handling, Unicode normalization, or obscure delimiter precedence rules. For example, the exact behavior of emphasis markers inside words (`middle_of_word` should not trigger emphasis) is important for production systems but adds implementation complexity that doesn't teach new concepts.\n\nOur approach prioritizes implementing the common usage patterns correctly rather than achieving 100% specification compliance on edge cases that rarely appear in real documents.\n\n| Non-Goal Category | Specific Excluded Features | Rationale | Alternative Learning Path |\n|-------------------|---------------------------|-----------|--------------------------|\n| Advanced Extensions | Tables, footnotes, math notation | Doubles complexity without new parsing concepts | Separate advanced project after completing core renderer |\n| Custom Syntax | Plugin-based syntax, custom blocks | Requires parser generator architecture | Study existing parser frameworks like ANTLR |\n| HTML Customization | CSS injection, attribute syntax | HTML generation becomes dominant complexity | Separate CSS/styling project |\n| Performance | Streaming, memory optimization | Obscures fundamental algorithms | Performance engineering course after mastering basics |\n| Specification Compliance | Unicode edge cases, obscure precedence | Implementation detail memorization vs. concept learning | Read CommonMark spec for completeness understanding |\n\n### Success Criteria and Acceptance Boundaries\n\nTo maintain clear project scope, we define specific success criteria that distinguish between acceptable implementation variations and scope creep that violates our goals.\n\n**Functional Success Criteria**\n\nA successful markdown renderer implementation must correctly parse and render a representative test document containing all supported elements in various combinations. This includes nested lists with inline formatting, code blocks adjacent to headings, blockquotes containing emphasis and links, and proper paragraph separation throughout.\n\nThe renderer must also handle empty inputs gracefully, process files with different line ending conventions (Unix, Windows, Mac), and generate HTML that validates against W3C standards without warnings or errors.\n\n**Quality Success Criteria**\n\nBeyond functional correctness, successful implementations demonstrate clean separation between parsing phases, readable code organization that follows the recommended file structure, and error handling that provides meaningful feedback rather than cryptic failure messages.\n\nThe AST structure should be inspectable for debugging, with utility functions that can pretty-print the parsed tree structure. This requirement ensures learners understand their parser's internal state, which is crucial for debugging and validation.\n\n**Learning Objective Success Criteria**\n\nMost importantly, successful implementations demonstrate that the learner understands the core concepts rather than just copying working code. This means they can explain why the two-phase parsing approach (block then inline) is necessary, how delimiter matching algorithms handle nested formatting, and what trade-offs their architectural decisions introduce.\n\nLearners should be able to extend their implementation with simple new features (like supporting `~~strikethrough~~` syntax) without requiring major architectural changes. This demonstrates they've internalized the parsing patterns rather than just implementing specific features.\n\n> **Key Design Principle**: Scope boundaries serve learning objectives, not feature completeness. Every included feature must teach a distinct parsing concept, while excluded features should be omittable without compromising the educational value of core implementation challenges.\n\nThe tension between scope and learning occurs when interesting features (like tables) would teach valuable lessons (like multi-pass parsing) but at the cost of project complexity that overwhelms beginners. Our goals resolve this tension by prioritizing depth in core concepts over breadth in supported features. Learners who master our focused implementation will be well-prepared to tackle extensions and advanced features in subsequent projects.\n\n### Implementation Guidance\n\nThe goals and non-goals translate into specific technology choices and project organization strategies that support successful implementation while maintaining educational focus.\n\n**A. Technology Recommendations Table:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Text Processing | Built-in string methods + basic regex | Full regex engines with lookahead/lookbehind |\n| Data Structures | Lists and dictionaries for AST nodes | Custom tree classes with traversal methods |\n| HTML Generation | String concatenation with escaping | Template engines or HTML builder libraries |\n| File I/O | Read entire file into memory | Streaming/chunked file processing |\n| Testing Framework | Built-in unittest/assert modules | Property-based testing frameworks |\n| Code Organization | Single module with classes | Multi-package architecture with interfaces |\n\nFor beginners, the simple options provide immediate productivity without requiring mastery of complex libraries. Advanced options become attractive once the core concepts are solid.\n\n**B. Recommended File/Module Structure:**\n\nThe file organization should reflect the parsing pipeline and make the architectural boundaries clear:\n\n```\nmarkdown-renderer/\n├── main.py                    # CLI entry point and file I/O\n├── parser.py                  # MarkdownParser class and parse_to_html()\n├── lexer.py                   # Line processing and normalization utilities  \n├── blocks.py                  # Block-level parsing (BlockNode classes)\n├── inlines.py                 # Inline parsing (InlineNode classes)\n├── lists.py                   # List parsing (separate due to complexity)\n├── ast_nodes.py               # ASTNode, BlockNode, InlineNode definitions\n├── html_generator.py          # HTML output generation and escaping\n├── utils.py                   # Helper functions (debug_print_ast, etc.)\n├── test_samples/              # Sample markdown files for testing\n│   ├── basic_elements.md      # Simple test cases for each element\n│   ├── nested_structures.md   # Complex combinations and nesting\n│   └── edge_cases.md          # Error conditions and malformed input\n└── tests/                     # Unit tests organized by component\n    ├── test_blocks.py\n    ├── test_inlines.py \n    ├── test_lists.py\n    └── test_integration.py\n```\n\nThis structure separates concerns while keeping related functionality together. The `test_samples/` directory provides immediate feedback during development.\n\n**C. Infrastructure Starter Code (COMPLETE, ready to use):**\n\n```python\n# utils.py - Complete utility functions for debugging and line processing\n\nHTML_ESCAPE_TABLE = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n}\n\ndef normalize_line_endings(text):\n    \"\"\"Convert all line endings to Unix format (\\n).\"\"\"\n    return text.replace('\\r\\n', '\\n').replace('\\r', '\\n')\n\ndef split_into_lines(text):\n    \"\"\"Split text into lines, preserving empty lines and tracking line numbers.\"\"\"\n    lines = text.split('\\n')\n    return [(i + 1, line) for i, line in enumerate(lines)]\n\ndef is_blank_line(line):\n    \"\"\"Check if line contains only whitespace characters.\"\"\"\n    return len(line.strip()) == 0\n\ndef get_indentation_level(line):\n    \"\"\"Count leading spaces in line. Tabs count as 4 spaces.\"\"\"\n    count = 0\n    for char in line:\n        if char == ' ':\n            count += 1\n        elif char == '\\t':\n            count += 4\n        else:\n            break\n    return count\n\ndef escape_html(text):\n    \"\"\"Escape special HTML characters to prevent injection.\"\"\"\n    if not text:\n        return text\n    result = text\n    for char, escape in HTML_ESCAPE_TABLE.items():\n        result = result.replace(char, escape)\n    return result\n\ndef debug_print_ast(node, indent=0):\n    \"\"\"Print AST structure for debugging purposes.\"\"\"\n    prefix = \"  \" * indent\n    if hasattr(node, 'node_type'):\n        print(f\"{prefix}{node.node_type}: {getattr(node, 'text_content', '')[:50]}\")\n    if hasattr(node, 'children'):\n        for child in node.children:\n            debug_print_ast(child, indent + 1)\n```\n\n**D. Core Logic Skeleton Code (signature + TODOs only):**\n\n```python\n# parser.py - Main parser class skeleton\n\nclass MarkdownParser:\n    \"\"\"Main markdown parser coordinating block and inline parsing phases.\"\"\"\n    \n    def __init__(self):\n        # TODO 1: Initialize block_parser, inline_parser, html_generator components\n        # TODO 2: Set up shared state like current line number, parsing context\n        pass\n    \n    def parse_to_html(self, markdown_text):\n        \"\"\"\n        Convert markdown text to HTML through two-phase parsing.\n        \n        Args:\n            markdown_text (str): Raw markdown input\n            \n        Returns:\n            str: Generated HTML output\n        \"\"\"\n        # TODO 1: Normalize line endings using normalize_line_endings()\n        # TODO 2: Split into lines with split_into_lines() \n        # TODO 3: Pass lines to block parser to build initial AST\n        # TODO 4: Pass block AST to inline parser to process formatting\n        # TODO 5: Pass complete AST to HTML generator for output\n        # TODO 6: Return final HTML string\n        pass\n    \n    def parse_file(self, file_path):\n        \"\"\"Parse markdown file and return HTML.\"\"\"\n        # TODO 1: Open and read file content\n        # TODO 2: Call parse_to_html() with file content\n        # TODO 3: Handle file I/O errors gracefully\n        pass\n```\n\n**E. Language-Specific Hints:**\n\nFor Python implementation:\n- Use `re.compile()` to pre-compile frequently used regex patterns for better performance\n- List comprehensions are excellent for filtering and transforming line collections\n- The `enumerate()` function simplifies line number tracking during parsing\n- Consider using `dataclasses` for AST node definitions to reduce boilerplate\n- The `textwrap.dedent()` function helps with processing indented code blocks\n- Use `isinstance()` checks rather than string comparisons for node type detection\n\n**F. Milestone Checkpoint:**\n\nAfter establishing goals and non-goals, verify your project setup:\n\n**Setup Verification Steps:**\n1. Create the recommended file structure with empty Python files\n2. Copy the complete utility functions into `utils.py`\n3. Run `python -c \"from utils import normalize_line_endings; print('Setup OK')\"` to verify imports work\n4. Create a simple test file `test_samples/basic.md` with a heading and paragraph\n5. Verify you can read the test file and print its content\n\n**Expected Behavior:**\n- All imports should work without errors\n- The utility functions should handle basic text processing correctly\n- You should be able to process line endings and count indentation accurately\n- File I/O should work for reading test markdown samples\n\n**Signs Something Is Wrong:**\n- Import errors suggest file structure problems or missing `__init__.py` files\n- Utility functions failing indicates issues with the starter code setup\n- File reading problems suggest path or permission issues\n\n**What to Check:**\n- Verify Python environment has required standard library modules\n- Ensure all files are in the correct directory structure\n- Check that test sample files use the line ending format your system expects\n- Confirm utility functions produce expected output on sample inputs\n\nThis milestone checkpoint ensures learners have a solid foundation before beginning the actual parsing implementation in subsequent milestones.\n\n\n## High-Level Architecture\n\n> **Milestone(s):** Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation\n\n### The Document Pipeline Mental Model\n\nThink of markdown parsing like a factory assembly line for translating documents. Raw markdown text enters one end, and polished HTML emerges from the other. The key insight is that this transformation happens in distinct phases, each with specialized workers who understand different aspects of the document structure.\n\nImagine you're translating a complex technical document from one language to another. You wouldn't try to translate every word simultaneously while also formatting paragraphs and checking grammar. Instead, you'd first identify the major sections (chapters, headings, paragraphs), then work on the detailed sentence structure within each section, and finally apply the target language's formatting conventions. This is exactly how our **two-phase parsing** approach works.\n\nThe first phase identifies the document's skeleton - the major structural elements like headings, paragraphs, code blocks, and lists. These are **block-level elements** that define the document's overall organization. The second phase focuses on the details within each block - the **inline elements** like bold text, links, and inline code that provide formatting and semantic meaning within the content.\n\nThis separation is crucial because block and inline elements follow different parsing rules. A heading can contain italic text, but italic text cannot contain a heading. By parsing blocks first and then processing inline content within those blocks, we maintain proper precedence and avoid complex interdependencies.\n\n![System Component Architecture](./diagrams/system-components.svg)\n\n### Component Overview\n\nThe markdown renderer follows a **four-component architecture** where each component has a clearly defined responsibility in the document transformation pipeline. This separation of concerns makes the system easier to understand, test, and extend while ensuring that each component can focus on its specific parsing challenges.\n\n#### Input Preprocessor and Lexer\n\nThe **Input Preprocessor** serves as the system's entry point, handling the messy realities of text input before any parsing begins. Think of it as a document sanitizer that ensures all components downstream can make consistent assumptions about the input format.\n\n| Responsibility | Description | Input | Output |\n|---|---|---|---|\n| Line Ending Normalization | Convert Windows CRLF and classic Mac CR to Unix LF | Raw markdown text | Normalized text |\n| Line Splitting | Break text into individual lines while preserving line numbers | Normalized text | List of lines with metadata |\n| Blank Line Detection | Identify whitespace-only lines for block boundary detection | Individual lines | Boolean classification |\n| Indentation Analysis | Measure leading whitespace for list and code block processing | Individual lines | Indentation levels |\n\nThe preprocessor doesn't make parsing decisions - it simply ensures that subsequent components receive clean, predictable input. This includes normalizing different line ending conventions, preserving empty lines that serve as block separators, and calculating indentation levels that will be crucial for list parsing.\n\n> **Key Design Insight**: The preprocessor eliminates platform-specific text handling concerns from the core parsing logic. Without this component, every parser would need to handle Windows CRLF, Unix LF, and classic Mac CR line endings, significantly complicating the parsing state machines.\n\n#### Block Parser\n\nThe **Block Parser** is responsible for identifying and parsing the document's structural skeleton. It processes the input line-by-line, maintaining state to recognize multi-line constructs and building the first level of the document's **Abstract Syntax Tree**.\n\n| Block Type | Recognition Pattern | State Requirements | Output Node Type |\n|---|---|---|---|\n| ATX Headings | Lines starting with 1-6 `#` characters | Single-line, immediate recognition | `BlockNode` with `block_type=\"heading\"` |\n| Paragraphs | Consecutive non-blank lines not matching other patterns | Multi-line accumulation state | `BlockNode` with `block_type=\"paragraph\"` |\n| Fenced Code Blocks | Lines between triple backticks | Start/end delimiter matching | `BlockNode` with `block_type=\"code_block\"` |\n| Indented Code Blocks | Lines indented by 4+ spaces | Consecutive indentation tracking | `BlockNode` with `block_type=\"code_block\"` |\n| Blockquotes | Lines starting with `>` character | Nested depth tracking | `BlockNode` with `block_type=\"blockquote\"` |\n| Horizontal Rules | Lines with 3+ dashes or asterisks | Pattern matching with spacing rules | `BlockNode` with `block_type=\"horizontal_rule\"` |\n\nThe block parser operates as a **state machine** where each line can potentially trigger a state transition. For example, when processing a paragraph, encountering a blank line transitions to a \"seeking next block\" state, while encountering an ATX heading immediately closes the paragraph and starts processing the heading.\n\n> **Architecture Decision: Line-by-Line State Machine vs Regex Chunking**\n> - **Context**: Block parsing requires handling multi-line constructs like paragraphs and code blocks\n> - **Options Considered**: \n>   1. Process entire input with complex regex patterns\n>   2. Line-by-line state machine\n>   3. Recursive descent parser\n> - **Decision**: Line-by-line state machine\n> - **Rationale**: Regex becomes unwieldy for nested constructs and lookahead requirements. Recursive descent adds complexity for what is fundamentally a sequential process. State machine provides clear separation of concerns and easier debugging.\n> - **Consequences**: Enables incremental processing, simplifies testing of individual block types, but requires careful state transition management.\n\n#### Inline Parser\n\nThe **Inline Parser** processes the text content within each block element, identifying and parsing formatting elements like emphasis, links, images, and inline code. This component operates on a fundamentally different principle than the block parser - it must handle **nested and overlapping constructs** within a single line or text span.\n\n| Inline Type | Delimiter Pattern | Nesting Rules | Special Handling |\n|---|---|---|---|\n| Strong (Bold) | `**text**` or `__text__` | Can contain emphasis | Cannot cross word boundaries for underscores |\n| Emphasis (Italic) | `*text*` or `_text_` | Can be nested in strong | Cannot cross word boundaries for underscores |\n| Inline Code | `code` | Cannot contain other formatting | Preserves literal content, including backticks |\n| Links | `[text](url)` | Text portion can contain formatting | URL portion is literal |\n| Images | `![alt](url)` | Alt text can contain formatting | URL portion is literal |\n| Autolinks | `<url>` or `<email>` | No nested formatting | Automatic protocol detection |\n\nThe inline parser uses a **delimiter matching algorithm** that maintains a stack of opening delimiters and matches them with closing delimiters according to CommonMark precedence rules. This is significantly more complex than block parsing because inline elements can be nested (bold text containing italic text) and can have complex interaction rules.\n\n> **Key Design Insight**: Inline parsing cannot be solved with simple regex patterns because of the nesting requirements and context-dependent rules. For example, underscores in the middle of words should not trigger emphasis, and unmatched delimiters should be treated as literal text.\n\n#### HTML Generator\n\nThe **HTML Generator** traverses the completed AST and produces valid HTML output. This component is responsible for **character escaping**, **proper tag nesting**, and **output formatting**. Think of it as the final assembly worker who takes the structured document representation and produces the final deliverable.\n\n| Generation Phase | Input | Process | Output |\n|---|---|---|---|\n| Tree Traversal | Complete AST | Depth-first traversal of nodes | Sequential processing order |\n| Character Escaping | Text content | Convert `&`, `<`, `>`, `\"` to HTML entities | Escaped text safe for HTML |\n| Tag Generation | AST nodes with types | Map node types to HTML elements | Opening and closing tags |\n| Attribute Handling | Node attributes (links, images, headings) | Generate HTML attributes | `href`, `src`, `alt`, `id` attributes |\n| Pretty Printing | Generated HTML | Add indentation and line breaks | Human-readable formatted output |\n\nThe generator must handle **self-closing tags** correctly (like `<hr>` for horizontal rules), ensure proper **tag nesting** (no unclosed or incorrectly ordered tags), and provide **extensibility** for custom renderers that might want to generate different output formats.\n\n> **Architecture Decision: Early vs Late Character Escaping**\n> - **Context**: HTML special characters must be escaped, but timing affects complexity\n> - **Options Considered**:\n>   1. Escape during initial input processing\n>   2. Escape during inline parsing\n>   3. Escape during HTML generation\n> - **Decision**: Escape during HTML generation\n> - **Rationale**: Early escaping interferes with parsing logic that needs to recognize literal characters. Late escaping ensures we only escape content that will be output as text, not structural markup.\n> - **Consequences**: Cleaner parsing logic, but requires careful tracking of what content needs escaping vs what is already HTML.\n\n#### Component Interaction and Data Flow\n\nThe components form a **pipeline architecture** where data flows unidirectionally from input to output, with each component transforming the data into a more structured representation.\n\n| Data Flow Stage | Data Format | Component | Key Transformations |\n|---|---|---|---|\n| Raw Input | String with mixed line endings | Input Preprocessor | Normalization and line splitting |\n| Normalized Lines | List of strings with metadata | Block Parser | Structure identification and AST building |\n| Block AST | Tree of `BlockNode` objects | Inline Parser | Text content parsing and inline AST integration |\n| Complete AST | Mixed tree of `BlockNode` and `InlineNode` objects | HTML Generator | HTML element generation and formatting |\n| HTML Output | Valid HTML string | External consumer | Ready for browser or file output |\n\nEach component maintains **clear interface boundaries** with well-defined input and output contracts. The block parser doesn't need to understand inline formatting, and the HTML generator doesn't need to understand markdown syntax. This separation enables independent testing, development, and potential replacement of individual components.\n\n> **Critical Design Principle**: Each component operates on a higher level of abstraction than its predecessor. The preprocessor works with raw text, the block parser works with lines and structure, the inline parser works with text spans and formatting, and the HTML generator works with semantic document elements.\n\n### Recommended File Structure\n\nThe file organization follows the principle of **component isolation** with clear separation between parsing logic, data structures, and utilities. This structure supports incremental development where each milestone can be implemented and tested independently.\n\n```\nmarkdown_renderer/\n├── __init__.py                    # Main package interface\n├── main.py                        # CLI entry point and file processing\n├── parser.py                      # MarkdownParser class and main API\n├── data_model.py                  # AST node definitions and data structures\n├── preprocessor.py                # Input normalization and line processing\n├── block_parser.py                # Block-level element parsing\n├── inline_parser.py               # Inline formatting parsing\n├── list_parser.py                 # Specialized list parsing logic\n├── html_generator.py              # AST to HTML conversion\n├── utils.py                       # Shared utilities and constants\n├── tests/                         # Test suite organization\n│   ├── __init__.py\n│   ├── test_preprocessor.py       # Input processing tests\n│   ├── test_block_parser.py       # Block parsing tests\n│   ├── test_inline_parser.py      # Inline parsing tests\n│   ├── test_list_parser.py        # List parsing tests\n│   ├── test_html_generator.py     # HTML generation tests\n│   ├── test_integration.py        # End-to-end pipeline tests\n│   └── fixtures/                  # Test data files\n│       ├── markdown_samples/      # Sample markdown inputs\n│       └── expected_html/         # Expected HTML outputs\n└── examples/                      # Usage examples and demos\n    ├── basic_usage.py             # Simple API demonstration\n    ├── custom_renderer.py         # Plugin interface example\n    └── sample_documents/          # Example markdown files\n```\n\nThis structure reflects several important architectural decisions:\n\n**Separation of Parsing Phases**: Each major parsing component gets its own module (`block_parser.py`, `inline_parser.py`, `list_parser.py`). This makes it easy to work on one parsing phase without being distracted by others and enables focused unit testing.\n\n**Centralized Data Model**: All AST node definitions live in `data_model.py`. This prevents circular imports and provides a single location for understanding the system's data structures. Any component that needs to create or manipulate AST nodes imports from this central module.\n\n**Utilities and Constants**: Shared functionality like HTML escaping, indentation detection, and debug printing is centralized in `utils.py`. This prevents code duplication and ensures consistent behavior across components.\n\n**Comprehensive Testing**: The test structure mirrors the module structure, with dedicated test files for each component plus integration tests that verify the complete pipeline. Fixture files separate test data from test logic, making tests easier to read and maintain.\n\n> **Implementation Strategy**: Start by implementing `data_model.py` with basic AST node structures, then implement `preprocessor.py` and `utils.py` to establish the foundation. This enables incremental development where each subsequent milestone can build on solid, tested infrastructure.\n\nThe file organization also supports the **plugin architecture** mentioned in future extensions. Custom renderers can import the AST data model and implement alternative HTML generators without modifying the core parsing logic.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option | Rationale |\n|---|---|---|---|\n| Text Processing | Built-in `str` methods and `re` module | `regex` library with advanced features | Standard library sufficient for CommonMark compliance |\n| Data Structures | Built-in `list` and `dict` | `collections.deque` for parser stacks | Standard containers handle AST and delimiter stacks adequately |\n| File I/O | Built-in `open()` and text mode | `pathlib` for path handling | Simple file reading adequate, `pathlib` improves cross-platform compatibility |\n| Testing Framework | Built-in `unittest` | `pytest` with fixtures | `pytest` provides cleaner test organization and better fixture support |\n| CLI Interface | `argparse` for command-line parsing | `click` for advanced CLI features | `argparse` sufficient for basic file processing interface |\n| Output Formatting | String concatenation and `join()` | Template engines like `jinja2` | String operations adequate for HTML generation, templates add complexity |\n\nFor this beginner-level project, the **simple options** are strongly recommended. The standard library provides all necessary functionality, and additional dependencies would complicate the learning experience without providing significant benefits.\n\n#### Core Infrastructure Starter Code\n\n**File: `utils.py` - Complete utility functions**\n\n```python\n\"\"\"\nShared utilities and constants for markdown parsing.\nProvides text processing utilities, HTML escaping, and debugging helpers.\n\"\"\"\n\nimport re\nfrom typing import List, Dict, Any\n\n# HTML character escaping table\nHTML_ESCAPE_TABLE = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n}\n\ndef normalize_line_endings(text: str) -> str:\n    \"\"\"Convert all line endings to Unix format (LF only).\"\"\"\n    # Replace Windows CRLF first, then Mac CR\n    return text.replace('\\r\\n', '\\n').replace('\\r', '\\n')\n\ndef split_into_lines(text: str) -> List[str]:\n    \"\"\"Split text into lines, preserving empty lines.\"\"\"\n    return text.split('\\n')\n\ndef is_blank_line(line: str) -> bool:\n    \"\"\"Check if line contains only whitespace characters.\"\"\"\n    return len(line.strip()) == 0\n\ndef get_indentation_level(line: str) -> int:\n    \"\"\"Count leading spaces in line. Tabs count as 4 spaces.\"\"\"\n    indent = 0\n    for char in line:\n        if char == ' ':\n            indent += 1\n        elif char == '\\t':\n            indent += 4\n        else:\n            break\n    return indent\n\ndef escape_html(text: str) -> str:\n    \"\"\"Escape HTML special characters in text content.\"\"\"\n    result = text\n    for char, entity in HTML_ESCAPE_TABLE.items():\n        result = result.replace(char, entity)\n    return result\n\ndef debug_print_ast(node: Any, indent: int = 0) -> None:\n    \"\"\"Print AST structure for debugging. Recursively shows node hierarchy.\"\"\"\n    prefix = \"  \" * indent\n    node_info = f\"{node.node_type}\"\n    if hasattr(node, 'block_type'):\n        node_info += f\" ({node.block_type})\"\n    elif hasattr(node, 'inline_type'):\n        node_info += f\" ({node.inline_type})\"\n    \n    if hasattr(node, 'text_content') and node.text_content:\n        # Truncate long text for readability\n        text = node.text_content[:30] + \"...\" if len(node.text_content) > 30 else node.text_content\n        node_info += f' \"{text}\"'\n    \n    print(f\"{prefix}{node_info}\")\n    \n    # Recursively print children\n    if hasattr(node, 'children') and node.children:\n        for child in node.children:\n            debug_print_ast(child, indent + 1)\n```\n\n**File: `data_model.py` - Complete AST node definitions**\n\n```python\n\"\"\"\nAbstract Syntax Tree node definitions for markdown document structure.\nDefines the core data model used throughout the parsing pipeline.\n\"\"\"\n\nfrom typing import List, Optional, Dict, Any, Union\nfrom enum import Enum\n\nclass NodeType(Enum):\n    \"\"\"Enumeration of all AST node types.\"\"\"\n    DOCUMENT = \"document\"\n    BLOCK = \"block\"\n    INLINE = \"inline\"\n    TEXT = \"text\"\n\nclass BlockType(Enum):\n    \"\"\"Enumeration of block-level element types.\"\"\"\n    PARAGRAPH = \"paragraph\"\n    HEADING = \"heading\"\n    CODE_BLOCK = \"code_block\"\n    BLOCKQUOTE = \"blockquote\"\n    HORIZONTAL_RULE = \"horizontal_rule\"\n    LIST = \"list\"\n    LIST_ITEM = \"list_item\"\n\nclass InlineType(Enum):\n    \"\"\"Enumeration of inline element types.\"\"\"\n    STRONG = \"strong\"\n    EMPHASIS = \"emphasis\"\n    CODE = \"code\"\n    LINK = \"link\"\n    IMAGE = \"image\"\n    LINE_BREAK = \"line_break\"\n\nclass ASTNode:\n    \"\"\"Base class for all AST nodes.\"\"\"\n    \n    def __init__(self, node_type: NodeType, line_number: int = 0):\n        self.node_type = node_type\n        self.children: List['ASTNode'] = []\n        self.parent: Optional['ASTNode'] = None\n        self.line_number = line_number\n    \n    def add_child(self, child: 'ASTNode') -> None:\n        \"\"\"Add a child node and set its parent reference.\"\"\"\n        child.parent = self\n        self.children.append(child)\n    \n    def remove_child(self, child: 'ASTNode') -> None:\n        \"\"\"Remove a child node and clear its parent reference.\"\"\"\n        if child in self.children:\n            child.parent = None\n            self.children.remove(child)\n\nclass BlockNode(ASTNode):\n    \"\"\"AST node for block-level elements.\"\"\"\n    \n    def __init__(self, block_type: BlockType, line_number: int = 0):\n        super().__init__(NodeType.BLOCK, line_number)\n        self.block_type = block_type\n        self.inline_content: str = \"\"\n        self.block_attributes: Dict[str, Any] = {}\n    \n    def set_content(self, content: str) -> None:\n        \"\"\"Set the raw text content for this block.\"\"\"\n        self.inline_content = content\n    \n    def set_attribute(self, key: str, value: Any) -> None:\n        \"\"\"Set a block-specific attribute (e.g., heading level, language).\"\"\"\n        self.block_attributes[key] = value\n    \n    def get_attribute(self, key: str, default: Any = None) -> Any:\n        \"\"\"Get a block-specific attribute with optional default.\"\"\"\n        return self.block_attributes.get(key, default)\n\nclass InlineNode(ASTNode):\n    \"\"\"AST node for inline formatting elements.\"\"\"\n    \n    def __init__(self, inline_type: InlineType, line_number: int = 0):\n        super().__init__(NodeType.INLINE, line_number)\n        self.inline_type = inline_type\n        self.text_content: str = \"\"\n        self.formatting_attributes: Dict[str, Any] = {}\n    \n    def set_text(self, text: str) -> None:\n        \"\"\"Set the text content for this inline element.\"\"\"\n        self.text_content = text\n    \n    def set_attribute(self, key: str, value: Any) -> None:\n        \"\"\"Set an inline-specific attribute (e.g., URL, alt text).\"\"\"\n        self.formatting_attributes[key] = value\n    \n    def get_attribute(self, key: str, default: Any = None) -> Any:\n        \"\"\"Get an inline-specific attribute with optional default.\"\"\"\n        return self.formatting_attributes.get(key, default)\n\nclass TextNode(ASTNode):\n    \"\"\"AST node for plain text content.\"\"\"\n    \n    def __init__(self, text: str, line_number: int = 0):\n        super().__init__(NodeType.TEXT, line_number)\n        self.text_content = text\n    \n    def set_text(self, text: str) -> None:\n        \"\"\"Set the text content.\"\"\"\n        self.text_content = text\n```\n\n#### Core Parsing Logic Skeletons\n\n**File: `parser.py` - Main parser class skeleton**\n\n```python\n\"\"\"\nMain MarkdownParser class that coordinates the parsing pipeline.\nThis is the primary public interface for the markdown renderer.\n\"\"\"\n\nfrom typing import Optional\nfrom .data_model import ASTNode, BlockNode, NodeType\nfrom .preprocessor import Preprocessor\nfrom .block_parser import BlockParser  \nfrom .inline_parser import InlineParser\nfrom .html_generator import HTMLGenerator\n\nclass MarkdownParser:\n    \"\"\"Main parser that coordinates the two-phase parsing pipeline.\"\"\"\n    \n    def __init__(self):\n        self.block_parser = BlockParser()\n        self.inline_parser = InlineParser() \n        self.html_generator = HTMLGenerator()\n    \n    def parse_to_html(self, markdown_text: str) -> str:\n        \"\"\"\n        Main parsing entry point. Converts markdown text to HTML.\n        \n        Args:\n            markdown_text: Raw markdown input string\n            \n        Returns:\n            Valid HTML string\n        \"\"\"\n        # TODO 1: Use normalize_line_endings to standardize input\n        # TODO 2: Use split_into_lines to break into line list\n        # TODO 3: Call block_parser.parse(lines) to get block AST\n        # TODO 4: Call inline_parser.parse(block_ast) to add inline elements\n        # TODO 5: Call html_generator.generate(complete_ast) to produce HTML\n        # TODO 6: Return the final HTML string\n        pass\n    \n    def parse_file(self, file_path: str) -> str:\n        \"\"\"\n        Parse markdown from a file path.\n        \n        Args:\n            file_path: Path to markdown file\n            \n        Returns:\n            HTML string\n        \"\"\"\n        # TODO 1: Open and read file content with UTF-8 encoding\n        # TODO 2: Call parse_to_html with file content\n        # TODO 3: Handle FileNotFoundError and UnicodeDecodeError appropriately\n        pass\n```\n\n**File: `preprocessor.py` - Input processing skeleton**\n\n```python\n\"\"\"\nInput preprocessing for markdown text.\nHandles normalization and basic text processing before parsing.\n\"\"\"\n\nfrom typing import List, Tuple\nfrom .utils import normalize_line_endings, split_into_lines, is_blank_line, get_indentation_level\n\nclass LineInfo:\n    \"\"\"Metadata about a single line of input.\"\"\"\n    \n    def __init__(self, content: str, line_number: int, is_blank: bool, indent_level: int):\n        self.content = content\n        self.line_number = line_number\n        self.is_blank = is_blank\n        self.indent_level = indent_level\n        self.stripped_content = content.strip()\n\nclass Preprocessor:\n    \"\"\"Handles input normalization and line-level analysis.\"\"\"\n    \n    def process_input(self, text: str) -> List[LineInfo]:\n        \"\"\"\n        Process raw markdown input into analyzed lines.\n        \n        Args:\n            text: Raw markdown text\n            \n        Returns:\n            List of LineInfo objects with metadata\n        \"\"\"\n        # TODO 1: Call normalize_line_endings on input text\n        # TODO 2: Call split_into_lines to get line list\n        # TODO 3: Create LineInfo object for each line with:\n        #         - content (original line)\n        #         - line_number (1-based)\n        #         - is_blank (use is_blank_line utility)\n        #         - indent_level (use get_indentation_level utility)\n        # TODO 4: Return list of LineInfo objects\n        pass\n```\n\n#### Milestone Checkpoints\n\n**After implementing the basic infrastructure (utils.py, data_model.py, parser.py):**\n\nRun the following verification:\n\n```python\n# Test basic infrastructure\nfrom markdown_renderer.utils import escape_html, normalize_line_endings\nfrom markdown_renderer.data_model import BlockNode, BlockType\n\n# Verify HTML escaping\ntest_text = 'Hello & <world> \"test\"'\nescaped = escape_html(test_text)\nassert escaped == 'Hello &amp; &lt;world&gt; &quot;test&quot;'\n\n# Verify line ending normalization  \ntest_input = \"Line 1\\r\\nLine 2\\rLine 3\\n\"\nnormalized = normalize_line_endings(test_input)\nassert normalized == \"Line 1\\nLine 2\\nLine 3\\n\"\n\n# Verify AST node creation\nheading = BlockNode(BlockType.HEADING)\nheading.set_attribute(\"level\", 1)\nheading.set_content(\"Test Heading\")\nassert heading.get_attribute(\"level\") == 1\nprint(\"✓ Basic infrastructure working correctly\")\n```\n\n**Expected behavior**: All assertions should pass, demonstrating that the utility functions handle text processing correctly and AST nodes can store block-level content and attributes.\n\n**Signs something is wrong**: If escaping doesn't handle all characters, check the `HTML_ESCAPE_TABLE` mapping. If line ending normalization fails, ensure Windows CRLF is processed before Mac CR. If AST node tests fail, verify the parent-child relationship management in `add_child`.\n\n#### Language-Specific Implementation Hints\n\n**Python Text Processing Tips:**\n- Use `str.strip()` for whitespace removal, but remember it removes all whitespace characters including tabs and newlines\n- `str.split('\\n')` preserves empty strings for blank lines, which is essential for block boundary detection\n- Regular expressions with `re.finditer()` provide both match content and position information useful for parsing\n- List comprehensions with conditionals help filter lines: `[line for line in lines if not is_blank_line(line)]`\n\n**AST Manipulation Patterns:**\n- Always set parent references when adding children to enable upward traversal\n- Use `isinstance(node, BlockNode)` for type checking instead of string comparison on `node_type`\n- Consider using `collections.deque` for parser stacks if you need frequent insertion/removal at both ends\n- Store line numbers in nodes during parsing - they're invaluable for error reporting and debugging\n\n**Error Handling Strategy:**\n- Catch `UnicodeDecodeError` when reading files and provide helpful error messages\n- Use `try/except` around file operations but let parsing errors propagate for debugging\n- Consider using `logging` module for debug output rather than print statements\n- Validate AST structure with assertions during development, but remove them for production\n\n> **Development Workflow Tip**: Implement and test each utility function independently before building the parser components. Use `python -m pytest tests/test_utils.py -v` to verify individual functions work correctly before integrating them into the larger parsing pipeline.\n\n\n## Data Model\n\n> **Milestone(s):** Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation\n\n### The Document Tree Mental Model\n\nThink of a markdown document as a family tree where each person (element) knows their role in the family hierarchy. Just as a family tree has generations—grandparents, parents, children—a markdown document has structural levels. The document root is like the family patriarch, containing major sections (headings, paragraphs, lists) as its children, which in turn contain their own children (bold text, links, images within paragraphs).\n\nUnlike a flat text file where everything is just characters in sequence, our parsed representation maintains these relationships explicitly. Each node in the tree knows its parent (the element that contains it), its children (the elements it contains), and its siblings (elements at the same level). This hierarchical structure makes it straightforward to apply consistent formatting rules, validate nesting constraints, and generate properly structured HTML output.\n\nThe key insight is that markdown parsing transforms linear text into a structured tree where semantic relationships are explicit rather than implicit. A paragraph doesn't just contain the text \"This is **bold** text\"—it contains a sequence of child elements: a text node \"This is \", a strong emphasis node containing \"bold\", and another text node \" text\". This explicitness enables precise control over HTML generation and makes complex transformations tractable.\n\n### Abstract Syntax Tree Nodes\n\nThe Abstract Syntax Tree (AST) serves as the central data structure throughout our parsing pipeline. Every element in the markdown document, from the document root down to individual words, is represented as a node in this tree. The AST captures not just the content of each element but its semantic meaning, formatting attributes, and relationship to other elements.\n\n![Abstract Syntax Tree Data Model](./diagrams/ast-data-model.svg)\n\n#### Base AST Node Structure\n\nThe foundation of our AST is the `ASTNode` base type, which provides the common interface and shared properties that all document elements require. Every node in the tree, regardless of its specific type or content, inherits these fundamental characteristics.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `node_type` | `NodeType` | Enum value identifying the general category of this node (DOCUMENT, BLOCK, INLINE, TEXT) |\n| `children` | `List[ASTNode]` | Ordered list of child nodes contained within this element |\n| `parent` | `ASTNode` | Reference to the parent node containing this element (None for document root) |\n| `line_number` | `int` | Source line number where this element begins in the original markdown text |\n\nThe `node_type` field enables type-safe traversal and processing—when the HTML generator encounters a node, it can immediately dispatch to the appropriate rendering logic without expensive type checking. The `children` list maintains document order, which is crucial for elements like paragraphs where the sequence of text and formatting matters. The `parent` reference enables bidirectional tree navigation, supporting operations like \"find the containing list to determine nesting level\" or \"check if this emphasis is inside a link\".\n\nLine number tracking serves multiple purposes beyond debugging. During error reporting, we can provide precise source locations for malformed elements. During incremental parsing (a future extension), we can map document edits back to specific AST subtrees for efficient re-parsing.\n\n#### Block-Level Node Structure\n\nBlock-level elements represent the document's structural backbone—paragraphs, headings, code blocks, lists, and other elements that establish the document's major sections. These elements typically span multiple lines and cannot appear inside other block elements (with specific exceptions like list items containing paragraphs).\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `block_type` | `BlockType` | Specific type of block element (PARAGRAPH, HEADING, CODE_BLOCK, etc.) |\n| `inline_content` | `str` | Raw text content before inline parsing (e.g., \"This is **bold** text\") |\n| `block_attributes` | `Dict[str, Any]` | Element-specific metadata (heading level, code language, list type) |\n\nThe `BlockNode` extends `ASTNode` with block-specific functionality. The `inline_content` field stores the raw text before inline parsing occurs—this supports our two-phase parsing approach where we first identify block structure, then parse inline formatting within each block. For a heading, this might be \"# Chapter **One**: Introduction\" before we parse the emphasis within the heading text.\n\nThe `block_attributes` dictionary provides flexibility for element-specific properties without requiring separate node types for every variation. A heading node stores its level (1-6) as `{\"level\": 2}`, while a code block stores its language hint as `{\"language\": \"python\", \"is_fenced\": true}`. This approach maintains type safety while avoiding an explosion of specialized node classes.\n\n> **Key Design Insight**: Separating block structure from inline content enables parallel processing in future extensions—we could parse multiple blocks' inline content concurrently once the document structure is established.\n\n#### Inline Element Node Structure\n\nInline elements provide formatting and semantic markup within block-level containers. Unlike block elements, inline elements can nest arbitrarily—emphasis can contain links, links can contain code spans (with restrictions), and complex combinations create rich text formatting.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `inline_type` | `InlineType` | Specific type of inline element (STRONG, EMPHASIS, CODE, LINK, IMAGE, LINE_BREAK) |\n| `text_content` | `str` | The actual text content for this inline element |\n| `formatting_attributes` | `Dict[str, Any]` | Element-specific properties (URL for links, alt text for images) |\n\nThe `InlineNode` specializes `ASTNode` for inline formatting elements. The `text_content` field holds the processed text—for emphasis, this is the text between the markers (\"bold\" from \"**bold**\"). For links, this is the link text, while the URL is stored in `formatting_attributes` as `{\"url\": \"https://example.com\", \"title\": \"Optional title\"}`.\n\nThis separation between content and attributes proves crucial during HTML generation. The generator can apply consistent escaping to all text content while handling attributes according to their specific requirements (URLs need different escaping than alt text).\n\n#### Text Node Structure\n\nText nodes represent the leaves of our AST—the actual words, punctuation, and whitespace that form the document's readable content. These nodes contain no child elements and require minimal metadata.\n\nText nodes inherit the base `ASTNode` structure but typically have empty `children` lists and use the `text_content` for their actual content. While we could define a specialized `TextNode` type, the base `ASTNode` with `node_type = TEXT` provides sufficient functionality while maintaining interface consistency.\n\n#### Node Type Enumerations\n\nThe type system uses enumerations to provide compile-time safety and clear semantic boundaries between different element categories.\n\n**NodeType Enumeration:**\n\n| Value | Purpose | Examples |\n|-------|---------|----------|\n| `DOCUMENT` | Root container for entire document | Document root node |\n| `BLOCK` | Block-level structural elements | Paragraphs, headings, code blocks |\n| `INLINE` | Inline formatting elements | Emphasis, links, inline code |\n| `TEXT` | Leaf nodes containing actual text | Word sequences, punctuation |\n\n**BlockType Enumeration:**\n\n| Value | Purpose | Attributes Used |\n|-------|---------|----------------|\n| `PARAGRAPH` | Regular paragraph text | None |\n| `HEADING` | Section headings | `level` (1-6) |\n| `CODE_BLOCK` | Preformatted code | `language`, `is_fenced` |\n| `BLOCKQUOTE` | Quoted text sections | `nesting_level` |\n| `HORIZONTAL_RULE` | Section dividers | None |\n| `LIST` | Ordered/unordered lists | `list_type` (ordered/unordered), `start_number` |\n| `LIST_ITEM` | Individual list items | `marker_type`, `is_tight` |\n\n**InlineType Enumeration:**\n\n| Value | Purpose | Attributes Used |\n|-------|---------|----------------|\n| `STRONG` | Bold/strong emphasis | None |\n| `EMPHASIS` | Italic/emphasis | None |\n| `CODE` | Inline code spans | None |\n| `LINK` | Hyperlinks | `url`, `title` |\n| `IMAGE` | Embedded images | `url`, `alt_text`, `title` |\n| `LINE_BREAK` | Hard line breaks | `break_type` (soft/hard) |\n\n### Parser Context and State\n\nThe parsing process requires sophisticated state management to handle markdown's context-sensitive rules and maintain consistency across the two-phase parsing pipeline. Our state structures capture both the current parsing context and the accumulated results as parsing progresses.\n\n#### Primary Parser State\n\nThe main parser coordinates the overall parsing process and maintains references to specialized parsers for different document elements. This centralized state enables consistent behavior and shared utility functions across parsing phases.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `block_parser` | `BlockParser` | Specialized parser for block-level elements |\n| `inline_parser` | `InlineParser` | Specialized parser for inline formatting elements |\n| `html_generator` | `HTMLGenerator` | Component responsible for AST-to-HTML conversion |\n\nThe `MarkdownParser` serves as the facade for the entire parsing system, orchestrating the flow from raw markdown text through block parsing, inline parsing, and final HTML generation. This design enables clean separation of concerns while providing a simple external interface.\n\n#### Line Processing Context\n\nBefore any structural parsing begins, the raw markdown text undergoes preprocessing to normalize line endings, analyze indentation, and identify blank lines. The `LineInfo` structure captures this analysis for each source line.\n\n| Field | Type | Description |\n|-------|------|-------------|\n| `content` | `str` | The line's text content with normalized whitespace handling |\n| `line_number` | `int` | One-based line number in the original source document |\n| `is_blank` | `bool` | True if the line contains only whitespace characters |\n| `indent_level` | `int` | Number of leading spaces (tabs converted to spaces) |\n\nThe preprocessing phase transforms raw input into a list of `LineInfo` objects that subsequent parsing phases consume. This preprocessing handles cross-platform compatibility (normalizing Windows/Mac line endings), establishes consistent indentation measurement, and pre-identifies blank lines that serve as block separators.\n\nThe `indent_level` calculation converts tabs to spaces using a configurable tab width (typically 4 spaces) and handles mixed indentation consistently. This preprocessing eliminates platform-specific edge cases from the core parsing logic.\n\n#### Block Parser State\n\nDuring block-level parsing, the parser maintains state about the current parsing context, including nesting levels for elements like blockquotes and lists, and accumulated content for multi-line elements like paragraphs.\n\nBlock parser state includes several key components that track the parsing progress and accumulated results. The parser maintains a stack of open block elements to handle nested structures like blockquotes containing lists. It tracks the current line position within the input and maintains buffers for accumulating multi-line content.\n\nThe block parser uses a state machine approach where each line can trigger transitions between parsing modes. When processing a paragraph, each subsequent non-blank line accumulates into the paragraph content until a blank line or new block element triggers paragraph closure and inline parsing of the accumulated content.\n\nFor list processing, the block parser maintains additional state tracking current list nesting levels, list types at each level, and tight versus loose list formatting. This state enables proper handling of complex nested list structures while maintaining CommonMark compliance.\n\n#### Inline Parser State\n\nInline parsing requires sophisticated state management to handle nested elements and delimiter matching. The inline parser maintains a delimiter stack to track opening markers (asterisks, underscores, backticks) and match them with corresponding closing markers according to CommonMark precedence rules.\n\nThe delimiter stack tracks not just the marker characters but their positions, surrounding context, and nesting relationships. When processing text like \"**bold *italic* text**\", the parser must correctly identify that the asterisks for italic are nested within the asterisks for bold, requiring careful stack management.\n\nThe inline parser also maintains context about whether it's currently inside certain elements that restrict further nesting. For example, code spans cannot contain other inline formatting, so the parser suppresses emphasis processing while inside backtick-delimited code.\n\nLink parsing requires special state management because link text can contain other inline formatting, but the URL portion cannot. The parser tracks whether it's currently inside link text versus link URLs and adjusts its behavior accordingly.\n\n> **Architecture Decision: Stateful vs Stateless Parsing**\n> - **Context**: Choose between maintaining parser state versus pure functional parsing\n> - **Options Considered**:\n>   - Stateful parsers with mutable context objects\n>   - Pure functional parsers passing immutable state\n>   - Hybrid approach with immutable state but mutable result accumulation\n> - **Decision**: Stateful parsers with carefully controlled mutable state\n> - **Rationale**: Markdown's context-sensitive rules (especially for lists and emphasis) create complex state dependencies that are clearer to express with mutable state. Functional approaches would require threading complex state through every parsing function.\n> - **Consequences**: Enables more readable parsing logic and better performance, but requires careful state management to avoid bugs from unexpected mutations.\n\n### AST Construction and Manipulation\n\nThe AST provides a comprehensive interface for constructing and manipulating the document tree during parsing. These operations maintain tree invariants and provide safe access to the hierarchical structure.\n\n#### Node Construction Interface\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `add_child` | `child: ASTNode` | `None` | Appends child node and sets its parent reference |\n| `set_content` | `content: str` | `None` | Sets the text content for leaf nodes |\n| `set_attribute` | `key: str, value: Any` | `None` | Stores element-specific attribute |\n| `get_attribute` | `key: str, default: Any` | `Any` | Retrieves attribute value or default |\n\nThe `add_child` method maintains bidirectional parent-child relationships automatically. When a child is added to a parent, the child's parent reference is updated, and if the child was previously attached to a different parent, it's removed from the old parent's children list. This ensures tree consistency without manual reference management.\n\nThe attribute methods provide type-safe access to element-specific properties. Rather than exposing the attribute dictionary directly, these methods enable validation and default value handling. For example, `get_attribute(\"level\", 1)` retrieves a heading's level with a sensible default.\n\n#### Tree Traversal Interface\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `depth_first_walk` | `visitor: function` | `None` | Visits all nodes in depth-first order |\n| `find_nodes_by_type` | `node_type: NodeType` | `List[ASTNode]` | Returns all descendant nodes of specified type |\n| `get_text_content` | None | `str` | Returns concatenated text from all descendant text nodes |\n\nTree traversal methods support common operations needed during HTML generation and analysis. The `depth_first_walk` method accepts a visitor function that's called for each node, enabling custom processing without exposing tree structure details.\n\nThe `get_text_content` method provides a convenient way to extract all text from a subtree, useful for generating alt text, computing heading anchor text, or extracting link text for processing.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Circular Parent References**\nWhen manually constructing AST nodes, developers sometimes create circular references by setting parent pointers incorrectly. This leads to infinite loops during tree traversal. Always use the `add_child` method rather than setting parent/children references manually—it maintains consistency automatically.\n\n⚠️ **Pitfall: Modifying Children During Traversal**\nModifying a node's children list while iterating over it (for example, during tree transformation) can skip nodes or cause index errors. Create a copy of the children list before iteration, or use reverse iteration when removing nodes.\n\n⚠️ **Pitfall: Inconsistent Node Types**\nSetting a node's `node_type` to `BLOCK` but using `InlineType` values in type-specific fields creates confusion during processing. The type hierarchy must be consistent—`BlockNode` instances should only use `BlockType` values, and the base `node_type` should match the specialized type field.\n\n⚠️ **Pitfall: Missing Line Number Tracking**\nFailing to set line numbers during parsing makes debugging extremely difficult. Users report \"the heading is malformed\" but without line numbers, finding the problem in large documents becomes painful. Always propagate line numbers from `LineInfo` to AST nodes.\n\n⚠️ **Pitfall: Deep Copying Node References**\nWhen cloning or serializing AST nodes, naive deep copying creates duplicate parent/child references that break tree structure. Implement custom cloning that reconstructs relationships rather than copying references directly.\n\n### Implementation Guidance\n\nThe AST implementation requires careful attention to memory management, type safety, and tree consistency. The following guidance provides practical approaches for implementing the data model in Python.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Node Classes | Python dataclasses with inheritance | Custom classes with `__slots__` for memory efficiency |\n| Type Safety | Python enums for node types | Python typing with Union types and type guards |\n| Tree Operations | Recursive methods with explicit stack management | Generator-based traversal to avoid stack overflow |\n| Attribute Storage | Simple dictionaries | Typed attribute classes for validation |\n\n#### Recommended File Structure\n\n```\nmarkdown_renderer/\n  ast/\n    __init__.py              ← Export public AST interface\n    nodes.py                 ← Core node class definitions\n    traversal.py             ← Tree traversal utilities\n    builder.py               ← High-level AST construction helpers\n  parser/\n    context.py               ← Parser state and context classes\n    line_info.py             ← Line preprocessing utilities\n```\n\nThis structure separates AST data structures from parsing logic while keeping related functionality grouped. The `ast` package can be imported independently for applications that work with pre-built trees.\n\n#### Infrastructure Starter Code\n\n**Complete LineInfo Processing (`parser/line_info.py`):**\n\n```python\nfrom dataclasses import dataclass\nfrom typing import List\nimport re\n\n@dataclass\nclass LineInfo:\n    content: str\n    line_number: int\n    is_blank: bool\n    indent_level: int\n\nclass Preprocessor:\n    TAB_WIDTH = 4\n    \n    def normalize_line_endings(self, text: str) -> str:\n        \"\"\"Convert all line endings to Unix format (\\n).\"\"\"\n        return text.replace('\\r\\n', '\\n').replace('\\r', '\\n')\n    \n    def split_into_lines(self, text: str) -> List[str]:\n        \"\"\"Split text into lines, preserving empty lines.\"\"\"\n        return text.split('\\n')\n    \n    def is_blank_line(self, line: str) -> bool:\n        \"\"\"Check if line contains only whitespace.\"\"\"\n        return len(line.strip()) == 0\n    \n    def get_indentation_level(self, line: str) -> int:\n        \"\"\"Count leading spaces, converting tabs to spaces.\"\"\"\n        indent = 0\n        for char in line:\n            if char == ' ':\n                indent += 1\n            elif char == '\\t':\n                indent += self.TAB_WIDTH\n            else:\n                break\n        return indent\n    \n    def process_input(self, text: str) -> List[LineInfo]:\n        \"\"\"Convert raw markdown text into analyzed line information.\"\"\"\n        normalized = self.normalize_line_endings(text)\n        lines = self.split_into_lines(normalized)\n        \n        line_infos = []\n        for i, line in enumerate(lines):\n            line_info = LineInfo(\n                content=line,\n                line_number=i + 1,\n                is_blank=self.is_blank_line(line),\n                indent_level=self.get_indentation_level(line)\n            )\n            line_infos.append(line_info)\n        \n        return line_infos\n```\n\n**HTML Escaping Utilities (`ast/nodes.py`):**\n\n```python\nfrom typing import Dict\n\n# HTML character escaping table for safe output generation\nHTML_ESCAPE_TABLE = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;'\n}\n\ndef escape_html(text: str) -> str:\n    \"\"\"Escape HTML special characters to prevent XSS and ensure valid output.\"\"\"\n    for char, entity in HTML_ESCAPE_TABLE.items():\n        text = text.replace(char, entity)\n    return text\n```\n\n#### Core Logic Skeleton Code\n\n**Base AST Node Implementation (`ast/nodes.py`):**\n\n```python\nfrom enum import Enum\nfrom typing import List, Optional, Any, Dict\nfrom dataclasses import dataclass, field\n\nclass NodeType(Enum):\n    DOCUMENT = \"document\"\n    BLOCK = \"block\" \n    INLINE = \"inline\"\n    TEXT = \"text\"\n\nclass BlockType(Enum):\n    PARAGRAPH = \"paragraph\"\n    HEADING = \"heading\"\n    CODE_BLOCK = \"code_block\"\n    BLOCKQUOTE = \"blockquote\"\n    HORIZONTAL_RULE = \"horizontal_rule\"\n    LIST = \"list\"\n    LIST_ITEM = \"list_item\"\n\nclass InlineType(Enum):\n    STRONG = \"strong\"\n    EMPHASIS = \"emphasis\"\n    CODE = \"code\"\n    LINK = \"link\"\n    IMAGE = \"image\"\n    LINE_BREAK = \"line_break\"\n\n@dataclass\nclass ASTNode:\n    node_type: NodeType\n    children: List['ASTNode'] = field(default_factory=list)\n    parent: Optional['ASTNode'] = None\n    line_number: int = 0\n    \n    def add_child(self, child: 'ASTNode') -> None:\n        \"\"\"Add child node and maintain bidirectional parent-child relationship.\"\"\"\n        # TODO 1: Remove child from its current parent if it has one\n        # TODO 2: Add child to this node's children list\n        # TODO 3: Set child's parent reference to this node\n        # Hint: Check if child.parent exists before removing from old parent\n        pass\n    \n    def set_content(self, content: str) -> None:\n        \"\"\"Set text content for leaf nodes.\"\"\"\n        # TODO 1: Store content in appropriate field based on node type\n        # TODO 2: For text nodes, content goes directly in text field\n        # TODO 3: For block nodes, content goes in inline_content for later inline parsing\n        # Hint: This method should behave differently for different node types\n        pass\n    \n    def set_attribute(self, key: str, value: Any) -> None:\n        \"\"\"Set element-specific attribute.\"\"\"\n        # TODO 1: Ensure attributes dictionary exists\n        # TODO 2: Store key-value pair in appropriate attributes field\n        # TODO 3: Handle validation for known attribute keys if desired\n        pass\n    \n    def get_attribute(self, key: str, default: Any = None) -> Any:\n        \"\"\"Get element-specific attribute with optional default.\"\"\"\n        # TODO 1: Check if attributes dictionary exists\n        # TODO 2: Return attribute value if key exists\n        # TODO 3: Return default value if key doesn't exist\n        pass\n\n@dataclass  \nclass BlockNode(ASTNode):\n    block_type: BlockType = BlockType.PARAGRAPH\n    inline_content: str = \"\"\n    block_attributes: Dict[str, Any] = field(default_factory=dict)\n    \n    def __post_init__(self):\n        # Ensure node_type is consistent with being a block node\n        self.node_type = NodeType.BLOCK\n\n@dataclass\nclass InlineNode(ASTNode):\n    inline_type: InlineType = InlineType.EMPHASIS\n    text_content: str = \"\"\n    formatting_attributes: Dict[str, Any] = field(default_factory=dict)\n    \n    def __post_init__(self):\n        # Ensure node_type is consistent with being an inline node  \n        self.node_type = NodeType.INLINE\n```\n\n**AST Traversal Utilities (`ast/traversal.py`):**\n\n```python\nfrom typing import Callable, List\nfrom .nodes import ASTNode, NodeType\n\ndef debug_print_ast(node: ASTNode, indent: int = 0) -> None:\n    \"\"\"Print AST structure for debugging purposes.\"\"\"\n    # TODO 1: Print current node with indentation showing tree depth\n    # TODO 2: Include node type, line number, and key attributes\n    # TODO 3: Recursively print all child nodes with increased indentation\n    # TODO 4: For text nodes, show truncated content\n    # TODO 5: For block/inline nodes, show their specific type\n    # Hint: Use \" \" * indent for indentation, truncate long content\n    pass\n\ndef depth_first_walk(node: ASTNode, visitor: Callable[[ASTNode], None]) -> None:\n    \"\"\"Visit all nodes in depth-first order.\"\"\"\n    # TODO 1: Call visitor function on current node\n    # TODO 2: Recursively walk all child nodes\n    # TODO 3: Handle any exceptions from visitor gracefully\n    # Hint: Visit parent before children for depth-first pre-order\n    pass\n\ndef find_nodes_by_type(root: ASTNode, target_type: NodeType) -> List[ASTNode]:\n    \"\"\"Find all descendant nodes of specified type.\"\"\"\n    results = []\n    \n    def collector(node: ASTNode) -> None:\n        # TODO 1: Check if current node matches target_type\n        # TODO 2: Add matching nodes to results list\n        pass\n    \n    # TODO 3: Use depth_first_walk with collector function\n    # TODO 4: Return accumulated results\n    return results\n\ndef get_text_content(node: ASTNode) -> str:\n    \"\"\"Extract all text content from node and descendants.\"\"\"\n    text_parts = []\n    \n    def text_collector(node: ASTNode) -> None:\n        # TODO 1: If node is text type, add its content to text_parts\n        # TODO 2: For other node types, extract text from appropriate fields\n        # TODO 3: Handle inline nodes with text_content field\n        # TODO 4: Handle block nodes with inline_content field\n        pass\n    \n    # TODO 5: Walk tree collecting text\n    # TODO 6: Join all text parts and return\n    return \"\"\n```\n\n#### Language-Specific Implementation Notes\n\n**Memory Efficiency in Python:**\n- Use `__slots__` in node classes if memory usage becomes an issue with large documents\n- Consider `weakref` for parent references to avoid circular reference memory leaks\n- Use generators for tree traversal to avoid building large intermediate lists\n\n**Type Safety:**\n- Use `typing.Union` to create precise type hints for methods that accept multiple node types  \n- Consider using `typing.Protocol` to define interfaces rather than concrete inheritance\n- Use `isinstance()` checks with enum values for type-safe node processing\n\n**Performance Considerations:**\n- Cache frequently-accessed attributes like text content extraction\n- Use iterative traversal instead of recursion for very deep document trees\n- Consider lazy evaluation for expensive operations like full-text search\n\n#### Milestone Checkpoint\n\nAfter implementing the AST data model, verify functionality with these tests:\n\n1. **Node Construction Test**: Create nodes of each type and verify all fields are properly initialized\n2. **Parent-Child Relationship Test**: Add children to parents and verify bidirectional references\n3. **Tree Traversal Test**: Build a small tree and verify depth-first traversal visits nodes in correct order\n4. **Attribute Management Test**: Set and retrieve attributes on different node types\n5. **Line Processing Test**: Process sample markdown text and verify `LineInfo` objects have correct properties\n\n**Expected Behavior:**\n- `debug_print_ast()` should show proper tree structure with indentation\n- Parent-child relationships should be consistent after `add_child()` calls\n- Line preprocessing should correctly identify blank lines and indentation levels\n- HTML escaping should convert `<script>` to `&lt;script&gt;`\n\n**Common Issues to Check:**\n- Circular references causing infinite loops in traversal\n- Missing line numbers making debugging difficult  \n- Inconsistent node types between base and specialized fields\n- Memory leaks from strong reference cycles in parent-child relationships\n\n\n## Block Parser Design\n\n> **Milestone(s):** Milestone 1: Block Elements\n\n### The Building Blocks Mental Model\n\nThink of block parsing like organizing a messy stack of papers into clearly labeled folders. When you process a pile of documents, you first separate them into major categories—reports go in one folder, memos in another, code printouts in a third. You don't worry about the formatting within each document (bold text, underlined words) until after you've sorted them into the right folders. Block parsing works the same way: it takes the raw lines of markdown text and groups them into structural containers like headings, paragraphs, code blocks, and blockquotes. Each block becomes a clearly defined section that can later be filled with inline formatting details.\n\nThe key insight is that block-level structure provides the skeleton of the document, while inline elements provide the flesh. You must build the skeleton first before you can properly attach the details. This two-phase approach prevents the parser from getting confused when it encounters complex nested structures like a bold link inside a blockquote within a list item.\n\n![Block Parser State Machine](./diagrams/block-parsing-states.svg)\n\n### Block Parsing Algorithm\n\nThe block parsing algorithm operates as a **state machine** that processes the markdown text line by line, maintaining context about what type of block is currently being built. The parser must handle the fact that some blocks span multiple lines (paragraphs, code blocks) while others are determined by a single line (headings, horizontal rules). Additionally, some blocks require lookahead to determine their type (distinguishing between a paragraph and a heading with Setext underlines).\n\nThe algorithm follows this sequential process:\n\n1. **Input Preprocessing**: The raw markdown text is normalized by converting all line endings to Unix format (`\\n`) and splitting into individual lines while preserving line numbers for error reporting. Each line is wrapped in a `LineInfo` object that captures the original content, line number, whether it's blank, and its indentation level.\n\n2. **Block Detection Loop**: The parser iterates through the processed lines, maintaining a current parsing state. For each line, it first checks if the current block type can continue (for multi-line blocks like paragraphs or code blocks). If the current block cannot continue, it finalizes the current block and attempts to start a new block based on the line's characteristics.\n\n3. **Block Type Recognition**: The parser uses a priority-ordered sequence of pattern matching to determine block types. Headings are checked first (both ATX-style with `#` prefixes and potential Setext-style with underline lookahead), followed by code blocks (both fenced with triple backticks and indented), then blockquotes (lines starting with `>`), horizontal rules (three or more dashes or asterisks), and finally defaulting to paragraph blocks.\n\n4. **Multi-line Block Handling**: For blocks that span multiple lines, the parser maintains state about the current block being constructed. Paragraph blocks accumulate consecutive non-blank lines until encountering a blank line or a line that starts a new block type. Code blocks have different continuation rules depending on whether they're fenced (continue until closing fence) or indented (continue while indentation is maintained).\n\n5. **Blank Line Processing**: Blank lines serve as block separators in most contexts, but their handling depends on the current block type. They terminate paragraph blocks and separate loose list items, but are preserved within fenced code blocks and ignored within indented code blocks after the required indentation is stripped.\n\n6. **Block Finalization**: When a block is completed (either by encountering a new block type or reaching the end of input), the parser creates a `BlockNode` with the appropriate `BlockType`, stores the raw content that will later be processed for inline elements, and adds it to the growing AST.\n\n7. **Lookahead Handling**: Some block types require examining subsequent lines to make parsing decisions. Setext headings are the primary example—a line of text followed by a line of equals signs or dashes indicates a heading, not two separate paragraphs. The parser implements limited lookahead by peeking at the next line when the current line could potentially be part of a Setext heading.\n\n8. **Context Preservation**: Throughout parsing, the algorithm maintains context about nesting levels (important for lists and blockquotes), indentation tracking, and the parent-child relationships needed to build the hierarchical AST structure.\n\nThe parser uses this state machine approach rather than attempting to parse all block types simultaneously with complex regular expressions. This provides better error recovery, clearer debugging, and easier extension to support additional block types.\n\n### Block Parser Architecture Decisions\n\nThe block parser must make several critical architectural choices that significantly impact both the implementation complexity and the system's extensibility. Each decision involves trade-offs between parsing accuracy, performance, and maintainability.\n\n> **Decision: State Machine vs. Regular Expression Matching**\n> - **Context**: Block parsing can be implemented either as a state machine that tracks parsing context across lines, or as a collection of regular expressions that pattern-match individual lines\n> - **Options Considered**: Stateful line-by-line processing, regex-based pattern matching, hybrid approach with regex patterns within state machine\n> - **Decision**: State machine with regex patterns for individual line recognition\n> - **Rationale**: State machines provide better context tracking for multi-line blocks and cleaner error recovery, while regex patterns excel at recognizing specific line formats like headings and horizontal rules\n> - **Consequences**: Enables robust handling of complex cases like nested blockquotes and provides clear extension points for new block types, but requires more complex state management\n\n| Approach | Pros | Cons | Chosen? |\n|----------|------|------|---------|\n| Pure State Machine | Clean context tracking, excellent error recovery, easy debugging | Complex state transitions, harder to modify individual patterns | No |\n| Pure Regex | Simple pattern matching, easy to modify individual rules | No context between lines, poor error handling, brittle | No |\n| Hybrid State Machine + Regex | Context tracking + flexible patterns, maintainable | Moderate complexity in state management | Yes |\n\n> **Decision: Lookahead Strategy for Setext Headings**\n> - **Context**: Setext headings require examining the next line to determine if a text line should become a heading, but lookahead complicates the single-pass parsing algorithm\n> - **Options Considered**: Single-line lookahead buffer, two-pass preprocessing, ignore Setext headings entirely\n> - **Decision**: Limited single-line lookahead with buffering\n> - **Rationale**: Setext headings are common enough to support, but full two-pass parsing adds unnecessary complexity for this single use case\n> - **Consequences**: Requires maintaining a one-line buffer and special handling in the main parsing loop, but keeps the parser mostly single-pass\n\n| Lookahead Strategy | Pros | Cons | Chosen? |\n|-------------------|------|------|---------|\n| No Lookahead | Simplest parsing, single-pass | Cannot handle Setext headings | No |\n| Single-line Buffer | Handles Setext headings, mostly single-pass | Slightly more complex state | Yes |\n| Full Two-pass | Handles all complex cases | Much more complex, performance overhead | No |\n\n> **Decision: Block Content Storage Format**\n> - **Context**: Blocks need to store their raw content for later inline processing, but the storage format affects both memory usage and inline parsing complexity\n> - **Options Considered**: Store as single concatenated string, maintain array of original lines, store preprocessed text with whitespace normalized\n> - **Decision**: Store as array of original line strings with metadata\n> - **Rationale**: Preserves original formatting for accurate inline parsing while maintaining line-level information needed for error reporting and debugging\n> - **Consequences**: Higher memory usage but better debugging information and more accurate inline parsing, especially for code blocks where whitespace is significant\n\n| Storage Format | Pros | Cons | Chosen? |\n|---------------|------|------|---------|\n| Single String | Low memory, simple | Loses line boundaries, poor debugging | No |\n| Line Array | Preserves formatting, good debugging | Higher memory usage | Yes |\n| Preprocessed | Normalized format | May lose important whitespace | No |\n\n> **Decision: Error Recovery Strategy**\n> - **Context**: When encountering malformed block syntax, the parser must decide whether to fail, skip the problematic content, or attempt graceful recovery\n> - **Options Considered**: Fail on any syntax error, skip malformed blocks entirely, treat unrecognized syntax as paragraph text\n> - **Decision**: Graceful degradation by treating unrecognized blocks as paragraphs\n> - **Rationale**: Markdown philosophy emphasizes readability even when formatting is imperfect, so the parser should produce reasonable output from imperfect input\n> - **Consequences**: Users get output even from malformed input, but may not notice formatting errors that should be corrected\n\nThe block parser implements these decisions through a `BlockParser` class that maintains parsing state and delegates to specialized recognition functions for each block type. The state machine tracks the current block being built, while individual regex patterns handle line-level recognition within the appropriate state context.\n\n### Block Parsing Common Pitfalls\n\nBlock parsing presents several subtle challenges that frequently trip up developers implementing their first markdown parser. These pitfalls often stem from the interaction between line-level pattern matching and multi-line context tracking.\n\n⚠️ **Pitfall: Forgetting Setext Heading Lookahead**\n\nMany developers implement ATX headings (lines starting with `#`) correctly but forget that Setext headings require examining the following line. They parse each line independently and end up treating \"Title\\n====\" as a paragraph containing \"Title\" followed by another paragraph containing \"====\", instead of recognizing it as a level-1 heading.\n\nThe issue occurs because single-line parsing cannot distinguish between a standalone line of text and the first line of a Setext heading. The parser must peek at the next line to check for underline characters (`=` for h1, `-` for h2) before deciding how to classify the current line.\n\nTo avoid this, implement a one-line lookahead buffer in your main parsing loop. When you encounter a non-blank line that could be a heading, check if the next line consists entirely of `=` or `-` characters. Only commit to creating a paragraph block after confirming the next line is not a Setext underline.\n\n⚠️ **Pitfall: Incorrect Indented Code Block Detection**\n\nIndented code blocks require exactly four spaces of indentation, but many parsers incorrectly handle mixed tabs and spaces or fail to distinguish between indented code and normal paragraph continuation. A common mistake is treating any indented line as code, which breaks when users indent regular paragraphs for visual formatting.\n\nThe problem is compounded by the fact that indented code blocks must be preceded by a blank line (or start of document) to distinguish them from indented continuation of previous blocks like list items or blockquotes. Without this check, indented text within lists gets incorrectly parsed as code blocks.\n\nImplement precise indentation checking by normalizing tabs to spaces early in preprocessing, then checking for exactly four spaces (or one tab) at the line start. Additionally, verify that indented code blocks are preceded by blank lines or other block boundaries, not continuation of existing blocks.\n\n⚠️ **Pitfall: Fenced Code Block Language Hints**\n\nFenced code blocks can specify a language identifier immediately after the opening triple backticks (e.g., \"```python\"), but many parsers either ignore this information entirely or fail to handle edge cases like languages with special characters or extra whitespace.\n\nThe language hint affects HTML generation because it should be included in the CSS class of the generated `<code>` element, but parsers often store only the content between the fences without preserving the language metadata. This breaks syntax highlighting and other language-specific processing.\n\nExtract the language hint during fenced code block parsing by capturing everything after the opening fence until the first whitespace or newline. Store this as a block attribute that the HTML generator can access later. Handle the case where no language is specified by storing an empty string rather than null.\n\n⚠️ **Pitfall: Blockquote Nesting and Lazy Continuation**\n\nBlockquote parsing has two subtle complications: nested blockquotes (lines with multiple `>` prefixes) and lazy continuation (subsequent lines without `>` that continue the blockquote content). Many parsers handle only simple single-level blockquotes.\n\nNested blockquotes require tracking the depth of `>` characters and building a hierarchical structure of blockquote nodes. Lazy continuation means that once a blockquote starts, subsequent non-blank lines continue the blockquote even without `>` prefixes, until a blank line or new block type is encountered.\n\nImplement blockquote parsing by counting the number of `>` characters at the start of each line to determine nesting depth. Maintain a stack of active blockquote levels, creating new nested blockquotes when depth increases and closing blockquotes when depth decreases. For lazy continuation, allow lines without `>` prefixes to continue the current blockquote level.\n\n⚠️ **Pitfall: Horizontal Rule False Positives**\n\nHorizontal rules are created by lines containing only three or more dashes, asterisks, or underscores, with optional whitespace. However, many parsers create false positives by not properly checking for other content on the line or by conflicting with Setext heading underlines.\n\nA line like \"--- some text\" should not create a horizontal rule, and a line with three dashes under text should be checked for Setext heading interpretation before considering it a horizontal rule. Additionally, the characters must all be the same type—mixing dashes and asterisks should not create a rule.\n\nImplement horizontal rule detection with a regex that anchors to the start and end of the line, ensures all characters are the same type, and requires at least three repetitions. Check for horizontal rules only after ruling out Setext headings to avoid conflicts.\n\n⚠️ **Pitfall: Block Boundary Detection**\n\nDetermining where one block ends and another begins is more complex than simply looking for blank lines. Different block types have different termination rules, and some blocks (like paragraphs) can be interrupted by other block types even without blank line separators.\n\nFor example, a paragraph can be immediately followed by a heading without a blank line separator, but a paragraph cannot be immediately followed by another paragraph. Similarly, fenced code blocks ignore all content until their closing fence, including lines that would normally start new block types.\n\nCreate a clear hierarchy of block interruption rules. Headings and horizontal rules can interrupt paragraphs immediately. Code blocks have their own continuation rules that override normal block detection. Use a state machine that tracks the current block type and consults type-specific continuation rules before attempting to start new blocks.\n\n### Implementation Guidance\n\nThe block parser forms the foundation of the entire markdown parsing pipeline, so robust implementation is crucial for the system's overall reliability. The following guidance provides both infrastructure components and core parsing logic to support all the block types required in Milestone 1.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Line Processing | Basic string splitting with manual parsing | Regular expression engine with compiled patterns |\n| State Management | Simple enum states with switch statements | State pattern with polymorphic state objects |\n| AST Construction | Direct node creation with manual tree building | Builder pattern with fluent interface |\n| Lookahead Buffer | Single-element peek buffer | Buffered reader with arbitrary lookahead |\n| Block Recognition | Hardcoded if-else chains for each block type | Strategy pattern with pluggable block recognizers |\n\nFor a beginner implementation, the simple options provide clear, debuggable code. The advanced options become valuable when extending the parser with custom block types or optimizing performance for large documents.\n\n#### Recommended File Structure\n\n```\nproject-root/\n  src/\n    markdown_parser/\n      __init__.py                    ← main parse_to_html() entry point\n      preprocessor.py                ← line processing and normalization\n      block_parser.py                ← core block parsing logic (implement this)\n      inline_parser.py               ← inline element parsing (future milestone)\n      ast_nodes.py                   ← AST node classes and enums\n      html_generator.py              ← HTML output generation (future milestone)\n      utils.py                       ← shared utilities and constants\n    tests/\n      test_block_parser.py           ← block parsing unit tests\n      test_integration.py            ← end-to-end parsing tests\n      fixtures/                      ← markdown test files\n        block_elements.md\n        edge_cases.md\n```\n\nThis structure separates concerns cleanly while keeping related functionality together. The `block_parser.py` module contains the core logic you'll implement, while infrastructure components provide support functionality.\n\n#### Infrastructure Starter Code\n\n**File: `src/markdown_parser/ast_nodes.py`**\n\n```python\nfrom enum import Enum\nfrom typing import List, Optional, Dict, Any\n\nclass NodeType(Enum):\n    DOCUMENT = \"document\"\n    BLOCK = \"block\"\n    INLINE = \"inline\"\n    TEXT = \"text\"\n\nclass BlockType(Enum):\n    PARAGRAPH = \"paragraph\"\n    HEADING = \"heading\"\n    CODE_BLOCK = \"code_block\"\n    BLOCKQUOTE = \"blockquote\"\n    HORIZONTAL_RULE = \"horizontal_rule\"\n    LIST = \"list\"\n    LIST_ITEM = \"list_item\"\n\nclass InlineType(Enum):\n    STRONG = \"strong\"\n    EMPHASIS = \"emphasis\"\n    CODE = \"code\"\n    LINK = \"link\"\n    IMAGE = \"image\"\n    LINE_BREAK = \"line_break\"\n\nclass ASTNode:\n    \"\"\"Base class for all AST nodes.\"\"\"\n    \n    def __init__(self, node_type: NodeType, line_number: int = 0):\n        self.node_type = node_type\n        self.children: List['ASTNode'] = []\n        self.parent: Optional['ASTNode'] = None\n        self.line_number = line_number\n    \n    def add_child(self, child: 'ASTNode') -> None:\n        \"\"\"Add child node and set parent relationship.\"\"\"\n        child.parent = self\n        self.children.append(child)\n    \n    def find_nodes_by_type(self, target_type) -> List['ASTNode']:\n        \"\"\"Find all descendant nodes of specified type.\"\"\"\n        results = []\n        if self.node_type == target_type:\n            results.append(self)\n        for child in self.children:\n            results.extend(child.find_nodes_by_type(target_type))\n        return results\n\nclass BlockNode(ASTNode):\n    \"\"\"Represents a block-level element like paragraph, heading, or code block.\"\"\"\n    \n    def __init__(self, block_type: BlockType, line_number: int = 0):\n        super().__init__(NodeType.BLOCK, line_number)\n        self.block_type = block_type\n        self.inline_content: str = \"\"\n        self.block_attributes: Dict[str, Any] = {}\n    \n    def set_content(self, content: str) -> None:\n        \"\"\"Set raw text content for block.\"\"\"\n        self.inline_content = content\n    \n    def set_attribute(self, key: str, value: Any) -> None:\n        \"\"\"Set element-specific attribute.\"\"\"\n        self.block_attributes[key] = value\n    \n    def get_attribute(self, key: str, default: Any = None) -> Any:\n        \"\"\"Get element-specific attribute.\"\"\"\n        return self.block_attributes.get(key, default)\n\nclass InlineNode(ASTNode):\n    \"\"\"Represents an inline element like emphasis, link, or code span.\"\"\"\n    \n    def __init__(self, inline_type: InlineType, line_number: int = 0):\n        super().__init__(NodeType.INLINE, line_number)\n        self.inline_type = inline_type\n        self.text_content: str = \"\"\n        self.formatting_attributes: Dict[str, Any] = {}\n```\n\n**File: `src/markdown_parser/preprocessor.py`**\n\n```python\nimport re\nfrom typing import List\nfrom dataclasses import dataclass\n\n@dataclass\nclass LineInfo:\n    \"\"\"Information about a single line of markdown input.\"\"\"\n    content: str\n    line_number: int\n    is_blank: bool\n    indent_level: int\n\nclass Preprocessor:\n    \"\"\"Handles input normalization and line-level analysis.\"\"\"\n    \n    def normalize_line_endings(self, text: str) -> str:\n        \"\"\"Convert all line endings to Unix format.\"\"\"\n        return text.replace('\\r\\n', '\\n').replace('\\r', '\\n')\n    \n    def split_into_lines(self, text: str) -> List[str]:\n        \"\"\"Split text preserving line numbers.\"\"\"\n        return text.split('\\n')\n    \n    def is_blank_line(self, line: str) -> bool:\n        \"\"\"Check for whitespace-only lines.\"\"\"\n        return len(line.strip()) == 0\n    \n    def get_indentation_level(self, line: str) -> int:\n        \"\"\"Count leading spaces (tabs count as 4 spaces).\"\"\"\n        indent = 0\n        for char in line:\n            if char == ' ':\n                indent += 1\n            elif char == '\\t':\n                indent += 4\n            else:\n                break\n        return indent\n    \n    def process_input(self, text: str) -> List[LineInfo]:\n        \"\"\"Process raw markdown into analyzed lines.\"\"\"\n        normalized = self.normalize_line_endings(text)\n        lines = self.split_into_lines(normalized)\n        \n        result = []\n        for i, line in enumerate(lines):\n            line_info = LineInfo(\n                content=line,\n                line_number=i + 1,\n                is_blank=self.is_blank_line(line),\n                indent_level=self.get_indentation_level(line)\n            )\n            result.append(line_info)\n        \n        return result\n```\n\n**File: `src/markdown_parser/utils.py`**\n\n```python\nimport re\nfrom typing import Dict\n\n# HTML entity escaping table\nHTML_ESCAPE_TABLE: Dict[str, str] = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;'\n}\n\ndef escape_html(text: str) -> str:\n    \"\"\"Escape HTML special characters.\"\"\"\n    for char, entity in HTML_ESCAPE_TABLE.items():\n        text = text.replace(char, entity)\n    return text\n\ndef debug_print_ast(node, indent: int = 0) -> None:\n    \"\"\"Display AST structure for debugging.\"\"\"\n    prefix = \"  \" * indent\n    node_info = f\"{prefix}{node.node_type.value}\"\n    \n    if hasattr(node, 'block_type'):\n        node_info += f\" ({node.block_type.value})\"\n    elif hasattr(node, 'inline_type'):\n        node_info += f\" ({node.inline_type.value})\"\n    \n    if hasattr(node, 'inline_content') and node.inline_content:\n        content_preview = node.inline_content[:50].replace('\\n', '\\\\n')\n        node_info += f': \"{content_preview}\"'\n    \n    print(node_info)\n    \n    for child in node.children:\n        debug_print_ast(child, indent + 1)\n\n# Compiled regex patterns for block recognition\nATX_HEADING_PATTERN = re.compile(r'^(#{1,6})\\s+(.*?)(?:\\s+#+)?$')\nSETEXT_H1_UNDERLINE = re.compile(r'^=+\\s*$')\nSETEXT_H2_UNDERLINE = re.compile(r'^-+\\s*$')\nFENCED_CODE_START = re.compile(r'^```(\\w*)\\s*$')\nFENCED_CODE_END = re.compile(r'^```\\s*$')\nHORIZONTAL_RULE_PATTERN = re.compile(r'^(\\*{3,}|-{3,}|_{3,})\\s*$')\nBLOCKQUOTE_PATTERN = re.compile(r'^>\\s?(.*)')\n```\n\n#### Core Logic Skeleton Code\n\n**File: `src/markdown_parser/block_parser.py`**\n\n```python\nfrom typing import List, Optional, Iterator\nfrom enum import Enum\nimport re\n\nfrom .ast_nodes import ASTNode, BlockNode, BlockType, NodeType\nfrom .preprocessor import LineInfo, Preprocessor\nfrom .utils import (ATX_HEADING_PATTERN, SETEXT_H1_UNDERLINE, SETEXT_H2_UNDERLINE,\n                    FENCED_CODE_START, FENCED_CODE_END, HORIZONTAL_RULE_PATTERN,\n                    BLOCKQUOTE_PATTERN)\n\nclass BlockParserState(Enum):\n    \"\"\"Current state of the block parser.\"\"\"\n    LOOKING_FOR_BLOCK = \"looking_for_block\"\n    IN_PARAGRAPH = \"in_paragraph\"\n    IN_FENCED_CODE = \"in_fenced_code\"\n    IN_INDENTED_CODE = \"in_indented_code\"\n    IN_BLOCKQUOTE = \"in_blockquote\"\n\nclass BlockParser:\n    \"\"\"Parses block-level markdown elements into an AST.\"\"\"\n    \n    def __init__(self):\n        self.preprocessor = Preprocessor()\n        self.state = BlockParserState.LOOKING_FOR_BLOCK\n        self.current_block: Optional[BlockNode] = None\n        self.root_document: Optional[ASTNode] = None\n        self.line_buffer: List[LineInfo] = []\n        self.current_line_index = 0\n    \n    def parse_blocks(self, markdown_text: str) -> ASTNode:\n        \"\"\"Main entry point for block parsing.\n        \n        Returns the root document node containing all parsed blocks.\n        \"\"\"\n        # TODO 1: Use preprocessor to convert text into LineInfo objects\n        # TODO 2: Create root document node to hold all blocks\n        # TODO 3: Initialize parsing state and line buffer\n        # TODO 4: Process all lines through the main parsing loop\n        # TODO 5: Finalize any incomplete block at end of input\n        # TODO 6: Return the completed document AST\n        pass\n    \n    def process_line_sequence(self, lines: List[LineInfo]) -> None:\n        \"\"\"Process a sequence of lines through the block parser state machine.\n        \n        This is the main parsing loop that handles state transitions and\n        delegates to specific block type handlers.\n        \"\"\"\n        # TODO 1: Set up line iteration with lookahead capability\n        # TODO 2: For each line, check if current block can continue\n        # TODO 3: If current block cannot continue, finalize it\n        # TODO 4: Attempt to start new block based on line characteristics\n        # TODO 5: If no specific block type matches, default to paragraph\n        # TODO 6: Handle end-of-input by finalizing any active block\n        pass\n    \n    def peek_next_line(self) -> Optional[LineInfo]:\n        \"\"\"Look ahead at the next line without consuming it.\n        \n        Used for Setext heading detection and other lookahead needs.\n        \"\"\"\n        # TODO 1: Check if there are more lines available\n        # TODO 2: Return the next line without advancing current position\n        # TODO 3: Return None if at end of input\n        pass\n    \n    def can_current_block_continue(self, line: LineInfo) -> bool:\n        \"\"\"Check if the current block can accept this line as continuation.\n        \n        Different block types have different continuation rules.\n        \"\"\"\n        # TODO 1: Check current parser state and block type\n        # TODO 2: For paragraphs, continue unless blank line or new block starts\n        # TODO 3: For fenced code, continue until closing fence\n        # TODO 4: For indented code, continue while indentation is maintained\n        # TODO 5: For blockquotes, handle both > prefixed and lazy continuation\n        # TODO 6: Return False if current block should terminate\n        pass\n    \n    def try_start_heading_block(self, line: LineInfo) -> bool:\n        \"\"\"Attempt to start an ATX or Setext heading block.\n        \n        Returns True if heading was successfully started.\n        \"\"\"\n        # TODO 1: Try ATX heading pattern (# through ######)\n        # TODO 2: Extract heading level and content from ATX match\n        # TODO 3: Try Setext heading by looking ahead to next line\n        # TODO 4: For Setext, check if next line is all = or - characters\n        # TODO 5: Create BlockNode with HEADING type and appropriate attributes\n        # TODO 6: Set heading level (1-6) and content in block attributes\n        pass\n    \n    def try_start_code_block(self, line: LineInfo) -> bool:\n        \"\"\"Attempt to start a fenced or indented code block.\n        \n        Returns True if code block was successfully started.\n        \"\"\"\n        # TODO 1: Check for fenced code block start (triple backticks)\n        # TODO 2: Extract language hint if present after opening fence\n        # TODO 3: Set parser state to IN_FENCED_CODE\n        # TODO 4: Check for indented code block (4+ spaces, after blank line)\n        # TODO 5: Verify indented code is preceded by block boundary\n        # TODO 6: Create CODE_BLOCK node with appropriate attributes\n        pass\n    \n    def try_start_blockquote(self, line: LineInfo) -> bool:\n        \"\"\"Attempt to start a blockquote block.\n        \n        Returns True if blockquote was successfully started.\n        \"\"\"\n        # TODO 1: Check for > prefix at start of line\n        # TODO 2: Extract content after > marker (handling optional space)\n        # TODO 3: Handle nested blockquotes by counting > characters\n        # TODO 4: Create BLOCKQUOTE node with nesting level attribute\n        # TODO 5: Set parser state to IN_BLOCKQUOTE\n        # TODO 6: Store first line of blockquote content\n        pass\n    \n    def try_start_horizontal_rule(self, line: LineInfo) -> bool:\n        \"\"\"Attempt to create a horizontal rule block.\n        \n        Returns True if horizontal rule was successfully created.\n        \"\"\"\n        # TODO 1: Check for horizontal rule pattern (3+ dashes, stars, or underscores)\n        # TODO 2: Ensure all characters are the same type\n        # TODO 3: Verify line contains only rule characters and whitespace\n        # TODO 4: Create HORIZONTAL_RULE node (no content needed)\n        # TODO 5: Add completed block to document immediately\n        # TODO 6: Reset state to LOOKING_FOR_BLOCK\n        pass\n    \n    def start_paragraph_block(self, line: LineInfo) -> None:\n        \"\"\"Start a new paragraph block with the given line.\n        \n        This is the default block type when no other pattern matches.\n        \"\"\"\n        # TODO 1: Create new BlockNode with PARAGRAPH type\n        # TODO 2: Set the line content as initial paragraph content\n        # TODO 3: Set parser state to IN_PARAGRAPH\n        # TODO 4: Store line number for error reporting\n        pass\n    \n    def continue_current_block(self, line: LineInfo) -> None:\n        \"\"\"Add the current line to the active block being built.\n        \n        Handling varies by block type and parser state.\n        \"\"\"\n        # TODO 1: Check current parser state to determine continuation behavior\n        # TODO 2: For paragraphs, append line content with proper spacing\n        # TODO 3: For fenced code, check for closing fence before appending\n        # TODO 4: For indented code, strip required indentation before appending\n        # TODO 5: For blockquotes, handle > prefix removal and lazy continuation\n        # TODO 6: Update block content while preserving line structure\n        pass\n    \n    def finalize_current_block(self) -> None:\n        \"\"\"Complete the current block and add it to the document.\n        \n        Performs any cleanup needed based on block type.\n        \"\"\"\n        # TODO 1: Check if there is an active block to finalize\n        # TODO 2: Trim trailing whitespace from block content if appropriate\n        # TODO 3: Add completed block as child of root document\n        # TODO 4: Clear current block reference and reset state\n        # TODO 5: Handle any block-type-specific finalization (e.g., code language)\n        pass\n```\n\n#### Milestone Checkpoint\n\nAfter implementing the block parser, verify correct functionality with these specific tests:\n\n**Test Command**: `python -m pytest tests/test_block_parser.py -v`\n\n**Expected Behavior**:\n- ATX headings from `#` through `######` create heading blocks with correct levels\n- Setext headings with `===` and `---` underlines create h1 and h2 blocks\n- Fenced code blocks preserve content exactly and capture language hints\n- Indented code blocks handle 4-space indentation correctly\n- Blockquotes handle both `>` prefixed and lazy continuation lines\n- Paragraphs group consecutive lines and terminate at blank lines\n- Horizontal rules recognize `---`, `***`, and `___` patterns\n\n**Manual Verification**: Create a test file with this content:\n```markdown\n# Main Title\n\nThis is a paragraph with\nmultiple lines of text.\n\n```\n\n## Subsection\n\n```python\ndef hello():\n    print(\"world\")\n```\n\n> This is a blockquote\n> with multiple lines.\n\n---\n\nFinal paragraph.\n```\n\nRun your parser and verify the AST contains 6 blocks: heading, paragraph, heading, code_block, blockquote, horizontal_rule, and paragraph.\n\n**Debugging Signs**:\n- If headings aren't recognized, check ATX pattern regex and heading level extraction\n- If paragraphs merge incorrectly, verify blank line handling in `can_current_block_continue`\n- If code blocks lose content, check fence detection and content preservation logic\n- If blockquotes don't handle continuation, verify lazy continuation rules\n\n```\n\n\n## Inline Parser Design\n\n> **Milestone(s):** Milestone 2: Inline Elements\n\n### The Text Surgery Mental Model\n\nThink of inline parsing like performing precise surgery on a sentence. You have a paragraph of text that looks normal on the surface, but hidden within are formatting markers that need to be carefully extracted and transformed. Just as a surgeon must navigate around vital organs while removing a tumor, the inline parser must navigate around nested formatting while preserving the structure of the surrounding text. \n\nConsider the text: `This **bold text contains *nested italic* formatting** here.` The parser must recognize that the asterisks aren't just characters—they're surgical markers indicating where to make precise cuts. The double asterisks mark the boundaries of bold formatting, but within that region, single asterisks mark italic formatting. The parser must track the nesting depth, ensuring that when it closes the italic formatting, it doesn't accidentally close the bold formatting too early.\n\nUnlike block parsing, which deals with entire lines and clear structural boundaries, inline parsing operates at the character level within continuous text. It's context-dependent parsing where the meaning of a character depends on what came before it and what surrounds it. An underscore in the middle of a word like `snake_case` should be treated as literal text, but underscores at word boundaries like `_emphasis_` should trigger formatting.\n\n### Inline Parsing Algorithm\n\nThe inline parser operates on text content that has already been extracted from block elements by the block parser. This two-phase approach allows the inline parser to focus purely on formatting markers without worrying about structural boundaries like paragraph breaks or code block delimiters.\n\n![Inline Element Parsing Sequence](./diagrams/inline-parsing-sequence.svg)\n\nThe core algorithm uses a **delimiter stack approach** combined with **left-to-right scanning**. This handles the fundamental challenge of nested formatting where delimiters must be matched correctly even when they overlap or contain each other.\n\n#### Primary Algorithm Steps\n\nThe inline parsing algorithm processes text through several coordinated phases:\n\n1. **Character-by-character scanning**: The parser maintains a current position index and examines each character in the input text. This allows it to detect delimiter sequences that might span multiple characters, such as `**` for strong emphasis or `![` for image syntax.\n\n2. **Delimiter detection and classification**: When the parser encounters a potential delimiter character (asterisk, underscore, backtick, square bracket), it must determine whether this character should be treated as a formatting marker or literal text. This involves checking the surrounding context, including whitespace, word boundaries, and escape sequences.\n\n3. **Delimiter stack management**: Valid formatting delimiters are pushed onto a stack structure that tracks their position, type, and nesting level. The stack enables proper matching of opening and closing delimiters even when they're separated by other nested formatting.\n\n4. **Content extraction**: Between matched delimiters, the parser recursively processes the contained text to handle nested formatting. This creates a tree structure where parent formatting elements contain child formatting elements.\n\n5. **AST node creation**: Successfully matched delimiter pairs result in the creation of `InlineNode` instances with the appropriate `InlineType` values. These nodes are inserted into the AST with their text content and any formatting attributes.\n\n6. **Escape sequence processing**: Throughout scanning, the parser must handle escape sequences where a backslash makes the following character literal. This prevents formatting markers from being processed when they're explicitly escaped by the author.\n\nThe algorithm handles several challenging cases that make inline parsing complex:\n\n**Emphasis delimiter precedence**: When both asterisks and underscores are present, or when single and double delimiters compete, the parser must apply CommonMark precedence rules. Longer delimiter sequences (like `**`) generally take precedence over shorter ones (like `*`), and delimiters that are closer together are matched before those that are farther apart.\n\n**Intraword underscore handling**: Underscores within words like `snake_case_variable` must not trigger emphasis formatting, while underscores at word boundaries should. The parser detects word boundaries by examining adjacent characters for alphanumeric content and Unicode word character properties.\n\n**Link and image parsing**: These elements use complex syntax like `[link text](URL \"title\")` that requires careful parsing of multiple components. The parser must handle nested square brackets in link text, optional title attributes in quotes, and URL validation.\n\n**Inline code span precedence**: Code spans delimited by backticks have special precedence—nothing inside them should be processed for other formatting. The parser must recognize code span boundaries first and treat their content as literal text for subsequent parsing phases.\n\n#### Delimiter Stack Data Structures\n\nThe delimiter stack uses specialized data structures to track formatting state:\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `delimiter_type` | `str` | The delimiter character(s): '*', '**', '_', '__', '`', '[', '![' |\n| `position` | `int` | Character index in the source text where delimiter was found |\n| `can_open` | `bool` | Whether this delimiter can open formatting based on surrounding context |\n| `can_close` | `bool` | Whether this delimiter can close formatting based on surrounding context |\n| `is_active` | `bool` | Whether this delimiter is still available for matching |\n| `delimiter_length` | `int` | Length of the delimiter sequence (1 for `*`, 2 for `**`) |\n| `original_stack_position` | `int` | Position in delimiter stack for tracking nesting relationships |\n\nThe stack enables several critical operations:\n\n**Push delimiter**: When a potential opening delimiter is encountered, it's pushed onto the stack with context information about whether it can legitimately open formatting based on the surrounding whitespace and characters.\n\n**Match and pop**: When a potential closing delimiter is found, the parser searches backward through the stack to find a matching opening delimiter of the same type. Intermediate delimiters may be deactivated if they interfere with the match.\n\n**Precedence resolution**: When multiple valid matches are possible, the parser applies CommonMark precedence rules to determine which delimiters should be paired together.\n\n### Inline Parser Architecture Decisions\n\nThe inline parser design requires several critical architectural decisions that significantly impact both correctness and performance.\n\n> **Decision: Delimiter Stack vs Regular Expression Matching**\n> - **Context**: Inline formatting can be nested arbitrarily deep and must handle complex precedence rules between different delimiter types\n> - **Options Considered**: \n>   - Pure regex approach with complex patterns for each formatting type\n>   - Delimiter stack with explicit delimiter matching logic  \n>   - Recursive descent parser with separate functions for each inline element type\n> - **Decision**: Delimiter stack with explicit matching logic\n> - **Rationale**: Regular expressions cannot handle arbitrary nesting depths due to their finite state nature, and complex regex patterns become unmaintainable. Recursive descent works but struggles with delimiter precedence when multiple formatting types interact. The delimiter stack approach directly models CommonMark's emphasis algorithm and handles both nesting and precedence correctly.\n> - **Consequences**: More complex implementation than regex but handles all edge cases correctly. Stack management adds some performance overhead but enables proper handling of malformed input.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Regex Only | Simple implementation, fast for basic cases | Cannot handle nested formatting, complex patterns unmaintainable | No |\n| Delimiter Stack | Handles nesting correctly, follows CommonMark spec exactly | More complex implementation, requires careful state management | **Yes** |\n| Recursive Descent | Natural tree structure, easy to extend | Struggles with delimiter precedence, harder to handle malformed input | No |\n\n> **Decision: Two-Phase vs Single-Phase Inline Processing**\n> - **Context**: Inline elements like code spans should take precedence over emphasis formatting, but links can contain emphasis in their text\n> - **Options Considered**:\n>   - Single pass processing all inline elements simultaneously\n>   - Two-phase approach: first pass for code spans and links, second pass for emphasis\n>   - Multi-phase approach with separate pass for each element type\n> - **Decision**: Two-phase approach with code spans processed first\n> - **Rationale**: Code spans must be processed before emphasis because nothing inside a code span should be formatted. Links need special handling because they can contain emphasis in their link text. Two phases balance correctness with implementation complexity.\n> - **Consequences**: Requires multiple passes over text but ensures correct precedence. Code spans properly mask their content from further processing.\n\n> **Decision: Escape Sequence Processing Timing**\n> - **Context**: Backslash escape sequences can appear anywhere and must prevent following characters from being interpreted as formatting\n> - **Options Considered**:\n>   - Process escapes during initial scanning before delimiter detection\n>   - Process escapes during delimiter matching after detection\n>   - Process escapes during HTML generation as final step\n> - **Decision**: Process escapes during initial scanning\n> - **Rationale**: Escaped characters should never be considered as potential delimiters, so escape processing must happen first. This prevents escaped asterisks from being pushed onto the delimiter stack at all.\n> - **Consequences**: Simplifies delimiter detection logic but requires careful handling of backslashes that aren't valid escape sequences.\n\n#### Emphasis Delimiter Precedence Rules\n\nThe CommonMark specification defines complex precedence rules for emphasis delimiters that the parser must implement correctly:\n\n| Precedence Level | Rule | Example | Result |\n|------------------|------|---------|--------|\n| 1 | Longer delimiter sequences take precedence | `***text***` | `<strong><em>text</em></strong>` |\n| 2 | Closer delimiter pairs are matched first | `*a **b* c**` | `<em>a **b</em> c**` (malformed) |\n| 3 | Left-to-right processing for equal precedence | `*a* *b*` | `<em>a</em> <em>b</em>` |\n| 4 | Intraword underscores are disabled | `snake_case_var` | No formatting applied |\n| 5 | Asterisks work anywhere | `a*b*c` | `a<em>b</em>c` |\n\nThese precedence rules require the delimiter stack to implement sophisticated matching logic that goes beyond simple stack operations.\n\n#### Context-Dependent Delimiter Rules\n\nThe parser must implement context-dependent rules for determining when characters can function as opening or closing delimiters:\n\n| Context Check | Applies To | Rule | Example Valid | Example Invalid |\n|---------------|------------|------|---------------|-----------------|\n| Left-flanking | Opening delimiters | Not preceded by Unicode whitespace, not followed by punctuation unless preceded by whitespace/punctuation | `*emphasis*` | `* not emphasis` |\n| Right-flanking | Closing delimiters | Not followed by Unicode whitespace, not preceded by punctuation unless followed by whitespace/punctuation | `*emphasis*` | `not emphasis *` |\n| Intraword underscore | Underscores only | Cannot open/close if flanked by alphanumeric characters | `_start_` | `snake_case` |\n| Code span priority | All delimiters | Cannot open/close inside code spans | `` `*literal*` `` | N/A |\n\n### Inline Parsing Common Pitfalls\n\nInline parsing presents several challenging edge cases that frequently trip up implementers. Understanding these pitfalls helps avoid subtle bugs that can be difficult to debug.\n\n⚠️ **Pitfall: Underscore Intraword Handling**\n\nMany implementations incorrectly handle underscores within words, either formatting when they shouldn't or failing to format when they should. The CommonMark specification has specific rules: underscores cannot open or close emphasis if they're flanked by alphanumeric characters.\n\nConsider `snake_case_variable` versus `_emphasis_word`. In the first case, both underscores are flanked by letters, so no emphasis should be applied. In the second case, the first underscore is preceded by whitespace (can open) and the second is followed by whitespace (can close), so emphasis should be applied.\n\nThe fix requires implementing proper flanking detection that checks the Unicode character classes of adjacent characters, not just simple whitespace detection. The parser must examine the character before the underscore and after to determine if they're alphanumeric.\n\n⚠️ **Pitfall: Delimiter Matching Precedence Errors**\n\nImplementers often use greedy matching that doesn't follow CommonMark precedence rules, leading to incorrect parsing of overlapping emphasis. For example, `***bold italic***` should parse as `<strong><em>bold italic</em></strong>` (double asterisk matched first, then single), not `<em><strong>bold italic</strong></em>`.\n\nThe issue occurs when parsers match the first opening delimiter they find with the first closing delimiter, rather than applying proper precedence rules. The CommonMark algorithm specifically handles this by processing longer delimiter sequences first and implementing complex matching logic.\n\nThe fix requires implementing the full CommonMark emphasis algorithm with proper precedence handling, not just simple stack matching.\n\n⚠️ **Pitfall: Escape Sequence Processing Order**\n\nProcessing escape sequences at the wrong time leads to either double-escaping or failure to escape properly. If escapes are processed during HTML generation, then `\\*` might be treated as a delimiter during parsing and incorrectly formatted.\n\nThe correct approach processes escapes during the initial scanning phase, converting `\\*` to a literal asterisk before any delimiter detection occurs. This ensures that escaped characters are never considered as formatting markers.\n\n⚠️ **Pitfall: Code Span Precedence Violations**\n\nMany parsers incorrectly process emphasis formatting inside code spans, violating the rule that code spans take precedence over all other inline formatting. Text like `` `*literal asterisks*` `` should render with literal asterisks, not emphasis.\n\nThis happens when parsers don't implement proper two-phase processing or when they detect code spans incorrectly. The fix requires processing code spans first and marking their content as literal text that should be skipped during emphasis processing.\n\n⚠️ **Pitfall: Link Parsing Bracket Matching**\n\nLink syntax parsing often fails on nested brackets or complex URLs. Text like `[link with [nested] brackets](URL)` requires careful bracket counting to determine where the link text ends and the URL begins.\n\nSimple regex patterns fail on this input because they can't handle the nested structure. The fix requires implementing proper bracket counting that tracks nesting depth and handles escape sequences within the link text.\n\n⚠️ **Pitfall: Malformed Input Recovery**\n\nMany parsers fail catastrophically on malformed input like unmatched delimiters or incomplete link syntax. Input like `**unmatched emphasis` should render with literal asterisks, not cause a parser error.\n\nThe correct approach implements graceful degradation where unmatched delimiters are left as literal text. This requires careful cleanup of the delimiter stack when processing completes, converting any unmatched delimiters back to literal characters.\n\n#### Delimiter Stack State Management Issues\n\nSeveral common issues arise from improper delimiter stack management:\n\n| Issue | Symptom | Cause | Fix |\n|-------|---------|-------|-----|\n| Stack overflow on deeply nested input | Parser crashes or hangs | No depth limit on delimiter nesting | Implement maximum nesting depth limit |\n| Memory leak on malformed input | Memory usage grows unbounded | Unmatched delimiters never removed from stack | Clean up unmatched delimiters at text boundaries |\n| Incorrect precedence handling | Wrong emphasis nesting in output | Matching first available delimiter instead of highest precedence | Implement proper precedence search in stack |\n| Performance degradation on long text | Parsing becomes very slow | O(n²) behavior from excessive stack scanning | Optimize delimiter matching with better data structures |\n\n#### Context Detection Edge Cases\n\nContext-dependent parsing creates several edge cases that are easy to get wrong:\n\n| Input | Expected Result | Common Wrong Result | Issue |\n|-------|----------------|---------------------|-------|\n| `a_b_c` | `a_b_c` (no formatting) | `a<em>b</em>c` | Intraword underscore rule not implemented |\n| `_a_b_` | `<em>a_b</em>` | `_a<em>b</em>_` | First underscore not recognized as opener |\n| `**a*b**` | `<strong>a*b</strong>` | `**a<em>b</em>*` | Inner asterisk shouldn't close outer emphasis |\n| `*a**b*c**` | `<em>a**b</em>c**` | Various incorrect parsings | Complex precedence interaction |\n\n### Implementation Guidance\n\nThe inline parser implementation requires careful attention to character-level processing and state management. The following guidance provides both infrastructure components and core parsing logic to help implement a correct inline parser.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Regex Engine | Built-in `re` module | Third-party `regex` module with Unicode support |\n| Character Classification | Manual ASCII checks | `unicodedata` module for proper Unicode handling |\n| Stack Implementation | Python `list` with append/pop | Custom stack class with additional metadata |\n| String Building | String concatenation | `io.StringIO` for efficient building |\n| Delimiter Detection | Character-by-character scanning | Compiled regex patterns for common delimiters |\n\n#### Recommended File Structure\n\n```python\nmarkdown_parser/\n  parsers/\n    inline_parser.py           ← main inline parsing logic\n    delimiter_stack.py         ← delimiter stack implementation\n    inline_elements.py         ← specific element parsers (links, emphasis)\n    escape_processor.py        ← escape sequence handling\n  ast/\n    inline_nodes.py           ← InlineNode and InlineType definitions\n  utils/\n    text_utils.py             ← character classification and flanking detection\n  tests/\n    test_inline_parser.py     ← comprehensive inline parsing tests\n    test_emphasis_precedence.py ← specific emphasis precedence tests\n```\n\n#### Infrastructure Starter Code\n\n**Complete Delimiter Stack Implementation (delimiter_stack.py):**\n\n```python\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Tuple\nfrom enum import Enum\n\nclass DelimiterType(Enum):\n    ASTERISK = \"asterisk\"\n    UNDERSCORE = \"underscore\"\n    BACKTICK = \"backtick\"\n    LEFT_BRACKET = \"left_bracket\"\n    EXCLAMATION_BRACKET = \"exclamation_bracket\"\n\n@dataclass\nclass Delimiter:\n    delimiter_type: DelimiterType\n    char: str\n    position: int\n    length: int\n    can_open: bool\n    can_close: bool\n    is_active: bool = True\n    original_length: int = None\n    \n    def __post_init__(self):\n        if self.original_length is None:\n            self.original_length = self.length\n\nclass DelimiterStack:\n    def __init__(self):\n        self.stack: List[Delimiter] = []\n    \n    def push(self, delimiter: Delimiter) -> None:\n        \"\"\"Add a delimiter to the stack.\"\"\"\n        self.stack.append(delimiter)\n    \n    def find_matching_opener(self, closer: Delimiter) -> Optional[Tuple[int, Delimiter]]:\n        \"\"\"Find the most recent matching opener for the given closer.\"\"\"\n        for i in range(len(self.stack) - 1, -1, -1):\n            opener = self.stack[i]\n            if (opener.is_active and \n                opener.can_open and \n                opener.delimiter_type == closer.delimiter_type and\n                opener.char == closer.char):\n                return i, opener\n        return None\n    \n    def deactivate_between(self, start_idx: int, end_idx: int) -> None:\n        \"\"\"Deactivate delimiters between two positions.\"\"\"\n        for i in range(start_idx + 1, end_idx):\n            if i < len(self.stack):\n                self.stack[i].is_active = False\n    \n    def clear_to_position(self, position: int) -> None:\n        \"\"\"Remove delimiters up to a specific text position.\"\"\"\n        self.stack = [d for d in self.stack if d.position >= position]\n    \n    def get_unmatched_delimiters(self) -> List[Delimiter]:\n        \"\"\"Get all unmatched delimiters for literal text conversion.\"\"\"\n        return [d for d in self.stack if d.is_active]\n\ndef detect_flanking_properties(text: str, pos: int, delimiter_len: int) -> Tuple[bool, bool]:\n    \"\"\"Detect if delimiter can open/close based on flanking rules.\"\"\"\n    import unicodedata\n    \n    # Get characters before and after delimiter\n    before_char = text[pos - 1] if pos > 0 else ' '\n    after_char = text[pos + delimiter_len] if pos + delimiter_len < len(text) else ' '\n    \n    # Unicode character classification\n    before_whitespace = before_char.isspace()\n    after_whitespace = after_char.isspace()\n    before_punctuation = unicodedata.category(before_char).startswith('P')\n    after_punctuation = unicodedata.category(after_char).startswith('P')\n    \n    # Left-flanking: not followed by whitespace, and either\n    # not followed by punctuation or preceded by whitespace/punctuation\n    left_flanking = (not after_whitespace and \n                    (not after_punctuation or before_whitespace or before_punctuation))\n    \n    # Right-flanking: not preceded by whitespace, and either\n    # not preceded by punctuation or followed by whitespace/punctuation  \n    right_flanking = (not before_whitespace and\n                     (not before_punctuation or after_whitespace or after_punctuation))\n    \n    return left_flanking, right_flanking\n\ndef can_open_emphasis(char: str, left_flanking: bool, right_flanking: bool, \n                     before_char: str, after_char: str) -> bool:\n    \"\"\"Determine if delimiter can open emphasis.\"\"\"\n    if char == '*':\n        return left_flanking\n    elif char == '_':\n        return left_flanking and (not right_flanking or not after_char.isalnum())\n    return False\n\ndef can_close_emphasis(char: str, left_flanking: bool, right_flanking: bool,\n                      before_char: str, after_char: str) -> bool:\n    \"\"\"Determine if delimiter can close emphasis.\"\"\"\n    if char == '*':\n        return right_flanking\n    elif char == '_':\n        return right_flanking and (not left_flanking or not before_char.isalnum())\n    return False\n```\n\n**Complete Escape Processor (escape_processor.py):**\n\n```python\nimport re\nfrom typing import List, Tuple\n\n# Characters that can be escaped in CommonMark\nESCAPABLE_CHARS = r'!\"#$%&\\'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~'\n\nclass EscapeProcessor:\n    def __init__(self):\n        self.escape_pattern = re.compile(r'\\\\(.)')\n    \n    def process_escapes(self, text: str) -> Tuple[str, List[int]]:\n        \"\"\"\n        Process escape sequences and return processed text with escape positions.\n        \n        Returns:\n            Tuple of (processed_text, list of positions that were escaped)\n        \"\"\"\n        result = []\n        escaped_positions = []\n        i = 0\n        \n        while i < len(text):\n            if text[i] == '\\\\' and i + 1 < len(text):\n                next_char = text[i + 1]\n                if next_char in ESCAPABLE_CHARS:\n                    # Valid escape sequence\n                    result.append(next_char)\n                    escaped_positions.append(len(result) - 1)\n                    i += 2\n                else:\n                    # Invalid escape, keep backslash\n                    result.append(text[i])\n                    i += 1\n            else:\n                result.append(text[i])\n                i += 1\n        \n        return ''.join(result), escaped_positions\n    \n    def is_escaped(self, position: int, escaped_positions: List[int]) -> bool:\n        \"\"\"Check if a character at given position was escaped.\"\"\"\n        return position in escaped_positions\n```\n\n#### Core Logic Skeleton Code\n\n**Main Inline Parser (inline_parser.py):**\n\n```python\nfrom typing import List, Optional, Dict, Any\nfrom .delimiter_stack import DelimiterStack, Delimiter, DelimiterType\nfrom .escape_processor import EscapeProcessor\nfrom ..ast.inline_nodes import InlineNode, InlineType\nfrom ..ast.ast_nodes import ASTNode\n\nclass InlineParser:\n    def __init__(self):\n        self.delimiter_stack = DelimiterStack()\n        self.escape_processor = EscapeProcessor()\n    \n    def parse_inline_elements(self, text: str) -> List[InlineNode]:\n        \"\"\"\n        Main entry point for parsing inline elements from text.\n        \n        Returns list of InlineNode objects representing the parsed content.\n        \"\"\"\n        # TODO 1: Process escape sequences first to handle \\* and other escapes\n        # TODO 2: First pass - process code spans (highest precedence)  \n        # TODO 3: Second pass - process links and images\n        # TODO 4: Third pass - process emphasis (asterisks and underscores)\n        # TODO 5: Convert any remaining text to text nodes\n        # TODO 6: Return list of inline nodes\n        pass\n    \n    def _process_code_spans(self, text: str, escaped_positions: List[int]) -> List[InlineNode]:\n        \"\"\"\n        Process inline code spans delimited by backticks.\n        Code spans have highest precedence and mask their content.\n        \"\"\"\n        # TODO 1: Scan for backtick sequences, ignoring escaped backticks\n        # TODO 2: Match opening and closing backtick sequences of same length\n        # TODO 3: Extract code content and normalize whitespace per CommonMark rules\n        # TODO 4: Create InlineNode with InlineType.CODE\n        # TODO 5: Mark code span regions as processed for subsequent passes\n        pass\n    \n    def _process_emphasis(self, text: str, escaped_positions: List[int], \n                         processed_regions: List[Tuple[int, int]]) -> List[InlineNode]:\n        \"\"\"\n        Process emphasis (bold and italic) using delimiter matching algorithm.\n        \"\"\"\n        self.delimiter_stack = DelimiterStack()  # Reset for each text segment\n        \n        # TODO 1: Scan character by character for emphasis delimiters\n        # TODO 2: For each potential delimiter, check flanking properties\n        # TODO 3: Push valid opening delimiters onto stack\n        # TODO 4: For closing delimiters, find matching opener with precedence rules\n        # TODO 5: Create InlineNode for matched delimiter pairs\n        # TODO 6: Handle unmatched delimiters as literal text\n        # TODO 7: Recursively process content within emphasis nodes\n        pass\n    \n    def _scan_emphasis_delimiters(self, text: str, pos: int) -> Optional[Delimiter]:\n        \"\"\"\n        Scan for emphasis delimiters at current position.\n        Returns Delimiter object if valid delimiter found, None otherwise.\n        \"\"\"\n        # TODO 1: Check for asterisk or underscore at current position\n        # TODO 2: Count consecutive delimiter characters (*, **, ***, etc.)\n        # TODO 3: Determine flanking properties using detect_flanking_properties\n        # TODO 4: Apply emphasis opening/closing rules based on delimiter type\n        # TODO 5: Return Delimiter object with all properties set\n        pass\n    \n    def _process_links_and_images(self, text: str, escaped_positions: List[int],\n                                 processed_regions: List[Tuple[int, int]]) -> List[InlineNode]:\n        \"\"\"\n        Process link and image syntax: [text](url) and ![alt](url)\n        \"\"\"\n        # TODO 1: Scan for opening brackets [ and image syntax ![\n        # TODO 2: Handle nested brackets in link text by counting bracket depth\n        # TODO 3: Look for closing bracket followed by opening parenthesis\n        # TODO 4: Parse URL and optional title in parentheses\n        # TODO 5: Create InlineNode with InlineType.LINK or InlineType.IMAGE\n        # TODO 6: Recursively process inline formatting in link text\n        # TODO 7: Handle malformed links as literal text\n        pass\n    \n    def _match_emphasis_delimiters(self, closer: Delimiter) -> Optional[Tuple[int, Delimiter]]:\n        \"\"\"\n        Find matching opener for emphasis closer using CommonMark precedence.\n        \"\"\"\n        # TODO 1: Search delimiter stack backward for matching opener\n        # TODO 2: Apply precedence rules - longer sequences first\n        # TODO 3: Check delimiter type compatibility (asterisk vs underscore)\n        # TODO 4: Ensure opener can open and closer can close\n        # TODO 5: Return stack index and opener delimiter if found\n        pass\n    \n    def _create_emphasis_node(self, opener: Delimiter, closer: Delimiter, \n                            inner_content: str) -> InlineNode:\n        \"\"\"\n        Create emphasis node based on delimiter length and type.\n        \"\"\"\n        # TODO 1: Determine emphasis type based on delimiter length (1=em, 2=strong)\n        # TODO 2: Create InlineNode with appropriate InlineType\n        # TODO 3: Recursively parse inner content for nested formatting\n        # TODO 4: Set text_content and formatting_attributes\n        # TODO 5: Return completed InlineNode\n        pass\n```\n\n**Link and Image Parser (inline_elements.py):**\n\n```python\nimport re\nfrom typing import Optional, Tuple, Dict, Any\nfrom ..ast.inline_nodes import InlineNode, InlineType\n\nclass LinkImageParser:\n    def __init__(self):\n        # Regex patterns for URL and title parsing\n        self.url_pattern = re.compile(r'^[^\\s<>]*(?:\\s+\"[^\"]*\")?')\n        self.title_pattern = re.compile(r'\\s+\"([^\"]*)\"$')\n    \n    def parse_link_or_image(self, text: str, start_pos: int, \n                           is_image: bool) -> Optional[Tuple[InlineNode, int]]:\n        \"\"\"\n        Parse link or image syntax starting at given position.\n        \n        Returns:\n            Tuple of (InlineNode, end_position) if successful, None if malformed\n        \"\"\"\n        # TODO 1: Skip opening marker ([ or ![) and find link text\n        # TODO 2: Handle nested brackets in link text with bracket counting\n        # TODO 3: Verify closing bracket followed by opening parenthesis\n        # TODO 4: Parse URL and optional title from parentheses\n        # TODO 5: Create InlineNode with InlineType.LINK or InlineType.IMAGE\n        # TODO 6: Return node and position after closing parenthesis\n        pass\n    \n    def _find_link_text_end(self, text: str, start_pos: int) -> Optional[int]:\n        \"\"\"\n        Find the end of link text, handling nested brackets.\n        \"\"\"\n        # TODO 1: Track bracket nesting depth starting from 1\n        # TODO 2: Scan character by character, ignoring escaped brackets\n        # TODO 3: Increment depth on '[', decrement on ']'\n        # TODO 4: Return position when depth reaches 0\n        # TODO 5: Return None if no matching bracket found\n        pass\n    \n    def _parse_url_and_title(self, text: str) -> Tuple[str, Optional[str]]:\n        \"\"\"\n        Parse URL and optional title from parentheses content.\n        \"\"\"\n        # TODO 1: Apply regex to extract URL portion\n        # TODO 2: Check for optional title in quotes after URL\n        # TODO 3: Handle angle-bracket enclosed URLs\n        # TODO 4: Return tuple of (url, title) where title may be None\n        pass\n```\n\n#### Milestone Checkpoints\n\n**After completing emphasis parsing:**\n- Test command: `python -m pytest tests/test_inline_parser.py::test_emphasis -v`\n- Expected behavior: `**bold**` becomes `<strong>bold</strong>`, `*italic*` becomes `<em>italic</em>`\n- Manual verification: Create test file with `**bold *nested* text**` and verify nested structure\n- Debug check: Print delimiter stack contents to verify proper delimiter matching\n\n**After completing link parsing:**  \n- Test command: `python -m pytest tests/test_inline_parser.py::test_links -v`\n- Expected behavior: `[text](url)` becomes `<a href=\"url\">text</a>`\n- Manual verification: Test nested brackets `[link [with] brackets](url)` parses correctly\n- Debug check: Verify bracket counting logic handles nested cases\n\n**After completing code spans:**\n- Test command: `python -m pytest tests/test_inline_parser.py::test_code_spans -v`  \n- Expected behavior: `` `code` `` becomes `<code>code</code>`, content is literal\n- Manual verification: `` `*not emphasis*` `` should not format the asterisks\n- Debug check: Confirm code spans are processed before emphasis in pipeline\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Emphasis not nested correctly | Wrong delimiter precedence | Print delimiter stack during matching | Implement proper precedence rules in `_match_emphasis_delimiters` |\n| Underscores in words get formatted | Missing intraword underscore check | Test with `snake_case` input | Add alphanumeric flanking check to `can_open_emphasis` |\n| Links with brackets don't parse | Bracket counting bug | Log bracket depth during parsing | Fix bracket nesting logic in `_find_link_text_end` |\n| Code spans don't mask emphasis | Processing order wrong | Check if code spans processed first | Move code span processing to first pass |\n| Escaped characters still format | Escape processing timing | Verify escaped positions list | Process escapes before delimiter detection |\n| Memory usage grows on long text | Delimiter stack not cleaned | Monitor stack size during parsing | Clear stack between text segments |\n\n\n## List Parser Design\n\n> **Milestone(s):** Milestone 3: Lists\n\n### The Document Hierarchy Mental Model\n\nThink of list parsing like organizing a company's org chart from a messy pile of business cards. Each business card has a person's name and shows their reporting level through indentation - the CEO has no indentation, VPs have one level, directors have two levels, and so on. Your job is to reconstruct the proper hierarchical tree structure by carefully tracking indentation levels and understanding who reports to whom.\n\nJust like how a person can't report to someone at a lower level in the hierarchy, markdown list items follow strict nesting rules based on indentation. A list item indented 4 spaces can only be a child of an item indented 0-3 spaces, never a sibling or parent. The challenge is that unlike a clean org chart, the \"business cards\" (markdown lines) arrive in sequential order, and you must build the hierarchy incrementally while handling edge cases like missing intermediate levels or inconsistent indentation.\n\nThe fundamental insight is that **list parsing is inherently recursive and stateful** - each list item's position in the hierarchy depends not just on its own indentation, but on the context of all previous items and the current nesting stack. This requires maintaining a sophisticated understanding of the document's hierarchical state as parsing progresses.\n\n### List Parsing Algorithm\n\nThe list parsing algorithm operates as a **stateful hierarchy builder** that maintains a stack of active list contexts while processing lines sequentially. The core challenge is correctly interpreting indentation levels and determining when to create new nested lists versus continuing existing ones.\n\n![List Nesting and Indentation Handling](./diagrams/list-nesting-structure.svg)\n\n#### Phase 1: List Item Detection and Classification\n\nThe algorithm begins by identifying potential list items through marker detection. This phase involves examining each line to determine if it represents a list item and, if so, what type of list it belongs to.\n\n1. **Line Analysis**: Extract the line's leading whitespace to calculate the base indentation level using `get_indentation_level()`. Remove leading whitespace to examine the content that follows.\n\n2. **Marker Detection**: Check if the line begins with a valid list marker. For unordered lists, look for dash (`-`), asterisk (`*`), or plus (`+`) followed by at least one space. For ordered lists, look for a sequence of 1-9 digits followed by either a period (`.`) or closing parenthesis (`)`) and at least one space.\n\n3. **Marker Validation**: Verify that the marker is properly formatted. The marker must be followed by at least one space or tab, or be at the end of the line (creating an empty list item). Calculate the marker's consumed width to determine the content indentation.\n\n4. **Content Indentation Calculation**: Determine the indentation level for list item content by adding the base indentation to the marker width plus following spaces. This becomes the reference indentation for continuation lines.\n\n5. **List Type Determination**: Based on the marker type, classify the item as either ordered or unordered. For ordered lists, extract the starting number, though CommonMark specifies that the actual numbering in output starts from the first item's number.\n\n#### Phase 2: Hierarchy Management and Nesting\n\nOnce a list item is detected, the algorithm must determine its position in the document hierarchy and manage the nesting stack appropriately.\n\n1. **Context Stack Evaluation**: Compare the current item's indentation with the indentation levels stored in the active context stack. The context stack maintains information about currently open lists and their indentation levels.\n\n2. **Stack Unwinding**: If the current item's indentation is less than or equal to any level in the stack, unwind the stack by finalizing and closing list contexts until reaching an appropriate parent level. This handles cases where the nesting level decreases.\n\n3. **Sibling vs Child Determination**: If the indentation matches an existing level in the stack, create a sibling item at that level. If the indentation is greater than all existing levels but within valid nesting bounds, create a new child list.\n\n4. **New List Creation**: When starting a new nested level, create a new `BlockNode` with `block_type` set to `LIST`. Set the list type attribute (ordered/unordered) and add it as a child to the current list item. Push this new context onto the stack.\n\n5. **List Item Creation**: Create a `BlockNode` with `block_type` set to `LIST_ITEM`. Set the raw content as the text following the marker. Add this item to the current list context and mark it as the active item for potential continuation lines.\n\n#### Phase 3: Content Processing and Continuation\n\nList items can contain multiple lines of content, including nested paragraphs, code blocks, and other structural elements. The algorithm must handle these continuation patterns correctly.\n\n1. **Continuation Line Detection**: For each subsequent line, determine if it continues the current list item, starts a new list item, or terminates the list structure. This requires checking indentation against the current list item's content indentation level.\n\n2. **Content Type Classification**: Continuation lines may be simple paragraph text, blank lines (which affect tight vs loose list determination), or the beginning of nested block elements like code blocks or nested lists.\n\n3. **Lazy Continuation Handling**: CommonMark allows \"lazy continuation\" where continuation lines may have less indentation than required, as long as they don't start a new block element. Implement this by checking if under-indented lines could plausibly continue the current list item.\n\n4. **Nested Block Processing**: When continuation lines indicate nested block elements (like indented code blocks or nested blockquotes), delegate parsing to the appropriate block parser while maintaining the list context.\n\n5. **Tight vs Loose List Determination**: Track whether blank lines appear between list items or within list items. Lists containing blank lines become \"loose\" lists, which affects HTML output (loose lists wrap content in paragraph tags).\n\n### List Parser Architecture Decisions\n\nThe list parser's design involves several critical architectural decisions that affect both correctness and implementation complexity. Each decision involves trade-offs between parsing accuracy, implementation simplicity, and performance.\n\n> **Decision: Indentation Tracking Strategy**\n> - **Context**: List nesting requires precise indentation tracking, but markdown allows various indentation styles and lazy continuation. The parser needs to handle both strict CommonMark compliance and graceful degradation for malformed input.\n> - **Options Considered**: Character-level position tracking, space-count normalization, tab-expansion with configurable width\n> - **Decision**: Normalize tabs to spaces using 4-space tab stops, then track indentation as space counts with a tolerance mechanism for minor variations\n> - **Rationale**: Tab normalization eliminates ambiguity in mixed-indentation documents. Space counting provides precise nesting level determination. Tolerance allows graceful handling of minor indentation inconsistencies common in hand-written markdown.\n> - **Consequences**: Enables reliable nesting detection and CommonMark compliance. Requires upfront tab normalization. May mask some user errors that strict parsers would reject.\n\n| Indentation Strategy | Pros | Cons |\n|---------------------|------|------|\n| Character Position Tracking | Exact position preservation, handles mixed tabs/spaces | Complex logic, fragile with copy/paste |\n| Space Count Normalization | Simple integer arithmetic, robust | Loses original formatting intent |\n| Tab Expansion + Space Count | CommonMark compliant, predictable | Requires configuration, upfront processing |\n\n> **Decision: List Context Stack Management**\n> - **Context**: Nested lists require maintaining multiple active contexts simultaneously. The parser must track which lists are open, their types, indentation levels, and current state for proper nesting and termination.\n> - **Options Considered**: Recursive descent parsing, explicit context stack, state machine with embedded stack\n> - **Decision**: Explicit context stack with list metadata including indentation level, list type, tight/loose status, and parent references\n> - **Rationale**: Explicit stack provides clear visibility into nesting state for debugging. Metadata tracking enables correct CommonMark compliance for tight/loose lists. Parent references enable proper AST construction.\n> - **Consequences**: Simplifies nesting logic and makes state transitions explicit. Requires careful stack management and cleanup. Enables comprehensive error reporting with context.\n\n| Context Management | Pros | Cons |\n|--------------------|------|------|\n| Recursive Descent | Natural nesting representation, clean code | Stack overflow risk, complex backtracking |\n| Explicit Context Stack | Clear state visibility, controlled memory usage | Manual stack management, more bookkeeping |\n| State Machine + Stack | Systematic state handling, good error recovery | Complex state explosion, harder to debug |\n\n> **Decision: Tight vs Loose List Handling**\n> - **Context**: CommonMark distinguishes between tight lists (no blank lines) and loose lists (containing blank lines), which affects HTML output. Tight lists don't wrap content in paragraph tags, while loose lists do.\n> - **Options Considered**: Post-processing analysis, incremental tracking during parsing, defer decision to HTML generator\n> - **Decision**: Incremental tracking during parsing with list-level and item-level blank line flags stored in block attributes\n> - **Rationale**: Incremental tracking avoids expensive post-processing passes. List-level flags enable correct handling of mixed scenarios. Early determination enables better error messages and debugging.\n> - **Consequences**: Enables correct CommonMark-compliant output generation. Requires careful blank line tracking. Complicates list item processing logic slightly.\n\n| Tight/Loose Strategy | Pros | Cons |\n|---------------------|------|------|\n| Post-processing Analysis | Clean separation of concerns, simple parsing | Extra traversal pass, complex analysis logic |\n| Incremental Tracking | Single-pass efficiency, immediate feedback | Distributed logic, more state tracking |\n| HTML Generator Decision | Deferred complexity, flexible output control | Generator complexity, limited error reporting |\n\n#### List Type Consistency and Mixed Lists\n\nThe parser must handle scenarios where list markers change within what appears to be a single list. CommonMark specifies that different marker types or ordered/unordered mixing creates separate lists.\n\n> **Decision: Mixed List Marker Handling**\n> - **Context**: Users sometimes mix different list markers (`-`, `*`, `+`) or combine ordered and unordered items, expecting them to be part of the same list. CommonMark treats different markers as separate lists.\n> - **Options Considered**: Strict CommonMark compliance (separate lists), marker normalization (treat all as same), user configuration option\n> - **Decision**: Strict CommonMark compliance with clear error reporting when marker types change\n> - **Rationale**: Ensures predictable output consistent with other CommonMark parsers. Encourages consistent markdown authoring. Avoids ambiguity in complex nested scenarios.\n> - **Consequences**: May surprise users expecting mixed markers to work. Enables reliable round-trip parsing. Simplifies nesting logic significantly.\n\n#### Continuation Line Processing Strategy\n\nList items can contain multiple paragraphs, code blocks, and other complex content. The parser must distinguish between content that belongs to the current list item versus content that terminates the list.\n\n> **Decision: Continuation Line Classification**\n> - **Context**: Lines following list items may be continuation content, lazy continuation (under-indented but still belonging to the item), new list items, or content that terminates the list entirely.\n> - **Options Considered**: Strict indentation matching, lazy continuation support, lookahead-based classification\n> - **Decision**: Support lazy continuation with lookahead to distinguish from new block elements, using content indentation thresholds\n> - **Rationale**: Lazy continuation is part of CommonMark spec and matches user expectations. Lookahead prevents false positives where under-indented lines start new blocks. Thresholds provide clear rules for classification.\n> - **Consequences**: Enables natural authoring patterns users expect. Requires more complex line classification logic. May accept some ambiguous input that strict parsers reject.\n\n### List Parsing Common Pitfalls\n\nList parsing involves several subtle edge cases that frequently cause implementation errors. Understanding these pitfalls helps build robust parsers that handle real-world markdown correctly.\n\n⚠️ **Pitfall: Incorrect Indentation Calculation**\n\nMany implementations incorrectly calculate the indentation required for list item continuation by only considering the marker width, ignoring the base indentation of the list item itself. This leads to incorrect nesting decisions and malformed output.\n\nFor example, consider this markdown:\n```markdown\n  - Item with base indentation\n    Continuation line\n```\n\nThe continuation line requires 4 spaces total: 2 for the base indentation plus 2 for the marker and space. Implementations that only check for 2 spaces of indentation will incorrectly treat the continuation as a new paragraph outside the list.\n\n**Fix**: Always calculate continuation indentation as `base_indentation + marker_width + min_space_requirement`. Store this value when creating each list item and use it consistently for all continuation line checks.\n\n⚠️ **Pitfall: Mixed List Type Confusion**\n\nImplementations often incorrectly handle scenarios where ordered and unordered list markers appear at the same indentation level, either by treating them as the same list or by not properly closing the previous list before starting the new one.\n\n```markdown\n1. First ordered item\n- First unordered item\n2. Second ordered item?\n```\n\nThe unordered item should start a new list, and the final line should start yet another ordered list, not continue the first one.\n\n**Fix**: Track the list type (ordered/unordered) and marker style for each list context. When a different type or marker style is encountered at the same indentation level, finalize the current list and start a new one. Store list type in the context stack along with indentation information.\n\n⚠️ **Pitfall: Loose List Detection Errors**\n\nIncorrect handling of blank lines leads to wrong tight/loose list classification, causing HTML output that doesn't match CommonMark specification. The most common error is not distinguishing between blank lines that separate list items versus blank lines within list items.\n\n```markdown\n1. First item\n\n2. Second item\n   \n   With continuation paragraph\n```\n\nThis should be a loose list because of the blank line between items, and the continuation paragraph should be wrapped in `<p>` tags.\n\n**Fix**: Track blank lines at both the list level and item level. Set the loose flag when blank lines appear between list items or when any individual item contains blank lines. Propagate loose status to parent lists when nested loose lists are encountered.\n\n⚠️ **Pitfall: Lazy Continuation Boundary Errors**\n\nImplementations often incorrectly handle lazy continuation by either being too permissive (allowing continuation that should start new blocks) or too restrictive (requiring strict indentation that CommonMark doesn't mandate).\n\n```markdown\n- List item\nThis should continue the item\n  - But this starts a nested list\n```\n\nThe middle line is lazy continuation, but the final line starts a nested list despite being more indented than the continuation.\n\n**Fix**: Implement lookahead to check if under-indented lines could start new block elements. Use the `can_current_block_continue()` method to test if a line belongs to the current list item before accepting it as lazy continuation.\n\n⚠️ **Pitfall: Nested List Context Cleanup**\n\nFailing to properly clean up list contexts when nesting levels decrease leads to memory leaks and incorrect parent-child relationships in the AST. This often manifests as lists that never properly close or items that appear in the wrong parent list.\n\n```markdown\n- Level 1\n  - Level 2\n    - Level 3\n- Back to level 1\n```\n\nThe final item should close all nested contexts and return to the top level.\n\n**Fix**: Implement proper stack unwinding when indentation decreases. Use the `finalize_current_block()` method to close contexts and ensure proper parent-child relationships. Maintain parent references to enable correct AST construction.\n\n⚠️ **Pitfall: Empty List Item Handling**\n\nEmpty list items (markers followed by blank lines or end of input) often break parsing logic that assumes list items always have content. This leads to null pointer exceptions or malformed AST nodes.\n\n```markdown\n- First item\n- \n- Third item\n```\n\nThe middle item is empty but valid according to CommonMark.\n\n**Fix**: Create list item nodes even for empty items, using empty string content. Handle empty content gracefully in continuation processing and HTML generation. Set appropriate attributes to distinguish truly empty items from items with whitespace-only content.\n\n⚠️ **Pitfall: Ordered List Starting Number Confusion**\n\nMany implementations either ignore ordered list starting numbers entirely or incorrectly propagate them to nested lists. CommonMark specifies that ordered lists should start from the number specified in the first item, but nested lists always start from 1.\n\n```markdown\n3. Starting from three\n4. Next item\n   1. Nested starts from one\n   2. Continues normally\n5. Back to main sequence\n```\n\n**Fix**: Store the starting number from the first item in each ordered list context using `set_attribute('start_number', num)`. Reset to 1 for nested ordered lists. Pass starting numbers to the HTML generator for proper `<ol start=\"3\">` attribute generation.\n\n### Implementation Guidance\n\nThe list parser implementation requires careful coordination between indentation tracking, context management, and content processing. The following guidance provides practical patterns and utilities for building a robust list parser.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Indentation Tracking | String splitting + len() counting | Regular expressions with capture groups |\n| Context Stack | Python list with dict contexts | Custom ListContext class with methods |\n| Marker Detection | String startswith() + manual parsing | Compiled regex patterns with named groups |\n| Content Processing | Line-by-line state machine | Recursive descent with backtracking |\n| Tight/Loose Tracking | Boolean flags in context dict | Enumerated state with validation rules |\n\n#### Recommended File Structure\n\n```\nproject-root/\n  src/\n    markdown_parser/\n      __init__.py                ← main parser interface\n      preprocessor.py            ← line normalization and analysis\n      block_parser/\n        __init__.py             ← block parser interface\n        block_parser.py         ← main block parsing logic\n        list_parser.py          ← list-specific parsing logic (this component)\n        list_context.py         ← list context stack management\n        list_utils.py           ← indentation and marker utilities\n      ast_nodes.py              ← AST node definitions\n      common/\n        line_info.py            ← LineInfo and related utilities\n        patterns.py             ← regex patterns and constants\n```\n\n#### Infrastructure Starter Code (Complete and Ready to Use)\n\n**list_utils.py** - Indentation and marker detection utilities:\n\n```python\nimport re\nfrom typing import Optional, Tuple, NamedTuple\nfrom enum import Enum\n\nclass MarkerType(Enum):\n    UNORDERED_DASH = \"-\"\n    UNORDERED_ASTERISK = \"*\"\n    UNORDERED_PLUS = \"+\"\n    ORDERED_PERIOD = \".\"\n    ORDERED_PAREN = \")\"\n\nclass ListMarkerInfo(NamedTuple):\n    marker_type: MarkerType\n    is_ordered: bool\n    marker_width: int\n    content_indent: int\n    start_number: Optional[int] = None\n\n# Regex patterns for list marker detection\nUNORDERED_MARKER_PATTERN = re.compile(r'^( {0,3})([-*+])( +)')\nORDERED_MARKER_PATTERN = re.compile(r'^( {0,3})([1-9][0-9]{0,8})([.)])( +)')\n\ndef normalize_line_endings(text: str) -> str:\n    \"\"\"Convert all line endings to Unix format.\"\"\"\n    return text.replace('\\r\\n', '\\n').replace('\\r', '\\n')\n\ndef expand_tabs_to_spaces(text: str, tab_width: int = 4) -> str:\n    \"\"\"Expand tabs to spaces using specified tab width.\"\"\"\n    result = []\n    column = 0\n    for char in text:\n        if char == '\\t':\n            spaces_to_add = tab_width - (column % tab_width)\n            result.append(' ' * spaces_to_add)\n            column += spaces_to_add\n        else:\n            result.append(char)\n            if char == '\\n':\n                column = 0\n            else:\n                column += 1\n    return ''.join(result)\n\ndef get_indentation_level(line: str) -> int:\n    \"\"\"Count leading spaces in a line.\"\"\"\n    count = 0\n    for char in line:\n        if char == ' ':\n            count += 1\n        else:\n            break\n    return count\n\ndef detect_list_marker(line: str) -> Optional[ListMarkerInfo]:\n    \"\"\"Detect and parse list marker information from a line.\"\"\"\n    # Try unordered markers first\n    match = UNORDERED_MARKER_PATTERN.match(line)\n    if match:\n        base_indent = len(match.group(1))\n        marker_char = match.group(2)\n        spaces_after = len(match.group(3))\n        \n        marker_type_map = {\n            '-': MarkerType.UNORDERED_DASH,\n            '*': MarkerType.UNORDERED_ASTERISK, \n            '+': MarkerType.UNORDERED_PLUS\n        }\n        \n        marker_width = 1 + spaces_after\n        content_indent = base_indent + marker_width\n        \n        return ListMarkerInfo(\n            marker_type=marker_type_map[marker_char],\n            is_ordered=False,\n            marker_width=marker_width,\n            content_indent=content_indent\n        )\n    \n    # Try ordered markers\n    match = ORDERED_MARKER_PATTERN.match(line)\n    if match:\n        base_indent = len(match.group(1))\n        number_str = match.group(2)\n        delimiter = match.group(3)\n        spaces_after = len(match.group(4))\n        \n        marker_type = MarkerType.ORDERED_PERIOD if delimiter == '.' else MarkerType.ORDERED_PAREN\n        marker_width = len(number_str) + 1 + spaces_after\n        content_indent = base_indent + marker_width\n        \n        return ListMarkerInfo(\n            marker_type=marker_type,\n            is_ordered=True,\n            marker_width=marker_width,\n            content_indent=content_indent,\n            start_number=int(number_str)\n        )\n    \n    return None\n\ndef is_blank_line(line: str) -> bool:\n    \"\"\"Check if line contains only whitespace.\"\"\"\n    return len(line.strip()) == 0\n\ndef can_lazy_continue(line: str, required_indent: int) -> bool:\n    \"\"\"Check if a line can be lazy continuation of a list item.\"\"\"\n    if is_blank_line(line):\n        return True\n    \n    actual_indent = get_indentation_level(line)\n    \n    # Allow lazy continuation if not starting a new block element\n    if actual_indent < required_indent:\n        # Check if line could start a new list item\n        if detect_list_marker(line) is not None:\n            return False\n        \n        # Check for other block elements (simplified check)\n        stripped = line.lstrip()\n        if (stripped.startswith('#') or \n            stripped.startswith('>') or \n            stripped.startswith('```') or\n            stripped.startswith('---')):\n            return False\n        \n        return True\n    \n    return True\n```\n\n**list_context.py** - Context stack management:\n\n```python\nfrom typing import List, Optional, Dict, Any\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom ..ast_nodes import ASTNode, BlockNode, BlockType\nfrom .list_utils import MarkerType\n\nclass ListState(Enum):\n    TIGHT = \"tight\"\n    LOOSE = \"loose\"\n    UNDETERMINED = \"undetermined\"\n\n@dataclass\nclass ListContext:\n    \"\"\"Context information for an active list.\"\"\"\n    list_node: BlockNode\n    marker_type: MarkerType\n    base_indentation: int\n    content_indentation: int\n    is_ordered: bool\n    state: ListState = ListState.UNDETERMINED\n    start_number: Optional[int] = None\n    item_count: int = 0\n    current_item: Optional[BlockNode] = None\n    has_blank_lines: bool = False\n    \n    def add_item(self, item_node: BlockNode) -> None:\n        \"\"\"Add a new list item to this list.\"\"\"\n        self.list_node.add_child(item_node)\n        self.current_item = item_node\n        self.item_count += 1\n    \n    def mark_loose(self) -> None:\n        \"\"\"Mark this list as loose (containing blank lines).\"\"\"\n        self.state = ListState.LOOSE\n        self.list_node.set_attribute('tight', False)\n    \n    def finalize(self) -> None:\n        \"\"\"Finalize list state when parsing is complete.\"\"\"\n        if self.state == ListState.UNDETERMINED:\n            self.state = ListState.TIGHT\n            self.list_node.set_attribute('tight', True)\n        \n        if self.is_ordered and self.start_number is not None:\n            self.list_node.set_attribute('start', self.start_number)\n\nclass ListContextStack:\n    \"\"\"Manages the stack of active list contexts.\"\"\"\n    \n    def __init__(self):\n        self.contexts: List[ListContext] = []\n    \n    def current_context(self) -> Optional[ListContext]:\n        \"\"\"Get the current (top) list context.\"\"\"\n        return self.contexts[-1] if self.contexts else None\n    \n    def push_context(self, context: ListContext) -> None:\n        \"\"\"Push a new list context onto the stack.\"\"\"\n        self.contexts.append(context)\n    \n    def pop_context(self) -> Optional[ListContext]:\n        \"\"\"Pop and finalize the top context.\"\"\"\n        if self.contexts:\n            context = self.contexts.pop()\n            context.finalize()\n            return context\n        return None\n    \n    def unwind_to_indentation(self, target_indent: int) -> List[ListContext]:\n        \"\"\"Unwind contexts until reaching target indentation level.\"\"\"\n        finalized = []\n        while (self.contexts and \n               self.contexts[-1].base_indentation >= target_indent):\n            finalized.append(self.pop_context())\n        return finalized\n    \n    def find_context_for_indentation(self, indent: int) -> Optional[ListContext]:\n        \"\"\"Find the context that should contain an item at given indentation.\"\"\"\n        for context in reversed(self.contexts):\n            if context.base_indentation <= indent:\n                return context\n        return None\n    \n    def mark_all_loose(self) -> None:\n        \"\"\"Mark all contexts as loose (blank lines affect all levels).\"\"\"\n        for context in self.contexts:\n            context.mark_loose()\n    \n    def clear(self) -> List[ListContext]:\n        \"\"\"Clear all contexts and return them finalized.\"\"\"\n        finalized = []\n        while self.contexts:\n            finalized.append(self.pop_context())\n        return finalized\n```\n\n#### Core Logic Skeleton Code\n\n**list_parser.py** - Main list parsing logic:\n\n```python\nfrom typing import List, Optional, Iterator\nfrom ..ast_nodes import ASTNode, BlockNode, BlockType, NodeType\nfrom ..common.line_info import LineInfo\nfrom .list_context import ListContextStack, ListContext, ListState\nfrom .list_utils import (\n    detect_list_marker, get_indentation_level, is_blank_line,\n    can_lazy_continue, MarkerType, ListMarkerInfo\n)\n\nclass ListParser:\n    \"\"\"Handles parsing of ordered and unordered lists with nesting.\"\"\"\n    \n    def __init__(self):\n        self.context_stack = ListContextStack()\n        self.current_line_index = 0\n        self.lines: List[LineInfo] = []\n    \n    def parse_list_sequence(self, lines: List[LineInfo], start_index: int) -> tuple[List[BlockNode], int]:\n        \"\"\"\n        Parse a sequence of list items starting at the given index.\n        Returns (list_nodes, next_index) where next_index is the first line\n        that doesn't belong to any list.\n        \"\"\"\n        # TODO 1: Initialize parsing state with lines and starting index\n        # TODO 2: Process lines sequentially until no more list content\n        # TODO 3: Handle context stack cleanup and finalization\n        # TODO 4: Return completed list nodes and next line index\n        # Hint: Use process_line_for_lists() for each line\n        pass\n    \n    def process_line_for_lists(self, line: LineInfo) -> bool:\n        \"\"\"\n        Process a single line in the context of list parsing.\n        Returns True if the line was consumed by list parsing, False otherwise.\n        \"\"\"\n        # TODO 1: Check if line is blank and handle loose list marking\n        # TODO 2: Try to detect list marker using detect_list_marker()\n        # TODO 3: If marker found, handle as new list item with handle_list_item()\n        # TODO 4: If no marker, try continuation with try_list_continuation()\n        # TODO 5: If neither works, finalize contexts and return False\n        # Hint: Blank lines between items mark lists as loose\n        pass\n    \n    def handle_list_item(self, line: LineInfo, marker_info: ListMarkerInfo) -> None:\n        \"\"\"\n        Handle a line that contains a list marker.\n        Creates appropriate list structures and adds the item.\n        \"\"\"\n        # TODO 1: Calculate base indentation from line and marker info\n        # TODO 2: Determine if this starts new list or continues existing\n        # TODO 3: Unwind context stack if indentation decreased\n        # TODO 4: Create new list context if needed with create_list_context()\n        # TODO 5: Create list item node and add to current list\n        # TODO 6: Extract item content after marker and set content\n        # Hint: Use context_stack.find_context_for_indentation() to find parent\n        pass\n    \n    def try_list_continuation(self, line: LineInfo) -> bool:\n        \"\"\"\n        Try to continue the current list item with this line.\n        Returns True if line was consumed as continuation.\n        \"\"\"\n        # TODO 1: Check if any list contexts are active\n        # TODO 2: Get current context and required indentation\n        # TODO 3: Check if line meets continuation requirements\n        # TODO 4: Use can_lazy_continue() to allow lazy continuation\n        # TODO 5: Append line content to current item if valid continuation\n        # TODO 6: Handle blank lines within items (mark loose if needed)\n        # Hint: Continuation requires indentation >= context.content_indentation\n        pass\n    \n    def create_list_context(self, marker_info: ListMarkerInfo, base_indent: int) -> ListContext:\n        \"\"\"\n        Create a new list context for the given marker and indentation.\n        \"\"\"\n        # TODO 1: Create BlockNode with LIST block_type\n        # TODO 2: Set list attributes (ordered/unordered, marker type)\n        # TODO 3: If ordered list, set start number from marker_info\n        # TODO 4: Create ListContext with all required parameters\n        # TODO 5: Add list node to parent context if nesting\n        # TODO 6: Return the new context for pushing to stack\n        # Hint: Check if this is a nested list and attach to current item\n        pass\n    \n    def check_marker_compatibility(self, current_marker: MarkerType, new_marker: MarkerType) -> bool:\n        \"\"\"\n        Check if a new marker is compatible with the current list type.\n        Different markers or ordered/unordered mixing starts new lists.\n        \"\"\"\n        # TODO 1: Extract ordered/unordered status from both markers\n        # TODO 2: Return False if mixing ordered and unordered\n        # TODO 3: For ordered lists, check delimiter compatibility (. vs ))\n        # TODO 4: For unordered lists, allow any unordered marker mix\n        # TODO 5: Return True if markers can be in same list\n        # Hint: CommonMark allows mixing -, *, + but not ordered/unordered\n        pass\n    \n    def extract_item_content(self, line: str, marker_info: ListMarkerInfo) -> str:\n        \"\"\"\n        Extract the content portion of a list item line after the marker.\n        \"\"\"\n        # TODO 1: Calculate total prefix length (indentation + marker + spaces)\n        # TODO 2: Slice line content after the prefix\n        # TODO 3: Handle case where line ends immediately after marker\n        # TODO 4: Strip trailing whitespace but preserve internal spacing\n        # TODO 5: Return cleaned content string\n        # Hint: marker_info.content_indent tells you where content starts\n        pass\n    \n    def finalize_all_contexts(self) -> List[BlockNode]:\n        \"\"\"\n        Finalize all remaining list contexts and return root list nodes.\n        \"\"\"\n        # TODO 1: Get all contexts from stack using context_stack.clear()\n        # TODO 2: Finalize each context to set tight/loose attributes\n        # TODO 3: Collect root list nodes (those not nested in other lists)\n        # TODO 4: Return list of root nodes for adding to document\n        # Hint: Root nodes are those whose parent is not a list item\n        pass\n    \n    def handle_blank_line_in_lists(self) -> None:\n        \"\"\"\n        Handle blank lines that appear within list structures.\n        Marks lists as loose according to CommonMark rules.\n        \"\"\"\n        # TODO 1: Check if we're currently in any list context\n        # TODO 2: Mark current context as having blank lines\n        # TODO 3: Apply loose marking rules (blank between items vs within items)\n        # TODO 4: Use context_stack.mark_all_loose() if between items\n        # Hint: Blank lines between items make all parent lists loose\n        pass\n```\n\n#### Language-Specific Hints\n\n**Python Implementation Tips:**\n- Use `str.lstrip()` and `str.rstrip()` for whitespace handling, but be careful about internal spacing preservation\n- The `re` module's named groups (`(?P<name>...)`) make marker parsing more readable\n- List comprehensions can simplify context stack filtering: `[ctx for ctx in contexts if ctx.base_indentation < target]`\n- Use `dataclasses.dataclass` for context objects to get automatic `__init__` and `__repr__` methods\n- Python's `enumerate()` function helps track line numbers during processing\n- Use `collections.deque` if you need efficient line lookahead with `peek_next_line()` functionality\n\n**Regex Pattern Optimization:**\n- Compile regex patterns once at module level rather than recreating them for each line\n- Use raw strings (`r\"...\"`) for regex patterns to avoid double-escaping backslashes\n- Named capture groups improve code readability: `r\"^(?P<indent> {0,3})(?P<marker>[-*+])(?P<space> +)\"`\n- Consider using `re.VERBOSE` flag for complex patterns to allow comments and formatting\n\n#### Milestone Checkpoint\n\nAfter implementing the list parser component, verify correct functionality with these specific tests:\n\n**Test Command**: `python -m pytest tests/test_list_parser.py -v`\n\n**Expected Behaviors to Verify:**\n\n1. **Simple List Parsing**: \n   ```python\n   markdown = \"- Item 1\\n- Item 2\\n- Item 3\"\n   # Should produce ul with 3 li elements\n   ```\n\n2. **Nested List Structure**:\n   ```python\n   markdown = \"1. First\\n   - Nested\\n   - Items\\n2. Second\"  \n   # Should produce ol containing li with nested ul\n   ```\n\n3. **Tight vs Loose Lists**:\n   ```python\n   tight = \"- Item 1\\n- Item 2\"  # No blank lines\n   loose = \"- Item 1\\n\\n- Item 2\"  # Blank line between\n   # Tight should have tight=True, loose should have tight=False\n   ```\n\n4. **Mixed Indentation Handling**:\n   ```python\n   markdown = \"  - Indented list\\n    - Nested item\\n  - Back to level 1\"\n   # Should correctly track indentation levels and nesting\n   ```\n\n**Manual Verification Steps:**\n1. Run `python -c \"from markdown_parser import parse_to_html; print(parse_to_html('- Test\\n  - Nested'))\"`\n2. Check that nested lists produce proper `<ul><li>` structures with correct nesting\n3. Verify that ordered lists use `<ol start=\"N\">` when starting number is not 1\n4. Confirm that loose lists wrap item content in `<p>` tags while tight lists don't\n\n**Common Issues and Diagnostics:**\n- **Lists not nesting**: Check indentation calculation in `get_indentation_level()` and context stack management\n- **Wrong tight/loose detection**: Verify blank line tracking in `handle_blank_line_in_lists()`\n- **Mixed list problems**: Check `check_marker_compatibility()` logic for ordered/unordered mixing\n- **Content not continuing**: Debug `can_lazy_continue()` and continuation indentation requirements\n\n**Debug Output Helpers:**\nUse `debug_print_ast()` to visualize the parsed AST structure and verify correct parent-child relationships in nested lists. The output should show clear hierarchical structure with proper list and list-item nesting.\n\n\n## HTML Generator Design\n\n> **Milestone(s):** Milestone 4: HTML Generation\n\n### The Document Assembly Mental Model\n\nThink of HTML generation like assembling a piece of furniture from parsed instruction components. You have all the individual pieces (your AST nodes) with their specifications and relationships clearly defined, and now you need to transform them into the final assembled product (valid HTML) following precise construction rules. Just as furniture assembly requires the right tools (HTML escaping), the correct order of operations (depth-first traversal), and attention to detail (proper nesting and formatting), HTML generation requires systematic conversion of each AST component into its corresponding HTML representation while maintaining structural integrity.\n\nThe key insight is that HTML generation is fundamentally a **translation process** - you're converting from one structured representation (AST) to another (HTML markup) while preserving all the semantic meaning and relationships. This is different from parsing, which discovers structure from unstructured text. Here, the structure already exists and must be faithfully represented in a different format.\n\n![HTML Generation Tree Traversal](./diagrams/html-generation-traversal.svg)\n\n## HTML Generation Algorithm\n\nThe HTML generation process follows a systematic **depth-first tree traversal** pattern where each AST node is visited exactly once and converted to its corresponding HTML representation. This approach ensures that nested structures are properly handled and that parent-child relationships in the AST translate correctly to HTML element nesting.\n\nThe core algorithm operates through a **visitor pattern** where different node types trigger different rendering behaviors. This design allows for extensible rendering where new node types can be added without modifying the core traversal logic, and custom renderers can override specific element generation while preserving the overall structure.\n\n### Tree Traversal Algorithm Steps\n\nThe HTML generation follows these sequential steps for each node in the AST:\n\n1. **Node Type Identification**: Examine the current node's `node_type` and `block_type` or `inline_type` to determine the appropriate HTML element to generate. This dispatch mechanism routes each node to its specialized rendering logic.\n\n2. **Pre-processing Content Escaping**: Before generating any HTML tags, process the node's text content through the HTML escaping system. This step must occur before any inline parsing results are incorporated to avoid double-escaping scenarios.\n\n3. **Opening Tag Generation**: Create the appropriate opening HTML tag based on the node type. For block elements like headings, this involves tags like `<h1>` through `<h6>`. For inline elements, this includes tags like `<strong>`, `<em>`, or `<code>`. Self-closing elements like `<hr>` and `<img>` require special handling.\n\n4. **Attribute Application**: Apply any attributes stored in the node's `formatting_attributes` or `block_attributes` dictionaries. This includes `href` attributes for links, `src` and `alt` attributes for images, `class` attributes for code blocks with language specifications, and any custom attributes defined by extensions.\n\n5. **Child Node Recursive Processing**: For nodes with children in their `children` list, recursively invoke the HTML generation algorithm on each child node in order. This step maintains the depth-first traversal pattern and ensures proper nesting of HTML elements.\n\n6. **Content Integration**: Combine the processed child content with any direct text content from the current node. For leaf nodes, this involves directly including the escaped text content. For container nodes, this involves wrapping the child HTML with the current node's tags.\n\n7. **Closing Tag Generation**: Generate the appropriate closing HTML tag to match the opening tag created in step 3. Self-closing elements skip this step. Proper tag matching is critical for valid HTML output.\n\n8. **Output Formatting**: Apply consistent indentation and line breaks according to the configured pretty-printing rules. This step enhances human readability without affecting the semantic meaning of the generated HTML.\n\n### Node Type Rendering Mappings\n\nThe following table defines how each AST node type maps to HTML elements:\n\n| AST Node Type | HTML Element | Attributes | Special Handling |\n|---------------|--------------|------------|------------------|\n| `DOCUMENT` | `html` with `head`/`body` | `lang` from document attributes | Wrapper template generation |\n| `PARAGRAPH` | `p` | Standard block attributes | Tight list detection affects wrapping |\n| `HEADING` | `h1` through `h6` | `id` from heading text slug | Level determined by heading depth |\n| `CODE_BLOCK` | `pre` containing `code` | `class` for language hint | Preserve exact whitespace and line breaks |\n| `BLOCKQUOTE` | `blockquote` | Citation attributes if present | Recursive processing for nested quotes |\n| `HORIZONTAL_RULE` | `hr` | None (self-closing) | No content or children |\n| `LIST` | `ul` or `ol` | `start` attribute for ordered lists | Tight vs loose list content handling |\n| `LIST_ITEM` | `li` | Task list attributes for checkboxes | Paragraph wrapping based on list tightness |\n| `STRONG` | `strong` | None | Inline element with nested content |\n| `EMPHASIS` | `em` | None | Inline element with nested content |\n| `CODE` | `code` | None | Preserve inner whitespace exactly |\n| `LINK` | `a` | `href`, optional `title` | URL escaping and validation |\n| `IMAGE` | `img` | `src`, `alt`, optional `title` | Self-closing with required attributes |\n| `LINE_BREAK` | `br` | None (self-closing) | Hard line break representation |\n| `TEXT` | Raw text content | None | HTML entity escaping only |\n\n### Content Processing Pipeline\n\nEach node's content undergoes a multi-stage processing pipeline before becoming final HTML:\n\n1. **Raw Content Extraction**: Extract the `text_content` or `inline_content` from the node, handling None values gracefully by treating them as empty strings.\n\n2. **HTML Entity Escaping**: Apply HTML entity encoding to special characters using the `HTML_ESCAPE_TABLE` mapping. This prevents HTML injection and ensures proper display of literal angle brackets, ampersands, and quotes.\n\n3. **Whitespace Preservation**: For code blocks and inline code elements, preserve all whitespace exactly as it appears in the source. For other elements, normalize whitespace according to HTML conventions while respecting intentional line breaks.\n\n4. **URL Processing**: For link and image elements, validate and potentially transform URLs. This includes relative URL resolution, protocol validation, and optional URL rewriting for security or functionality purposes.\n\n5. **Inline Content Integration**: Combine processed text content with the HTML generated from child inline elements, maintaining the correct order and nesting relationships established during inline parsing.\n\n## HTML Generator Architecture Decisions\n\nThe HTML generator design involves several critical architectural decisions that affect correctness, performance, and extensibility. Each decision represents a trade-off between competing concerns and establishes patterns that influence the entire generation system.\n\n> **Decision: HTML Escaping Timing**\n> - **Context**: HTML special characters (&, <, >, \", ') must be escaped to prevent malformed output and security vulnerabilities, but escaping must occur at the right time to avoid double-escaping or interference with legitimate HTML tags.\n> - **Options Considered**: \n>   1. Escape during initial text parsing before AST construction\n>   2. Escape during HTML generation at the leaf node level\n>   3. Escape at the very end after all HTML is generated\n> - **Decision**: Escape during HTML generation at the leaf node level when processing text content\n> - **Rationale**: This timing ensures that all text content is properly escaped while allowing legitimate HTML tags generated by the renderer to remain unescaped. Early escaping would interfere with inline parsing delimiter detection, while late escaping would risk missing content or double-escaping already-processed elements.\n> - **Consequences**: Enables safe handling of user content while maintaining clean separation between content and markup. Requires careful implementation to ensure all text paths go through escaping logic.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Escape during parsing | Simple, happens once | Interferes with delimiter detection | No |\n| Escape during generation | Clean separation, no double-escaping | Must be applied consistently | **Yes** |\n| Escape after generation | Handles all content uniformly | Risk of escaping legitimate HTML tags | No |\n\n> **Decision: Self-Closing Tag Handling**\n> - **Context**: HTML5 has specific rules for self-closing tags like `<hr>`, `<br>`, and `<img>` that should not have closing tags, while container tags like `<p>` and `<div>` must have matching closing tags.\n> - **Options Considered**: \n>   1. Always generate closing tags and let browsers handle invalid combinations\n>   2. Maintain a list of self-closing tag names and handle them specially\n>   3. Use XHTML-style self-closing syntax (`<br />`) for all self-closing elements\n> - **Decision**: Maintain a list of self-closing tag names and generate HTML5-compliant output\n> - **Rationale**: Produces the most correct and standards-compliant HTML output. Modern validation tools and accessibility checkers expect proper self-closing tag usage. XHTML syntax is unnecessarily verbose for HTML5 output.\n> - **Consequences**: Requires maintaining an accurate list of self-closing tags but produces the highest quality output. Enables proper validation and compatibility with HTML processing tools.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Always generate closing tags | Simple implementation | Invalid HTML for self-closing elements | No |\n| Special handling by tag name | Correct HTML5 output | Requires tag name knowledge | **Yes** |\n| XHTML-style syntax | Valid in both HTML and XHTML | Unnecessarily verbose | No |\n\n> **Decision: Extensible Rendering Interface**\n> - **Context**: Users may want to customize HTML output for specific node types, add custom attributes, or integrate with template systems while maintaining the core generation logic.\n> - **Options Considered**: \n>   1. Hard-coded rendering with no customization options\n>   2. Callback-based system where users can override specific node type rendering\n>   3. Template-based system where HTML generation uses external templates\n> - **Decision**: Callback-based system with a renderer plugin interface\n> - **Rationale**: Provides flexibility for customization while maintaining performance and simplicity. Templates would add complexity and external dependencies, while hard-coded rendering would limit extensibility for advanced users.\n> - **Consequences**: Enables custom output formats and integration with existing systems. Requires careful interface design to maintain backward compatibility and performance.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Hard-coded rendering | Simple, fast, predictable | No customization possible | No |\n| Callback-based plugins | Flexible, maintains performance | Interface complexity | **Yes** |\n| Template-based system | Very flexible, familiar pattern | External dependencies, complexity | No |\n\n> **Decision: Pretty Printing Strategy**\n> - **Context**: Generated HTML can be output as minified (single line) for efficiency or pretty-printed (indented, multi-line) for human readability, with implications for file size, debugging, and processing speed.\n> - **Options Considered**: \n>   1. Always generate minified output for smallest size\n>   2. Always generate pretty-printed output for readability\n>   3. Configurable option with default to pretty-printed\n> - **Decision**: Configurable option with default to pretty-printed output\n> - **Rationale**: Development and debugging benefit significantly from readable HTML output, while production systems can opt for minified output when needed. The size difference is typically negligible for markdown-generated content compared to other web assets.\n> - **Consequences**: Adds slight complexity to the generator but provides significant developer experience benefits. Pretty-printing logic must be carefully implemented to avoid introducing semantic whitespace changes.\n\n| Option | Pros | Cons | Chosen? |\n|--------|------|------|---------|\n| Always minified | Smallest output, fastest generation | Difficult to debug | No |\n| Always pretty-printed | Easy debugging, readable output | Slightly larger files | No |\n| Configurable with pretty default | Best of both worlds | Additional complexity | **Yes** |\n\n### HTML Generation Component Responsibilities\n\nThe HTML generator consists of several specialized components, each with clearly defined responsibilities:\n\n| Component | Responsibilities | Dependencies | Output |\n|-----------|------------------|--------------|--------|\n| `HtmlRenderer` | Orchestrates overall generation process | AST root node, configuration | Complete HTML document string |\n| `NodeVisitor` | Implements depth-first tree traversal | AST node structure | Visits each node exactly once |\n| `TagGenerator` | Creates opening and closing HTML tags | Node type mappings, attributes | Individual HTML tags with attributes |\n| `ContentEscaper` | Applies HTML entity escaping to text | Escape mapping table | Safely escaped text content |\n| `AttributeProcessor` | Converts node attributes to HTML attributes | Node attribute dictionaries | Formatted attribute strings |\n| `PrettyPrinter` | Applies consistent formatting and indentation | Generated HTML string, formatting rules | Formatted HTML output |\n| `RendererPlugin` | Provides extensibility for custom output | Plugin interface, node context | Custom HTML for specific nodes |\n\n## HTML Generation Common Pitfalls\n\nHTML generation involves several subtle issues that can produce incorrect output or security vulnerabilities. Understanding these pitfalls is crucial for implementing a robust and secure markdown renderer.\n\n⚠️ **Pitfall: Double-Escaping HTML Entities**\n\nThe most common mistake in HTML generation is applying HTML entity escaping multiple times to the same content, resulting in output like `&amp;lt;` instead of `&lt;`. This occurs when text is escaped during parsing and then escaped again during HTML generation, or when already-escaped content from child nodes is re-escaped by parent nodes.\n\n**Why it's wrong**: Double-escaped content displays incorrectly to users. For example, the HTML entity `&lt;` should render as the `<` character, but `&amp;lt;` renders as the literal text `&lt;`.\n\n**How to avoid**: Implement escaping exactly once during HTML generation when processing leaf text nodes. Ensure that content returned by child node processing is already properly escaped and should not be re-escaped. Use clear data flow contracts where escaped and unescaped content are never mixed without explicit conversion.\n\n⚠️ **Pitfall: Incorrect Self-Closing Tag Syntax**\n\nMany implementations generate invalid HTML by either adding closing tags to self-closing elements (`<hr></hr>`) or forgetting closing tags for container elements. This produces HTML that may render inconsistently across browsers and fails validation.\n\n**Why it's wrong**: Invalid HTML can cause rendering differences between browsers, accessibility issues, and problems with HTML processing tools. Some browsers attempt to fix invalid markup automatically, leading to unpredictable results.\n\n**How to avoid**: Maintain an accurate list of HTML5 self-closing elements (`hr`, `br`, `img`, `input`, `area`, `base`, `col`, `embed`, `link`, `meta`, `source`, `track`, `wbr`) and handle them specially in tag generation logic. Use a clear distinction in code between self-closing and container element generation.\n\n⚠️ **Pitfall: Whitespace Semantic Changes**\n\nPretty-printing logic can inadvertently introduce or remove whitespace that has semantic meaning in HTML, particularly around inline elements where spaces between tags affect text layout and rendering.\n\n**Why it's wrong**: Adding or removing spaces between inline elements changes how text flows and displays. For example, `<strong>bold</strong> <em>italic</em>` renders differently than `<strong>bold</strong><em>italic</em>` - the first has a space between \"bold\" and \"italic\" while the second does not.\n\n**How to avoid**: Apply pretty-printing indentation only at block-level boundaries where whitespace is not semantically significant. Preserve exact spacing within and between inline elements. Test pretty-printed output against minified output to ensure semantic equivalence.\n\n⚠️ **Pitfall: Improper Attribute Value Escaping**\n\nHTML attributes have different escaping requirements than HTML content. Attribute values must escape quotes appropriately for the quote style used, and certain characters like newlines may need special handling or replacement.\n\n**Why it's wrong**: Unescaped quotes in attribute values can break HTML parsing by prematurely terminating the attribute value. This can lead to HTML injection vulnerabilities or malformed output.\n\n**How to avoid**: Use different escaping logic for attribute values than for HTML content. When using double quotes for attribute values, escape internal double quotes as `&quot;`. When using single quotes, escape internal single quotes as `&#39;`. Consider using double quotes consistently for all attributes to simplify escaping logic.\n\n⚠️ **Pitfall: Missing URL Validation and Escaping**\n\nLinks and images require special handling for their URL attributes, including proper percent-encoding and validation to prevent malformed URLs or potential security issues with javascript: or data: URLs.\n\n**Why it's wrong**: Invalid URLs can break page functionality or create security vulnerabilities. Unescaped special characters in URLs can cause parsing errors or unexpected behavior.\n\n**How to avoid**: Implement URL-specific validation and encoding for `href` and `src` attributes. Consider implementing configurable URL scheme filtering to block potentially dangerous protocols. Apply proper percent-encoding to URL components while preserving valid URL structure.\n\n⚠️ **Pitfall: Inconsistent List Handling**\n\nLists have complex rules around tight versus loose formatting, where tight lists render list items without paragraph tags while loose lists wrap list item content in paragraphs. Inconsistent handling produces incorrect HTML structure.\n\n**Why it's wrong**: Incorrect list formatting affects both visual appearance and semantic meaning. Screen readers and other assistive technologies rely on proper list structure for navigation and content understanding.\n\n**How to avoid**: Implement clear logic for determining list tightness based on blank lines between list items during parsing. Consistently apply paragraph wrapping rules based on the list's tight/loose status. Test with nested lists to ensure proper handling of mixed tight/loose scenarios.\n\n⚠️ **Pitfall: Plugin Interface State Pollution**\n\nWhen implementing extensible rendering through plugins, state sharing between the main renderer and plugins can cause unexpected interactions or side effects that affect subsequent rendering operations.\n\n**Why it's wrong**: State pollution can cause rendering inconsistencies, memory leaks, or unexpected behavior when plugins modify shared state. This makes the system unreliable and difficult to debug.\n\n**How to avoid**: Design plugin interfaces to be stateless where possible. Pass all necessary context as parameters rather than sharing mutable state. If state is required, use immutable data structures or clear ownership patterns where plugins cannot affect the main renderer's state.\n\n## Implementation Guidance\n\nThe HTML generation system requires careful coordination between several components while maintaining clean separation of concerns. The implementation focuses on correctness, security, and extensibility while providing clear debugging capabilities.\n\n### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| HTML Escaping | Built-in string replacement with escape table | `html` module with `html.escape()` function |\n| Tree Traversal | Recursive function with node type dispatch | Visitor pattern with abstract base classes |\n| Template System | String formatting with f-strings | `jinja2` or similar template engine |\n| Pretty Printing | Manual indentation tracking with string building | `xml.dom.minidom` for structured formatting |\n| Plugin System | Simple callback dictionary | Full plugin architecture with registration |\n| URL Validation | Basic regex pattern matching | `urllib.parse` with comprehensive validation |\n\n### Recommended File Structure\n\nThe HTML generator integrates into the overall project structure as the final stage of the parsing pipeline:\n\n```\nproject-root/\n  src/\n    markdown_renderer/\n      core/\n        ast_nodes.py              ← AST node definitions (from Data Model)\n        parser.py                 ← Main parser orchestration\n      parsers/\n        block_parser.py           ← Block-level parsing logic\n        inline_parser.py          ← Inline element parsing logic\n        list_parser.py            ← List parsing logic\n      generators/\n        html_generator.py         ← Main HTML generation logic (THIS COMPONENT)\n        html_escaper.py           ← HTML entity escaping utilities\n        tag_generator.py          ← HTML tag creation logic\n        pretty_printer.py         ← Output formatting utilities\n        renderer_plugins.py       ← Extensible rendering interface\n      utils/\n        html_utils.py             ← HTML-specific utility functions\n        url_validator.py          ← URL validation and encoding\n  tests/\n    test_html_generation.py       ← HTML generator test suite\n    test_escaping.py             ← Entity escaping test cases\n    test_plugins.py              ← Plugin system test cases\n  examples/\n    basic_usage.py               ← Simple HTML generation examples\n    custom_renderer.py           ← Plugin usage examples\n```\n\n### HTML Escaping Infrastructure (Complete Starter Code)\n\n```python\n\"\"\"HTML entity escaping utilities for safe content rendering.\"\"\"\nimport re\nfrom typing import Dict, Optional\n\n# Complete mapping of characters that must be escaped in HTML content\nHTML_ESCAPE_TABLE: Dict[str, str] = {\n    '&': '&amp;',    # Must be first to avoid double-escaping\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',   # More compatible than &apos;\n}\n\n# Separate mapping for HTML attribute values\nATTRIBUTE_ESCAPE_TABLE: Dict[str, str] = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '\\n': '&#10;',   # Newlines in attributes\n    '\\r': '&#13;',   # Carriage returns in attributes\n    '\\t': '&#9;',    # Tabs in attributes\n}\n\nclass HtmlEscaper:\n    \"\"\"Handles HTML entity escaping for content and attributes.\"\"\"\n    \n    def __init__(self):\n        # Pre-compile regex patterns for performance\n        self._content_pattern = re.compile('([' + ''.join(HTML_ESCAPE_TABLE.keys()) + '])')\n        self._attr_pattern = re.compile('([' + ''.join(ATTRIBUTE_ESCAPE_TABLE.keys()) + '])')\n    \n    def escape_content(self, text: str) -> str:\n        \"\"\"Escape text content for safe inclusion in HTML.\"\"\"\n        if not text:\n            return text\n        \n        def replace_char(match):\n            return HTML_ESCAPE_TABLE[match.group(1)]\n        \n        return self._content_pattern.sub(replace_char, text)\n    \n    def escape_attribute(self, value: str) -> str:\n        \"\"\"Escape attribute value for safe inclusion in HTML attributes.\"\"\"\n        if not value:\n            return value\n        \n        def replace_char(match):\n            return ATTRIBUTE_ESCAPE_TABLE[match.group(1)]\n        \n        return self._attr_pattern.sub(replace_char, value)\n    \n    def is_safe_url_scheme(self, url: str) -> bool:\n        \"\"\"Check if URL uses a safe scheme for links and images.\"\"\"\n        safe_schemes = {'http', 'https', 'ftp', 'mailto', 'tel'}\n        if ':' not in url:\n            return True  # Relative URLs are safe\n        \n        scheme = url.split(':', 1)[0].lower()\n        return scheme in safe_schemes\n\n# Global escaper instance for convenience\nhtml_escaper = HtmlEscaper()\n\ndef escape_html(text: str) -> str:\n    \"\"\"Convenience function for HTML content escaping.\"\"\"\n    return html_escaper.escape_content(text)\n\ndef escape_html_attribute(value: str) -> str:\n    \"\"\"Convenience function for HTML attribute escaping.\"\"\"\n    return html_escaper.escape_attribute(value)\n```\n\n### Pretty Printing Utilities (Complete Starter Code)\n\n```python\n\"\"\"Pretty printing utilities for formatted HTML output.\"\"\"\nfrom typing import List, Optional\nimport re\n\nclass HtmlPrettyPrinter:\n    \"\"\"Formats HTML output with consistent indentation and line breaks.\"\"\"\n    \n    def __init__(self, indent_size: int = 2, max_line_length: Optional[int] = None):\n        self.indent_size = indent_size\n        self.max_line_length = max_line_length\n        \n        # Elements that should have their content on the same line\n        self.inline_elements = {\n            'a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'button', 'cite', 'code', \n            'dfn', 'em', 'i', 'kbd', 'mark', 'q', 's', 'samp', 'small', \n            'span', 'strong', 'sub', 'sup', 'time', 'u', 'var'\n        }\n        \n        # Self-closing elements that don't have content\n        self.void_elements = {\n            'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input',\n            'link', 'meta', 'source', 'track', 'wbr'\n        }\n    \n    def format_html(self, html: str, start_indent: int = 0) -> str:\n        \"\"\"Format HTML string with proper indentation and line breaks.\"\"\"\n        if not html.strip():\n            return html\n        \n        lines = []\n        current_indent = start_indent\n        i = 0\n        \n        while i < len(html):\n            if html[i] == '<':\n                # Find the end of this tag\n                tag_end = html.find('>', i)\n                if tag_end == -1:\n                    # Malformed HTML - just add the rest as-is\n                    lines.append(' ' * (current_indent * self.indent_size) + html[i:])\n                    break\n                \n                tag_content = html[i:tag_end + 1]\n                \n                # Determine if this is a closing tag, self-closing tag, or opening tag\n                if tag_content.startswith('</'):\n                    # Closing tag - decrease indent before adding\n                    current_indent = max(0, current_indent - 1)\n                    lines.append(' ' * (current_indent * self.indent_size) + tag_content)\n                elif tag_content.endswith('/>') or self._is_void_element(tag_content):\n                    # Self-closing or void element - no indent change\n                    lines.append(' ' * (current_indent * self.indent_size) + tag_content)\n                else:\n                    # Opening tag - add then increase indent\n                    lines.append(' ' * (current_indent * self.indent_size) + tag_content)\n                    if not self._is_inline_element(tag_content):\n                        current_indent += 1\n                \n                i = tag_end + 1\n            else:\n                # Text content - find the next tag or end of string\n                next_tag = html.find('<', i)\n                if next_tag == -1:\n                    text_content = html[i:].strip()\n                else:\n                    text_content = html[i:next_tag].strip()\n                \n                if text_content:\n                    lines.append(' ' * (current_indent * self.indent_size) + text_content)\n                \n                i = next_tag if next_tag != -1 else len(html)\n        \n        return '\\n'.join(lines)\n    \n    def _extract_tag_name(self, tag_content: str) -> str:\n        \"\"\"Extract tag name from tag content like '<div class=\"foo\">' -> 'div'.\"\"\"\n        # Remove < and > brackets\n        tag_inner = tag_content[1:-1].strip()\n        if tag_inner.startswith('/'):\n            tag_inner = tag_inner[1:]\n        \n        # Split on whitespace to get just the tag name\n        return tag_inner.split()[0] if tag_inner else ''\n    \n    def _is_inline_element(self, tag_content: str) -> bool:\n        \"\"\"Check if tag represents an inline element.\"\"\"\n        tag_name = self._extract_tag_name(tag_content)\n        return tag_name in self.inline_elements\n    \n    def _is_void_element(self, tag_content: str) -> bool:\n        \"\"\"Check if tag represents a void (self-closing) element.\"\"\"\n        tag_name = self._extract_tag_name(tag_content)\n        return tag_name in self.void_elements\n\n# Global pretty printer instance\nhtml_pretty_printer = HtmlPrettyPrinter()\n\ndef format_html(html: str, indent_size: int = 2) -> str:\n    \"\"\"Convenience function for HTML pretty printing.\"\"\"\n    printer = HtmlPrettyPrinter(indent_size)\n    return printer.format_html(html)\n```\n\n### Core HTML Generation Logic (Skeleton with TODOs)\n\n```python\n\"\"\"Core HTML generation logic for converting AST to HTML.\"\"\"\nfrom typing import Dict, Any, List, Optional, Callable\nfrom abc import ABC, abstractmethod\n\nfrom ..core.ast_nodes import ASTNode, NodeType, BlockType, InlineType\nfrom .html_escaper import html_escaper\nfrom .pretty_printer import html_pretty_printer\n\nclass HtmlRenderer:\n    \"\"\"Main HTML generation class that converts AST to HTML output.\"\"\"\n    \n    def __init__(self, pretty_print: bool = True, custom_renderers: Optional[Dict[str, Callable]] = None):\n        self.pretty_print = pretty_print\n        self.custom_renderers = custom_renderers or {}\n        self.escaper = html_escaper\n        self.pretty_printer = html_pretty_printer if pretty_print else None\n    \n    def render_to_html(self, ast_root: ASTNode) -> str:\n        \"\"\"Convert AST to complete HTML document string.\"\"\"\n        # TODO 1: Check if ast_root is None or empty and return appropriate default\n        # TODO 2: Call render_node on the root to get the body content\n        # TODO 3: If pretty_print is enabled, format the output using pretty_printer\n        # TODO 4: Return the final HTML string\n        # Hint: Consider whether to wrap in full HTML document or just return content\n        pass\n    \n    def render_node(self, node: ASTNode) -> str:\n        \"\"\"Render a single AST node and all its children to HTML.\"\"\"\n        # TODO 1: Check if there's a custom renderer for this node type in self.custom_renderers\n        # TODO 2: If custom renderer exists, call it with the node and return result\n        # TODO 3: Dispatch to appropriate rendering method based on node.node_type\n        # TODO 4: If node_type is BLOCK, call render_block_node(node)\n        # TODO 5: If node_type is INLINE, call render_inline_node(node) \n        # TODO 6: If node_type is TEXT, call render_text_node(node)\n        # TODO 7: Handle unknown node types with graceful degradation\n        # Hint: Use a dispatch dictionary to map node types to methods\n        pass\n    \n    def render_block_node(self, node: ASTNode) -> str:\n        \"\"\"Render block-level elements like paragraphs, headings, lists.\"\"\"\n        # TODO 1: Extract block_type from node (it should be a BlockNode)\n        # TODO 2: Dispatch based on block_type using if/elif or dictionary lookup\n        # TODO 3: For PARAGRAPH: wrap children in <p> tags\n        # TODO 4: For HEADING: determine level and wrap in <h1>-<h6> tags  \n        # TODO 5: For CODE_BLOCK: wrap in <pre><code> with language class if present\n        # TODO 6: For BLOCKQUOTE: wrap in <blockquote> tags\n        # TODO 7: For HORIZONTAL_RULE: return <hr> (self-closing)\n        # TODO 8: For LIST: determine if ordered/unordered and wrap in <ol>/<ul>\n        # TODO 9: For LIST_ITEM: wrap in <li> tags, handle tight/loose list formatting\n        # TODO 10: Render all children and combine with appropriate wrapping\n        # Hint: Use get_attribute() to access block-specific data like heading level\n        pass\n    \n    def render_inline_node(self, node: ASTNode) -> str:\n        \"\"\"Render inline elements like emphasis, links, code spans.\"\"\"\n        # TODO 1: Extract inline_type from node (it should be an InlineNode)\n        # TODO 2: Dispatch based on inline_type\n        # TODO 3: For STRONG: wrap children in <strong> tags\n        # TODO 4: For EMPHASIS: wrap children in <em> tags  \n        # TODO 5: For CODE: wrap text_content in <code> tags, preserve whitespace\n        # TODO 6: For LINK: create <a> tag with href attribute, render children as link text\n        # TODO 7: For IMAGE: create <img> tag with src and alt attributes (self-closing)\n        # TODO 8: For LINE_BREAK: return <br> (self-closing)\n        # TODO 9: Apply HTML escaping to text content but not to child HTML\n        # TODO 10: Handle missing or invalid attributes gracefully\n        # Hint: Use formatting_attributes dictionary for link URLs, image sources, etc.\n        pass\n    \n    def render_text_node(self, node: ASTNode) -> str:\n        \"\"\"Render plain text nodes with proper HTML escaping.\"\"\"\n        # TODO 1: Extract text_content from the node\n        # TODO 2: Handle None or empty text content by returning empty string\n        # TODO 3: Apply HTML entity escaping using self.escaper.escape_content()\n        # TODO 4: Return the escaped text (no HTML tags for text nodes)\n        # Hint: This is where HTML injection prevention happens\n        pass\n    \n    def render_children(self, node: ASTNode) -> str:\n        \"\"\"Render all child nodes and concatenate their HTML.\"\"\"\n        # TODO 1: Check if node has children attribute and it's not None\n        # TODO 2: If no children, return empty string\n        # TODO 3: Iterate through node.children list\n        # TODO 4: Call render_node() recursively on each child\n        # TODO 5: Concatenate all child HTML strings\n        # TODO 6: Return the combined result\n        # Hint: Maintain the order of children as they appear in the list\n        pass\n    \n    def generate_tag(self, tag_name: str, attributes: Dict[str, str] = None, \n                    self_closing: bool = False) -> tuple[str, str]:\n        \"\"\"Generate opening and closing HTML tags with attributes.\"\"\"\n        # TODO 1: Start building opening tag with '<' + tag_name\n        # TODO 2: If attributes provided, iterate through them\n        # TODO 3: For each attribute, escape the value using escaper.escape_attribute()\n        # TODO 4: Add each attribute as ' key=\"escaped_value\"' to opening tag\n        # TODO 5: Close opening tag with '>' or '/>' if self_closing\n        # TODO 6: If self_closing, return (opening_tag, '') for empty closing tag\n        # TODO 7: If not self_closing, generate closing tag as '</' + tag_name + '>'\n        # TODO 8: Return tuple of (opening_tag, closing_tag)\n        # Hint: Check VOID_ELEMENTS list to determine if tag should be self-closing\n        pass\n\n# List of HTML void elements that should not have closing tags\nVOID_ELEMENTS = {\n    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input',\n    'link', 'meta', 'source', 'track', 'wbr'\n}\n\ndef render_ast_to_html(ast_root: ASTNode, pretty_print: bool = True) -> str:\n    \"\"\"Convenience function for rendering AST to HTML.\"\"\"\n    renderer = HtmlRenderer(pretty_print=pretty_print)\n    return renderer.render_to_html(ast_root)\n```\n\n### Plugin Interface Implementation (Complete Starter Code)\n\n```python\n\"\"\"Extensible rendering interface for custom HTML output.\"\"\"\nfrom typing import Protocol, Dict, Any, Optional, Callable\nfrom abc import ABC, abstractmethod\n\nfrom ..core.ast_nodes import ASTNode\n\nclass NodeRenderer(Protocol):\n    \"\"\"Protocol for custom node renderers.\"\"\"\n    \n    def render(self, node: ASTNode, default_renderer: Callable[[ASTNode], str]) -> str:\n        \"\"\"Render a node with access to the default rendering logic.\"\"\"\n        ...\n\nclass RendererPlugin(ABC):\n    \"\"\"Base class for renderer plugins.\"\"\"\n    \n    @abstractmethod\n    def get_supported_types(self) -> List[str]:\n        \"\"\"Return list of node types this plugin can render.\"\"\"\n        pass\n    \n    @abstractmethod\n    def render_node(self, node: ASTNode, context: Dict[str, Any]) -> str:\n        \"\"\"Render the given node type.\"\"\"\n        pass\n\nclass PluginManager:\n    \"\"\"Manages registration and execution of renderer plugins.\"\"\"\n    \n    def __init__(self):\n        self.plugins: Dict[str, RendererPlugin] = {}\n        self.node_renderers: Dict[str, NodeRenderer] = {}\n    \n    def register_plugin(self, plugin: RendererPlugin):\n        \"\"\"Register a plugin for specific node types.\"\"\"\n        for node_type in plugin.get_supported_types():\n            self.plugins[node_type] = plugin\n    \n    def register_node_renderer(self, node_type: str, renderer: NodeRenderer):\n        \"\"\"Register a simple node renderer function.\"\"\"\n        self.node_renderers[node_type] = renderer\n    \n    def has_renderer(self, node_type: str) -> bool:\n        \"\"\"Check if a custom renderer exists for the node type.\"\"\"\n        return node_type in self.plugins or node_type in self.node_renderers\n    \n    def render_node(self, node_type: str, node: ASTNode, \n                   context: Dict[str, Any], default_renderer: Callable) -> str:\n        \"\"\"Render node using custom renderer if available.\"\"\"\n        if node_type in self.node_renderers:\n            return self.node_renderers[node_type].render(node, default_renderer)\n        elif node_type in self.plugins:\n            return self.plugins[node_type].render_node(node, context)\n        else:\n            return default_renderer(node)\n\n# Example custom renderer for code blocks with syntax highlighting\nclass SyntaxHighlightRenderer(RendererPlugin):\n    \"\"\"Example plugin that adds syntax highlighting to code blocks.\"\"\"\n    \n    def get_supported_types(self) -> List[str]:\n        return ['CODE_BLOCK']\n    \n    def render_node(self, node: ASTNode, context: Dict[str, Any]) -> str:\n        # This is a simplified example - real syntax highlighting\n        # would integrate with libraries like Pygments\n        language = node.get_attribute('language', '')\n        content = self.escape_html(node.get_attribute('content', ''))\n        \n        if language:\n            return f'<pre><code class=\"language-{language} highlighted\">{content}</code></pre>'\n        else:\n            return f'<pre><code class=\"highlighted\">{content}</code></pre>'\n    \n    def escape_html(self, text: str) -> str:\n        \"\"\"Simple HTML escaping for code content.\"\"\"\n        return (text.replace('&', '&amp;')\n                   .replace('<', '&lt;')\n                   .replace('>', '&gt;')\n                   .replace('\"', '&quot;')\n                   .replace(\"'\", '&#x27;'))\n```\n\n### Milestone Checkpoint\n\nAfter implementing the HTML generator, verify your implementation with these checkpoints:\n\n1. **Basic HTML Generation Test**: Create a simple AST with a paragraph containing text and verify it generates `<p>escaped text content</p>`.\n\n2. **Escaping Verification**: Test that input containing `<script>` and other HTML special characters are properly escaped in the output.\n\n3. **Self-Closing Tags Test**: Verify that `<hr>` elements are generated without closing tags and `<img>` elements have proper `src` and `alt` attributes.\n\n4. **Pretty Printing Test**: Generate HTML with pretty printing enabled and verify consistent indentation and line breaks.\n\n5. **Plugin System Test**: Register a custom renderer for headings and verify it's called instead of the default renderer.\n\nExpected output for a basic test case:\n```html\n<h1>Test Heading</h1>\n<p>This is a paragraph with <strong>bold text</strong> and a <a href=\"http://example.com\">link</a>.</p>\n<hr>\n<pre><code class=\"language-python\">print(\"Hello, world!\")</code></pre>\n```\n\n### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Output contains `&amp;lt;` instead of `&lt;` | Double-escaping of content | Check if content is escaped multiple times | Apply escaping only once during HTML generation |\n| Invalid HTML with `<hr></hr>` tags | Self-closing elements getting closing tags | Verify void element list and tag generation logic | Add proper self-closing tag detection |\n| Missing spaces between inline elements | Pretty printer removing semantic whitespace | Compare pretty-printed vs minified output | Preserve whitespace around inline boundaries |\n| Links or images not working | Unescaped or invalid URLs in attributes | Inspect generated `href` and `src` attributes | Apply proper URL validation and attribute escaping |\n| Plugin not being called | Registration or dispatch logic issues | Add debug logging to plugin manager | Verify plugin registration and node type matching |\n| Malformed nested HTML | Incorrect tree traversal or tag matching | Print AST structure and trace rendering order | Fix recursive child rendering and tag pairing |\n\n\n## Interactions and Data Flow\n\n> **Milestone(s):** Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation\n\n### The Orchestra Conductor Mental Model\n\nThink of the markdown parsing pipeline like a symphony orchestra performing a complex piece. Each component—the block parser, inline parser, and HTML generator—is like a different section of the orchestra (strings, woodwinds, brass). The `MarkdownParser` acts as the conductor, coordinating when each section plays and ensuring the data flows smoothly from one to the next. Just as the conductor ensures the violins finish their phrase before the trumpets begin, the parser ensures each phase completes and passes clean, well-structured data to the next phase. The AST serves as the musical score—a shared representation that all components can read and contribute to.\n\nThe beauty of this orchestrated approach is that each component can focus on its specialized task without worrying about the complexities of other phases. The block parser doesn't need to understand emphasis rules, just as the first violin doesn't need to know the tuba part. But through careful coordination and clear interfaces, they work together to create something beautiful and coherent.\n\n### Complete Parsing Pipeline\n\nThe markdown parsing pipeline transforms raw text through four distinct phases, each building upon the work of the previous phase. This sequential approach mirrors how humans naturally process documents—first identifying the major structural elements, then focusing on the formatting details within those structures.\n\n#### Pipeline Phase Overview\n\nThe complete transformation follows this sequence:\n\n1. **Preprocessing Phase**: Raw markdown text undergoes normalization to ensure consistent line endings, tab expansion, and basic structural analysis\n2. **Block Parsing Phase**: Normalized text is analyzed line-by-line to identify and construct block-level elements like headings, paragraphs, and code blocks\n3. **Inline Parsing Phase**: Text content within block elements is processed to identify and construct inline formatting like emphasis, links, and inline code\n4. **HTML Generation Phase**: The completed AST is traversed to generate clean, properly escaped HTML output\n\n| Phase | Input Format | Output Format | Primary Responsibility | State Maintained |\n|-------|-------------|---------------|----------------------|------------------|\n| Preprocessing | Raw string | List of `LineInfo` objects | Text normalization, line analysis | None (stateless) |\n| Block Parsing | `LineInfo` objects | AST with block structure | Block element identification | `BlockParserState`, current block context |\n| Inline Parsing | Block nodes with raw text | AST with inline elements | Inline formatting identification | `DelimiterStack`, escape processing state |\n| HTML Generation | Complete AST | HTML string | Tree traversal and HTML generation | Rendering context, indentation state |\n\n#### Detailed Pipeline Flow\n\n**Preprocessing Phase**: The `Preprocessor` receives the raw markdown text and performs essential normalization operations. It calls `normalize_line_endings()` to convert all line endings to Unix format, ensuring consistent behavior across platforms. The `split_into_lines()` function then breaks the text into individual lines while preserving line number information for error reporting. Each line is analyzed using `is_blank_line()` and `get_indentation_level()` to create rich `LineInfo` objects that carry both content and metadata.\n\n> The preprocessing phase is crucial because it establishes the foundation for all subsequent parsing. By normalizing text encoding and capturing structural metadata early, we prevent countless edge cases that would otherwise plague the parsing phases.\n\n**Block Parsing Phase**: The block parser processes the `LineInfo` sequence through a state machine that identifies block-level structures. It maintains a `BlockParserState` that tracks whether it's currently inside a paragraph, code block, blockquote, or looking for a new block to start. The parser calls `peek_next_line()` to look ahead when necessary, particularly for Setext headings that require examining the following line. Each line triggers either `can_current_block_continue()` to extend the current block or one of the `try_start_*_block()` methods to begin a new block type.\n\nThe block parser builds the AST incrementally, creating `BlockNode` instances and establishing parent-child relationships through the `add_child()` method. When a block is complete, `finalize_current_block()` processes any remaining content and adds the block to the document tree.\n\n**Inline Parsing Phase**: Once the block structure is established, the inline parser processes the text content within each block element. It operates on individual text spans, typically paragraph content or heading text, using `parse_inline_elements()` as the main entry point. The parser maintains a `DelimiterStack` to track potential formatting markers as it scans through the text character by character.\n\nWhen the parser encounters potential delimiters like asterisks or underscores, it uses `detect_flanking_properties()` to determine whether the delimiter can open or close emphasis. The `find_matching_opener()` function searches back through the delimiter stack to find valid emphasis pairs. Links and images are handled through the `LinkImageParser`, which uses specialized regex patterns to extract URLs and alt text.\n\n**HTML Generation Phase**: The final phase traverses the complete AST using depth-first traversal to generate HTML output. The `HtmlRenderer` calls `render_node()` for each AST node, which delegates to specialized methods like `render_block_node()` and `render_inline_node()` based on the node type. The `HtmlEscaper` ensures all text content is properly escaped using `escape_html()`, while `generate_tag()` creates well-formed HTML elements with appropriate attributes.\n\n#### Pipeline Error Handling and Recovery\n\nEach phase implements graceful degradation when encountering malformed input. The preprocessing phase handles unusual line ending combinations and encoding issues by falling back to best-effort normalization. The block parser implements error recovery by treating unrecognized input as plain paragraph content. The inline parser handles mismatched delimiters by treating them as literal text. The HTML generator ensures output is always valid HTML, even when the AST contains unexpected structures.\n\n| Error Scenario | Detection Phase | Recovery Strategy | Output Impact |\n|----------------|-----------------|-------------------|---------------|\n| Invalid UTF-8 sequences | Preprocessing | Replace with Unicode replacement character | Minimal - content preserved |\n| Unclosed code fences | Block parsing | Treat as paragraph content | Moderate - formatting lost but readable |\n| Mismatched emphasis delimiters | Inline parsing | Render delimiters as literal text | Minimal - content fully preserved |\n| Malformed link syntax | Inline parsing | Render as plain text | Minimal - text content preserved |\n| Missing AST node types | HTML generation | Render as plain text with warning | Low - graceful fallback |\n\n#### Data Flow Contracts Between Phases\n\nEach pipeline phase establishes clear contracts for the data it receives and produces. These contracts ensure that phases can evolve independently while maintaining system integrity.\n\n**Preprocessing → Block Parsing Contract**: The preprocessor guarantees that line endings are normalized, tab characters are expanded to spaces using `expand_tabs_to_spaces()`, and each `LineInfo` object contains accurate `line_number`, `content`, `is_blank`, and `indent_level` fields. The block parser can rely on this normalized format and doesn't need to handle platform-specific text variations.\n\n**Block Parsing → Inline Parsing Contract**: The block parser guarantees that the AST contains a valid tree structure with proper parent-child relationships established through `add_child()` calls. Each `BlockNode` contains raw text content in its `inline_content` field that represents the content to be processed for inline elements. List items, headings, and paragraph blocks all provide their text content in a consistent format that the inline parser can process uniformly.\n\n**Inline Parsing → HTML Generation Contract**: The inline parser guarantees that all text content within block elements has been fully processed for inline formatting. The AST contains a complete representation of the document structure, with `InlineNode` instances properly nested within their containing blocks. The HTML generator can traverse this tree without needing to understand markdown syntax, focusing purely on HTML generation concerns.\n\n### Component Interface Contracts\n\nThe parsing pipeline depends on well-defined interfaces between components to maintain modularity and enable independent testing. These contracts specify not just method signatures but also preconditions, postconditions, and behavioral guarantees.\n\n#### MarkdownParser Primary Interface\n\nThe `MarkdownParser` serves as the main orchestrator, providing the primary entry points that applications use to transform markdown text into HTML.\n\n| Method Name | Parameters | Returns | Description | Preconditions | Postconditions |\n|-------------|------------|---------|-------------|---------------|----------------|\n| `parse_to_html` | `markdown_text: str` | `str` | Complete markdown to HTML transformation | Text must be valid Unicode string | Returns valid HTML5 document fragment |\n| `parse_file` | `file_path: str` | `str` | File-based parsing with error handling | File must exist and be readable | Returns HTML or raises IOException |\n| `debug_print_ast` | `node: ASTNode, indent: int` | `None` | Display AST structure for debugging | Node must be valid AST structure | Prints tree to stdout |\n\nThe `parse_to_html()` method orchestrates the entire pipeline. It first calls the preprocessor's `process_input()` method to normalize the input text. The resulting `LineInfo` objects are passed to the block parser's `parse_blocks()` method, which returns an AST with block structure. Each block node's text content is then processed by the inline parser's `parse_inline_elements()` method. Finally, the complete AST is passed to the HTML generator's `render_to_html()` method.\n\n> **Decision: Sequential Pipeline Architecture**\n> - **Context**: We need to coordinate multiple parsing phases that have dependencies on each other's output\n> - **Options Considered**: \n>   1. Monolithic parser that handles all concerns simultaneously\n>   2. Sequential pipeline with clear phase boundaries\n>   3. Concurrent pipeline with synchronization points\n> - **Decision**: Sequential pipeline with clear phase boundaries\n> - **Rationale**: Block parsing must complete before inline parsing can begin, since inline parsing depends on knowing the block context. This natural dependency makes sequential processing the most straightforward approach. The overhead of multiple passes is minimal compared to the complexity savings.\n> - **Consequences**: Enables clear separation of concerns and independent testing of each phase, but requires multiple passes through the document structure\n\n#### Preprocessor Interface Contract\n\nThe `Preprocessor` provides text normalization services that prepare raw markdown for block parsing. This component handles platform differences and encoding issues that would otherwise complicate the parsing phases.\n\n| Method Name | Parameters | Returns | Description | Guarantees |\n|-------------|------------|---------|-------------|------------|\n| `process_input` | `text: str` | `List[LineInfo]` | Convert raw text to analyzed lines | Line endings normalized, indentation calculated |\n| `normalize_line_endings` | `text: str` | `str` | Convert all line endings to Unix format | Only \\n line endings in output |\n| `split_into_lines` | `text: str` | `List[str]` | Split text preserving empty lines | Line count preserved, no content lost |\n| `expand_tabs_to_spaces` | `text: str, tab_width: int` | `str` | Convert tabs to spaces | Tab stops respect CommonMark spec |\n\nThe `process_input()` method serves as the main entry point, combining all normalization operations into a single call. It ensures that downstream components receive consistent, well-formed input regardless of the original text encoding or platform conventions.\n\n#### Block Parser Interface Contract\n\nThe block parser transforms normalized text into an AST representing the document's block structure. This component implements the most complex parsing logic, handling state transitions and lookahead requirements.\n\n| Method Name | Parameters | Returns | Description | State Changes |\n|-------------|------------|---------|-------------|---------------|\n| `parse_blocks` | `markdown_text: str` | `ASTNode` | Main block parsing entry point | Creates new parser state |\n| `process_line_sequence` | `lines: List[LineInfo]` | `None` | Process lines through state machine | Updates `BlockParserState` |\n| `peek_next_line` | None | `Optional[LineInfo]` | Look ahead without consuming | No state changes |\n| `can_current_block_continue` | `line: LineInfo` | `bool` | Check if line extends current block | No state changes |\n| `try_start_heading_block` | `line: LineInfo` | `bool` | Attempt to create heading block | May create new block |\n| `try_start_code_block` | `line: LineInfo` | `bool` | Attempt to create code block | May create new block |\n| `try_start_blockquote` | `line: LineInfo` | `bool` | Attempt to create blockquote | May create new block |\n| `try_start_horizontal_rule` | `line: LineInfo` | `bool` | Attempt to create horizontal rule | May create new block |\n| `start_paragraph_block` | `line: LineInfo` | `None` | Start paragraph with given line | Creates paragraph block |\n| `continue_current_block` | `line: LineInfo` | `None` | Add line to active block | Updates current block content |\n| `finalize_current_block` | None | `None` | Complete current block | Adds block to AST, resets state |\n\nThe block parser maintains internal state through the `BlockParserState` enum, which tracks whether the parser is looking for a new block, continuing a paragraph, or inside a specialized block like a code block or blockquote. The `try_start_*_block()` methods implement the block recognition logic, checking line patterns against the various block type signatures defined in the CommonMark specification.\n\n> The block parser's lookahead capability through `peek_next_line()` is essential for handling Setext headings, where a line's meaning depends on the following line. This lookahead is implemented without consuming the line from the input stream, allowing the parser to make decisions while preserving the sequential processing model.\n\n#### Inline Parser Interface Contract\n\nThe inline parser processes text content within block elements to identify and construct inline formatting elements. This component handles the complex delimiter matching required for nested emphasis and link parsing.\n\n| Method Name | Parameters | Returns | Description | State Management |\n|-------------|------------|---------|-------------|------------------|\n| `parse_inline_elements` | `text: str` | `List[InlineNode]` | Main inline parsing entry point | Creates fresh delimiter stack |\n| `process_escapes` | `text: str` | `Tuple[str, List[int]]` | Process escape sequences | Returns processed text and positions |\n| `detect_flanking_properties` | `text: str, pos: int, delimiter_len: int` | `Tuple[bool, bool]` | Detect opener/closer capability | No state changes |\n| `find_matching_opener` | `closer: Delimiter` | `Optional[Tuple[int, Delimiter]]` | Find matching emphasis opener | Searches delimiter stack |\n| `can_open_emphasis` | `char: str, left_flanking: bool, right_flanking: bool, before_char: str, after_char: str` | `bool` | Check if delimiter can open | Uses flanking detection rules |\n| `can_close_emphasis` | `char: str, left_flanking: bool, right_flanking: bool, before_char: str, after_char: str` | `bool` | Check if delimiter can close | Uses flanking detection rules |\n\nThe inline parser uses a `DelimiterStack` to track potential formatting markers as it processes text character by character. When it encounters asterisks, underscores, or other delimiter characters, it pushes them onto the stack with metadata about their flanking properties. When it finds potential closing delimiters, it searches backward through the stack to find matching openers.\n\nThe `LinkImageParser` component handles the complex regular expression matching required for link and image syntax. It maintains compiled patterns for URL detection and title extraction, ensuring efficient processing of link-heavy documents.\n\n#### HTML Generator Interface Contract\n\nThe HTML generator traverses the completed AST to produce clean, well-formatted HTML output. This component handles HTML escaping, tag generation, and pretty printing concerns.\n\n| Method Name | Parameters | Returns | Description | Output Guarantees |\n|-------------|------------|---------|-------------|-------------------|\n| `render_to_html` | `ast_root: ASTNode` | `str` | Main HTML generation entry point | Valid HTML5 fragment |\n| `render_node` | `node: ASTNode` | `str` | Render single AST node | Properly escaped HTML |\n| `render_block_node` | `node: BlockNode` | `str` | Render block-level elements | Block-level HTML tags |\n| `render_inline_node` | `node: InlineNode` | `str` | Render inline elements | Inline HTML tags |\n| `render_text_node` | `node: ASTNode` | `str` | Render plain text with escaping | HTML entity escaped text |\n| `render_children` | `node: ASTNode` | `str` | Render all child nodes | Concatenated child HTML |\n| `generate_tag` | `tag_name: str, attributes: dict, self_closing: bool` | `Tuple[str, str]` | Create HTML tag pair | Well-formed opening/closing tags |\n| `escape_html` | `text: str` | `str` | Escape special characters | HTML entity escaped output |\n| `escape_html_attribute` | `value: str` | `str` | Escape attribute values | Attribute-safe escaped text |\n| `format_html` | `html: str, indent_size: int` | `str` | Pretty print HTML output | Indented, formatted HTML |\n\nThe HTML generator implements the visitor pattern for tree traversal, calling the appropriate `render_*_node()` method based on each node's type. The `HtmlEscaper` component handles the critical security concern of properly escaping user content to prevent HTML injection attacks.\n\n> **Decision: Visitor Pattern for HTML Generation**\n> - **Context**: Need to traverse an AST with multiple node types and generate appropriate HTML for each type\n> - **Options Considered**:\n>   1. Switch statement based on node type in single method\n>   2. Visitor pattern with specialized methods for each node type\n>   3. Node-specific render methods on each AST node class\n> - **Decision**: Visitor pattern with specialized render methods\n> - **Rationale**: Keeps rendering logic centralized in the HTML generator while allowing easy extension for new node types. Avoids polluting AST nodes with rendering concerns.\n> - **Consequences**: Clear separation of concerns and easy testing, but requires coordinated changes when adding new node types\n\n#### Plugin and Extension Interface\n\nThe HTML generator supports customization through a plugin interface that allows users to override rendering behavior for specific node types.\n\n| Method Name | Parameters | Returns | Description | Extension Point |\n|-------------|------------|---------|-------------|-----------------|\n| `register_plugin` | `plugin: RendererPlugin` | `None` | Register custom renderer plugin | Adds to plugin registry |\n| `register_node_renderer` | `node_type: str, renderer: NodeRenderer` | `None` | Register simple node renderer | Overrides default rendering |\n| `has_renderer` | `node_type: str` | `bool` | Check for custom renderer | Query capability |\n\nThe `PluginManager` maintains a registry of custom renderers that can override the default HTML generation for specific node types. This allows applications to customize output format (e.g., generating LaTeX instead of HTML) or add special handling for domain-specific markdown extensions.\n\n#### Error Propagation and Recovery Contracts\n\nEach component defines clear error handling contracts that specify when errors are recoverable versus when they should propagate to the caller.\n\n| Component | Recoverable Errors | Non-Recoverable Errors | Recovery Strategy |\n|-----------|-------------------|------------------------|-------------------|\n| Preprocessor | Unusual line endings, mixed encodings | Invalid UTF-8, null input | Best-effort normalization |\n| Block Parser | Unclosed blocks, invalid syntax | Null input, corrupted AST | Treat as paragraph content |\n| Inline Parser | Mismatched delimiters, malformed links | Null text, invalid AST nodes | Render as literal text |\n| HTML Generator | Unknown node types, missing attributes | Null AST, circular references | Default rendering with warnings |\n\nThis error handling strategy ensures that the parser exhibits graceful degradation—it always produces some meaningful output, even when the input contains syntax errors or unexpected constructs.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Implementation | Advanced Implementation |\n|-----------|----------------------|-------------------------|\n| Main Parser | Single class with delegation methods | Factory pattern with dependency injection |\n| AST Representation | Simple dataclass/struct with lists | Immutable nodes with persistent data structures |\n| Error Handling | Exception propagation with try/catch | Result/Either types with error accumulation |\n| Plugin System | Dictionary of callable functions | Full plugin architecture with lifecycle management |\n| Testing Infrastructure | unittest with manual test data | Property-based testing with generated inputs |\n\n#### Recommended File Structure\n\n```\nmarkdown_renderer/\n  __init__.py                    ← Public API exports\n  parser.py                      ← Main MarkdownParser class\n  preprocessor.py                ← Text normalization utilities\n  ast_nodes.py                   ← AST node type definitions\n  block_parser.py               ← Block parsing implementation\n  inline_parser.py              ← Inline parsing implementation\n  html_generator.py             ← HTML generation and rendering\n  plugins/\n    __init__.py                 ← Plugin interface definitions\n    base_plugin.py              ← Abstract base classes\n  utils/\n    __init__.py\n    line_info.py                ← LineInfo and text utilities\n    html_escaping.py            ← HTML escaping utilities\n    constants.py                ← Regex patterns and constants\n  tests/\n    test_integration.py         ← End-to-end pipeline tests\n    test_parser_orchestration.py ← Component interaction tests\n    test_error_handling.py      ← Error recovery tests\n```\n\n#### Main Parser Infrastructure Code\n\n```python\n# parser.py - Complete main orchestrator implementation\nfrom typing import Optional, List, Union, Protocol\nimport re\nfrom dataclasses import dataclass\n\nfrom .preprocessor import Preprocessor\nfrom .block_parser import BlockParser\nfrom .inline_parser import InlineParser\nfrom .html_generator import HtmlRenderer\nfrom .ast_nodes import ASTNode, NodeType\nfrom .utils.line_info import LineInfo\n\nclass MarkdownParser:\n    \"\"\"Main parser that orchestrates the complete markdown to HTML pipeline.\"\"\"\n    \n    def __init__(self, \n                 pretty_print: bool = True,\n                 enable_plugins: bool = False):\n        \"\"\"Initialize the markdown parser with component dependencies.\n        \n        Args:\n            pretty_print: Whether to format HTML output with indentation\n            enable_plugins: Whether to load and enable plugin system\n        \"\"\"\n        self.preprocessor = Preprocessor()\n        self.block_parser = BlockParser()\n        self.inline_parser = InlineParser()\n        self.html_generator = HtmlRenderer(\n            pretty_print=pretty_print,\n            custom_renderers={} if not enable_plugins else None\n        )\n        \n    def parse_to_html(self, markdown_text: str) -> str:\n        \"\"\"Transform markdown text to HTML through complete pipeline.\n        \n        Args:\n            markdown_text: Raw markdown content as Unicode string\n            \n        Returns:\n            Valid HTML5 document fragment\n            \n        Raises:\n            ValueError: If input is None or contains invalid UTF-8\n        \"\"\"\n        if markdown_text is None:\n            raise ValueError(\"Markdown text cannot be None\")\n            \n        try:\n            # Phase 1: Preprocess and normalize input\n            line_info_list = self.preprocessor.process_input(markdown_text)\n            \n            # Phase 2: Parse block structure\n            ast_root = self.block_parser.parse_blocks(line_info_list)\n            \n            # Phase 3: Parse inline elements within blocks\n            self._process_inline_content(ast_root)\n            \n            # Phase 4: Generate HTML output\n            return self.html_generator.render_to_html(ast_root)\n            \n        except Exception as e:\n            # Log error and attempt graceful degradation\n            return f\"<p>Error processing markdown: {self._escape_error_message(str(e))}</p>\"\n    \n    def parse_file(self, file_path: str) -> str:\n        \"\"\"Parse markdown file and return HTML.\n        \n        Args:\n            file_path: Path to markdown file\n            \n        Returns:\n            HTML string or error message\n            \n        Raises:\n            IOError: If file cannot be read\n        \"\"\"\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n            return self.parse_to_html(content)\n        except IOError as e:\n            raise IOError(f\"Cannot read file {file_path}: {e}\")\n    \n    def debug_print_ast(self, node: ASTNode, indent: int = 0) -> None:\n        \"\"\"Print AST structure for debugging purposes.\n        \n        Args:\n            node: Root node to print\n            indent: Current indentation level\n        \"\"\"\n        indent_str = \"  \" * indent\n        node_info = f\"{node.node_type.value}\"\n        \n        if hasattr(node, 'block_type'):\n            node_info += f\" ({node.block_type.value})\"\n        elif hasattr(node, 'inline_type'):\n            node_info += f\" ({node.inline_type.value})\"\n            \n        print(f\"{indent_str}{node_info}\")\n        \n        for child in node.children:\n            self.debug_print_ast(child, indent + 1)\n    \n    def _process_inline_content(self, ast_root: ASTNode) -> None:\n        \"\"\"Process inline content for all applicable block nodes.\"\"\"\n        # TODO 1: Traverse AST using depth_first_walk with inline processing visitor\n        # TODO 2: For each block node, check if it contains inline content\n        # TODO 3: Call inline_parser.parse_inline_elements on block's text content\n        # TODO 4: Replace block's text content with parsed inline node children\n        # TODO 5: Handle error cases where inline parsing fails\n        pass\n        \n    def _escape_error_message(self, message: str) -> str:\n        \"\"\"Escape error message for safe HTML inclusion.\"\"\"\n        return (message.replace('&', '&amp;')\n                      .replace('<', '&lt;')\n                      .replace('>', '&gt;')\n                      .replace('\"', '&quot;'))\n\n# Public API convenience functions\ndef parse_to_html(markdown_text: str, pretty_print: bool = True) -> str:\n    \"\"\"Convenience function for simple markdown to HTML conversion.\"\"\"\n    parser = MarkdownParser(pretty_print=pretty_print)\n    return parser.parse_to_html(markdown_text)\n\ndef parse_file(file_path: str, pretty_print: bool = True) -> str:\n    \"\"\"Convenience function for file-based markdown conversion.\"\"\"\n    parser = MarkdownParser(pretty_print=pretty_print)\n    return parser.parse_file(file_path)\n```\n\n![System Component Architecture](./diagrams/system-components.svg)\n\n#### Pipeline Orchestration Skeleton\n\n```python\n# pipeline.py - Core pipeline coordination logic (implement this)\nfrom typing import List, Iterator\nfrom .ast_nodes import ASTNode, BlockNode, NodeType\nfrom .utils.line_info import LineInfo\n\nclass PipelineOrchestrator:\n    \"\"\"Coordinates the flow of data between parsing phases.\"\"\"\n    \n    def execute_complete_pipeline(self, \n                                 raw_text: str,\n                                 preprocessor,\n                                 block_parser,\n                                 inline_parser,\n                                 html_generator) -> str:\n        \"\"\"Execute complete parsing pipeline with error recovery.\n        \n        This is the core implementation you need to complete.\n        \"\"\"\n        # TODO 1: Validate input text is not None/empty\n        # TODO 2: Call preprocessor.process_input() to get LineInfo list\n        # TODO 3: Call block_parser.parse_blocks() with LineInfo list\n        # TODO 4: Walk through AST calling process_block_inline_content()\n        # TODO 5: Call html_generator.render_to_html() on completed AST\n        # TODO 6: Handle any exceptions with graceful degradation\n        # TODO 7: Return final HTML string\n        pass\n    \n    def process_block_inline_content(self, \n                                   block_node: BlockNode, \n                                   inline_parser) -> None:\n        \"\"\"Process inline content within a single block node.\"\"\"\n        # TODO 1: Check if block_node has inline_content field\n        # TODO 2: Skip processing if content is empty or None\n        # TODO 3: Call inline_parser.parse_inline_elements() on content\n        # TODO 4: Add returned InlineNode objects as children to block_node\n        # TODO 5: Clear the inline_content field since it's now parsed\n        # TODO 6: Recursively process any child blocks\n        pass\n    \n    def validate_pipeline_state(self, \n                               ast_root: ASTNode) -> List[str]:\n        \"\"\"Validate AST structure before HTML generation.\"\"\"\n        # TODO 1: Check that ast_root is not None and has valid node_type\n        # TODO 2: Verify all BlockNode objects have either children or content\n        # TODO 3: Verify all parent-child relationships are bidirectional\n        # TODO 4: Check for circular references in AST structure\n        # TODO 5: Return list of validation errors (empty list if valid)\n        pass\n```\n\n![Complete Parsing Pipeline Flow](./diagrams/parsing-pipeline-flow.svg)\n\n#### Error Recovery Infrastructure\n\n```python\n# error_recovery.py - Complete error handling utilities\nimport logging\nfrom typing import Optional, Any, List, Union\nfrom enum import Enum\n\nclass ErrorSeverity(Enum):\n    WARNING = \"warning\"\n    ERROR = \"error\"\n    CRITICAL = \"critical\"\n\nclass ParseError:\n    \"\"\"Structured representation of parsing errors.\"\"\"\n    \n    def __init__(self, \n                 message: str, \n                 line_number: Optional[int] = None,\n                 column: Optional[int] = None,\n                 severity: ErrorSeverity = ErrorSeverity.ERROR):\n        self.message = message\n        self.line_number = line_number\n        self.column = column\n        self.severity = severity\n        \n    def __str__(self) -> str:\n        location = \"\"\n        if self.line_number is not None:\n            location = f\" at line {self.line_number}\"\n            if self.column is not None:\n                location += f\", column {self.column}\"\n        return f\"{self.severity.value.upper()}: {self.message}{location}\"\n\nclass ErrorCollector:\n    \"\"\"Collects and manages parsing errors during pipeline execution.\"\"\"\n    \n    def __init__(self):\n        self.errors: List[ParseError] = []\n        self.logger = logging.getLogger(__name__)\n        \n    def add_error(self, \n                  message: str, \n                  line_number: Optional[int] = None,\n                  column: Optional[int] = None,\n                  severity: ErrorSeverity = ErrorSeverity.ERROR) -> None:\n        \"\"\"Add a parsing error to the collection.\"\"\"\n        error = ParseError(message, line_number, column, severity)\n        self.errors.append(error)\n        self.logger.log(self._severity_to_log_level(severity), str(error))\n        \n    def has_critical_errors(self) -> bool:\n        \"\"\"Check if any critical errors were collected.\"\"\"\n        return any(error.severity == ErrorSeverity.CRITICAL for error in self.errors)\n        \n    def get_error_summary(self) -> str:\n        \"\"\"Generate human-readable error summary.\"\"\"\n        if not self.errors:\n            return \"No errors\"\n            \n        summary = f\"Found {len(self.errors)} parsing issues:\\n\"\n        for error in self.errors:\n            summary += f\"  - {error}\\n\"\n        return summary\n        \n    def _severity_to_log_level(self, severity: ErrorSeverity) -> int:\n        \"\"\"Convert error severity to logging level.\"\"\"\n        mapping = {\n            ErrorSeverity.WARNING: logging.WARNING,\n            ErrorSeverity.ERROR: logging.ERROR,\n            ErrorSeverity.CRITICAL: logging.CRITICAL\n        }\n        return mapping[severity]\n```\n\n#### Milestone Checkpoints\n\n**After Milestone 1 (Block Elements):**\n- Run: `python -c \"from markdown_renderer import parse_to_html; print(parse_to_html('# Hello\\n\\nWorld'))\"`\n- Expected: `<h1>Hello</h1>\\n<p>World</p>`\n- Verify: AST contains HEADING and PARAGRAPH nodes with correct hierarchy\n\n**After Milestone 2 (Inline Elements):**\n- Run: `python -c \"from markdown_renderer import parse_to_html; print(parse_to_html('**bold** and *italic*'))\"`\n- Expected: `<p><strong>bold</strong> and <em>italic</em></p>`\n- Verify: Inline nodes are properly nested within block nodes\n\n**After Milestone 3 (Lists):**\n- Run: `python -c \"from markdown_renderer import parse_to_html; print(parse_to_html('- Item 1\\n  - Nested'))\"`\n- Expected: `<ul><li>Item 1<ul><li>Nested</li></ul></li></ul>`\n- Verify: Nested list structures render with proper HTML nesting\n\n**After Milestone 4 (HTML Generation):**\n- Run full integration test with complex document containing all element types\n- Expected: Valid HTML5 that passes W3C validation\n- Verify: All special characters properly escaped, no malformed tags\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation\n\n### The Graceful Degradation Mental Model\n\nThink of error handling in markdown parsing like being a helpful teacher grading a student's essay written in a second language. When you encounter grammatical errors or unclear sentences, you don't throw the entire essay in the trash — instead, you make reasonable interpretations, provide the best possible understanding of what the student meant, and continue reading. Similarly, when your markdown parser encounters malformed syntax or ambiguous input, it should make sensible assumptions, produce the most reasonable HTML output possible, and continue processing the rest of the document.\n\nThis graceful degradation approach is fundamental to markdown parsing because markdown exists in a messy, real-world context. Users type markdown in text editors without syntax highlighting, copy-paste content from various sources, and often mix valid markdown with informal text patterns. A parser that fails completely on the first syntax error would be virtually unusable. Instead, your parser should embody the principle of \"be liberal in what you accept\" — interpret ambiguous input charitably while still maintaining predictable behavior.\n\nThe key insight is that markdown parsing errors fall into two categories: recoverable inconsistencies where you can make reasonable assumptions about user intent, and structural corruption where continuing could produce misleading output. Your error handling strategy must distinguish between these cases and respond appropriately to each.\n\n### Parser Error Recovery\n\nParser error recovery represents the strategies your markdown renderer uses when it encounters input that doesn't conform to valid markdown syntax. The recovery approach differs significantly between the block parsing phase and the inline parsing phase because these phases have different error characteristics and different consequences for getting the interpretation wrong.\n\nDuring block parsing, most errors involve ambiguous line classification or incomplete block structures. For example, a user might start a fenced code block with triple backticks but forget to close it, or they might create what looks like a heading but with invalid syntax. These errors are typically local to specific lines or line sequences, making recovery relatively straightforward. The parser can make reasonable assumptions about user intent and continue processing subsequent lines.\n\nDuring inline parsing, errors more commonly involve mismatched delimiters or ambiguous emphasis markers. A user might write `**bold text without closing` or create nested emphasis that violates CommonMark precedence rules. These errors affect text spans within blocks, and recovery involves deciding how to interpret the malformed delimiters while preserving as much of the intended formatting as possible.\n\n#### Block Parser Error Recovery Strategy\n\nThe block parser uses a **continuation-based recovery** approach where errors in one block don't prevent parsing of subsequent blocks. When the parser encounters malformed block syntax, it applies a hierarchy of fallback interpretations designed to preserve user intent whenever possible.\n\nThe recovery strategy follows this decision sequence:\n\n1. **Attempt completion**: If the current block is incomplete (like an unclosed fenced code block), attempt to complete it using document boundaries or other structural clues\n2. **Graceful degradation**: If completion isn't possible, degrade the block to a simpler, valid form (like converting a malformed heading to a paragraph)\n3. **Content preservation**: Ensure that all text content appears somewhere in the output, even if the formatting is lost\n4. **Error isolation**: Prevent errors in one block from affecting the interpretation of subsequent blocks\n5. **Resume normal parsing**: Continue with the standard parsing algorithm for the next line sequence\n\nFor example, consider an unclosed fenced code block where the user writes:\n\n```\nSome paragraph text.\n\n```python\ndef hello():\n    print(\"world\")\n\nMore paragraph text continues here.\n```\n\nThe parser detects that the code block starting with triple backticks never encounters a closing fence. Rather than treating the entire rest of the document as code content, the recovery strategy recognizes that the user likely intended to close the code block before the next paragraph. The parser closes the code block implicitly at the next blank line followed by non-indented text, preserving both the code formatting and the subsequent paragraph content.\n\nThe block parser maintains an `ErrorCollector` that records recovery decisions without interrupting the parsing process. This allows the parser to complete successfully while still providing feedback about ambiguous input interpretation.\n\n| Error Type | Detection Method | Recovery Strategy | Fallback Behavior |\n|------------|------------------|-------------------|--------------------|\n| Unclosed fenced code | End of document reached while in fenced code state | Close code block at document end | Preserve all content as code |\n| Malformed ATX heading | Hash characters without following space or text | Convert to paragraph | Treat hash characters as literal text |\n| Invalid Setext underline | Underline length doesn't match heading text | Treat as separate paragraph | Keep both lines as paragraph content |\n| Incomplete blockquote | Lines start with `>` but have inconsistent spacing | Normalize spacing and continue | Remove `>` markers and treat as paragraph |\n| Broken horizontal rule | Line has some dashes/asterisks but not enough | Convert to paragraph | Preserve characters as literal text |\n| Mixed indentation in code | Some lines indented with spaces, others with tabs | Normalize to consistent indentation | Convert tabs to spaces using standard width |\n\n#### Inline Parser Error Recovery Strategy\n\nThe inline parser uses a **delimiter balancing recovery** approach that attempts to create the most reasonable interpretation of mismatched or ambiguous formatting markers. Because inline formatting can be nested and overlapping, the recovery strategy must maintain consistency with CommonMark's emphasis precedence rules while handling cases those rules don't cover.\n\nThe delimiter stack mechanism provides the foundation for error recovery. When the parser completes processing all text in a block but still has unmatched openers in the `DelimiterStack`, it applies recovery rules to determine how to handle the orphaned delimiters.\n\nThe recovery process follows this sequence:\n\n1. **Attempt delayed matching**: Look for potential closers that were initially rejected due to precedence rules\n2. **Pair partial matches**: Match delimiters even if they don't follow strict flanking rules, prioritizing user intent over specification compliance\n3. **Convert to literal text**: Transform unmatched delimiters into regular text characters\n4. **Preserve content**: Ensure all text content appears in the output with as much formatting as can be reasonably inferred\n5. **Maintain consistency**: Apply the same recovery rules consistently across similar situations\n\nFor example, consider the text `**bold text with *italic inside` where the user forgot to close both the italic and bold formatting. The parser's delimiter stack contains an unmatched asterisk (for italic) and an unmatched double-asterisk (for bold). The recovery strategy recognizes that the user likely intended some formatting and converts the text to `**bold text with *italic inside**` by treating the entire span as bold text containing a literal asterisk character.\n\nThe inline parser also handles **intraword underscore** issues by implementing recovery rules that distinguish between intended emphasis and underscores that happen to appear within words. When the parser encounters underscores in positions where they could technically match according to basic delimiter rules but violate the intraword prohibition, it converts them to literal characters rather than attempting to create emphasis spans.\n\n| Error Type | Detection Method | Recovery Strategy | Fallback Behavior |\n|------------|------------------|-------------------|--------------------|\n| Unmatched emphasis opener | Delimiter stack not empty after processing text | Convert to literal characters | Remove delimiter properties, keep as text |\n| Mismatched emphasis types | Asterisk opener with underscore closer | Match delimiters of same type only | Leave unmatched delimiters as literals |\n| Invalid nesting | Strong inside emphasis when emphasis can't contain strong | Allow nesting but adjust precedence | Follow CommonMark precedence rules |\n| Broken link syntax | Opening bracket without closing bracket or parentheses | Treat brackets as literal text | Preserve all text including brackets |\n| Incomplete image syntax | Exclamation mark with broken link syntax | Remove exclamation, apply link recovery | Fall back to link parsing rules |\n| Unclosed inline code | Backtick without matching closing backtick | Close at end of current block | Treat remaining text as code content |\n\n### Edge Case Handling\n\nEdge cases in markdown parsing represent input patterns that are technically valid according to the specification but create ambiguous or counterintuitive results. Unlike errors, which involve clearly malformed syntax, edge cases require the parser to choose between multiple valid interpretations or handle boundary conditions that don't have obvious correct answers.\n\nThe markdown specification itself contains numerous edge cases because it attempts to codify the behavior of existing markdown implementations that evolved organically. Many of these edge cases arise from the interaction between different markdown features or from the need to handle whitespace, line breaks, and character sequences that have special meaning in some contexts but not others.\n\nYour parser's edge case handling strategy should prioritize **consistent behavior** and **predictable results** over trying to guess user intent. When faced with ambiguous input, the parser should always make the same interpretation choice, even if that choice might not match what the user intended in every specific case.\n\n![Error Recovery Decision Flow](./diagrams/error-recovery-flow.svg)\n\n#### Whitespace and Line Break Edge Cases\n\nWhitespace handling represents one of the most complex categories of edge cases because markdown gives semantic meaning to certain whitespace patterns while treating others as insignificant. The parser must distinguish between whitespace that affects document structure, whitespace that affects formatting, and whitespace that should be preserved in the output.\n\n**Trailing whitespace on lines** creates edge cases because two or more trailing spaces at the end of a line create a hard line break in the output, but a single trailing space is typically insignificant. However, users often have editors that automatically trim trailing whitespace, or they copy-paste content that loses trailing spaces. The parser must decide whether to preserve these line breaks strictly according to the input or to apply some normalization.\n\nThe recommended approach is to implement **semantic whitespace preservation** where the parser preserves trailing spaces that clearly indicate intentional line breaks (two or more spaces) but normalizes accidental single trailing spaces. This requires the parser to track the original whitespace patterns during the preprocessing phase and apply consistent rules during HTML generation.\n\n**Mixed line endings** create edge cases when documents contain a mixture of Unix (`\\n`), Windows (`\\r\\n`), and legacy Mac (`\\r`) line endings. While the `normalize_line_endings` function converts everything to Unix format, the parser must handle cases where the mixed line endings create unexpected blank lines or affect block boundary detection.\n\n**Tab expansion** creates edge cases in indentation-sensitive contexts like code blocks and lists. The CommonMark specification requires tabs to be expanded to the next multiple of 4 spaces, but this can create counterintuitive results when users mix tabs and spaces or use different tab width assumptions. The `expand_tabs_to_spaces` function must handle these cases consistently while preserving the visual alignment that users intended.\n\n| Edge Case | Input Pattern | Expected Behavior | Implementation Strategy |\n|-----------|---------------|-------------------|-------------------------|\n| Single trailing space | `Line content \\n` | Ignore trailing space | Normalize during preprocessing |\n| Double trailing space | `Line content  \\n` | Create hard line break | Preserve and convert to `<br>` tag |\n| Mixed tabs and spaces | `\\t  some text` | Normalize to consistent spacing | Expand tabs first, then calculate indentation |\n| Empty lines with spaces | `   \\n` | Treat as blank line | Trim whitespace before blank line detection |\n| CRLF followed by LF | `text\\r\\n\\nmore` | Single paragraph break | Normalize line endings before processing |\n| Unicode whitespace | `text\\u00A0more` | Preserve non-breaking space | Only normalize ASCII whitespace characters |\n\n#### Delimiter Precedence Edge Cases\n\nDelimiter precedence edge cases arise when multiple emphasis markers compete for the same text spans or when nested formatting creates ambiguous parsing situations. The CommonMark specification defines precedence rules for these cases, but implementing them correctly requires careful attention to delimiter matching order and flanking detection.\n\n**Overlapping emphasis spans** occur when delimiter pairs would create emphasis spans that partially overlap rather than being properly nested. For example, the text `*emphasis **strong* text**` contains asterisks that would create overlapping emphasis if matched naively. The parser must apply precedence rules that ensure valid HTML nesting while producing predictable results.\n\nThe precedence algorithm processes delimiters in a specific order: shorter emphasis spans (single asterisks/underscores) are resolved before longer ones (double asterisks/underscores), and delimiters are matched from left to right within each precedence level. When conflicts arise, the earlier delimiter takes precedence and later conflicting delimiters are treated as literal text.\n\n**Intraword underscore handling** creates edge cases when underscores appear within words in contexts where they could technically form valid emphasis according to basic flanking rules. The specification prohibits intraword underscore emphasis, but determining what constitutes a \"word\" requires understanding Unicode character classes and handling edge cases with punctuation, numbers, and non-Latin scripts.\n\nThe `can_open_emphasis` and `can_close_emphasis` functions implement flanking detection that considers the characters immediately before and after each delimiter. For underscores, additional logic checks whether both the delimiter and its potential match are surrounded by word characters, which would violate the intraword prohibition.\n\n**Emphasis delimiter length matching** creates edge cases when the parser encounters sequences of emphasis markers with different lengths. For example, `***text***` could be interpreted as strong emphasis (`**text**`) with an extra literal asterisk, or as emphasis (`*text*`) with extra literal asterisks, or as a combination of both emphasis and strong emphasis. The specification defines rules for these cases, but implementing them requires careful tracking of available delimiter lengths.\n\n| Edge Case | Input Pattern | CommonMark Interpretation | Implementation Notes |\n|-----------|---------------|---------------------------|----------------------|\n| Overlapping emphasis | `*em **strong* text**` | `<em>em **strong</em> text**` | Earlier delimiter wins, later becomes literal |\n| Intraword underscore | `snake_case_variable` | `snake_case_variable` (no emphasis) | Check word character boundaries for underscores |\n| Triple asterisk | `***text***` | `<em><strong>text</strong></em>` | Parse as nested emphasis and strong |\n| Mixed delimiter types | `*emphasis with __strong* text__` | `<em>emphasis with __strong</em> text__` | Don't match asterisks with underscores |\n| Adjacent delimiters | `** **bold** **` | `** <strong>bold</strong> **` | Middle pair matches, outer delimiters are literals |\n| Escaped delimiters | `\\*not emphasis\\*` | `*not emphasis*` | Process escapes before delimiter detection |\n\n#### List Structure Edge Cases\n\nList structure edge cases arise from the complexity of list continuation rules, indentation handling, and the interaction between lists and other block elements. These edge cases often involve determining whether a line continues an existing list item, starts a new list item, or ends the list entirely.\n\n**Lazy continuation** represents one of the most subtle edge cases in list parsing. The CommonMark specification allows certain types of content to continue list items without requiring the full indentation that would normally be needed. This means a line that appears to be a regular paragraph might actually be a continuation of a preceding list item, depending on context.\n\nThe lazy continuation rules apply differently to different types of content. Paragraph content can be lazily continued, but other block types like headings, code blocks, and blockquotes cannot. This creates edge cases where the same indentation level might continue a list in some contexts but not others.\n\n**Blank lines in lists** affect whether lists are considered \"tight\" or \"loose,\" which changes the HTML output by determining whether list item content is wrapped in paragraph tags. A single blank line within a list can change the formatting of the entire list, creating edge cases where small whitespace changes have large effects on the output.\n\n**List marker changes** create edge cases when a sequence of list items uses inconsistent markers. For ordered lists, different numbering patterns or punctuation styles might indicate separate lists. For unordered lists, mixing different bullet characters (`-`, `*`, `+`) should create separate lists according to the specification, but users often mix them unintentionally.\n\nThe `ListContext` and `ListContextStack` classes handle these edge cases by tracking the specific marker types and indentation patterns for each nested list level. When the parser encounters a potential list item that doesn't match the current context, it must decide whether to end the current list and start a new one, or treat the line as non-list content.\n\n| Edge Case | Input Pattern | Expected Behavior | Implementation Strategy |\n|-----------|---------------|-------------------|-------------------------|\n| Lazy continuation | List item followed by unindented text | Continue list item if paragraph content | Check content type and previous context |\n| Blank line in tight list | List items with single blank line between | Convert entire list to loose formatting | Track blank line presence across all items |\n| Mixed ordered markers | `1. item` followed by `1) item` | Create separate lists | Compare marker punctuation styles |\n| Mixed unordered markers | `- item` followed by `* item` | Create separate lists | Compare bullet character types |\n| Insufficient continuation indent | List item with under-indented continuation | End list, start new paragraph | Calculate required indentation precisely |\n| List followed by code block | Indented code after list without blank line | Continue list vs. start code block | Require blank line before code block |\n\n#### Link and Image Edge Cases\n\nLink and image parsing creates edge cases around URL validation, title extraction, and the interaction between link syntax and other markdown features. These edge cases often involve determining whether character sequences that look like links should be interpreted as links or treated as literal text.\n\n**Nested brackets** in link text create parsing challenges because the link syntax uses brackets to delimit the link text, but the link text itself might contain brackets for other purposes. The parser must track bracket nesting levels and determine which closing bracket corresponds to the link text versus brackets that are part of the content.\n\n**URL validation** creates edge cases because the parser must decide which character sequences constitute valid URLs without implementing a full URL parser. The specification allows a wide range of URL formats, including relative URLs, fragment identifiers, and URLs with unusual schemes. The parser must balance accepting valid URLs against avoiding false positives where parentheses or other punctuation accidentally close link syntax.\n\n**Link titles with quotes** create edge cases when the title text contains the same quote characters used to delimit the title. The parser must handle escaped quotes within titles and determine which quotes are delimiters versus content.\n\nThe `LinkImageParser` class handles these edge cases through careful delimiter matching and context tracking. The parser maintains separate state for bracket nesting, parenthesis matching, and quote handling to ensure that complex link syntax is parsed correctly even when it contains characters that have special meaning in other contexts.\n\n| Edge Case | Input Pattern | Expected Behavior | Implementation Strategy |\n|-----------|---------------|-------------------|-------------------------|\n| Nested brackets in text | `[link [with brackets]](url)` | Include brackets in link text | Track bracket nesting depth |\n| URL with parentheses | `[text](url(with)parens)` | Include parentheses in URL | Balance parentheses in URL |\n| Link title with quotes | `[text](url \"title with \\\"quotes\\\"\")` | Handle escaped quotes in title | Process escapes within quoted strings |\n| Image vs link precedence | `[![image](img.png)](link.html)` | Image inside link | Parse inner image first, then outer link |\n| Malformed URL | `[text](not a url)` | Treat as literal text | Validate basic URL structure |\n| Missing link URL | `[text]()` | Create link with empty href | Allow empty URLs but create valid HTML |\n\n> **Key Insight**: Edge case handling is not about guessing user intent — it's about providing consistent, predictable behavior that users can learn and rely on. When faced with ambiguous input, always choose the interpretation that produces valid HTML and maintains consistency with the CommonMark specification.\n\n### Implementation Guidance\n\nThe error handling and edge case management system requires careful coordination between all parsing phases to ensure consistent behavior and comprehensive error recovery. The implementation focuses on building robust error collection and recovery mechanisms that don't interrupt the parsing pipeline while providing detailed information about how ambiguous input was interpreted.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Error Collection | List of error messages with line numbers | Structured error objects with severity levels and recovery suggestions |\n| Recovery Strategy | Fixed fallback rules hardcoded in parser | Configurable recovery policies with user-defined handlers |\n| Edge Case Testing | Manual test cases for known edge cases | Property-based testing with random input generation |\n| Validation | Basic HTML structure validation | Full CommonMark specification compliance testing |\n\n#### Recommended File Structure\n\nThe error handling system integrates across all parsing components:\n\n```\nmarkdown_renderer/\n  src/\n    parser/\n      error_handling.py      ← ErrorCollector, ParseError classes\n      recovery_strategies.py ← Recovery algorithms for each parser phase\n      edge_cases.py         ← Edge case detection and handling utilities\n    block_parser/\n      block_parser.py       ← Modified to use ErrorCollector\n      block_recovery.py     ← Block-specific recovery strategies\n    inline_parser/\n      inline_parser.py      ← Modified to use ErrorCollector  \n      delimiter_recovery.py ← Delimiter matching recovery\n    list_parser/\n      list_parser.py        ← Modified to use ErrorCollector\n      list_recovery.py      ← List structure recovery\n    html_generator/\n      html_generator.py     ← Modified to validate output\n      validation.py         ← HTML structure validation utilities\n    tests/\n      error_cases/          ← Test files for error scenarios\n      edge_cases/           ← Test files for edge case handling\n      recovery_tests.py     ← Tests for recovery behavior\n```\n\n#### Error Collection Infrastructure\n\nThe error handling system begins with a comprehensive error collection mechanism that captures parsing issues without interrupting the parsing process. This infrastructure provides the foundation for both immediate recovery and post-processing analysis of parsing decisions.\n\n```python\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Any, Dict\nimport re\n\nclass ErrorSeverity(Enum):\n    \"\"\"Severity levels for parsing errors and edge cases.\"\"\"\n    WARNING = \"warning\"      # Ambiguous input with reasonable interpretation\n    ERROR = \"error\"          # Invalid syntax with fallback behavior\n    CRITICAL = \"critical\"    # Structural problems affecting output quality\n\n@dataclass\nclass ParseError:\n    \"\"\"Structured representation of parsing errors and recovery decisions.\"\"\"\n    line_number: int\n    column: Optional[int]\n    severity: ErrorSeverity\n    error_type: str\n    message: str\n    original_text: str\n    recovery_action: str\n    suggested_fix: Optional[str] = None\n    context: Dict[str, Any] = None\n    \n    def __post_init__(self):\n        if self.context is None:\n            self.context = {}\n\nclass ErrorCollector:\n    \"\"\"Collects and manages parsing errors during markdown processing.\"\"\"\n    \n    def __init__(self):\n        self.errors: List[ParseError] = []\n        self.max_errors: int = 100  # Prevent excessive error collection\n        self.collect_warnings: bool = True\n        \n    def add_error(self, line_number: int, error_type: str, message: str, \n                  original_text: str, recovery_action: str,\n                  severity: ErrorSeverity = ErrorSeverity.ERROR,\n                  column: Optional[int] = None,\n                  suggested_fix: Optional[str] = None,\n                  **context) -> None:\n        \"\"\"Add a parsing error with recovery information.\"\"\"\n        # TODO 1: Check if max_errors limit reached, skip if exceeded\n        # TODO 2: Create ParseError instance with all provided parameters\n        # TODO 3: Set context dictionary from **context kwargs\n        # TODO 4: Append error to self.errors list\n        # TODO 5: If severity is WARNING and collect_warnings is False, skip adding\n        pass\n        \n    def has_errors(self, min_severity: ErrorSeverity = ErrorSeverity.ERROR) -> bool:\n        \"\"\"Check if any errors of specified severity or higher exist.\"\"\"\n        # TODO 1: Iterate through self.errors\n        # TODO 2: Compare each error's severity to min_severity\n        # TODO 3: Return True if any error meets severity threshold\n        pass\n        \n    def get_errors_by_line(self, line_number: int) -> List[ParseError]:\n        \"\"\"Get all errors that occurred on a specific line.\"\"\"\n        # TODO 1: Filter self.errors where error.line_number == line_number\n        # TODO 2: Return filtered list\n        pass\n        \n    def format_error_report(self) -> str:\n        \"\"\"Generate human-readable error report.\"\"\"\n        # TODO 1: Group errors by severity level\n        # TODO 2: Format each error with line number, message, and recovery action\n        # TODO 3: Include suggested fixes when available\n        # TODO 4: Return formatted report string\n        pass\n```\n\n#### Block Parser Recovery Implementation\n\nThe block parser recovery system handles incomplete or malformed block structures by maintaining recovery state alongside the normal parsing state machine. This allows the parser to detect error conditions and apply appropriate fallback strategies without losing document content.\n\n```python\nfrom typing import Optional, List, Tuple\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass RecoveryStrategy(Enum):\n    \"\"\"Recovery strategies for different types of block parsing errors.\"\"\"\n    COMPLETE_BLOCK = \"complete_block\"      # Try to complete incomplete block\n    CONVERT_TO_PARAGRAPH = \"convert_to_paragraph\"  # Fallback to paragraph\n    PRESERVE_CONTENT = \"preserve_content\"   # Keep content, lose formatting\n    SKIP_MALFORMED = \"skip_malformed\"      # Skip line, continue parsing\n\n@dataclass\nclass BlockRecoveryContext:\n    \"\"\"Context information for block-level error recovery.\"\"\"\n    current_block_type: Optional[BlockType]\n    lines_in_block: int\n    expected_closing: Optional[str]\n    fallback_strategy: RecoveryStrategy\n    \ndef recover_incomplete_fenced_code(block_node: BlockNode, \n                                   error_collector: ErrorCollector,\n                                   line_number: int) -> None:\n    \"\"\"Recover from unclosed fenced code block at end of document.\"\"\"\n    # TODO 1: Add error to collector about unclosed fenced code block\n    # TODO 2: Set block's closing fence implicitly\n    # TODO 3: Mark block as complete in block attributes\n    # TODO 4: Log recovery action taken\n    pass\n\ndef recover_malformed_atx_heading(line: str, line_number: int,\n                                  error_collector: ErrorCollector) -> BlockNode:\n    \"\"\"Recover from invalid ATX heading syntax by converting to paragraph.\"\"\"\n    # TODO 1: Detect specific malformation (no space after #, too many #, etc.)\n    # TODO 2: Add error to collector with specific issue description\n    # TODO 3: Create paragraph block node with original line content\n    # TODO 4: Set recovery information in block attributes\n    # TODO 5: Return paragraph block node\n    pass\n\ndef recover_inconsistent_blockquote(lines: List[str], line_numbers: List[int],\n                                    error_collector: ErrorCollector) -> BlockNode:\n    \"\"\"Recover from blockquote with inconsistent > prefixes.\"\"\"\n    # TODO 1: Identify lines with missing or malformed > prefixes\n    # TODO 2: Add warning for each inconsistent line\n    # TODO 3: Normalize all lines to have consistent > prefix\n    # TODO 4: Create blockquote block with normalized content\n    # TODO 5: Record normalization actions in block attributes\n    pass\n```\n\n#### Inline Parser Recovery Implementation\n\nThe inline parser recovery system focuses on delimiter matching issues and emphasis precedence conflicts. The recovery strategies maintain the delimiter stack integrity while providing reasonable interpretations of malformed inline formatting.\n\n```python\nfrom typing import List, Optional, Tuple, Dict\nfrom dataclasses import dataclass\n\n@dataclass \nclass DelimiterRecoveryInfo:\n    \"\"\"Information about delimiter recovery actions.\"\"\"\n    original_position: int\n    delimiter_char: str\n    recovery_action: str\n    matched_with: Optional[int] = None\n    converted_to_literal: bool = False\n\ndef recover_unmatched_delimiters(delimiter_stack: DelimiterStack,\n                                text: str,\n                                error_collector: ErrorCollector) -> List[DelimiterRecoveryInfo]:\n    \"\"\"Recover from unmatched emphasis delimiters in delimiter stack.\"\"\"\n    # TODO 1: Iterate through remaining delimiters in stack\n    # TODO 2: For each delimiter, determine if partial matching is possible\n    # TODO 3: Apply recovery strategy (convert to literal, force match, etc.)\n    # TODO 4: Add error/warning to collector for each recovery action\n    # TODO 5: Create DelimiterRecoveryInfo for each action taken\n    # TODO 6: Clear delimiter stack after recovery\n    # TODO 7: Return list of recovery actions taken\n    pass\n\ndef handle_intraword_underscore_conflict(text: str, start_pos: int, end_pos: int,\n                                        error_collector: ErrorCollector) -> str:\n    \"\"\"Handle underscore emphasis that would violate intraword rules.\"\"\"\n    # TODO 1: Extract the text span between start_pos and end_pos\n    # TODO 2: Check if both delimiter positions are within words\n    # TODO 3: If intraword violation detected, add warning to collector\n    # TODO 4: Convert delimiter characters to literal underscores\n    # TODO 5: Return text with delimiters converted to literals\n    pass\n\ndef recover_broken_link_syntax(text: str, bracket_pos: int,\n                              error_collector: ErrorCollector) -> Tuple[str, bool]:\n    \"\"\"Recover from malformed link syntax by treating as literal text.\"\"\"\n    # TODO 1: Analyze link syntax starting at bracket_pos\n    # TODO 2: Identify specific malformation (missing closing bracket, invalid URL, etc.)\n    # TODO 3: Add error to collector with specific issue\n    # TODO 4: Convert link syntax characters to literal text\n    # TODO 5: Return tuple of (recovered_text, recovery_applied)\n    pass\n```\n\n#### Edge Case Detection and Handling\n\nThe edge case handling system provides consistent behavior for ambiguous input patterns that are technically valid but could be interpreted multiple ways. The implementation focuses on predictable rule application rather than trying to guess user intent.\n\n```python\nimport re\nfrom typing import List, Tuple, Optional, Dict, Any\n\n# Edge case detection patterns\nMIXED_LINE_ENDING_PATTERN = re.compile(r'\\r\\n|\\r|\\n')\nTRAILING_WHITESPACE_PATTERN = re.compile(r'[ \\t]+$', re.MULTILINE)\nUNICODE_WHITESPACE_PATTERN = re.compile(r'[\\u00A0\\u1680\\u2000-\\u200B\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]')\n\ndef normalize_edge_case_whitespace(text: str, \n                                  preserve_semantic_breaks: bool = True) -> Tuple[str, List[str]]:\n    \"\"\"Normalize whitespace while handling edge cases consistently.\"\"\"\n    # TODO 1: Track normalization actions taken for reporting\n    # TODO 2: Convert all line endings to Unix format (\\n)\n    # TODO 3: Handle trailing whitespace - preserve semantic line breaks (2+ spaces)\n    # TODO 4: Expand tabs to spaces using 4-space tab width\n    # TODO 5: Normalize Unicode whitespace to ASCII equivalents where appropriate\n    # TODO 6: Remove trailing whitespace from blank lines\n    # TODO 7: Return tuple of (normalized_text, list_of_actions_taken)\n    pass\n\ndef detect_emphasis_precedence_conflict(delimiters: List[Delimiter]) -> List[Tuple[int, int, str]]:\n    \"\"\"Detect potential emphasis delimiter precedence conflicts.\"\"\"\n    # TODO 1: Sort delimiters by position\n    # TODO 2: Check for overlapping emphasis spans\n    # TODO 3: Identify conflicts between asterisk and underscore delimiters\n    # TODO 4: Find cases where delimiter length precedence applies\n    # TODO 5: Return list of (start_pos, end_pos, conflict_type) tuples\n    pass\n\ndef handle_list_marker_inconsistency(current_marker: str, new_marker: str,\n                                    context: Dict[str, Any]) -> Tuple[bool, str]:\n    \"\"\"Handle inconsistent list markers according to CommonMark rules.\"\"\"\n    # TODO 1: Parse marker types (ordered vs unordered, specific characters)\n    # TODO 2: Check if markers are compatible (same list vs separate lists)\n    # TODO 3: For ordered lists, check numbering continuity\n    # TODO 4: For unordered lists, check bullet character consistency\n    # TODO 5: Return tuple of (should_continue_list, explanation)\n    pass\n```\n\n#### Comprehensive Error Testing Framework\n\nThe error handling system requires extensive testing to ensure consistent behavior across all edge cases and recovery scenarios. The testing framework validates both the recovery actions taken and the quality of the final output.\n\n```python\nimport pytest\nfrom typing import List, Dict, Any, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass ErrorTestCase:\n    \"\"\"Test case for error handling and recovery behavior.\"\"\"\n    name: str\n    markdown_input: str\n    expected_html: str\n    expected_errors: List[Dict[str, Any]]\n    recovery_actions: List[str]\n    edge_case_type: str\n\ndef create_error_test_cases() -> List[ErrorTestCase]:\n    \"\"\"Create comprehensive test cases for error handling scenarios.\"\"\"\n    return [\n        ErrorTestCase(\n            name=\"unclosed_fenced_code_block\",\n            markdown_input=\"```python\\ndef test():\\n    pass\\n\\nMore text here.\",\n            expected_html=\"<pre><code class=\\\"language-python\\\">def test():\\n    pass\\n</code></pre>\\n<p>More text here.</p>\",\n            expected_errors=[{\n                \"error_type\": \"unclosed_fenced_code\", \n                \"severity\": \"ERROR\",\n                \"recovery_action\": \"closed_at_next_paragraph\"\n            }],\n            recovery_actions=[\"close_code_block_at_paragraph_break\"],\n            edge_case_type=\"block_structure\"\n        ),\n        # TODO: Add test cases for:\n        # - Malformed ATX headings\n        # - Unmatched emphasis delimiters  \n        # - Intraword underscore conflicts\n        # - Broken link syntax\n        # - Mixed list markers\n        # - Whitespace edge cases\n        # - Nested delimiter conflicts\n        # - Unicode edge cases\n    ]\n\ndef test_error_recovery_consistency():\n    \"\"\"Test that error recovery produces consistent results.\"\"\"\n    # TODO 1: Load error test cases\n    # TODO 2: For each test case, parse markdown with error collection enabled\n    # TODO 3: Verify that expected errors were collected\n    # TODO 4: Verify that recovery actions match expectations\n    # TODO 5: Verify that HTML output matches expected result\n    # TODO 6: Test that parsing same input twice produces identical results\n    pass\n\ndef test_edge_case_predictability():\n    \"\"\"Test that edge cases produce predictable, consistent behavior.\"\"\"\n    # TODO 1: Create variations of edge case inputs\n    # TODO 2: Parse each variation multiple times\n    # TODO 3: Verify identical output across all parsing attempts\n    # TODO 4: Verify that similar edge cases produce similar handling\n    # TODO 5: Test that edge case handling follows CommonMark specification\n    pass\n```\n\n#### Debugging Error Handling Issues\n\nThe error handling system includes comprehensive debugging support to help identify why specific recovery actions were taken and how to adjust the behavior if needed.\n\n| Symptom | Likely Cause | How to Diagnose | Fix Approach |\n|---------|--------------|-----------------|--------------|\n| Parser silently ignores malformed input | Recovery strategy too aggressive | Enable error collection, check error report | Adjust recovery strategy to be more conservative |\n| Parser fails on minor syntax issues | Recovery strategy too strict | Check ErrorCollector for excessive ERROR level issues | Add more WARNING-level recoveries for minor issues |\n| Inconsistent output for similar inputs | Edge case handling not standardized | Test with variations of problematic input | Implement consistent rule application |\n| Valid markdown parsed incorrectly | Edge case detector too aggressive | Check for false positive edge case detection | Refine detection patterns to be more specific |\n| HTML output contains formatting errors | Recovery created invalid nesting | Validate HTML structure after recovery | Add HTML validation step after recovery actions |\n| Error messages not helpful | ParseError lacks context information | Check ParseError.context field population | Add more contextual information during error creation |\n\nThe error handling and edge case management system provides the foundation for a robust markdown parser that handles real-world input gracefully while maintaining predictable behavior. The combination of structured error collection, consistent recovery strategies, and comprehensive edge case handling ensures that users receive useful output even when their markdown input contains syntax errors or ambiguous patterns.\n\n\n## Testing Strategy\n\n> **Milestone(s):** Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation\n\n### The Quality Assurance Mental Model\n\nThink of testing a markdown renderer like quality control in a translation service. You have documents coming in one language (markdown) and going out in another (HTML), and you need to verify that the meaning, structure, and formatting are preserved accurately across this transformation. Just as a translation service would test with simple phrases, complex literary works, edge cases like idioms, and even malformed input, your markdown renderer needs systematic verification at every level.\n\nThe testing strategy serves as both a safety net and a learning accelerator. Each test category validates different properties of correctness, from basic functionality to edge case resilience. The systematic approach ensures that as you build each milestone, you can confidently rely on previously implemented components while adding new functionality.\n\n### Test Categories and Properties\n\nTesting a markdown renderer requires validating multiple dimensions of correctness simultaneously. Unlike simple algorithmic problems where you test input-output pairs, document transformation involves structural correctness, semantic preservation, and format compliance. Each test category validates specific properties and catches different classes of errors.\n\n#### Unit Test Categories\n\n**Block Parser Unit Tests** verify that individual block-level elements are recognized and parsed correctly in isolation. These tests focus on the `BlockParser` component and validate that each block type handler correctly identifies, extracts, and structures content.\n\n| Test Category | Property Validated | Example Test Case | Expected Behavior |\n|---|---|---|---|\n| ATX Heading Recognition | Heading level detection accuracy | `### Hello World` | Creates `BlockNode` with `block_type=HEADING`, level 3, content \"Hello World\" |\n| Paragraph Boundary Detection | Text grouping correctness | Two lines separated by blank line | Creates two separate `BlockNode` instances with `block_type=PARAGRAPH` |\n| Fenced Code Block Parsing | Content preservation with metadata | Triple backticks with language hint | Preserves exact whitespace, extracts language identifier |\n| Blockquote Nesting | Hierarchical structure building | Multiple `>` levels | Creates nested `BlockNode` tree with proper parent-child relationships |\n| Horizontal Rule Recognition | Pattern matching precision | Various `---`, `***`, `___` patterns | Distinguishes valid rules from similar-looking text |\n\n**Inline Parser Unit Tests** validate that formatting elements within text are correctly identified, paired, and nested. These tests exercise the `DelimiterStack` and emphasis matching algorithms.\n\n| Test Category | Property Validated | Example Test Case | Expected Behavior |\n|---|---|---|---|\n| Emphasis Delimiter Matching | Proper opener-closer pairing | `**bold** and *italic*` | Matches delimiters correctly, doesn't cross-pair |\n| Intraword Underscore Handling | Context-sensitive formatting | `snake_case_variable` | Doesn't apply emphasis to underscores within words |\n| Nested Formatting | Hierarchical inline structure | `**bold with *italic* inside**` | Creates proper AST nesting without conflicts |\n| Link Syntax Parsing | URL and title extraction | `[text](url \"title\")` | Extracts all components with proper escaping |\n| Escape Sequence Processing | Literal character handling | `\\*not emphasis\\*` | Converts escape sequences to literal characters |\n\n**List Parser Unit Tests** verify the complex indentation tracking and nesting logic that handles one of markdown's most challenging parsing scenarios.\n\n| Test Category | Property Validated | Example Test Case | Expected Behavior |\n|---|---|---|---|\n| Marker Type Consistency | List type enforcement | Mixed `-` and `*` markers | Treats as separate lists per CommonMark rules |\n| Indentation Level Tracking | Nesting depth calculation | Various indentation patterns | Builds correct hierarchical structure |\n| Lazy Continuation | Content flow rules | Multi-line items without markers | Properly continues items without requiring markers |\n| Tight vs Loose Lists | Spacing semantics | Lists with/without blank lines | Sets appropriate formatting flags for HTML generation |\n| List Item Content Parsing | Multi-paragraph item handling | Items containing multiple blocks | Nests paragraphs, code blocks within list items |\n\n#### Integration Test Categories\n\n**Parser Pipeline Integration Tests** validate that the complete parsing pipeline produces coherent results when components work together. These tests catch interaction bugs that unit tests miss.\n\n| Test Category | Property Validated | Example Test Case | Expected Behavior |\n|---|---|---|---|\n| Block-Inline Coordination | Proper processing order | Paragraph with emphasis | Block parser creates paragraph, inline parser processes emphasis within |\n| List-Inline Integration | Complex nested parsing | List items with links and emphasis | Maintains both list structure and inline formatting |\n| Escape Context Preservation | Consistent escape handling | Escapes in different contexts | Escapes work consistently across block and inline contexts |\n| AST Structure Integrity | Tree validity | Complex nested documents | Produces well-formed AST with proper parent-child links |\n| State Machine Transitions | Parser state consistency | Mixed block types | State transitions don't leave parser in inconsistent state |\n\n**HTML Generation Integration Tests** ensure that the parsed AST converts to valid, semantically correct HTML that preserves the original document's intent.\n\n| Test Category | Property Validated | Example Test Case | Expected Behavior |\n|---|---|---|---|\n| HTML Validity | Standards compliance | Complex nested structures | Produces HTML5-compliant output that passes validation |\n| Character Escaping | Security and correctness | Special characters in various contexts | Properly escapes content vs attribute contexts |\n| Semantic Preservation | Meaning conservation | Complex formatting combinations | HTML conveys same semantic meaning as original markdown |\n| Pretty Printing | Output readability | Nested block structures | Produces properly indented, human-readable HTML |\n| Custom Renderer Integration | Extensibility verification | Documents using custom renderers | Plugin system works without breaking core functionality |\n\n#### Property-Based Test Categories\n\nProperty-based tests validate system behaviors that should hold regardless of specific input content. These tests are particularly valuable for catching edge cases and ensuring robust error handling.\n\n| Property Category | Invariant Tested | Test Approach | Validation Method |\n|---|---|---|---|\n| Roundtrip Stability | `parse(markdown).to_text() ≈ original` | Generate varied markdown inputs | Compare semantic equivalence |\n| Parsing Determinism | Same input always produces same AST | Repeat parsing with identical input | Verify AST structure matches exactly |\n| Error Recovery Bounds | Malformed input produces valid output | Inject syntax errors systematically | Check output is still valid HTML |\n| Memory Safety | No resource leaks during parsing | Parse large documents repeatedly | Monitor memory usage patterns |\n| Performance Linearity | Parse time scales reasonably | Vary document size systematically | Verify no exponential behavior |\n\n> The key insight in testing document transformation is that you're validating not just correctness, but also consistency across different contexts. A delimiter that works in paragraphs must also work in list items, blockquotes, and other nested contexts.\n\n#### Error Handling Test Categories\n\nError handling tests ensure graceful degradation when encountering malformed or edge-case input. These tests validate the `ErrorCollector` and recovery mechanisms described in the Error Handling section.\n\n| Error Category | Failure Mode | Test Case | Expected Recovery |\n|---|---|---|---|\n| Unclosed Fenced Code | EOF before closing fence | Code block without `'''` end | Convert to indented code block |\n| Malformed Links | Invalid URL or missing parts | `[text](invalid` | Render as literal text |\n| Unmatched Emphasis | Mismatched delimiters | `**bold *italic**` | Handle precedence correctly |\n| Invalid List Structure | Inconsistent indentation | Mixed tabs and spaces | Normalize to consistent spacing |\n| Mixed Line Endings | Platform inconsistencies | Mix of `\\n`, `\\r\\n`, `\\r` | Normalize to consistent format |\n\n**Architecture Decision: Test Organization Strategy**\n\n> **Decision: Hierarchical Test Organization with Component Isolation**\n> - **Context**: Need to balance comprehensive coverage with maintainable test suite organization, while supporting incremental milestone development\n> - **Options Considered**: \n>   1. Single large test file with all cases\n>   2. Test files mirroring source code structure exactly  \n>   3. Hierarchical organization by test type and milestone\n> - **Decision**: Hierarchical organization with separate directories for unit, integration, and property-based tests\n> - **Rationale**: Allows learners to focus on relevant tests during each milestone while maintaining clear separation between test categories. Supports both incremental development and comprehensive validation.\n> - **Consequences**: Requires more initial setup but provides better long-term maintainability and learning progression\n\n### Milestone Verification Checkpoints\n\nEach milestone represents a significant capability milestone that should be thoroughly verified before proceeding. The verification checkpoints provide concrete, measurable criteria for determining when a milestone is complete and the foundation is solid for the next phase.\n\n#### Milestone 1: Block Elements Verification\n\n**Functional Verification Criteria** for the block parsing infrastructure ensure that the foundational parsing capabilities work correctly across all supported block types.\n\n| Block Type | Verification Test | Input Example | Expected Output Structure |\n|---|---|---|---|\n| ATX Headings | All heading levels parse correctly | `# H1\\n## H2\\n### H3\\n#### H4\\n##### H5\\n###### H6` | Six `BlockNode` instances with correct levels 1-6 |\n| Setext Headings | Underline styles recognized | `Heading 1\\n========\\nHeading 2\\n--------` | Two `BlockNode` instances with levels 1 and 2 |\n| Paragraphs | Text grouping with blank line separation | `Para 1\\n\\nPara 2\\n\\nPara 3` | Three separate `BlockNode` instances with `block_type=PARAGRAPH` |\n| Fenced Code | Language hints and content preservation | ````python\\nprint(\"hello\")\\n```  | `BlockNode` with language=\"python\", exact content preservation |\n| Indented Code | Four-space rule compliance | `    code line 1\\n    code line 2` | Single code `BlockNode` with preserved indentation |\n| Blockquotes | Simple and nested structures | `> Quote\\n>> Nested\\n> Back to level 1` | Nested `BlockNode` tree with proper hierarchy |\n| Horizontal Rules | Various marker patterns | `---\\n***\\n___` | Three `BlockNode` instances with `block_type=HORIZONTAL_RULE` |\n\n**State Machine Verification** ensures that the `BlockParserState` transitions work correctly and don't leave the parser in inconsistent states.\n\n| State Transition | Test Scenario | Expected Behavior | Error Detection |\n|---|---|---|---|\n| `LOOKING_FOR_BLOCK` → `IN_PARAGRAPH` | Regular text line encountered | Creates new paragraph block, transitions state | Should not remain in looking state |\n| `IN_PARAGRAPH` → `LOOKING_FOR_BLOCK` | Blank line encountered | Finalizes paragraph, resets state | Paragraph should be added to document |\n| `IN_FENCED_CODE` → `LOOKING_FOR_BLOCK` | Matching closing fence | Finalizes code block with preserved content | Missing closure should be detected |\n| Mixed block transitions | Complex document with all block types | All blocks parsed correctly in sequence | No state machine confusion |\n\n**Manual Verification Steps** provide concrete actions to verify milestone completion:\n\n1. **Create comprehensive test document** containing all supported block types in various combinations\n2. **Run block parser** on the test document and examine the generated AST structure\n3. **Verify AST node count** matches expected number of blocks (use `debug_print_ast` function)\n4. **Check block type assignment** - each block should have correct `block_type` value\n5. **Validate content extraction** - block content should match original text with proper whitespace handling\n6. **Test edge cases** - empty blocks, blocks at document boundaries, maximum nesting levels\n\n**Milestone 1 Checkpoint Command Sequence**:\n```bash\n# Run comprehensive block parser tests\npython -m pytest tests/unit/block_parser/ -v\n\n# Run milestone 1 integration tests\npython -m pytest tests/integration/milestone1/ -v\n\n# Manual verification with debug output\npython -c \"\nfrom markdown_parser import MarkdownParser\nparser = MarkdownParser()\nast = parser.parse_blocks(open('test_documents/milestone1_comprehensive.md').read())\nparser.debug_print_ast(ast, 0)\n\"\n```\n\n#### Milestone 2: Inline Elements Verification\n\n**Delimiter Matching Verification** ensures that the `DelimiterStack` correctly handles all emphasis and formatting patterns.\n\n| Formatting Type | Test Pattern | Expected Result | Common Failure Mode |\n|---|---|---|---|\n| Bold (asterisk) | `**bold text**` | `InlineNode` with `inline_type=STRONG` | Fails to match across line breaks |\n| Bold (underscore) | `__bold text__` | `InlineNode` with `inline_type=STRONG` | Incorrectly matches intraword |\n| Italic (asterisk) | `*italic text*` | `InlineNode` with `inline_type=EMPHASIS` | Conflicts with list markers |\n| Italic (underscore) | `_italic text_` | `InlineNode` with `inline_type=EMPHASIS` | Triggers on snake_case variables |\n| Nested emphasis | `**bold with *italic* inside**` | Properly nested `InlineNode` tree | Incorrect precedence resolution |\n| Inline code | `` `code span` `` | `InlineNode` with `inline_type=CODE` | Doesn't preserve internal formatting |\n| Links | `[text](url)` | `InlineNode` with URL and text extracted | Fails on nested brackets |\n| Images | `![alt](url)` | `InlineNode` with alt text and URL | Confuses with link syntax |\n\n**Flanking Detection Verification** validates the complex rules for when delimiters can open or close emphasis spans.\n\n| Flanking Scenario | Test Case | Expected Behavior | Rule Applied |\n|---|---|---|---|\n| Left-flanking asterisk | `*emphasis` at word start | Can open emphasis | Preceded by whitespace or punctuation |\n| Right-flanking asterisk | `emphasis*` at word end | Can close emphasis | Followed by whitespace or punctuation |\n| Non-flanking underscore | `snake_case_var` | Cannot open/close | Surrounded by alphanumeric characters |\n| Punctuation flanking | `\"*quoted emphasis*\"` | Can open and close | Punctuation counts as whitespace |\n| Mixed flanking | `*emphasis* and **bold**` | Correct delimiter pairing | Doesn't cross-match different types |\n\n**Manual Verification Steps** for inline parsing:\n\n1. **Create inline formatting test suite** with all supported inline elements\n2. **Verify delimiter stack behavior** by adding debug output to delimiter matching\n3. **Test precedence rules** with complex nested formatting combinations\n4. **Validate escape sequence handling** - escaped delimiters should render literally\n5. **Check URL parsing accuracy** for links and images with various URL formats\n\n#### Milestone 3: Lists Verification\n\n**List Structure Verification** validates the complex indentation tracking and nesting logic implemented in the `ListContext` system.\n\n| List Type | Test Pattern | Expected Structure | Nesting Validation |\n|---|---|---|---|\n| Simple unordered | `- Item 1\\n- Item 2` | Single `BlockNode` list with two items | Flat structure, no nesting |\n| Simple ordered | `1. First\\n2. Second` | Single ordered list with sequential numbering | Preserves start numbers |\n| Nested unordered | `- Parent\\n  - Child\\n- Sibling` | Nested list structure | Child list within first item |\n| Mixed nesting | `1. Ordered\\n   - Unordered child\\n2. Next` | Mixed list types in hierarchy | Proper type preservation |\n| Multi-paragraph items | `- Para 1\\n\\n  Para 2\\n- Next item` | Items containing multiple blocks | Paragraph nesting within items |\n\n**Indentation Tracking Verification** ensures that the `ListContext` and indentation calculation work correctly across different scenarios.\n\n| Indentation Scenario | Test Case | Expected Behavior | Error Detection |\n|---|---|---|---|\n| Consistent spaces | All items use 2-space indent | Proper nesting levels calculated | Should build clean hierarchy |\n| Tab vs space mixing | Some items use tabs, others spaces | Normalized to consistent spacing | Should detect and handle gracefully |\n| Lazy continuation | Multi-line items without full indent | Content correctly attributed to items | Should not break item boundaries |\n| Over-indentation | Items indented more than required | Treated as code blocks within items | Should preserve extra indentation |\n\n**Manual Verification Steps** for list parsing:\n\n1. **Test complex nesting scenarios** with multiple levels and mixed types\n2. **Verify tight vs loose list detection** by checking spacing between items\n3. **Validate continuation line handling** for items spanning multiple lines\n4. **Test list boundary detection** - where lists end and other blocks begin\n5. **Check marker consistency enforcement** within single lists\n\n#### Milestone 4: HTML Generation Verification\n\n**HTML Validity Verification** ensures that the generated HTML is standards-compliant and semantically correct.\n\n| Validity Aspect | Verification Method | Expected Result | Validation Tool |\n|---|---|---|---|\n| HTML5 Compliance | W3C validator on generated output | Zero validation errors | Nu HTML Checker |\n| Character Escaping | Special characters in various contexts | Proper entity encoding | Manual inspection + validation |\n| Tag Nesting | Complex nested structures | Properly closed and nested tags | HTML parser verification |\n| Attribute Formatting | Links, images with various attributes | Quoted, escaped attribute values | Attribute syntax validation |\n| Semantic Correctness | Markdown meaning preserved in HTML | Equivalent semantic meaning | Manual comparison |\n\n**Pretty Printing Verification** validates that the optional formatting produces readable, well-structured HTML output.\n\n| Formatting Aspect | Test Case | Expected Output | Quality Measure |\n|---|---|---|---|\n| Consistent Indentation | Nested block structures | Each nesting level properly indented | 2-space increments |\n| Line Breaking | Long documents | Appropriate line breaks between blocks | Readable structure |\n| Inline Element Handling | Mixed block and inline content | Inline elements on same line as parents | No unnecessary breaks |\n| Whitespace Preservation | Code blocks and preformatted text | Exact whitespace preservation where needed | Content fidelity |\n\n**End-to-End Integration Verification** tests the complete pipeline from markdown input to HTML output.\n\n| Integration Test | Input Document Type | Validation Criteria | Success Metric |\n|---|---|---|---|\n| CommonMark Specification Examples | Official CommonMark test suite | Matches expected HTML output | 100% spec compliance |\n| Real-world Documents | GitHub README files, documentation | Produces usable, readable HTML | Visual inspection passes |\n| Stress Testing | Large documents (1000+ lines) | Completes without errors or crashes | Performance within bounds |\n| Malformed Input Recovery | Documents with syntax errors | Produces valid HTML despite errors | Graceful degradation |\n\n**Final Verification Command Sequence**:\n```bash\n# Run complete test suite\npython -m pytest tests/ -v --cov=markdown_parser\n\n# Validate against CommonMark spec examples\npython scripts/run_spec_tests.py\n\n# Generate HTML from sample documents\npython -c \"\nfrom markdown_parser import MarkdownParser\nparser = MarkdownParser()\nhtml = parser.parse_to_html(open('samples/comprehensive_test.md').read())\nprint(html)\n\" > output.html\n\n# Validate generated HTML\ncurl -X POST -F \"file=@output.html\" https://validator.w3.org/nu/\n\n# Performance baseline test\ntime python -c \"\nfrom markdown_parser import MarkdownParser\nparser = MarkdownParser()\nhtml = parser.parse_to_html(open('samples/large_document.md').read())\n\"\n```\n\n> The verification checkpoints serve as both quality gates and confidence builders. Each checkpoint confirms that the implementation is solid before adding complexity in the next milestone. This systematic approach prevents the common trap of building on unstable foundations.\n\n### Implementation Guidance\n\nThis section provides concrete tools and approaches for implementing a comprehensive testing strategy that supports both learning and quality assurance throughout the markdown renderer development process.\n\n#### Technology Recommendations Table\n\n| Test Category | Simple Option | Advanced Option |\n|---|---|---|\n| Unit Testing Framework | `unittest` (Python standard library) | `pytest` with fixtures and parametrization |\n| Test Data Management | Inline strings in test methods | External test files with YAML/JSON metadata |\n| Property-Based Testing | Manual edge case enumeration | `hypothesis` library for automated input generation |\n| HTML Validation | Manual inspection with browser | Automated W3C validator API integration |\n| Performance Testing | Simple timing with `time` module | `pytest-benchmark` with statistical analysis |\n| Coverage Analysis | Visual code inspection | `coverage.py` with branch coverage reporting |\n| Test Organization | Single test directory | Structured hierarchy with milestone-based organization |\n\n#### Recommended File Structure\n\nThe testing infrastructure should mirror the component architecture while supporting milestone-based development progression:\n\n```\nmarkdown_parser/\n├── tests/\n│   ├── __init__.py\n│   ├── conftest.py                    ← pytest configuration and shared fixtures\n│   ├── test_data/                     ← shared test documents and expected outputs\n│   │   ├── milestone1_blocks.md       ← comprehensive block parsing test cases\n│   │   ├── milestone2_inline.md       ← inline formatting test cases\n│   │   ├── milestone3_lists.md        ← list parsing test cases\n│   │   ├── milestone4_complete.md     ← full integration test document\n│   │   ├── expected_outputs/          ← expected HTML outputs for integration tests\n│   │   └── malformed_inputs/          ← error handling test cases\n│   ├── unit/                          ← component-level tests\n│   │   ├── __init__.py\n│   │   ├── test_preprocessor.py       ← line processing and normalization tests\n│   │   ├── test_block_parser.py       ← block parsing unit tests\n│   │   ├── test_inline_parser.py      ← inline parsing unit tests\n│   │   ├── test_list_parser.py        ← list parsing unit tests\n│   │   ├── test_html_generator.py     ← HTML generation unit tests\n│   │   └── test_ast_nodes.py          ← AST data structure tests\n│   ├── integration/                   ← multi-component interaction tests\n│   │   ├── __init__.py\n│   │   ├── test_milestone1.py         ← block parsing integration tests\n│   │   ├── test_milestone2.py         ← inline parsing integration tests\n│   │   ├── test_milestone3.py         ← list parsing integration tests\n│   │   ├── test_milestone4.py         ← complete pipeline integration tests\n│   │   └── test_pipeline.py           ← end-to-end pipeline tests\n│   ├── property/                      ← property-based and generative tests\n│   │   ├── __init__.py\n│   │   ├── test_roundtrip.py          ← roundtrip stability tests\n│   │   ├── test_performance.py        ← performance and scalability tests\n│   │   └── test_error_recovery.py     ← error handling property tests\n│   ├── spec_compliance/               ← CommonMark specification compliance\n│   │   ├── __init__.py\n│   │   ├── test_commonmark_spec.py    ← official spec test runner\n│   │   └── commonmark_examples.json   ← spec examples in JSON format\n│   └── manual/                        ← manual testing scripts and tools\n│       ├── debug_ast_viewer.py        ← interactive AST exploration tool\n│       ├── html_validator.py          ← HTML validation utility\n│       └── performance_profiler.py    ← performance analysis tool\n├── scripts/                           ← testing automation scripts\n│   ├── run_milestone_tests.py         ← milestone-specific test runner\n│   ├── generate_coverage_report.py    ← coverage analysis automation\n│   └── validate_html_output.py        ← batch HTML validation\n```\n\n#### Infrastructure Starter Code\n\n**Complete Test Configuration Setup** (`tests/conftest.py`):\n\n```python\n\"\"\"\nPytest configuration and shared test fixtures for markdown parser testing.\nProvides common test utilities and data that can be reused across test modules.\n\"\"\"\n\nimport pytest\nfrom pathlib import Path\nfrom typing import List, Dict, Any\nimport json\nimport yaml\n\nfrom markdown_parser.core import MarkdownParser\nfrom markdown_parser.ast_nodes import ASTNode, BlockNode, InlineNode\nfrom markdown_parser.html_generator import HtmlRenderer\n\n# Test data directory path\nTEST_DATA_DIR = Path(__file__).parent / \"test_data\"\n\n@pytest.fixture\ndef parser():\n    \"\"\"Provides a fresh MarkdownParser instance for each test.\"\"\"\n    return MarkdownParser()\n\n@pytest.fixture\ndef html_renderer():\n    \"\"\"Provides an HtmlRenderer instance with default settings.\"\"\"\n    return HtmlRenderer(pretty_print=True)\n\n@pytest.fixture\ndef sample_documents():\n    \"\"\"Loads all sample documents from test_data directory.\"\"\"\n    documents = {}\n    for md_file in TEST_DATA_DIR.glob(\"*.md\"):\n        with open(md_file, 'r', encoding='utf-8') as f:\n            documents[md_file.stem] = f.read()\n    return documents\n\n@pytest.fixture\ndef expected_outputs():\n    \"\"\"Loads expected HTML outputs for integration testing.\"\"\"\n    outputs = {}\n    expected_dir = TEST_DATA_DIR / \"expected_outputs\"\n    for html_file in expected_dir.glob(\"*.html\"):\n        with open(html_file, 'r', encoding='utf-8') as f:\n            outputs[html_file.stem] = f.read().strip()\n    return outputs\n\n@pytest.fixture\ndef commonmark_examples():\n    \"\"\"Loads CommonMark specification examples for compliance testing.\"\"\"\n    spec_file = TEST_DATA_DIR.parent / \"spec_compliance\" / \"commonmark_examples.json\"\n    if spec_file.exists():\n        with open(spec_file, 'r', encoding='utf-8') as f:\n            return json.load(f)\n    return []\n\nclass ASTTestHelpers:\n    \"\"\"Helper methods for testing AST structure and content.\"\"\"\n    \n    @staticmethod\n    def count_nodes_by_type(root: ASTNode, node_type: str) -> int:\n        \"\"\"Count all nodes of specified type in AST tree.\"\"\"\n        count = 0\n        if hasattr(root, 'node_type') and root.node_type.name == node_type:\n            count += 1\n        for child in getattr(root, 'children', []):\n            count += ASTTestHelpers.count_nodes_by_type(child, node_type)\n        return count\n    \n    @staticmethod\n    def extract_text_content(node: ASTNode) -> str:\n        \"\"\"Extract all text content from node and descendants.\"\"\"\n        text_parts = []\n        if hasattr(node, 'text_content') and node.text_content:\n            text_parts.append(node.text_content)\n        if hasattr(node, 'inline_content') and node.inline_content:\n            text_parts.append(node.inline_content)\n        for child in getattr(node, 'children', []):\n            text_parts.append(ASTTestHelpers.extract_text_content(child))\n        return ''.join(text_parts)\n    \n    @staticmethod\n    def find_nodes_with_content(root: ASTNode, content_substring: str) -> List[ASTNode]:\n        \"\"\"Find all nodes containing specified text content.\"\"\"\n        matches = []\n        node_text = ASTTestHelpers.extract_text_content(root)\n        if content_substring in node_text:\n            matches.append(root)\n        for child in getattr(root, 'children', []):\n            matches.extend(ASTTestHelpers.find_nodes_with_content(child, content_substring))\n        return matches\n\n@pytest.fixture\ndef ast_helpers():\n    \"\"\"Provides AST testing helper methods.\"\"\"\n    return ASTTestHelpers()\n\nclass HTMLValidationHelpers:\n    \"\"\"Helper methods for validating generated HTML output.\"\"\"\n    \n    @staticmethod\n    def validate_html_structure(html: str) -> Dict[str, Any]:\n        \"\"\"Basic HTML structure validation.\"\"\"\n        from html.parser import HTMLParser\n        \n        class ValidationParser(HTMLParser):\n            def __init__(self):\n                super().__init__()\n                self.tag_stack = []\n                self.errors = []\n                self.warnings = []\n            \n            def handle_starttag(self, tag, attrs):\n                if tag not in ['br', 'hr', 'img', 'input', 'meta', 'link']:\n                    self.tag_stack.append(tag)\n            \n            def handle_endtag(self, tag):\n                if self.tag_stack and self.tag_stack[-1] == tag:\n                    self.tag_stack.pop()\n                else:\n                    self.errors.append(f\"Mismatched closing tag: {tag}\")\n            \n            def error(self, message):\n                self.errors.append(message)\n        \n        parser = ValidationParser()\n        try:\n            parser.feed(html)\n            return {\n                'valid': len(parser.errors) == 0,\n                'errors': parser.errors,\n                'warnings': parser.warnings,\n                'unclosed_tags': parser.tag_stack\n            }\n        except Exception as e:\n            return {\n                'valid': False,\n                'errors': [f\"Parse error: {str(e)}\"],\n                'warnings': [],\n                'unclosed_tags': []\n            }\n    \n    @staticmethod\n    def check_character_escaping(html: str) -> Dict[str, bool]:\n        \"\"\"Verify that special characters are properly escaped.\"\"\"\n        import re\n        \n        # Check for unescaped special characters in content (not attributes)\n        content_pattern = r'>([^<]*)<'\n        content_matches = re.findall(content_pattern, html)\n        \n        results = {\n            'ampersands_escaped': all('&' not in content or '&amp;' in content or '&lt;' in content or '&gt;' in content or '&quot;' in content for content in content_matches),\n            'less_than_escaped': all('<' not in content for content in content_matches),\n            'greater_than_escaped': all('>' not in content for content in content_matches),\n            'quotes_handled': True  # More complex check needed for attribute contexts\n        }\n        \n        return results\n\n@pytest.fixture\ndef html_helpers():\n    \"\"\"Provides HTML validation helper methods.\"\"\"\n    return HTMLValidationHelpers()\n\n# Performance testing utilities\n@pytest.fixture\ndef performance_tracker():\n    \"\"\"Provides performance tracking utilities for tests.\"\"\"\n    import time\n    import psutil\n    import os\n    \n    class PerformanceTracker:\n        def __init__(self):\n            self.process = psutil.Process(os.getpid())\n            self.start_time = None\n            self.start_memory = None\n        \n        def start_tracking(self):\n            self.start_time = time.perf_counter()\n            self.start_memory = self.process.memory_info().rss\n        \n        def stop_tracking(self):\n            end_time = time.perf_counter()\n            end_memory = self.process.memory_info().rss\n            \n            return {\n                'duration_seconds': end_time - self.start_time,\n                'memory_delta_bytes': end_memory - self.start_memory,\n                'final_memory_mb': end_memory / (1024 * 1024)\n            }\n    \n    return PerformanceTracker()\n```\n\n**Complete Test Data Generator** (`scripts/generate_test_cases.py`):\n\n```python\n\"\"\"\nGenerates comprehensive test cases for all markdown parser components.\nCreates both positive test cases and negative/edge case scenarios.\n\"\"\"\n\nimport os\nimport json\nfrom pathlib import Path\nfrom typing import List, Dict, Any, Tuple\n\ndef generate_block_test_cases() -> Dict[str, str]:\n    \"\"\"Generate comprehensive block parsing test cases.\"\"\"\n    \n    test_cases = {\n        'milestone1_blocks': \"\"\"# Top Level Heading\n\nThis is a regular paragraph with some text that spans\nmultiple lines but should be grouped together.\n\n```\n\n## Second Level Heading\n\nAnother paragraph here.\n\n### Third Level Heading\n\n    This is indented code block\n    with multiple lines\n    and preserved spacing\n\n```python\n# This is fenced code block\ndef hello_world():\n    print(\"Hello, World!\")\n```\n\n```\nPlain fenced code without language\n```\n\n> This is a blockquote\n> that spans multiple lines\n> and maintains formatting\n\n> ## Heading in blockquote\n> \n> Paragraph in blockquote with blank lines around it.\n\n---\n\nHorizontal rule above.\n\n***\n\nAnother horizontal rule.\n\n___\n\nThird horizontal rule style.\n\n#### Nested Blockquotes\n\n> Level 1 quote\n>> Level 2 nested quote  \n>> Still level 2\n> Back to level 1\n\n##### Mixed Block Types\n\nRegular paragraph followed by:\n\n```\nCode block\n```\n\n> Quote block\n\nMore regular text.\n\n###### Edge Cases\n\n# Heading with extra spaces   \n\n   ## Heading with leading spaces\n\n#No space after hash\n\n# \n\nEmpty heading content above.\n\n####### Invalid - too many hashes\n\nSetext Heading Level 1\n======================\n\nSetext Heading Level 2\n----------------------\n\nNot a setext heading\n---regular text continues---\n\"\"\",\n        \n        'edge_cases_blocks': \"\"\"\n\n\nDocument starting with blank lines.\n\n# Heading immediately after blanks\n\nParagraph with trailing spaces.   \n\n    Indented code with trailing spaces    \n    Second line of code  \n\n```javascript\n// Fenced code with empty lines\n\nconsole.log(\"test\");\n\n```\n\n> Blockquote with trailing spaces   \n> Second line  \n\n---   \n\nText immediately after horizontal rule.\n\nMixed line endings test case would be handled by test runner.\n\nLast paragraph without trailing newline.\"\"\"\n    }\n    \n    return test_cases\n\ndef generate_inline_test_cases() -> Dict[str, str]:\n    \"\"\"Generate comprehensive inline parsing test cases.\"\"\"\n    \n    test_cases = {\n        'milestone2_inline': \"\"\"# Inline Formatting Tests\n\n## Basic Emphasis\n\nThis paragraph contains **bold text** and *italic text* for testing.\n\nAlso testing __bold with underscores__ and _italic with underscores_.\n\n## Nested Formatting\n\nHere is **bold text with *italic inside* it** for testing nesting.\n\nAnd here is *italic text with **bold inside** it* for reverse nesting.\n\n## Code Spans\n\nHere is `inline code` within a sentence.\n\nHere is `code with **bold** inside` where the bold should not render.\n\n## Links and Images\n\nThis is a [simple link](http://example.com) in text.\n\nThis is a [link with title](http://example.com \"Example Title\") including title.\n\nHere is an image: ![Alt text](http://example.com/image.jpg)\n\nAnd an image with title: ![Alt text](http://example.com/image.jpg \"Image Title\")\n\n## Complex Link Cases\n\n[Link with *emphasis* in text](http://example.com)\n\n[Link with `code` in text](http://example.com)\n\n## Edge Cases for Emphasis\n\nThis has *emphasis at start* of sentence.\n\nThis has emphasis *at the end*.\n\n*Emphasis at paragraph start* looks like this.\n\nWords with under_scores_inside should not be emphasized.\n\nBut _this should be emphasized_ because it has word boundaries.\n\n## Escape Sequences\n\nThis has \\\\*escaped asterisks\\\\* that should not format.\n\nAnd \\\\`escaped backticks\\\\` that should not format.\n\nAlso \\\\[escaped brackets\\\\] and \\\\! exclamation points.\n\n## Complex Combinations\n\n**Bold text with [a link](http://example.com) inside**.\n\n*Italic text with `code` and [link](http://example.com) inside*.\n\n[Link with **bold** and *italic* text](http://example.com)\n\n## Delimiter Matching Edge Cases\n\n**This is bold** but **this** is also **bold**.\n\n*Single* and *multiple* and *italic* spans.\n\n**Unmatched bold at end\n\n*Unmatched italic at end\n\n**Bold with *italic inside** and back to normal*.\n\nMismatched delimiters: **bold* should not work.\n\n## URL Edge Cases\n\n[Link with spaces in URL](http://example.com/path with spaces)\n\n[Link with special chars](http://example.com/path?param=value&other=value2)\n\n<http://autolink.example.com>\n\n<autolink@email.com>\n\"\"\",\n        \n        'delimiter_edge_cases': \"\"\"**bold**normal*italic*normal**bold**\n\n***bold italic*** combined\n\n**bold *italic in bold* bold**\n\n*italic **bold in italic** italic*\n\nsnake_case_variable_name\n\n_emphasis_with_underscores_\n\n__double__underscore__test__\n\n*emphasis* and **bold** and `code`\n\n[link](url)*italic*[link](url)\n\n![image](url)**bold**![image](url)\n\n`code with *emphasis* inside`\n\n`code` and *emphasis* and `code`\n\n**bold\nacross\nlines**\n\n*italic\nacross  \nlines*\n\n---\n\nThis is **bold and [link](http://example.com) and `code`** together.\n\n*This is italic with ![image](image.jpg) inside.*\n\n***\n\nEdge case: ** (empty emphasis)\n\nEdge case: __ (empty emphasis)\n\nEdge case: ` (single backtick)\n\nEdge case: ```\n\n[](empty link)\n\n![](empty image)\n\"\"\"\n    }\n    \n    return test_cases\n\ndef generate_list_test_cases() -> Dict[str, str]:\n    \"\"\"Generate comprehensive list parsing test cases.\"\"\"\n    \n    test_cases = {\n        'milestone3_lists': \"\"\"# List Parsing Tests\n\n## Simple Unordered Lists\n\n- First item\n- Second item\n- Third item\n\n* Alternative bullet style\n* Second item with asterisk\n* Third item\n\n+ Plus sign bullets\n+ Second item with plus\n+ Third item\n\n## Simple Ordered Lists\n\n1. First numbered item\n2. Second numbered item\n3. Third numbered item\n\n1) Alternative parenthesis style\n2) Second item with parenthesis\n3) Third item\n\n## Nested Lists\n\n- Top level item\n  - Nested item level 2\n  - Another nested item\n    - Deeper nesting level 3\n    - More deep content\n  - Back to level 2\n- Back to top level\n\n## Mixed List Types\n\n1. Ordered parent\n   - Unordered child\n   - Another unordered child\n     1. Ordered grandchild\n     2. Another ordered grandchild\n   - Back to unordered child level\n2. Second ordered parent\n\n## Multi-paragraph List Items\n\n- First item with single paragraph\n\n- Second item with multiple paragraphs\n\n  This is the second paragraph of the second item.\n  It continues here.\n\n  And this is a third paragraph in the same item.\n\n- Third item back to single paragraph\n\n## Lists with Code Blocks\n\n1. Item with indented code block:\n\n       def example_function():\n           return \"Hello World\"\n\n2. Item with fenced code block:\n\n   ```python\n   def another_example():\n       print(\"In a list!\")\n   ```\n\n3. Regular item after code\n\n## Lists with Blockquotes\n\n- Item with blockquote:\n\n  > This is a quote inside a list item.\n  > It continues on multiple lines.\n\n- Another regular item\n\n## Tight vs Loose Lists\n\nTight list (no blank lines):\n- Item 1\n- Item 2\n- Item 3\n\nLoose list (blank lines between items):\n\n- Item 1\n\n- Item 2\n\n- Item 3\n\n## Complex Nesting with Mixed Content\n\n1. First ordered item\n\n   This item has a paragraph.\n\n   - Nested unordered list\n   - With multiple items\n   \n     1. And further nesting\n     2. With ordered list\n     \n        > And even blockquotes\n        > Inside nested items\n\n   Back to paragraph in first item.\n\n2. Second ordered item with `inline code`\n\n## Edge Cases\n\n- Item with *emphasis* and **bold** and [links](http://example.com)\n- Item with `inline code` formatting\n- Item ending with colon:\n- Item with trailing spaces   \n-Item without space after marker\n  -Nested without proper spacing\n    -Deep nesting spacing issues\n\n## Lazy Continuation\n\n- This is a lazy continuation\nwhere the second line doesn't have\nproper indentation but should still\nbe part of the same item.\n\n  - Nested item\nwith lazy continuation\nthat continues without indentation.\n\n## List Marker Consistency\n\n- First item with dash\n- Second item with dash\n* This starts a new list with asterisk\n* Because marker changed\n\n1. Ordered list\n2. Continues with same marker\n1) This starts new list with different marker\n2) Because marker style changed\n\n## Lists at Document Boundaries\n\nFirst paragraph.\n\n- List immediately after paragraph\n- Without blank line\n\nLast list at end of document:\n- Item 1\n- Item 2\"\"\",\n        \n        'list_edge_cases': \"\"\"1.No space after period\n\n2. Item with proper space\n\n-No space after dash\n- Item with proper space\n\n1.  Multiple spaces after period\n-   Multiple spaces after dash\n\n   1. Indented ordered list\n   2. Second indented item\n\n* List with lots of content\n\n  Multiple paragraphs in item.\n  \n  > Blockquote in item\n  \n      Code in item\n      \n  More text.\n\n* Next item\n\n15. List starting with large number\n16. Continues correctly\n\n0. List starting with zero\n1. Next item\n\n-1. Invalid negative number (should be paragraph)\n\n1. Item\n  2. Invalid nesting (different marker continuation)\n  \n1.Item without space\n 2. Item with wrong indentation\n\nText\n\n1. List after text without blank line\n2. Should still work per CommonMark\n\nParagraph\n- Unordered after paragraph\n- Also works\n\nMixed indentation:\n\t1. Tab indented\n    2. Space indented (may cause issues)\n\nEmpty items:\n- \n- Item after empty\n-\n\nTrailing content:\n1. Item with trailing content...\n2. ...continues here\n\"\"\"\n    }\n    \n    return test_cases\n\ndef generate_html_output_test_cases() -> Dict[str, str]:\n    \"\"\"Generate expected HTML outputs for integration testing.\"\"\"\n    \n    expected_outputs = {\n        'simple_blocks': \"\"\"<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Generated HTML</title>\n</head>\n<body>\n  <h1>Main Heading</h1>\n  <p>This is a simple paragraph with some text.</p>\n  <h2>Subheading</h2>\n  <p>Another paragraph here.</p>\n  <pre><code>Code block content\nwith multiple lines</code></pre>\n  <blockquote>\n    <p>This is a quote block.</p>\n  </blockquote>\n  <hr>\n</body>\n</html>\"\"\",\n        \n        'inline_formatting': \"\"\"<h1>Inline Tests</h1>\n<p>This has <strong>bold</strong> and <em>italic</em> text.</p>\n<p>Also <code>inline code</code> and <a href=\"http://example.com\">links</a>.</p>\n<p>Complex: <strong>bold with <em>italic</em> inside</strong>.</p>\"\"\",\n        \n        'nested_lists': \"\"\"<ol>\n  <li>\n    <p>First item</p>\n    <ul>\n      <li>Nested item</li>\n      <li>Another nested</li>\n    </ul>\n  </li>\n  <li>Second item</li>\n</ol>\"\"\"\n    }\n    \n    return expected_outputs\n\ndef create_test_data_files():\n    \"\"\"Create all test data files in the appropriate directory structure.\"\"\"\n    \n    # Create directory structure\n    base_dir = Path(\"tests/test_data\")\n    base_dir.mkdir(parents=True, exist_ok=True)\n    \n    expected_dir = base_dir / \"expected_outputs\"\n    expected_dir.mkdir(exist_ok=True)\n    \n    malformed_dir = base_dir / \"malformed_inputs\"\n    malformed_dir.mkdir(exist_ok=True)\n    \n    # Generate and write block test cases\n    block_cases = generate_block_test_cases()\n    for name, content in block_cases.items():\n        with open(base_dir / f\"{name}.md\", 'w', encoding='utf-8') as f:\n            f.write(content)\n    \n    # Generate and write inline test cases\n    inline_cases = generate_inline_test_cases()\n    for name, content in inline_cases.items():\n        with open(base_dir / f\"{name}.md\", 'w', encoding='utf-8') as f:\n            f.write(content)\n    \n    # Generate and write list test cases\n    list_cases = generate_list_test_cases()\n    for name, content in list_cases.items():\n        with open(base_dir / f\"{name}.md\", 'w', encoding='utf-8') as f:\n            f.write(content)\n    \n    # Generate and write expected HTML outputs\n    html_outputs = generate_html_output_test_cases()\n    for name, content in html_outputs.items():\n        with open(expected_dir / f\"{name}.html\", 'w', encoding='utf-8') as f:\n            f.write(content)\n    \n    print(f\"Generated test data files in {base_dir}\")\n\nif __name__ == \"__main__\":\n    create_test_data_files()\n```\n\n```\n\n#### Core Logic Skeleton Code\n\n**Block Parser Test Template** (`tests/unit/test_block_parser.py`):\n\n```python\n\"\"\"\nUnit tests for block-level element parsing.\nTests each block type in isolation to verify correct parsing behavior.\n\"\"\"\n\nimport pytest\nfrom markdown_parser.block_parser import BlockParser, BlockParserState\nfrom markdown_parser.ast_nodes import BlockNode, NodeType, BlockType\nfrom markdown_parser.preprocessor import LineInfo\n\nclass TestBlockParserCore:\n    \"\"\"Test core block parser functionality.\"\"\"\n    \n    def test_parser_initialization(self):\n        \"\"\"Verify parser initializes with correct default state.\"\"\"\n        parser = BlockParser()\n        # TODO: Assert parser state is LOOKING_FOR_BLOCK\n        # TODO: Assert document root is created with correct type\n        # TODO: Assert line buffer is empty\n        \n    def test_line_processing_basic(self, parser):\n        \"\"\"Test basic line processing without specific block types.\"\"\"\n        lines = [\n            LineInfo(\"Regular text\", 1, False, 0),\n            LineInfo(\"\", 2, True, 0),\n            LineInfo(\"More text\", 3, False, 0)\n        ]\n        \n        # TODO: Process line sequence through parser\n        # TODO: Verify correct number of blocks created\n        # TODO: Check that blank lines separate blocks appropriately\n        # TODO: Validate final parser state\n\nclass TestATXHeadings:\n    \"\"\"Test ATX-style heading parsing (#, ##, ###, etc.).\"\"\"\n    \n    @pytest.mark.parametrize(\"level,markdown,expected_text\", [\n        (1, \"# Heading 1\", \"Heading 1\"),\n        (2, \"## Heading 2\", \"Heading 2\"),\n        (3, \"### Heading 3\", \"Heading 3\"),\n        (4, \"#### Heading 4\", \"Heading 4\"),\n        (5, \"##### Heading 5\", \"Heading 5\"),\n        (6, \"###### Heading 6\", \"Heading 6\"),\n    ])\n    def test_atx_heading_levels(self, parser, level, markdown, expected_text):\n        \"\"\"Test all valid ATX heading levels parse correctly.\"\"\"\n        line = LineInfo(markdown, 1, False, 0)\n        \n        # TODO: Process line through parser\n        # TODO: Verify BlockNode created with block_type=HEADING\n        # TODO: Check heading level attribute matches expected\n        # TODO: Verify text content matches expected_text\n        # TODO: Ensure no child nodes created for simple heading\n    \n    def test_atx_heading_with_trailing_hashes(self, parser):\n        \"\"\"Test ATX headings with optional trailing hash marks.\"\"\"\n        test_cases = [\n            (\"# Heading #\", \"Heading\"),\n            (\"## Heading ##\", \"Heading\"),\n            (\"### Heading ###\", \"Heading\"),\n            (\"# Heading ####\", \"Heading\"),  # Mismatched trailing\n        ]\n        \n        for markdown, expected_text in test_cases:\n            # TODO: Parse each test case\n            # TODO: Verify trailing hashes are stripped correctly\n            # TODO: Check that mismatched trailing hashes are handled\n    \n    def test_atx_heading_edge_cases(self, parser):\n        \"\"\"Test edge cases for ATX heading parsing.\"\"\"\n        edge_cases = [\n            (\"#No space\", False),  # Should not be heading\n            (\"# \", True),          # Empty heading content\n            (\"#######\", False),    # Too many hashes\n            (\"  # Indented\", False), # Indented headings invalid\n        ]\n        \n        for markdown, should_be_heading in edge_cases:\n            # TODO: Process each edge case\n            # TODO: Verify heading detection matches expected\n            # TODO: For non-headings, ensure treated as paragraph\n            # TODO: For invalid cases, check error recovery\n\nclass TestSetextHeadings:\n    \"\"\"Test Setext-style heading parsing (underlined headings).\"\"\"\n    \n    def test_setext_h1_detection(self, parser):\n        \"\"\"Test detection of H1 Setext headings with = underlines.\"\"\"\n        markdown_lines = [\n            LineInfo(\"Main Heading\", 1, False, 0),\n            LineInfo(\"============\", 2, False, 0)\n        ]\n        \n        # TODO: Process both lines through parser\n        # TODO: Verify single BlockNode created with HEADING type\n        # TODO: Check heading level is 1\n        # TODO: Verify text content is \"Main Heading\"\n        # TODO: Ensure underline is not included in content\n    \n    def test_setext_h2_detection(self, parser):\n        \"\"\"Test detection of H2 Setext headings with - underlines.\"\"\"\n        # TODO: Similar test structure as H1 but with dashes\n        # TODO: Verify heading level is 2\n        # TODO: Test various dash lengths and patterns\n    \n    def test_setext_invalid_cases(self, parser):\n        \"\"\"Test cases that look like Setext but should not be headings.\"\"\"\n        invalid_cases = [\n            # Blank line before underline breaks Setext\n            [\"Text\", \"\", \"===\"],\n            # Mixed underline characters\n            [\"Text\", \"=-=\"],\n            # Underline without preceding text\n            [\"\", \"===\"],\n        ]\n        \n        # TODO: Test each invalid case\n        # TODO: Verify they are treated as separate paragraphs/blocks\n        # TODO: Check no heading nodes are created\n\nclass TestParagraphs:\n    \"\"\"Test paragraph detection and grouping.\"\"\"\n    \n    def test_simple_paragraph(self, parser):\n        \"\"\"Test basic paragraph creation from consecutive lines.\"\"\"\n        lines = [\n            LineInfo(\"First line of paragraph.\", 1, False, 0),\n            LineInfo(\"Second line continues paragraph.\", 2, False, 0),\n            LineInfo(\"Third line also continues.\", 3, False, 0)\n        ]\n        \n        # TODO: Process lines through parser\n        # TODO: Verify single BlockNode created with PARAGRAPH type\n        # TODO: Check all lines are included in paragraph content\n        # TODO: Verify line breaks are preserved appropriately\n    \n    def test_paragraph_separation(self, parser):\n        \"\"\"Test that blank lines separate paragraphs correctly.\"\"\"\n        lines = [\n            LineInfo(\"First paragraph.\", 1, False, 0),\n            LineInfo(\"\", 2, True, 0),\n            LineInfo(\"Second paragraph.\", 3, False, 0),\n            LineInfo(\"\", 4, True, 0),\n            LineInfo(\"Third paragraph.\", 5, False, 0)\n        ]\n        \n        # TODO: Process all lines\n        # TODO: Verify three separate BlockNode instances created\n        # TODO: Check each has PARAGRAPH type\n        # TODO: Ensure content separation is correct\n        # TODO: Verify no blank line content in paragraphs\n\nclass TestCodeBlocks:\n    \"\"\"Test both fenced and indented code block parsing.\"\"\"\n    \n    def test_fenced_code_basic(self, parser):\n        \"\"\"Test basic fenced code block parsing.\"\"\"\n        lines = [\n            LineInfo(\"```\", 1, False, 0),\n            LineInfo(\"code line 1\", 2, False, 0),\n            LineInfo(\"code line 2\", 3, False, 0),\n            LineInfo(\"```\", 4, False, 0)\n        ]\n        \n        # TODO: Process lines through parser\n        # TODO: Verify BlockNode created with CODE_BLOCK type\n        # TODO: Check exact content preservation including whitespace\n        # TODO: Ensure fence markers are not included in content\n        # TODO: Verify parser state transitions correctly\n    \n    def test_fenced_code_with_language(self, parser):\n        \"\"\"Test fenced code blocks with language identifiers.\"\"\"\n        lines = [\n            LineInfo(\"```python\", 1, False, 0),\n            LineInfo(\"def hello():\", 2, False, 0),\n            LineInfo(\"    print('Hello')\", 3, False, 0),\n            LineInfo(\"```\", 4, False, 0)\n        ]\n        \n        # TODO: Parse and verify language attribute is set\n        # TODO: Check that language info doesn't appear in content\n        # TODO: Verify code content is preserved exactly\n    \n    def test_indented_code_block(self, parser):\n        \"\"\"Test indented code block parsing (4+ spaces).\"\"\"\n        lines = [\n            LineInfo(\"    code line 1\", 1, False, 4),\n            LineInfo(\"    code line 2\", 2, False, 4),\n            LineInfo(\"        more indented\", 3, False, 8),\n            LineInfo(\"    back to base\", 4, False, 4)\n        ]\n        \n        # TODO: Process indented lines\n        # TODO: Verify CODE_BLOCK type created\n        # TODO: Check that base indentation is removed\n        # TODO: Ensure relative indentation is preserved\n        # TODO: Test transition out of code block state\n    \n    def test_code_block_edge_cases(self, parser):\n        \"\"\"Test edge cases for code block parsing.\"\"\"\n        # TODO: Test unclosed fenced code blocks (EOF)\n        # TODO: Test empty code blocks\n        # TODO: Test mixed indentation in code blocks\n        # TODO: Test fence markers inside code content\n        # TODO: Test language identifiers with spaces/special chars\n\nclass TestBlockquotes:\n    \"\"\"Test blockquote parsing including nested blockquotes.\"\"\"\n    \n    def test_simple_blockquote(self, parser):\n        \"\"\"Test basic blockquote parsing.\"\"\"\n        lines = [\n            LineInfo(\"> This is a quote\", 1, False, 0),\n            LineInfo(\"> It continues here\", 2, False, 0)\n        ]\n        \n        # TODO: Process blockquote lines\n        # TODO: Verify BLOCKQUOTE type BlockNode created\n        # TODO: Check that > markers are stripped from content\n        # TODO: Ensure content is preserved correctly\n    \n    def test_nested_blockquotes(self, parser):\n        \"\"\"Test nested blockquote structures.\"\"\"\n        lines = [\n            LineInfo(\"> Level 1\", 1, False, 0),\n            LineInfo(\">> Level 2\", 2, False, 0),\n            LineInfo(\">>> Level 3\", 3, False, 0),\n            LineInfo(\">> Back to Level 2\", 4, False, 0),\n            LineInfo(\"> Back to Level 1\", 5, False, 0)\n        ]\n        \n        # TODO: Parse nested structure\n        # TODO: Verify proper nesting hierarchy in AST\n        # TODO: Check parent-child relationships are correct\n        # TODO: Ensure content at each level is accurate\n\nclass TestHorizontalRules:\n    \"\"\"Test horizontal rule parsing with different marker styles.\"\"\"\n    \n    @pytest.mark.parametrize(\"marker_line\", [\n        \"---\",\n        \"***\",\n        \"___\",\n        \"----\",\n        \"*****\",\n        \"_____\",\n        \"- - -\",\n        \"* * *\",\n        \"_ _ _\"\n    ])\n    def test_horizontal_rule_variants(self, parser, marker_line):\n        \"\"\"Test all valid horizontal rule patterns.\"\"\"\n        line = LineInfo(marker_line, 1, False, 0)\n        \n        # TODO: Process horizontal rule line\n        # TODO: Verify HORIZONTAL_RULE type BlockNode created\n        # TODO: Check that content is empty or minimal\n        # TODO: Ensure parser state resets correctly after rule\n    \n    def test_horizontal_rule_invalid(self, parser):\n        \"\"\"Test patterns that look like HR but should not be.\"\"\"\n        invalid_patterns = [\n            \"--\",      # Too short\n            \"- -\",     # Too short\n            \"-- -\",    # Mixed patterns\n            \"***text\", # Text after markers\n        ]\n        \n        for pattern in invalid_patterns:\n            # TODO: Process each invalid pattern\n            # TODO: Verify NO horizontal rule is created\n            # TODO: Check that line is treated as paragraph instead\n\n# TODO: Add comprehensive integration tests that combine multiple block types\n# TODO: Add state machine transition tests\n# TODO: Add error recovery tests for malformed blocks\n# TODO: Add performance tests with large documents\n```\n\n**Milestone Checkpoint Implementation** (`scripts/run_milestone_tests.py`):\n\n```python\n\"\"\"\nAutomated milestone verification script.\nRuns appropriate test suites for each milestone and provides clear pass/fail feedback.\n\"\"\"\n\nimport sys\nimport subprocess\nimport json\nfrom pathlib import Path\nfrom typing import Dict, List, Any, Optional\nimport time\n\nclass MilestoneTestRunner:\n    \"\"\"Coordinates milestone-specific testing and validation.\"\"\"\n    \n    def __init__(self, project_root: Path):\n        self.project_root = project_root\n        self.test_results = {}\n        \n    def run_milestone_1_tests(self) -> Dict[str, Any]:\n        \"\"\"Run all tests required for Milestone 1: Block Elements.\"\"\"\n        print(\"🧪 Running Milestone 1: Block Elements Tests\")\n        \n        results = {\n            'milestone': 1,\n            'description': 'Block Elements',\n            'test_categories': {},\n            'overall_status': 'pending'\n        }\n        \n        # TODO: Run block parser unit tests\n        # TODO: Command: pytest tests/unit/test_block_parser.py -v\n        # TODO: Capture output and parse results\n        # TODO: Check for specific test method completions\n        \n        # TODO: Run block parsing integration tests\n        # TODO: Command: pytest tests/integration/test_milestone1.py -v\n        # TODO: Verify AST structure correctness\n        \n        # TODO: Run manual verification steps\n        # TODO: Parse comprehensive test document\n        # TODO: Validate AST node counts and types\n        # TODO: Check for proper block detection\n        \n        # TODO: Generate summary report\n        # TODO: Set overall_status based on all test results\n        # TODO: Return detailed results dictionary\n        \n        return results\n    \n    def run_milestone_2_tests(self) -> Dict[str, Any]:\n        \"\"\"Run all tests required for Milestone 2: Inline Elements.\"\"\"\n        print(\"🧪 Running Milestone 2: Inline Elements Tests\")\n        \n        # TODO: Similar structure to milestone 1\n        # TODO: Focus on inline parser unit tests\n        # TODO: Test delimiter stack functionality\n        # TODO: Verify emphasis and link parsing\n        # TODO: Check escape sequence handling\n        \n        return {'milestone': 2, 'status': 'not_implemented'}\n    \n    def run_milestone_3_tests(self) -> Dict[str, Any]:\n        \"\"\"Run all tests required for Milestone 3: Lists.\"\"\"\n        print(\"🧪 Running Milestone 3: Lists Tests\")\n        \n        # TODO: List parser unit tests\n        # TODO: Indentation tracking verification\n        # TODO: Nested list structure validation\n        # TODO: Tight vs loose list detection\n        \n        return {'milestone': 3, 'status': 'not_implemented'}\n    \n    def run_milestone_4_tests(self) -> Dict[str, Any]:\n        \"\"\"Run all tests required for Milestone 4: HTML Generation.\"\"\"\n        print(\"🧪 Running Milestone 4: HTML Generation Tests\")\n        \n        # TODO: HTML generator unit tests\n        # TODO: End-to-end integration tests\n        # TODO: HTML validity verification\n        # TODO: Character escaping validation\n        # TODO: Performance benchmarking\n        \n        return {'milestone': 4, 'status': 'not_implemented'}\n    \n    def verify_milestone_completion(self, milestone: int) -> bool:\n        \"\"\"Verify that a specific milestone meets all completion criteria.\"\"\"\n        verification_methods = {\n            1: self._verify_milestone_1,\n            2: self._verify_milestone_2,\n            3: self._verify_milestone_3,\n            4: self._verify_milestone_4\n        }\n        \n        if milestone in verification_methods:\n            return verification_methods[milestone]()\n        else:\n            print(f\"❌ Unknown milestone: {milestone}\")\n            return False\n    \n    def _verify_milestone_1(self) -> bool:\n        \"\"\"Verify Milestone 1 completion criteria.\"\"\"\n        print(\"✅ Verifying Milestone 1 completion...\")\n        \n        # TODO: Check that all required block types are implemented\n        # TODO: Verify AST structure correctness\n        # TODO: Test state machine transitions\n        # TODO: Validate error handling for malformed blocks\n        \n        required_block_types = ['HEADING', 'PARAGRAPH', 'CODE_BLOCK', 'BLOCKQUOTE', 'HORIZONTAL_RULE']\n        \n        # TODO: For each block type:\n        # TODO:   - Create test input\n        # TODO:   - Parse through block parser\n        # TODO:   - Verify correct BlockNode type created\n        # TODO:   - Check content extraction accuracy\n        \n        return False  # TODO: Replace with actual verification logic\n    \n    def _verify_milestone_2(self) -> bool:\n        \"\"\"Verify Milestone 2 completion criteria.\"\"\"\n        # TODO: Test all inline formatting types\n        # TODO: Verify delimiter stack functionality\n        # TODO: Check emphasis precedence rules\n        # TODO: Test link and image parsing\n        return False\n    \n    def _verify_milestone_3(self) -> bool:\n        \"\"\"Verify Milestone 3 completion criteria.\"\"\"\n        # TODO: Test list parsing accuracy\n        # TODO: Verify nesting level calculations\n        # TODO: Check marker consistency enforcement\n        # TODO: Test lazy continuation handling\n        return False\n    \n    def _verify_milestone_4(self) -> bool:\n        \"\"\"Verify Milestone 4 completion criteria.\"\"\"\n        # TODO: Test complete pipeline functionality\n        # TODO: Verify HTML validity\n        # TODO: Check character escaping\n        # TODO: Test performance requirements\n        return False\n    \n    def run_comprehensive_test_suite(self) -> Dict[str, Any]:\n        \"\"\"Run all tests across all milestones.\"\"\"\n        print(\"🚀 Running Comprehensive Test Suite\")\n        \n        all_results = {\n            'timestamp': time.time(),\n            'milestones': {},\n            'overall_summary': {}\n        }\n        \n        # Run each milestone's tests\n        milestone_runners = [\n            self.run_milestone_1_tests,\n            self.run_milestone_2_tests,\n            self.run_milestone_3_tests,\n            self.run_milestone_4_tests\n        ]\n        \n        for i, runner in enumerate(milestone_runners, 1):\n            try:\n                results = runner()\n                all_results['milestones'][i] = results\n                print(f\"✅ Milestone {i}: {results.get('overall_status', 'unknown')}\")\n            except Exception as e:\n                print(f\"❌ Milestone {i} failed: {str(e)}\")\n                all_results['milestones'][i] = {\n                    'milestone': i,\n                    'overall_status': 'error',\n                    'error': str(e)\n                }\n        \n        # TODO: Calculate overall summary statistics\n        # TODO: Identify which milestones are complete\n        # TODO: Generate recommendations for next steps\n        \n        return all_results\n    \n    def generate_test_report(self, results: Dict[str, Any]) -> str:\n        \"\"\"Generate human-readable test report.\"\"\"\n        report_lines = [\n            \"# Markdown Renderer Test Report\",\n            f\"Generated: {time.ctime(results['timestamp'])}\",\n            \"\",\n            \"## Milestone Summary\",\n            \"\"\n        ]\n        \n        for milestone_num, milestone_results in results['milestones'].items():\n            status = milestone_results.get('overall_status', 'unknown')\n            description = milestone_results.get('description', f'Milestone {milestone_num}')\n            \n            status_emoji = {\n                'passed': '✅',\n                'failed': '❌',\n                'partial': '⚠️',\n                'not_implemented': '⏳',\n                'error': '🔥'\n            }.get(status, '❓')\n            \n            report_lines.extend([\n                f\"### {status_emoji} Milestone {milestone_num}: {description}\",\n                f\"Status: {status.title()}\",\n                \"\"\n            ])\n            \n            # TODO: Add detailed test category results\n            # TODO: Include specific failure information\n            # TODO: Add recommendations for fixing issues\n        \n        # TODO: Add overall recommendations section\n        # TODO: Include next steps guidance\n        # TODO: Add debugging tips for common failures\n        \n        return \"\\n\".join(report_lines)\n\ndef main():\n    \"\"\"Main entry point for milestone testing.\"\"\"\n    if len(sys.argv) < 2:\n        print(\"Usage: python run_milestone_tests.py <milestone_number|all>\")\n        print(\"Example: python run_milestone_tests.py 1\")\n        print(\"Example: python run_milestone_tests.py all\")\n        sys.exit(1)\n    \n    project_root = Path(__file__).parent.parent\n    runner = MilestoneTestRunner(project_root)\n    \n    target = sys.argv[1].lower()\n    \n    if target == 'all':\n        results = runner.run_comprehensive_test_suite()\n        report = runner.generate_test_report(results)\n        print(\"\\n\" + \"=\"*50)\n        print(report)\n    elif target.isdigit():\n        milestone_num = int(target)\n        if 1 <= milestone_num <= 4:\n            success = runner.verify_milestone_completion(milestone_num)\n            if success:\n                print(f\"🎉 Milestone {milestone_num} is complete!\")\n            else:\n                print(f\"❌ Milestone {milestone_num} needs more work.\")\n                sys\n\n```\n\n\n## Debugging Guide\n\n> **Milestone(s):** Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation\n\n### The Detective Work Mental Model\n\nThink of debugging a markdown parser like being a detective at a crime scene where the \"crime\" is incorrect HTML output. You have evidence (the wrong output), witnesses (intermediate parsing states), and forensic tools (debugging utilities). Just as a detective systematically examines evidence and follows leads, debugging text parsing requires systematic examination of each transformation stage to identify where the parsing pipeline diverged from expected behavior.\n\nThe key insight is that text parsing bugs often manifest far from their source. A missing paragraph tag might be caused by incorrect line splitting in preprocessing, a malformed list structure might stem from indentation calculation errors, and broken emphasis formatting could result from delimiter stack corruption. Effective debugging requires understanding these cause-and-effect relationships and knowing where to look for root causes.\n\n### Symptom-Based Debugging Table\n\nThe following comprehensive table maps common symptoms learners encounter to their likely root causes, specific diagnostic approaches, and targeted fixes. This systematic approach helps developers identify and resolve issues efficiently rather than randomly trying different solutions.\n\n| Symptom | Likely Root Cause | Diagnostic Steps | Specific Fix |\n|---------|------------------|------------------|-------------|\n| Headings render as plain paragraphs | ATX heading regex not matching or incorrect heading detection | 1. Print raw line content before heading detection 2. Test `ATX_HEADING_PATTERN` regex against failing line 3. Check if line has unexpected characters or encoding issues | Fix regex pattern to handle edge cases like trailing spaces, or add line content normalization before pattern matching |\n| Code blocks appear as regular paragraphs | Fenced code detection failing or state machine not transitioning | 1. Print current `BlockParserState` when processing code fence lines 2. Verify fence marker counting (minimum 3 backticks) 3. Check if closing fence detection is working | Ensure `FENCED_CODE_START` pattern matches opening fence, verify state transitions to `IN_FENCED_CODE`, fix closing fence detection logic |\n| Emphasis markers show as literal text | Delimiter stack not processing or flanking detection broken | 1. Print delimiter stack contents after each character 2. Check flanking detection results for failing delimiters 3. Verify `can_open_emphasis` and `can_close_emphasis` logic | Fix flanking detection algorithm, ensure delimiters are properly added to stack, verify opener-closer matching logic |\n| Nested emphasis produces malformed HTML | Incorrect emphasis delimiter precedence or double processing | 1. Trace delimiter matching decisions step by step 2. Check if same text being processed multiple times 3. Verify delimiter precedence rules implementation | Implement proper emphasis precedence (** before *, length-based matching), ensure single-pass processing of inline content |\n| Lists render as separate paragraphs | List marker detection failing or indentation calculation wrong | 1. Print detected marker info for each line 2. Verify indentation level calculations 3. Check `ListMarkerInfo` extraction results | Fix marker detection regex patterns, correct indentation calculation (handle tabs vs spaces), ensure marker width calculation includes trailing space |\n| List items lose indentation structure | Context stack management broken or continuation logic wrong | 1. Print `ListContextStack` state changes 2. Trace context creation and finalization 3. Check continuation line indentation requirements | Fix context stack push/pop logic, correct continuation indentation requirements, ensure proper context nesting |\n| Blockquotes miss nested levels | Blockquote prefix detection or nesting logic incorrect | 1. Count `>` characters manually vs detection results 2. Check recursive blockquote parsing 3. Verify nested content processing | Fix blockquote prefix counting, ensure recursive parsing for nested quotes, handle mixed content properly |\n| Links become literal text | Link syntax regex not matching or URL extraction failing | 1. Test link patterns against failing input 2. Check bracket-parenthesis pairing 3. Verify URL extraction logic | Fix link detection regex, ensure proper bracket matching, handle edge cases like nested brackets and special characters |\n| HTML contains unescaped characters | Character escaping missing or applied at wrong stage | 1. Check when `escape_html` is called in pipeline 2. Verify all content paths include escaping 3. Look for double-escaping issues | Apply escaping consistently before HTML generation, avoid double-escaping already processed content |\n| HTML tags are malformed or unclosed | Tag generation logic broken or self-closing tag confusion | 1. Check `generate_tag` output for specific elements 2. Verify self-closing vs container tag logic 3. Check tag nesting in output | Fix tag generation for self-closing elements, ensure proper opening/closing tag pairing, correct void element handling |\n| Output HTML lacks proper indentation | Pretty printing disabled or indentation logic broken | 1. Verify `pretty_print` flag is enabled 2. Check indentation level tracking 3. Test with simple nested structure | Enable pretty printing in renderer, fix indentation calculation logic, ensure consistent indentation increment |\n| Parser crashes on empty input | Null/empty string handling missing in pipeline stages | 1. Test each component with empty input 2. Check bounds checking in line processing 3. Verify null checks in parsers | Add empty input validation at pipeline entry, ensure all components handle empty/null gracefully |\n| Infinite loops during parsing | State machine stuck or incorrect termination conditions | 1. Add loop counters and limits 2. Print state transitions 3. Check termination conditions in parsing loops | Fix state transition logic, add loop guards with maximum iteration limits, ensure all parsing loops have proper exit conditions |\n| Memory usage grows unbounded | AST nodes not properly linked or circular references created | 1. Check parent-child relationships in AST 2. Look for reference cycles 3. Monitor node creation vs finalization | Fix parent pointer management, break circular references, ensure nodes are properly finalized and released |\n| Parsing becomes extremely slow on large documents | Inefficient regex patterns or quadratic algorithm behavior | 1. Profile parsing with large inputs 2. Check regex backtracking 3. Identify nested loop structures | Optimize regex patterns to avoid backtracking, replace quadratic algorithms with linear alternatives, add early termination optimizations |\n| Inconsistent output across multiple runs | Race conditions in parser state or shared mutable state | 1. Check for shared state between parser instances 2. Look for static/global variables 3. Test with concurrent parsing | Eliminate shared mutable state, ensure each parser instance is independent, make parsing functions pure |\n\n> **Critical Insight**: Most parsing bugs are actually data structure bugs in disguise. When emphasis doesn't work, it's usually because the delimiter stack isn't managed correctly. When lists break, it's because the context stack or indentation tracking has bugs. Always examine the underlying data structures first.\n\n### Advanced Diagnostic Techniques\n\nBeyond basic symptom diagnosis, effective markdown parser debugging requires specialized techniques tailored to text processing and document transformation challenges.\n\n#### AST Structure Inspection\n\nThe most powerful debugging tool for markdown parsing is systematic AST inspection. The `debug_print_ast` function should be your first resort when output doesn't match expectations. This function performs depth-first traversal of the parsed tree and displays the complete structure with proper indentation.\n\nWhen using AST inspection, look for these common structural problems: missing parent-child relationships indicating incomplete tree construction, incorrect node types suggesting classification errors during parsing, unexpected nesting levels pointing to state machine bugs, and missing or extra child nodes revealing content processing issues.\n\nThe debugging workflow involves first printing the AST after block parsing to verify block-level structure is correct, then printing again after inline parsing to check inline element nesting, and finally examining the tree structure before HTML generation to ensure all content is properly represented.\n\n#### Pipeline Stage Isolation\n\nEffective debugging requires isolating which stage of the parsing pipeline introduces errors. This systematic approach involves testing each component independently with controlled inputs.\n\nStart by feeding known-good input to the preprocessor and verifying line splitting, normalization, and metadata extraction. Then pass preprocessor output to the block parser and examine the resulting block-level AST structure. Next, take known-good block nodes and test inline parsing in isolation. Finally, provide known-good AST structures to the HTML generator and verify output correctness.\n\nThis isolation technique quickly narrows the problem scope and prevents you from debugging the wrong component. Most developers waste time examining the HTML generator when the real bug is in block parsing or preprocessor normalization.\n\n#### State Machine Debugging\n\nBlock and list parsing both use state machines that can be challenging to debug when they malfunction. The key is systematic state transition logging combined with input correlation.\n\nFor block parsing state machine issues, log every state transition with the triggering input line, current block type, and any relevant context. Create a state transition trace that shows the complete sequence of states for failing input. Look for incorrect transitions (moving to wrong state), missing transitions (staying in state when should change), or impossible states (reaching states that shouldn't be reachable with given input).\n\nList parsing state machine debugging requires additional attention to the context stack. Log context creation, modification, and destruction events. Track indentation calculations and marker compatibility checks. The most common bugs involve incorrect context nesting or failure to properly close contexts when list structures end.\n\n#### Regular Expression Testing and Optimization\n\nMany parsing bugs stem from incorrect regular expressions that work for simple cases but fail on edge cases or complex input. Systematic regex debugging involves creating comprehensive test cases and analyzing pattern behavior.\n\nTest each regex pattern in isolation with boundary cases: empty strings, maximum length inputs, inputs with special characters, inputs with mixed whitespace types, and inputs with unusual but valid markdown syntax. Use regex debugging tools to visualize pattern matching and identify backtracking issues that cause performance problems.\n\nCommon regex pitfalls include greedy quantifiers causing over-matching, insufficient escaping of special characters, patterns that don't account for all valid whitespace types, and patterns that fail on Unicode content or non-ASCII characters.\n\n### Domain-Specific Debugging Techniques\n\nText parsing and document transformation introduce unique debugging challenges that require specialized approaches beyond general software debugging techniques.\n\n#### Whitespace and Character Encoding Issues\n\nInvisible characters are a frequent source of parsing bugs that are extremely difficult to diagnose without proper techniques. Develop the habit of inspecting raw character codes rather than relying on visual inspection of text content.\n\nCreate debugging utilities that display whitespace visually by replacing spaces with `·`, tabs with `→`, and line endings with `↵`. This makes invisible formatting immediately apparent. Use hexadecimal dumps to inspect raw byte sequences when dealing with encoding issues or unusual whitespace characters.\n\nPay special attention to mixed line endings (mixing `\\n` and `\\r\\n` in the same document), trailing whitespace that affects block boundary detection, tabs versus spaces in indentation calculations, and Unicode whitespace characters that don't match standard space patterns.\n\nThe `normalize_edge_case_whitespace` function should be instrumented with detailed logging showing before and after content along with explanations of what normalization was applied and why.\n\n#### Context Dependency Debugging\n\nMarkdown parsing is highly context-dependent, meaning the same character sequence can have different meanings depending on surrounding content. Debugging context-dependent parsing requires understanding these dependencies and systematically testing context variations.\n\nFor emphasis parsing, the same asterisk character can be a literal character, an opening delimiter, or a closing delimiter depending on flanking context. Debug emphasis issues by creating minimal test cases that isolate specific flanking scenarios. Test emphasis with various surrounding character types: punctuation, whitespace, alphanumeric, and Unicode characters.\n\nList parsing context dependencies involve indentation relationships between lines, marker type consistency within lists, and lazy continuation rules that allow certain lines to be included in list items without full indentation. Debug list issues by creating test cases that systematically vary indentation levels and marker combinations.\n\nBlockquote context dependencies involve prefix detection and nested blockquote handling. Debug blockquote issues by testing various combinations of `>` characters, spaces, and content types.\n\n#### Delimiter Balance and Nesting Debugging\n\nInline formatting relies on proper delimiter balancing that can become complex with nested emphasis, code spans that prevent emphasis processing, and multiple competing delimiter types in the same text span.\n\nUse delimiter stack visualization to understand how delimiters are being processed. Create debugging output that shows the stack state after each character is processed, including delimiter position, type, and open/close capabilities. This visualization quickly reveals delimiter matching errors and precedence issues.\n\nTest delimiter edge cases systematically: unmatched openers (emphasis that never closes), unmatched closers (closing emphasis without opener), overlapping delimiters of different types, delimiters inside code spans that should be treated as literal text, and complex nesting scenarios with multiple emphasis levels.\n\nThe `detect_emphasis_precedence_conflict` function should be used extensively during debugging to identify potential conflicts before they cause rendering issues.\n\n#### Tree Structure and Parent-Child Relationship Debugging\n\nAST construction bugs often manifest as incorrect parent-child relationships, missing links between nodes, or malformed tree structures that cause HTML generation to fail or produce incorrect nesting.\n\nImplement comprehensive tree validation that checks for common structural problems: nodes with missing parent pointers, parents that don't include children in their child lists, circular references that could cause infinite loops during traversal, and orphaned nodes that exist in memory but aren't reachable from the document root.\n\nUse tree visualization tools that display the complete AST structure with clear parent-child relationships. This visualization should include node types, content summaries, and relationship indicators that make structural problems immediately apparent.\n\nThe `validate_pipeline_state` function should be called between each major parsing phase to catch structural problems early before they propagate to later stages.\n\n#### Performance Debugging for Large Documents\n\nMarkdown parsers can exhibit performance problems that only appear with large documents or complex nesting structures. These performance issues require specialized debugging approaches focused on algorithmic complexity and resource usage.\n\nProfile parsing performance with documents of varying sizes to identify quadratic or exponential behavior. Common performance pitfalls include nested loops in list processing, backtracking regex patterns, repeated AST traversals, and inefficient string manipulation that creates many temporary objects.\n\nUse algorithmic analysis to verify that parsing algorithms are linear in input size. Implement monitoring for excessive memory allocation, particularly in delimiter processing and AST construction. Monitor parsing time per input size to identify performance regressions.\n\nCreate performance test cases with pathological inputs that stress-test worst-case behavior: deeply nested lists, very long lines with many delimiters, documents with thousands of emphasis markers, and complex mixed formatting that exercises all parser components simultaneously.\n\n### Implementation Guidance\n\nThe debugging infrastructure for a markdown parser requires specialized tools and techniques tailored to text processing and document transformation challenges.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|--------------|----------------|\n| AST Debugging | Print statements with manual formatting | Rich tree visualization library (anytree for Python) |\n| Regex Testing | Online regex testers and manual verification | Integrated regex profiler with backtrack analysis |\n| State Logging | File-based logging with manual analysis | Structured logging with real-time analysis dashboard |\n| Performance Profiling | Manual timing with print statements | Professional profiler (cProfile for Python, pprof for Go) |\n| Memory Analysis | Basic memory monitoring | Memory profiler with object lifecycle tracking |\n\n#### Debugging Infrastructure Setup\n\nThe debugging infrastructure should be built into the parser from the beginning rather than added after problems appear. This proactive approach makes debugging much more efficient when issues inevitably arise.\n\n```\nmarkdown_renderer/\n  debug/\n    __init__.py\n    ast_inspector.py        ← AST visualization and validation\n    pipeline_tracer.py      ← Stage-by-stage execution tracking\n    regex_tester.py         ← Pattern testing and validation\n    performance_monitor.py  ← Timing and memory analysis\n    test_case_generator.py  ← Systematic edge case creation\n  tests/\n    debug/\n      test_debugging_tools.py  ← Verify debugging infrastructure\n      edge_cases/              ← Systematic edge case test files\n        malformed_emphasis.md\n        broken_list_nesting.md\n        invalid_link_syntax.md\n  src/\n    parser/\n      block_parser.py      ← Include debug hooks in implementation\n      inline_parser.py     ← Include debug hooks in implementation\n```\n\n#### AST Inspector Implementation\n\n```python\n\"\"\"\nAST debugging and validation utilities for markdown parser development.\nProvides comprehensive tree inspection, validation, and visualization tools.\n\"\"\"\n\nimport sys\nfrom typing import Dict, List, Optional, Set, Tuple\nfrom dataclasses import dataclass\nfrom enum import Enum\n\n@dataclass\nclass ValidationError:\n    \"\"\"Represents an AST structural validation error.\"\"\"\n    node_id: str\n    error_type: str\n    description: str\n    severity: str\n    suggested_fix: str\n\nclass ASTValidator:\n    \"\"\"Validates AST structure for common construction errors.\"\"\"\n    \n    def __init__(self):\n        self.errors = []\n        self.visited_nodes = set()\n        self.node_ids = {}\n    \n    def validate_tree(self, root: 'ASTNode') -> List[ValidationError]:\n        \"\"\"\n        Perform comprehensive AST validation checking for structural problems.\n        Returns list of validation errors found during inspection.\n        \"\"\"\n        # TODO 1: Clear validation state for new validation run\n        # TODO 2: Assign unique IDs to all nodes for error reporting\n        # TODO 3: Check for circular references using depth-first traversal\n        # TODO 4: Validate parent-child relationship consistency\n        # TODO 5: Check for orphaned nodes not reachable from root\n        # TODO 6: Verify node type constraints and content validation\n        # TODO 7: Check for missing required attributes in block/inline nodes\n        # TODO 8: Validate proper nesting according to CommonMark rules\n        pass\n    \n    def check_parent_child_consistency(self, node: 'ASTNode') -> None:\n        \"\"\"Verify bidirectional parent-child relationships are correct.\"\"\"\n        # TODO 1: For each child, verify child.parent points to this node\n        # TODO 2: Verify all children in child list are unique\n        # TODO 3: Check that parent's child list includes this node\n        # TODO 4: Recursively validate all descendant nodes\n        pass\n\ndef debug_print_ast(node: 'ASTNode', indent: int = 0) -> None:\n    \"\"\"\n    Print comprehensive AST structure with detailed node information.\n    Shows node types, content, attributes, and relationships clearly.\n    \"\"\"\n    # TODO 1: Print node basic information (type, line number, content summary)\n    # TODO 2: Print node-specific attributes (block_type, inline_type, etc.)\n    # TODO 3: Print relationship information (parent type, child count)\n    # TODO 4: Print content preview (first 50 chars of text content)\n    # TODO 5: Recursively print all children with increased indentation\n    # TODO 6: Add visual indicators for tree structure (├── └──)\n    pass\n\ndef find_parsing_divergence(expected_ast: 'ASTNode', actual_ast: 'ASTNode') -> List[str]:\n    \"\"\"\n    Compare expected vs actual AST structures and identify differences.\n    Useful for test failure analysis and regression debugging.\n    \"\"\"\n    # TODO 1: Compare node types at each level of tree structure\n    # TODO 2: Compare content and attributes for matching nodes\n    # TODO 3: Identify missing, extra, or differently typed children\n    # TODO 4: Generate detailed difference report with specific locations\n    # TODO 5: Suggest likely causes for each identified difference\n    pass\n```\n\n#### Pipeline State Tracer\n\n```python\n\"\"\"\nPipeline execution tracing for step-by-step parsing analysis.\nTracks data flow through all parsing stages with detailed state capture.\n\"\"\"\n\nfrom typing import Any, Dict, List, Optional\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\n\n@dataclass\nclass PipelineEvent:\n    \"\"\"Records a single event in the parsing pipeline execution.\"\"\"\n    timestamp: datetime\n    stage: str\n    event_type: str\n    input_summary: str\n    output_summary: str\n    state_changes: Dict[str, Any]\n    performance_metrics: Dict[str, float]\n    debug_context: Dict[str, Any] = field(default_factory=dict)\n\nclass PipelineTracer:\n    \"\"\"Traces complete parsing pipeline execution for debugging analysis.\"\"\"\n    \n    def __init__(self, enable_detailed_tracing: bool = True):\n        self.events = []\n        self.detailed_tracing = enable_detailed_tracing\n        self.stage_timers = {}\n        self.current_context = {}\n    \n    def trace_stage_entry(self, stage_name: str, input_data: Any, initial_state: Dict[str, Any]) -> None:\n        \"\"\"Record entry into a parsing stage with input and initial state.\"\"\"\n        # TODO 1: Record stage entry timestamp and input characteristics\n        # TODO 2: Capture initial state snapshot for comparison\n        # TODO 3: Start performance timer for this stage\n        # TODO 4: Create stage context for subsequent event tracking\n        pass\n    \n    def trace_state_change(self, stage_name: str, change_description: str, \n                          old_state: Any, new_state: Any, triggering_input: str) -> None:\n        \"\"\"Record significant state changes during parsing.\"\"\"\n        # TODO 1: Compare old and new state to identify specific changes\n        # TODO 2: Record triggering input that caused the state change\n        # TODO 3: Calculate and record timing since last state change\n        # TODO 4: Add contextual information about why change occurred\n        pass\n    \n    def generate_execution_report(self) -> str:\n        \"\"\"Generate comprehensive report of pipeline execution for analysis.\"\"\"\n        # TODO 1: Summarize overall pipeline execution timing and stages\n        # TODO 2: Identify performance bottlenecks and slow operations\n        # TODO 3: Highlight unusual state transitions or unexpected events\n        # TODO 4: Provide recommendations for performance or correctness improvements\n        pass\n```\n\n#### Regex Pattern Tester\n\n```python\n\"\"\"\nRegular expression testing and validation utilities for markdown parsing patterns.\nProvides comprehensive pattern testing with edge case generation and performance analysis.\n\"\"\"\n\nimport re\nfrom typing import List, Tuple, Dict, Optional\nfrom dataclasses import dataclass\n\n@dataclass\nclass RegexTestCase:\n    \"\"\"Test case for regex pattern validation.\"\"\"\n    name: str\n    input_text: str\n    should_match: bool\n    expected_groups: Optional[List[str]] = None\n    expected_span: Optional[Tuple[int, int]] = None\n    edge_case_category: str = \"normal\"\n\nclass MarkdownRegexTester:\n    \"\"\"Comprehensive testing framework for markdown parsing regex patterns.\"\"\"\n    \n    def __init__(self):\n        self.test_cases = []\n        self.pattern_performance = {}\n    \n    def test_pattern_comprehensive(self, pattern: re.Pattern, pattern_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Test regex pattern against comprehensive set of edge cases.\n        Returns detailed analysis of pattern behavior and potential issues.\n        \"\"\"\n        # TODO 1: Generate systematic edge case test inputs\n        # TODO 2: Test pattern against each case and record results\n        # TODO 3: Identify false positives and false negatives\n        # TODO 4: Analyze pattern performance with various input sizes\n        # TODO 5: Check for catastrophic backtracking scenarios\n        # TODO 6: Generate detailed test report with recommendations\n        pass\n    \n    def create_emphasis_edge_cases(self) -> List[RegexTestCase]:\n        \"\"\"Create comprehensive edge cases for emphasis delimiter testing.\"\"\"\n        # TODO 1: Create intraword underscore test cases\n        # TODO 2: Create nested emphasis combinations\n        # TODO 3: Create delimiter precedence conflict cases\n        # TODO 4: Create flanking detection boundary cases\n        # TODO 5: Create Unicode and special character cases\n        pass\n    \n    def create_list_marker_edge_cases(self) -> List[RegexTestCase]:\n        \"\"\"Create comprehensive edge cases for list marker detection.\"\"\"\n        # TODO 1: Create various whitespace combinations after markers\n        # TODO 2: Create invalid marker combinations that should not match\n        # TODO 3: Create nested indentation and continuation scenarios\n        # TODO 4: Create mixed ordered/unordered marker test cases\n        pass\n```\n\n#### Performance and Memory Profiler\n\n```python\n\"\"\"\nPerformance monitoring and memory analysis for markdown parser optimization.\nTracks parsing performance across document sizes and complexity levels.\n\"\"\"\n\nimport time\nimport tracemalloc\nfrom typing import Dict, List, Any, Optional, Callable\nfrom dataclasses import dataclass, field\nfrom collections import defaultdict\n\n@dataclass\nclass PerformanceMetrics:\n    \"\"\"Performance measurements for parsing operations.\"\"\"\n    operation_name: str\n    execution_time: float\n    memory_peak: int\n    memory_current: int\n    input_size: int\n    complexity_factors: Dict[str, int] = field(default_factory=dict)\n\nclass MarkdownParserProfiler:\n    \"\"\"Comprehensive performance profiling for markdown parser components.\"\"\"\n    \n    def __init__(self, enable_memory_tracking: bool = True):\n        self.metrics = []\n        self.memory_tracking = enable_memory_tracking\n        self.operation_counters = defaultdict(int)\n        self.timing_stack = []\n    \n    def profile_parsing_operation(self, operation_name: str, operation_func: Callable, \n                                input_data: Any, complexity_factors: Dict[str, int] = None) -> Any:\n        \"\"\"\n        Profile a parsing operation with comprehensive performance measurement.\n        Returns operation result along with detailed performance metrics.\n        \"\"\"\n        # TODO 1: Start memory tracking if enabled\n        # TODO 2: Record operation start time and input characteristics\n        # TODO 3: Execute operation while monitoring resource usage\n        # TODO 4: Record final memory usage and execution time\n        # TODO 5: Calculate performance characteristics and complexity metrics\n        # TODO 6: Store metrics for later analysis and reporting\n        pass\n    \n    def generate_performance_report(self, min_operation_time: float = 0.001) -> str:\n        \"\"\"Generate comprehensive performance analysis report.\"\"\"\n        # TODO 1: Analyze performance trends across input sizes\n        # TODO 2: Identify operations with quadratic or worse complexity\n        # TODO 3: Highlight memory usage patterns and potential leaks\n        # TODO 4: Compare performance across different input characteristics\n        # TODO 5: Provide optimization recommendations based on profiling data\n        pass\n    \n    def create_performance_test_suite(self) -> List[Tuple[str, str, Dict[str, int]]]:\n        \"\"\"Create systematic performance test cases with varying complexity.\"\"\"\n        # TODO 1: Create documents with varying sizes (small to very large)\n        # TODO 2: Create documents with different nesting complexity levels\n        # TODO 3: Create documents with varying density of formatting elements\n        # TODO 4: Create pathological cases that stress-test worst-case behavior\n        pass\n```\n\n#### Milestone Debugging Checkpoints\n\nAfter completing each milestone, verify parsing correctness using these systematic checkpoints:\n\n**Milestone 1 (Block Elements) Debugging Checkpoint:**\n1. Run `python -m debug.ast_inspector tests/milestone1_blocks.md` and verify AST structure matches expected block hierarchy\n2. Test edge cases: headings with trailing spaces, code blocks with unusual fencing, blockquotes with inconsistent prefixes\n3. Check state machine transitions using `PipelineTracer` - verify clean transitions between block types\n4. Expected behavior: All block-level structures parse correctly, no content is lost or misclassified\n\n**Milestone 2 (Inline Elements) Debugging Checkpoint:**\n1. Run delimiter stack visualization on complex emphasis examples to verify proper matching\n2. Test flanking detection with edge cases using `MarkdownRegexTester`\n3. Verify inline parsing doesn't interfere with block structure using AST comparison\n4. Expected behavior: Emphasis, links, and inline code render correctly without breaking block structure\n\n**Milestone 3 (Lists) Debugging Checkpoint:**\n1. Use `debug_print_ast` to verify nested list structures are properly represented\n2. Test indentation edge cases with mixed tabs/spaces and various nesting levels\n3. Verify context stack management using pipeline tracer during complex list parsing\n4. Expected behavior: All list nesting levels are correct, no items are lost or misplaced\n\n**Milestone 4 (HTML Generation) Debugging Checkpoint:**\n1. Validate generated HTML using W3C validator or similar tool\n2. Check HTML entity escaping completeness using systematic character testing\n3. Verify pretty printing produces properly indented, human-readable output\n4. Expected behavior: Valid HTML5 output with proper escaping and formatting\n\n\n## Future Extensions\n\n> **Milestone(s):** Builds upon all milestones - Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation\n\n### The Evolution Framework Mental Model\n\nThink of extending the markdown renderer like upgrading a modular kitchen. The core appliances (block parser, inline parser, HTML generator) are already in place and working perfectly. Now you want to add specialty equipment - perhaps a pasta machine for tables, a bread maker for math expressions, or modular attachments that let third-party manufacturers create custom tools. The key insight is that these extensions should plug into the existing infrastructure without requiring you to rewire the entire kitchen. A well-designed extension system feels like adding new capabilities that were always meant to be there, rather than awkward bolt-ons that compromise the original design.\n\nThe architectural challenge with markdown extensions lies in maintaining the elegant simplicity of the core parsing pipeline while accommodating the complexity that advanced features inevitably introduce. Each extension potentially touches multiple components - new syntax requires lexer changes, new block types need parser modifications, new output formats demand renderer updates. The goal is to create extension points that feel natural and maintain the clean separation of concerns established in the base system.\n\n### CommonMark Extensions\n\nThe CommonMark specification intentionally focuses on a stable, well-defined core that captures the essence of markdown while leaving room for extensions. These extensions represent commonly requested features that build logically on the existing parsing infrastructure. Understanding how to add these extensions reveals the flexibility and robustness of the two-phase parsing architecture.\n\n#### Table Extension Architecture\n\nTables represent one of the most requested markdown extensions, transforming the simple grid-like syntax into structured HTML table elements. The table extension demonstrates how complex block-level structures can be parsed using the existing block parser infrastructure with minimal modifications to the core architecture.\n\nThe table parsing process follows a recognition pattern similar to existing block elements. The block parser identifies potential table structures by detecting pipe characters (`|`) that suggest columnar organization. However, unlike simple blocks like paragraphs or headings, tables require sophisticated parsing of internal structure to extract headers, alignment specifications, and cell content.\n\nConsider how a table integrates into the existing parsing pipeline. During block parsing, the system encounters lines that contain pipe characters in positions that suggest table structure. The table parser examines consecutive lines to determine if they form a valid table structure - a header row, a delimiter row specifying column alignments, and one or more data rows. This multi-line analysis fits naturally into the block parser's lookahead capabilities.\n\n**Table Structure Recognition Algorithm:**\n\n1. **Initial Detection**: During block parsing, when encountering a line containing pipe characters, examine if this could be a table header row\n2. **Delimiter Row Validation**: Look ahead to the next line to check for a valid delimiter row with alignment specifications (`:---`, `:---:`, `---:`)\n3. **Structure Confirmation**: Verify that header and delimiter rows have compatible column counts and valid separator patterns\n4. **Row Collection**: Continue consuming lines that match the established table structure until encountering a line that breaks the pattern\n5. **Cell Content Extraction**: Parse individual cell content, trimming whitespace and preparing for inline element processing\n6. **Alignment Processing**: Extract column alignment information from the delimiter row and store as table metadata\n7. **AST Node Creation**: Create a table `BlockNode` with child nodes representing rows and cells, preserving alignment specifications\n\nThe table extension introduces new node types that integrate seamlessly with the existing AST structure:\n\n| Node Type | Parent Node | Child Nodes | Special Attributes |\n|-----------|-------------|-------------|-------------------|\n| `TABLE` | Document or container block | `TABLE_HEADER`, `TABLE_BODY` | column_count, alignment_specs |\n| `TABLE_HEADER` | `TABLE` | `TABLE_ROW` | none |\n| `TABLE_BODY` | `TABLE` | `TABLE_ROW` | none |\n| `TABLE_ROW` | `TABLE_HEADER` or `TABLE_BODY` | `TABLE_CELL` | row_type |\n| `TABLE_CELL` | `TABLE_ROW` | Inline elements | alignment, is_header |\n\nThe inline parsing phase processes table cell content normally, applying emphasis, links, and other inline formatting within cell boundaries. This demonstrates the power of the two-phase parsing architecture - table structure is resolved during block parsing, while cell formatting is handled during inline parsing without requiring specialized logic.\n\n> **Design Insight**: Tables showcase how complex extensions can leverage the existing parsing infrastructure. The block parser handles structure recognition and AST construction, while the inline parser processes cell content using existing mechanisms. No modifications to the core inline parsing logic are required.\n\n#### Math Expression Extension\n\nMathematical expressions represent a different category of extension that introduces domain-specific syntax requiring specialized rendering. Math extensions typically support both inline math (delimited by single dollar signs) and display math (delimited by double dollar signs or fenced blocks). This extension demonstrates how to handle content that requires pass-through processing rather than standard markdown parsing.\n\nThe math extension introduces the concept of **verbatim content blocks** - regions where normal markdown parsing is suspended in favor of preserving exact content for specialized processors. This is similar to how code blocks preserve content literally, but math blocks may require additional processing by mathematical typesetting systems.\n\n**Math Block Recognition Process:**\n\n1. **Inline Math Detection**: During inline parsing, detect single dollar sign delimiters that enclose mathematical expressions\n2. **Display Math Block Detection**: During block parsing, detect double dollar signs or fenced math blocks (````math` or `$$`)\n3. **Content Preservation**: Extract math content without applying normal markdown parsing rules - preserve all characters literally\n4. **Metadata Extraction**: Identify the math notation type (LaTeX, MathML, etc.) from fences or context\n5. **AST Integration**: Create specialized math nodes that carry the unparsed mathematical content and notation metadata\n6. **Renderer Integration**: Pass math content to specialized renderers (MathJax, KaTeX) while handling the HTML integration\n\nMath extensions typically require coordination with client-side rendering libraries or server-side mathematical typesetting systems. The markdown renderer's responsibility is to preserve the mathematical content accurately and provide the necessary HTML structure for math rendering libraries to process.\n\n| Extension Feature | Block Level | Inline Level | Processing Phase | Special Requirements |\n|-------------------|-------------|--------------|------------------|-------------------|\n| Table Structure | Yes | Cell content only | Block then inline | Column alignment, row grouping |\n| Math Expressions | Display math | Inline math | Content preservation | External renderer integration |\n| Footnotes | Reference definitions | Reference markers | Cross-document linking | Link resolution, numbering |\n| Task Lists | Special list items | Checkbox indicators | List parsing extension | Interactive element generation |\n| Definition Lists | Term/definition pairs | Term highlighting | Block parsing extension | Semantic HTML generation |\n\n#### Task List Extension\n\nTask lists extend the existing list parsing infrastructure to support interactive checkbox elements. This extension demonstrates how existing parsing components can be enhanced without disrupting their core functionality. Task lists use a special syntax within list items (`- [ ]` for unchecked, `- [x]` for checked) that the list parser can recognize and process.\n\nThe task list extension modifies list item recognition to detect checkbox patterns at the beginning of list item content. When such patterns are found, the list parser extracts the checkbox state and marks the list item with task list attributes. During HTML generation, these attributes trigger the creation of interactive checkbox input elements.\n\n> **Design Principle**: Extensions should enhance existing functionality rather than replace it. Task lists build on the standard list parsing infrastructure, adding recognition patterns and output modifications while preserving all existing list behaviors.\n\n#### Architecture Decision: Extension Integration Strategy\n\n> **Decision: Compositional Extension Architecture**\n> - **Context**: Extensions need to add functionality without modifying core parsing logic or breaking backward compatibility\n> - **Options Considered**: \n>   1. **Inheritance-based extensions**: Subclass core parsers and override methods\n>   2. **Plugin system**: Load extensions dynamically with registration hooks\n>   3. **Compositional extensions**: Extend parsers through composition and configuration\n> - **Decision**: Implement compositional extensions with registration-based integration\n> - **Rationale**: Composition preserves the stability of core parsing logic while allowing extensions to add new parsing rules and output formats. Registration-based integration provides clear extension points without requiring dynamic loading complexity\n> - **Consequences**: Extensions integrate cleanly with minimal core modifications, but advanced extensions may require multiple registration points across different parsing phases\n\n### Plugin and Extension Architecture\n\nThe plugin architecture provides a systematic framework for extending the markdown renderer beyond the built-in CommonMark extensions. This architecture must balance flexibility with simplicity, allowing powerful customizations without compromising the performance or reliability of the core parsing pipeline.\n\n#### The Extension Point Mental Model\n\nThink of extension points like electrical outlets in a building. The building's wiring (core parsing pipeline) provides standardized connection points where different appliances (extensions) can plug in safely. Each outlet type (extension point) provides specific electrical characteristics (data formats, calling conventions, lifecycle management) that appliances must respect. Well-designed extension points mean that new appliances can be added without rewiring the building, and multiple appliances can coexist without interference.\n\nThe markdown renderer provides several natural extension points corresponding to the major phases of document processing. Each extension point offers different capabilities and operates on different data representations, allowing extensions to target the most appropriate level of abstraction for their functionality.\n\n#### Extension Point Architecture\n\nThe plugin system defines multiple extension points that correspond to different phases of the parsing pipeline. Each extension point operates on specific data structures and provides well-defined hooks for custom functionality.\n\n| Extension Point | Input Data | Output Data | Timing | Use Cases |\n|-----------------|------------|-------------|--------|-----------|\n| Preprocessor Plugins | Raw markdown text | Modified text | Before any parsing | Text normalization, macro expansion |\n| Block Parser Plugins | `LineInfo` sequences | Additional `BlockNode` types | During block parsing | Custom block syntax |\n| Inline Parser Plugins | Text spans within blocks | Additional `InlineNode` types | During inline parsing | Custom inline formatting |\n| Renderer Plugins | `ASTNode` instances | HTML fragments | During HTML generation | Custom output formats |\n| Post-processor Plugins | Complete HTML | Modified HTML | After rendering | Document-wide transformations |\n\nThe `PluginManager` coordinates plugin registration and execution, ensuring that plugins are invoked at appropriate points in the parsing pipeline. The manager maintains plugin registries for each extension point and provides the interface for plugins to declare their capabilities and requirements.\n\n#### Plugin Interface Design\n\nEach plugin type implements a specific interface that defines its interaction with the parsing pipeline. These interfaces are designed to be minimal yet powerful, allowing plugins to integrate seamlessly while maintaining clear separation of concerns.\n\n**Renderer Plugin Interface:**\n\n| Method | Parameters | Returns | Purpose |\n|--------|------------|---------|---------|\n| `get_supported_types()` | None | `List[NodeType]` | Declare which AST node types this plugin handles |\n| `render_node(node, context)` | `ASTNode`, `RenderContext` | `str` | Convert AST node to output format |\n| `get_priority()` | None | `int` | Determine plugin precedence for overlapping capabilities |\n| `initialize(config)` | `Dict[str, Any]` | `bool` | Perform plugin initialization with configuration |\n| `finalize()` | None | `None` | Clean up plugin resources |\n\nThe `RenderContext` provides plugins with access to the rendering environment, including the parent renderer, configuration options, and utility functions for common tasks like HTML escaping and indentation management.\n\n**Block Parser Plugin Interface:**\n\n| Method | Parameters | Returns | Purpose |\n|--------|------------|---------|---------|\n| `can_handle_block(line)` | `LineInfo` | `bool` | Determine if plugin can parse a block starting with this line |\n| `parse_block(lines, start_index)` | `List[LineInfo]`, `int` | `Tuple[BlockNode, int]` | Parse block and return consumed line count |\n| `get_block_precedence()` | None | `int` | Priority for block recognition conflicts |\n\n#### Plugin Configuration and Lifecycle\n\nThe plugin system supports both built-in extensions that ship with the renderer and external plugins loaded dynamically. Plugin configuration allows users to enable, disable, and configure individual plugins without modifying core code.\n\n**Plugin Configuration Structure:**\n\n```\nPlugin Configuration:\n  - plugin_name: str (unique identifier)\n  - enabled: bool (activation status)\n  - priority: int (execution order)\n  - config: Dict[str, Any] (plugin-specific settings)\n  - dependencies: List[str] (required plugins)\n  - conflicts: List[str] (incompatible plugins)\n```\n\nThe `PluginManager` handles plugin lifecycle management, ensuring that plugins are loaded in dependency order, initialized with appropriate configuration, and cleaned up properly when the renderer shuts down.\n\n**Plugin Lifecycle States:**\n\n| State | Description | Allowed Transitions | Cleanup Required |\n|-------|-------------|-------------------|-----------------|\n| `UNLOADED` | Plugin not yet loaded | → `LOADING` | No |\n| `LOADING` | Plugin being initialized | → `LOADED`, `ERROR` | Partial |\n| `LOADED` | Plugin ready for use | → `ACTIVE`, `UNLOADING` | No |\n| `ACTIVE` | Plugin currently processing | → `LOADED` | No |\n| `ERROR` | Plugin failed to load/initialize | → `UNLOADING` | Yes |\n| `UNLOADING` | Plugin being shut down | → `UNLOADED` | Yes |\n\n#### Custom Renderer Development\n\nCustom renderers demonstrate the most common and powerful use of the plugin architecture. Rather than generating HTML, custom renderers can produce LaTeX for academic papers, plain text for accessibility, or structured data formats like JSON or XML.\n\nA LaTeX renderer plugin illustrates how specialized output formats leverage the existing AST structure while producing completely different markup. The LaTeX renderer traverses the same AST generated by the standard parsing pipeline but emits LaTeX commands instead of HTML tags.\n\n**LaTeX Renderer Example Mapping:**\n\n| AST Node Type | HTML Output | LaTeX Output | Special Handling |\n|---------------|-------------|--------------|-----------------|\n| `HEADING` (level 1) | `<h1>title</h1>` | `\\section{title}` | Convert heading levels to LaTeX sectioning |\n| `STRONG` | `<strong>text</strong>` | `\\textbf{text}` | Handle nested emphasis |\n| `EMPHASIS` | `<em>text</em>` | `\\textit{text}` | Handle nested emphasis |\n| `CODE_BLOCK` | `<pre><code>content</code></pre>` | `\\begin{verbatim}content\\end{verbatim}` | Preserve exact formatting |\n| `LINK` | `<a href=\"url\">text</a>` | `\\href{url}{text}` | URL validation for LaTeX |\n\nCustom renderers must handle the tree traversal logic and maintain proper nesting of their output format. The plugin interface provides helper methods for common tasks, but complex renderers may need sophisticated state management to produce well-formed output.\n\n#### Extension Development Best Practices\n\nEffective plugin development requires understanding both the markdown renderer's architecture and the specific requirements of the extension's domain. Successful plugins follow several key principles that ensure reliable integration and good performance.\n\n**Plugin Development Principles:**\n\n1. **Minimal Surface Area**: Plugins should interact with the core system through well-defined interfaces, avoiding dependencies on internal implementation details\n2. **Error Isolation**: Plugin errors should not crash the entire parsing pipeline - implement proper error handling and graceful degradation\n3. **Performance Awareness**: Plugins operate within the parsing pipeline and can impact overall performance - optimize for common cases and avoid expensive operations in hot paths\n4. **Configuration Validation**: Validate plugin configuration early and provide clear error messages for misconfigurations\n5. **Documentation Standards**: Provide clear documentation of supported syntax, configuration options, and interaction with other plugins\n\n> **Architecture Insight**: The plugin architecture's power comes from operating on the AST representation rather than raw text. This means plugins can focus on their specific functionality without reimplementing text parsing logic, and multiple plugins can collaborate by operating on the same standardized data structures.\n\n#### Extension Ecosystem Considerations\n\nAs the plugin ecosystem grows, certain patterns emerge for managing plugin interactions and maintaining system stability. The plugin architecture must accommodate both simple single-purpose plugins and complex multi-feature extensions.\n\n**Plugin Interaction Patterns:**\n\n| Pattern | Description | Benefits | Challenges |\n|---------|-------------|----------|-----------|\n| **Independent Plugins** | Plugins operate on disjoint node types | No conflicts, simple testing | Limited collaboration possibilities |\n| **Layered Processing** | Plugins process in defined order with dependencies | Powerful compositions, clear data flow | Complex dependency management |\n| **Collaborative Plugins** | Plugins share state or coordinate through APIs | Rich feature interactions | Increased coupling, harder debugging |\n| **Override Plugins** | Later plugins can replace earlier plugin output | Flexible customization | Potential conflicts, unclear precedence |\n\nThe plugin manager implements sophisticated conflict detection and resolution to handle cases where multiple plugins claim to handle the same node types or syntax patterns. Priority systems and explicit conflict declarations help users configure complex plugin combinations successfully.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Implementation | Advanced Implementation |\n|-----------|----------------------|------------------------|\n| Extension Registry | Dictionary-based lookup with static registration | Dynamic loading with dependency resolution |\n| Plugin Interface | Duck-typed protocols | Abstract base classes with type checking |\n| Configuration Management | JSON/YAML files with manual validation | Schema validation with automatic documentation |\n| Plugin Discovery | Explicit registration in main module | Automatic discovery via entry points |\n| Error Handling | Try-catch around plugin calls | Circuit breaker pattern with fallback strategies |\n\n#### File Structure for Extensions\n\n```\nproject-root/\n  core/\n    parser.py           ← Core parsing logic\n    ast_nodes.py        ← AST node definitions\n    html_renderer.py    ← Base HTML renderer\n  \n  extensions/\n    __init__.py         ← Extension registry\n    tables.py           ← Table extension\n    math.py             ← Math expression extension\n    task_lists.py       ← Task list extension\n    \n  plugins/\n    __init__.py         ← Plugin manager and interfaces\n    base_plugin.py      ← Abstract plugin base classes\n    renderer_plugins.py ← Renderer plugin interfaces\n    parser_plugins.py   ← Parser plugin interfaces\n    \n  renderers/\n    latex_renderer.py   ← LaTeX output renderer\n    json_renderer.py    ← JSON AST serializer\n    plain_text.py       ← Accessibility text renderer\n```\n\n#### Plugin Manager Infrastructure\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, List, Any, Optional, Protocol\nfrom enum import Enum\nimport logging\n\nclass PluginState(Enum):\n    UNLOADED = \"unloaded\"\n    LOADING = \"loading\" \n    LOADED = \"loaded\"\n    ACTIVE = \"active\"\n    ERROR = \"error\"\n    UNLOADING = \"unloading\"\n\nclass RendererPlugin(ABC):\n    \"\"\"\n    Abstract base class for custom renderer plugins.\n    Renderers transform AST nodes into output formats.\n    \"\"\"\n    \n    @abstractmethod\n    def get_supported_types(self) -> List[str]:\n        \"\"\"Return list of NodeType enum values this plugin handles.\"\"\"\n        # TODO: Return NodeType values this renderer supports\n        pass\n    \n    @abstractmethod\n    def render_node(self, node: 'ASTNode', context: 'RenderContext') -> str:\n        \"\"\"\n        Render a single AST node to output format.\n        \n        Args:\n            node: AST node to render\n            context: Rendering context with utilities and state\n            \n        Returns:\n            String representation in target format\n        \"\"\"\n        # TODO: Implement node-specific rendering logic\n        # TODO: Handle child node rendering via context.render_children()\n        # TODO: Apply any node-specific formatting or escaping\n        pass\n    \n    def get_priority(self) -> int:\n        \"\"\"Return priority for plugin precedence (higher = more priority).\"\"\"\n        return 0\n    \n    def initialize(self, config: Dict[str, Any]) -> bool:\n        \"\"\"Initialize plugin with configuration. Return True if successful.\"\"\"\n        # TODO: Validate configuration parameters\n        # TODO: Set up any required resources or connections\n        # TODO: Return False if initialization fails\n        return True\n    \n    def finalize(self) -> None:\n        \"\"\"Clean up plugin resources.\"\"\"\n        # TODO: Close any open files, connections, or resources\n        # TODO: Save any persistent state if needed\n        pass\n\nclass PluginManager:\n    \"\"\"\n    Manages plugin registration, lifecycle, and execution.\n    Coordinates between core parser and extension plugins.\n    \"\"\"\n    \n    def __init__(self):\n        self.plugins: Dict[str, RendererPlugin] = {}\n        self.node_renderers: Dict[str, List[RendererPlugin]] = {}\n        self.plugin_states: Dict[str, PluginState] = {}\n        self.plugin_configs: Dict[str, Dict[str, Any]] = {}\n        self.logger = logging.getLogger(__name__)\n    \n    def register_plugin(self, name: str, plugin: RendererPlugin, \n                       config: Optional[Dict[str, Any]] = None) -> bool:\n        \"\"\"\n        Register a renderer plugin with the manager.\n        \n        Args:\n            name: Unique plugin identifier\n            plugin: Plugin instance implementing RendererPlugin\n            config: Optional configuration dictionary\n            \n        Returns:\n            True if registration successful, False otherwise\n        \"\"\"\n        # TODO: Check if plugin name already exists\n        # TODO: Validate plugin implements required interface\n        # TODO: Store plugin with UNLOADED state\n        # TODO: Initialize plugin with provided config\n        # TODO: Update node_renderers mapping for supported types\n        # TODO: Handle initialization errors gracefully\n        pass\n    \n    def get_renderer(self, node_type: str) -> Optional[RendererPlugin]:\n        \"\"\"\n        Get the best renderer for a given node type.\n        \n        Args:\n            node_type: NodeType enum value as string\n            \n        Returns:\n            Highest priority renderer for node type, or None\n        \"\"\"\n        # TODO: Look up renderers for node_type in node_renderers\n        # TODO: Return highest priority renderer from available options\n        # TODO: Handle case where no renderer is available\n        pass\n    \n    def render_with_fallback(self, node: 'ASTNode', \n                           context: 'RenderContext') -> str:\n        \"\"\"\n        Render node with automatic fallback to default renderer.\n        \n        Args:\n            node: AST node to render\n            context: Rendering context\n            \n        Returns:\n            Rendered output with fallback if plugin fails\n        \"\"\"\n        # TODO: Get best renderer for node.node_type\n        # TODO: Attempt rendering with primary renderer\n        # TODO: Catch and log any plugin errors\n        # TODO: Fall back to default renderer if plugin fails\n        # TODO: Return rendered output or error placeholder\n        pass\n\nclass RenderContext:\n    \"\"\"\n    Provides rendering utilities and state management for plugins.\n    Passed to renderer plugins during node processing.\n    \"\"\"\n    \n    def __init__(self, plugin_manager: PluginManager, config: Dict[str, Any]):\n        self.plugin_manager = plugin_manager\n        self.config = config\n        self.depth = 0\n        self.current_list_context: Optional['ListContext'] = None\n        self.html_escaper = HtmlEscaper()\n        \n    def render_children(self, node: 'ASTNode') -> str:\n        \"\"\"\n        Render all child nodes of the given node.\n        \n        Args:\n            node: Parent node whose children should be rendered\n            \n        Returns:\n            Concatenated rendering of all child nodes\n        \"\"\"\n        # TODO: Iterate through node.children\n        # TODO: Render each child using plugin_manager.render_with_fallback\n        # TODO: Concatenate results and return combined output\n        pass\n    \n    def escape_for_format(self, text: str, format_type: str = \"html\") -> str:\n        \"\"\"\n        Escape text for target output format.\n        \n        Args:\n            text: Raw text to escape\n            format_type: Target format (\"html\", \"latex\", \"xml\", etc.)\n            \n        Returns:\n            Properly escaped text for target format\n        \"\"\"\n        # TODO: Implement format-specific escaping logic\n        # TODO: Handle HTML entities, LaTeX special chars, etc.\n        # TODO: Return escaped text appropriate for format\n        pass\n```\n\n#### Table Extension Implementation\n\n```python\nimport re\nfrom typing import List, Optional, Tuple\nfrom dataclasses import dataclass\n\n@dataclass\nclass TableAlignment:\n    \"\"\"Represents column alignment specification from table delimiter row.\"\"\"\n    left: bool = False\n    right: bool = False\n    center: bool = False\n    \n    @classmethod\n    def from_delimiter(cls, delimiter: str) -> 'TableAlignment':\n        \"\"\"Parse alignment from delimiter cell like ':---:', '---:', ':---'\"\"\"\n        # TODO: Check for leading colon (left alignment)\n        # TODO: Check for trailing colon (right alignment) \n        # TODO: Determine center alignment (both colons present)\n        # TODO: Return TableAlignment instance with appropriate flags\n        pass\n\nclass TableExtension:\n    \"\"\"\n    Extension for parsing GitHub Flavored Markdown tables.\n    Integrates with block parser to recognize and process table syntax.\n    \"\"\"\n    \n    # Regex patterns for table recognition\n    TABLE_ROW_PATTERN = re.compile(r'^\\s*\\|.*\\|\\s*$')\n    DELIMITER_ROW_PATTERN = re.compile(r'^\\s*\\|?\\s*:?-+:?\\s*(\\|\\s*:?-+:?\\s*)*\\|?\\s*$')\n    \n    def can_start_table(self, current_line: 'LineInfo', \n                       next_line: Optional['LineInfo']) -> bool:\n        \"\"\"\n        Determine if current line could start a table.\n        \n        Args:\n            current_line: Potential table header line\n            next_line: Potential delimiter row (must be present)\n            \n        Returns:\n            True if these lines form valid table start\n        \"\"\"\n        # TODO: Check current_line matches TABLE_ROW_PATTERN\n        # TODO: Check next_line exists and matches DELIMITER_ROW_PATTERN  \n        # TODO: Verify column count compatibility between header and delimiter\n        # TODO: Return True only if valid table structure detected\n        pass\n    \n    def parse_table_block(self, lines: List['LineInfo'], \n                         start_index: int) -> Tuple['BlockNode', int]:\n        \"\"\"\n        Parse complete table from line sequence.\n        \n        Args:\n            lines: Full document line sequence\n            start_index: Index of table header line\n            \n        Returns:\n            Tuple of (table BlockNode, number of lines consumed)\n        \"\"\"\n        # TODO: Parse header row and extract cell content\n        # TODO: Parse delimiter row and extract alignment specifications\n        # TODO: Continue parsing data rows until table structure breaks\n        # TODO: Create table BlockNode with appropriate child structure\n        # TODO: Set table attributes (column_count, alignments)\n        # TODO: Return table node and consumed line count\n        pass\n    \n    def parse_table_row(self, line: 'LineInfo', \n                       expected_columns: int) -> List[str]:\n        \"\"\"\n        Parse a single table row into cell contents.\n        \n        Args:\n            line: Line containing table row\n            expected_columns: Expected number of columns\n            \n        Returns:\n            List of cell contents (trimmed strings)\n        \"\"\"\n        # TODO: Split line on pipe characters\n        # TODO: Handle escaped pipes (\\|) that should not split\n        # TODO: Trim whitespace from each cell\n        # TODO: Pad or truncate to match expected_columns\n        # TODO: Return list of cell content strings\n        pass\n    \n    def extract_alignments(self, delimiter_line: 'LineInfo') -> List[TableAlignment]:\n        \"\"\"\n        Extract column alignment specifications from delimiter row.\n        \n        Args:\n            delimiter_line: Table delimiter row like '|:---|---:|:---:|'\n            \n        Returns:\n            List of TableAlignment objects for each column\n        \"\"\"\n        # TODO: Split delimiter line on pipe characters\n        # TODO: Parse each delimiter cell for colon positions\n        # TODO: Create TableAlignment objects based on colon placement\n        # TODO: Return list of alignments matching column order\n        pass\n```\n\n#### Milestone Checkpoints\n\n**Extension Integration Checkpoint:**\nAfter implementing the basic plugin architecture:\n\n1. **Plugin Registration Test**: Create a simple test plugin and verify it registers correctly\n   ```bash\n   python -m pytest tests/test_plugin_manager.py::test_plugin_registration\n   ```\n\n2. **Table Extension Test**: Test table parsing with various alignment combinations\n   ```bash\n   echo \"| Header 1 | Header 2 | Header 3 |\n   |:---------|:--------:|---------:|\n   | Left     | Center   | Right    |\" | python -m markdown_renderer --extension tables\n   ```\n\n3. **Custom Renderer Test**: Implement a simple JSON renderer and verify AST serialization\n   ```bash\n   echo \"# Test heading\\n\\nSome **bold** text\" | python -m markdown_renderer --renderer json\n   ```\n\n**Plugin Development Checkpoint:**\nExpected plugin development workflow:\n\n1. **Interface Implementation**: Plugin implements required abstract methods without errors\n2. **Registration Success**: Plugin registers with manager and appears in plugin list\n3. **Node Processing**: Plugin correctly processes assigned node types\n4. **Error Handling**: Plugin failures don't crash the parser pipeline\n5. **Configuration Loading**: Plugin accepts and validates configuration parameters\n\n**Common Plugin Issues:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Plugin not found | Registration failed | Check plugin manager logs | Verify plugin registration call |\n| Node not processed | Type mapping incorrect | Check get_supported_types() | Fix node type constants |\n| Rendering errors | Missing context usage | Test render_node() directly | Use context.render_children() |\n| Performance slow | Inefficient traversal | Profile plugin execution | Optimize hot path operations |\n| Config errors | Validation missing | Check initialize() return | Add config parameter validation |\n\n\n## Glossary\n\n> **Milestone(s):** Milestone 1: Block Elements, Milestone 2: Inline Elements, Milestone 3: Lists, Milestone 4: HTML Generation\n\n### The Reference Manual Mental Model\n\nThink of this glossary as a reference manual for a complex piece of machinery - the markdown renderer. Just as a mechanic needs to understand the precise terminology for each engine component to diagnose problems and communicate solutions, developers working with markdown parsers need a shared vocabulary of technical terms, parsing concepts, and architectural patterns. Each term in this glossary represents a specific concept with precise meaning within the context of document transformation systems.\n\nThe glossary serves multiple purposes beyond simple definition lookup. It establishes consistent terminology across the entire system, prevents confusion between similar concepts (like \"block-level elements\" versus \"block nodes\"), and provides the conceptual foundation for understanding complex interactions between parser components. When debugging a delimiter matching issue or discussing extension architecture, having precise terminology eliminates ambiguity and accelerates problem resolution.\n\nThis reference organizes terminology into logical categories that mirror the system architecture: core parsing concepts, data structures and types, algorithms and processes, architectural patterns, error handling terminology, testing and debugging vocabulary, and extensibility concepts. Each category builds upon previous ones, creating a coherent knowledge framework for the entire markdown rendering domain.\n\n### Core Parsing Concepts\n\nThese fundamental concepts form the theoretical foundation for understanding how markdown parsers transform textual input into structured output. Each concept represents a key insight about the nature of document transformation that influences architectural decisions throughout the system.\n\n**Abstract Syntax Tree (AST)**: A hierarchical tree data structure that represents the parsed structure of a markdown document, where each node corresponds to a markdown element (paragraph, heading, emphasis, link, etc.) and the tree relationships capture the nesting and containment relationships between elements. The AST serves as the intermediate representation that decouples parsing logic from HTML generation, enabling different output formats and transformation passes.\n\n**Block-level elements**: Structural markdown elements that define document layout and organization, including paragraphs, headings, lists, code blocks, blockquotes, and horizontal rules. Block-level elements typically span multiple lines, can contain other block elements or inline elements, and establish the primary document structure that determines reading flow and semantic meaning.\n\n**Inline elements**: Formatting markdown elements that exist within block-level elements and modify text appearance or behavior, including emphasis (bold and italic), inline code spans, links, images, and line breaks. Inline elements cannot contain block-level elements and typically span portions of a single line, though they can contain other inline elements through nesting.\n\n**Two-phase parsing**: A parsing architecture that separates document processing into distinct block parsing and inline parsing phases, where block parsing first identifies and structures document-level elements, then inline parsing processes formatting within each block's content. This separation simplifies parsing logic, enables context-dependent inline processing, and allows independent optimization of each parsing phase.\n\n**CommonMark**: The standardized specification for markdown syntax that defines precise parsing rules, handles edge cases consistently, and provides a reference implementation for validation. CommonMark eliminates ambiguities in original markdown specifications and serves as the authoritative source for parsing behavior in complex scenarios.\n\n**Context-dependent parsing**: Parsing rules that change behavior based on surrounding content, document state, or position within other elements. Examples include emphasis delimiters that behave differently at word boundaries, list markers that require specific indentation contexts, and inline code that disables other formatting rules within its boundaries.\n\n**State machine**: A parsing approach that models the parser as having distinct internal states (like \"looking for block,\" \"in paragraph,\" \"in code block\") with defined transitions between states triggered by specific input patterns. State machines provide predictable parsing behavior, simplify handling of complex multi-line constructs, and enable systematic testing of parser logic.\n\n**Lookahead**: The technique of examining upcoming input characters or lines without consuming them from the input stream, enabling the parser to make decisions based on future context. Lookahead is essential for handling Setext headings (which require examining the following line), determining block continuation, and resolving parsing ambiguities.\n\n### Markdown Syntax Terminology\n\nThese terms describe specific markdown syntactic constructs and their parsing requirements, providing precise vocabulary for discussing parsing challenges and implementation strategies.\n\n**ATX headings**: Hash-prefix style headings that use one to six `#` characters at the beginning of a line to indicate heading levels, such as `# Heading 1` or `### Heading 3`. ATX headings are self-contained on a single line and can be identified immediately without lookahead.\n\n**Setext headings**: Underline-style headings that use lines of `=` characters (for level 1) or `-` characters (for level 2) underneath the heading text. Setext headings require lookahead parsing since the heading text appears first, followed by the underline marker on the next line.\n\n**Fenced code blocks**: Multi-line code blocks delimited by lines containing three or more backticks (`` ``` ``) or tildes (`~~~`), optionally followed by a language identifier for syntax highlighting. Fenced code blocks preserve all internal content literally, including markdown syntax that would otherwise be parsed.\n\n**Indented code blocks**: Multi-line code blocks created by indenting every line by at least four spaces or one tab character. Indented code blocks end when a line is encountered that is not indented sufficiently or when the document ends.\n\n**Lazy continuation**: The CommonMark rule allowing certain block elements (like blockquotes and list items) to continue on subsequent lines even when those lines don't include the expected prefix markers, as long as the content would otherwise be part of a paragraph.\n\n**Intraword underscore**: Underscore characters that appear within a word (like `snake_case_variable`) and should not trigger emphasis formatting according to CommonMark rules. Detecting intraword underscores requires examining characters before and after potential emphasis delimiters.\n\n### Parsing Algorithm Terminology\n\nThese terms describe the specific algorithms and techniques used throughout the parsing pipeline, providing precise vocabulary for discussing implementation strategies and optimization approaches.\n\n**Delimiter matching**: The algorithm for finding pairs of formatting markers (like `**` for bold or `[` and `]` for links) that define the boundaries of inline formatting. Delimiter matching must handle nesting, precedence rules, and various edge cases like unmatched or overlapping delimiters.\n\n**Delimiter stack**: A data structure that tracks unmatched opening delimiters during inline parsing, enabling proper nesting and precedence handling for emphasis, strong emphasis, and other delimiter-based formatting. The delimiter stack is processed using specific algorithms defined in the CommonMark specification.\n\n**Flanking detection**: The algorithm for determining whether emphasis delimiters (asterisks and underscores) can open or close emphasis based on the characters immediately before and after the delimiter sequence. Flanking rules prevent emphasis in contexts like `a*b*c` where the asterisks are surrounded by alphanumeric characters.\n\n**Emphasis delimiter precedence**: The rules for resolving conflicts when multiple emphasis delimiters could match the same text span, such as in `***bold and italic***` where delimiters must be matched according to specific precedence rules to produce consistent output.\n\n**Depth-first traversal**: The tree traversal algorithm used during HTML generation to visit AST nodes, where each node is processed before its siblings, and all descendants are visited before moving to the next sibling. This traversal pattern ensures proper HTML nesting and content ordering.\n\n**HTML entity escaping**: The process of converting special characters (like `<`, `>`, `&`, and quotes) to their corresponding HTML entities (`&lt;`, `&gt;`, `&amp;`, etc.) to prevent HTML injection and ensure proper display of literal characters.\n\n**Pretty printing**: The process of formatting HTML output with consistent indentation, line breaks, and spacing to make the generated HTML human-readable for debugging and development purposes.\n\n### Data Structure and Type Terminology\n\nThese terms describe the specific data structures, types, and interfaces used throughout the system, providing precise vocabulary for discussing implementation details and component interactions.\n\n**AST node types**: The enumerated categories of nodes in the abstract syntax tree, including `DOCUMENT` (root node), `BLOCK` (block-level elements), `INLINE` (inline formatting elements), and `TEXT` (literal text content). Each node type determines processing behavior and available operations.\n\n**Block types**: The specific categories of block-level elements, including `PARAGRAPH`, `HEADING`, `CODE_BLOCK`, `BLOCKQUOTE`, `HORIZONTAL_RULE`, `LIST`, `LIST_ITEM`, and extended types like `TABLE` components. Block types determine parsing rules, HTML output generation, and containment relationships.\n\n**Inline types**: The specific categories of inline formatting elements, including `STRONG` (bold), `EMPHASIS` (italic), `CODE` (inline code), `LINK`, `IMAGE`, and `LINE_BREAK`. Inline types determine delimiter matching rules, nesting behavior, and HTML generation logic.\n\n**Parser state enumeration**: The defined states for the block parsing state machine, including `LOOKING_FOR_BLOCK`, `IN_PARAGRAPH`, `IN_FENCED_CODE`, `IN_INDENTED_CODE`, and `IN_BLOCKQUOTE`. These states determine how input lines are processed and when state transitions occur.\n\n**Delimiter types**: The categories of characters that can act as formatting delimiters, including `ASTERISK`, `UNDERSCORE`, `BACKTICK`, `LEFT_BRACKET`, and `EXCLAMATION_BRACKET`. Each delimiter type has specific rules for opening and closing formatting spans.\n\n**List marker types**: The categories of list markers, including `UNORDERED_DASH`, `UNORDERED_ASTERISK`, `UNORDERED_PLUS` for unordered lists, and `ORDERED_PERIOD`, `ORDERED_PAREN` for ordered lists. Marker types determine list compatibility and nesting rules.\n\n**List state enumeration**: The states that track whether lists should have tight or loose formatting, including `TIGHT` (no blank lines between items), `LOOSE` (blank lines create paragraph wrapping), and `UNDETERMINED` (final state not yet decided based on input).\n\n### Error Handling and Recovery Terminology\n\nThese terms describe the systematic approach to handling malformed input, parsing errors, and recovery strategies that maintain system stability while providing useful feedback to users.\n\n**Parser error recovery**: The comprehensive strategy for handling invalid markdown syntax while continuing to parse subsequent content, including detection of errors, classification by severity, application of recovery strategies, and collection of diagnostic information for user feedback.\n\n**Graceful degradation**: The design principle where parser failures in one component or with one piece of input do not prevent processing of other components or content, ensuring the system produces useful output even when encountering unexpected input patterns.\n\n**Recovery strategies**: The defined approaches for handling specific types of parsing errors, including `COMPLETE_BLOCK` (finish current block and continue), `CONVERT_TO_PARAGRAPH` (treat malformed syntax as regular text), `PRESERVE_CONTENT` (maintain content while fixing structure), and `SKIP_MALFORMED` (ignore invalid sections entirely).\n\n**Error severity levels**: The classification system for parsing errors, including `WARNING` (non-critical issues that don't prevent processing), `ERROR` (significant problems that require recovery), and `CRITICAL` (failures that prevent further processing of affected sections).\n\n**Continuation-based recovery**: The recovery approach where errors in parsing one block element do not prevent successful parsing of subsequent blocks, maintaining document-level processing even when individual elements contain syntax errors.\n\n**Delimiter balancing recovery**: The specialized recovery strategy for handling unmatched or incorrectly nested emphasis delimiters, including conversion to literal characters, automatic closing of unmatched openers, and precedence-based resolution of conflicting matches.\n\n**Semantic whitespace preservation**: The recovery technique that preserves whitespace characters that affect document meaning and display while normalizing insignificant whitespace, ensuring consistent output regardless of input formatting variations.\n\n### Testing and Debugging Terminology\n\nThese terms describe the specialized vocabulary for systematic testing and debugging of parser components, providing precise language for discussing quality assurance approaches and problem diagnosis techniques.\n\n**State machine debugging**: The systematic debugging approach for parser state transitions, including verification of state consistency, validation of transition triggers, identification of unreachable states, and detection of infinite loops or incorrect state changes.\n\n**Pipeline stage isolation**: The debugging technique that tests individual parsing components in isolation from the complete pipeline, enabling precise identification of issues within specific transformation stages without interference from other components.\n\n**Delimiter balance and nesting debugging**: The specialized debugging approach for inline formatting issues, focusing on delimiter stack state, matching algorithms, precedence resolution, and the interaction between different types of emphasis delimiters.\n\n**Tree structure validation**: The comprehensive checking of AST parent-child relationships, node type consistency, content validation, and structural integrity to ensure the parsed tree accurately represents the intended document structure.\n\n**Performance debugging**: The specialized debugging focused on algorithmic complexity, resource usage patterns, memory allocation behavior, and execution time analysis to identify and resolve performance bottlenecks in parsing operations.\n\n**Context dependency debugging**: The debugging approach for parser rules that depend on surrounding content, document state, or position within other elements, requiring careful analysis of parsing context and state propagation.\n\n**Edge case handling**: The systematic approach to defining consistent behavior for ambiguous input patterns, unusual syntax combinations, and boundary conditions that may not be explicitly covered by the CommonMark specification.\n\n### Architecture and Extension Terminology\n\nThese terms describe the extensibility mechanisms, architectural patterns, and design approaches that enable customization and enhancement of the core markdown renderer while maintaining system integrity.\n\n**Plugin architecture**: The extensibility system that allows custom functionality to be added to the markdown renderer without modifying core components, including plugin registration, lifecycle management, and integration points for custom behavior.\n\n**Extension points**: The defined integration interfaces where plugins can hook into the parsing or rendering pipeline, including custom block parsers, inline element handlers, HTML renderers, and output format generators.\n\n**Renderer plugins**: The specific type of plugin that generates custom output formats or modifies HTML generation behavior for specific node types, enabling support for different target formats while reusing the parsing pipeline.\n\n**Plugin lifecycle**: The managed states and transitions for plugin loading and cleanup, including `UNLOADED`, `LOADING`, `LOADED`, `ACTIVE`, `ERROR`, and `UNLOADING` states with defined transitions and error handling.\n\n**Compositional extensions**: The design approach where new functionality is added through composition of existing components rather than inheritance or modification of core classes, enabling flexible customization while maintaining system stability.\n\n**CommonMark extensions**: The standardized additions to the base CommonMark specification, including tables, task lists, strikethrough text, and other commonly supported features that extend basic markdown capabilities.\n\n**Pipeline architecture**: The unidirectional data flow design where input is transformed through a sequence of processing stages, with each stage having well-defined inputs, outputs, and responsibilities that enable component isolation and testing.\n\n**Component isolation**: The design principle ensuring clear separation between parsing logic components, with minimal dependencies and well-defined interfaces that enable independent development, testing, and modification of system parts.\n\n### Regular Expression and Pattern Matching Terminology\n\nThese terms describe the specific patterns, matching techniques, and regex-based parsing approaches used throughout the system for recognizing markdown syntax and extracting structured information.\n\n**ATX_HEADING_PATTERN**: The regular expression pattern for matching hash-prefix headings, typically `^(#{1,6})\\s+(.+?)(?:\\s+#+)?$`, which captures the heading level through hash count and the heading text while allowing optional trailing hashes.\n\n**SETEXT_H1_UNDERLINE** and **SETEXT_H2_UNDERLINE**: Regular expression patterns for matching Setext heading underlines, using patterns like `^=+$` for level 1 headings and `^-+$` for level 2 headings, requiring coordination with the previous line's content.\n\n**FENCED_CODE_START** and **FENCED_CODE_END**: Patterns for matching the opening and closing delimiters of fenced code blocks, typically `^```(\\w*)$` or `^~~~(\\w*)$` for opening (with optional language specification) and corresponding closing patterns.\n\n**HORIZONTAL_RULE_PATTERN**: The pattern for matching horizontal rules, such as `^(?:(?:\\* *){3,}|(?:- *){3,}|(?:_ *){3,})$`, which recognizes three or more asterisks, dashes, or underscores with optional spacing.\n\n**BLOCKQUOTE_PATTERN**: The pattern for matching blockquote lines, typically `^> ?(.*)$`, which captures the content after the blockquote marker while allowing for optional space after the greater-than symbol.\n\n**UNORDERED_MARKER_PATTERN** and **ORDERED_MARKER_PATTERN**: Patterns for detecting list markers, such as `^( *)([*+-]) +(.*)$` for unordered lists and `^( *)(\\d{1,9})[.)] +(.*)$` for ordered lists, capturing indentation, marker, and content.\n\n### HTML Generation and Output Terminology\n\nThese terms describe the specific concepts, techniques, and standards used when converting the parsed AST into HTML output, including escaping, formatting, and validation considerations.\n\n**HTML_ESCAPE_TABLE**: The mapping data structure that defines character-to-entity conversions for HTML escaping, typically including `&` → `&amp;`, `<` → `&lt;`, `>` → `&gt;`, `\"` → `&quot;`, and `'` → `&#39;`.\n\n**ATTRIBUTE_ESCAPE_TABLE**: The specialized character mapping for escaping HTML attribute values, which may have different escaping requirements than HTML content, particularly for quote characters and attribute-specific special characters.\n\n**VOID_ELEMENTS**: The set of HTML5 element names that cannot have content or closing tags, including `area`, `base`, `br`, `col`, `embed`, `hr`, `img`, `input`, `link`, `meta`, `param`, `source`, `track`, and `wbr`.\n\n**Self-closing tags**: HTML elements that don't have separate closing tags and are written as single tags like `<hr>` or `<img src=\"...\" alt=\"...\">`, requiring special handling during HTML generation to avoid generating incorrect closing tags.\n\n**Double-escaping**: The error condition where HTML special characters are escaped multiple times, resulting in output like `&amp;lt;` instead of `&lt;`, typically caused by applying escaping at multiple stages of the processing pipeline.\n\n**Attribute value escaping**: The specialized escaping rules for content within HTML attribute values, which must handle quote characters appropriately and may require different escape sequences than general HTML content escaping.\n\n**Visitor pattern**: The design pattern used for traversing and operating on AST trees, where different node types accept visitor objects that implement specific operations, enabling separation of tree structure from processing algorithms.\n\n### Performance and Optimization Terminology\n\nThese terms describe the concepts and techniques related to parser performance, resource usage optimization, and scalability considerations in document processing systems.\n\n**Verbatim content blocks**: Regions of the document (like code blocks) where content is preserved exactly as written without any markdown parsing, requiring specialized handling to avoid unnecessary processing while maintaining exact character preservation.\n\n**Algorithmic complexity**: The analysis of parser operations in terms of time and space complexity, particularly important for operations like delimiter matching, list nesting resolution, and AST traversal that can exhibit quadratic or worse behavior on pathological input.\n\n**Memory allocation patterns**: The analysis of object creation and memory usage during parsing, including strategies for reducing garbage collection pressure, reusing temporary objects, and managing memory-intensive operations like large document processing.\n\n**Pipeline optimization**: The techniques for improving performance across the entire parsing pipeline, including lazy evaluation, early termination conditions, and optimization of data structure choices for specific access patterns.\n\n**Input size scaling**: The analysis of how parser performance changes with document size, including identification of operations that scale poorly and implementation of strategies to maintain reasonable performance on large documents.\n\nThis comprehensive glossary provides the terminological foundation for understanding, implementing, and extending markdown parsing systems. Each term represents a specific concept with precise meaning within the domain of document transformation, enabling clear communication about complex parsing algorithms and architectural decisions. The terminology spans from fundamental parsing concepts through specific implementation details to advanced extensibility patterns, supporting developers at all levels of expertise in building robust and maintainable markdown rendering systems.\n\n### Implementation Guidance\n\nThe terminology and concepts defined in this glossary should be implemented through consistent naming conventions and clear documentation standards throughout the codebase. This implementation guidance provides practical approaches for maintaining terminological consistency and supporting developer understanding.\n\n#### Technology Recommendations for Documentation\n\n| Aspect | Simple Option | Advanced Option |\n|--------|---------------|-----------------|\n| Code Documentation | Inline comments with term definitions | Sphinx/godoc with cross-references |\n| API Documentation | README with terminology section | OpenAPI specs with consistent terminology |\n| Type Documentation | Docstrings using exact term names | Generated docs with glossary integration |\n| Error Messages | Clear messages using standard terms | Structured errors with terminology links |\n\n#### Recommended Documentation Structure\n\n```\nproject-root/\n  docs/\n    glossary.md              ← this comprehensive glossary\n    api-reference.md         ← API docs using consistent terms\n    architecture-guide.md    ← high-level concepts with term links\n  src/\n    types.py                 ← type definitions with docstring references\n    constants.py             ← all named constants from glossary\n    exceptions.py            ← error types with standard terminology\n    utils/\n      validation.py          ← terminology validation utilities\n```\n\n#### Terminology Validation Utilities\n\n```python\n# Complete terminology validation infrastructure\nclass TerminologyValidator:\n    \"\"\"Validates that code uses consistent terminology from the glossary.\"\"\"\n    \n    def __init__(self, glossary_terms: Dict[str, str]):\n        self.glossary_terms = glossary_terms\n        self.deprecated_terms = {\n            'markdown_node': 'ASTNode',\n            'text_element': 'InlineNode', \n            'block_element': 'BlockNode'\n        }\n    \n    def validate_variable_names(self, source_code: str) -> List[str]:\n        \"\"\"Validate that variable names use standard terminology.\"\"\"\n        # TODO: Parse source code and extract variable names\n        # TODO: Check against glossary_terms dictionary\n        # TODO: Flag usage of deprecated_terms\n        # TODO: Suggest corrections for non-standard terminology\n        # TODO: Return list of validation errors with line numbers\n        pass\n    \n    def validate_function_signatures(self, module) -> List[str]:\n        \"\"\"Validate that function names and parameters use standard terms.\"\"\"\n        # TODO: Inspect module functions using reflection\n        # TODO: Check parameter names against standard terminology\n        # TODO: Validate return type annotations use correct type names\n        # TODO: Flag functions that don't follow naming conventions\n        pass\n\n# Standard constants with exact names from glossary\nHTML_ESCAPE_TABLE = {\n    '&': '&amp;',\n    '<': '&lt;', \n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n}\n\nATTRIBUTE_ESCAPE_TABLE = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;', \n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '\\n': '&#10;',\n    '\\r': '&#13;',\n    '\\t': '&#9;'\n}\n\nVOID_ELEMENTS = {\n    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', \n    'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'\n}\n\nESCAPABLE_CHARS = '\\\\`*_{}[]()#+-.!|~'\n\nEMPHASIS_DELIMITER_CHARS = {'*', '_'}\n```\n\n#### Core Terminology Integration\n\n```python\ndef validate_ast_terminology(root: ASTNode) -> List[ValidationError]:\n    \"\"\"Validate AST structure uses standard terminology and relationships.\"\"\"\n    # TODO: Check that node_type values match NodeType enum\n    # TODO: Verify block_type values match BlockType enum  \n    # TODO: Validate inline_type values match InlineType enum\n    # TODO: Ensure parent-child relationships are properly established\n    # TODO: Check that node attributes use standard attribute names\n    # TODO: Return comprehensive validation errors with fix suggestions\n    pass\n\ndef generate_terminology_report(codebase_path: str) -> str:\n    \"\"\"Generate report on terminology usage consistency across codebase.\"\"\"\n    # TODO: Scan all Python files in codebase_path\n    # TODO: Extract type names, variable names, function names\n    # TODO: Compare against standard terminology from glossary\n    # TODO: Identify inconsistencies and deprecated usage\n    # TODO: Generate formatted report with recommendations\n    # TODO: Include metrics on terminology compliance percentage\n    pass\n```\n\n#### Language-Specific Terminology Hints\n\nFor Python implementation:\n- Use exact enum names from glossary: `NodeType.DOCUMENT`, `BlockType.PARAGRAPH`, `InlineType.STRONG`\n- Follow PEP 8 naming: `parse_blocks()`, `render_to_html()`, `escape_html()`\n- Use descriptive variable names: `ast_root` not `root`, `block_node` not `node`\n- Include type hints with exact type names: `def parse_blocks(text: str) -> ASTNode`\n\nFor error messages:\n- Use standard terminology: \"Failed to parse ATX heading\" not \"Failed to parse hash heading\"\n- Reference specific types: \"Expected BlockType.HEADING\" not \"Expected heading type\"\n- Include glossary term definitions in extended error messages for learning\n\n#### Milestone Checkpoint: Terminology Consistency\n\nAfter implementing terminology standards:\n- Run `python -m terminology_validator src/` to check naming consistency\n- Verify all type definitions match glossary exactly: `NodeType`, `BlockType`, `InlineType`\n- Confirm error messages use standard terms from glossary\n- Test that API documentation uses consistent terminology throughout\n- Validate that code comments reference correct technical terms\n\nSigns of terminology problems:\n- Mixed naming conventions (some camelCase, some snake_case for same concepts)\n- Error messages using informal terms not in glossary\n- Type names that don't match the standard definitions\n- Function parameters with non-standard names like `md_text` instead of `markdown_text`\n\n#### Debugging Terminology Issues\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Confusing error messages | Inconsistent terminology usage | Check error message text against glossary | Update messages to use standard terms |\n| Hard to navigate codebase | Non-standard naming conventions | Audit variable/function names | Rename to match glossary conventions |\n| Documentation inconsistencies | Multiple terms for same concept | Cross-reference docs with glossary | Standardize on single term per concept |\n| Integration problems | Different components use different terms | Check inter-component interfaces | Align all interfaces to standard terminology |\n\nThis implementation guidance ensures that the comprehensive terminology defined in the glossary is consistently applied throughout the codebase, enabling clear communication, easier maintenance, and better developer experience when working with the markdown renderer system.\n"}