{"html":"<h1 id=\"password-hashing-design-document\">Password Hashing: Design Document</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>This system implements secure password storage and verification using cryptographic hashing, salting, and key stretching techniques. The key architectural challenge is balancing security against brute force attacks while maintaining reasonable performance for legitimate authentication attempts.</p>\n<blockquote>\n<p>This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.</p>\n</blockquote>\n<h2 id=\"context-and-problem-statement\">Context and Problem Statement</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (foundational concepts underlying the entire project)</p>\n</blockquote>\n<h3 id=\"mental-model-the-security-safe-analogy\">Mental Model: The Security Safe Analogy</h3>\n<p>Think of password storage like protecting valuables in a safe. A naive approach would be like writing down the safe combination on a sticky note and putting it on the safe door — anyone who finds it has immediate access. A slightly better approach might be hiding the combination in a desk drawer, but a determined thief will eventually find it. Secure password storage is like using multiple layers of protection: a time-locked safe (slow to open even with the right combination), a unique key for each safe (salt), and a combination that takes significant effort to discover even if you know the algorithm.</p>\n<p>The fundamental challenge in password storage is asymmetry: legitimate users need fast authentication (milliseconds), but attackers with stolen data have unlimited time and computational resources. Our security model must make authentication convenient for legitimate use while making brute force attacks computationally infeasible.</p>\n<h3 id=\"password-storage-vulnerabilities\">Password Storage Vulnerabilities</h3>\n<p>Password storage vulnerabilities represent one of the most critical security risks in modern applications. Understanding these vulnerabilities is essential because they directly impact user safety across multiple services — users frequently reuse passwords, so a breach in one system can cascade to compromise accounts elsewhere.</p>\n<p><strong>Plain Text Storage</strong> represents the most severe vulnerability. When passwords are stored in readable form, any system compromise immediately exposes all user credentials. Consider a database containing user records where the password field contains actual passwords like &quot;mypassword123&quot;. An attacker gaining read access through SQL injection, backup theft, or insider threat immediately obtains every user&#39;s authentication credentials. This vulnerability extends beyond the immediate system — if users have reused these passwords on other services (email, banking, social media), the attacker gains access to those accounts as well.</p>\n<p><strong>Simple Hashing Without Salt</strong> appears secure on the surface but falls victim to precomputed attacks. When passwords are hashed using algorithms like MD5 or SHA-256 without additional randomization, identical passwords produce identical hashes. An attacker can build rainbow tables — precomputed databases mapping common passwords to their hash values. For example, the password &quot;password123&quot; always produces the SHA-256 hash <code>ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f</code>. Rainbow tables for common passwords and hash algorithms are readily available online, making this attack trivial to execute.</p>\n<p><strong>Inadequate Salt Implementation</strong> introduces several attack vectors. Using predictable salts (like user ID or username) allows attackers to build targeted rainbow tables. Using short salts (less than 16 bytes) makes brute force attacks against the salt space feasible. Not storing the salt alongside the hash makes verification impossible. Using the same salt for multiple passwords eliminates the salt&#39;s protective benefit.</p>\n<p><strong>Fast Hashing Algorithm Selection</strong> enables high-speed brute force attacks. Algorithms like MD5, SHA-1, and SHA-256 were designed for speed and can compute millions of hashes per second on modern hardware. Graphics cards and specialized ASIC hardware can achieve billions of hash computations per second. An attacker with stolen password hashes can systematically try password combinations at these speeds, making weak passwords vulnerable within hours or days.</p>\n<blockquote>\n<p><strong>Critical Security Insight</strong>: The attacker&#39;s advantage is time and computational resources. While legitimate authentication happens once per login session, an attacker with stolen hashes can attempt billions of password guesses offline without detection or rate limiting.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Vulnerability Type</th>\n<th>Attack Vector</th>\n<th>Impact Severity</th>\n<th>Detection Difficulty</th>\n<th>Exploitation Speed</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Plain Text Storage</td>\n<td>Direct database access</td>\n<td>Critical - immediate full compromise</td>\n<td>Easy - obvious in data</td>\n<td>Instant</td>\n</tr>\n<tr>\n<td>Simple Hash (MD5/SHA256)</td>\n<td>Rainbow table lookup</td>\n<td>High - common passwords compromised</td>\n<td>Medium - requires hash analysis</td>\n<td>Seconds to minutes</td>\n</tr>\n<tr>\n<td>Predictable Salt</td>\n<td>Targeted rainbow tables</td>\n<td>High - targeted attack possible</td>\n<td>Medium - pattern analysis needed</td>\n<td>Minutes to hours</td>\n</tr>\n<tr>\n<td>Short Salt (&lt;16 bytes)</td>\n<td>Salt space brute force</td>\n<td>Medium - increases attack feasibility</td>\n<td>Hard - statistical analysis</td>\n<td>Hours to days</td>\n</tr>\n<tr>\n<td>Fast Algorithm (SHA256)</td>\n<td>High-speed brute force</td>\n<td>Medium to High - depends on password strength</td>\n<td>Hard - requires hash rate analysis</td>\n<td>Hours to weeks</td>\n</tr>\n</tbody></table>\n<p><strong>Timing Attack Vulnerabilities</strong> occur during password verification when comparison operations leak information through execution time differences. A naive string comparison function that returns false immediately upon finding a mismatched character allows attackers to measure response times and gradually discover the correct hash byte by byte. This side-channel attack can completely bypass the cryptographic protection.</p>\n<h3 id=\"threat-model\">Threat Model</h3>\n<p>Understanding our adversaries and their capabilities shapes every design decision in our password hashing system. We must defend against multiple threat categories with varying resources, motivations, and attack vectors.</p>\n<p><strong>Script Kiddie Attackers</strong> represent the most common threat category. These attackers use readily available tools and databases without deep technical understanding. They rely on automated vulnerability scanners, pre-built exploitation frameworks, and publicly available password lists. Their attacks typically target known vulnerabilities and common misconfigurations. They have limited computational resources (personal computers) and patience (looking for quick wins).</p>\n<p>Script kiddies primarily use rainbow table attacks against unsalted hashes and dictionary attacks against weakly salted hashes. They download password lists from previous breaches and hash them using common algorithms, hoping for matches. Their attack duration typically spans hours to days — they move on to easier targets if immediate success isn&#39;t achieved.</p>\n<p><strong>Organized Cybercriminal Groups</strong> operate with significantly more resources and sophistication. They maintain specialized hardware for password cracking, including GPU farms capable of billions of hash computations per second. These groups have access to comprehensive password databases compiled from years of breaches, sophisticated rule-based attack generators, and custom software optimized for specific hashing algorithms.</p>\n<p>Criminal organizations can sustain attacks for weeks or months, especially when targeting high-value accounts. They employ hybrid attacks combining dictionary words with common patterns, social engineering to discover password hints, and correlation attacks using data from multiple breaches to identify password reuse patterns.</p>\n<p><strong>Nation-State Actors</strong> possess the highest level of resources and technical capability. They have access to specialized hardware, custom silicon designed for cryptographic attacks, and significant computational budgets. Nation-state attackers can develop zero-day exploits against systems, conduct long-term persistent attacks, and correlate vast amounts of data from multiple sources.</p>\n<p>These actors can sustain attacks for months or years against specific high-value targets. They may compromise the systems where password hashing occurs rather than attacking the hashes themselves. Their threat extends beyond password cracking to include supply chain attacks against cryptographic libraries and side-channel attacks against hardware implementations.</p>\n<blockquote>\n<p><strong>Design Principle</strong>: Defense in depth requires protecting against the most sophisticated attackers while maintaining usability. If our system can resist nation-state level attacks, it will easily handle lesser threats.</p>\n</blockquote>\n<p><strong>Attack Scenarios and System Response</strong></p>\n<p>Consider a data breach where attackers gain access to our password database. The attack progression depends on our security implementations:</p>\n<ol>\n<li><strong>Database Extraction</strong>: Attackers export user authentication data containing usernames and password hashes</li>\n<li><strong>Hash Analysis</strong>: They analyze the hash format to identify the algorithm, salt presence, and iteration parameters  </li>\n<li><strong>Attack Preparation</strong>: Based on the analysis, they select appropriate cracking tools and resource allocation</li>\n<li><strong>Credential Recovery</strong>: They execute brute force, dictionary, or rule-based attacks to recover plaintext passwords</li>\n<li><strong>Credential Validation</strong>: Recovered passwords are tested against the original system and other services</li>\n<li><strong>Account Takeover</strong>: Successful password recovery enables unauthorized access to user accounts</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Attack Scenario</th>\n<th>Attacker Resources</th>\n<th>Attack Duration</th>\n<th>Success Rate vs Our System</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Rainbow table (unsalted SHA256)</td>\n<td>Personal computer</td>\n<td>Minutes</td>\n<td>90%+ of common passwords</td>\n</tr>\n<tr>\n<td>Dictionary attack (salted SHA256)</td>\n<td>GPU rig</td>\n<td>Days</td>\n<td>60-80% of weak passwords</td>\n</tr>\n<tr>\n<td>Brute force (PBKDF2, 100k iterations)</td>\n<td>GPU farm</td>\n<td>Weeks</td>\n<td>20-40% of weak passwords</td>\n</tr>\n<tr>\n<td>Advanced rules (bcrypt, cost 12)</td>\n<td>Specialized hardware</td>\n<td>Months</td>\n<td>5-15% of weak passwords</td>\n</tr>\n<tr>\n<td>Quantum-resistant (Argon2id, high memory)</td>\n<td>Nation-state resources</td>\n<td>Years</td>\n<td>&lt;5% of weak passwords</td>\n</tr>\n</tbody></table>\n<p><strong>Insider Threat Considerations</strong></p>\n<p>Insider threats represent a unique challenge because insiders may have elevated access to systems and data. A malicious administrator could potentially access password hashes directly from database backups, memory dumps, or log files. Our system must protect against insider threats through several mechanisms:</p>\n<ul>\n<li>Password hashes remain computationally expensive to crack even with administrator access</li>\n<li>Audit logging captures all access to authentication data</li>\n<li>Separation of duties prevents single administrators from accessing both encrypted backups and decryption keys</li>\n<li>Time-based security ensures that even compromised hashes become less valuable as users change passwords</li>\n</ul>\n<h3 id=\"existing-approaches-comparison\">Existing Approaches Comparison</h3>\n<p>Understanding the evolution of password storage approaches provides critical context for our design decisions. Each approach represents a response to attacks against its predecessors, building layers of protection against increasingly sophisticated threats.</p>\n<p><strong>Plain Text Storage</strong> offers no cryptographic protection but maximum simplicity. Legacy systems sometimes used plain text for debugging convenience or due to developer inexperience. The complete lack of security makes this approach unsuitable for any production system, but understanding it provides a baseline for comparison.</p>\n<p><strong>Simple Cryptographic Hashing</strong> applies one-way functions like MD5, SHA-1, or SHA-256 directly to passwords. The mathematical properties of cryptographic hash functions make password recovery theoretically difficult — finding an input that produces a specific hash output requires trying numerous possibilities. However, this approach fails against precomputed attacks because identical passwords always produce identical hashes.</p>\n<p>The fundamental weakness lies in the deterministic nature of cryptographic hashes. When millions of users choose &quot;password123&quot; as their password, all produce the same SHA-256 hash. An attacker can precompute hashes for common passwords and instantly identify users with those passwords in any breached database.</p>\n<blockquote>\n<p><strong>Architecture Decision: Salt Requirement</strong></p>\n<ul>\n<li><strong>Context</strong>: Simple hashing fails against rainbow table attacks due to deterministic hash outputs</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Faster hashing with larger password requirements</li>\n<li>Salted hashing with random values per password</li>\n<li>Encrypted storage with shared keys</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Require unique random salt for each password</li>\n<li><strong>Rationale</strong>: Salts make precomputed attacks impractical by ensuring unique hash outputs even for identical passwords, while maintaining the simplicity of one-way hashing</li>\n<li><strong>Consequences</strong>: Increased storage requirements (salt + hash per password) but elimination of rainbow table vulnerabilities</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Approach</th>\n<th>Computation Speed</th>\n<th>Precomputed Attack Resistance</th>\n<th>Storage Requirements</th>\n<th>Implementation Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Plain Text</td>\n<td>Instant</td>\n<td>None - no protection</td>\n<td>Minimal</td>\n<td>Trivial</td>\n</tr>\n<tr>\n<td>MD5 Hash</td>\n<td>~1 billion/sec/GPU</td>\n<td>None - rainbow tables available</td>\n<td>32 bytes</td>\n<td>Simple</td>\n</tr>\n<tr>\n<td>SHA-256 Hash</td>\n<td>~100 million/sec/GPU</td>\n<td>None - rainbow tables available</td>\n<td>64 bytes</td>\n<td>Simple</td>\n</tr>\n<tr>\n<td>SHA-256 + Salt</td>\n<td>~100 million/sec/GPU</td>\n<td>High - unique hashes</td>\n<td>80+ bytes</td>\n<td>Moderate</td>\n</tr>\n</tbody></table>\n<p><strong>Salted Hashing</strong> addresses rainbow table attacks by concatenating a unique random value (salt) with each password before hashing. Even if two users choose identical passwords, their different salts produce completely different hash outputs. This forces attackers to compute password guesses individually for each user rather than using precomputed tables.</p>\n<p>Effective salting requires cryptographically secure random salt generation, adequate salt length (minimum 16 bytes), and salt storage alongside the hash for verification. The salt doesn&#39;t need to be secret — it can be stored in plain text in the same database as the hash. Its security comes from uniqueness, not secrecy.</p>\n<p>However, salted hashing with fast algorithms still enables high-speed brute force attacks against individual users. Modern GPUs can compute millions of salted SHA-256 hashes per second, making weak passwords vulnerable within reasonable time frames.</p>\n<p><strong>Key Stretching Algorithms</strong> like PBKDF2, bcrypt, and scrypt intentionally slow down hash computation to make brute force attacks more expensive. Instead of computing a hash once, key stretching applies the hash function thousands or millions of times in sequence. This multiplicatively increases the computational cost for both legitimate verification and attacker password guessing.</p>\n<p>PBKDF2 (Password-Based Key Derivation Function 2) applies a pseudorandom function (typically HMAC-SHA256) iteratively. The iteration count parameter allows tuning the computational cost to match available hardware capabilities. Increasing the iteration count proportionally increases both verification time and brute force attack time.</p>\n<blockquote>\n<p><strong>Architecture Decision: Minimum Iteration Count</strong></p>\n<ul>\n<li><strong>Context</strong>: PBKDF2 security depends on sufficient iterations to slow brute force attacks</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Fixed 10,000 iterations (fast but potentially weak)</li>\n<li>Configurable minimum 100,000 iterations (balanced)</li>\n<li>Dynamic iteration count targeting specific verification time</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Configurable minimum 100,000 iterations with ability to increase</li>\n<li><strong>Rationale</strong>: 100,000 iterations provides reasonable protection against current GPU capabilities while allowing future increases as hardware improves</li>\n<li><strong>Consequences</strong>: Longer verification times (100-500ms) but significant increase in brute force attack cost</li>\n</ul>\n</blockquote>\n<p><strong>Modern Adaptive Hashing</strong> algorithms like bcrypt, scrypt, and Argon2 incorporate additional security features beyond simple iteration counting. These algorithms adapt to hardware capabilities and include memory-hard components that resist specialized attack hardware.</p>\n<p>bcrypt incorporates both time cost (iteration rounds) and built-in salt management. Its key innovation is adaptive cost — the work factor can be increased over time as hardware capabilities improve. bcrypt&#39;s design also includes resistance to timing attacks and side-channel analysis.</p>\n<p>Argon2 represents the current state-of-the-art in password hashing. It incorporates three cost parameters: time cost (iterations), memory cost (RAM usage), and parallelism (thread count). The memory-hard property makes attacks expensive even with specialized hardware like ASICs or FPGAs, which typically have limited memory compared to general-purpose computers.</p>\n<table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Time Cost Control</th>\n<th>Memory Cost</th>\n<th>Parallel Resistance</th>\n<th>Hardware Resistance</th>\n<th>Standardization</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PBKDF2</td>\n<td>Iteration count</td>\n<td>Minimal</td>\n<td>Good</td>\n<td>Limited - GPU friendly</td>\n<td>NIST approved</td>\n</tr>\n<tr>\n<td>bcrypt</td>\n<td>Work factor (2^n)</td>\n<td>Moderate</td>\n<td>Good</td>\n<td>Good - memory access patterns</td>\n<td>Widely deployed</td>\n</tr>\n<tr>\n<td>scrypt</td>\n<td>Time + memory parameters</td>\n<td>High - configurable</td>\n<td>Moderate</td>\n<td>Excellent - memory hard</td>\n<td>Some adoption</td>\n</tr>\n<tr>\n<td>Argon2</td>\n<td>Time + memory + threads</td>\n<td>High - configurable</td>\n<td>Excellent</td>\n<td>Excellent - memory hard</td>\n<td>PHC winner</td>\n</tr>\n</tbody></table>\n<p><strong>Comparative Security Analysis</strong></p>\n<p>The security effectiveness of each approach depends on the attacker&#39;s computational resources and time constraints. Against a moderately resourced attacker with GPU hardware, the time required to crack passwords varies dramatically:</p>\n<p>For a 8-character mixed-case alphanumeric password against different storage methods:</p>\n<ul>\n<li>Plain text: Instant compromise upon data access</li>\n<li>MD5 hash: Seconds (rainbow table lookup)  </li>\n<li>SHA-256 + salt: Hours (direct GPU brute force)</li>\n<li>PBKDF2 (100k iterations): Weeks (GPU farm required)</li>\n<li>bcrypt (cost 12): Months (significant computational investment)</li>\n<li>Argon2id (high memory): Years (requires massive memory + computation)</li>\n</ul>\n<p><strong>Migration Strategy Considerations</strong></p>\n<p>Real-world systems often need to support multiple password hashing approaches simultaneously during migration periods. Users&#39; passwords were hashed using different algorithms over the system&#39;s lifetime, and forcing all users to reset passwords during security upgrades creates poor user experience.</p>\n<p>An effective migration strategy identifies the hashing algorithm used for each password and upgrades to stronger algorithms opportunistically during successful login attempts. When a user authenticates successfully using an older, weaker hash, the system immediately rehashes their password using the current strongest algorithm and updates the stored hash.</p>\n<blockquote>\n<p><strong>Design Principle: Algorithm Agility</strong>\nSystems must support multiple hashing algorithms simultaneously and provide clear migration paths to stronger algorithms as cryptographic recommendations evolve.</p>\n</blockquote>\n<p>This comparison analysis drives our architectural decisions to implement multiple hashing approaches with clear upgrade paths, starting from educational implementations (salted SHA-256) and progressing to production-grade security (bcrypt and Argon2).</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>Understanding password storage vulnerabilities and threats provides the foundation for implementing secure hashing systems. This guidance bridges the conceptual understanding to practical implementation decisions.</p>\n<p><strong>A. Technology Recommendations</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Random Generation</td>\n<td><code>os.urandom()</code> / <code>secrets</code> module</td>\n<td>Hardware security module integration</td>\n</tr>\n<tr>\n<td>Hash Computation</td>\n<td><code>hashlib</code> standard library</td>\n<td>Cryptographic acceleration libraries</td>\n</tr>\n<tr>\n<td>Key Stretching</td>\n<td><code>hashlib.pbkdf2_hmac()</code> built-in</td>\n<td>Custom PBKDF2 with configurable PRF</td>\n</tr>\n<tr>\n<td>Modern Hashing</td>\n<td><code>bcrypt</code> library</td>\n<td><code>argon2-cffi</code> with memory tuning</td>\n</tr>\n<tr>\n<td>Constant-Time Comparison</td>\n<td><code>secrets.compare_digest()</code></td>\n<td>Custom implementation with timing analysis</td>\n</tr>\n<tr>\n<td>Storage Format</td>\n<td>JSON serialization</td>\n<td>Binary format with version headers</td>\n</tr>\n</tbody></table>\n<p><strong>B. Recommended File Structure</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>password-hashing/\n  src/\n    password_hash/\n      __init__.py              ← Public API exports\n      vulnerabilities.py       ← Demonstration of vulnerable approaches\n      threat_model.py          ← Attack simulation and testing\n      comparison.py            ← Algorithm comparison utilities\n    tests/\n      test_vulnerabilities.py  ← Tests demonstrating attack vectors\n      test_timing.py          ← Timing attack verification\n  examples/\n    vulnerable_examples.py     ← Educational examples of bad practices\n    secure_examples.py        ← Best practice demonstrations\n  docs/\n    vulnerability_analysis.md  ← Detailed attack documentation</code></pre></div>\n\n<p><strong>C. Infrastructure Starter Code</strong></p>\n<p><strong>Vulnerable Implementation Demonstrator</strong> (Complete working code for educational purposes):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">EDUCATIONAL ONLY - Demonstrates password storage vulnerabilities</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">DO NOT USE IN PRODUCTION - These implementations are intentionally insecure</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> VulnerablePasswordStorage</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Demonstrates common password storage vulnerabilities for educational analysis.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.users </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> store_plaintext</span><span style=\"color:#E1E4E8\">(self, username: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"VULNERABLE: Stores password in plain text - never do this.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.users[username] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'method'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'plaintext'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'password'</span><span style=\"color:#E1E4E8\">: password  </span><span style=\"color:#6A737D\"># Critical vulnerability - readable password</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> store_simple_hash</span><span style=\"color:#E1E4E8\">(self, username: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"VULNERABLE: Simple hash without salt - vulnerable to rainbow tables.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        password_hash </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hashlib.sha256(password.encode()).hexdigest()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.users[username] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'method'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'simple_hash'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'hash'</span><span style=\"color:#E1E4E8\">: password_hash  </span><span style=\"color:#6A737D\"># Vulnerable to precomputed attacks</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> store_predictable_salt</span><span style=\"color:#E1E4E8\">(self, username: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"VULNERABLE: Uses predictable salt - enables targeted attacks.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        salt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> username.encode()  </span><span style=\"color:#6A737D\"># Predictable salt based on username</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        salted </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> salt </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> password.encode()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        password_hash </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hashlib.sha256(salted).hexdigest()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.users[username] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'method'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'predictable_salt'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'salt'</span><span style=\"color:#E1E4E8\">: salt.hex(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'hash'</span><span style=\"color:#E1E4E8\">: password_hash</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify_with_timing_leak</span><span style=\"color:#E1E4E8\">(self, username: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"VULNERABLE: Timing attack via non-constant-time comparison.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> username </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.users:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        stored </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.users[username]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> stored[</span><span style=\"color:#9ECBFF\">'method'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'simple_hash'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            candidate_hash </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hashlib.sha256(password.encode()).hexdigest()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # VULNERABILITY: Character-by-character comparison leaks timing info</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._naive_string_compare(stored[</span><span style=\"color:#9ECBFF\">'hash'</span><span style=\"color:#E1E4E8\">], candidate_hash)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _naive_string_compare</span><span style=\"color:#E1E4E8\">(self, a: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, b: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"VULNERABLE: Returns immediately on first mismatch - enables timing attacks.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(a) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(b):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(a)):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> a[i] </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> b[i]:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> False</span><span style=\"color:#6A737D\">  # Early return leaks position of mismatch</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AttackSimulator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Simulates common attacks against password storage for educational purposes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> rainbow_table_attack</span><span style=\"color:#E1E4E8\">(hash_list: </span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Simulates rainbow table lookup for common passwords.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        common_passwords </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">'password'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'123456'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'password123'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'admin'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'letmein'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rainbow_table </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Build rainbow table for common passwords</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> pwd </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> common_passwords:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            hash_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hashlib.sha256(pwd.encode()).hexdigest()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            rainbow_table[hash_value] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> pwd</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Attempt to crack hashes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cracked </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> hash_val </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> hash_list:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> hash_val </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> rainbow_table:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                cracked[hash_val] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> rainbow_table[hash_val]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> cracked</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> timing_attack_demo</span><span style=\"color:#E1E4E8\">(storage: VulnerablePasswordStorage, username: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Demonstrates timing attack against non-constant-time comparison.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> username </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> storage.users:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">'error'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'User not found'</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timings </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        test_passwords </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">'a'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'ab'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'abc'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'abcd'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'abcde'</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># Progressively longer</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> pwd </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> test_passwords:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            storage.verify_with_timing_leak(username, pwd)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            end_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            timings[pwd] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> end_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> timings</span></span></code></pre></div>\n\n<p><strong>D. Core Logic Skeleton Code</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SecurePasswordAnalyzer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Analyze and demonstrate secure password storage principles.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> analyze_hash_strength</span><span style=\"color:#E1E4E8\">(self, password_hash: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                            salt: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, iterations: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Analyze the cryptographic strength of a password hash configuration.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            password_hash: The hash value to analyze</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            algorithm: Hash algorithm used ('md5', 'sha256', 'pbkdf2', 'bcrypt', 'argon2')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            salt: Salt value if used</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            iterations: Iteration count if applicable</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dictionary with strength analysis and recommendations</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate algorithm type and identify known vulnerabilities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check salt quality - length, randomness, uniqueness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Evaluate iteration count against current hardware capabilities</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Calculate estimated brute force time for different attack scenarios</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Provide specific recommendations for improvement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Generate security score (1-100) based on all factors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> simulate_attack_cost</span><span style=\"color:#E1E4E8\">(self, algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, iterations: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           hardware_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Calculate computational cost for brute force attacks.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            algorithm: Hash algorithm ('pbkdf2', 'bcrypt', 'argon2')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            iterations: Number of iterations/rounds</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            hardware_type: 'cpu', 'gpu', 'asic', 'quantum'</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Cost analysis with time estimates and hardware requirements</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Define hash rates for different algorithm/hardware combinations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Calculate hashes per second for given configuration  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Estimate time to crack passwords of different strengths</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Calculate monetary cost based on hardware and electricity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Factor in memory requirements for memory-hard algorithms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Provide timeline estimates (hours/days/months/years)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> compare_algorithms</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Compare multiple hashing algorithms applied to the same password.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            password: Test password to hash with different algorithms</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Comparison matrix showing security properties and performance</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate secure random salt for each algorithm test</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Hash password using MD5, SHA256, PBKDF2, bcrypt, Argon2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Measure computation time for each algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Calculate attack resistance estimates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Analyze storage requirements for each approach</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Create recommendation matrix for different use cases</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>E. Language-Specific Hints</strong></p>\n<ul>\n<li><strong>Secure Random Generation</strong>: Use <code>secrets.token_bytes(32)</code> for cryptographically secure salt generation, never <code>random.randint()</code></li>\n<li><strong>Hash Libraries</strong>: <code>hashlib</code> provides basic cryptographic hashes, <code>bcrypt</code> and <code>argon2-cffi</code> for advanced algorithms</li>\n<li><strong>Timing Attack Prevention</strong>: Always use <code>secrets.compare_digest()</code> for hash comparison - it runs in constant time</li>\n<li><strong>Memory Management</strong>: Clear password variables after use with <code>del password</code> to minimize plaintext exposure time</li>\n<li><strong>Error Handling</strong>: Never leak timing information through different error paths - authenticate() should take the same time whether user exists or not</li>\n</ul>\n<p><strong>F. Milestone Checkpoint</strong></p>\n<p>After implementing vulnerability demonstrations and attack simulations:</p>\n<p><strong>Test Command</strong>: <code>python -m pytest tests/test_vulnerabilities.py -v</code></p>\n<p><strong>Expected Behavior</strong>:</p>\n<ul>\n<li>Rainbow table attack should crack simple MD5/SHA256 hashes of common passwords within seconds</li>\n<li>Timing attack demonstration should show measurable time differences for wrong password lengths</li>\n<li>Salt analysis should correctly identify predictable vs random salts</li>\n<li>Attack cost calculator should provide realistic time estimates for different scenarios</li>\n</ul>\n<p><strong>Manual Verification</strong>:</p>\n<ol>\n<li>Run <code>python examples/vulnerable_examples.py</code> and observe that common passwords are cracked instantly</li>\n<li>Test timing attack demo - verify that longer incorrect passwords take slightly more time to reject</li>\n<li>Compare hash outputs - same password with different salts should produce completely different hashes</li>\n</ol>\n<p><strong>Signs of Problems</strong>:</p>\n<ul>\n<li><strong>All hashes look similar</strong>: Salt generation may not be truly random</li>\n<li><strong>Timing attack shows no difference</strong>: System timer resolution may be insufficient or comparison is already constant-time</li>\n<li><strong>Rainbow table attack fails</strong>: Password list may be too complex or hash format incorrect</li>\n</ul>\n<h2 id=\"goals-and-non-goals\">Goals and Non-Goals</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (foundational scope definition underlying the entire project)</p>\n</blockquote>\n<h3 id=\"mental-model-the-security-perimeter-analogy\">Mental Model: The Security Perimeter Analogy</h3>\n<p>Think of designing a password hashing system like building a secure vault. Your primary job is to protect the vault&#39;s contents (passwords) using sophisticated locking mechanisms (cryptographic hashing). However, you&#39;re not responsible for the entire bank building - you don&#39;t need to design the customer lobby (user interface), the teller windows (authentication workflows), or the alarm system monitoring (logging infrastructure). Your vault must have specific interfaces where other systems can interact with it, but your core responsibility is ensuring that even if someone breaks into the bank, they cannot extract usable passwords from your vault.</p>\n<p>This analogy helps clarify the boundaries of our password hashing system. We focus intensely on the cryptographic protection mechanisms while providing clean interfaces for integration with broader authentication systems.</p>\n<h3 id=\"core-goals\">Core Goals</h3>\n<p>The password hashing system must accomplish several critical security and usability objectives. These goals directly map to the three milestone progression, building from basic cryptographic primitives to production-ready password protection.</p>\n<table>\n<thead>\n<tr>\n<th>Goal Category</th>\n<th>Specific Objective</th>\n<th>Success Criteria</th>\n<th>Related Milestone</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cryptographic Security</td>\n<td>Prevent rainbow table attacks</td>\n<td>Generate cryptographically secure random salt of at least 16 bytes per password</td>\n<td>Milestone 1</td>\n</tr>\n<tr>\n<td>Cryptographic Security</td>\n<td>Resist brute force attacks</td>\n<td>Implement configurable key stretching with minimum 100,000 PBKDF2 iterations</td>\n<td>Milestone 2</td>\n</tr>\n<tr>\n<td>Cryptographic Security</td>\n<td>Use industry-standard algorithms</td>\n<td>Support bcrypt with configurable cost factor and optionally Argon2id</td>\n<td>Milestone 3</td>\n</tr>\n<tr>\n<td>Side-Channel Resistance</td>\n<td>Prevent timing attacks</td>\n<td>Implement constant-time password comparison preventing information leakage</td>\n<td>Milestone 2</td>\n</tr>\n<tr>\n<td>Algorithm Agility</td>\n<td>Support multiple hash algorithms</td>\n<td>Enable migration between SHA-256, PBKDF2, bcrypt, and Argon2 without breaking existing passwords</td>\n<td>Milestone 3</td>\n</tr>\n<tr>\n<td>Performance Tuning</td>\n<td>Balance security and usability</td>\n<td>Provide utilities to tune algorithm parameters based on target hardware performance</td>\n<td>Milestone 3</td>\n</tr>\n<tr>\n<td>Data Integrity</td>\n<td>Preserve algorithm parameters</td>\n<td>Store all necessary information (salt, iterations, algorithm identifier) for future verification</td>\n<td>All Milestones</td>\n</tr>\n<tr>\n<td>Integration Ready</td>\n<td>Clean API boundaries</td>\n<td>Provide simple register/verify interface that external systems can easily consume</td>\n<td>All Milestones</td>\n</tr>\n</tbody></table>\n<h4 id=\"security-goal-deep-dive\">Security Goal Deep Dive</h4>\n<p>The security objectives require careful consideration of threat models and attack vectors. <strong>Rainbow table prevention</strong> means that identical passwords must produce different stored hashes, achieved through unique salt generation using cryptographically secure random number generators. The system must generate salts with sufficient entropy - a minimum of 16 bytes provides 128 bits of randomness, making precomputed attacks computationally infeasible.</p>\n<p><strong>Brute force resistance</strong> requires making password verification computationally expensive for attackers while remaining reasonable for legitimate authentication. Key stretching algorithms like PBKDF2 achieve this by performing many iterations of cryptographic operations. The system must support configurable iteration counts, with a minimum of 100,000 PBKDF2-HMAC-SHA256 iterations to meet current security recommendations.</p>\n<p><strong>Side-channel attack prevention</strong> addresses subtle information leakage through execution timing differences. When comparing a provided password against a stored hash, the comparison operation must take the same amount of time regardless of where the passwords differ, preventing attackers from gradually discovering correct password characters through timing measurements.</p>\n<blockquote>\n<p><strong>Decision: Multi-Algorithm Support Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Password hashing recommendations evolve as computing power increases and new attacks are discovered</li>\n<li><strong>Options Considered</strong>: Single algorithm (simple but inflexible), plugin architecture (complex but extensible), built-in multi-algorithm support (moderate complexity, good flexibility)</li>\n<li><strong>Decision</strong>: Built-in support for SHA-256+salt, PBKDF2, bcrypt, and Argon2 with migration utilities</li>\n<li><strong>Rationale</strong>: Provides upgrade paths for deployed systems while keeping implementation complexity manageable for learning purposes</li>\n<li><strong>Consequences</strong>: Enables real-world deployment scenarios but requires careful parameter management and format parsing</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Algorithm Option</th>\n<th>Implementation Complexity</th>\n<th>Security Properties</th>\n<th>Adoption Timeline</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SHA-256 + Salt</td>\n<td>Low - basic cryptographic primitives</td>\n<td>Vulnerable to specialized hardware attacks</td>\n<td>Educational only</td>\n</tr>\n<tr>\n<td>PBKDF2</td>\n<td>Medium - requires iteration management</td>\n<td>Good general-purpose security</td>\n<td>Legacy systems</td>\n</tr>\n<tr>\n<td>bcrypt</td>\n<td>Low - well-tested library integration</td>\n<td>Excellent security with automatic salt</td>\n<td>Current standard</td>\n</tr>\n<tr>\n<td>Argon2id</td>\n<td>Medium - memory parameter tuning</td>\n<td>Best-in-class memory-hard function</td>\n<td>Future-proofing</td>\n</tr>\n</tbody></table>\n<h3 id=\"integration-goals\">Integration Goals</h3>\n<p>The password hashing system must integrate cleanly with external authentication systems without imposing architectural constraints on the consuming application. This requires well-defined interface boundaries and data formats.</p>\n<p><strong>API Simplicity</strong> means external systems should interact with the password hasher through two primary operations: <code>register_password(username, password) -&gt; stored_hash</code> and <code>verify_password(username, password, stored_hash) -&gt; boolean</code>. The complexity of salt generation, algorithm selection, and parameter tuning should be hidden behind these simple interfaces.</p>\n<p><strong>Format Compatibility</strong> requires that stored password hashes include all necessary metadata for future verification. The system must encode the algorithm identifier, parameters (iterations, cost factors, memory settings), salt, and hash result in a single string that can be stored in existing database schemas without requiring additional columns.</p>\n<p><strong>Migration Support</strong> acknowledges that password databases evolve over time. The system must detect legacy hash formats and provide upgrade paths, potentially re-hashing passwords with stronger algorithms during successful authentication attempts.</p>\n<h3 id=\"performance-goals\">Performance Goals</h3>\n<p>Performance objectives balance security requirements with user experience expectations. Authentication systems typically target sub-100ms response times for password verification, which constrains the computational complexity of hashing algorithms.</p>\n<table>\n<thead>\n<tr>\n<th>Performance Metric</th>\n<th>Target Value</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Verification Time</td>\n<td>50-200ms on modern CPU</td>\n<td>Fast enough for interactive login, slow enough to limit brute force</td>\n</tr>\n<tr>\n<td>Memory Usage</td>\n<td>&lt; 64MB per verification</td>\n<td>Reasonable for web applications, prevents memory exhaustion attacks</td>\n</tr>\n<tr>\n<td>Concurrent Verifications</td>\n<td>Support 100+ simultaneous</td>\n<td>Handles typical web application load patterns</td>\n</tr>\n<tr>\n<td>Parameter Tuning</td>\n<td>&lt; 1 second benchmark runs</td>\n<td>Enables administrators to configure optimal security/performance balance</td>\n</tr>\n</tbody></table>\n<p><strong>Adaptive Performance Tuning</strong> means the system should provide utilities to measure actual hashing performance on deployment hardware, recommending optimal parameters for bcrypt cost factors, Argon2 memory settings, and PBKDF2 iteration counts. This addresses the reality that security recommendations must adapt to hardware capabilities.</p>\n<h3 id=\"educational-goals\">Educational Goals</h3>\n<p>Since this project serves as a learning vehicle for cryptographic security concepts, the implementation must clearly demonstrate security principles and common vulnerabilities.</p>\n<p><strong>Vulnerability Demonstration</strong> requires implementing deliberately insecure approaches alongside secure ones, showing why plain text storage, simple hashing, and predictable salts are inadequate. The <code>VulnerablePasswordStorage</code> class demonstrates these anti-patterns with methods like <code>store_plaintext()</code>, <code>store_simple_hash()</code>, and <code>store_predictable_salt()</code>.</p>\n<p><strong>Attack Simulation</strong> capabilities help learners understand threat models through concrete examples. The <code>AttackSimulator</code> class provides methods like <code>rainbow_table_attack()</code> and <code>timing_attack_demo()</code> that demonstrate how these attacks work against vulnerable implementations.</p>\n<p><strong>Security Analysis Tools</strong> enable learners to evaluate the strength of different approaches. The <code>SecurePasswordAnalyzer</code> class offers methods like <code>analyze_hash_strength()</code> and <code>compare_algorithms()</code> that quantify security properties and attack costs.</p>\n<h3 id=\"explicit-non-goals\">Explicit Non-Goals</h3>\n<p>Defining what this system does NOT handle prevents scope creep and clarifies integration boundaries. These non-goals are equally important as the goals themselves.</p>\n<h4 id=\"authentication-system-non-goals\">Authentication System Non-Goals</h4>\n<p>The password hashing system explicitly does not implement broader authentication concerns:</p>\n<table>\n<thead>\n<tr>\n<th>Non-Goal Area</th>\n<th>Specific Exclusions</th>\n<th>Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Session Management</td>\n<td>Login sessions, tokens, cookies</td>\n<td>Separate concern with different security properties</td>\n</tr>\n<tr>\n<td>User Management</td>\n<td>User registration, profile storage, account lifecycle</td>\n<td>Database and business logic concerns outside cryptography scope</td>\n</tr>\n<tr>\n<td>Password Policy</td>\n<td>Strength validation, complexity requirements, history tracking</td>\n<td>Policy enforcement is application-specific</td>\n</tr>\n<tr>\n<td>Account Security</td>\n<td>Lockouts, rate limiting, breach detection</td>\n<td>Requires application-level state management</td>\n</tr>\n<tr>\n<td>Multi-Factor Authentication</td>\n<td>TOTP, SMS codes, hardware tokens</td>\n<td>Different cryptographic techniques and user experience flows</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>Permissions, roles, access control</td>\n<td>Separate security domain after authentication</td>\n</tr>\n</tbody></table>\n<h4 id=\"database-integration-non-goals\">Database Integration Non-Goals</h4>\n<p>While the system must produce data suitable for database storage, it does not handle database-specific concerns:</p>\n<p><strong>Schema Management</strong>: The system provides serialized hash strings but does not define database schemas, manage migrations, or handle indexing strategies. Applications must design appropriate user tables and password storage columns.</p>\n<p><strong>Connection Management</strong>: Database connectivity, connection pooling, transaction management, and error handling remain application responsibilities. The password hasher is a pure function that transforms inputs to outputs.</p>\n<p><strong>Query Optimization</strong>: While hash verification must be fast, optimizing database queries for user lookup, implementing caching strategies, or managing read replicas are application concerns.</p>\n<h4 id=\"deployment-and-operations-non-goals\">Deployment and Operations Non-Goals</h4>\n<p>Operational concerns remain outside the password hashing system scope:</p>\n<p><strong>Monitoring and Alerting</strong>: While the system may log security events, implementing comprehensive monitoring, alerting on suspicious activity, or integrating with SIEM systems are infrastructure concerns.</p>\n<p><strong>Configuration Management</strong>: The system accepts configuration parameters but does not handle configuration file parsing, environment variable management, or dynamic configuration updates.</p>\n<p><strong>Performance Monitoring</strong>: While the system provides tuning utilities, production performance monitoring, capacity planning, and auto-scaling decisions are operational responsibilities.</p>\n<h4 id=\"security-infrastructure-non-goals\">Security Infrastructure Non-Goals</h4>\n<p>Certain security concerns remain outside scope despite their relevance to password protection:</p>\n<p><strong>Breach Response</strong>: If a password database is compromised, coordinating user notifications, forced password resets, and forensic analysis are incident response activities beyond the hashing system&#39;s scope.</p>\n<p><strong>Compliance Reporting</strong>: While the system implements security best practices, generating compliance reports, audit trails, or regulatory documentation are governance concerns.</p>\n<p><strong>Network Security</strong>: Protecting passwords in transit through TLS, implementing certificate management, or preventing network-level attacks are transport layer responsibilities.</p>\n<h3 id=\"architecture-decision-scope-boundaries\">Architecture Decision: Scope Boundaries</h3>\n<blockquote>\n<p><strong>Decision: Minimal Core with Clean Integration Points</strong></p>\n<ul>\n<li><strong>Context</strong>: Balancing educational clarity with real-world applicability while preventing scope creep</li>\n<li><strong>Options Considered</strong>: Monolithic authentication system (too complex for learning), bare cryptographic primitives (insufficient for practical use), focused password hashing with integration interfaces (balanced approach)</li>\n<li><strong>Decision</strong>: Implement core password hashing functionality with well-defined interfaces for external integration</li>\n<li><strong>Rationale</strong>: Allows learners to focus on cryptographic concepts while producing components suitable for real applications</li>\n<li><strong>Consequences</strong>: Requires careful interface design but enables integration with diverse authentication architectures</li>\n</ul>\n</blockquote>\n<p>This scope decision directly influences the component architecture and testing strategy. By focusing intensely on password hashing while providing clean interfaces, learners can master cryptographic security concepts without getting overwhelmed by authentication system complexity.</p>\n<h3 id=\"success-metrics\">Success Metrics</h3>\n<p>The system&#39;s success will be measured through specific, testable criteria that align with both educational and practical objectives:</p>\n<table>\n<thead>\n<tr>\n<th>Success Category</th>\n<th>Measurement Criteria</th>\n<th>Verification Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Security Implementation</td>\n<td>All stored passwords use unique salts</td>\n<td>Automated test verifying no salt reuse across 1000+ passwords</td>\n</tr>\n<tr>\n<td>Security Implementation</td>\n<td>Timing attacks fail against verification</td>\n<td>Benchmark showing constant verification time regardless of password similarity</td>\n</tr>\n<tr>\n<td>Algorithm Support</td>\n<td>Multiple algorithms work correctly</td>\n<td>Test suite verifying SHA-256, PBKDF2, bcrypt, and Argon2 implementations</td>\n</tr>\n<tr>\n<td>Performance Tuning</td>\n<td>Parameters optimize for target hardware</td>\n<td>Utility that recommends cost factors achieving 100ms verification time</td>\n</tr>\n<tr>\n<td>Migration Support</td>\n<td>Legacy hashes upgrade transparently</td>\n<td>Test demonstrating seamless upgrade from PBKDF2 to bcrypt during authentication</td>\n</tr>\n<tr>\n<td>Educational Value</td>\n<td>Vulnerability demonstrations work</td>\n<td>Attack simulations successfully exploit insecure implementations</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-in-goal-definition\">Common Pitfalls in Goal Definition</h3>\n<p>⚠️ <strong>Pitfall: Scope Creep into Authentication Systems</strong>\nMany implementations attempt to solve broader authentication problems, creating unnecessary complexity. This occurs when developers think &quot;since I&#39;m handling passwords, I should also handle user sessions.&quot; This leads to mixing cryptographic logic with web application concerns, making the code harder to understand and test. Instead, maintain strict boundaries - the password hasher transforms passwords into secure storage formats and verifies them, nothing more.</p>\n<p>⚠️ <strong>Pitfall: Underestimating Performance Goals</strong>\nDevelopers often focus exclusively on security without considering performance implications, leading to authentication systems that timeout under load. Setting overly aggressive security parameters (like 1 million PBKDF2 iterations) can make systems unusable. Always benchmark on target hardware and consider concurrent load when setting algorithm parameters.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Migration Requirements</strong>\nInitial implementations often assume they&#39;ll use the same algorithm forever, creating no upgrade path for stronger algorithms. This leaves deployed systems stuck with weakening security over time. Always design hash formats to include algorithm identifiers and version information, enabling future upgrades.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cryptographic Library</td>\n<td>Python <code>hashlib</code> + <code>secrets</code></td>\n<td>Python <code>cryptography</code> package</td>\n</tr>\n<tr>\n<td>Random Generation</td>\n<td><code>secrets.token_bytes()</code> for salt</td>\n<td>Hardware RNG integration</td>\n</tr>\n<tr>\n<td>Algorithm Support</td>\n<td>Built-in <code>hashlib.pbkdf2_hmac()</code></td>\n<td><code>bcrypt</code> and <code>argon2</code> packages</td>\n</tr>\n<tr>\n<td>Performance Measurement</td>\n<td><code>time.time()</code> for basic benchmarks</td>\n<td><code>timeit</code> module for precise measurements</td>\n</tr>\n<tr>\n<td>Data Serialization</td>\n<td>Base64 encoding for hash storage</td>\n<td>Custom binary format with length prefixes</td>\n</tr>\n</tbody></table>\n<h4 id=\"project-structure-for-goals-implementation\">Project Structure for Goals Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">password_hashing</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  __init__</span><span style=\"color:#E1E4E8\">.py                    </span><span style=\"color:#6A737D\"># Main API exports</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  goals</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    __init__</span><span style=\"color:#E1E4E8\">.py</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    security_goals.py            </span><span style=\"color:#6A737D\"># Security objective verification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    performance_goals.py         </span><span style=\"color:#6A737D\"># Performance measurement utilities  </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    educational_goals.py         </span><span style=\"color:#6A737D\"># Vulnerability demonstrations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  core</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    __init__</span><span style=\"color:#E1E4E8\">.py</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hasher.py                   </span><span style=\"color:#6A737D\"># Main password hashing implementation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    vulnerabilities.py          </span><span style=\"color:#6A737D\"># Deliberately insecure implementations</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    analysis.py                 </span><span style=\"color:#6A737D\"># Security analysis tools</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  tests</span><span style=\"color:#F97583\">/</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    test_goals.py               </span><span style=\"color:#6A737D\"># Goal verification tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    test_security_properties.py </span><span style=\"color:#6A737D\"># Cryptographic property tests</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    test_performance.py         </span><span style=\"color:#6A737D\"># Performance benchmark tests</span></span></code></pre></div>\n\n<h4 id=\"goal-verification-starter-code\">Goal Verification Starter Code</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># password_hashing/goals/security_goals.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Security goal verification utilities.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> secrets</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.hasher </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SecurePasswordHasher</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.vulnerabilities </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> VulnerablePasswordStorage</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SecurityGoalVerifier</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Verifies that security objectives are met.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.secure_hasher </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SecurePasswordHasher()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.vulnerable_storage </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> VulnerablePasswordStorage()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify_salt_uniqueness</span><span style=\"color:#E1E4E8\">(self, password_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify that identical passwords produce unique hashes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            password_count: Number of identical passwords to hash</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dict with verification results and statistics</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Hash the same password multiple times using secure hasher</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract salt values from each hash result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify all salts are unique (no duplicates)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Calculate entropy statistics for salt randomness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return verification results with pass/fail status</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify_timing_attack_resistance</span><span style=\"color:#E1E4E8\">(self, username: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify that password verification takes constant time.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            username: Test username for timing measurements</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dict with timing analysis and resistance verification</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Store a test password hash for the username</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Measure verification time for correct password</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Measure verification time for incorrect passwords of various lengths</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Calculate timing variance across different inputs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Verify variance is below threshold indicating constant-time behavior</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"performance-goal-implementation\">Performance Goal Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># password_hashing/goals/performance_goals.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Performance goal measurement and tuning utilities.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.hasher </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SecurePasswordHasher</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PerformanceGoalTuner</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Measures and tunes password hashing performance.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.hasher </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SecurePasswordHasher()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.target_verification_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.1</span><span style=\"color:#6A737D\">  # 100ms target</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> benchmark_algorithm</span><span style=\"color:#E1E4E8\">(self, algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, test_password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"test123\"</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Benchmark hashing algorithm performance.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            algorithm: Algorithm name ('pbkdf2', 'bcrypt', 'argon2')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            test_password: Password to use for benchmarking</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dict with timing statistics and recommended parameters</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Configure algorithm with default parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Run multiple hash operations measuring execution time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate mean, median, and standard deviation of timing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Determine parameter adjustments to hit target timing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return timing statistics and recommended configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> tune_parameters_for_hardware</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Automatically tune algorithm parameters for current hardware.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dict mapping algorithm names to recommended parameters</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Benchmark each supported algorithm with default parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Adjust parameters (iterations, cost, memory) based on timing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify adjusted parameters still meet minimum security requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return recommended parameter configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"educational-goal-demonstrations\">Educational Goal Demonstrations</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># password_hashing/goals/educational_goals.py</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Educational demonstrations of security concepts.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..core.vulnerabilities </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> VulnerablePasswordStorage, AttackSimulator</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SecurityEducationDemos</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Demonstrates security concepts through working examples.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.vulnerable </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> VulnerablePasswordStorage()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.attacker </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> AttackSimulator()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> demonstrate_rainbow_table_attack</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">any</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Show how rainbow tables crack unsalted hashes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dict with attack results and educational insights</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create several user accounts with simple passwords using store_simple_hash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract the unsalted hashes from storage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Use AttackSimulator.rainbow_table_attack to crack hashes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Show which passwords were cracked and why</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Contrast with salted hash security</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> demonstrate_timing_attack</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">any</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Show how timing differences leak password information.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dict with attack results demonstrating information leakage</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Store a test password using vulnerable timing-leak verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Use AttackSimulator.timing_attack_demo to measure timing differences</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Show how timing varies based on password similarity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Demonstrate gradual password discovery through timing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Contrast with constant-time verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>Milestone 1 Checkpoint - Basic Security Goals:</strong></p>\n<ul>\n<li>Run <code>python -m pytest tests/test_goals.py::test_salt_uniqueness</code> - should verify 1000 identical passwords produce unique hashes</li>\n<li>Execute <code>python -c &quot;from password_hashing.goals.educational_goals import *; demo = SecurityEducationDemos(); print(demo.demonstrate_rainbow_table_attack())&quot;</code> - should show successful rainbow table attack against unsalted hashes</li>\n<li>Verify that <code>MINIMUM_SALT_LENGTH</code> constant is set to 16 bytes minimum</li>\n</ul>\n<p><strong>Milestone 2 Checkpoint - Performance and Timing Goals:</strong></p>\n<ul>\n<li>Run performance tuner: <code>python -c &quot;from password_hashing.goals.performance_goals import *; tuner = PerformanceGoalTuner(); print(tuner.benchmark_algorithm(&#39;pbkdf2&#39;))&quot;</code> - should complete within target timing</li>\n<li>Execute timing attack resistance test - should show constant verification time regardless of password differences</li>\n<li>Verify <code>PBKDF2_MIN_ITERATIONS</code> meets 100,000 minimum requirement</li>\n</ul>\n<p><strong>Milestone 3 Checkpoint - Algorithm Agility Goals:</strong></p>\n<ul>\n<li>Test algorithm migration: create password with PBKDF2, verify successful upgrade to bcrypt during authentication</li>\n<li>Benchmark all algorithms: <code>tuner.tune_parameters_for_hardware()</code> should return recommendations for bcrypt and Argon2</li>\n<li>Verify <code>BCRYPT_MIN_COST</code> meets security recommendations for current hardware</li>\n</ul>\n<h2 id=\"high-level-architecture\">High-Level Architecture</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (architectural foundation supporting all implementation phases)</p>\n</blockquote>\n<h3 id=\"mental-model-the-security-checkpoint-system-analogy\">Mental Model: The Security Checkpoint System Analogy</h3>\n<p>Think of a secure password hashing system like a multi-stage security checkpoint at a high-security facility. When someone presents their credentials (password), they don&#39;t just get waved through with a simple ID check. Instead, their identity verification goes through multiple specialized stations, each with a specific security purpose:</p>\n<ol>\n<li><strong>Salt Generation Station</strong> - Like issuing a unique, random visitor badge number that can&#39;t be predicted or reused, ensuring no two people get the same treatment even if they have the same name</li>\n<li><strong>Basic Hashing Station</strong> - Like taking a photograph that transforms the person&#39;s appearance into a standardized format that can&#39;t be reversed back to the original</li>\n<li><strong>Key Stretching Station</strong> - Like requiring the verification process to take a deliberately slow, resource-intensive amount of time to prevent someone from rapidly testing thousands of fake IDs</li>\n<li><strong>Modern Hashing Station</strong> - Like using the latest biometric scanners with adaptive security that automatically adjusts difficulty based on current threat levels</li>\n</ol>\n<p>Each station has specialized equipment and trained personnel who excel at their specific security function. The stations work together in sequence, but each can be upgraded independently as security threats evolve. Most importantly, even if an attacker somehow gets access to the verification records, they can&#39;t use them to impersonate legitimate visitors because the transformation process can&#39;t be reversed.</p>\n<p>This architectural approach provides <strong>defense in depth</strong> - multiple independent security barriers that an attacker must overcome, with each barrier specifically designed to defeat different attack methods like rainbow tables, brute force attempts, and timing analysis.</p>\n<h3 id=\"component-overview\">Component Overview</h3>\n<p>The password hashing system consists of four primary components that work together to transform user passwords into securely stored verification data. Each component has a focused responsibility and clear integration boundaries with the others.</p>\n<p><img src=\"/api/project/password-hashing/architecture-doc/asset?path=diagrams%2Fsystem-components.svg\" alt=\"Password Hashing System Components\"></p>\n<h4 id=\"core-components-and-responsibilities\">Core Components and Responsibilities</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Primary Responsibility</th>\n<th>Security Property</th>\n<th>Data Inputs</th>\n<th>Data Outputs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SaltGenerator</code></td>\n<td>Generate cryptographically secure random salts</td>\n<td>Prevents rainbow table attacks</td>\n<td>Entropy from OS random source</td>\n<td>Unique random byte sequences</td>\n</tr>\n<tr>\n<td><code>BasicHasher</code></td>\n<td>Apply SHA-256 hashing with salt concatenation</td>\n<td>Provides one-way transformation</td>\n<td>Password + salt</td>\n<td>SHA-256 digest</td>\n</tr>\n<tr>\n<td><code>KeyStretcher</code></td>\n<td>Apply PBKDF2 with configurable iterations</td>\n<td>Slows brute force attacks</td>\n<td>Password + salt + iteration count</td>\n<td>Derived key bytes</td>\n</tr>\n<tr>\n<td><code>ModernHasher</code></td>\n<td>Interface to bcrypt/Argon2 libraries</td>\n<td>Production-grade memory-hard hashing</td>\n<td>Password + algorithm parameters</td>\n<td>Algorithm-specific hash format</td>\n</tr>\n</tbody></table>\n<h4 id=\"component-dependencies-and-integration-boundaries\">Component Dependencies and Integration Boundaries</h4>\n<p>The components form a dependency hierarchy where later milestones build upon earlier ones, but each maintains clear integration boundaries:</p>\n<p><strong>SaltGenerator</strong> serves as the foundation component with no dependencies. It encapsulates all OS-specific entropy gathering and provides a consistent interface for secure random generation across different platforms. The component guarantees that every salt it produces has sufficient entropy and length to prevent rainbow table attacks.</p>\n<p><strong>BasicHasher</strong> depends on <code>SaltGenerator</code> for salt creation but implements its own hash computation logic. It handles the critical security requirement of salt concatenation order and provides constant-time comparison to prevent timing attacks. This component serves as the educational foundation for understanding core hashing concepts before moving to more sophisticated approaches.</p>\n<p><strong>KeyStretcher</strong> also depends on <code>SaltGenerator</code> and implements the PBKDF2 algorithm with HMAC-SHA256. It introduces the concept of configurable computational cost through iteration counts and demonstrates how to balance security against performance. This component bridges the gap between basic hashing and production-ready approaches.</p>\n<p><strong>ModernHasher</strong> represents the production-ready endpoint that integrates with established cryptographic libraries. It depends on <code>SaltGenerator</code> for consistency in salt handling but delegates the complex hashing logic to proven implementations like bcrypt and Argon2. This component emphasizes algorithm agility and migration planning.</p>\n<blockquote>\n<p><strong>Decision: Layered Component Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Password hashing involves multiple distinct security concerns (randomness, transformation, timing resistance, algorithm evolution) that beginners need to understand incrementally</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Monolithic component handling all hashing logic</li>\n<li>Layered components with milestone-based progression</li>\n<li>Plugin-based architecture with interchangeable algorithms</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Layered components with clear dependencies and milestone alignment</li>\n<li><strong>Rationale</strong>: Allows learners to build understanding progressively while maintaining clear separation of concerns. Each component can be tested independently and later components demonstrate evolution of security practices</li>\n<li><strong>Consequences</strong>: Enables incremental learning but requires careful interface design to prevent scope creep between components</li>\n</ul>\n</blockquote>\n<h4 id=\"data-flow-and-component-interactions\">Data Flow and Component Interactions</h4>\n<p>Password processing flows through the components in a predictable sequence, with each component adding a specific security transformation:</p>\n<ol>\n<li><strong>Registration Flow</strong>: <code>SaltGenerator</code> creates unique salt → <code>[Chosen Hasher]</code> combines password and salt → Result stored with algorithm metadata</li>\n<li><strong>Verification Flow</strong>: Stored hash retrieved with algorithm metadata → Same hasher recreates hash with provided password → Constant-time comparison determines match</li>\n</ol>\n<p>The architecture supports <strong>algorithm agility</strong> by allowing different hasher components to be selected based on stored metadata, enabling seamless migration from basic approaches to production-grade algorithms as learners progress through milestones.</p>\n<h4 id=\"common-integration-patterns\">Common Integration Patterns</h4>\n<table>\n<thead>\n<tr>\n<th>Integration Pattern</th>\n<th>Use Case</th>\n<th>Components Involved</th>\n<th>Benefits</th>\n<th>Trade-offs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Direct Component Chaining</td>\n<td>Educational progression through milestones</td>\n<td>All components in sequence</td>\n<td>Clear learning path, explicit dependencies</td>\n<td>More verbose integration code</td>\n</tr>\n<tr>\n<td>Factory Pattern</td>\n<td>Algorithm selection based on stored metadata</td>\n<td><code>ModernHasher</code> with algorithm-specific implementations</td>\n<td>Clean abstraction, easy algorithm switching</td>\n<td>Additional indirection complexity</td>\n</tr>\n<tr>\n<td>Strategy Pattern</td>\n<td>Runtime algorithm configuration</td>\n<td>All hasher components implementing common interface</td>\n<td>Flexible algorithm choice, consistent API</td>\n<td>Interface design complexity</td>\n</tr>\n</tbody></table>\n<h3 id=\"recommended-file-structure\">Recommended File Structure</h3>\n<p>The codebase organization reflects the component architecture and supports both educational progression and maintainable code structure. The file layout separates core components from educational demonstrations and provides clear module boundaries.</p>\n<h4 id=\"project-root-structure\">Project Root Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>password-hashing/\n├── README.md                          # Project overview and milestone roadmap\n├── requirements.txt                   # Python dependencies (bcrypt, argon2-cffi)\n├── main.py                           # CLI interface and usage examples\n├── config/\n│   └── security_settings.py         # Configurable security parameters\n├── src/\n│   ├── __init__.py\n│   ├── components/                   # Core hashing components\n│   │   ├── __init__.py\n│   │   ├── salt_generator.py         # Milestone 1: Secure random salt generation\n│   │   ├── basic_hasher.py          # Milestone 1: SHA-256 with salt\n│   │   ├── key_stretcher.py         # Milestone 2: PBKDF2 implementation\n│   │   └── modern_hasher.py         # Milestone 3: bcrypt/Argon2 integration\n│   ├── storage/                     # Hash storage and retrieval\n│   │   ├── __init__.py\n│   │   ├── hash_record.py           # Data models for stored hashes\n│   │   └── storage_manager.py       # Persistent storage interface\n│   ├── security/                    # Security analysis and verification\n│   │   ├── __init__.py\n│   │   ├── timing_safe.py           # Constant-time comparison utilities\n│   │   └── security_analyzer.py     # Hash strength analysis\n│   └── utils/                       # Common utilities\n│       ├── __init__.py\n│       ├── constants.py             # Security constants and minimums\n│       └── exceptions.py            # Custom exception types\n├── educational/                     # Educational demonstrations and attacks\n│   ├── __init__.py\n│   ├── vulnerable_storage.py        # Anti-patterns and vulnerability demos\n│   ├── attack_simulator.py          # Rainbow table and timing attack demos\n│   └── security_education.py       # Interactive security concept demonstrations\n├── tests/                          # Test suites organized by milestone\n│   ├── __init__.py\n│   ├── test_milestone1.py          # Basic hashing and salt tests\n│   ├── test_milestone2.py          # Key stretching and PBKDF2 tests\n│   ├── test_milestone3.py          # Modern hashing integration tests\n│   ├── security/\n│   │   ├── test_timing_attacks.py  # Timing attack resistance verification\n│   │   ├── test_salt_uniqueness.py # Salt randomness statistical tests\n│   │   └── test_performance.py     # Algorithm performance benchmarks\n│   └── integration/\n│       └── test_full_system.py     # End-to-end system integration tests\n└── docs/                          # Additional documentation\n    ├── milestones/                # Detailed milestone requirements\n    ├── security_analysis.md       # Security property verification\n    └── performance_tuning.md      # Algorithm parameter tuning guide</code></pre></div>\n\n<h4 id=\"component-module-design-rationale\">Component Module Design Rationale</h4>\n<blockquote>\n<p><strong>Decision: Component-Based Module Organization</strong></p>\n<ul>\n<li><strong>Context</strong>: Educational project needs to support incremental learning while maintaining professional code organization standards</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Single file with all hashing logic</li>\n<li>Separate files by algorithm (sha256.py, pbkdf2.py, bcrypt.py)</li>\n<li>Component-based organization matching architectural boundaries</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Component-based modules with clear milestone alignment</li>\n<li><strong>Rationale</strong>: Each component encapsulates a specific security responsibility and learning objective, making it easier to understand, test, and extend individual components</li>\n<li><strong>Consequences</strong>: Slightly more complex imports but much clearer separation of concerns and better support for incremental development</li>\n</ul>\n</blockquote>\n<h4 id=\"educational-structure-integration\">Educational Structure Integration</h4>\n<p>The <code>educational/</code> directory serves as a critical component for understanding security concepts through concrete examples. This separation ensures that demonstration code (including intentionally vulnerable implementations) doesn&#39;t accidentally get used in production while providing hands-on learning about security pitfalls.</p>\n<table>\n<thead>\n<tr>\n<th>Educational Module</th>\n<th>Learning Purpose</th>\n<th>Security Demonstrations</th>\n<th>Integration with Core Components</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>VulnerablePasswordStorage</code></td>\n<td>Show common security mistakes</td>\n<td>Plain text storage, unsalted hashes, predictable salts</td>\n<td>Contrasts with secure implementations</td>\n</tr>\n<tr>\n<td><code>AttackSimulator</code></td>\n<td>Demonstrate attack vectors</td>\n<td>Rainbow table lookups, timing attacks, brute force cost analysis</td>\n<td>Uses same interfaces as secure components for comparison</td>\n</tr>\n<tr>\n<td><code>SecurityEducationDemos</code></td>\n<td>Interactive security concept exploration</td>\n<td>Hash collision demonstrations, entropy visualization, algorithm comparison</td>\n<td>Leverages core components to show security properties</td>\n</tr>\n</tbody></table>\n<h4 id=\"testing-strategy-integration\">Testing Strategy Integration</h4>\n<p>The test organization supports both milestone-based development and comprehensive security verification:</p>\n<p><strong>Milestone Tests</strong> validate that each implementation phase meets its acceptance criteria and security requirements. These tests serve as automated checkpoints for learners to verify their implementations.</p>\n<p><strong>Security Tests</strong> go beyond functional correctness to verify cryptographic properties like timing attack resistance, salt uniqueness, and proper entropy utilization. These tests help learners understand how to validate security properties programmatically.</p>\n<p><strong>Integration Tests</strong> verify that components work together correctly and that the system maintains security properties when components are combined. This testing layer catches issues that might not appear when testing components in isolation.</p>\n<h4 id=\"file-organization-benefits-and-trade-offs\">File Organization Benefits and Trade-offs</h4>\n<table>\n<thead>\n<tr>\n<th>Organizational Decision</th>\n<th>Benefits</th>\n<th>Trade-offs</th>\n<th>Mitigation Strategies</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Separate component modules</td>\n<td>Clear responsibility boundaries, easier testing, supports incremental learning</td>\n<td>More import complexity, potential circular dependencies</td>\n<td>Careful interface design, dependency injection patterns</td>\n</tr>\n<tr>\n<td>Educational code separation</td>\n<td>Safe demonstration of vulnerabilities, clear contrast with secure approaches</td>\n<td>Duplication of some interfaces, maintenance overhead</td>\n<td>Shared interface definitions, automated consistency checks</td>\n</tr>\n<tr>\n<td>Milestone-aligned testing</td>\n<td>Clear progression checkpoints, targeted feedback for learners</td>\n<td>Test organization complexity, potential redundancy</td>\n<td>Test utilities for common patterns, clear test naming conventions</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-in-component-architecture\">Common Pitfalls in Component Architecture</h3>\n<p>⚠️ <strong>Pitfall: Circular Dependencies Between Components</strong>\nMany learners create circular dependencies by having <code>BasicHasher</code> import from <code>KeyStretcher</code> for &quot;shared utilities&quot; while <code>KeyStretcher</code> imports from <code>BasicHasher</code> for &quot;basic hashing operations.&quot; This breaks the clean milestone progression and makes testing difficult. Instead, extract shared utilities into the <code>utils/</code> package and maintain the clear dependency hierarchy: <code>SaltGenerator</code> → <code>BasicHasher</code> → <code>KeyStretcher</code> → <code>ModernHasher</code>.</p>\n<p>⚠️ <strong>Pitfall: Mixing Educational and Production Code</strong>\nLearners often put vulnerable demonstration code in the same modules as secure implementations, risking accidental use of insecure functions. The <code>educational/</code> directory separation prevents this by clearly marking demonstration code and ensuring it doesn&#39;t get imported into production paths.</p>\n<p>⚠️ <strong>Pitfall: Component Responsibility Creep</strong>\nA common mistake is having <code>SaltGenerator</code> also handle hash storage, or having <code>BasicHasher</code> implement its own salt generation. This violates separation of concerns and makes individual components harder to test and understand. Each component should have a single, well-defined responsibility aligned with its security purpose.</p>\n<p>⚠️ <strong>Pitfall: Inadequate Integration Boundaries</strong>\nWithout clear interfaces between components, learners often create tight coupling that prevents individual component testing and makes algorithm migration difficult. Define explicit interfaces for each component and use dependency injection to support testing and flexibility.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides concrete technical recommendations for implementing the component architecture in Python, including complete starter code for infrastructure components and detailed skeletons for the core learning components.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option (Milestone 1-2)</th>\n<th>Advanced Option (Milestone 3)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Random Generation</td>\n<td><code>os.urandom()</code> + <code>secrets</code> module</td>\n<td>Same (Python stdlib is sufficient)</td>\n</tr>\n<tr>\n<td>Basic Hashing</td>\n<td><code>hashlib.sha256()</code></td>\n<td>Same (part of learning objectives)</td>\n</tr>\n<tr>\n<td>Key Stretching</td>\n<td>Custom PBKDF2 with <code>hashlib.pbkdf2_hmac()</code></td>\n<td>Same (educational implementation)</td>\n</tr>\n<tr>\n<td>Modern Hashing</td>\n<td><code>bcrypt</code> library</td>\n<td><code>bcrypt</code> + <code>argon2-cffi</code> libraries</td>\n</tr>\n<tr>\n<td>Storage Format</td>\n<td>JSON with base64 encoding</td>\n<td>Same (human-readable for debugging)</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td><code>unittest</code> (stdlib)</td>\n<td><code>pytest</code> with security-specific assertions</td>\n</tr>\n</tbody></table>\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>File: <code>src/utils/constants.py</code></strong> (Complete implementation - copy and use)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Security constants and minimum recommended values.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">These values reflect current best practices as of 2024.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Salt generation requirements</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MINIMUM_SALT_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#6A737D\">  # bytes - cryptographic security requirement</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">RECOMMENDED_SALT_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#6A737D\">  # bytes - provides extra security margin</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Key stretching minimum requirements  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">PBKDF2_MIN_ITERATIONS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#6A737D\">  # OWASP 2024 recommendation for PBKDF2-HMAC-SHA256</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">PBKDF2_RECOMMENDED_ITERATIONS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 600000</span><span style=\"color:#6A737D\">  # Higher security margin</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Modern hashing algorithm parameters</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">BCRYPT_MIN_COST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#6A737D\">  # 2^12 = 4096 iterations minimum</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">BCRYPT_RECOMMENDED_COST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 14</span><span style=\"color:#6A737D\">  # 2^14 = 16384 iterations for better security</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Argon2 parameters (if implementing milestone 3 advanced option)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ARGON2_TIME_COST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 3</span><span style=\"color:#6A737D\">  # iterations</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ARGON2_MEMORY_COST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 65536</span><span style=\"color:#6A737D\">  # 64 MB memory usage  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ARGON2_PARALLELISM</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#6A737D\">  # single thread for simplicity</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Hash output format constants</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">HASH_RECORD_VERSION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"1.0\"</span><span style=\"color:#6A737D\">  # for future algorithm migration support</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">SUPPORTED_ALGORITHMS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">\"sha256\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"pbkdf2\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"bcrypt\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"argon2id\"</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Security verification constants</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">TIMING_ATTACK_TEST_SAMPLES</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#6A737D\">  # statistical samples for timing analysis</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MIN_HASH_COMPUTATION_TIME_MS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 250</span><span style=\"color:#6A737D\">  # minimum acceptable hash time for security</span></span></code></pre></div>\n\n<p><strong>File: <code>src/utils/exceptions.py</code></strong> (Complete implementation - copy and use)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Custom exception types for password hashing operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides specific error handling for different failure modes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PasswordHashingError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for all password hashing operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SaltGenerationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PasswordHashingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when cryptographically secure salt generation fails.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HashComputationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PasswordHashingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when hash computation encounters an error.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AlgorithmNotSupportedError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PasswordHashingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when requested hashing algorithm is not available.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, algorithm_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, supported_algorithms: </span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.algorithm_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> algorithm_name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.supported_algorithms </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> supported_algorithms</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Algorithm '</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">algorithm_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">' not supported. \"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        f</span><span style=\"color:#9ECBFF\">\"Available: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#9ECBFF\">', '</span><span style=\"color:#E1E4E8\">.join(supported_algorithms)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InvalidHashFormatError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PasswordHashingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when stored hash format cannot be parsed.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TimingAttackVulnerabilityError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PasswordHashingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when timing attack vulnerability is detected during testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>File: <code>src/security/timing_safe.py</code></strong> (Complete implementation - copy and use)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Timing-safe comparison utilities to prevent timing attack vulnerabilities.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">These functions ensure constant execution time regardless of input differences.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hmac</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Union</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> constant_time_compare</span><span style=\"color:#E1E4E8\">(a: Union[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">], b: Union[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Compare two values in constant time to prevent timing attacks.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Uses HMAC's constant-time comparison internally, which is implemented</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    to take the same amount of time regardless of where the first difference</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    appears in the compared values.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        a: First value to compare (string or bytes)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        b: Second value to compare (string or bytes)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        True if values are equal, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Security Note:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        This function takes the same time to execute whether the values</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        match completely, differ in the first byte, or differ in the last byte.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Convert strings to bytes for consistent comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(a, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        a </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> a.encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(b, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b.encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # hmac.compare_digest provides cryptographically secure constant-time comparison</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> hmac.compare_digest(a, b)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> verify_timing_safety</span><span style=\"color:#E1E4E8\">(comparison_func, test_cases: </span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">, tolerance_ms: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5.0</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Statistical test to verify that a comparison function has constant timing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Tests the comparison function with various inputs and measures execution time</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    to detect potential timing attack vulnerabilities.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        comparison_func: Function to test for timing safety</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        test_cases: List of (input1, input2, expected_result) tuples</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        tolerance_ms: Maximum acceptable timing variance in milliseconds</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        dict with timing analysis results and vulnerability assessment</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> statistics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timing_results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> input1, input2, expected </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> test_cases:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> comparison_func(input1, input2)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        end_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        execution_time_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (end_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timing_results.append({</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'inputs'</span><span style=\"color:#E1E4E8\">: (input1, input2),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'expected'</span><span style=\"color:#E1E4E8\">: expected,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'actual'</span><span style=\"color:#E1E4E8\">: result,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'time_ms'</span><span style=\"color:#E1E4E8\">: execution_time_ms,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'correct'</span><span style=\"color:#E1E4E8\">: result </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> expected</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        })</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Statistical analysis of timing variance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    times </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [r[</span><span style=\"color:#9ECBFF\">'time_ms'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> r </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> timing_results]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mean_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> statistics.mean(times)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    std_dev </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> statistics.stdev(times) </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(times) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> else</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_variance </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> max</span><span style=\"color:#E1E4E8\">(times) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> min</span><span style=\"color:#E1E4E8\">(times)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_timing_safe </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> max_variance </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> tolerance_ms</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'is_timing_safe'</span><span style=\"color:#E1E4E8\">: is_timing_safe,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'mean_time_ms'</span><span style=\"color:#E1E4E8\">: mean_time,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'std_deviation_ms'</span><span style=\"color:#E1E4E8\">: std_dev,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'max_variance_ms'</span><span style=\"color:#E1E4E8\">: max_variance,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'tolerance_ms'</span><span style=\"color:#E1E4E8\">: tolerance_ms,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'sample_count'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(timing_results),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'detailed_results'</span><span style=\"color:#E1E4E8\">: timing_results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span></code></pre></div>\n\n<h4 id=\"core-component-skeletons\">Core Component Skeletons</h4>\n<p><strong>File: <code>src/components/salt_generator.py</code></strong> (Skeleton - implement the TODOs)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Cryptographically secure salt generation for password hashing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Milestone 1: Provides foundation for all subsequent hashing operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> secrets</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..utils.constants </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> MINIMUM_SALT_LENGTH</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">RECOMMENDED_SALT_LENGTH</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..utils.exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SaltGenerationError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SaltGenerator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Generates cryptographically secure random salts for password hashing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Ensures each password gets a unique salt to prevent rainbow table attacks</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    and provides sufficient entropy for cryptographic security.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, default_length: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> RECOMMENDED_SALT_LENGTH</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Initialize salt generator with configurable default length.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            default_length: Default salt length in bytes (minimum 16)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate that default_length meets MINIMUM_SALT_LENGTH requirement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Store default_length as instance variable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify that OS provides cryptographically secure randomness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Check that os.urandom and secrets module are available</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_salt</span><span style=\"color:#E1E4E8\">(self, length: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Generate a cryptographically secure random salt.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            length: Salt length in bytes (uses default if None)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Random salt bytes suitable for cryptographic use</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            SaltGenerationError: If secure random generation fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Use provided length or fall back to default_length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate length meets MINIMUM_SALT_LENGTH requirement  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Generate random bytes using os.urandom() for cryptographic security</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Handle potential OS errors and raise SaltGenerationError with context</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return the generated salt bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: os.urandom() can raise OSError if entropy is insufficient</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_salt_hex</span><span style=\"color:#E1E4E8\">(self, length: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Generate salt and return as hexadecimal string for easy storage.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            length: Salt length in bytes (uses default if None)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Salt encoded as lowercase hexadecimal string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Call generate_salt() to get raw bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Convert bytes to hexadecimal string using .hex() method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return hex string (will be 2x length due to hex encoding)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_salt</span><span style=\"color:#E1E4E8\">(self, salt: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Validate that provided salt meets security requirements.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            salt: Salt bytes to validate</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if salt meets security requirements, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check that salt is bytes type (not string)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Verify salt length meets MINIMUM_SALT_LENGTH</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Return True if valid, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Note: We can't verify randomness, only length and type</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>File: <code>src/components/basic_hasher.py</code></strong> (Skeleton - implement the TODOs)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Basic password hashing with SHA-256 and salt.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Milestone 1: Foundation for understanding salted password hashing concepts.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .salt_generator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SaltGenerator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..security.timing_safe </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> constant_time_compare</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..utils.exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> HashComputationError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BasicHasher</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Implements salted password hashing using SHA-256.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Provides educational foundation for password hashing concepts including</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    salt concatenation, one-way transformation, and timing-safe verification.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, salt_generator: SaltGenerator):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Initialize hasher with salt generation capability.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            salt_generator: SaltGenerator instance for creating salts</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Store salt_generator as instance variable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Set algorithm identifier for hash record metadata</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.algorithm </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"sha256\"</span><span style=\"color:#6A737D\">  # Algorithm identifier for storage</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> hash_password</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, salt: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Hash password with salt using SHA-256.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            password: Plain text password to hash</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            salt: Optional salt bytes (generates new salt if None)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dictionary containing salt, hash, and algorithm metadata</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            HashComputationError: If hashing operation fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate new salt if none provided using self.salt_generator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Convert password string to UTF-8 bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Concatenate salt + password bytes (salt first for consistency)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create SHA-256 hash object and update with concatenated data</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Get final hash digest as bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return dictionary with salt, hash, algorithm, and any metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Hint: Use hashlib.sha256() and .digest() method</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Hint: Dictionary should include 'salt', 'hash', 'algorithm' keys</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> HashComputationError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"SHA-256 hash computation failed: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify_password</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, hash_record: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Verify password against stored hash using timing-safe comparison.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            password: Plain text password to verify</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            hash_record: Stored hash record from hash_password()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if password matches, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract salt from hash_record dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Re-hash the provided password with stored salt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Extract stored hash from hash_record</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Compare computed hash with stored hash using constant_time_compare</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return comparison result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Hint: Call self.hash_password(password, salt) to recompute hash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Hint: Use constant_time_compare to prevent timing attacks</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Security: Always return False for any verification errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # This prevents information leakage about hash storage format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_algorithm_info</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Get information about this hashing algorithm.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dictionary with algorithm metadata and security properties</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Return dictionary with algorithm name, security properties</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Include information about salt length, hash output size</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Include security notes about this algorithm's limitations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: SHA-256 output is always 32 bytes (256 bits)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint-basic-hashing-implementation\">Milestone Checkpoint: Basic Hashing Implementation</h4>\n<p>After implementing <code>SaltGenerator</code> and <code>BasicHasher</code>, verify your implementation with this checkpoint:</p>\n<p><strong>Test Command:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_milestone1.py</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p><strong>Manual Verification Script:</strong> Create <code>test_basic_implementation.py</code>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.components.salt_generator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SaltGenerator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.components.basic_hasher </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BasicHasher</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test salt generation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">salt_gen </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> SaltGenerator()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">salt1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> salt_gen.generate_salt()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">salt2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> salt_gen.generate_salt()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Salt 1: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">salt1.hex()[:</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">... (length: </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(salt1)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> bytes)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Salt 2: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">salt2.hex()[:</span><span style=\"color:#79B8FF\">16</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">... (length: </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(salt2)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> bytes)\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Salts are unique: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">salt1 </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> salt2</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test basic hashing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">hasher </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BasicHasher(salt_gen)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">password </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"test_password_123\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">hash_record </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hasher.hash_password(password)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Hash algorithm: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">hash_record[</span><span style=\"color:#9ECBFF\">'algorithm'</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Hash length: </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(hash_record[</span><span style=\"color:#9ECBFF\">'hash'</span><span style=\"color:#E1E4E8\">])</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test verification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">verify_correct </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hasher.verify_password(password, hash_record)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">verify_wrong </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hasher.verify_password(</span><span style=\"color:#9ECBFF\">\"wrong_password\"</span><span style=\"color:#E1E4E8\">, hash_record)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Correct password verification: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">verify_correct</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Wrong password verification: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">verify_wrong</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p><strong>Expected Output:</strong></p>\n<ul>\n<li>Salt 1 and Salt 2 should be different hex strings, each 64 characters long (32 bytes)</li>\n<li>Hash algorithm should be &quot;sha256&quot;</li>\n<li>Hash length should be 32 bytes</li>\n<li>Correct password verification should return <code>True</code></li>\n<li>Wrong password verification should return <code>False</code></li>\n</ul>\n<p><strong>Common Issues and Debugging:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>SaltGenerationError</code> on startup</td>\n<td>OS entropy insufficient</td>\n<td>Check that <code>/dev/urandom</code> exists (Linux/Mac) or CryptGenRandom available (Windows)</td>\n</tr>\n<tr>\n<td>Same salt generated twice</td>\n<td>Using <code>random</code> instead of <code>secrets</code></td>\n<td>Use <code>os.urandom()</code> or <code>secrets.token_bytes()</code></td>\n</tr>\n<tr>\n<td>Hash verification always fails</td>\n<td>Salt concatenation order mismatch</td>\n<td>Ensure same order (salt + password) in both hash and verify</td>\n</tr>\n<tr>\n<td>Timing attack vulnerability detected</td>\n<td>Using <code>==</code> for hash comparison</td>\n<td>Use <code>constant_time_compare()</code> function</td>\n</tr>\n</tbody></table>\n<h2 id=\"data-model\">Data Model</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (data structures evolve across implementation phases)</p>\n</blockquote>\n<h3 id=\"mental-model-the-medical-chart-system-analogy\">Mental Model: The Medical Chart System Analogy</h3>\n<p>Think of a password hash record like a patient&#39;s medical chart at a hospital. Just as each patient has a comprehensive medical record containing their identification, medical history, current medications, dosage instructions, and treatment protocols, each password requires a complete record containing the original salt, the computed hash, the algorithm used, and all the parameters needed to recreate the same result during verification.</p>\n<p>The medical chart analogy extends further: just as different doctors might use different treatment protocols (some prefer newer medications, others stick with proven classics), our password system must support multiple hashing algorithms. A patient&#39;s chart includes not just what medication they&#39;re taking, but the exact dosage, frequency, and administration method. Similarly, our password hash record must capture not just which algorithm was used, but the exact iteration counts, memory parameters, and salt lengths required to reproduce the hash.</p>\n<p>Most importantly, just as a medical chart must be completely self-contained (a doctor in the emergency room must be able to understand a patient&#39;s entire treatment history from the chart alone), our password hash record must contain everything needed for verification. We cannot rely on external configuration files or global settings that might change over time.</p>\n<h3 id=\"password-hash-record\">Password Hash Record</h3>\n<p>The <code>PasswordHashRecord</code> serves as the authoritative data structure containing all information necessary to verify a password against its stored representation. This structure embodies the principle of <strong>self-contained verification</strong> - every piece of information needed to recreate the hash and perform comparison must be preserved within the record itself.</p>\n<p><img src=\"/api/project/password-hashing/architecture-doc/asset?path=diagrams%2Fdata-model.svg\" alt=\"Password Hash Data Model\"></p>\n<p>The design challenge lies in creating a format that can accommodate multiple hashing algorithms while maintaining forward and backward compatibility. As our system evolves from basic SHA-256 hashing in Milestone 1 through PBKDF2 in Milestone 2 to bcrypt and Argon2 in Milestone 3, the data model must gracefully handle this progression without breaking existing stored passwords.</p>\n<blockquote>\n<p><strong>Decision: Unified Hash Record Structure</strong></p>\n<ul>\n<li><strong>Context</strong>: Multiple hashing algorithms require different parameters (iterations for PBKDF2, cost factors for bcrypt, memory parameters for Argon2), but we need a single storage format</li>\n<li><strong>Options Considered</strong>: Separate record types per algorithm, JSON blob for parameters, fixed fields for all possible parameters</li>\n<li><strong>Decision</strong>: Single record type with algorithm identifier and flexible parameter dictionary</li>\n<li><strong>Rationale</strong>: Enables algorithm agility and future algorithm addition without schema changes, while maintaining type safety for critical fields like salt and hash</li>\n<li><strong>Consequences</strong>: Slightly more complex parsing logic, but enables seamless algorithm migration and future-proofing</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Field Name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>algorithm</code></td>\n<td>string</td>\n<td>Algorithm identifier (e.g., &quot;sha256&quot;, &quot;pbkdf2-sha256&quot;, &quot;bcrypt&quot;, &quot;argon2id&quot;)</td>\n</tr>\n<tr>\n<td><code>salt</code></td>\n<td>bytes</td>\n<td>Cryptographically random salt of at least <code>MINIMUM_SALT_LENGTH</code> bytes</td>\n</tr>\n<tr>\n<td><code>hash</code></td>\n<td>bytes</td>\n<td>The computed password hash output</td>\n</tr>\n<tr>\n<td><code>parameters</code></td>\n<td>dict</td>\n<td>Algorithm-specific parameters (iterations, cost factors, memory limits)</td>\n</tr>\n<tr>\n<td><code>version</code></td>\n<td>int</td>\n<td>Schema version for future compatibility and migration support</td>\n</tr>\n<tr>\n<td><code>created_at</code></td>\n<td>timestamp</td>\n<td>When this hash was created (for algorithm upgrade scheduling)</td>\n</tr>\n</tbody></table>\n<p>The <code>salt</code> field represents the cryptographically secure random value that prevents rainbow table attacks. Its length must meet or exceed <code>MINIMUM_SALT_LENGTH</code> (16 bytes) for cryptographic security, though <code>RECOMMENDED_SALT_LENGTH</code> (32 bytes) provides additional security margin. The salt remains constant for the lifetime of the password - it is generated once during initial hashing and reused during every verification.</p>\n<p>The <code>hash</code> field contains the final output of the hashing algorithm. For SHA-256, this will be exactly 32 bytes. For PBKDF2, the length is configurable but typically 32 bytes. For bcrypt, the output includes algorithm metadata and is variable length. For Argon2, the output length is configurable based on security requirements.</p>\n<p>The <code>parameters</code> dictionary provides algorithm-specific configuration without requiring schema changes as new algorithms are added. This flexibility enables the system to evolve while maintaining compatibility with existing stored hashes.</p>\n<blockquote>\n<p>The critical insight here is that password hash records must be <strong>immutable archives</strong> - once created, they preserve exactly the algorithm and parameters that were current at the time of creation, enabling verification years later even as the system&#39;s default algorithms evolve.</p>\n</blockquote>\n<h4 id=\"parameter-storage-by-algorithm\">Parameter Storage by Algorithm</h4>\n<p>Different hashing algorithms require distinct parameter sets, all stored within the unified <code>parameters</code> dictionary:</p>\n<table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Required Parameters</th>\n<th>Optional Parameters</th>\n<th>Example Values</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>sha256</code></td>\n<td>None</td>\n<td>None</td>\n<td><code>{}</code></td>\n</tr>\n<tr>\n<td><code>pbkdf2-sha256</code></td>\n<td><code>iterations</code></td>\n<td><code>derived_key_length</code></td>\n<td><code>{&quot;iterations&quot;: 100000, &quot;derived_key_length&quot;: 32}</code></td>\n</tr>\n<tr>\n<td><code>bcrypt</code></td>\n<td><code>cost</code></td>\n<td>None</td>\n<td><code>{&quot;cost&quot;: 12}</code></td>\n</tr>\n<tr>\n<td><code>argon2id</code></td>\n<td><code>memory_cost</code>, <code>time_cost</code>, <code>parallelism</code></td>\n<td><code>hash_length</code></td>\n<td><code>{&quot;memory_cost&quot;: 65536, &quot;time_cost&quot;: 3, &quot;parallelism&quot;: 4, &quot;hash_length&quot;: 32}</code></td>\n</tr>\n</tbody></table>\n<p>The <code>version</code> field enables schema evolution without breaking compatibility. Version 1 represents the initial implementation supporting basic algorithms. Future versions might add fields for password policy compliance, breach detection results, or enhanced security metadata.</p>\n<p>The <code>created_at</code> timestamp serves multiple purposes: it enables gradual migration from weaker to stronger algorithms, supports compliance requirements that mandate password age tracking, and provides forensic information for security incident analysis.</p>\n<h4 id=\"hash-record-serialization-formats\">Hash Record Serialization Formats</h4>\n<p>The password hash record must be serialized for storage in databases, files, or other persistent storage systems. The design supports multiple serialization formats depending on deployment requirements:</p>\n<blockquote>\n<p><strong>Decision: Primary Serialization Format</strong></p>\n<ul>\n<li><strong>Context</strong>: Hash records need persistent storage across different database systems and file formats</li>\n<li><strong>Options Considered</strong>: Binary format for compactness, JSON for human readability, custom string format for simplicity</li>\n<li><strong>Decision</strong>: JSON as primary format with optional binary encoding for performance-critical applications</li>\n<li><strong>Rationale</strong>: JSON provides human readability for debugging, universal parsing support, and natural handling of the flexible parameters dictionary</li>\n<li><strong>Consequences</strong>: Slightly larger storage footprint than binary, but significantly improved maintainability and debugging capability</li>\n</ul>\n</blockquote>\n<p><strong>JSON Format Example:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">json</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"algorithm\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"pbkdf2-sha256\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"salt\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"base64-encoded-salt-bytes\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"hash\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"base64-encoded-hash-bytes\"</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"parameters\"</span><span style=\"color:#E1E4E8\">: {</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"iterations\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    \"derived_key_length\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">32</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"version\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">  \"created_at\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"2024-01-15T10:30:00Z\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span></code></pre></div>\n\n<p><strong>String Format for Simple Storage:</strong>\nFor applications requiring single-string storage (like database varchar columns), the system supports a compact encoding format:\n<code>algorithm$version$base64-salt$base64-hash$base64-parameters</code></p>\n<p>This format enables storage in systems with limited schema flexibility while preserving all necessary information for verification.</p>\n<h3 id=\"algorithm-parameters\">Algorithm Parameters</h3>\n<p>The <code>AlgorithmParameters</code> structure defines the configuration settings that control the behavior and security properties of each hashing algorithm. These parameters directly impact the trade-off between security and performance - higher parameter values increase resistance to brute force attacks but require more computational resources for legitimate verification.</p>\n<p>The fundamental principle underlying parameter selection is <strong>adaptive security tuning</strong> - the ability to adjust security levels based on current hardware capabilities and threat landscape changes. What represents strong security today may become weak as computing power advances, requiring parameter upgrades over time.</p>\n<table>\n<thead>\n<tr>\n<th>Parameter Category</th>\n<th>Purpose</th>\n<th>Security Impact</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Iteration Counts</td>\n<td>Increase computation time</td>\n<td>Higher = more brute force resistance</td>\n<td>Higher = slower legitimate verification</td>\n</tr>\n<tr>\n<td>Memory Requirements</td>\n<td>Force memory usage</td>\n<td>Higher = specialized hardware resistance</td>\n<td>Higher = more RAM consumption</td>\n</tr>\n<tr>\n<td>Parallelism Factors</td>\n<td>Control thread usage</td>\n<td>Tuned for defender hardware</td>\n<td>Must match deployment environment</td>\n</tr>\n<tr>\n<td>Output Lengths</td>\n<td>Control hash size</td>\n<td>Longer = more collision resistance</td>\n<td>Minimal impact</td>\n</tr>\n</tbody></table>\n<h4 id=\"algorithm-specific-parameter-structures\">Algorithm-Specific Parameter Structures</h4>\n<p>Each hashing algorithm requires a distinct parameter configuration that captures its unique security and performance characteristics:</p>\n<p><strong>SHA-256 Parameters (Milestone 1):</strong></p>\n<table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Type</th>\n<th>Default Value</th>\n<th>Security Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>salt_length</code></td>\n<td>int</td>\n<td><code>RECOMMENDED_SALT_LENGTH</code> (32)</td>\n<td>Longer salts provide stronger rainbow table protection</td>\n</tr>\n</tbody></table>\n<p>The simplicity of SHA-256 parameters reflects its role as a foundational building block rather than a complete password hashing solution. SHA-256 alone, even with salting, provides insufficient protection against modern brute force attacks due to its computational speed.</p>\n<p><strong>PBKDF2 Parameters (Milestone 2):</strong></p>\n<table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Type</th>\n<th>Default Value</th>\n<th>Valid Range</th>\n<th>Security Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>iterations</code></td>\n<td>int</td>\n<td><code>PBKDF2_MIN_ITERATIONS</code> (100,000)</td>\n<td>100,000+</td>\n<td>Each iteration requires full HMAC computation, multiplying brute force cost</td>\n</tr>\n<tr>\n<td><code>derived_key_length</code></td>\n<td>int</td>\n<td>32</td>\n<td>16-128</td>\n<td>Longer keys provide more entropy and collision resistance</td>\n</tr>\n<tr>\n<td><code>hash_function</code></td>\n<td>string</td>\n<td>&quot;sha256&quot;</td>\n<td>sha256, sha512</td>\n<td>SHA-256 balances security and performance for most applications</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: PBKDF2 Iteration Count Defaults</strong></p>\n<ul>\n<li><strong>Context</strong>: Iteration count directly controls security vs performance trade-off, but optimal values change as hardware improves</li>\n<li><strong>Options Considered</strong>: Fixed high count (500K+), adaptive based on hardware benchmarking, conservative minimum with manual tuning</li>\n<li><strong>Decision</strong>: Conservative minimum (100K) with benchmarking utilities to guide tuning</li>\n<li><strong>Rationale</strong>: Provides baseline security while enabling applications to tune for their specific hardware and security requirements</li>\n<li><strong>Consequences</strong>: Applications must actively tune parameters rather than relying entirely on defaults, but this encourages security-conscious configuration</li>\n</ul>\n</blockquote>\n<p><strong>bcrypt Parameters (Milestone 3):</strong></p>\n<table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Type</th>\n<th>Default Value</th>\n<th>Valid Range</th>\n<th>Security Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>cost</code></td>\n<td>int</td>\n<td><code>BCRYPT_MIN_COST</code> (12)</td>\n<td>10-15</td>\n<td>Cost factor is logarithmic - each increment doubles computation time</td>\n</tr>\n<tr>\n<td><code>salt_length</code></td>\n<td>int</td>\n<td>16</td>\n<td>16 (fixed)</td>\n<td>bcrypt internally generates and manages 16-byte salts</td>\n</tr>\n</tbody></table>\n<p>The bcrypt cost parameter represents a logarithmic scale where cost N requires 2^N iterations internally. This design enables fine-grained security tuning while maintaining reasonable parameter values (12 instead of 4096).</p>\n<p><strong>Argon2id Parameters (Milestone 3):</strong></p>\n<table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Type</th>\n<th>Default Value</th>\n<th>Valid Range</th>\n<th>Security Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>memory_cost</code></td>\n<td>int</td>\n<td>65536 (64 MB)</td>\n<td>1024-1048576</td>\n<td>Memory requirement prevents ASIC/GPU optimization</td>\n</tr>\n<tr>\n<td><code>time_cost</code></td>\n<td>int</td>\n<td>3</td>\n<td>1-10</td>\n<td>Time iterations increase computation without proportional memory growth</td>\n</tr>\n<tr>\n<td><code>parallelism</code></td>\n<td>int</td>\n<td>4</td>\n<td>1-16</td>\n<td>Thread count must match deployment hardware</td>\n</tr>\n<tr>\n<td><code>hash_length</code></td>\n<td>int</td>\n<td>32</td>\n<td>16-128</td>\n<td>Output length affects collision resistance</td>\n</tr>\n</tbody></table>\n<p>Argon2id parameters require careful balancing since they interact with each other. High memory costs provide ASIC resistance but may exceed available system memory. Parallelism factors must match the deployment environment&#39;s CPU capabilities to achieve intended performance.</p>\n<h4 id=\"parameter-validation-and-constraints\">Parameter Validation and Constraints</h4>\n<p>The system enforces parameter validation to prevent configuration errors that could compromise security:</p>\n<p><strong>Security Minimum Enforcement:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Parameter</th>\n<th>Minimum Value</th>\n<th>Rejection Reason</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PBKDF2</td>\n<td>iterations</td>\n<td><code>PBKDF2_MIN_ITERATIONS</code></td>\n<td>Below minimum provides inadequate brute force protection</td>\n</tr>\n<tr>\n<td>bcrypt</td>\n<td>cost</td>\n<td><code>BCRYPT_MIN_COST</code></td>\n<td>Low cost factors can be brute forced with modern hardware</td>\n</tr>\n<tr>\n<td>Argon2</td>\n<td>memory_cost</td>\n<td>1024</td>\n<td>Insufficient memory requirement enables specialized hardware attacks</td>\n</tr>\n<tr>\n<td>All</td>\n<td>salt_length</td>\n<td><code>MINIMUM_SALT_LENGTH</code></td>\n<td>Short salts vulnerable to rainbow table attacks</td>\n</tr>\n</tbody></table>\n<p><strong>Resource Limit Protection:</strong></p>\n<p>The system also validates that parameters don&#39;t exceed reasonable resource limits that could cause denial of service:</p>\n<table>\n<thead>\n<tr>\n<th>Parameter Category</th>\n<th>Maximum Limit</th>\n<th>Protection Against</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory Usage</td>\n<td>1 GB per hash</td>\n<td>Memory exhaustion attacks</td>\n</tr>\n<tr>\n<td>Iteration Counts</td>\n<td>10 million</td>\n<td>CPU exhaustion attacks</td>\n</tr>\n<tr>\n<td>Hash Lengths</td>\n<td>256 bytes</td>\n<td>Storage bloat attacks</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Parameter Validation Bypass</strong>\nDevelopers often implement parameter validation only in user-facing APIs, forgetting that stored hash records might contain parameters that were valid when created but exceed current limits. Always validate parameters during hash record parsing, not just during initial configuration.</p>\n</blockquote>\n<h4 id=\"parameter-evolution-and-migration-strategy\">Parameter Evolution and Migration Strategy</h4>\n<p>As hardware capabilities advance and cryptographic research progresses, parameter requirements evolve. The system design accommodates this evolution through <strong>versioned parameter schemas</strong> and <strong>gradual migration strategies</strong>.</p>\n<p><strong>Migration Trigger Conditions:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Condition</th>\n<th>Action Required</th>\n<th>Migration Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Algorithm deprecated</td>\n<td>Replace with modern alternative</td>\n<td>Transparent upgrade during next password change</td>\n</tr>\n<tr>\n<td>Parameters below current minimums</td>\n<td>Increase to current standards</td>\n<td>Background migration with performance monitoring</td>\n</tr>\n<tr>\n<td>New security research</td>\n<td>Evaluate parameter adjustments</td>\n<td>Phased rollout with fallback capability</td>\n</tr>\n</tbody></table>\n<p>The parameter evolution strategy balances security improvements against operational disruption. Rather than forcing immediate migration of all stored hashes, the system upgrades hashes gradually as users authenticate, spreading the computational load over time.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Parameter Storage Separation</strong></p>\n<p>A frequent mistake involves storing algorithm parameters separately from the hash record itself, often in configuration files or global application settings. This creates a <strong>temporal coupling</strong> problem - the parameters used to create a hash must remain available and unchanged throughout the hash&#39;s lifetime, potentially years later.</p>\n<p><strong>Why this breaks:</strong> Configuration files get updated, applications get redeployed with new defaults, and servers get migrated. If parameters are stored separately, hash verification fails unpredictably when configurations change.</p>\n<p><strong>How to fix:</strong> Always embed all necessary parameters directly within the hash record. The <code>parameters</code> dictionary ensures that each hash remains verifiable regardless of configuration changes.</p>\n<p>⚠️ <strong>Pitfall: Algorithm Parameter Mixing</strong></p>\n<p>Developers sometimes accidentally apply parameters from one algorithm to another, such as passing bcrypt cost factors to PBKDF2 iterations or using Argon2 memory costs with bcrypt.</p>\n<p><strong>Why this breaks:</strong> Each algorithm interprets parameters differently. A bcrypt cost of 12 means 2^12 iterations, while PBKDF2 iterations of 12 would provide virtually no security.</p>\n<p><strong>How to fix:</strong> Implement strict parameter validation that checks parameter compatibility with the specified algorithm. Use typed parameter structures rather than generic dictionaries when possible.</p>\n<p>⚠️ <strong>Pitfall: Default Parameter Stagnation</strong></p>\n<p>Applications often hardcode &quot;reasonable&quot; default parameters at development time, then never update them as hardware capabilities advance or security recommendations evolve.</p>\n<p><strong>Why this breaks:</strong> Security parameters that were appropriate in 2020 may provide inadequate protection by 2025 as computing power increases and attack techniques improve.</p>\n<p><strong>How to fix:</strong> Implement parameter benchmarking utilities that measure current hardware performance and recommend appropriate parameter values. Schedule regular security reviews that evaluate parameter adequacy against current threat models.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Serialization</td>\n<td>Python <code>json</code> module with base64 encoding</td>\n<td><code>msgpack</code> or Protocol Buffers for binary efficiency</td>\n</tr>\n<tr>\n<td>Parameter Validation</td>\n<td>Manual validation with explicit checks</td>\n<td><code>pydantic</code> or <code>marshmallow</code> for schema validation</td>\n</tr>\n<tr>\n<td>Data Storage</td>\n<td>Dictionary-based in-memory storage</td>\n<td>SQLAlchemy models for database persistence</td>\n</tr>\n<tr>\n<td>Timestamp Handling</td>\n<td>ISO 8601 strings with <code>datetime</code> module</td>\n<td>Unix timestamps with timezone awareness</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>The data model components should be organized to separate concerns and enable easy testing:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  src/\n    password_hashing/\n      data_model.py              ← Core data structures (this section)\n      __init__.py\n      algorithms/                ← Algorithm implementations  \n        __init__.py\n        basic_hasher.py\n        pbkdf2_hasher.py\n        modern_hasher.py\n      storage/                   ← Persistence layer\n        __init__.py\n        json_storage.py\n        database_storage.py\n      validation/                ← Parameter validation\n        __init__.py\n        parameter_validator.py\n  tests/\n    test_data_model.py          ← Data model tests\n    test_parameter_validation.py ← Parameter validation tests\n  examples/\n    hash_record_examples.py     ← Usage examples</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete Parameter Validation Infrastructure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Parameter validation infrastructure - complete implementation ready to use.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">This handles all the validation logic so you can focus on the core hashing algorithms.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timezone</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Constants from project naming conventions</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MINIMUM_SALT_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 16</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">RECOMMENDED_SALT_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 32</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">PBKDF2_MIN_ITERATIONS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100000</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">BCRYPT_MIN_COST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 12</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParameterValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when algorithm parameters fail validation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationResult</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Result of parameter validation with detailed feedback.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_valid: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    errors: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    warnings: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> raise_if_invalid</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Raise ParameterValidationError if validation failed.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.is_valid:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> ParameterValidationError(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Parameter validation failed: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#9ECBFF\">', '</span><span style=\"color:#E1E4E8\">.join(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.errors)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParameterValidator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validates algorithm parameters against security and resource constraints.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Maximum limits to prevent resource exhaustion</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MAX_MEMORY_MB</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#6A737D\">  # 1 GB maximum memory usage</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MAX_ITERATIONS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 10_000_000</span><span style=\"color:#6A737D\">  # 10 million iteration maximum</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MAX_HASH_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 256</span><span style=\"color:#6A737D\">  # Maximum output hash length</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_parameters</span><span style=\"color:#E1E4E8\">(self, algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, parameters: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> ValidationResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate parameters for the specified algorithm.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        warnings </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> algorithm </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"sha256\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.extend(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._validate_sha256_params(parameters))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> algorithm </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"pbkdf2-sha256\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.extend(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._validate_pbkdf2_params(parameters))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> algorithm </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"bcrypt\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.extend(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._validate_bcrypt_params(parameters))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> algorithm </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> \"argon2id\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.extend(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._validate_argon2_params(parameters))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unknown algorithm: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">algorithm</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ValidationResult(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            is_valid</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(errors) </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            errors</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">errors,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            warnings</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">warnings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_sha256_params</span><span style=\"color:#E1E4E8\">(self, params: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate SHA-256 specific parameters.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        salt_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> params.get(</span><span style=\"color:#9ECBFF\">\"salt_length\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">RECOMMENDED_SALT_LENGTH</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> salt_length </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> MINIMUM_SALT_LENGTH</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"salt_length </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">salt_length</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> below minimum </span><span style=\"color:#79B8FF\">{MINIMUM_SALT_LENGTH}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_pbkdf2_params</span><span style=\"color:#E1E4E8\">(self, params: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate PBKDF2 specific parameters.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        iterations </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> params.get(</span><span style=\"color:#9ECBFF\">\"iterations\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">PBKDF2_MIN_ITERATIONS</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> iterations </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> PBKDF2_MIN_ITERATIONS</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"iterations </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">iterations</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> below minimum </span><span style=\"color:#79B8FF\">{PBKDF2_MIN_ITERATIONS}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> iterations </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">MAX_ITERATIONS</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"iterations </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">iterations</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> exceeds maximum </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">MAX_ITERATIONS}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        key_length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> params.get(</span><span style=\"color:#9ECBFF\">\"derived_key_length\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> key_length </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">MAX_HASH_LENGTH</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"derived_key_length </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">key_length</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> exceeds maximum </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">MAX_HASH_LENGTH}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_bcrypt_params</span><span style=\"color:#E1E4E8\">(self, params: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate bcrypt specific parameters.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cost </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> params.get(</span><span style=\"color:#9ECBFF\">\"cost\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">BCRYPT_MIN_COST</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cost </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> BCRYPT_MIN_COST</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"cost </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">cost</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> below minimum </span><span style=\"color:#79B8FF\">{BCRYPT_MIN_COST}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> cost </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 18</span><span style=\"color:#E1E4E8\">:  </span><span style=\"color:#6A737D\"># bcrypt practical maximum</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"cost </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">cost</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> exceeds practical maximum 18\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_argon2_params</span><span style=\"color:#E1E4E8\">(self, params: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate Argon2 specific parameters.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        memory_cost </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> params.get(</span><span style=\"color:#9ECBFF\">\"memory_cost\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">65536</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> memory_cost </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"memory_cost </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">memory_cost</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> below minimum 1024\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> memory_cost </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">MAX_MEMORY_MB</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.append(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"memory_cost </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">memory_cost</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> exceeds maximum </span><span style=\"color:#79B8FF\">{self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">MAX_MEMORY_MB</span><span style=\"color:#F97583\"> *</span><span style=\"color:#79B8FF\"> 1024}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        time_cost </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> params.get(</span><span style=\"color:#9ECBFF\">\"time_cost\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> time_cost </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.append(</span><span style=\"color:#9ECBFF\">\"time_cost must be at least 1\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        parallelism </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> params.get(</span><span style=\"color:#9ECBFF\">\"parallelism\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">4</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> parallelism </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> or</span><span style=\"color:#E1E4E8\"> parallelism </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            errors.append(</span><span style=\"color:#9ECBFF\">\"parallelism must be between 1 and 16\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> errors</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Global validator instance for convenience</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">parameter_validator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ParameterValidator()</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>PasswordHashRecord Class Structure:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Core data model for password hash storage - implement the </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#9ECBFF\"> sections.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">This represents the heart of the password hashing system's data layer.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> base64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timezone</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, asdict</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PasswordHashRecord</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Complete password hash record containing all information needed for verification.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This class embodies the principle of self-contained verification - everything</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    needed to verify a password must be preserved within this record.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    algorithm: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    salt: </span><span style=\"color:#79B8FF\">bytes</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    hash</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">bytes</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parameters: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    version: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    created_at: Optional[datetime] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __post_init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Initialize created_at if not provided.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.created_at </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.created_at </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> datetime.now(timezone.utc)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_json</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Serialize hash record to JSON format for storage.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            JSON string representation of the hash record</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Convert salt bytes to base64 string for JSON serialization</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Convert hash bytes to base64 string for JSON serialization</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Convert datetime to ISO 8601 string format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Build dictionary with all fields using proper encodings</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return json.dumps() result with consistent formatting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use base64.b64encode().decode() for bytes to string conversion</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_json</span><span style=\"color:#E1E4E8\">(cls, json_str: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'PasswordHashRecord'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Deserialize hash record from JSON format.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            json_str: JSON string representation</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            PasswordHashRecord instance</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ValueError: If JSON is invalid or missing required fields</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Parse JSON string using json.loads() with error handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Decode base64 salt string back to bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Decode base64 hash string back to bytes  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Parse ISO 8601 created_at string to datetime object</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Validate all required fields are present</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Create and return PasswordHashRecord instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use base64.b64decode() and datetime.fromisoformat() for decoding</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_string_format</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Serialize to compact string format: algorithm$version$salt$hash$params</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Compact string representation for simple storage systems</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Encode salt as base64 string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Encode hash as base64 string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Encode parameters dict as base64-encoded JSON</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Join all components with '$' delimiter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return complete string format</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: json.dumps(parameters) then base64 encode the JSON string</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">classmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> from_string_format</span><span style=\"color:#E1E4E8\">(cls, string_repr: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#9ECBFF\">'PasswordHashRecord'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Deserialize from compact string format.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            string_repr: String in format algorithm$version$salt$hash$params</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            PasswordHashRecord instance</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ValueError: If string format is invalid</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Split string on '$' delimiter and validate part count</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract algorithm and version from first two parts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Base64 decode salt and hash from next two parts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Base64 decode and JSON parse parameters from last part</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Create PasswordHashRecord with decoded values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Expect exactly 5 parts after splitting on '$'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Validate hash record fields and parameters.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ValueError: If any field is invalid</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check algorithm is not empty string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check salt length meets MINIMUM_SALT_LENGTH requirement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check hash is not empty</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Use parameter_validator to validate algorithm parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Raise ValueError with specific error messages for failures</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Import parameter_validator from the infrastructure code above</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_parameter</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, default: Any </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Get algorithm parameter with default fallback.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            name: Parameter name</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            default: Default value if parameter not found</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Parameter value or default</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return parameter from self.parameters dict with default fallback</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> update_parameters</span><span style=\"color:#E1E4E8\">(self, new_params: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> </span><span style=\"color:#9ECBFF\">'PasswordHashRecord'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create new hash record with updated parameters.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Note: This creates a new record rather than modifying existing one</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        to maintain immutability of stored hash records.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            new_params: Parameters to add or update</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            New PasswordHashRecord with merged parameters</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create copy of existing parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Update copy with new_params using dict.update()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Create new PasswordHashRecord with updated parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Validate new record before returning</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return new record instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use dataclass replace() or create new instance manually</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Algorithm Parameter Management:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Algorithm parameter configuration and management - implement parameter logic.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Union</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AlgorithmParameters</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Manages algorithm-specific parameter configurations and defaults.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This class provides the interface between high-level algorithm selection</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    and low-level parameter tuning for each supported hashing method.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Initialize with default parameter sets for all algorithms.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create default parameters dictionary for each algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Include sha256, pbkdf2-sha256, bcrypt, and argon2id defaults</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Use constants from naming conventions for minimum values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Store in self._defaults for later reference</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Structure as {\"algorithm\": {\"param\": value, ...}, ...}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_defaults</span><span style=\"color:#E1E4E8\">(self, algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Get default parameters for specified algorithm.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            algorithm: Algorithm name (e.g., \"pbkdf2-sha256\")</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dictionary of default parameters</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ValueError: If algorithm is not supported</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check if algorithm exists in self._defaults</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Return copy of default parameters (not reference)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Raise ValueError for unsupported algorithms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use dict.copy() to avoid modifying defaults</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> create_parameters</span><span style=\"color:#E1E4E8\">(self, algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, overrides: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create parameter set by merging defaults with custom overrides.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            algorithm: Algorithm name</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            overrides: Custom parameter values to override defaults</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Complete parameter dictionary ready for use</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get default parameters for algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Apply overrides if provided using dict.update()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate merged parameters using parameter_validator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return validated parameter set</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Handle validation errors appropriately</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> benchmark_parameters</span><span style=\"color:#E1E4E8\">(self, algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, target_time_ms: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 250.0</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Automatically tune parameters to achieve target verification time.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        This helps applications set appropriate security levels based on their</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        hardware capabilities and performance requirements.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            algorithm: Algorithm to benchmark</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            target_time_ms: Target verification time in milliseconds</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Optimized parameters achieving approximately target time</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Start with default parameters for algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Implement binary search or iterative tuning approach</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Measure actual hash computation time using test password</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Adjust key parameters (iterations, cost, memory) based on timing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return parameters that achieve target timing within tolerance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use time.time() to measure hash computation duration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Note: This is advanced functionality - implement basic version first</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> compare_security_levels</span><span style=\"color:#E1E4E8\">(self, algorithm1: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, params1: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              algorithm2: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, params2: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Compare relative security levels between two parameter configurations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            algorithm1, params1: First configuration</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            algorithm2, params2: Second configuration</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dictionary containing security comparison metrics</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate approximate operation counts for each configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Estimate memory requirements for each configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Compare brute force attack costs based on parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return structured comparison with recommendations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Include warnings for configurations below security minimums</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Note: This requires security modeling - implement basic version</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>Python Data Model Best Practices:</strong></p>\n<ul>\n<li>Use <code>dataclasses</code> for structured data with automatic <code>__init__</code>, <code>__repr__</code>, and comparison methods</li>\n<li>Leverage <code>typing</code> module for clear type annotations that document expected data types</li>\n<li>Use <code>datetime.timezone.utc</code> for consistent timezone handling across deployments</li>\n<li>Handle <code>bytes</code> vs <code>str</code> carefully - passwords are text but salts and hashes are binary data</li>\n<li>Use <code>json.dumps(sort_keys=True)</code> for consistent JSON serialization across Python versions</li>\n</ul>\n<p><strong>Binary Data Handling:</strong></p>\n<ul>\n<li>Use <code>base64.b64encode().decode()</code> to convert bytes to JSON-safe strings</li>\n<li>Use <code>base64.b64decode()</code> to convert base64 strings back to bytes</li>\n<li>Always specify encoding explicitly: <code>&quot;utf-8&quot;</code> for text, base64 for binary data</li>\n<li>Validate base64 strings before decoding to provide clear error messages</li>\n</ul>\n<p><strong>Error Handling Patterns:</strong></p>\n<ul>\n<li>Create custom exception classes (<code>ParameterValidationError</code>, <code>HashRecordError</code>) for specific failure modes</li>\n<li>Use <code>ValueError</code> for data validation failures with descriptive messages</li>\n<li>Use <code>TypeError</code> for incorrect data types passed to functions</li>\n<li>Include the invalid value in error messages to aid debugging</li>\n</ul>\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After implementing PasswordHashRecord:</strong></p>\n<ul>\n<li>Run: <code>python -c &quot;from data_model import PasswordHashRecord; print(&#39;Import successful&#39;)&quot;</code></li>\n<li>Test JSON serialization round-trip: create record, serialize to JSON, deserialize, verify equality</li>\n<li>Test string format round-trip: create record, convert to string format, parse back, verify equality</li>\n<li>Verify validation catches invalid salt lengths and unknown algorithms</li>\n</ul>\n<p><strong>After implementing AlgorithmParameters:</strong></p>\n<ul>\n<li>Run parameter validation tests: <code>python -m pytest tests/test_parameter_validation.py -v</code></li>\n<li>Test default parameter retrieval for all supported algorithms</li>\n<li>Verify parameter override functionality works correctly</li>\n<li>Test that validation catches security violations (too few iterations, etc.)</li>\n</ul>\n<p><strong>Integration Test:</strong>\nCreate a complete password hash record with PBKDF2 parameters, serialize to JSON, store in file, read back, and verify the password - this tests the entire data model pipeline.</p>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JSON serialization fails with &quot;not serializable&quot;</td>\n<td>bytes fields not base64 encoded</td>\n<td>Check if salt/hash are bytes objects</td>\n<td>Convert bytes to base64 strings before JSON</td>\n</tr>\n<tr>\n<td>Parameter validation passes but hashing fails</td>\n<td>Wrong parameter types (int vs str)</td>\n<td>Print parameter types and values</td>\n<td>Ensure parameters match algorithm expectations</td>\n</tr>\n<tr>\n<td>Hash records can&#39;t be parsed after storage</td>\n<td>Encoding/decoding mismatch</td>\n<td>Compare original vs stored JSON</td>\n<td>Use consistent base64 encoding for all bytes</td>\n</tr>\n<tr>\n<td>Created timestamps cause JSON errors</td>\n<td>Timezone-aware datetime objects</td>\n<td>Check datetime.isoformat() output</td>\n<td>Use UTC timezone consistently</td>\n</tr>\n<tr>\n<td>String format parsing fails</td>\n<td>Wrong delimiter count or encoding</td>\n<td>Count &#39;$&#39; delimiters in string</td>\n<td>Verify 5 parts: algorithm$version$salt$hash$params</td>\n</tr>\n</tbody></table>\n<h2 id=\"salt-generation-component\">Salt Generation Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (Basic Hashing with Salt)</p>\n</blockquote>\n<h3 id=\"mental-model-the-fingerprint-database-security-system\">Mental Model: The Fingerprint Database Security System</h3>\n<p>Think of salt generation like a fingerprint database security system at a high-security facility. Every person who enters gets their fingerprint scanned, but instead of storing the raw fingerprint (which could be stolen and replicated), the system combines each fingerprint with a unique, random &quot;case number&quot; before storing it. This case number is different for every person, even if they have identical fingerprints (like identical twins). The case number is stored alongside the processed fingerprint data, so when someone returns, the system can retrieve their specific case number and re-process their fingerprint the same way for comparison.</p>\n<p>In password hashing, the <strong>salt</strong> is like that unique case number. It&#39;s a cryptographically random value that gets combined with every password before hashing. Even if two users have the same password (&quot;password123&quot;), their stored hashes will be completely different because each got a different salt. This prevents attackers from using <strong>rainbow tables</strong> (precomputed hash-to-password lookup databases) because they would need to recompute their entire attack database for every possible salt value - an computationally infeasible task.</p>\n<p>The <code>SaltGenerator</code> component serves as the secure random number generator for our password hashing system. Its primary responsibility is producing cryptographically secure random values that serve as unique inputs to the hashing process. This component must guarantee that each generated salt is unpredictable, unique, and of sufficient length to provide cryptographic security against precomputed attacks.</p>\n<p><img src=\"/api/project/password-hashing/architecture-doc/asset?path=diagrams%2Fregistration-sequence.svg\" alt=\"Password Registration Sequence\"></p>\n<h3 id=\"component-responsibilities\">Component Responsibilities</h3>\n<p>The <code>SaltGenerator</code> component owns several critical security functions within the broader password hashing architecture. Its core responsibility is generating cryptographically secure random values, but this seemingly simple task encompasses multiple technical requirements and security considerations.</p>\n<p>The component must produce random values using cryptographically secure random number generators that draw from sufficient entropy sources. This means utilizing operating system-provided entropy pools rather than pseudo-random number generators designed for statistical randomness. The difference is crucial: statistical randomness might pass mathematical tests for randomness but could still be predictable to an attacker who understands the algorithm, while cryptographic randomness is designed to be unpredictable even to attackers with significant computational resources.</p>\n<p>Beyond random generation, the component must enforce minimum security standards for salt length and format. Different cryptographic contexts require different minimum salt lengths, and the component must reject requests that fall below these thresholds. It also handles salt encoding and serialization, ensuring that generated salts can be safely stored alongside password hashes and reliably reconstructed during verification.</p>\n<table>\n<thead>\n<tr>\n<th>Responsibility</th>\n<th>Description</th>\n<th>Security Requirement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Random Generation</td>\n<td>Produce cryptographically secure random bytes</td>\n<td>Must use OS entropy sources, not PRNG</td>\n</tr>\n<tr>\n<td>Length Validation</td>\n<td>Enforce minimum salt lengths for security</td>\n<td>Reject salts shorter than <code>MINIMUM_SALT_LENGTH</code></td>\n</tr>\n<tr>\n<td>Encoding Management</td>\n<td>Convert random bytes to storable format</td>\n<td>Support both binary and text representations</td>\n</tr>\n<tr>\n<td>Uniqueness Assurance</td>\n<td>Ensure statistical uniqueness across generations</td>\n<td>Collision probability must be negligible</td>\n</tr>\n<tr>\n<td>Format Standardization</td>\n<td>Provide consistent salt output format</td>\n<td>Enable interoperability between components</td>\n</tr>\n</tbody></table>\n<h3 id=\"cryptographic-randomness-requirements\">Cryptographic Randomness Requirements</h3>\n<p>Cryptographic randomness represents the foundation of salt security, yet many developers underestimate the complexity and importance of proper random number generation. The distinction between &quot;random enough for testing&quot; and &quot;random enough for cryptographic security&quot; can mean the difference between robust security and trivial compromise.</p>\n<h4 id=\"understanding-entropy-sources\">Understanding Entropy Sources</h4>\n<p>True randomness in computer systems originates from physical processes that are inherently unpredictable. Modern operating systems collect entropy from various sources: keyboard timing variations, mouse movement patterns, disk seek time fluctuations, network packet arrival timing, and dedicated hardware random number generators. These entropy sources feed into kernel-maintained entropy pools that cryptographic random number generators draw from.</p>\n<p>The critical architectural decision for salt generation involves choosing between different classes of random number generators. Pseudo-random number generators (PRNGs) like those used for statistical simulations produce mathematically random sequences but are completely deterministic given their seed value. An attacker who discovers the seed or internal state can predict all future outputs. Cryptographically secure pseudo-random number generators (CSPRNGs) are designed to remain unpredictable even if attackers learn some previous outputs, but they still require high-quality seed material from true entropy sources.</p>\n<blockquote>\n<p><strong>Decision: Use Operating System Cryptographic APIs</strong></p>\n<ul>\n<li><strong>Context</strong>: Need cryptographically secure random values for salt generation with guarantee of sufficient entropy</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Standard library PRNG (like <code>random.random()</code>)</li>\n<li>Custom cryptographic PRNG implementation</li>\n<li>Operating system cryptographic APIs (like <code>/dev/urandom</code> or <code>CryptGenRandom</code>)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use operating system cryptographic APIs exclusively</li>\n<li><strong>Rationale</strong>: OS APIs provide access to kernel entropy pools with hardware entropy sources, have been extensively audited, and handle entropy estimation automatically. Custom implementations risk subtle vulnerabilities, while standard PRNGs offer no cryptographic security.</li>\n<li><strong>Consequences</strong>: Dependency on OS cryptographic subsystem, but eliminates entire classes of implementation vulnerabilities and ensures access to best available entropy sources.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Option</th>\n<th>Entropy Quality</th>\n<th>Predictability Risk</th>\n<th>Implementation Complexity</th>\n<th>Performance</th>\n<th>Security Audit History</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Standard PRNG</td>\n<td>Low</td>\n<td>High - fully predictable</td>\n<td>Low</td>\n<td>Excellent</td>\n<td>Not designed for security</td>\n</tr>\n<tr>\n<td>Custom CSPRNG</td>\n<td>Variable</td>\n<td>Medium - depends on implementation</td>\n<td>Very High</td>\n<td>Good</td>\n<td>None - new implementation</td>\n</tr>\n<tr>\n<td>OS Crypto APIs</td>\n<td>High</td>\n<td>Very Low</td>\n<td>Low</td>\n<td>Good</td>\n<td>Extensively audited</td>\n</tr>\n</tbody></table>\n<h4 id=\"platform-specific-entropy-sources\">Platform-Specific Entropy Sources</h4>\n<p>Different operating systems provide cryptographically secure random numbers through different interfaces, each with specific characteristics and guarantees. Understanding these differences helps explain why the <code>SaltGenerator</code> component abstracts platform-specific details behind a common interface.</p>\n<p>On Unix-like systems (Linux, macOS, BSD variants), <code>/dev/urandom</code> provides the standard interface to kernel entropy. Despite its name suggesting &quot;unreliable&quot; randomness, <code>/dev/urandom</code> provides cryptographically secure random numbers in all practical scenarios. It draws from the same entropy pool as <code>/dev/random</code> but doesn&#39;t block when entropy estimates are low. The blocking behavior of <code>/dev/random</code> can cause denial-of-service conditions in server applications, while the theoretical security difference is negligible for salt generation use cases.</p>\n<p>Windows systems provide cryptographically secure randomness through the CryptoAPI, specifically the <code>CryptGenRandom</code> function or the newer Cryptography API: Next Generation (CNG) <code>BCryptGenRandom</code> function. These APIs access hardware random number generators when available and fall back to software-based CSPRNGs seeded from multiple entropy sources including hardware timing, process information, and user input.</p>\n<p>Modern programming language standard libraries abstract these platform differences, providing portable interfaces that select the appropriate OS-level mechanism. Python&#39;s <code>secrets</code> module, Go&#39;s <code>crypto/rand</code> package, and Node.js&#39;s <code>crypto.randomBytes()</code> function all provide this abstraction while maintaining cryptographic security guarantees.</p>\n<blockquote>\n<p>The key architectural insight is that salt generation must never compromise on entropy quality for convenience or performance. A single weak salt compromises the security of that password hash permanently, making the entropy quality decision one of the most critical in the entire system.</p>\n</blockquote>\n<h4 id=\"detecting-entropy-exhaustion\">Detecting Entropy Exhaustion</h4>\n<p>While modern systems rarely exhaust entropy pools, understanding entropy exhaustion scenarios helps explain why certain implementation choices matter. Entropy exhaustion occurs when random number generation outpaces the rate at which the system can collect new entropy from physical sources. This can happen during system boot before entropy sources have provided sufficient randomness, in virtualized environments with limited entropy sources, or under extremely high random number generation loads.</p>\n<p>The <code>SaltGenerator</code> component must handle potential entropy exhaustion gracefully. Rather than generating predictable values or hanging indefinitely, it should detect low entropy conditions and either wait for entropy recovery or fail securely by refusing to generate salts. Most modern OS cryptographic APIs handle this automatically, but understanding the underlying concepts helps explain why certain APIs are preferred.</p>\n<table>\n<thead>\n<tr>\n<th>Entropy Condition</th>\n<th><code>/dev/random</code> Behavior</th>\n<th><code>/dev/urandom</code> Behavior</th>\n<th>Windows CryptoAPI</th>\n<th>Recommended Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>High Entropy</td>\n<td>Returns immediately</td>\n<td>Returns immediately</td>\n<td>Returns immediately</td>\n<td>Normal operation</td>\n</tr>\n<tr>\n<td>Low Entropy</td>\n<td>Blocks until entropy available</td>\n<td>Returns immediately</td>\n<td>Returns immediately</td>\n<td>Monitor but continue</td>\n</tr>\n<tr>\n<td>Critical Low Entropy</td>\n<td>Blocks indefinitely</td>\n<td>May return predictable values</td>\n<td>Fails securely</td>\n<td>Fail salt generation</td>\n</tr>\n<tr>\n<td>Boot Time</td>\n<td>Blocks</td>\n<td>May be predictable</td>\n<td>Waits for entropy seeding</td>\n<td>Delay application start</td>\n</tr>\n</tbody></table>\n<h3 id=\"salt-length-architecture-decisions\">Salt Length Architecture Decisions</h3>\n<p>Salt length directly impacts security effectiveness, storage requirements, and computational overhead. While longer salts provide stronger security guarantees, they also increase storage costs and may impact performance in high-throughput scenarios. The architectural challenge involves balancing these factors while ensuring adequate security for the foreseeable future.</p>\n<h4 id=\"security-analysis-of-salt-length\">Security Analysis of Salt Length</h4>\n<p>The primary security function of salts is preventing <strong>rainbow table attacks</strong> - precomputed hash-to-password lookup tables that accelerate password cracking. To understand salt length requirements, consider the economics of rainbow table construction. An attacker building rainbow tables must compute and store hash values for every combination of likely passwords and possible salt values. The computational and storage costs scale linearly with the number of possible salt values.</p>\n<p>With a salt length of <code>n</code> bits, there are <code>2^n</code> possible salt values. An attacker wanting comprehensive rainbow table coverage must compute approximately <code>2^n</code> times as many hashes as they would for unsalted passwords. For practical attack scenarios, this quickly becomes computationally infeasible.</p>\n<p>A 128-bit salt (16 bytes) provides <code>2^128</code> possible values - approximately <code>3.4 × 10^38</code> possibilities. Even with advanced hardware capable of computing billions of hashes per second, building comprehensive rainbow tables for all possible 128-bit salts would require more computational resources than are practically available. This analysis provides the foundation for the <code>MINIMUM_SALT_LENGTH</code> constant.</p>\n<blockquote>\n<p><strong>Decision: 128-bit Minimum Salt Length</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to determine minimum salt length that provides cryptographic security against rainbow table attacks while considering storage and performance constraints</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>64-bit salts (8 bytes) - minimal storage overhead</li>\n<li>128-bit salts (16 bytes) - current cryptographic standard</li>\n<li>256-bit salts (32 bytes) - future-proofing against quantum attacks</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: 128-bit minimum with 256-bit recommended default</li>\n<li><strong>Rationale</strong>: 128-bit salts provide <code>2^128</code> possible values, making rainbow table attacks computationally infeasible with current and foreseeable technology. 64-bit salts might become vulnerable to well-funded attackers, while 256-bit salts provide quantum resistance with minimal additional overhead.</li>\n<li><strong>Consequences</strong>: Requires 16 bytes storage per password hash minimum, 32 bytes recommended. Provides long-term security against rainbow table attacks and some quantum computing scenarios.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Salt Length</th>\n<th>Possible Values</th>\n<th>Rainbow Table Storage (1TB passwords)</th>\n<th>Attack Feasibility</th>\n<th>Quantum Resistance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>64-bit</td>\n<td><code>2^64</code> ≈ 18 × 10^18</td>\n<td>18 exabytes</td>\n<td>Potentially feasible for nation-states</td>\n<td>Vulnerable</td>\n</tr>\n<tr>\n<td>128-bit</td>\n<td><code>2^128</code> ≈ 3.4 × 10^38</td>\n<td>340 undecillion bytes</td>\n<td>Computationally infeasible</td>\n<td>Reduced but significant</td>\n</tr>\n<tr>\n<td>256-bit</td>\n<td><code>2^256</code> ≈ 1.2 × 10^77</td>\n<td>Impossibly large</td>\n<td>Impossible with known physics</td>\n<td>Strong resistance</td>\n</tr>\n</tbody></table>\n<h4 id=\"storage-format-considerations\">Storage Format Considerations</h4>\n<p>Salt storage format affects interoperability, debugging capabilities, and integration with existing systems. The <code>SaltGenerator</code> must produce salts in formats that can be efficiently stored alongside password hashes and reliably reconstructed during verification.</p>\n<p>Binary storage provides optimal space efficiency, storing salts as raw byte arrays without encoding overhead. A 128-bit salt requires exactly 16 bytes in binary format. However, binary storage complicates debugging (binary data isn&#39;t human-readable), integration with text-based systems, and serialization to formats like JSON that don&#39;t handle arbitrary binary data well.</p>\n<p>Base64 encoding converts binary salt data to printable ASCII characters, enabling storage in text databases and easy serialization to standard formats. Base64 encoding adds approximately 33% storage overhead (a 16-byte salt becomes a 24-character string), but the overhead is generally acceptable given the benefits for system integration and debugging.</p>\n<p>Hexadecimal encoding provides another text representation option, converting each byte to two hexadecimal digits. A 16-byte salt becomes a 32-character hex string, doubling storage requirements but providing human-readable output that&#39;s easier to debug than Base64.</p>\n<table>\n<thead>\n<tr>\n<th>Storage Format</th>\n<th>128-bit Salt Size</th>\n<th>256-bit Salt Size</th>\n<th>Human Readable</th>\n<th>JSON Compatible</th>\n<th>Storage Efficiency</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Binary</td>\n<td>16 bytes</td>\n<td>32 bytes</td>\n<td>No</td>\n<td>No</td>\n<td>100%</td>\n</tr>\n<tr>\n<td>Base64</td>\n<td>24 characters</td>\n<td>44 characters</td>\n<td>Partially</td>\n<td>Yes</td>\n<td>75%</td>\n</tr>\n<tr>\n<td>Hexadecimal</td>\n<td>32 characters</td>\n<td>64 characters</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>50%</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The architectural decision to support multiple encoding formats within the <code>SaltGenerator</code> provides flexibility for different deployment scenarios while maintaining a consistent internal binary representation for cryptographic operations.</p>\n</blockquote>\n<h4 id=\"salt-uniqueness-requirements\">Salt Uniqueness Requirements</h4>\n<p>While cryptographically secure random generation makes salt collisions extremely unlikely, understanding the mathematical foundations helps explain why certain implementation practices matter. Salt uniqueness isn&#39;t just about avoiding identical salts - it&#39;s about ensuring that the distribution of salt values provides maximum entropy for the hashing process.</p>\n<p>The birthday paradox provides insight into collision probabilities for different salt lengths. For randomly generated values from a space of <code>N</code> possibilities, the probability of collision becomes significant when approximately <code>√N</code> values have been generated. For 128-bit salts with <code>2^128</code> possible values, collision probability becomes meaningful only after generating approximately <code>2^64</code> salts - far more than any practical system would generate.</p>\n<p>However, cryptographic security requires considering not just average-case collision probability but also worst-case scenarios where attackers might deliberately attempt to generate salt collisions. The <code>SaltGenerator</code> component must use cryptographically secure random sources that resist prediction and manipulation, ensuring that salt generation remains secure even under adversarial conditions.</p>\n<table>\n<thead>\n<tr>\n<th>Salt Length</th>\n<th>Collision Probability (1 million salts)</th>\n<th>Collision Probability (1 billion salts)</th>\n<th>Practical Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>64-bit</td>\n<td>~1 in 18 × 10^12</td>\n<td>~1 in 18 × 10^6</td>\n<td>Possible in large systems</td>\n</tr>\n<tr>\n<td>128-bit</td>\n<td>~1 in 3.4 × 10^32</td>\n<td>~1 in 3.4 × 10^26</td>\n<td>Negligible</td>\n</tr>\n<tr>\n<td>256-bit</td>\n<td>~1 in 1.2 × 10^71</td>\n<td>~1 in 1.2 × 10^65</td>\n<td>Impossible</td>\n</tr>\n</tbody></table>\n<h3 id=\"salt-generation-algorithm\">Salt Generation Algorithm</h3>\n<p>The salt generation algorithm implements the architectural decisions described above while providing a clean interface for other system components. The algorithm must balance security, performance, and usability requirements while maintaining consistent behavior across different deployment environments.</p>\n<p>The core salt generation process follows these steps:</p>\n<ol>\n<li><p><strong>Validate Input Parameters</strong>: Check that the requested salt length meets minimum security requirements defined by <code>MINIMUM_SALT_LENGTH</code>. Reject requests for shorter salts to prevent security degradation through misconfiguration.</p>\n</li>\n<li><p><strong>Access System Entropy Source</strong>: Establish connection to the operating system&#39;s cryptographic random number generator. This involves opening <code>/dev/urandom</code> on Unix systems or initializing Windows CryptoAPI handles.</p>\n</li>\n<li><p><strong>Generate Random Bytes</strong>: Request the specified number of random bytes from the entropy source. Handle potential errors like entropy exhaustion or system call failures that could compromise security.</p>\n</li>\n<li><p><strong>Validate Output Quality</strong>: Perform basic sanity checks on generated random data. While cryptographic entropy sources should never produce obviously non-random output, defensive programming principles suggest validating that the output isn&#39;t all zeros or other obviously wrong patterns.</p>\n</li>\n<li><p><strong>Format for Storage</strong>: Convert raw binary random data to the requested output format (binary, Base64, or hexadecimal) based on system requirements and storage constraints.</p>\n</li>\n<li><p><strong>Return Salt with Metadata</strong>: Provide the generated salt along with metadata about its generation (timestamp, length, format) to support debugging and system monitoring.</p>\n</li>\n</ol>\n<p>The algorithm must handle several error conditions gracefully. Entropy source unavailability should cause immediate failure rather than falling back to weaker randomness sources. Invalid length requests should be rejected with clear error messages explaining security requirements. System resource exhaustion should result in temporary failure with retry guidance rather than generating potentially weak salts.</p>\n<blockquote>\n<p><strong>Critical Design Principle</strong>: The salt generation algorithm must fail securely. It&#39;s better to refuse salt generation than to generate cryptographically weak salts that compromise password security permanently.</p>\n</blockquote>\n<h3 id=\"integration-with-password-hashing-components\">Integration with Password Hashing Components</h3>\n<p>The <code>SaltGenerator</code> component integrates with other password hashing system components through well-defined interfaces that maintain security boundaries while enabling flexible system architecture. Understanding these integration points helps clarify the component&#39;s role within the broader system.</p>\n<p>The primary integration occurs with the <code>BasicHasher</code> component, which calls <code>generate_salt()</code> during password registration to obtain unique random values for each password. This integration must ensure that salt generation happens immediately before password hashing to minimize the window where salts might be cached in memory or temporary storage.</p>\n<p>Integration with the <code>PasswordHashRecord</code> data structure requires consistent salt formatting that supports both storage and retrieval operations. The generated salt becomes part of the permanent password hash record, so format decisions made during generation affect the system permanently.</p>\n<p>The component also integrates with system monitoring and logging infrastructure to provide visibility into salt generation operations without compromising security. This includes metrics about generation rates, error conditions, and entropy source health, but never logs the actual salt values which would compromise their security properties.</p>\n<table>\n<thead>\n<tr>\n<th>Integration Point</th>\n<th>Interface</th>\n<th>Security Boundary</th>\n<th>Failure Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>BasicHasher</td>\n<td><code>generate_salt(length) -&gt; bytes</code></td>\n<td>Salt values never logged or cached</td>\n<td>Propagate failures to prevent weak hashing</td>\n</tr>\n<tr>\n<td>PasswordHashRecord</td>\n<td>Salt serialization/deserialization</td>\n<td>Immutable salt storage</td>\n<td>Validation during record creation</td>\n</tr>\n<tr>\n<td>Monitoring System</td>\n<td>Performance and error metrics</td>\n<td>No salt value exposure</td>\n<td>Aggregate statistics only</td>\n</tr>\n<tr>\n<td>Configuration System</td>\n<td>Length and format parameters</td>\n<td>Enforce minimum security requirements</td>\n<td>Reject unsafe configurations</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>Understanding common mistakes in salt generation helps avoid subtle security vulnerabilities that might not manifest until systems face real attacks. These pitfalls often arise from misconceptions about randomness, security requirements, or implementation details.</p>\n<p>⚠️ <strong>Pitfall: Using Standard Library Random Functions</strong></p>\n<p>Many developers instinctively reach for their language&#39;s standard <code>random()</code> function when implementing salt generation. Functions like Python&#39;s <code>random.random()</code>, JavaScript&#39;s <code>Math.random()</code>, or C&#39;s <code>rand()</code> are designed for statistical randomness in simulations and games, not cryptographic security. These functions are completely predictable if an attacker can determine their internal state or seed value.</p>\n<p><strong>Why it&#39;s wrong</strong>: Standard random functions use algorithms optimized for speed and statistical properties, not unpredictability. An attacker who observes several salt values might be able to predict future salts, enabling targeted attacks against new password hashes.</p>\n<p><strong>How to fix</strong>: Always use cryptographically secure random functions: Python&#39;s <code>secrets.token_bytes()</code>, Go&#39;s <code>crypto/rand.Read()</code>, Node.js&#39;s <code>crypto.randomBytes()</code>, or direct OS interfaces like <code>/dev/urandom</code>.</p>\n<p>⚠️ <strong>Pitfall: Reusing Salts Across Users</strong></p>\n<p>Some implementations attempt to optimize storage or simplify code by using a single &quot;global salt&quot; for all users or generating salts based on predictable values like usernames or timestamps.</p>\n<p><strong>Why it&#39;s wrong</strong>: Salt reuse eliminates the primary security benefit - preventing rainbow table attacks. If multiple users share the same salt, an attacker can build rainbow tables for that salt and crack multiple passwords efficiently.</p>\n<p><strong>How to fix</strong>: Generate a unique, random salt for every individual password. Never derive salts from predictable inputs or reuse them across different passwords.</p>\n<p>⚠️ <strong>Pitfall: Insufficient Salt Length</strong></p>\n<p>Developers sometimes choose salt lengths based on convenience (like 4 or 8 bytes) rather than security requirements, not understanding that shorter salts provide exponentially less security.</p>\n<p><strong>Why it&#39;s wrong</strong>: Short salts create feasible rainbow table attack scenarios. An 8-byte salt has only <code>2^64</code> possible values - large but potentially manageable for well-funded attackers with specialized hardware.</p>\n<p><strong>How to fix</strong>: Use minimum 16-byte (128-bit) salts as defined by <code>MINIMUM_SALT_LENGTH</code>. Prefer 32-byte (256-bit) salts when storage overhead isn&#39;t critical.</p>\n<p>⚠️ <strong>Pitfall: Not Handling Entropy Exhaustion</strong></p>\n<p>Some implementations assume that random number generation always succeeds immediately and don&#39;t handle scenarios where entropy sources might be temporarily unavailable or exhausted.</p>\n<p><strong>Why it&#39;s wrong</strong>: Entropy exhaustion can cause systems to hang indefinitely, create denial-of-service conditions, or in worst cases, fall back to predictable randomness that compromises security.</p>\n<p><strong>How to fix</strong>: Use non-blocking entropy sources like <code>/dev/urandom</code>, implement timeouts for random number generation, and fail securely if entropy sources become unavailable rather than generating potentially weak salts.</p>\n<p>⚠️ <strong>Pitfall: Salt Storage Format Inconsistencies</strong></p>\n<p>Inconsistent handling of salt encoding can lead to verification failures where the same password appears invalid due to salt format mismatches between generation and verification.</p>\n<p><strong>Why it&#39;s wrong</strong>: If salt generation produces Base64-encoded values but verification expects binary data, password verification will always fail even with correct passwords, creating a complete authentication system failure.</p>\n<p><strong>How to fix</strong>: Standardize on a single salt storage format within the system and ensure all components handle the same encoding consistently. Document format decisions clearly and validate format consistency in tests.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The <code>SaltGenerator</code> component translates cryptographic security requirements into practical code that developers can integrate into their password hashing systems. This implementation guidance provides complete, production-ready code for infrastructure components while offering detailed skeleton code for the core salt generation logic that learners should implement themselves.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Random Generation</td>\n<td><code>secrets</code> module (Python)</td>\n<td>Direct OS crypto APIs with error handling</td>\n</tr>\n<tr>\n<td>Salt Encoding</td>\n<td>Base64 with standard library</td>\n<td>Custom binary format with version headers</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>Hard-coded constants</td>\n<td>Runtime configuration with validation</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td>Unit tests with fixed test vectors</td>\n<td>Property-based testing with entropy analysis</td>\n</tr>\n<tr>\n<td>Monitoring</td>\n<td>Basic logging</td>\n<td>Metrics collection with entropy health monitoring</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>password-hashing/\n  src/\n    salt_generation/\n      __init__.py              ← Component public interface\n      salt_generator.py        ← Core SaltGenerator class\n      entropy_monitor.py       ← Entropy source health monitoring\n      test_salt_generation.py  ← Comprehensive test suite\n    common/\n      constants.py             ← Security constants and limits\n      exceptions.py            ← Custom exception types\n      validation.py            ← Input validation utilities\n  tests/\n    integration/\n      test_salt_uniqueness.py  ← Statistical uniqueness testing\n    security/\n      test_entropy_quality.py  ← Entropy quality validation</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>File: <code>src/common/constants.py</code></strong> (Complete implementation - copy and use)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Security constants for password hashing system.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">These values are based on current cryptographic best practices.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Salt generation security parameters</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MINIMUM_SALT_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#6A737D\">        # 128 bits - cryptographic minimum</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">RECOMMENDED_SALT_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#6A737D\">    # 256 bits - recommended for new systems</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MAX_SALT_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#6A737D\">           # 512 bits - reasonable upper limit</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Supported salt encoding formats</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">SALT_FORMAT_BINARY</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"binary\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">SALT_FORMAT_BASE64</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"base64\"</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">SALT_FORMAT_HEX</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"hex\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Default configuration</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_SALT_FORMAT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> SALT_FORMAT_BASE64</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">DEFAULT_SALT_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> RECOMMENDED_SALT_LENGTH</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Error messages</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ERROR_SALT_TOO_SHORT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Salt length must be at least </span><span style=\"color:#79B8FF\">{MINIMUM_SALT_LENGTH}</span><span style=\"color:#9ECBFF\"> bytes\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ERROR_SALT_TOO_LONG</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Salt length must not exceed </span><span style=\"color:#79B8FF\">{MAX_SALT_LENGTH}</span><span style=\"color:#9ECBFF\"> bytes\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">ERROR_INVALID_FORMAT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Salt format must be one of: </span><span style=\"color:#79B8FF\">{SALT_FORMAT_BINARY}</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">{SALT_FORMAT_BASE64}</span><span style=\"color:#9ECBFF\">, </span><span style=\"color:#79B8FF\">{SALT_FORMAT_HEX}</span><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p><strong>File: <code>src/common/exceptions.py</code></strong> (Complete implementation - copy and use)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Custom exceptions for password hashing system.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PasswordHashingError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for password hashing system errors.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SaltGenerationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PasswordHashingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when salt generation fails.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EntropyExhaustionError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">SaltGenerationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when system entropy is insufficient for secure salt generation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParameterValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PasswordHashingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when algorithm parameters fail validation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, message, field_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">, provided_value</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.field_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field_name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.provided_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> provided_value</span></span></code></pre></div>\n\n<p><strong>File: <code>src/common/validation.py</code></strong> (Complete implementation - copy and use)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Input validation utilities for password hashing system.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .constants </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    MINIMUM_SALT_LENGTH</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">MAX_SALT_LENGTH</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SALT_FORMAT_BINARY</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SALT_FORMAT_BASE64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SALT_FORMAT_HEX</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ERROR_SALT_TOO_SHORT</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">ERROR_SALT_TOO_LONG</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">ERROR_INVALID_FORMAT</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ParameterValidationError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationResult</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Result of parameter validation with errors and warnings.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.is_valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.warnings </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_error</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.is_valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.errors.append(message)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_warning</span><span style=\"color:#E1E4E8\">(self, message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.warnings.append(message)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_salt_length</span><span style=\"color:#E1E4E8\">(length: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> ValidationResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validate salt length meets security requirements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ValidationResult()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(length, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result.add_error(</span><span style=\"color:#9ECBFF\">\"Salt length must be an integer\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> length </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> MINIMUM_SALT_LENGTH</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result.add_error(</span><span style=\"color:#79B8FF\">ERROR_SALT_TOO_SHORT</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#E1E4E8\"> length </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> MAX_SALT_LENGTH</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result.add_error(</span><span style=\"color:#79B8FF\">ERROR_SALT_TOO_LONG</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    elif</span><span style=\"color:#E1E4E8\"> length </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> RECOMMENDED_SALT_LENGTH</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result.add_warning(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Salt length </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">length</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> is below recommended </span><span style=\"color:#79B8FF\">{RECOMMENDED_SALT_LENGTH}</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_salt_format</span><span style=\"color:#E1E4E8\">(format_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> ValidationResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validate salt output format is supported.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ValidationResult()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(format_name, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result.add_error(</span><span style=\"color:#9ECBFF\">\"Salt format must be a string\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    valid_formats </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">SALT_FORMAT_BINARY</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SALT_FORMAT_BASE64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SALT_FORMAT_HEX</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> format_name </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> valid_formats:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result.add_error(</span><span style=\"color:#79B8FF\">ERROR_INVALID_FORMAT</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>File: <code>src/salt_generation/salt_generator.py</code></strong> (Skeleton for learner implementation)</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Cryptographically secure salt generation for password hashing.</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">This module provides the SaltGenerator class responsible for generating</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">unique, random salt values that prevent rainbow table attacks.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> secrets</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> base64</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..common.constants </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    DEFAULT_SALT_LENGTH</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">DEFAULT_SALT_FORMAT</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SALT_FORMAT_BINARY</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SALT_FORMAT_BASE64</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">SALT_FORMAT_HEX</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..common.validation </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> validate_salt_length, validate_salt_format</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..common.exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SaltGenerationError, ParameterValidationError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SaltGenerator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Generates cryptographically secure random salts for password hashing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This component uses the operating system's cryptographic entropy sources</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    to generate unique, unpredictable salt values that prevent rainbow table</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    attacks and ensure each password hash is unique even for identical passwords.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, default_length: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> DEFAULT_SALT_LENGTH</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"system_random\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Initialize salt generator with security parameters.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            default_length: Default salt length in bytes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            algorithm: Random generation algorithm (currently only \"system_random\")</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate default_length using validate_salt_length()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Store default_length and algorithm as instance variables</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Initialize any monitoring counters (salts_generated, errors_encountered)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Reject invalid parameters immediately to fail fast</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_salt</span><span style=\"color:#E1E4E8\">(self, length: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Generate cryptographically secure random salt.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            length: Salt length in bytes (uses default if None)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Random salt as bytes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            SaltGenerationError: If salt generation fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ParameterValidationError: If length parameter is invalid</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Use self.default_length if length is None</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate length parameter using validate_salt_length()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If validation fails, raise ParameterValidationError with validation.errors</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Use secrets.token_bytes(length) to generate cryptographically secure random bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Validate that returned bytes are not all zeros (basic sanity check)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Update internal counters (self.salts_generated += 1)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return the random bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Wrap secrets.token_bytes() in try/except to catch OS-level entropy errors</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_salt_string</span><span style=\"color:#E1E4E8\">(self, length: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                           format_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> DEFAULT_SALT_FORMAT</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Generate salt and encode as string for text storage.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            length: Salt length in bytes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            format_name: Output format (\"binary\", \"base64\", or \"hex\")</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Encoded salt as string</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            SaltGenerationError: If salt generation fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ParameterValidationError: If parameters are invalid</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate format_name using validate_salt_format()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call self.generate_salt(length) to get raw bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Encode bytes based on format_name:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - SALT_FORMAT_BASE64: use base64.b64encode().decode('ascii')</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - SALT_FORMAT_HEX: use salt_bytes.hex()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - SALT_FORMAT_BINARY: raise error (binary data can't be string)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return encoded string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Handle encoding errors by raising SaltGenerationError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> generate_salt_with_metadata</span><span style=\"color:#E1E4E8\">(self, length: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Generate salt with additional metadata for monitoring and debugging.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            length: Salt length in bytes</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dictionary with salt bytes, length, timestamp, and generation info</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Record start_time = time.time() for performance monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Call self.generate_salt(length) to generate salt bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate generation_time_ms = (time.time() - start_time) * 1000</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Build result dictionary with keys:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - 'salt': salt bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - 'length': actual length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - 'generated_at': datetime.now().isoformat()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - 'generation_time_ms': time taken</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - 'algorithm': self.algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return result dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: This method is useful for testing and monitoring salt generation performance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify_salt_uniqueness</span><span style=\"color:#E1E4E8\">(self, password_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              sample_size: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Generate multiple salts and verify statistical uniqueness.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Used for testing and system validation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            password_count: Simulated number of passwords in system</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            sample_size: Number of salts to generate for testing</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dictionary with uniqueness analysis results</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate sample_size salts using self.generate_salt()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check for duplicate salts using set() or Counter</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate collision probability based on birthday paradox</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Compare against theoretical collision probability for salt length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return analysis with keys:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - 'sample_size': number of salts generated</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - 'unique_count': number of unique salts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - 'collision_count': number of collisions found</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - 'theoretical_collision_prob': expected probability</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - 'actual_collision_rate': observed rate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        #         - 'uniqueness_acceptable': boolean assessment</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: For 128-bit salts, collision probability should be negligible for reasonable sample sizes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_statistics</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get salt generation statistics for monitoring.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Return dictionary with internal counters and configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Include: salts_generated, default_length, algorithm, errors_encountered</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Add current timestamp as 'statistics_generated_at'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Don't include any actual salt values in statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>Python Cryptographic Random Generation:</strong></p>\n<ul>\n<li>Always use <code>secrets</code> module, never <code>random</code> module for cryptographic purposes</li>\n<li><code>secrets.token_bytes(n)</code> generates <code>n</code> cryptographically secure random bytes</li>\n<li><code>secrets.token_hex(n)</code> generates <code>2n</code> character hex string (n bytes worth)</li>\n<li>Handle <code>OSError</code> from <code>secrets</code> functions - indicates entropy source problems</li>\n</ul>\n<p><strong>Error Handling Best Practices:</strong></p>\n<ul>\n<li>Use custom exception types (<code>SaltGenerationError</code>) rather than generic exceptions</li>\n<li>Include diagnostic information in exception messages (requested length, available entropy)</li>\n<li>Log generation failures for monitoring but never log actual salt values</li>\n<li>Fail fast on configuration errors rather than using unsafe defaults</li>\n</ul>\n<p><strong>Performance Considerations:</strong></p>\n<ul>\n<li>Salt generation is typically fast (microseconds) but can vary with system load</li>\n<li>Don&#39;t cache salts - generate fresh for each password</li>\n<li>Monitor generation times to detect entropy source health issues</li>\n<li>Consider rate limiting in high-throughput scenarios to prevent entropy exhaustion</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the <code>SaltGenerator</code> component, verify correct behavior with these tests:</p>\n<p><strong>Command to run:</strong> <code>python -m pytest src/salt_generation/test_salt_generation.py -v</code></p>\n<p><strong>Expected output:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>test_generate_salt_length ✓ - Generates salts of requested length\ntest_generate_salt_uniqueness ✓ - All generated salts are unique\ntest_generate_salt_randomness ✓ - Salts pass basic randomness checks\ntest_invalid_length_rejection ✓ - Rejects salts shorter than minimum\ntest_format_encoding ✓ - Properly encodes salts in different formats</code></pre></div>\n\n<p><strong>Manual verification steps:</strong></p>\n<ol>\n<li>Generate 1000 salts and verify all are unique: <code>salt_gen.verify_salt_uniqueness(10000)</code></li>\n<li>Test minimum length enforcement: try generating 8-byte salt (should fail)</li>\n<li>Test format encoding: generate salt in Base64 and hex formats</li>\n<li>Monitor generation timing: typical generation should take &lt; 1ms</li>\n</ol>\n<p><strong>Signs something is wrong:</strong></p>\n<ul>\n<li><strong>Symptom</strong>: All generated salts are identical → <strong>Cause</strong>: Using <code>random</code> instead of <code>secrets</code></li>\n<li><strong>Symptom</strong>: Salt generation raises <code>OSError</code> → <strong>Cause</strong>: Entropy exhaustion, test in VM with more entropy</li>\n<li><strong>Symptom</strong>: Base64 encoded salts contain invalid characters → <strong>Cause</strong>: Encoding raw bytes incorrectly</li>\n<li><strong>Symptom</strong>: Validation always fails → <strong>Cause</strong>: Length validation logic incorrect</li>\n</ul>\n<h2 id=\"basic-hashing-component\">Basic Hashing Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 1 (Basic Hashing with Salt)</p>\n</blockquote>\n<h3 id=\"mental-model-the-sealed-envelope-authentication-system\">Mental Model: The Sealed Envelope Authentication System</h3>\n<p>Think of the basic hashing component like a postal authentication system for confidential documents. When someone sends a confidential message, they don&#39;t just put it in a plain envelope that anyone could intercept and read. Instead, they use a sophisticated sealing process: they mix their message with a unique, unpredictable substance (like invisible ink with a random chemical composition), then run the entire mixture through a document shredder that creates a distinctive pattern of confetti. The resulting confetti pattern becomes the &quot;proof&quot; that the original message existed, without revealing what the message actually said.</p>\n<p>Later, when someone claims to have the original message, the authentication process reverses this: they mix their claimed message with the same random substance (which was stored alongside the confetti pattern), shred it the same way, and check if the new confetti pattern matches the stored one. If the patterns match exactly, the message is authentic. If even one word was different, the confetti patterns would be completely different due to the chaotic nature of the shredding process.</p>\n<p>The <code>BasicHasher</code> component implements this sealed envelope system for passwords. It combines each password with a unique random salt (the invisible ink), runs the mixture through SHA-256 hashing (the document shredder), and stores both the resulting hash (confetti pattern) and the salt for later verification. The component also ensures that the comparison process takes exactly the same amount of time regardless of whether the password is correct or incorrect, preventing attackers from using timing differences to gradually guess the password.</p>\n<h3 id=\"hash-computation-algorithm\">Hash Computation Algorithm</h3>\n<p>The hash computation process transforms a plain password into a cryptographically secure representation that cannot be reversed to recover the original password. This transformation involves carefully combining the password with random data before applying the hash function to prevent precomputed attack strategies.</p>\n<p>The <code>BasicHasher</code> component implements a systematic approach to password hashing that builds upon the salt generation capabilities established in the previous component. The hasher maintains a reference to a <code>SaltGenerator</code> instance and uses SHA-256 as its underlying cryptographic primitive. This combination provides the foundation for secure password storage while remaining computationally efficient for legitimate authentication attempts.</p>\n<blockquote>\n<p><strong>Decision: Salt-Password Concatenation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: The system must combine the password with the salt before hashing, and the order and method of combination affects security properties and implementation complexity.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Simple concatenation (salt + password)</li>\n<li>Interleaved combination (alternating salt and password bytes)</li>\n<li>HMAC-style construction with salt as key</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Simple concatenation with salt prepended to password</li>\n<li><strong>Rationale</strong>: Simple concatenation provides equivalent security to more complex schemes when using a cryptographically secure hash function like SHA-256, while being easier to implement correctly and debug. The prepended salt position follows common cryptographic library conventions and ensures the salt affects the hash computation from the first block.</li>\n<li><strong>Consequences</strong>: Enables straightforward implementation with minimal error potential, maintains compatibility with standard practices, and provides full protection against rainbow table attacks.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Concatenation Strategy</th>\n<th>Security Level</th>\n<th>Implementation Complexity</th>\n<th>Performance</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Salt + Password</td>\n<td>High</td>\n<td>Low</td>\n<td>Fast</td>\n<td>✓</td>\n</tr>\n<tr>\n<td>Interleaved bytes</td>\n<td>High</td>\n<td>Medium</td>\n<td>Slower</td>\n<td></td>\n</tr>\n<tr>\n<td>HMAC construction</td>\n<td>High</td>\n<td>High</td>\n<td>Slower</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>The hash computation algorithm follows a precise sequence of steps that ensures consistent and secure processing of password data:</p>\n<ol>\n<li><p><strong>Input Validation</strong>: The algorithm begins by validating that the input password is provided as a string or bytes object and that it meets basic length requirements (not empty, not exceeding reasonable maximum length).</p>\n</li>\n<li><p><strong>Salt Generation Invocation</strong>: The hasher calls its <code>SaltGenerator</code> instance to produce a cryptographically random salt of the configured length (typically 32 bytes for enhanced security).</p>\n</li>\n<li><p><strong>Encoding Normalization</strong>: The password string undergoes UTF-8 encoding to convert it into a consistent byte representation, ensuring that identical passwords produce identical byte sequences regardless of how they were input.</p>\n</li>\n<li><p><strong>Salt-Password Concatenation</strong>: The algorithm concatenates the raw salt bytes directly with the UTF-8 encoded password bytes, placing the salt at the beginning of the combined sequence to ensure it influences the hash computation from the first hash block.</p>\n</li>\n<li><p><strong>SHA-256 Hash Computation</strong>: The concatenated byte sequence passes through the SHA-256 hash function, which produces a deterministic 256-bit (32-byte) hash output that appears random and cannot be reversed to recover the input.</p>\n</li>\n<li><p><strong>Result Structure Creation</strong>: The algorithm constructs a <code>PasswordHashRecord</code> containing the original salt, the computed hash, algorithm metadata, and timestamp information for future verification needs.</p>\n</li>\n<li><p><strong>Security Metadata Population</strong>: The hash record receives additional security metadata including the algorithm name (&quot;sha256_with_salt&quot;), version identifier, and creation timestamp for audit and migration purposes.</p>\n</li>\n</ol>\n<p>The <code>hash_password</code> method implements this algorithm with careful attention to memory management and error handling:</p>\n<table>\n<thead>\n<tr>\n<th>Method Component</th>\n<th>Input Type</th>\n<th>Output Type</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>password</code> parameter</td>\n<td><code>str</code> or <code>bytes</code></td>\n<td>N/A</td>\n<td>Raw password to be hashed</td>\n</tr>\n<tr>\n<td><code>salt</code> parameter</td>\n<td><code>bytes</code> (optional)</td>\n<td>N/A</td>\n<td>Pre-generated salt or None for auto-generation</td>\n</tr>\n<tr>\n<td>Salt generation</td>\n<td>N/A</td>\n<td><code>bytes</code></td>\n<td>Cryptographically random salt</td>\n</tr>\n<tr>\n<td>UTF-8 encoding</td>\n<td><code>str</code></td>\n<td><code>bytes</code></td>\n<td>Normalized password representation</td>\n</tr>\n<tr>\n<td>Concatenation</td>\n<td><code>bytes</code> + <code>bytes</code></td>\n<td><code>bytes</code></td>\n<td>Combined salt and password</td>\n</tr>\n<tr>\n<td>SHA-256 hashing</td>\n<td><code>bytes</code></td>\n<td><code>bytes</code></td>\n<td>Irreversible hash computation</td>\n</tr>\n<tr>\n<td>Record creation</td>\n<td>Multiple inputs</td>\n<td><code>PasswordHashRecord</code></td>\n<td>Complete hash information package</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>The critical insight here is that the salt must be generated fresh for each password hashing operation, never reused across different passwords, and stored alongside the hash for verification. Reusing salts across passwords would allow attackers to optimize their attacks across multiple accounts simultaneously.</p>\n</blockquote>\n<p><strong>Walk-through Example</strong>: Consider hashing the password &quot;SecurePass123&quot; with a randomly generated 32-byte salt. The salt generation produces bytes like <code>[0x4a, 0x7b, 0x2f, ...]</code> (32 bytes total). The password encodes to UTF-8 bytes <code>[0x53, 0x65, 0x63, 0x75, 0x72, 0x65, 0x50, 0x61, 0x73, 0x73, 0x31, 0x32, 0x33]</code>. Concatenation produces a 45-byte sequence starting with the 32 salt bytes followed by the 13 password bytes. SHA-256 processes this combined sequence and outputs a 32-byte hash like <code>[0xa4, 0xd2, 0x9e, ...]</code>. The resulting <code>PasswordHashRecord</code> stores both the original salt and the computed hash, enabling future verification of the same password.</p>\n<h3 id=\"timing-attack-prevention\">Timing Attack Prevention</h3>\n<p>Timing attacks represent a subtle but serious vulnerability in password verification systems where attackers can extract information about stored passwords by measuring how long verification operations take to complete. These attacks exploit the fact that many comparison operations terminate early when they encounter the first differing byte, causing shorter execution times for incorrect guesses that differ early in the sequence compared to incorrect guesses that match more of the stored hash.</p>\n<p>The <code>BasicHasher</code> component implements <strong>constant-time comparison</strong> techniques to ensure that password verification operations consume identical amounts of time regardless of whether the provided password is correct, incorrect, or how many bytes of the computed hash match the stored hash. This timing consistency prevents attackers from using execution time measurements to gradually deduce information about the stored password hashes.</p>\n<blockquote>\n<p><strong>Decision: Constant-Time Comparison Implementation Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Password verification must compare computed hashes with stored hashes without leaking timing information that could enable side-channel attacks.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Built-in language comparison operators (<code>==</code>, <code>equals()</code>)</li>\n<li>Custom byte-by-byte XOR accumulation</li>\n<li>Cryptographic library constant-time comparison functions</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Custom XOR accumulation with full-length processing</li>\n<li><strong>Rationale</strong>: Built-in operators typically use optimized short-circuit logic that terminates on first difference, creating timing variations. Custom implementation provides full control over timing behavior and doesn&#39;t depend on external library availability. XOR accumulation processes every byte regardless of matches, ensuring consistent timing.</li>\n<li><strong>Consequences</strong>: Eliminates timing side-channel vulnerabilities at the cost of slightly more complex implementation and marginally slower comparisons for obviously incorrect inputs.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Comparison Approach</th>\n<th>Timing Consistency</th>\n<th>Implementation Complexity</th>\n<th>Library Dependency</th>\n<th>Chosen?</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Built-in operators</td>\n<td>Poor (short-circuit)</td>\n<td>Low</td>\n<td>None</td>\n<td></td>\n</tr>\n<tr>\n<td>XOR accumulation</td>\n<td>Excellent</td>\n<td>Medium</td>\n<td>None</td>\n<td>✓</td>\n</tr>\n<tr>\n<td>Library functions</td>\n<td>Excellent</td>\n<td>Low</td>\n<td>High</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>The timing attack vulnerability manifests when verification code uses standard comparison operations that optimize for speed by returning immediately upon finding the first differing byte. An attacker can exploit this by:</p>\n<ol>\n<li><p><strong>Baseline Measurement</strong>: Measuring the time required for obviously incorrect password attempts to establish baseline verification timing.</p>\n</li>\n<li><p><strong>Systematic Probing</strong>: Attempting password guesses designed to match progressively more bytes of the actual hash, looking for timing increases that indicate longer partial matches.</p>\n</li>\n<li><p><strong>Statistical Analysis</strong>: Performing multiple timing measurements for each guess to filter out system noise and identify consistent timing patterns.</p>\n</li>\n<li><p><strong>Progressive Reconstruction</strong>: Using timing differences to gradually reconstruct information about the stored hash, potentially enabling more efficient brute force attacks.</p>\n</li>\n</ol>\n<p>The <code>constant_time_compare</code> function implements timing attack resistance through several carefully designed mechanisms:</p>\n<p><strong>Algorithm Steps for Constant-Time Comparison</strong>:</p>\n<ol>\n<li><p><strong>Length Preprocessing</strong>: The function first checks if the two input byte sequences have different lengths, but continues processing rather than returning immediately to avoid length-based timing leaks.</p>\n</li>\n<li><p><strong>Accumulator Initialization</strong>: An integer accumulator variable initializes to zero and will collect the XOR results of all byte comparisons throughout the entire comparison process.</p>\n</li>\n<li><p><strong>Full-Length Iteration</strong>: The function iterates through every byte position in both sequences, always processing the full length of the longer sequence to ensure consistent iteration counts.</p>\n</li>\n<li><p><strong>Byte-Wise XOR Accumulation</strong>: For each byte position, the function XORs the corresponding bytes from both sequences and accumulates the result, ensuring that identical bytes contribute zero to the accumulator while different bytes contribute non-zero values.</p>\n</li>\n<li><p><strong>Padding Handling</strong>: When sequences have different lengths, the shorter sequence is effectively padded with zero bytes for comparison purposes, ensuring length differences still produce non-zero accumulator results.</p>\n</li>\n<li><p><strong>Final Result Determination</strong>: After processing all byte positions, the function returns True if and only if the accumulator equals zero (indicating all bytes matched) and the lengths were identical.</p>\n</li>\n<li><p><strong>Timing Consistency Verification</strong>: The entire process consumes the same number of CPU cycles regardless of where differences occur in the sequences or whether the sequences match completely.</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Function Component</th>\n<th>Input Processing</th>\n<th>Timing Behavior</th>\n<th>Security Property</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Length check</td>\n<td>Always performed</td>\n<td>Constant</td>\n<td>Prevents length-based timing leaks</td>\n</tr>\n<tr>\n<td>XOR accumulation</td>\n<td>All bytes processed</td>\n<td>Constant per byte</td>\n<td>Eliminates position-based timing leaks</td>\n</tr>\n<tr>\n<td>Loop iteration</td>\n<td>Full length always</td>\n<td>Constant iteration count</td>\n<td>Prevents short-circuit timing variations</td>\n</tr>\n<tr>\n<td>Result computation</td>\n<td>Single comparison</td>\n<td>Constant</td>\n<td>No early termination timing leaks</td>\n</tr>\n</tbody></table>\n<p>The <code>verify_password</code> method integrates constant-time comparison into the complete verification workflow:</p>\n<ol>\n<li><p><strong>Hash Recomputation</strong>: The method takes the provided password, extracts the stored salt from the <code>PasswordHashRecord</code>, and recomputes the hash using identical steps to the original hashing process.</p>\n</li>\n<li><p><strong>Constant-Time Hash Comparison</strong>: The method invokes <code>constant_time_compare</code> to compare the newly computed hash with the stored hash from the record, ensuring timing consistency regardless of the comparison outcome.</p>\n</li>\n<li><p><strong>Boolean Result Return</strong>: The method returns True if the hashes match (indicating correct password) or False otherwise, with identical timing characteristics for both cases.</p>\n</li>\n</ol>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Using Built-in Comparison Operators</strong>\nMany developers instinctively use language built-in comparison operators like <code>==</code> in Python or <code>bytes.Equal()</code> in Go for hash comparison. These operators are optimized for performance and typically implement short-circuit logic that returns False as soon as the first differing byte is found. This creates a timing side-channel where incorrect passwords that happen to match more bytes of the stored hash take longer to reject than passwords that differ in early bytes. Attackers can exploit this timing difference to gradually extract information about the stored hash. The fix is to always use constant-time comparison functions that process every byte of both sequences regardless of where differences occur.</p>\n</blockquote>\n<p><strong>Timing Attack Demonstration Example</strong>: Consider an attacker probing a system that uses vulnerable comparison logic. The stored hash begins with bytes <code>[0xa4, 0xd2, 0x9e, 0x7f, ...]</code>. The attacker submits passwords that generate hashes beginning with <code>[0x12, ...]</code>, <code>[0xa4, 0x13, ...]</code>, and <code>[0xa4, 0xd2, 0x15, ...]</code>. The first guess fails immediately at byte 0, taking ~10 microseconds. The second guess fails at byte 1, taking ~12 microseconds. The third guess fails at byte 2, taking ~14 microseconds. This timing progression reveals that the stored hash begins with <code>[0xa4, 0xd2, ...]</code>, giving the attacker partial information to optimize subsequent attacks. With constant-time comparison, all three guesses would take exactly ~50 microseconds regardless of where they differ, preventing information leakage.</p>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Salt Reuse Across Password Changes</strong>\nSome implementations attempt to &quot;optimize&quot; storage by reusing the same salt when a user changes their password, thinking this saves space or computation time. This approach catastrophically weakens security because it allows attackers who compromise one hash to immediately apply the same rainbow table or precomputed attacks to the user&#39;s new password. Each password hashing operation must generate a fresh, cryptographically random salt, even for the same user account. The storage overhead of additional salt bytes is negligible compared to the security benefit.</p>\n<p>⚠️ <strong>Pitfall: Concatenating Password Before Salt</strong>\nWhile either concatenation order (salt+password or password+salt) provides equivalent cryptographic security, choosing password+salt creates compatibility issues with many standard tools and libraries that expect salt-first ordering. More critically, some developers mistakenly believe they can optimize by putting the password first and truncating the hash computation early, which would eliminate the salt&#39;s protection entirely. Always concatenate salt+password to follow established conventions and avoid implementation mistakes.</p>\n<p>⚠️ <strong>Pitfall: Converting Strings to Bytes Inconsistently</strong>\nPassword strings must undergo consistent encoding to bytes before hashing, typically using UTF-8. Some implementations mix encoding schemes (UTF-8 for registration, Latin-1 for verification) or apply platform-specific default encodings that vary between systems. This creates a situation where the same password string produces different byte sequences and therefore different hashes, making verification impossible. Always explicitly specify UTF-8 encoding for password-to-bytes conversion and use the same encoding consistently across all operations.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Timing Attack Vectors Beyond Hash Comparison</strong>\nWhile implementing constant-time hash comparison is crucial, some developers focus only on the final comparison step and ignore timing leaks in other parts of the verification process. For example, spending different amounts of time on salt extraction, hash recomputation setup, or error handling based on the input characteristics can still leak information. The entire verification function should maintain consistent timing characteristics, not just the final comparison operation.</p>\n<p>⚠️ <strong>Pitfall: Inadequate Error Information in Hash Records</strong>\nWhen hash computation fails due to invalid inputs, memory exhaustion, or algorithm unavailability, some implementations either crash the application or return incomplete hash records that cause verification failures later. The <code>BasicHasher</code> should validate inputs thoroughly, handle all anticipated error conditions gracefully, and ensure that any successfully returned <code>PasswordHashRecord</code> contains all information needed for future verification. Failed operations should raise specific exception types that calling code can handle appropriately.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Hash Library</td>\n<td><code>hashlib</code> (Python standard library)</td>\n<td><code>cryptography</code> library with FIPS compliance</td>\n</tr>\n<tr>\n<td>Salt Generation</td>\n<td><code>secrets</code> module (Python 3.6+)</td>\n<td>Hardware security module integration</td>\n</tr>\n<tr>\n<td>Timing Functions</td>\n<td><code>time.perf_counter()</code> for benchmarking</td>\n<td><code>timeit</code> module for statistical analysis</td>\n</tr>\n<tr>\n<td>Serialization</td>\n<td>JSON with base64 encoding</td>\n<td>Protocol Buffers with binary efficiency</td>\n</tr>\n<tr>\n<td>Testing</td>\n<td><code>unittest</code> with manual test cases</td>\n<td><code>pytest</code> with property-based testing</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<p>The basic hashing component integrates into the overall project structure as a focused module with clear dependencies:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  src/password_hashing/\n    __init__.py                 ← package initialization\n    salt_generator.py           ← SaltGenerator implementation (from previous milestone)\n    basic_hasher.py            ← BasicHasher implementation (this component)\n    data_models.py             ← PasswordHashRecord and related structures\n    exceptions.py              ← Custom exception classes\n    utils/\n      timing_utils.py          ← Constant-time comparison utilities\n      validation_utils.py      ← Input validation helpers\n  tests/\n    test_basic_hasher.py       ← BasicHasher unit tests\n    test_timing_attacks.py     ← Timing attack resistance verification\n    test_integration.py        ← End-to-end password hashing workflows\n  examples/\n    basic_usage.py             ← Simple usage demonstrations</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>File: <code>src/password_hashing/exceptions.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Custom exception classes for password hashing operations.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PasswordHashingError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception class for password hashing failures.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SaltGenerationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PasswordHashingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when salt generation fails due to entropy or system issues.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HashComputationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PasswordHashingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when hash computation fails due to algorithm or input issues.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PasswordHashingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when input validation fails due to invalid parameters.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>File: <code>src/password_hashing/utils/timing_utils.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"Timing attack prevention utilities.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Dict, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> constant_time_compare</span><span style=\"color:#E1E4E8\">(a: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, b: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Compare two byte sequences in constant time to prevent timing attacks.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        a: First byte sequence</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        b: Second byte sequence</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        True if sequences are identical, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Note:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        This function always processes the full length of both sequences</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        and takes the same amount of time regardless of where differences</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        occur or whether the sequences match.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Implementation provided as starter code since timing attacks</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # are subtle and easy to implement incorrectly</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(a) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(b):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Still process bytes to maintain timing consistency</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#6A737D\">  # Mark as different due to length mismatch</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Process all bytes in the longer sequence</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_len </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> max</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(a), </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(b)) </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> a </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(max_len):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        byte_a </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> a[i] </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(a) </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        byte_b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b[i] </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(b) </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">|=</span><span style=\"color:#E1E4E8\"> byte_a </span><span style=\"color:#F97583\">^</span><span style=\"color:#E1E4E8\"> byte_b</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> result </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> verify_timing_safety</span><span style=\"color:#E1E4E8\">(func, test_cases: List[Any], tolerance_ms: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Verify that a function has consistent timing across different inputs.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        func: Function to test for timing consistency</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        test_cases: List of input parameters to test</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        tolerance_ms: Maximum acceptable timing variation in milliseconds</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Dictionary with timing analysis results</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timings </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> case </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> test_cases:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        func(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">case </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(case, </span><span style=\"color:#79B8FF\">tuple</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> (case,))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        end_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timings.append((end_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Convert to milliseconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    min_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> min</span><span style=\"color:#E1E4E8\">(timings)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> max</span><span style=\"color:#E1E4E8\">(timings)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    avg_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> sum</span><span style=\"color:#E1E4E8\">(timings) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(timings)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    variation </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> max_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> min_time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'min_time_ms'</span><span style=\"color:#E1E4E8\">: min_time,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'max_time_ms'</span><span style=\"color:#E1E4E8\">: max_time,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'avg_time_ms'</span><span style=\"color:#E1E4E8\">: avg_time,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'variation_ms'</span><span style=\"color:#E1E4E8\">: variation,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'is_timing_safe'</span><span style=\"color:#E1E4E8\">: variation </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> tolerance_ms,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'timing_measurements'</span><span style=\"color:#E1E4E8\">: timings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>File: <code>src/password_hashing/basic_hasher.py</code></strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"BasicHasher implementation for SHA-256 password hashing with salt.\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Any</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .salt_generator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SaltGenerator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .data_models </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PasswordHashRecord</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> HashComputationError, ValidationError</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .utils.timing_utils </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> constant_time_compare</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BasicHasher</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Implements SHA-256 based password hashing with cryptographic salt.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This hasher provides the foundation for secure password storage by</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    combining passwords with random salts before hashing to prevent</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    rainbow table attacks and ensure unique hashes for identical passwords.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, salt_generator: Optional[SaltGenerator] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">, algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"sha256_with_salt\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize salt_generator (create default if None provided)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Store algorithm identifier for hash record metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate that algorithm parameter is supported</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Store both salt_generator and algorithm as instance variables</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> hash_password</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, salt: Optional[</span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Hash a password with cryptographic salt using SHA-256.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            password: Plain text password to hash</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            salt: Optional pre-generated salt (generates new salt if None)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dictionary containing hash record information</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ValidationError: If password is invalid</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            HashComputationError: If hashing operation fails</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate password input (not None, not empty, reasonable length)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Generate salt if not provided (use self.salt_generator.generate_salt())</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Encode password to UTF-8 bytes for consistent processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Concatenate salt bytes with password bytes (salt first)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Compute SHA-256 hash of concatenated bytes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Create PasswordHashRecord with salt, hash, and metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return hash record as dictionary for easy serialization</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use hashlib.sha256() and .digest() for hash computation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Include algorithm, version, and timestamp in hash record</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify_password</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, hash_record: PasswordHashRecord) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Verify a password against a stored hash record using constant-time comparison.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            password: Plain text password to verify</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            hash_record: Stored hash record containing salt and hash</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if password matches the hash record, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Note:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            This method uses constant-time comparison to prevent timing attacks</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            that could leak information about the stored hash.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate input parameters (password not None, hash_record valid)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract salt from hash record</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Recompute hash using the same algorithm as original hashing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Use constant_time_compare to compare computed hash with stored hash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return comparison result (True for match, False for mismatch)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Reuse hash_password method with extracted salt for consistency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Handle any exceptions from hash computation gracefully</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _validate_password_input</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Validate password input for security and correctness requirements.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            password: Password string to validate</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ValidationError: If password fails validation checks</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check that password is not None</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check that password is not empty string</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check that password length is reasonable (not too long for DoS prevention)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Verify password is string type (not bytes or other types)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Maximum reasonable password length might be 1000-4096 characters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Raise ValidationError with descriptive message for each failure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>Python-Specific Implementation Details:</strong></p>\n<ul>\n<li>Use <code>hashlib.sha256()</code> from the standard library for hash computation rather than third-party libraries for maximum compatibility</li>\n<li>Call <code>.digest()</code> on hash objects to get raw bytes rather than <code>.hexdigest()</code> which returns hex strings and wastes storage space</li>\n<li>Use <code>secrets.token_bytes()</code> for salt generation as it provides cryptographically secure randomness on all platforms</li>\n<li>Store the <code>SaltGenerator</code> instance as <code>self.salt_generator</code> to enable dependency injection and testing flexibility</li>\n<li>Import <code>datetime.datetime.now()</code> for timestamp generation, but consider using UTC with <code>datetime.utcnow()</code> for consistency across timezones</li>\n<li>Handle encoding explicitly with <code>password.encode(&#39;utf-8&#39;)</code> rather than relying on default encoding behavior</li>\n<li>Use type hints consistently (<code>bytes</code>, <code>str</code>, <code>Optional[bytes]</code>) to catch type-related errors early during development</li>\n</ul>\n<p><strong>Error Handling Patterns:</strong></p>\n<ul>\n<li>Wrap <code>hashlib.sha256()</code> calls in try-except blocks to catch potential system-level failures</li>\n<li>Validate all inputs at method entry points rather than assuming calling code provides correct data</li>\n<li>Raise custom exception types (<code>ValidationError</code>, <code>HashComputationError</code>) rather than generic <code>Exception</code> to enable targeted error handling</li>\n<li>Include descriptive error messages that help developers debug issues without revealing sensitive information</li>\n</ul>\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the <code>BasicHasher</code> component, verify correct functionality through these concrete checkpoints:</p>\n<p><strong>Unit Test Execution:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#79B8FF\">cd</span><span style=\"color:#9ECBFF\"> project-root/</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_basic_hasher.py</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p><strong>Expected Test Output:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>tests/test_basic_hasher.py::test_hash_password_generates_unique_salts PASSED\ntests/test_basic_hasher.py::test_hash_password_different_passwords_different_hashes PASSED  \ntests/test_basic_hasher.py::test_verify_password_correct_password_returns_true PASSED\ntests/test_basic_hasher.py::test_verify_password_incorrect_password_returns_false PASSED\ntests/test_basic_hasher.py::test_constant_time_comparison PASSED\n==================== 5 passed in 0.12s ====================</code></pre></div>\n\n<p><strong>Manual Verification Script:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> src.password_hashing.basic_hasher </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> BasicHasher</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Test basic functionality</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">hasher </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BasicHasher()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">password </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"TestPassword123\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Hash the password</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">hash_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hasher.hash_password(password)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Hash computed successfully: </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(hash_result[</span><span style=\"color:#9ECBFF\">'hash'</span><span style=\"color:#E1E4E8\">])</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Salt generated: </span><span style=\"color:#79B8FF\">{len</span><span style=\"color:#E1E4E8\">(hash_result[</span><span style=\"color:#9ECBFF\">'salt'</span><span style=\"color:#E1E4E8\">])</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> bytes\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify correct password</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">verification_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hasher.verify_password(password, hash_result)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Correct password verification: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">verification_result</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Should be True</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Verify incorrect password</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">wrong_verification </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hasher.verify_password(</span><span style=\"color:#9ECBFF\">\"WrongPassword\"</span><span style=\"color:#E1E4E8\">, hash_result)  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Incorrect password verification: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">wrong_verification</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Should be False</span></span></code></pre></div>\n\n<p><strong>Security Property Verification:</strong></p>\n<ul>\n<li><strong>Salt Uniqueness</strong>: Hash the same password 100 times and verify all salts are different</li>\n<li><strong>Hash Uniqueness</strong>: Verify that identical passwords with different salts produce different hashes  </li>\n<li><strong>Timing Consistency</strong>: Use the provided <code>verify_timing_safety</code> function to confirm verification timing is consistent</li>\n<li><strong>Round-Trip Consistency</strong>: Ensure any password that hashes successfully can be verified correctly</li>\n</ul>\n<p><strong>Signs of Implementation Issues:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Check</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Same hash for same password</td>\n<td>Salt not being generated or used</td>\n<td>Check if salt varies between calls</td>\n<td>Ensure fresh salt generation per hash</td>\n</tr>\n<tr>\n<td>Verification always returns False</td>\n<td>Encoding inconsistency</td>\n<td>Print byte values during hash/verify</td>\n<td>Use consistent UTF-8 encoding</td>\n</tr>\n<tr>\n<td>Timing attack test fails</td>\n<td>Using built-in comparison</td>\n<td>Time multiple verification calls</td>\n<td>Implement constant_time_compare correctly</td>\n</tr>\n<tr>\n<td>Hash record missing fields</td>\n<td>Incomplete record construction</td>\n<td>Check PasswordHashRecord contents</td>\n<td>Include all required metadata fields</td>\n</tr>\n<tr>\n<td>Import errors</td>\n<td>Missing dependencies</td>\n<td>Check module structure</td>\n<td>Verify all files in correct locations</td>\n</tr>\n</tbody></table>\n<h2 id=\"key-stretching-component\">Key Stretching Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 2 (Key Stretching)</p>\n</blockquote>\n<h3 id=\"mental-model-the-time-lock-vault-analogy\">Mental Model: The Time Lock Vault Analogy</h3>\n<p>Think of key stretching like a bank&#39;s time lock vault mechanism. A traditional safe might take a few seconds for someone with the combination to open, but a skilled safecracker could potentially break it in hours using specialized tools. A time lock vault, however, has a built-in delay mechanism—even with the correct combination, the vault takes exactly 10 minutes to open, no matter what. This delay doesn&#39;t inconvenience legitimate bank employees (10 minutes is acceptable), but it makes a brute force attack completely impractical—trying 10,000 combinations would take over 69 days of continuous attempts.</p>\n<p>Key stretching works the same way for passwords. While a simple hash like SHA-256 takes microseconds to compute, key stretching algorithms like PBKDF2 intentionally take hundreds of milliseconds by performing thousands of internal hash operations. This delay is barely noticeable to a legitimate user logging in once, but transforms a brute force attack that might take hours into one requiring decades. The &quot;time lock&quot; is implemented through iteration counts—performing the same cryptographic operation thousands of times in sequence, with each round depending on the previous one, making parallel computation impossible.</p>\n<h3 id=\"pbkdf2-algorithm-implementation\">PBKDF2 Algorithm Implementation</h3>\n<p><strong>PBKDF2 (Password-Based Key Derivation Function 2)</strong> represents a fundamental shift from simple hashing to intentionally slow key derivation. Unlike basic hashing where the goal is computational efficiency, PBKDF2&#39;s primary purpose is controlled computational expense. The algorithm transforms a password and salt into a derived key through thousands of iterative HMAC operations, creating what cryptographers call a &quot;computational bottleneck&quot; that equally affects both legitimate users and attackers.</p>\n<h4 id=\"core-pbkdf2-architecture\">Core PBKDF2 Architecture</h4>\n<p>The PBKDF2 algorithm operates through a carefully designed iteration structure that builds upon the cryptographic properties of HMAC (Hash-based Message Authentication Code). The fundamental architecture consists of multiple rounds of HMAC computation, where each round takes the output of the previous round as input, creating a sequential dependency chain that cannot be parallelized or short-circuited.</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Purpose</th>\n<th>Security Property</th>\n<th>Performance Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HMAC-SHA256 Core</td>\n<td>Provides pseudorandom function for each iteration</td>\n<td>Cryptographic strength via proven hash function</td>\n<td>Constant time per iteration</td>\n</tr>\n<tr>\n<td>Iteration Counter</td>\n<td>Tracks current round number in derivation process</td>\n<td>Ensures exact iteration count is performed</td>\n<td>Linear scaling with count</td>\n</tr>\n<tr>\n<td>Block Generator</td>\n<td>Produces multiple output blocks for longer keys</td>\n<td>Enables configurable output key length</td>\n<td>Scales with desired key length</td>\n</tr>\n<tr>\n<td>XOR Accumulator</td>\n<td>Combines intermediate values across iterations</td>\n<td>Prevents intermediate value attacks</td>\n<td>Minimal overhead</td>\n</tr>\n</tbody></table>\n<p>The iteration structure creates what cryptographers term &quot;memory-hard&quot; properties at the algorithmic level—while PBKDF2 doesn&#39;t require significant memory like Argon2, it requires significant time that scales linearly with the iteration count. This time-cost scaling is the crucial security property that makes brute force attacks computationally prohibitive.</p>\n<blockquote>\n<p><strong>Decision: HMAC-SHA256 as PBKDF2 Pseudorandom Function</strong></p>\n<ul>\n<li><strong>Context</strong>: PBKDF2 requires a pseudorandom function (PRF) for its iterative operations, with SHA-1, SHA-256, and other hash functions as options</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>HMAC-SHA1 (original PBKDF2 standard)</li>\n<li>HMAC-SHA256 (stronger hash function)</li>\n<li>HMAC-SHA512 (maximum strength but slower)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use HMAC-SHA256 as the pseudorandom function</li>\n<li><strong>Rationale</strong>: SHA-256 provides significantly stronger cryptographic security than SHA-1 without the performance penalty of SHA-512, and is widely supported across platforms</li>\n<li><strong>Consequences</strong>: Each iteration takes approximately 2x longer than SHA-1 but provides quantum-resistant security properties and compatibility with modern cryptographic standards</li>\n</ul>\n</blockquote>\n<h4 id=\"pbkdf2-internal-algorithm-flow\">PBKDF2 Internal Algorithm Flow</h4>\n<p>The PBKDF2 derivation process follows a precise mathematical specification (RFC 2898) that ensures consistent results across implementations while maintaining the desired security properties. Understanding this internal flow is crucial for both implementation and security analysis.</p>\n<p><img src=\"/api/project/password-hashing/architecture-doc/asset?path=diagrams%2Fpbkdf2-process.svg\" alt=\"PBKDF2 Key Derivation Process\"></p>\n<p>The algorithm operates through the following detailed steps:</p>\n<ol>\n<li><p><strong>Input Validation and Preprocessing</strong>: The function receives the password (as bytes), salt (minimum 16 bytes), iteration count (minimum 100,000), and desired output key length. Input validation ensures the salt meets minimum entropy requirements and the iteration count provides adequate security.</p>\n</li>\n<li><p><strong>Block Count Calculation</strong>: PBKDF2 divides the desired output length into blocks, where each block produces exactly 32 bytes (for SHA-256). The number of blocks required equals <code>ceil(desired_length / 32)</code>, enabling the generation of arbitrarily long derived keys.</p>\n</li>\n<li><p><strong>Block Generation Loop</strong>: For each required block, PBKDF2 performs the complete iteration process independently. This block-wise generation enables parallel computation of different blocks while maintaining the sequential dependency within each block.</p>\n</li>\n<li><p><strong>Initial HMAC Computation</strong>: The first iteration computes <code>HMAC-SHA256(password, salt || block_number)</code> where <code>block_number</code> is a 4-byte big-endian integer. This initial computation incorporates both the salt and block identifier into the derivation process.</p>\n</li>\n<li><p><strong>Iterative HMAC Chain</strong>: For iterations 2 through N, the algorithm computes <code>HMAC-SHA256(password, previous_iteration_result)</code>. This creates a sequential chain where each iteration depends on the complete result of the previous iteration, preventing any computational shortcuts.</p>\n</li>\n<li><p><strong>XOR Accumulation</strong>: Throughout the iteration process, PBKDF2 maintains an accumulator that XORs together the results of every iteration. This accumulation ensures that an attacker cannot skip intermediate iterations—the final result depends on every single iteration being computed correctly.</p>\n</li>\n<li><p><strong>Block Concatenation</strong>: After completing all iterations for all required blocks, the algorithm concatenates the block results and truncates to the exact desired output length.</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Input</th>\n<th>Operation</th>\n<th>Output</th>\n<th>Security Property</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Password, Salt</td>\n<td>Validate inputs meet minimum requirements</td>\n<td>Validated parameters</td>\n<td>Prevents weak inputs</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Desired length</td>\n<td>Calculate required blocks (ceil(length/32))</td>\n<td>Block count</td>\n<td>Enables arbitrary key lengths</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Password, Salt, Block#</td>\n<td>HMAC-SHA256(password, salt||block#)</td>\n<td>Initial block value</td>\n<td>Incorporates salt and position</td>\n</tr>\n<tr>\n<td>4-N</td>\n<td>Password, Previous</td>\n<td>HMAC-SHA256(password, previous_result)</td>\n<td>Iteration result</td>\n<td>Creates computational dependency</td>\n</tr>\n<tr>\n<td>Accumulate</td>\n<td>All iterations</td>\n<td>XOR all iteration results</td>\n<td>Final block value</td>\n<td>Requires complete computation</td>\n</tr>\n<tr>\n<td>Final</td>\n<td>All blocks</td>\n<td>Concatenate and truncate blocks</td>\n<td>Derived key</td>\n<td>Produces final key material</td>\n</tr>\n</tbody></table>\n<h4 id=\"cryptographic-security-properties\">Cryptographic Security Properties</h4>\n<p>PBKDF2&#39;s security effectiveness stems from several carefully designed cryptographic properties that work together to resist various attack vectors. These properties distinguish PBKDF2 from simple iterative hashing approaches that might seem similar but lack crucial security guarantees.</p>\n<p>The <strong>computational amplification</strong> property ensures that password verification requires exactly N HMAC operations, where N is the iteration count. Unlike simple loop constructions, PBKDF2&#39;s sequential dependency prevents attackers from reducing computational costs through parallelization, specialized hardware optimization, or algorithmic shortcuts. Each HMAC operation requires the complete result of the previous operation, creating an unavoidable computational bottleneck.</p>\n<p>The <strong>uniform difficulty scaling</strong> property means that the computational cost increases linearly with iteration count for both legitimate users and attackers. Doubling the iteration count exactly doubles the computation time for password verification, providing predictable security scaling. This linear scaling enables precise tuning of the security-performance trade-off based on available hardware and security requirements.</p>\n<blockquote>\n<p>The critical insight is that PBKDF2&#39;s sequential structure creates &quot;proof of work&quot; requirements—there is no way to verify a password without performing exactly the same computational work required for derivation, making offline attacks computationally equivalent to online attacks in terms of per-attempt cost.</p>\n</blockquote>\n<p>The <strong>avalanche resistance</strong> property ensures that small changes in password, salt, or iteration count produce completely different derived keys. This property prevents attackers from using partial computation results or finding computational shortcuts based on input similarities. The HMAC construction provides this avalanche effect throughout the iteration chain.</p>\n<h4 id=\"implementation-architecture-decisions\">Implementation Architecture Decisions</h4>\n<p>The key stretching component requires careful architectural decisions that balance security, performance, and implementation complexity. These decisions affect both the immediate functionality and long-term maintainability of the password hashing system.</p>\n<blockquote>\n<p><strong>Decision: Configurable vs Fixed Iteration Counts</strong></p>\n<ul>\n<li><strong>Context</strong>: Systems can either use fixed iteration counts for all passwords or allow configuration per password record</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Fixed global iteration count (simpler implementation)</li>\n<li>Per-record configurable counts (flexible but complex)</li>\n<li>Time-based adaptive counts (automatic but unpredictable)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use per-record configurable iteration counts with sensible defaults</li>\n<li><strong>Rationale</strong>: Different passwords may have different security requirements, and iteration counts must increase over time as hardware improves</li>\n<li><strong>Consequences</strong>: Requires storing iteration count with each password hash but enables security evolution and customization</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Implementation Approach</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Complexity</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Fixed Global Count</td>\n<td>Simple configuration, consistent performance</td>\n<td>Cannot evolve security over time</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>Per-Record Configuration</td>\n<td>Flexible security levels, future-proof</td>\n<td>Complex parameter management</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>Adaptive Time-Based</td>\n<td>Automatic hardware scaling</td>\n<td>Unpredictable performance, complex</td>\n<td>High</td>\n</tr>\n</tbody></table>\n<p>The per-record approach enables <strong>algorithm agility</strong> at the parameter level—newer password hashes can use higher iteration counts without requiring migration of existing hashes. This approach also supports different security contexts where some passwords require stronger protection than others.</p>\n<blockquote>\n<p><strong>Decision: Memory-Efficient vs Memory-Hard Implementation</strong></p>\n<ul>\n<li><strong>Context</strong>: PBKDF2 can be implemented to use minimal memory or to deliberately consume significant memory</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Memory-efficient implementation (minimal RAM usage)</li>\n<li>Memory-hard variant (deliberate memory consumption)</li>\n<li>Configurable memory usage (complexity increase)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement memory-efficient PBKDF2 as specified in RFC 2898</li>\n<li><strong>Rationale</strong>: Standard PBKDF2 provides time-based security, and memory-hard requirements are better addressed by dedicated algorithms like Argon2</li>\n<li><strong>Consequences</strong>: Lower memory requirements but potential vulnerability to custom hardware attacks</li>\n</ul>\n</blockquote>\n<p>The memory-efficient approach maintains compatibility with standard PBKDF2 implementations while keeping resource requirements predictable. Memory-hard properties are intentionally deferred to Milestone 3&#39;s Argon2 implementation, maintaining clear separation of algorithmic concerns.</p>\n<h3 id=\"iteration-count-tuning\">Iteration Count Tuning</h3>\n<p><strong>Iteration count tuning</strong> represents one of the most critical security decisions in key stretching implementation. Unlike cryptographic key lengths where &quot;more is always better,&quot; iteration counts require careful balancing between security effectiveness and system usability. The optimal iteration count changes continuously as hardware capabilities improve, requiring systematic approaches to parameter selection and evolution.</p>\n<h4 id=\"performance-security-trade-off-analysis\">Performance-Security Trade-off Analysis</h4>\n<p>The fundamental challenge in iteration count tuning lies in the competing requirements of security and usability. From a security perspective, higher iteration counts provide exponentially better protection against brute force attacks. However, from a usability perspective, longer password verification times can degrade user experience and system responsiveness.</p>\n<table>\n<thead>\n<tr>\n<th>Iteration Count</th>\n<th>Hash Time</th>\n<th>Brute Force Cost (1M attempts)</th>\n<th>User Experience Impact</th>\n<th>Recommendation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>100,000</td>\n<td>~100ms</td>\n<td>~28 hours</td>\n<td>Barely noticeable</td>\n<td>Minimum acceptable</td>\n</tr>\n<tr>\n<td>200,000</td>\n<td>~200ms</td>\n<td>~56 hours</td>\n<td>Acceptable for web</td>\n<td>Recommended default</td>\n</tr>\n<tr>\n<td>500,000</td>\n<td>~500ms</td>\n<td>~140 hours</td>\n<td>Acceptable for desktop</td>\n<td>High security</td>\n</tr>\n<tr>\n<td>1,000,000</td>\n<td>~1000ms</td>\n<td>~280 hours</td>\n<td>Noticeable delay</td>\n<td>Maximum for interactive</td>\n</tr>\n<tr>\n<td>10,000,000</td>\n<td>~10 seconds</td>\n<td>~2800 hours</td>\n<td>Unusable for web</td>\n<td>Batch processing only</td>\n</tr>\n</tbody></table>\n<p>The <strong>computational cost scaling</strong> follows predictable mathematical relationships that enable precise trade-off analysis. Each doubling of iteration count exactly doubles both legitimate authentication time and attacker brute force cost. This linear scaling allows administrators to make informed decisions about acceptable delays versus security improvements.</p>\n<p>The <strong>attack cost analysis</strong> reveals why iteration count tuning is crucial for effective security. Consider a password with 40 bits of entropy (approximately 6-7 random characters). Without key stretching, an attacker with commodity hardware could exhaustively search this space in minutes. With 200,000 PBKDF2 iterations, the same attack requires months of computation, transforming a practical attack into an impractical one.</p>\n<blockquote>\n<p>The key insight is that iteration counts must be chosen based on the weakest passwords in the system, not the strongest ones. A user with a 12-character random password has inherent security regardless of iteration count, but a user with &quot;password123&quot; relies entirely on key stretching for protection.</p>\n</blockquote>\n<h4 id=\"hardware-based-tuning-methodology\">Hardware-Based Tuning Methodology</h4>\n<p>Effective iteration count tuning requires systematic measurement of computational performance across the target deployment environment. Different server configurations, cloud instance types, and client devices will exhibit dramatically different PBKDF2 performance characteristics, necessitating measurement-based parameter selection rather than arbitrary defaults.</p>\n<p>The <strong>benchmark-driven approach</strong> provides the most reliable foundation for iteration count selection. This methodology involves measuring actual PBKDF2 performance on target hardware with representative workloads, then selecting iteration counts that achieve specific timing targets.</p>\n<table>\n<thead>\n<tr>\n<th>Timing Target</th>\n<th>Use Case</th>\n<th>Rationale</th>\n<th>Typical Iteration Count</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>100ms</td>\n<td>High-volume web services</td>\n<td>Minimal impact on request latency</td>\n<td>100,000-150,000</td>\n</tr>\n<tr>\n<td>250ms</td>\n<td>Standard web applications</td>\n<td>Acceptable delay for security</td>\n<td>200,000-300,000</td>\n</tr>\n<tr>\n<td>500ms</td>\n<td>Desktop applications</td>\n<td>Users expect brief delays</td>\n<td>400,000-600,000</td>\n</tr>\n<tr>\n<td>1000ms</td>\n<td>Administrative systems</td>\n<td>Security over convenience</td>\n<td>800,000-1,200,000</td>\n</tr>\n</tbody></table>\n<p>The tuning methodology follows these systematic steps:</p>\n<ol>\n<li><p><strong>Baseline Performance Measurement</strong>: Execute PBKDF2 with known iteration counts on target hardware, measuring both average and 95th percentile timing. This measurement must occur under realistic load conditions to account for CPU contention and thermal throttling.</p>\n</li>\n<li><p><strong>Scaling Factor Calculation</strong>: Determine the linear relationship between iteration count and execution time on the specific hardware configuration. This scaling factor enables accurate prediction of performance for any iteration count.</p>\n</li>\n<li><p><strong>Security Requirement Analysis</strong>: Assess the threat model and determine minimum computational cost requirements for password attacks. Consider both current attack capabilities and projected hardware improvements over the password lifetime.</p>\n</li>\n<li><p><strong>Tolerance Testing</strong>: Validate that selected iteration counts provide acceptable user experience under various load conditions, including peak usage periods and degraded hardware performance.</p>\n</li>\n<li><p><strong>Evolution Planning</strong>: Establish procedures for increasing iteration counts over time as hardware capabilities improve, ensuring long-term security effectiveness.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Decision: Target-Time vs Fixed-Count Parameter Selection</strong></p>\n<ul>\n<li><strong>Context</strong>: Systems can choose iteration counts based on achieving target timing or using predetermined fixed counts</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Fixed iteration counts (simple but hardware-dependent)</li>\n<li>Target timing with measurement (complex but adaptive)</li>\n<li>Hybrid approach with ranges (balanced complexity)</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement target-timing approach with fallback to safe defaults</li>\n<li><strong>Rationale</strong>: Hardware performance varies dramatically across deployments, requiring adaptive parameter selection for consistent security</li>\n<li><strong>Consequences</strong>: Requires runtime performance measurement but provides consistent security across diverse hardware</li>\n</ul>\n</blockquote>\n<h4 id=\"dynamic-iteration-count-management\">Dynamic Iteration Count Management</h4>\n<p>Production password hashing systems must evolve their security parameters over time to maintain effectiveness against improving attack capabilities. Moore&#39;s Law and specialized hardware development continuously reduce the computational cost of password attacks, requiring corresponding increases in iteration counts to maintain equivalent security levels.</p>\n<p>The <strong>security decay problem</strong> represents a fundamental challenge in long-lived password systems. An iteration count that provided strong security in 2020 may offer inadequate protection by 2025 due to hardware improvements. Without systematic parameter evolution, password systems experience gradual security degradation even without explicit vulnerabilities.</p>\n<p><strong>Algorithm agility</strong> at the parameter level provides a solution to security decay through systematic iteration count increases. New password hashes use current recommended iteration counts, while existing hashes remain valid with their original parameters. This approach avoids forced password resets while ensuring new passwords receive optimal protection.</p>\n<table>\n<thead>\n<tr>\n<th>Parameter Evolution Strategy</th>\n<th>Implementation</th>\n<th>Pros</th>\n<th>Cons</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Immediate Global Update</td>\n<td>Change all future hashes to new parameters</td>\n<td>Simple, consistent security</td>\n<td>Sudden performance impact</td>\n</tr>\n<tr>\n<td>Gradual Migration</td>\n<td>Increase iteration counts over time</td>\n<td>Smooth transition</td>\n<td>Complex scheduling</td>\n</tr>\n<tr>\n<td>User-Triggered Upgrade</td>\n<td>Update parameters on password change</td>\n<td>Natural evolution</td>\n<td>Slow adoption</td>\n</tr>\n<tr>\n<td>Background Rehashing</td>\n<td>Upgrade hashes during low-traffic periods</td>\n<td>Transparent to users</td>\n<td>Complex implementation</td>\n</tr>\n</tbody></table>\n<p>The <strong>user-triggered upgrade</strong> approach provides the most practical balance between security improvement and implementation complexity. When users change passwords or successfully authenticate, the system generates new hashes with current iteration count recommendations. This approach ensures active accounts receive updated security while avoiding forced migrations.</p>\n<h4 id=\"security-monitoring-and-validation\">Security Monitoring and Validation</h4>\n<p>Effective iteration count tuning requires continuous monitoring of both security effectiveness and performance characteristics. Security parameters that seemed adequate during initial deployment may prove insufficient as attack capabilities evolve or system requirements change.</p>\n<p><strong>Security effectiveness monitoring</strong> involves tracking metrics that indicate whether current iteration counts provide adequate protection against realistic attack scenarios. These metrics include computational cost analysis, comparative security assessment, and threat intelligence integration.</p>\n<table>\n<thead>\n<tr>\n<th>Monitoring Metric</th>\n<th>Measurement Method</th>\n<th>Alert Threshold</th>\n<th>Response Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Hash Computation Time</td>\n<td>Server-side timing measurement</td>\n<td>&gt;150% of baseline</td>\n<td>Performance investigation</td>\n</tr>\n<tr>\n<td>Attack Cost Estimate</td>\n<td>Theoretical brute force calculation</td>\n<td>&lt;1 week for common passwords</td>\n<td>Iteration count increase</td>\n</tr>\n<tr>\n<td>Hardware Benchmark</td>\n<td>Periodic performance testing</td>\n<td>50% performance improvement</td>\n<td>Parameter review</td>\n</tr>\n<tr>\n<td>Security Standard Compliance</td>\n<td>Comparison to current recommendations</td>\n<td>Below industry minimums</td>\n<td>Immediate update</td>\n</tr>\n</tbody></table>\n<p><strong>Performance impact assessment</strong> ensures that security improvements don&#39;t compromise system usability or availability. Regular measurement of authentication latency, resource consumption, and user experience metrics provides early warning of parameter selections that may require adjustment.</p>\n<blockquote>\n<p>The fundamental principle is that iteration count tuning is not a one-time decision but an ongoing security practice requiring regular review and adjustment based on evolving threat landscapes and hardware capabilities.</p>\n</blockquote>\n<h3 id=\"common-pitfalls\">Common Pitfalls</h3>\n<p>⚠️ <strong>Pitfall: Using Insufficient Iteration Counts</strong></p>\n<p>Many implementations use iteration counts that provide inadequate security against modern attack capabilities. Developers often choose round numbers like 10,000 or 50,000 iterations without understanding the actual security implications, or use outdated recommendations from early PBKDF2 documentation.</p>\n<p>The problem occurs because iteration count requirements have increased dramatically as hardware has improved. An iteration count that provided strong security in 2010 may be completely inadequate today. Additionally, developers sometimes optimize for perceived performance concerns without understanding the security trade-offs.</p>\n<p>To avoid this pitfall, always use current security recommendations as minimums (100,000+ iterations for PBKDF2-SHA256), measure actual performance on target hardware rather than assuming iteration counts are &quot;too slow,&quot; and implement systematic processes for increasing iteration counts over time as hardware improves.</p>\n<p>⚠️ <strong>Pitfall: Not Storing Iteration Count with Password Hash</strong></p>\n<p>Some implementations use fixed global iteration counts and fail to store the iteration count with each password hash record. This creates serious problems when iteration counts need to be increased—existing password hashes become unverifiable because the system doesn&#39;t know which iteration count was used during hash creation.</p>\n<p>The issue manifests as authentication failures after security parameter updates, inability to evolve security over time, and forced password resets for all users when iteration counts change. This violates the principle of algorithm agility and creates operational difficulties in production systems.</p>\n<p>The solution requires storing iteration count as part of each <code>PasswordHashRecord</code>, implementing parameter evolution that allows different iteration counts for different password records, and using default iteration counts that can change over time without breaking existing authentications.</p>\n<p>⚠️ <strong>Pitfall: Implementing PBKDF2 with Variable-Time Operations</strong></p>\n<p>Subtle timing vulnerabilities can occur in PBKDF2 implementations that don&#39;t maintain constant execution time. These vulnerabilities might arise from optimizations that skip operations under certain conditions, different code paths based on input values, or comparison operations that fail faster for incorrect passwords.</p>\n<p>Variable timing can leak information about password correctness, salt values, or internal algorithm state. While timing attacks against PBKDF2 are more difficult due to the inherent computational delay, they remain possible if implementations contain timing side channels.</p>\n<p>Prevent timing attacks by ensuring all code paths take the same execution time regardless of input values, using constant-time comparison functions for all password verification steps, and avoiding optimizations that create conditional execution based on secret values.</p>\n<p>⚠️ <strong>Pitfall: Not Validating PBKDF2 Parameters</strong></p>\n<p>Implementations sometimes fail to validate PBKDF2 parameters, accepting dangerously low iteration counts, excessively short salts, or malformed input data. This can lead to security vulnerabilities if attackers can influence parameter selection or if configuration errors result in weak security.</p>\n<p>Parameter validation must enforce minimum security requirements including minimum iteration counts (100,000+), minimum salt lengths (16+ bytes), reasonable maximum values to prevent denial-of-service attacks, and proper input format validation to prevent parsing errors.</p>\n<p>Implement comprehensive parameter validation in the <code>ParameterValidator</code> component, reject requests with insufficient security parameters even if they would execute faster, and use safe defaults when parameters are not explicitly specified.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Memory and CPU Resource Constraints</strong></p>\n<p>PBKDF2 with high iteration counts can consume significant CPU resources, potentially creating denial-of-service vulnerabilities if not properly managed. Implementations that don&#39;t consider resource constraints may become unavailable under high authentication loads or targeted resource exhaustion attacks.</p>\n<p>The problem occurs when systems don&#39;t limit concurrent PBKDF2 operations, fail to account for CPU usage in capacity planning, or don&#39;t implement proper resource monitoring and alerting. High iteration counts that work fine for single authentications can overwhelm servers under load.</p>\n<p>Address resource constraints by implementing concurrency limits for password hashing operations, monitoring CPU usage and authentication latency during load testing, and designing systems that can gracefully degrade performance rather than failing completely under high loads.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The key stretching component builds upon the basic hashing foundation to implement PBKDF2 key derivation with configurable security parameters. This implementation focuses on providing both educational clarity and production-ready security.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PBKDF2 Implementation</td>\n<td>Python&#39;s <code>hashlib.pbkdf2_hmac()</code> (built-in)</td>\n<td>Custom PBKDF2 with detailed controls</td>\n</tr>\n<tr>\n<td>Parameter Storage</td>\n<td>JSON serialization with validation</td>\n<td>Binary format with version headers</td>\n</tr>\n<tr>\n<td>Performance Measurement</td>\n<td>Simple timing with <code>time.time()</code></td>\n<td>Statistical timing analysis with <code>timeit</code></td>\n</tr>\n<tr>\n<td>Constant-Time Comparison</td>\n<td><code>hmac.compare_digest()</code> (built-in)</td>\n<td>Custom constant-time implementation</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  src/\n    password_security/\n      key_stretching/\n        __init__.py              ← exports main classes\n        pbkdf2_hasher.py         ← PBKDF2 implementation\n        iteration_tuner.py       ← performance measurement and tuning\n        key_stretching_errors.py ← specific exception types\n      basic_hashing/\n        basic_hasher.py          ← from previous milestone\n        salt_generator.py        ← from previous milestone\n      data_model/\n        hash_record.py           ← from previous milestone\n        parameters.py            ← algorithm parameters\n  tests/\n    test_key_stretching/\n      test_pbkdf2_hasher.py      ← PBKDF2 functionality tests\n      test_iteration_tuning.py   ← performance tuning tests\n      test_timing_safety.py      ← timing attack resistance tests</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Complete Parameter Validation Infrastructure</strong> (<code>key_stretching_errors.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Key stretching specific exception types and validation utilities.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides comprehensive error handling for PBKDF2 parameter validation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> KeyStretchingError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Base exception for all key stretching operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> IterationCountError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">KeyStretchingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when iteration count is invalid or insufficient.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, count, minimum_required):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.count </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> count</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.minimum_required </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> minimum_required</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Iteration count </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">count</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> below minimum </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">minimum_required</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DerivationLengthError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">KeyStretchingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when derived key length is invalid.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, length, maximum_allowed):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> length</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.maximum_allowed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> maximum_allowed</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Derived key length </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">length</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> exceeds maximum </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">maximum_allowed</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParameterValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">KeyStretchingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Raised when PBKDF2 parameters fail validation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, parameter_name, value, constraint):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parameter_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parameter_name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.constraint </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> constraint</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Parameter </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">parameter_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">=</span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">value</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> violates </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">constraint</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_iteration_count</span><span style=\"color:#E1E4E8\">(count):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validate PBKDF2 iteration count meets security requirements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(count, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> ParameterValidationError(</span><span style=\"color:#9ECBFF\">\"iteration_count\"</span><span style=\"color:#E1E4E8\">, count, </span><span style=\"color:#9ECBFF\">\"must be integer\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> IterationCountError(count, </span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 10000000</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> ParameterValidationError(</span><span style=\"color:#9ECBFF\">\"iteration_count\"</span><span style=\"color:#E1E4E8\">, count, </span><span style=\"color:#9ECBFF\">\"exceeds reasonable maximum\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_derived_key_length</span><span style=\"color:#E1E4E8\">(length):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validate derived key length is reasonable and secure.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> isinstance</span><span style=\"color:#E1E4E8\">(length, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> ParameterValidationError(</span><span style=\"color:#9ECBFF\">\"derived_key_length\"</span><span style=\"color:#E1E4E8\">, length, </span><span style=\"color:#9ECBFF\">\"must be integer\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> length </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> ParameterValidationError(</span><span style=\"color:#9ECBFF\">\"derived_key_length\"</span><span style=\"color:#E1E4E8\">, length, </span><span style=\"color:#9ECBFF\">\"minimum 16 bytes\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> length </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 256</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> DerivationLengthError(length, </span><span style=\"color:#79B8FF\">256</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#79B8FF\"> True</span></span></code></pre></div>\n\n<p><strong>Complete Performance Measurement Infrastructure</strong> (<code>iteration_tuner.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Performance measurement and iteration count tuning for PBKDF2.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides comprehensive timing analysis and parameter recommendations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Tuple</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PerformanceGoalTuner</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Measures PBKDF2 performance and recommends iteration counts.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.measurements </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.test_password </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">\"test_password_for_timing\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.test_salt </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">\"test_salt_16_bytes_long\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> benchmark_algorithm</span><span style=\"color:#E1E4E8\">(self, algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, test_password: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Measure algorithm performance with statistical analysis.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> algorithm </span><span style=\"color:#F97583\">!=</span><span style=\"color:#9ECBFF\"> \"pbkdf2_hmac_sha256\"</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"error\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unsupported algorithm: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">algorithm</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Measure baseline performance with known iteration counts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        iteration_counts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#79B8FF\">50000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">200000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">500000</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timing_results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> iteration_counts:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            times </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">):  </span><span style=\"color:#6A737D\"># Multiple measurements for statistical accuracy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                hashlib.pbkdf2_hmac(</span><span style=\"color:#9ECBFF\">'sha256'</span><span style=\"color:#E1E4E8\">, test_password, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.test_salt, count, </span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                end_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                times.append(end_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            timing_results[count] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'mean'</span><span style=\"color:#E1E4E8\">: statistics.mean(times),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'median'</span><span style=\"color:#E1E4E8\">: statistics.median(times),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'stdev'</span><span style=\"color:#E1E4E8\">: statistics.stdev(times) </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(times) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> else</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'min'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">min</span><span style=\"color:#E1E4E8\">(times),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'max'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">max</span><span style=\"color:#E1E4E8\">(times)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Calculate scaling factor (time per iteration)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        scaling_factors </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> count, timing </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> timing_results.items():</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            scaling_factors.append(timing[</span><span style=\"color:#9ECBFF\">'mean'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> count)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        avg_scaling_factor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> statistics.mean(scaling_factors)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'algorithm'</span><span style=\"color:#E1E4E8\">: algorithm,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'timing_results'</span><span style=\"color:#E1E4E8\">: timing_results,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'scaling_factor'</span><span style=\"color:#E1E4E8\">: avg_scaling_factor,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'measurement_count'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(timing_results)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> recommend_iteration_count</span><span style=\"color:#E1E4E8\">(self, target_time_ms: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Recommend iteration count to achieve target timing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        target_time_seconds </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> target_time_ms </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1000.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Measure current performance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        benchmark </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.benchmark_algorithm(</span><span style=\"color:#9ECBFF\">\"pbkdf2_hmac_sha256\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.test_password)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#9ECBFF\"> 'error'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> benchmark:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> benchmark</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        scaling_factor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> benchmark[</span><span style=\"color:#9ECBFF\">'scaling_factor'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        recommended_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> int</span><span style=\"color:#E1E4E8\">(target_time_seconds </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> scaling_factor)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Ensure minimum security requirements</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        minimum_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> recommended_count </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> minimum_count:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            recommended_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> minimum_count</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            actual_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> recommended_count </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> scaling_factor </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'recommended_iterations'</span><span style=\"color:#E1E4E8\">: recommended_count,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'target_time_ms'</span><span style=\"color:#E1E4E8\">: target_time_ms,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'actual_time_ms'</span><span style=\"color:#E1E4E8\">: actual_time,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'warning'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Hardware too fast for target time, using minimum </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">minimum_count</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> iterations\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Verify recommendation with actual measurement</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        hashlib.pbkdf2_hmac(</span><span style=\"color:#9ECBFF\">'sha256'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.test_password, </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.test_salt, recommended_count, </span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        end_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        actual_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (end_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'recommended_iterations'</span><span style=\"color:#E1E4E8\">: recommended_count,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'target_time_ms'</span><span style=\"color:#E1E4E8\">: target_time_ms,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'actual_time_ms'</span><span style=\"color:#E1E4E8\">: actual_time,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'scaling_factor'</span><span style=\"color:#E1E4E8\">: scaling_factor,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'accuracy_percentage'</span><span style=\"color:#E1E4E8\">: (target_time_ms </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> actual_time) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 100</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>PBKDF2 Key Stretching Implementation</strong> (<code>pbkdf2_hasher.py</code>):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">PBKDF2-based password hashing with configurable iteration counts.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Implements secure key stretching for password protection.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hmac</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..data_model.hash_record </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PasswordHashRecord</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> ..basic_hashing.salt_generator </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> SaltGenerator</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .key_stretching_errors </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> validate_iteration_count, validate_derived_key_length</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> KeyStretchingHasher</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Implements PBKDF2 key stretching for password security.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, default_iterations: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 200000</span><span style=\"color:#E1E4E8\">, default_key_length: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate default_iterations meets minimum security requirements (100,000+)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate default_key_length provides adequate security (32+ bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Initialize salt_generator for secure random salt generation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Store algorithm identifier for hash record metadata</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> hash_password_with_stretching</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                    iterations: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                    key_length: Optional[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> PasswordHashRecord:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Generate PBKDF2 hash with configurable iteration count and key length.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Uses default values if parameters not specified.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Convert password string to bytes using UTF-8 encoding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Use provided iterations or fall back to default, validate against minimum</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Use provided key_length or fall back to default, validate range</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Generate cryptographically random salt using salt_generator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Call hashlib.pbkdf2_hmac('sha256', password_bytes, salt, iterations, key_length)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Create PasswordHashRecord with algorithm='pbkdf2_hmac_sha256'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Store iterations and key_length in parameters dict for verification</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Return complete hash record with all metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: parameters = {'iterations': iterations, 'key_length': key_length}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify_password_with_stretching</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, hash_record: PasswordHashRecord) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Verify password against PBKDF2 hash using stored parameters.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Implements constant-time comparison to prevent timing attacks.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate hash_record.algorithm == 'pbkdf2_hmac_sha256'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Extract iterations from hash_record.parameters dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Extract key_length from hash_record.parameters dict</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Convert password to bytes using UTF-8 encoding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Recompute PBKDF2 hash using stored salt and parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Compare recomputed hash with stored hash using hmac.compare_digest()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return boolean result (True if passwords match, False otherwise)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use hmac.compare_digest(computed_hash, hash_record.hash) for timing safety</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> upgrade_iteration_count</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, old_record: PasswordHashRecord, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               new_iterations: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> PasswordHashRecord:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Create new hash record with increased iteration count.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Used for transparent security upgrades during authentication.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate new_iterations > old_record.parameters['iterations']</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Verify password against old_record to ensure correctness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If verification succeeds, create new hash with new_iterations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Use same key_length as original record for compatibility</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Generate new salt for the upgraded hash record</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return new PasswordHashRecord with upgraded parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: If verification fails, raise authentication error</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: This enables transparent security upgrades during login</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> benchmark_iterations</span><span style=\"color:#E1E4E8\">(self, target_time_ms: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Measure PBKDF2 performance and recommend iteration count for target timing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns performance analysis and recommended parameters.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create test password and salt for benchmarking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Measure execution time for various iteration counts (50k, 100k, 200k, 500k)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate linear scaling factor (time per iteration)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Recommend iteration count to achieve target_time_ms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Ensure recommended count meets minimum security requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return dict with recommended_iterations, actual_time, scaling_factor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Include warning if hardware is too fast for reasonable target time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use time.perf_counter() for accurate timing measurements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Integration with Algorithm Parameters</strong> (<code>parameters.py</code> additions):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Algorithm parameters management for key stretching algorithms.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Extends base parameter system with PBKDF2-specific configurations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AlgorithmParameters</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages algorithm parameters with validation and defaults.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_pbkdf2_defaults</span><span style=\"color:#E1E4E8\">(self) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get default PBKDF2 parameters for current security standards.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Return dict with default iterations (200,000)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Include default key_length (32 bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Include algorithm identifier ('pbkdf2_hmac_sha256')</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Include version number for parameter evolution</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: These defaults should meet current security recommendations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_pbkdf2_parameters</span><span style=\"color:#E1E4E8\">(self, parameters: Dict) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate PBKDF2 parameters meet security requirements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check iterations >= 100,000 (security minimum)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check key_length >= 16 bytes (adequate key material)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check iterations &#x3C;= 10,000,000 (DoS prevention)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check key_length &#x3C;= 256 bytes (reasonable maximum)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Raise ParameterValidationError for invalid values</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return True if all validations pass</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use validation functions from key_stretching_errors module</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> evolve_security_parameters</span><span style=\"color:#E1E4E8\">(self, current_params: Dict, target_year: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Recommend parameter updates based on projected security requirements.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Accounts for hardware improvements and attack capability evolution.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Calculate years from present to target_year</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Estimate hardware improvement factor (assume 2x every 3 years)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Scale iteration count proportionally to maintain security level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Ensure scaled parameters meet future minimum requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return updated parameters dict with evolution metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Include rationale for recommended changes</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Moore's law suggests doubling iteration count every 3 years</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the key stretching component, verify functionality with these specific tests:</p>\n<p><strong>Performance Verification:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_key_stretching/test_iteration_tuning.py</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p>Expected output should show:</p>\n<ul>\n<li>Iteration count recommendations within 10% of target timing</li>\n<li>Minimum iteration count enforcement (100,000+)</li>\n<li>Linear scaling factor calculation accuracy</li>\n<li>Performance measurement statistical stability</li>\n</ul>\n<p><strong>Security Property Verification:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_key_stretching/test_pbkdf2_hasher.py::test_timing_attack_resistance</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p>Expected behavior:</p>\n<ul>\n<li>All password verifications take similar time regardless of password correctness</li>\n<li>Constant-time comparison prevents early termination</li>\n<li>No timing information leaks through execution patterns</li>\n</ul>\n<p><strong>Manual Integration Test:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> password_security.key_stretching.pbkdf2_hasher </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> KeyStretchingHasher</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">hasher </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> KeyStretchingHasher(</span><span style=\"color:#FFAB70\">default_iterations</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">150000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">hash_record </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hasher.hash_password_with_stretching(</span><span style=\"color:#9ECBFF\">\"test_password\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Hash time: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">hash_record.created_at</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Iterations: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">hash_record.parameters[</span><span style=\"color:#9ECBFF\">'iterations'</span><span style=\"color:#E1E4E8\">]</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Verification: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">hasher.verify_password_with_stretching(</span><span style=\"color:#9ECBFF\">'test_password'</span><span style=\"color:#E1E4E8\">, hash_record)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<p>You should see:</p>\n<ul>\n<li>Hash creation taking 100-500ms depending on hardware</li>\n<li>Successful password verification returning True</li>\n<li>Identical parameters stored and retrieved from hash record</li>\n<li>Failed verification (wrong password) also taking similar time</li>\n</ul>\n<p><strong>Signs of Implementation Problems:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnostic Command</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Hashing takes &gt;2 seconds</td>\n<td>Iteration count too high</td>\n<td>Check <code>hash_record.parameters[&#39;iterations&#39;]</code></td>\n<td>Reduce to 200,000-500,000 range</td>\n</tr>\n<tr>\n<td>Verification fails for correct passwords</td>\n<td>Parameter extraction error</td>\n<td>Print <code>hash_record.parameters</code></td>\n<td>Fix parameter dictionary key names</td>\n</tr>\n<tr>\n<td>Timing varies significantly</td>\n<td>Not using constant-time comparison</td>\n<td>Time multiple verifications</td>\n<td>Use <code>hmac.compare_digest()</code></td>\n</tr>\n<tr>\n<td>Import errors</td>\n<td>Missing dependencies</td>\n<td><code>python -c &quot;import hashlib, hmac&quot;</code></td>\n<td>Check Python standard library</td>\n</tr>\n</tbody></table>\n<h2 id=\"modern-hashing-component\">Modern Hashing Component</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Milestone 3 (Modern Password Hashing)</p>\n</blockquote>\n<h3 id=\"mental-model-the-bank-vault-evolution-system\">Mental Model: The Bank Vault Evolution System</h3>\n<p>Think of the modern hashing component like a bank&#39;s vault evolution over decades. Early banks used simple mechanical locks (basic SHA-256 hashing), which worked until lock picking became widespread. Then banks adopted time-locked mechanisms (key stretching with PBKDF2), which delayed thieves but could still be overcome with enough time and determination. Modern banks use sophisticated multi-layered vault systems with biometric scanners, time delays, and specialized materials that require enormous resources to breach (bcrypt and Argon2).</p>\n<p>Just like banks must periodically upgrade their vault technology as new attack methods emerge, password systems need <strong>algorithm agility</strong> — the ability to migrate from older methods to newer, more secure approaches without disrupting existing users. The vault manufacturer (our modern hashing component) must support multiple vault generations simultaneously during transition periods, ensuring that customers with older vaults can still access their deposits while new customers get the latest protection.</p>\n<p>The crucial insight is that <strong>security decay</strong> affects all cryptographic systems over time. What seems computationally infeasible today becomes trivial with tomorrow&#39;s hardware and attack techniques. A well-designed system anticipates this evolution and provides seamless upgrade paths.</p>\n<h3 id=\"bcrypt-integration-using-bcrypt39s-built-in-salt-generation-and-cost-factor-management\">Bcrypt Integration: Using Bcrypt&#39;s Built-in Salt Generation and Cost Factor Management</h3>\n<p><strong>Bcrypt</strong> represents the first widely-adopted <strong>memory-hard</strong> password hashing algorithm specifically designed for password storage. Unlike PBKDF2, which performs many simple operations quickly, bcrypt incorporates the expensive Blowfish key setup that requires significant memory and resists optimization on specialized hardware like GPUs and ASICs.</p>\n<p>The bcrypt algorithm follows a carefully engineered process that combines multiple security mechanisms into a single operation. First, it generates a cryptographically random salt internally, eliminating the need for external salt management. Second, it applies the computationally expensive Blowfish key setup algorithm multiple times, with the iteration count determined by a <strong>cost factor</strong> parameter. This cost factor uses logarithmic scaling — cost 12 means 2^12 = 4,096 iterations, while cost 13 doubles the computation time to 8,192 iterations.</p>\n<p>The elegant aspect of bcrypt lies in its self-contained hash format that embeds all verification parameters directly in the output string. A typical bcrypt hash looks like <code>$2b$12$R9h/cIPz0gi.URNNX3kh2OUXGWU6CDQFU4rIpSJqX3gLJPkkR1ueS</code>, where the format breaks down into distinct components that preserve all necessary information for future verification.</p>\n<blockquote>\n<p><strong>Decision: Adopt Bcrypt for Production Password Hashing</strong></p>\n<ul>\n<li><strong>Context</strong>: Need production-grade password hashing that balances security, performance, and hardware resistance</li>\n<li><strong>Options Considered</strong>: Continue with PBKDF2, implement bcrypt, implement Argon2</li>\n<li><strong>Decision</strong>: Use bcrypt as the primary modern hashing algorithm with optional Argon2 support</li>\n<li><strong>Rationale</strong>: Bcrypt provides proven security with 25+ years of cryptanalysis, widespread library support, and excellent hardware attack resistance. The logarithmic cost factor provides clear upgrade paths as hardware improves.</li>\n<li><strong>Consequences</strong>: Adds external library dependency but eliminates custom cryptographic implementation risks. Provides industry-standard security with straightforward parameter tuning.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Bcrypt Hash Component</th>\n<th>Example Value</th>\n<th>Purpose</th>\n<th>Security Property</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Algorithm Identifier</td>\n<td><code>$2b$</code></td>\n<td>Specifies bcrypt variant and version</td>\n<td>Prevents algorithm confusion attacks</td>\n</tr>\n<tr>\n<td>Cost Factor</td>\n<td><code>12</code></td>\n<td>Logarithmic work factor (2^12 iterations)</td>\n<td>Configurable computational bottleneck</td>\n</tr>\n<tr>\n<td>Salt</td>\n<td><code>R9h/cIPz0gi.URNNX3kh2O</code></td>\n<td>128-bit random value (base64 encoded)</td>\n<td>Prevents rainbow table attacks</td>\n</tr>\n<tr>\n<td>Hash</td>\n<td><code>UXGWU6CDQFU4rIpSJqX3gLJPkkR1ueS</code></td>\n<td>184-bit derived key (base64 encoded)</td>\n<td>Password-dependent verification value</td>\n</tr>\n</tbody></table>\n<p>The <strong>cost factor tuning</strong> process requires careful measurement of actual hardware performance rather than theoretical calculations. The goal is selecting a cost that imposes acceptable delays on legitimate authentication (typically 100-500 milliseconds) while creating prohibitive costs for brute force attacks. Since bcrypt&#39;s cost factor uses logarithmic scaling, each increment doubles the computation time, providing precise control over the security-performance trade-off.</p>\n<blockquote>\n<p>The critical insight with bcrypt cost factors is that they must be tuned for your specific hardware and gradually increased over time. A cost factor appropriate for 2020 hardware becomes insufficient by 2025 due to Moore&#39;s Law improvements.</p>\n</blockquote>\n<p><strong>Cost Factor Selection Algorithm:</strong></p>\n<ol>\n<li>Start with the industry minimum cost factor (<code>BCRYPT_MIN_COST</code> = 12)</li>\n<li>Measure actual hash computation time on production hardware using representative test passwords</li>\n<li>Increase cost factor incrementally until hash computation reaches target latency (200-300ms recommended)</li>\n<li>Document the selected cost factor with hardware specifications and measurement date</li>\n<li>Schedule periodic reviews (annually) to reassess cost factor adequacy</li>\n<li>Plan migration strategy for upgrading existing password hashes with higher cost factors</li>\n</ol>\n<p>The bcrypt integration architecture separates <strong>algorithm mechanics</strong> from <strong>parameter management</strong> to support long-term maintainability. The core bcrypt wrapper handles the cryptographic operations and format parsing, while a separate parameter management system tracks cost factor evolution and supports gradual migration of existing password databases.</p>\n<table>\n<thead>\n<tr>\n<th>Bcrypt Integration Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>hash_password_bcrypt</code></td>\n<td><code>password: bytes, cost: int</code></td>\n<td><code>PasswordHashRecord</code></td>\n<td>Generate bcrypt hash with specified cost factor</td>\n</tr>\n<tr>\n<td><code>verify_password_bcrypt</code></td>\n<td><code>password: bytes, hash_record: PasswordHashRecord</code></td>\n<td><code>bool</code></td>\n<td>Verify password against stored bcrypt hash</td>\n</tr>\n<tr>\n<td><code>parse_bcrypt_hash</code></td>\n<td><code>bcrypt_string: str</code></td>\n<td><code>dict</code></td>\n<td>Extract algorithm, cost, salt, and hash from bcrypt format</td>\n</tr>\n<tr>\n<td><code>format_bcrypt_hash</code></td>\n<td><code>cost: int, salt: bytes, hash: bytes</code></td>\n<td><code>str</code></td>\n<td>Construct standard bcrypt format string</td>\n</tr>\n<tr>\n<td><code>benchmark_bcrypt_cost</code></td>\n<td><code>target_time_ms: int</code></td>\n<td><code>dict</code></td>\n<td>Measure performance and recommend cost factor</td>\n</tr>\n<tr>\n<td><code>upgrade_bcrypt_cost</code></td>\n<td><code>password: bytes, old_record: PasswordHashRecord, new_cost: int</code></td>\n<td><code>PasswordHashRecord</code></td>\n<td>Re-hash password with higher cost factor</td>\n</tr>\n</tbody></table>\n<h3 id=\"argon2-support-memory-hard-hashing-for-enhanced-security-against-specialized-hardware\">Argon2 Support: Memory-Hard Hashing for Enhanced Security Against Specialized Hardware</h3>\n<p><strong>Argon2</strong> represents the state-of-the-art in password hashing, winning the Password Hashing Competition in 2015 and becoming the recommended algorithm for new applications. Unlike bcrypt, which focuses primarily on time-based computational cost, Argon2 introduces <strong>memory-hardness</strong> — requiring substantial memory allocation that resists optimization on specialized hardware like GPUs, FPGAs, and ASICs.</p>\n<p>The Argon2 algorithm family includes three variants designed for different threat models. <strong>Argon2d</strong> maximizes resistance against GPU-based attacks by using data-dependent memory access patterns, but becomes vulnerable to side-channel attacks in shared environments. <strong>Argon2i</strong> uses data-independent memory access to prevent side-channel attacks, making it suitable for password hashing in multi-tenant systems. <strong>Argon2id</strong> combines both approaches, using data-independent access for the first half of iterations and data-dependent access for the second half, providing the best overall security properties.</p>\n<p>The memory-hard property fundamentally changes the economics of password cracking. Traditional attacks could use thousands of lightweight GPU cores to parallelize hash computations, but Argon2&#39;s memory requirements limit the parallelization factor. An attacker who previously could run 10,000 parallel bcrypt computations might only manage 100 parallel Argon2 computations due to memory constraints.</p>\n<blockquote>\n<p><strong>Decision: Support Argon2id as Advanced Option</strong></p>\n<ul>\n<li><strong>Context</strong>: Need maximum security for high-value applications and defense against specialized hardware attacks</li>\n<li><strong>Options Considered</strong>: Bcrypt only, Argon2d, Argon2i, Argon2id</li>\n<li><strong>Decision</strong>: Implement Argon2id support as an advanced option alongside bcrypt</li>\n<li><strong>Rationale</strong>: Argon2id provides the best balance of side-channel resistance and GPU attack resistance. Memory-hardness provides superior protection against well-funded attackers with specialized hardware.</li>\n<li><strong>Consequences</strong>: Increases memory usage and implementation complexity but provides maximum security for applications that require it.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Argon2 Parameter</th>\n<th>Typical Value</th>\n<th>Purpose</th>\n<th>Security Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Memory Cost (m)</td>\n<td>65536 (64 MB)</td>\n<td>Memory allocation in KB</td>\n<td>Higher values resist parallel attacks</td>\n</tr>\n<tr>\n<td>Time Cost (t)</td>\n<td>3</td>\n<td>Number of iterations</td>\n<td>Higher values increase computation time</td>\n</tr>\n<tr>\n<td>Parallelism (p)</td>\n<td>4</td>\n<td>Number of parallel threads</td>\n<td>Must match available CPU cores</td>\n</tr>\n<tr>\n<td>Hash Length</td>\n<td>32 bytes</td>\n<td>Output key length</td>\n<td>Standard 256-bit security level</td>\n</tr>\n<tr>\n<td>Salt Length</td>\n<td>16 bytes</td>\n<td>Random salt length</td>\n<td>Prevents precomputed attacks</td>\n</tr>\n</tbody></table>\n<p>The <strong>memory cost parameter</strong> requires careful tuning based on available system memory and concurrent authentication load. Unlike bcrypt&#39;s logarithmic cost factor, Argon2&#39;s memory cost scales linearly — doubling the memory parameter doubles the memory usage. For web applications, memory costs between 32 MB and 128 MB provide good security while remaining feasible for typical server hardware.</p>\n<p><strong>Argon2 Parameter Selection Algorithm:</strong></p>\n<ol>\n<li>Determine maximum acceptable memory per hash operation based on concurrent user load</li>\n<li>Set memory cost to use 50-75% of available per-operation memory budget</li>\n<li>Configure parallelism to match available CPU cores (typically 2-8)</li>\n<li>Adjust time cost to achieve target verification latency (100-500ms)</li>\n<li>Measure actual memory usage and verification time under realistic load</li>\n<li>Document parameter choices with hardware specifications and load assumptions</li>\n</ol>\n<p>The Argon2 integration must handle the increased complexity of multi-parameter tuning compared to bcrypt&#39;s single cost factor. The parameter validation system ensures that configurations remain within secure boundaries and provides warnings when parameter combinations might create resource exhaustion risks.</p>\n<table>\n<thead>\n<tr>\n<th>Argon2 Integration Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>hash_password_argon2</code></td>\n<td><code>password: bytes, memory_cost: int, time_cost: int, parallelism: int</code></td>\n<td><code>PasswordHashRecord</code></td>\n<td>Generate Argon2id hash with specified parameters</td>\n</tr>\n<tr>\n<td><code>verify_password_argon2</code></td>\n<td><code>password: bytes, hash_record: PasswordHashRecord</code></td>\n<td><code>bool</code></td>\n<td>Verify password against stored Argon2 hash</td>\n</tr>\n<tr>\n<td><code>parse_argon2_hash</code></td>\n<td><code>argon2_string: str</code></td>\n<td><code>dict</code></td>\n<td>Extract parameters and hash from Argon2 format</td>\n</tr>\n<tr>\n<td><code>format_argon2_hash</code></td>\n<td><code>memory_cost: int, time_cost: int, parallelism: int, salt: bytes, hash: bytes</code></td>\n<td><code>str</code></td>\n<td>Construct standard Argon2 format string</td>\n</tr>\n<tr>\n<td><code>benchmark_argon2_parameters</code></td>\n<td><code>target_time_ms: int, max_memory_mb: int</code></td>\n<td><code>dict</code></td>\n<td>Recommend parameters for performance and memory constraints</td>\n</tr>\n<tr>\n<td><code>validate_argon2_parameters</code></td>\n<td><code>memory_cost: int, time_cost: int, parallelism: int</code></td>\n<td><code>ValidationResult</code></td>\n<td>Validate parameter combinations for security and feasibility</td>\n</tr>\n</tbody></table>\n<h3 id=\"algorithm-agility-design-supporting-multiple-algorithms-and-migration-paths-for-future-upgrades\">Algorithm Agility Design: Supporting Multiple Algorithms and Migration Paths for Future Upgrades</h3>\n<p><strong>Algorithm agility</strong> represents one of the most critical architectural decisions in cryptographic systems. The fundamental challenge is that all cryptographic algorithms eventually become obsolete due to advances in mathematics, computing hardware, or attack techniques. A well-designed password hashing system must anticipate this evolution and provide seamless migration paths that preserve existing user accounts while adopting stronger security measures.</p>\n<p>The algorithm agility architecture separates <strong>algorithm implementation</strong> from <strong>algorithm selection</strong> and <strong>migration management</strong>. The core insight is that password hash records must be <strong>immutable archives</strong> that preserve exact creation-time parameters while supporting verification across multiple algorithm generations. This design prevents <strong>temporal coupling</strong> where verification depends on current system configuration rather than the original hash parameters.</p>\n<p><img src=\"/api/project/password-hashing/architecture-doc/asset?path=diagrams%2Falgorithm-evolution.svg\" alt=\"Algorithm Evolution State Machine\"></p>\n<p>The migration strategy addresses the fundamental constraint that password hashes are one-way operations — upgrading security requires user cooperation to provide their plaintext password during authentication. The system must support <strong>lazy migration</strong> where password hashes upgrade opportunistically during successful login attempts, allowing gradual improvement of the password database security profile over time.</p>\n<blockquote>\n<p><strong>Decision: Implement Algorithm-Agnostic Hash Record Format</strong></p>\n<ul>\n<li><strong>Context</strong>: Need to support multiple hashing algorithms and enable future migrations without breaking existing authentication</li>\n<li><strong>Options Considered</strong>: Algorithm-specific storage, unified hash record format, external migration utility</li>\n<li><strong>Decision</strong>: Use unified <code>PasswordHashRecord</code> format with embedded algorithm identification and parameters</li>\n<li><strong>Rationale</strong>: Self-contained records eliminate external dependencies and support verification across system upgrades. Algorithm identification prevents confusion attacks and enables automatic dispatch to appropriate verification logic.</li>\n<li><strong>Consequences</strong>: Increases storage overhead slightly but provides complete algorithm agility and eliminates migration complexity.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Algorithm Agility Component</th>\n<th>Responsibility</th>\n<th>Design Pattern</th>\n<th>Benefits</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>AlgorithmRegistry</code></td>\n<td>Maps algorithm names to implementation classes</td>\n<td>Registry pattern</td>\n<td>Extensible algorithm support</td>\n</tr>\n<tr>\n<td><code>MigrationManager</code></td>\n<td>Orchestrates lazy password hash upgrades</td>\n<td>Strategy pattern</td>\n<td>Gradual security improvements</td>\n</tr>\n<tr>\n<td><code>VersioningSystem</code></td>\n<td>Tracks algorithm security levels and recommendations</td>\n<td>Observer pattern</td>\n<td>Automated migration triggers</td>\n</tr>\n<tr>\n<td><code>BackwardCompatibility</code></td>\n<td>Maintains verification for legacy hash formats</td>\n<td>Adapter pattern</td>\n<td>Seamless system upgrades</td>\n</tr>\n</tbody></table>\n<p>The <strong>algorithm selection strategy</strong> must balance security, performance, and operational constraints. The system provides sensible defaults while allowing explicit algorithm selection for specialized requirements. High-security applications might mandate Argon2id, while high-throughput systems might prefer bcrypt with carefully tuned cost factors.</p>\n<p><strong>Algorithm Selection Decision Matrix:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Use Case</th>\n<th>Primary Algorithm</th>\n<th>Fallback Algorithm</th>\n<th>Cost Factor/Parameters</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>General Web Application</td>\n<td>bcrypt</td>\n<td>PBKDF2</td>\n<td>Cost 12-14</td>\n</tr>\n<tr>\n<td>High-Security System</td>\n<td>Argon2id</td>\n<td>bcrypt</td>\n<td>64MB memory, cost 13+</td>\n</tr>\n<tr>\n<td>High-Throughput API</td>\n<td>bcrypt</td>\n<td>PBKDF2</td>\n<td>Cost 10-12</td>\n</tr>\n<tr>\n<td>Mobile Application</td>\n<td>bcrypt</td>\n<td>PBKDF2</td>\n<td>Cost 10-12</td>\n</tr>\n<tr>\n<td>Legacy System Migration</td>\n<td>PBKDF2 → bcrypt</td>\n<td>PBKDF2</td>\n<td>Gradual upgrade</td>\n</tr>\n</tbody></table>\n<p>The <strong>migration workflow</strong> handles the complex orchestration of upgrading password hashes without disrupting user experience. The system identifies candidates for migration based on algorithm age, security level, and user activity patterns, then performs upgrades transparently during successful authentication attempts.</p>\n<p><strong>Migration Process Algorithm:</strong></p>\n<ol>\n<li>User attempts authentication with current password</li>\n<li>System retrieves stored <code>PasswordHashRecord</code> and identifies algorithm version</li>\n<li>Verification proceeds using the original algorithm and parameters</li>\n<li>If verification succeeds and hash qualifies for upgrade, system checks migration policy</li>\n<li>Migration manager selects target algorithm based on current security recommendations</li>\n<li>System computes new hash using target algorithm and current password</li>\n<li>Database transaction updates user record with new hash while preserving backup of original</li>\n<li>System logs migration event for security auditing and rollback capabilities</li>\n</ol>\n<p>The migration system maintains <strong>migration metadata</strong> to track upgrade progress and support rollback scenarios. This metadata includes migration timestamps, source and target algorithms, and verification that the migration preserved authentication functionality.</p>\n<table>\n<thead>\n<tr>\n<th>Migration Management Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>assess_migration_candidate</code></td>\n<td><code>hash_record: PasswordHashRecord</code></td>\n<td><code>MigrationAssessment</code></td>\n<td>Evaluate whether hash should be upgraded</td>\n</tr>\n<tr>\n<td><code>execute_lazy_migration</code></td>\n<td><code>password: bytes, old_record: PasswordHashRecord</code></td>\n<td><code>PasswordHashRecord</code></td>\n<td>Upgrade hash during successful verification</td>\n</tr>\n<tr>\n<td><code>batch_migration_analysis</code></td>\n<td><code>user_records: list</code></td>\n<td><code>MigrationReport</code></td>\n<td>Analyze entire user database for migration opportunities</td>\n</tr>\n<tr>\n<td><code>rollback_migration</code></td>\n<td><code>user_id: str, backup_record: PasswordHashRecord</code></td>\n<td><code>bool</code></td>\n<td>Restore previous hash format if migration causes issues</td>\n</tr>\n<tr>\n<td><code>migration_progress_report</code></td>\n<td><code>date_range: tuple</code></td>\n<td><code>dict</code></td>\n<td>Generate statistics on migration completion rates</td>\n</tr>\n<tr>\n<td><code>schedule_migration_campaign</code></td>\n<td><code>target_algorithm: str, completion_deadline: datetime</code></td>\n<td><code>MigrationPlan</code></td>\n<td>Plan systematic migration of user base</td>\n</tr>\n</tbody></table>\n<h3 id=\"common-pitfalls-in-modern-hashing-implementation\">Common Pitfalls in Modern Hashing Implementation</h3>\n<p>⚠️ <strong>Pitfall: Implementing Cryptographic Algorithms from Scratch</strong></p>\n<p>Many developers attempt to implement bcrypt or Argon2 algorithms themselves rather than using established cryptographic libraries. This approach introduces severe security vulnerabilities because cryptographic implementations require extensive expertise in side-channel resistance, constant-time operations, and secure memory management. Even minor implementation errors can completely compromise the security properties that make these algorithms effective.</p>\n<p><strong>Why it&#39;s wrong:</strong> Cryptographic algorithms contain subtle implementation requirements that aren&#39;t obvious from reading algorithm specifications. For example, bcrypt requires specific memory clearing patterns and constant-time comparison operations that prevent timing attacks. These details are often omitted from academic papers but are critical for security.</p>\n<p><strong>How to fix:</strong> Always use well-established cryptographic libraries that have undergone extensive peer review and security auditing. In Python, use the <code>bcrypt</code> and <code>argon2-cffi</code> libraries. In Go, use <code>golang.org/x/crypto/bcrypt</code> and <code>github.com/argon2-cffi/argon2-cffi</code>. These libraries handle all low-level implementation details correctly.</p>\n<p>⚠️ <strong>Pitfall: Using Insufficient Cost Factors or Parameters</strong></p>\n<p>Developers often select cost factors or parameters based on development machine performance rather than production hardware and security requirements. This leads to password hashes that provide inadequate protection against modern attack techniques and specialized hardware.</p>\n<p><strong>Why it&#39;s wrong:</strong> Password cracking hardware improves rapidly, and attackers use specialized equipment like GPU clusters and ASICs that far exceed typical development hardware capabilities. A cost factor that seems adequate during development may provide minimal protection against real-world attacks.</p>\n<p><strong>How to fix:</strong> Measure performance on production hardware under realistic load conditions. Use industry minimum recommendations as starting points: bcrypt cost factor 12+ for new systems, Argon2 with 64MB+ memory cost. Implement regular security reviews that reassess parameter adequacy as hardware evolves.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Algorithm Migration Planning</strong></p>\n<p>Many systems implement modern hashing algorithms but fail to plan migration strategies for future algorithm upgrades. This creates <strong>technical debt</strong> that becomes increasingly expensive to resolve as the user base grows and security requirements evolve.</p>\n<p><strong>Why it&#39;s wrong:</strong> All cryptographic algorithms eventually become obsolete. Systems without migration capabilities face expensive emergency upgrades when security vulnerabilities emerge or compliance requirements change. Users may lose access to accounts if migration isn&#39;t handled properly.</p>\n<p><strong>How to fix:</strong> Design algorithm-agnostic hash storage from the beginning using formats like <code>PasswordHashRecord</code> that embed algorithm identification and parameters. Implement lazy migration workflows that upgrade hashes opportunistically during user authentication. Plan migration testing and rollback procedures before they&#39;re needed.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p><strong>Technology Recommendations:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Bcrypt Library</td>\n<td><code>bcrypt</code> (pip install bcrypt)</td>\n<td><code>passlib</code> with bcrypt backend</td>\n</tr>\n<tr>\n<td>Argon2 Library</td>\n<td><code>argon2-cffi</code> (pip install argon2-cffi)</td>\n<td><code>passlib</code> with Argon2 backend</td>\n</tr>\n<tr>\n<td>Parameter Storage</td>\n<td>JSON configuration files</td>\n<td>Database-backed parameter management</td>\n</tr>\n<tr>\n<td>Migration Management</td>\n<td>Manual upgrade scripts</td>\n<td>Automated migration workflows</td>\n</tr>\n<tr>\n<td>Performance Monitoring</td>\n<td>Simple timing measurements</td>\n<td>Statistical analysis with confidence intervals</td>\n</tr>\n</tbody></table>\n<p><strong>Recommended File Structure:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  password_hashing/\n    __init__.py\n    modern_hasher.py          ← ModernPasswordHasher implementation\n    bcrypt_integration.py     ← Bcrypt-specific functionality\n    argon2_integration.py     ← Argon2-specific functionality\n    algorithm_registry.py     ← Algorithm selection and dispatch\n    migration_manager.py      ← Migration workflows and policies\n    parameter_tuning.py       ← Performance benchmarking utilities\n  tests/\n    test_modern_hashing.py    ← Comprehensive algorithm testing\n    test_migration.py         ← Migration workflow testing\n    benchmark_performance.py  ← Performance measurement scripts\n  config/\n    algorithm_defaults.json   ← Default parameters for each algorithm\n    migration_policies.json   ← Migration rules and triggers</code></pre></div>\n\n<p><strong>Infrastructure Starter Code (Complete Implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># algorithm_registry.py - Complete algorithm registry system</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> importlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Type, Optional, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span><span style=\"color:#E1E4E8\">, abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PasswordHashRecord</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PasswordHashingAlgorithm</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Abstract base class for password hashing algorithm implementations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> hash_password</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs) -> PasswordHashRecord:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate password hash with algorithm-specific parameters.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify_password</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, hash_record: PasswordHashRecord) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify password against stored hash record.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_default_parameters</span><span style=\"color:#E1E4E8\">(self) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return recommended default parameters for this algorithm.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> benchmark_parameters</span><span style=\"color:#E1E4E8\">(self, target_time_ms: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Recommend parameters for target performance characteristics.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AlgorithmRegistry</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Registry for managing multiple password hashing algorithm implementations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._algorithms: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Type[PasswordHashingAlgorithm]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._default_algorithm: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._migration_preferences: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register_algorithm</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, algorithm_class: Type[PasswordHashingAlgorithm]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register a password hashing algorithm implementation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> issubclass</span><span style=\"color:#E1E4E8\">(algorithm_class, PasswordHashingAlgorithm):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Algorithm class must inherit from PasswordHashingAlgorithm\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._algorithms[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> algorithm_class</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_algorithm</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> PasswordHashingAlgorithm:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Retrieve algorithm implementation by name.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._algorithms:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unknown algorithm: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._algorithms[name]()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> set_default_algorithm</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set the default algorithm for new password hashes.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._algorithms:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Cannot set unknown algorithm as default: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._default_algorithm </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> name</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_default_algorithm</span><span style=\"color:#E1E4E8\">(self) -> PasswordHashingAlgorithm:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get the current default algorithm implementation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._default_algorithm </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> RuntimeError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"No default algorithm configured\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.get_algorithm(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._default_algorithm)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> list_available_algorithms</span><span style=\"color:#E1E4E8\">(self) -> List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return list of registered algorithm names.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> list</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._algorithms.keys())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> set_migration_preferences</span><span style=\"color:#E1E4E8\">(self, preferences: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Set preferred migration path ordering (most preferred first).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Validate all algorithms are registered</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> algorithm </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> preferences:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> algorithm </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._algorithms:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Migration preference includes unknown algorithm: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">algorithm</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._migration_preferences </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> preferences.copy()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_migration_target</span><span style=\"color:#E1E4E8\">(self, current_algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Determine target algorithm for migrating from current algorithm.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._migration_preferences:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._default_algorithm</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Find current algorithm in preference list</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            current_index </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._migration_preferences.index(current_algorithm)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # If not the most preferred, return the most preferred</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> current_index </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._migration_preferences[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Current algorithm not in preferences, return most preferred</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._migration_preferences[</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Already using most preferred algorithm</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Global algorithm registry instance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">algorithm_registry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> AlgorithmRegistry()</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># parameter_tuning.py - Complete performance benchmarking utilities</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> gc</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Callable, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BenchmarkResult</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Results from algorithm performance benchmarking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    algorithm: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parameters: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    mean_time_ms: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    median_time_ms: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    std_deviation_ms: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    min_time_ms: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    max_time_ms: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sample_count: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recommended: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PerformanceBenchmarker</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Utility for measuring password hashing algorithm performance.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, test_password: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">\"test_password_for_benchmarking\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.test_password </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> test_password</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.warmup_iterations </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 3</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.measurement_iterations </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> benchmark_function</span><span style=\"color:#E1E4E8\">(self, func: Callable, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Measure function execution time with statistical analysis.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Warmup runs to stabilize performance</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.warmup_iterations):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            func(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            gc.collect()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Measurement runs</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        times </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.measurement_iterations):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            func(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            end_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            times.append((end_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Convert to milliseconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            gc.collect()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'mean_ms'</span><span style=\"color:#E1E4E8\">: statistics.mean(times),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'median_ms'</span><span style=\"color:#E1E4E8\">: statistics.median(times),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'std_dev_ms'</span><span style=\"color:#E1E4E8\">: statistics.stdev(times) </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(times) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> else</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'min_ms'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">min</span><span style=\"color:#E1E4E8\">(times),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'max_ms'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">max</span><span style=\"color:#E1E4E8\">(times),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'sample_count'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(times)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> find_target_parameters</span><span style=\"color:#E1E4E8\">(self, algorithm_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, target_time_ms: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                             tolerance_ms: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 50.0</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Find algorithm parameters that achieve target execution time.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        from</span><span style=\"color:#E1E4E8\"> .algorithm_registry </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> algorithm_registry</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        algorithm </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> algorithm_registry.get_algorithm(algorithm_name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> algorithm_name.lower() </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'bcrypt'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._tune_bcrypt_cost(algorithm, target_time_ms, tolerance_ms)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        elif</span><span style=\"color:#E1E4E8\"> algorithm_name.lower().startswith(</span><span style=\"color:#9ECBFF\">'argon2'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._tune_argon2_parameters(algorithm, target_time_ms, tolerance_ms)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Parameter tuning not implemented for algorithm: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">algorithm_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _tune_bcrypt_cost</span><span style=\"color:#E1E4E8\">(self, algorithm, target_time_ms: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">, tolerance_ms: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Binary search to find optimal bcrypt cost factor.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        from</span><span style=\"color:#E1E4E8\"> .constants </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> BCRYPT_MIN_COST</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        min_cost </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> BCRYPT_MIN_COST</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        max_cost </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#6A737D\">  # Reasonable upper bound</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        best_cost </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> min_cost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        best_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> float</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'inf'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        while</span><span style=\"color:#E1E4E8\"> min_cost </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> max_cost:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            test_cost </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (min_cost </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> max_cost) </span><span style=\"color:#F97583\">//</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Measure performance at this cost level</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            timing_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.benchmark_function(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                algorithm.hash_password, </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                self</span><span style=\"color:#E1E4E8\">.test_password, </span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                cost</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">test_cost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            mean_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timing_result[</span><span style=\"color:#9ECBFF\">'mean_ms'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Check if this is within acceptable range</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#79B8FF\"> abs</span><span style=\"color:#E1E4E8\">(mean_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> target_time_ms) </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> tolerance_ms:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">'cost'</span><span style=\"color:#E1E4E8\">: test_cost, </span><span style=\"color:#9ECBFF\">'measured_time_ms'</span><span style=\"color:#E1E4E8\">: mean_time}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Track best option found so far</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#79B8FF\"> abs</span><span style=\"color:#E1E4E8\">(mean_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> target_time_ms) </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> abs</span><span style=\"color:#E1E4E8\">(best_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> target_time_ms):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                best_cost </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> test_cost</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                best_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> mean_time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Adjust search range</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> mean_time </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> target_time_ms:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                min_cost </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> test_cost </span><span style=\"color:#F97583\">+</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                max_cost </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> test_cost </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">'cost'</span><span style=\"color:#E1E4E8\">: best_cost, </span><span style=\"color:#9ECBFF\">'measured_time_ms'</span><span style=\"color:#E1E4E8\">: best_time}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _tune_argon2_parameters</span><span style=\"color:#E1E4E8\">(self, algorithm, target_time_ms: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">, tolerance_ms: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Find optimal Argon2 parameters through systematic search.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Start with reasonable defaults and adjust</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        base_params </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'memory_cost'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">65536</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># 64 MB</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'time_cost'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'parallelism'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">4</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Test base parameters</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timing_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.benchmark_function(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            algorithm.hash_password,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.test_password,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            **</span><span style=\"color:#E1E4E8\">base_params</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        current_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timing_result[</span><span style=\"color:#9ECBFF\">'mean_ms'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Adjust time_cost to get closer to target</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> current_time </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> target_time_ms:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Need more iterations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            while</span><span style=\"color:#E1E4E8\"> current_time </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> target_time_ms </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> tolerance_ms </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> base_params[</span><span style=\"color:#9ECBFF\">'time_cost'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                base_params[</span><span style=\"color:#9ECBFF\">'time_cost'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                timing_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.benchmark_function(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    algorithm.hash_password,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">.test_password,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    **</span><span style=\"color:#E1E4E8\">base_params</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                current_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timing_result[</span><span style=\"color:#9ECBFF\">'mean_ms'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Need fewer iterations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            while</span><span style=\"color:#E1E4E8\"> current_time </span><span style=\"color:#F97583\">></span><span style=\"color:#E1E4E8\"> target_time_ms </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> tolerance_ms </span><span style=\"color:#F97583\">and</span><span style=\"color:#E1E4E8\"> base_params[</span><span style=\"color:#9ECBFF\">'time_cost'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                base_params[</span><span style=\"color:#9ECBFF\">'time_cost'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">-=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                timing_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.benchmark_function(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    algorithm.hash_password,</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">.test_password,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    **</span><span style=\"color:#E1E4E8\">base_params</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                current_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timing_result[</span><span style=\"color:#9ECBFF\">'mean_ms'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        base_params[</span><span style=\"color:#9ECBFF\">'measured_time_ms'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> current_time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> base_params</span></span></code></pre></div>\n\n<p><strong>Core Logic Skeleton Code (for learner implementation):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># modern_hasher.py - Core modern hashing component (skeleton for learner implementation)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Optional, Union, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PasswordHashRecord, AlgorithmParameters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .algorithm_registry </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> algorithm_registry</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .migration_manager </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> MigrationManager</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ModernPasswordHasher</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Modern password hashing component supporting multiple algorithms with migration capabilities.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    This component provides the main interface for password hashing using bcrypt, Argon2, and other</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    modern algorithms. It handles algorithm selection, parameter management, and migration workflows.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, default_algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"bcrypt\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.default_algorithm </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> default_algorithm</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.migration_manager </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> MigrationManager()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize algorithm registry with bcrypt and Argon2 implementations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Set up default algorithm configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Load algorithm parameters from configuration files</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use algorithm_registry.register_algorithm() for each supported algorithm</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> hash_password</span><span style=\"color:#E1E4E8\">(self, password: Union[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                     algorithm: Optional[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                     **</span><span style=\"color:#E1E4E8\">algorithm_params) -> PasswordHashRecord:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Generate secure password hash using specified or default algorithm.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            password: The password to hash (string or bytes)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            algorithm: Algorithm name (bcrypt, argon2id) or None for default</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            **algorithm_params: Algorithm-specific parameters (cost, memory_cost, etc.)</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            PasswordHashRecord with all verification information</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate password input (check for None, empty, convert to bytes)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Select algorithm (use provided algorithm or fall back to default)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Get algorithm implementation from registry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Merge provided parameters with algorithm defaults</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Generate password hash using selected algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Create PasswordHashRecord with all necessary metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Validate the generated hash record before returning</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use algorithm_registry.get_algorithm() to get implementation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Call algorithm.get_default_parameters() and merge with algorithm_params</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify_password</span><span style=\"color:#E1E4E8\">(self, password: Union[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       hash_record: PasswordHashRecord,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       enable_migration: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Verify password against stored hash with optional migration.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            password: The password to verify</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            hash_record: Stored password hash record</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            enable_migration: Whether to perform lazy migration if hash is outdated</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if password matches, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Side Effects:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            May update hash_record with migrated hash if enable_migration=True</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate inputs (password not None/empty, hash_record valid)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Convert password to bytes if necessary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Get algorithm implementation for the stored hash algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Perform password verification using original algorithm and parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: If verification succeeds and enable_migration=True, check if migration needed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: If migration needed, generate new hash with current algorithm/parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Update hash_record with migrated hash (preserve original as backup)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Return verification result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use self.migration_manager.assess_migration_candidate() to check migration need</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use algorithm_registry.get_algorithm(hash_record.algorithm) for verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assess_hash_strength</span><span style=\"color:#E1E4E8\">(self, hash_record: PasswordHashRecord) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">any</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Analyze the security strength of a password hash record.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            hash_record: The hash record to analyze</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dictionary with strength assessment including recommendations</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract algorithm and parameters from hash record</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check algorithm against current security recommendations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate parameters meet minimum security requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Calculate estimated attack cost based on current hardware</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Determine if migration is recommended</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Generate strength score and recommendations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return comprehensive analysis dictionary</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Compare against constants like BCRYPT_MIN_COST, PBKDF2_MIN_ITERATIONS</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Include fields: strength_score, algorithm_current, parameters_adequate, migration_recommended</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> batch_migration_analysis</span><span style=\"color:#E1E4E8\">(self, hash_records: List[PasswordHashRecord]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">any</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Analyze a collection of password hashes for migration opportunities.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            hash_records: List of hash records to analyze</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Migration analysis report with statistics and recommendations</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize analysis counters and categorization</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Iterate through all hash records</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Categorize each record by algorithm and security level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Count records needing migration vs. adequate records</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Calculate migration effort estimates</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Generate prioritized migration recommendations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return comprehensive migration report</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use self.assess_hash_strength() for each record</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Group results by algorithm and create migration priority levels</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> benchmark_algorithm</span><span style=\"color:#E1E4E8\">(self, algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">parameters) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Benchmark algorithm performance with specified parameters.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            algorithm: Algorithm name to benchmark</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            **parameters: Algorithm-specific parameters to test</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Performance statistics including timing measurements</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Get algorithm implementation from registry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Create test password for consistent benchmarking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Set up performance measurement (warmup runs, timing)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Execute multiple hash operations with timing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Calculate statistical measures (mean, median, std dev)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Generate performance report with recommendations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return timing statistics and parameter recommendations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use time.perf_counter() for high-precision timing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Include warmup runs to stabilize performance measurements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># bcrypt_integration.py - Bcrypt algorithm implementation (skeleton)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> bcrypt</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PasswordHashRecord</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .algorithm_registry </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PasswordHashingAlgorithm</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .constants </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> BCRYPT_MIN_COST</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BcryptAlgorithm</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PasswordHashingAlgorithm</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Bcrypt password hashing algorithm implementation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> hash_password</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, cost: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs) -> PasswordHashRecord:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Generate bcrypt hash with specified cost factor.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate cost factor meets minimum security requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Generate bcrypt hash using library (bcrypt.hashpw)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Parse bcrypt output to extract algorithm version, cost, salt, and hash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Create PasswordHashRecord with extracted components</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Set appropriate algorithm identifier and version</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return completed hash record</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use bcrypt.hashpw(password, bcrypt.gensalt(rounds=cost))</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Bcrypt output format: $2b$cost$salt+hash (base64 encoded)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify_password</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, hash_record: PasswordHashRecord) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify password against stored bcrypt hash.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract bcrypt hash string from hash_record</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Use bcrypt.checkpw to verify password</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Handle any bcrypt library exceptions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return verification result</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: bcrypt.checkpw(password, stored_hash.encode()) returns boolean</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_default_parameters</span><span style=\"color:#E1E4E8\">(self) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return recommended bcrypt parameters.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Return dictionary with default cost factor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Include parameter descriptions and security rationale</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use BCRYPT_MIN_COST as minimum, recommend 12-14 for most applications</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> benchmark_parameters</span><span style=\"color:#E1E4E8\">(self, target_time_ms: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> Dict:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Find optimal bcrypt cost factor for target timing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Start with minimum cost factor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Measure hash computation time at current cost</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Adjust cost factor based on measured vs. target time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Use binary search to efficiently find optimal cost</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return recommended parameters with measured performance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Each cost increment doubles computation time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Language-Specific Hints:</strong></p>\n<ul>\n<li><strong>Library Installation</strong>: Use <code>pip install bcrypt argon2-cffi</code> for cryptographic libraries</li>\n<li><strong>Memory Management</strong>: Both bcrypt and Argon2 libraries handle secure memory clearing automatically</li>\n<li><strong>Threading Safety</strong>: bcrypt and argon2-cffi are thread-safe for concurrent operations</li>\n<li><strong>Error Handling</strong>: Wrap cryptographic operations in try-catch blocks for library-specific exceptions</li>\n<li><strong>Parameter Validation</strong>: Validate cost factors and memory parameters before passing to libraries</li>\n<li><strong>Performance Monitoring</strong>: Use <code>time.perf_counter()</code> for high-precision benchmarking measurements</li>\n</ul>\n<p><strong>Milestone Checkpoint:</strong></p>\n<p>After implementing the modern hashing component, verify functionality:</p>\n<ol>\n<li><strong>Algorithm Integration Test</strong>:</li>\n</ol>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_modern_hashing.py::test_bcrypt_integration</span><span style=\"color:#79B8FF\"> -v</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">   python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/test_modern_hashing.py::test_argon2_integration</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<ol start=\"2\">\n<li><p><strong>Expected Behavior</strong>: </p>\n<ul>\n<li>Bcrypt hashes should start with <code>$2b$</code> and include cost factor in format</li>\n<li>Argon2 hashes should start with <code>$argon2id$</code> and include all parameters</li>\n<li>Parameter tuning should recommend cost factors based on measured performance</li>\n<li>Migration assessment should identify outdated hashes and recommend upgrades</li>\n</ul>\n</li>\n<li><p><strong>Manual Verification</strong>:</p>\n<ul>\n<li>Generate bcrypt hash with cost 12, verify timing is 100-500ms on your hardware</li>\n<li>Generate Argon2 hash with 64MB memory, verify memory usage during operation</li>\n<li>Test migration workflow by creating PBKDF2 hash then upgrading to bcrypt</li>\n<li>Verify hash records contain all necessary parameters for future verification</li>\n</ul>\n</li>\n<li><p><strong>Performance Validation</strong>:</p>\n<ul>\n<li>Run benchmark suite: <code>python benchmark_performance.py --algorithms bcrypt,argon2id</code></li>\n<li>Verify cost factor recommendations scale appropriately with target timing</li>\n<li>Test concurrent authentication load doesn&#39;t cause memory exhaustion with Argon2</li>\n</ul>\n</li>\n</ol>\n<p><strong>Debugging Tips:</strong></p>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ValueError: Invalid rounds</code></td>\n<td>Cost factor too low for bcrypt</td>\n<td>Check cost &lt; BCRYPT_MIN_COST</td>\n<td>Increase cost factor to 12+</td>\n</tr>\n<tr>\n<td><code>MemoryError</code> with Argon2</td>\n<td>Memory cost too high for system</td>\n<td>Monitor system memory during hash</td>\n<td>Reduce memory_cost parameter</td>\n</tr>\n<tr>\n<td>Hash verification always fails</td>\n<td>Algorithm mismatch or corrupted hash</td>\n<td>Print algorithm from hash_record</td>\n<td>Verify algorithm registration and hash format</td>\n</tr>\n<tr>\n<td>Performance much slower than expected</td>\n<td>Wrong algorithm or excessive parameters</td>\n<td>Time individual hash operations</td>\n<td>Tune parameters with benchmark_algorithm()</td>\n</tr>\n<tr>\n<td>Migration not triggering</td>\n<td>Migration policies too restrictive</td>\n<td>Check migration_manager.assess_migration_candidate()</td>\n<td>Adjust migration thresholds in configuration</td>\n</tr>\n</tbody></table>\n<h2 id=\"interactions-and-data-flow\">Interactions and Data Flow</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (complete data flow spans all implementation phases)</p>\n</blockquote>\n<h3 id=\"mental-model-the-airport-security-processing-pipeline\">Mental Model: The Airport Security Processing Pipeline</h3>\n<p>Think of password processing like an airport security checkpoint system. When passengers arrive at security, they follow a standardized processing pipeline: they present their ID, remove items for scanning, pass through detection equipment, and receive clearance to proceed. The system handles two distinct flows - initial passenger enrollment (when someone first registers for TSA PreCheck) and routine verification (daily security screening).</p>\n<p>Similarly, our password hashing system orchestrates two critical data flows. During <strong>password registration</strong>, a new user&#39;s plain password enters our security pipeline, gets processed through salt generation and hashing components, and emerges as a secure hash record ready for storage. During <strong>password verification</strong>, a stored hash record and incoming password attempt flow through verification components that reconstruct the original hashing process and perform constant-time comparison.</p>\n<p>Just as airport security maintains detailed logs of every passenger interaction and follows strict protocols regardless of passenger status, our system maintains comprehensive audit trails and follows identical processing steps whether handling a brand new password or verifying an existing one. The pipeline architecture ensures that every password receives the same rigorous security treatment while maintaining clear separation between the registration and verification flows.</p>\n<p><img src=\"/api/project/password-hashing/architecture-doc/asset?path=diagrams%2Fregistration-sequence.svg\" alt=\"Password Registration Sequence\"></p>\n<p><img src=\"/api/project/password-hashing/architecture-doc/asset?path=diagrams%2Fverification-sequence.svg\" alt=\"Password Verification Sequence\"></p>\n<h3 id=\"password-registration-flow\">Password Registration Flow</h3>\n<p>The password registration flow represents the complete journey from user password input through cryptographic processing to secure storage. This flow must execute identically regardless of which hashing algorithm the system employs, ensuring consistent security properties across all implementation milestones.</p>\n<h4 id=\"registration-flow-architecture\">Registration Flow Architecture</h4>\n<p>The registration flow follows a strict sequential processing model where each component performs its specialized function and passes validated output to the next stage. This pipeline architecture prevents bypassing security steps and ensures complete audit trails for every password registration attempt.</p>\n<blockquote>\n<p><strong>Decision: Sequential Pipeline Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Password registration involves multiple independent cryptographic operations (salt generation, hashing, parameter validation) that must execute in correct order</li>\n<li><strong>Options Considered</strong>: <ul>\n<li>Monolithic registration function handling all steps internally</li>\n<li>Sequential pipeline with clear component boundaries</li>\n<li>Event-driven asynchronous processing with message queues</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Sequential pipeline with synchronous component interactions</li>\n<li><strong>Rationale</strong>: Cryptographic operations require deterministic ordering and error handling. Sequential processing provides clear failure points and simplifies debugging. Asynchronous processing introduces timing attack vectors and complicates constant-time guarantees.</li>\n<li><strong>Consequences</strong>: Enables component-level testing and validation. Requires careful error propagation design. Provides clear audit trail for security analysis.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Registration Stage</th>\n<th>Component Responsible</th>\n<th>Input Data</th>\n<th>Output Data</th>\n<th>Validation Performed</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Input Validation</td>\n<td>PasswordHashingService</td>\n<td>Raw password string</td>\n<td>Validated password</td>\n<td>Length, character set, encoding</td>\n</tr>\n<tr>\n<td>Salt Generation</td>\n<td>SaltGenerator</td>\n<td>Validation success</td>\n<td>Cryptographic salt bytes</td>\n<td>Entropy verification, length check</td>\n</tr>\n<tr>\n<td>Algorithm Selection</td>\n<td>AlgorithmRegistry</td>\n<td>User preferences, policy</td>\n<td>Algorithm instance</td>\n<td>Availability check, parameter validation</td>\n</tr>\n<tr>\n<td>Hash Computation</td>\n<td>Selected Algorithm</td>\n<td>Password + salt + parameters</td>\n<td>Hash bytes</td>\n<td>Computation success, output length</td>\n</tr>\n<tr>\n<td>Record Assembly</td>\n<td>PasswordHashingService</td>\n<td>All components</td>\n<td>PasswordHashRecord</td>\n<td>Completeness, consistency</td>\n</tr>\n<tr>\n<td>Storage Preparation</td>\n<td>PasswordHashingService</td>\n<td>Complete record</td>\n<td>Serialized format</td>\n<td>Serialization integrity</td>\n</tr>\n</tbody></table>\n<h4 id=\"detailed-registration-process\">Detailed Registration Process</h4>\n<p>The registration process follows these precise steps, with each step including comprehensive error handling and security validation:</p>\n<ol>\n<li><p><strong>Password Input Validation</strong>: The system receives the raw password string and validates it meets basic requirements. This includes checking for null values, empty strings, and character encoding issues. The validation does not enforce password strength policies (that responsibility belongs to application-level components), but ensures the input is processable by cryptographic functions.</p>\n</li>\n<li><p><strong>Algorithm Selection and Configuration</strong>: Based on system configuration and user preferences, the <code>AlgorithmRegistry</code> selects the appropriate hashing algorithm. For Milestone 1, this defaults to <code>BasicHasher</code> with SHA-256. For Milestone 2, <code>KeyStretchingHasher</code> with PBKDF2 becomes available. For Milestone 3, <code>ModernPasswordHasher</code> provides bcrypt and Argon2 options. The registry validates that the selected algorithm is available and properly configured.</p>\n</li>\n<li><p><strong>Parameter Validation and Tuning</strong>: The selected algorithm validates its parameters meet security requirements. For basic hashing, this verifies salt length meets <code>MINIMUM_SALT_LENGTH</code>. For key stretching, this ensures iteration count exceeds <code>PBKDF2_MIN_ITERATIONS</code>. For modern algorithms, this validates cost factors and memory parameters. The <code>ParameterValidator</code> component performs these checks and raises <code>ParameterValidationError</code> for invalid configurations.</p>\n</li>\n<li><p><strong>Cryptographic Salt Generation</strong>: The <code>SaltGenerator</code> component produces a cryptographically secure random salt. This process accesses the system&#39;s entropy source (typically <code>/dev/urandom</code> on Unix systems or <code>CryptGenRandom</code> on Windows) and verifies sufficient entropy is available. If entropy is exhausted, the system raises <code>EntropyExhaustionError</code> rather than proceeding with predictable randomness.</p>\n</li>\n<li><p><strong>Hash Computation</strong>: The selected algorithm combines the validated password, generated salt, and configured parameters to compute the cryptographic hash. For basic hashing, this involves SHA-256 computation over concatenated password and salt. For PBKDF2, this involves iterative HMAC-SHA256 rounds. For bcrypt/Argon2, this delegates to the respective library implementations. Computation failures raise <code>HashComputationError</code>.</p>\n</li>\n<li><p><strong>Hash Record Assembly</strong>: The system constructs a complete <code>PasswordHashRecord</code> containing the algorithm identifier, salt bytes, hash bytes, algorithm parameters, version number, and creation timestamp. This record is self-contained and includes all information necessary for future password verification without relying on external configuration.</p>\n</li>\n<li><p><strong>Record Validation</strong>: Before finalizing the registration, the system validates the assembled record by calling <code>validate()</code> on the <code>PasswordHashRecord</code>. This ensures all required fields are populated, parameter dictionaries contain valid values, and the record structure is internally consistent.</p>\n</li>\n<li><p><strong>Storage Serialization</strong>: The validated record undergoes serialization using either <code>to_json()</code> for structured storage systems or <code>to_string_format()</code> for compact string-based storage. The serialization process includes integrity checks to verify the serialized data can be correctly deserialized.</p>\n</li>\n</ol>\n<h4 id=\"registration-data-flow-example\">Registration Data Flow Example</h4>\n<p>Consider a concrete example of registering the password <code>&quot;secure123&quot;</code> using PBKDF2 with 150,000 iterations:</p>\n<p><strong>Input Phase</strong>: The application calls <code>hash_password(&quot;secure123&quot;, &quot;pbkdf2&quot;, iterations=150000)</code>. The system validates the password string is valid UTF-8 and non-empty.</p>\n<p><strong>Algorithm Selection</strong>: The <code>AlgorithmRegistry</code> locates the <code>KeyStretchingHasher</code> algorithm and validates PBKDF2 is available. It creates an <code>AlgorithmParameters</code> instance with the requested 150,000 iterations and default 32-byte key length.</p>\n<p><strong>Parameter Validation</strong>: The <code>ParameterValidator</code> confirms 150,000 exceeds <code>PBKDF2_MIN_ITERATIONS</code> (100,000) and the 32-byte key length is within acceptable bounds. Validation passes.</p>\n<p><strong>Salt Generation</strong>: The <code>SaltGenerator</code> requests 32 bytes of random data from the system entropy source. It receives bytes like <code>b&#39;\\x8f\\x3a\\x7b...[32 bytes total]&#39;</code> and verifies the entropy pool is not exhausted.</p>\n<p><strong>Hash Computation</strong>: The <code>KeyStretchingHasher</code> invokes <code>hash_password_with_stretching()</code> with the password, salt, and 150,000 iterations. PBKDF2-HMAC-SHA256 executes 150,000 rounds, producing a 32-byte derived key.</p>\n<p><strong>Record Assembly</strong>: The system creates a <code>PasswordHashRecord</code> with:</p>\n<ul>\n<li><code>algorithm</code>: <code>&quot;pbkdf2&quot;</code></li>\n<li><code>salt</code>: The 32-byte random salt</li>\n<li><code>hash</code>: The 32-byte derived key</li>\n<li><code>parameters</code>: <code>{&quot;iterations&quot;: 150000, &quot;key_length&quot;: 32, &quot;hash_function&quot;: &quot;sha256&quot;}</code></li>\n<li><code>version</code>: <code>1</code></li>\n<li><code>created_at</code>: Current timestamp</li>\n</ul>\n<p><strong>Validation and Storage</strong>: The record passes validation checks. Serialization produces a JSON string containing all fields, ready for database storage.</p>\n<h4 id=\"registration-error-handling\">Registration Error Handling</h4>\n<p>The registration flow implements comprehensive error handling with specific recovery strategies for each failure mode:</p>\n<table>\n<thead>\n<tr>\n<th>Error Type</th>\n<th>Failure Scenario</th>\n<th>Detection Method</th>\n<th>Recovery Action</th>\n<th>Security Implication</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Input Validation</td>\n<td>Null/empty password</td>\n<td>Length check</td>\n<td>Return validation error</td>\n<td>Prevents processing invalid input</td>\n</tr>\n<tr>\n<td>Entropy Exhaustion</td>\n<td><code>/dev/urandom</code> unavailable</td>\n<td>OS error on read</td>\n<td>Retry with backoff, then fail</td>\n<td>Prevents predictable salt generation</td>\n</tr>\n<tr>\n<td>Algorithm Unavailable</td>\n<td>Requested algorithm not installed</td>\n<td>Registry lookup failure</td>\n<td>Fall back to default algorithm</td>\n<td>Maintains service availability</td>\n</tr>\n<tr>\n<td>Parameter Invalid</td>\n<td>Iteration count too low</td>\n<td>Parameter validation</td>\n<td>Use secure defaults</td>\n<td>Prevents weak configuration</td>\n</tr>\n<tr>\n<td>Hash Computation</td>\n<td>Cryptographic library error</td>\n<td>Exception during hashing</td>\n<td>Log error and fail</td>\n<td>Prevents corrupted hash storage</td>\n</tr>\n<tr>\n<td>Serialization Failure</td>\n<td>Record too large for storage</td>\n<td>Serialization exception</td>\n<td>Optimize parameters and retry</td>\n<td>Prevents storage system errors</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Partial Registration Recovery</strong>\nA common mistake is attempting to recover from mid-pipeline failures by reusing already-generated components (like keeping the salt but regenerating the hash). This creates timing-dependent behavior that can leak information through side channels. Always restart the entire registration process from input validation when any component fails.</p>\n</blockquote>\n<h4 id=\"registration-performance-monitoring\">Registration Performance Monitoring</h4>\n<p>The registration flow includes performance monitoring to detect security parameter tuning needs and system capacity planning:</p>\n<table>\n<thead>\n<tr>\n<th>Monitoring Metric</th>\n<th>Measurement Method</th>\n<th>Normal Range</th>\n<th>Alert Threshold</th>\n<th>Response Action</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Salt Generation Time</td>\n<td>Timestamp before/after generation</td>\n<td>&lt; 1ms</td>\n<td>&gt; 10ms</td>\n<td>Check entropy source</td>\n</tr>\n<tr>\n<td>Hash Computation Time</td>\n<td>Algorithm-specific benchmarking</td>\n<td>Varies by algorithm</td>\n<td>2x expected</td>\n<td>Reduce parameters</td>\n</tr>\n<tr>\n<td>Total Registration Time</td>\n<td>End-to-end measurement</td>\n<td>&lt; 500ms typical</td>\n<td>&gt; 2 seconds</td>\n<td>System capacity review</td>\n</tr>\n<tr>\n<td>Success Rate</td>\n<td>Registration completion ratio</td>\n<td>&gt; 99.9%</td>\n<td>&lt; 99%</td>\n<td>Investigate failures</td>\n</tr>\n<tr>\n<td>Parameter Distribution</td>\n<td>Algorithm/parameter usage</td>\n<td>Expected distribution</td>\n<td>Skew &gt; 20%</td>\n<td>Review defaults</td>\n</tr>\n</tbody></table>\n<h3 id=\"password-verification-flow\">Password Verification Flow</h3>\n<p>The password verification flow reconstructs the original registration process using stored hash record information and compares the result against the stored hash using constant-time comparison. This flow must resist timing attacks and provide identical execution patterns regardless of password correctness.</p>\n<h4 id=\"verification-flow-architecture\">Verification Flow Architecture</h4>\n<p>The verification flow implements a <strong>reconstruction and comparison</strong> model where the system recreates the exact hashing process used during registration and performs cryptographically secure comparison of results. This approach ensures verification succeeds only when the input password produces identical cryptographic output through identical processing steps.</p>\n<blockquote>\n<p><strong>Decision: Reconstruction-Based Verification</strong></p>\n<ul>\n<li><strong>Context</strong>: Password verification must confirm an input password produces the same hash as originally stored, while preventing timing attacks and maintaining algorithm agility</li>\n<li><strong>Options Considered</strong>:<ul>\n<li>Direct hash comparison after re-hashing with stored parameters</li>\n<li>Database query-based verification with hash comparison in database</li>\n<li>Token-based verification avoiding password re-hashing</li>\n</ul>\n</li>\n<li><strong>Decision</strong>: Reconstruct original hashing process and use constant-time comparison</li>\n<li><strong>Rationale</strong>: Reconstruction ensures identical cryptographic operations regardless of algorithm evolution. Constant-time comparison prevents timing side channels. Database-level comparison leaks timing information and reduces algorithm flexibility.</li>\n<li><strong>Consequences</strong>: Provides strong timing attack resistance. Requires careful constant-time implementation. Enables seamless algorithm migration during verification.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Verification Stage</th>\n<th>Component Responsible</th>\n<th>Input Data</th>\n<th>Processing Action</th>\n<th>Security Property</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Record Retrieval</td>\n<td>Storage Interface</td>\n<td>User identifier</td>\n<td>Deserialize hash record</td>\n<td>Data integrity verification</td>\n</tr>\n<tr>\n<td>Record Validation</td>\n<td>PasswordHashRecord</td>\n<td>Stored record</td>\n<td>Field completeness check</td>\n<td>Prevents corrupted data processing</td>\n</tr>\n<tr>\n<td>Algorithm Resolution</td>\n<td>AlgorithmRegistry</td>\n<td>Algorithm identifier</td>\n<td>Locate algorithm instance</td>\n<td>Ensures algorithm availability</td>\n</tr>\n<tr>\n<td>Parameter Extraction</td>\n<td>PasswordHashRecord</td>\n<td>Parameter dictionary</td>\n<td>Extract algorithm configuration</td>\n<td>Preserves original settings</td>\n</tr>\n<tr>\n<td>Hash Reconstruction</td>\n<td>Selected Algorithm</td>\n<td>Password + stored salt + parameters</td>\n<td>Re-execute hashing process</td>\n<td>Identical cryptographic computation</td>\n</tr>\n<tr>\n<td>Constant-Time Comparison</td>\n<td>Security utilities</td>\n<td>Computed hash + stored hash</td>\n<td>Byte-by-byte timing-safe comparison</td>\n<td>Prevents timing side channels</td>\n</tr>\n<tr>\n<td>Migration Assessment</td>\n<td>MigrationManager</td>\n<td>Hash record age/strength</td>\n<td>Evaluate upgrade necessity</td>\n<td>Opportunistic security improvements</td>\n</tr>\n</tbody></table>\n<h4 id=\"detailed-verification-process\">Detailed Verification Process</h4>\n<p>The verification process executes these steps with careful attention to timing consistency and side-channel resistance:</p>\n<ol>\n<li><p><strong>Hash Record Retrieval and Deserialization</strong>: The system retrieves the stored hash record using the user identifier and deserializes it from JSON or string format. The deserialization process validates the record structure and raises <code>ValidationError</code> if required fields are missing or corrupted. This step must complete in consistent time regardless of record contents to prevent user enumeration attacks.</p>\n</li>\n<li><p><strong>Record Integrity Validation</strong>: The system calls <code>validate()</code> on the deserialized <code>PasswordHashRecord</code> to verify internal consistency. This checks that the algorithm identifier is recognized, salt and hash lengths are appropriate for the algorithm, and parameter dictionaries contain required values. Invalid records indicate either corruption or attempted tampering.</p>\n</li>\n<li><p><strong>Algorithm Instance Resolution</strong>: Using the <code>algorithm</code> field from the hash record, the <code>AlgorithmRegistry</code> locates the appropriate algorithm implementation. For records created in Milestone 1, this resolves to <code>BasicHasher</code>. For PBKDF2 records, this resolves to <code>KeyStretchingHasher</code>. For modern algorithm records, this resolves to the specific <code>BcryptAlgorithm</code> or <code>Argon2Algorithm</code> implementation.</p>\n</li>\n<li><p><strong>Parameter Reconstruction</strong>: The verification process extracts algorithm parameters from the stored record&#39;s <code>parameters</code> dictionary. This ensures the re-hashing process uses identical settings to the original registration, including iteration counts, key lengths, memory costs, and algorithm variants. Parameter extraction preserves the exact configuration active at registration time.</p>\n</li>\n<li><p><strong>Salt and Password Preparation</strong>: The system extracts the stored salt bytes from the hash record and combines them with the input password according to the algorithm&#39;s requirements. For basic hashing, this involves simple concatenation. For PBKDF2, this provides the salt parameter to the key derivation function. For bcrypt/Argon2, this follows the algorithm-specific salt incorporation mechanisms.</p>\n</li>\n<li><p><strong>Hash Reconstruction</strong>: The selected algorithm re-executes the complete hashing process using the input password, stored salt, and stored parameters. This produces a fresh hash that should be identical to the stored hash if the input password is correct. The reconstruction must use identical computational steps to prevent timing differences based on password correctness.</p>\n</li>\n<li><p><strong>Constant-Time Comparison</strong>: The system compares the reconstructed hash against the stored hash using <code>constant_time_compare()</code>. This function compares every byte regardless of early mismatches, ensuring execution time depends only on hash length, not on password correctness or mismatch location. The comparison result is a boolean indicating password validity.</p>\n</li>\n<li><p><strong>Migration Assessment and Execution</strong>: If verification succeeds and the hash record indicates outdated security parameters, the <code>MigrationManager</code> assesses whether lazy migration should occur. This involves creating a new hash record with current security parameters and replacing the stored record transparently during the verification process.</p>\n</li>\n</ol>\n<h4 id=\"verification-data-flow-example\">Verification Data Flow Example</h4>\n<p>Consider verifying the password <code>&quot;secure123&quot;</code> against a stored PBKDF2 hash record:</p>\n<p><strong>Record Retrieval</strong>: The system retrieves a hash record containing algorithm <code>&quot;pbkdf2&quot;</code>, 32-byte salt, 32-byte hash, and parameters <code>{&quot;iterations&quot;: 150000, &quot;key_length&quot;: 32, &quot;hash_function&quot;: &quot;sha256&quot;}</code>.</p>\n<p><strong>Validation</strong>: The record passes integrity validation with all required fields present and parameter values within acceptable ranges.</p>\n<p><strong>Algorithm Resolution</strong>: The <code>AlgorithmRegistry</code> locates the <code>KeyStretchingHasher</code> and confirms PBKDF2 support is available.</p>\n<p><strong>Hash Reconstruction</strong>: The system calls <code>hash_password_with_stretching(&quot;secure123&quot;, 150000, 32)</code> using the stored salt. PBKDF2 executes 150,000 iterations of HMAC-SHA256, producing a 32-byte derived key.</p>\n<p><strong>Comparison</strong>: <code>constant_time_compare()</code> compares the reconstructed 32-byte key against the stored 32-byte hash. The function examines all 32 bytes regardless of match/mismatch status, taking identical time for correct and incorrect passwords.</p>\n<p><strong>Result</strong>: If the reconstructed hash matches the stored hash exactly, verification returns <code>True</code>. Otherwise, it returns <code>False</code> without indicating where the mismatch occurred.</p>\n<h4 id=\"verification-timing-attack-prevention\">Verification Timing Attack Prevention</h4>\n<p>The verification flow implements multiple layers of timing attack resistance to prevent password-related information leakage:</p>\n<table>\n<thead>\n<tr>\n<th>Timing Attack Vector</th>\n<th>Vulnerable Implementation</th>\n<th>Secure Implementation</th>\n<th>Timing Consistency Mechanism</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Early Comparison Exit</td>\n<td>Stop comparing on first byte mismatch</td>\n<td>Compare all bytes regardless</td>\n<td>Fixed-time loop over full hash length</td>\n</tr>\n<tr>\n<td>Branch-Based Timing</td>\n<td>Different code paths for match/mismatch</td>\n<td>Identical operations both cases</td>\n<td>Branchless comparison using bitwise operations</td>\n</tr>\n<tr>\n<td>Hash Length Variation</td>\n<td>Different comparison times for different algorithms</td>\n<td>Normalize to maximum hash length</td>\n<td>Pad comparison to consistent length</td>\n</tr>\n<tr>\n<td>Record Lookup Timing</td>\n<td>Fast failure for non-existent users</td>\n<td>Consistent processing time</td>\n<td>Dummy processing for missing records</td>\n</tr>\n<tr>\n<td>Algorithm Dispatch</td>\n<td>Different timing for different algorithms</td>\n<td>Equalize algorithm selection time</td>\n<td>Consistent algorithm resolution overhead</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>⚠️ <strong>Pitfall: Timing Attack Through Error Messages</strong>\nReturning different error messages for &quot;user not found&quot; versus &quot;invalid password&quot; creates a timing side channel even with constant-time comparison. Always return identical generic error messages like &quot;authentication failed&quot; regardless of the specific failure reason.</p>\n</blockquote>\n<h4 id=\"verification-error-handling-and-recovery\">Verification Error Handling and Recovery</h4>\n<p>The verification flow implements defensive error handling that maintains security properties even during failure scenarios:</p>\n<table>\n<thead>\n<tr>\n<th>Error Condition</th>\n<th>Detection Method</th>\n<th>Secure Response</th>\n<th>Security Rationale</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>User Not Found</td>\n<td>Database lookup failure</td>\n<td>Execute dummy hash computation</td>\n<td>Prevents user enumeration timing</td>\n</tr>\n<tr>\n<td>Corrupted Hash Record</td>\n<td>Deserialization exception</td>\n<td>Return authentication failure</td>\n<td>Prevents oracle attacks on storage</td>\n</tr>\n<tr>\n<td>Algorithm Unavailable</td>\n<td>Registry lookup failure</td>\n<td>Return authentication failure</td>\n<td>Prevents downgrade attacks</td>\n</tr>\n<tr>\n<td>Hash Reconstruction Failure</td>\n<td>Algorithm exception</td>\n<td>Return authentication failure</td>\n<td>Prevents partial verification bypass</td>\n</tr>\n<tr>\n<td>Migration Failure</td>\n<td>Migration exception</td>\n<td>Allow verification success, log error</td>\n<td>Maintains availability during upgrades</td>\n</tr>\n</tbody></table>\n<h4 id=\"lazy-migration-during-verification\">Lazy Migration During Verification</h4>\n<p>When verification succeeds but the hash record indicates outdated security parameters, the system can perform <strong>lazy migration</strong> to upgrade the hash transparently:</p>\n<ol>\n<li><p><strong>Migration Assessment</strong>: The <code>MigrationManager</code> evaluates the current hash record against current security standards. Factors include algorithm age, parameter strength, and organizational security policies.</p>\n</li>\n<li><p><strong>Migration Decision</strong>: If migration is recommended, the system generates a new hash record using current algorithms and parameters while preserving the successful password verification result.</p>\n</li>\n<li><p><strong>Atomic Replacement</strong>: The system atomically replaces the stored hash record with the upgraded version, ensuring no data loss if the replacement fails.</p>\n</li>\n<li><p><strong>Migration Logging</strong>: Successful migrations are logged for security audit purposes, including the old and new algorithm details and migration timestamp.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Migration triggers include</strong>:</p>\n<ul>\n<li>Algorithm age exceeding policy thresholds (e.g., SHA-256 records older than 2 years)</li>\n<li>Parameter weakness below current minimums (e.g., PBKDF2 with &lt; 100,000 iterations)</li>\n<li>Algorithm deprecation announcements (e.g., bcrypt cost factor &lt; 12)</li>\n<li>Organizational policy changes requiring stronger protection</li>\n</ul>\n</blockquote>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Flow Orchestration</td>\n<td>Single service class with method calls</td>\n<td>Event-driven pipeline with message passing</td>\n</tr>\n<tr>\n<td>Error Handling</td>\n<td>Exception-based with try/catch blocks</td>\n<td>Result types with explicit error propagation</td>\n</tr>\n<tr>\n<td>Timing Attack Prevention</td>\n<td>Manual constant-time implementation</td>\n<td>Cryptographic library timing-safe functions</td>\n</tr>\n<tr>\n<td>Performance Monitoring</td>\n<td>Simple logging with timestamps</td>\n<td>Metrics collection with statistical analysis</td>\n</tr>\n<tr>\n<td>Migration Management</td>\n<td>Database triggers with stored procedures</td>\n<td>Application-level lazy migration with audit trail</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>password-hashing/\n  src/\n    core/\n      password_service.py       ← Main orchestration service\n      flow_coordinator.py       ← Registration/verification flows\n      timing_security.py        ← Constant-time utilities\n    algorithms/\n      basic_hasher.py          ← From previous sections\n      key_stretching.py        ← From previous sections  \n      modern_hasher.py         ← From previous sections\n    security/\n      migration_manager.py     ← Hash upgrade logic\n      audit_logger.py          ← Security event logging\n    storage/\n      hash_repository.py       ← Storage interface\n      serialization.py         ← Record serialization\n  tests/\n    test_flows.py              ← Registration/verification flow tests\n    test_timing_attacks.py     ← Side-channel resistance tests\n    test_migration.py          ← Lazy migration tests</code></pre></div>\n\n<h4 id=\"infrastructure-starter-code\">Infrastructure Starter Code</h4>\n<p><strong>Timing Security Utilities</strong> (complete implementation):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hmac</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Dict, List, Callable</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TimingSecurity</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Utilities for preventing timing-based side channel attacks.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> constant_time_compare</span><span style=\"color:#E1E4E8\">(a: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, b: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Compare two byte strings in constant time regardless of content.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Uses HMAC-based comparison to prevent timing attacks through</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        branch prediction and memory access patterns.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(a) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(b):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Still perform comparison to maintain timing consistency</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            b </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> b[:</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(a)] </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(b) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(a) </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">+</span><span style=\"color:#F97583\"> b</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\x00</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(a) </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(b))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> hmac.compare_digest(a, b)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> execute_with_minimum_time</span><span style=\"color:#E1E4E8\">(func: Callable, min_time_ms: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute function with guaranteed minimum execution time.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Prevents timing attacks that rely on measuring operation duration.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> func(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        elapsed_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (time.perf_counter() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> elapsed_ms </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> min_time_ms:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            time.sleep((min_time_ms </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> elapsed_ms) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify_timing_consistency</span><span style=\"color:#E1E4E8\">(func: Callable, test_cases: List[</span><span style=\"color:#79B8FF\">tuple</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                tolerance_ms: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5.0</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Verify function execution time is consistent across different inputs.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timings </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> case </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> test_cases:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            func(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">case)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            elapsed_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (time.perf_counter() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            timings.append(elapsed_ms)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        avg_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> sum</span><span style=\"color:#E1E4E8\">(timings) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(timings)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        max_deviation </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> max</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">abs</span><span style=\"color:#E1E4E8\">(t </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> avg_time) </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> t </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> timings)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'average_time_ms'</span><span style=\"color:#E1E4E8\">: avg_time,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'max_deviation_ms'</span><span style=\"color:#E1E4E8\">: max_deviation,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'timing_consistent'</span><span style=\"color:#E1E4E8\">: max_deviation </span><span style=\"color:#F97583\">&#x3C;=</span><span style=\"color:#E1E4E8\"> tolerance_ms,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'individual_timings'</span><span style=\"color:#E1E4E8\">: timings</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span></code></pre></div>\n\n<p><strong>Storage Repository Interface</strong> (complete implementation):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span><span style=\"color:#E1E4E8\">, abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> logging</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asdict</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> core.data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PasswordHashRecord</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HashRepository</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Abstract interface for password hash storage operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> store_hash_record</span><span style=\"color:#E1E4E8\">(self, user_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, record: PasswordHashRecord) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Store a password hash record for the specified user.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> retrieve_hash_record</span><span style=\"color:#E1E4E8\">(self, user_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[PasswordHashRecord]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Retrieve stored password hash record for the specified user.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> update_hash_record</span><span style=\"color:#E1E4E8\">(self, user_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, record: PasswordHashRecord) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Update existing hash record (used for lazy migration).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> InMemoryHashRepository</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">HashRepository</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Simple in-memory hash storage for development and testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._storage: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._logger </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> logging.getLogger(</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> store_hash_record</span><span style=\"color:#E1E4E8\">(self, user_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, record: PasswordHashRecord) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Store hash record as JSON string.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            serialized </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> record.to_json()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._storage[user_id] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> serialized</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._logger.info(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Stored hash record for user </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">user_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> using </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">record.algorithm</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Failed to store hash record for user </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">user_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> retrieve_hash_record</span><span style=\"color:#E1E4E8\">(self, user_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[PasswordHashRecord]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Retrieve and deserialize hash record.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> user_id </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._storage:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Execute timing-consistent dummy processing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                dummy_data </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> '{\"algorithm\": \"dummy\", \"version\": 1}'</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    PasswordHashRecord.from_json(dummy_data)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                except</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    pass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            serialized </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._storage[user_id]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> PasswordHashRecord.from_json(serialized)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">._logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Failed to retrieve hash record for user </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">user_id</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> update_hash_record</span><span style=\"color:#E1E4E8\">(self, user_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, record: PasswordHashRecord) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Update existing record (same as store for this implementation).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.store_hash_record(user_id, record)</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-code\">Core Logic Skeleton Code</h4>\n<p><strong>Password Service Orchestration</strong> (signatures + TODOs):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Optional, Dict, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> core.data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PasswordHashRecord</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> security.timing_security </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> TimingSecurity</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> storage.hash_repository </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> HashRepository</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PasswordService</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Main service orchestrating password registration and verification flows.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, repository: HashRepository, migration_manager</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.repository </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> repository</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.migration_manager </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> migration_manager</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.timing_security </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> TimingSecurity()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register_password</span><span style=\"color:#E1E4E8\">(self, user_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                         algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"bcrypt\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">params) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute complete password registration flow.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            user_id: Unique identifier for the user</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            password: Plain text password to hash</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            algorithm: Hashing algorithm to use</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            **params: Algorithm-specific parameters</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if registration successful, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Validate input password meets basic requirements (not null, proper encoding)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Resolve algorithm instance from AlgorithmRegistry</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Validate algorithm parameters against security requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Generate cryptographically secure salt using SaltGenerator</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Execute hash computation using selected algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Assemble complete PasswordHashRecord with metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Validate assembled record for completeness and consistency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Store record using repository interface with error handling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Log registration success/failure for security audit</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Wrap entire process in try/except to handle component failures</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify_password</span><span style=\"color:#E1E4E8\">(self, user_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                       enable_migration: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute complete password verification flow with timing attack protection.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            user_id: Unique identifier for the user</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            password: Plain text password to verify</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            enable_migration: Whether to perform lazy migration on successful verification</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            True if password is correct, False otherwise</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Retrieve hash record from repository (handle user not found)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Validate retrieved record structure and required fields</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Resolve algorithm instance from stored algorithm identifier</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Extract salt and parameters from stored record</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Reconstruct hash using identical process as registration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Compare reconstructed hash with stored hash using constant-time comparison</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: If verification succeeds and migration enabled, assess migration need</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Execute lazy migration if recommended (upgrade hash parameters)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 9: Return verification result without leaking timing information</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use TimingSecurity.execute_with_minimum_time for consistent timing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _execute_dummy_verification</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Execute realistic verification steps for non-existent users.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Prevents timing attacks that distinguish between 'user not found'</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        and 'invalid password' by performing equivalent computational work.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate dummy salt of standard length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Execute hash computation using default algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Perform constant-time comparison against dummy hash</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Return False after timing-consistent processing</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: This should take similar time to real verification</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<p><strong>Migration Manager</strong> (signatures + TODOs):</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timedelta</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> core.data_model </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PasswordHashRecord</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> MigrationManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages lazy migration of password hashes to stronger algorithms.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, migration_policies: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.migration_policies </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> migration_policies</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.migration_statistics </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assess_migration_need</span><span style=\"color:#E1E4E8\">(self, record: PasswordHashRecord) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate whether a hash record should be migrated to stronger parameters.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            Dictionary with migration assessment results including:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            - needs_migration: bool</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            - target_algorithm: str  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            - security_level: str</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            - migration_reason: str</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Check record age against policy maximum ages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Evaluate algorithm strength against current standards</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Compare parameters (iterations, cost factors) against minimums</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Assess record version compatibility with current system</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Determine target algorithm and parameters for migration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Calculate migration priority based on security risk</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Return assessment dictionary with migration recommendations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Consider graceful handling when policies are unavailable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> execute_lazy_migration</span><span style=\"color:#E1E4E8\">(self, user_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              old_record: PasswordHashRecord) -> Optional[PasswordHashRecord]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Perform opportunistic hash upgrade during successful verification.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Creates new hash record with current security parameters while</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        preserving successful authentication result.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Assess migration need using assess_migration_need</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If migration not needed, return None</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Select target algorithm and parameters for upgrade</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Generate new hash using current security standards</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Validate new record meets current security requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Log migration activity for security audit trail</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Update migration statistics for monitoring</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Return new PasswordHashRecord for atomic storage update</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Migration failure should not prevent successful authentication</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"language-specific-hints\">Language-Specific Hints</h4>\n<p><strong>Python-specific implementation guidance</strong>:</p>\n<ul>\n<li>Use <code>secrets.compare_digest()</code> for constant-time comparison instead of <code>==</code> operator</li>\n<li>Import <code>time.perf_counter()</code> for high-precision timing measurements in benchmarks</li>\n<li>Use <code>logging.getLogger(__name__)</code> for component-specific security audit logging</li>\n<li>Handle <code>UnicodeEncodeError</code> when processing international characters in passwords</li>\n<li>Use <code>@dataclass</code> for PasswordHashRecord to get automatic serialization methods</li>\n<li>Import <code>typing.Optional</code> and <code>typing.Dict</code> for clear parameter type hints</li>\n<li>Use <code>contextlib.contextmanager</code> for guaranteed cleanup in error scenarios</li>\n</ul>\n<p><strong>Error handling patterns</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hash_function(password, salt, iterations)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">except</span><span style=\"color:#E1E4E8\"> CryptographyError </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    logger.error(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Hash computation failed: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">e</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    raise</span><span style=\"color:#E1E4E8\"> HashComputationError(</span><span style=\"color:#9ECBFF\">\"Cryptographic operation failed\"</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> e</span></span></code></pre></div>\n\n<p><strong>Timing-consistent error responses</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Always return same error type regardless of failure reason</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> user_not_found </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> invalid_password </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> hash_corrupted:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> AuthenticationResult(</span><span style=\"color:#FFAB70\">success</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">message</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"Authentication failed\"</span><span style=\"color:#E1E4E8\">)</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After implementing registration flow</strong>:</p>\n<ul>\n<li>Run <code>python -m pytest tests/test_flows.py::test_registration_flow -v</code></li>\n<li>Expected: All registration tests pass including error handling scenarios</li>\n<li>Manual verification: Register user with <code>curl -X POST http://localhost:8000/register -d &#39;{&quot;username&quot;: &quot;test&quot;, &quot;password&quot;: &quot;secure123&quot;}&#39;</code></li>\n<li>Expected response: <code>{&quot;success&quot;: true, &quot;algorithm&quot;: &quot;bcrypt&quot;}</code> (or current default)</li>\n<li>Check database contains hash record with proper structure and non-empty salt/hash fields</li>\n</ul>\n<p><strong>After implementing verification flow</strong>:</p>\n<ul>\n<li>Run <code>python -m pytest tests/test_flows.py::test_verification_flow -v</code> </li>\n<li>Expected: Verification succeeds for correct passwords, fails for incorrect ones</li>\n<li>Manual verification: Login with <code>curl -X POST http://localhost:8000/login -d &#39;{&quot;username&quot;: &quot;test&quot;, &quot;password&quot;: &quot;secure123&quot;}&#39;</code></li>\n<li>Expected response: <code>{&quot;success&quot;: true}</code> for correct password, <code>{&quot;success&quot;: false}</code> for wrong password</li>\n<li>Timing test: Verify similar response times for valid/invalid users and correct/incorrect passwords</li>\n</ul>\n<p><strong>After implementing timing attack resistance</strong>:</p>\n<ul>\n<li>Run <code>python -m pytest tests/test_timing_attacks.py -v</code></li>\n<li>Expected: Timing consistency tests pass with &lt;5ms deviation between different scenarios</li>\n<li>Use timing analysis script: <code>python scripts/analyze_timing.py --samples 1000</code></li>\n<li>Expected: No statistically significant timing differences between password verification scenarios</li>\n</ul>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>How to Diagnose</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Registration always fails</td>\n<td>Parameter validation too strict</td>\n<td>Check logs for <code>ParameterValidationError</code></td>\n<td>Review parameter minimums in configuration</td>\n</tr>\n<tr>\n<td>Verification fails for correct passwords</td>\n<td>Salt/hash corruption during storage</td>\n<td>Compare stored vs. computed hash in debugger</td>\n<td>Check serialization/deserialization integrity</td>\n</tr>\n<tr>\n<td>Timing attack tests fail</td>\n<td>Branching logic in comparison</td>\n<td>Profile verification with different inputs</td>\n<td>Use <code>secrets.compare_digest()</code> for all comparisons</td>\n</tr>\n<tr>\n<td>Migration never triggers</td>\n<td>Assessment logic too conservative</td>\n<td>Log migration assessment results</td>\n<td>Adjust migration policies in configuration</td>\n</tr>\n<tr>\n<td>High verification latency</td>\n<td>Hash parameters too aggressive</td>\n<td>Benchmark individual algorithms</td>\n<td>Reduce iteration counts or cost factors</td>\n</tr>\n<tr>\n<td>Memory usage growing</td>\n<td>Hash records not garbage collected</td>\n<td>Monitor object lifecycle</td>\n<td>Ensure records released after processing</td>\n</tr>\n</tbody></table>\n<p><strong>Common debugging commands</strong>:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Enable debug logging for password operations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">export</span><span style=\"color:#E1E4E8\"> PYTHONPATH</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">. &#x26;&#x26; </span><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"import logging; logging.basicConfig(level=logging.DEBUG); from core.password_service import PasswordService; # your test code\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Profile verification timing</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> cProfile</span><span style=\"color:#79B8FF\"> -s</span><span style=\"color:#9ECBFF\"> cumulative</span><span style=\"color:#9ECBFF\"> scripts/benchmark_verification.py</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Analyze timing attack resistance  </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#9ECBFF\"> scripts/timing_analysis.py</span><span style=\"color:#79B8FF\"> --algorithm</span><span style=\"color:#9ECBFF\"> bcrypt</span><span style=\"color:#79B8FF\"> --samples</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#79B8FF\"> --output</span><span style=\"color:#9ECBFF\"> timing_report.json</span></span></code></pre></div>\n\n\n<h2 id=\"error-handling-and-edge-cases\">Error Handling and Edge Cases</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (robust error handling is essential across all implementation phases)</p>\n</blockquote>\n<h3 id=\"mental-model-the-airport-security-crisis-management-system\">Mental Model: The Airport Security Crisis Management System</h3>\n<p>Think of error handling in password hashing like an airport security checkpoint&#39;s crisis management protocols. Just as airport security must handle everything from broken X-ray machines to suspicious packages to system-wide power outages, a password hashing system must gracefully handle invalid inputs, missing algorithms, corrupted data, and resource exhaustion. The key principle is the same: <strong>maintain security even when things go wrong</strong>. Airport security doesn&#39;t abandon all checks when one scanner breaks—they have backup procedures, manual verification protocols, and escalation paths that preserve safety. Similarly, password hashing error handling must ensure that security failures never degrade into vulnerability windows, and that legitimate users aren&#39;t locked out by transient technical problems.</p>\n<p>The airport analogy extends further: just as security checkpoints validate passengers, baggage, and credentials according to strict protocols, password systems must validate every input parameter, configuration value, and algorithm availability before proceeding with cryptographic operations. When validation fails, the response must be both secure (no information leakage) and operational (clear guidance for resolution).</p>\n<h3 id=\"input-validation\">Input Validation</h3>\n<p><strong>Input validation</strong> in password hashing serves as the first line of defense against both accidental misuse and deliberate attacks. Unlike typical application validation that focuses on user experience, cryptographic input validation must prioritize <strong>security invariants</strong>—mathematical and operational requirements that, if violated, could compromise the entire security model.</p>\n<p>The validation challenge operates on multiple levels simultaneously. At the data level, we must ensure that passwords, salts, and configuration parameters meet minimum security requirements. At the algorithm level, we must verify that chosen parameters actually provide the intended security properties. At the system level, we must confirm that required cryptographic primitives and entropy sources are available and functioning correctly.</p>\n<blockquote>\n<p><strong>Decision: Fail-Fast Input Validation Architecture</strong></p>\n<ul>\n<li><strong>Context</strong>: Input validation can occur early (before any cryptographic operations) or late (during algorithm execution), and can be strict (reject any questionable input) or permissive (accept reasonable variations)</li>\n<li><strong>Options Considered</strong>: Early strict validation, late permissive validation, hybrid validation with warnings</li>\n<li><strong>Decision</strong>: Early strict validation with detailed error messages for debugging</li>\n<li><strong>Rationale</strong>: Cryptographic systems must be predictable and deterministic. Late failures during hashing operations can create timing side channels or partial state corruption. Strict validation prevents subtle security degradation from parameter drift over time.</li>\n<li><strong>Consequences</strong>: Higher initial complexity but eliminates entire classes of runtime security failures. Clear error messages aid debugging without exposing sensitive information.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Validation Strategy</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Security Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Early strict validation</td>\n<td>Predictable failures, no partial state corruption, clear debugging</td>\n<td>Higher upfront complexity</td>\n<td>Eliminates timing side channels from validation</td>\n</tr>\n<tr>\n<td>Late permissive validation</td>\n<td>Simple implementation, flexible parameter acceptance</td>\n<td>Timing attacks possible, partial failures</td>\n<td>Potential information leakage</td>\n</tr>\n<tr>\n<td>Hybrid with warnings</td>\n<td>Balance flexibility and security</td>\n<td>Complex error handling logic</td>\n<td>Mixed security properties</td>\n</tr>\n</tbody></table>\n<h4 id=\"password-input-validation\">Password Input Validation</h4>\n<p>Password validation must balance security requirements against usability concerns, while avoiding any validation logic that could leak information about stored passwords or system configuration. The core principle is <strong>statistical validation</strong>—ensuring the input has sufficient entropy and meets minimum security requirements without imposing arbitrary restrictions that reduce actual security.</p>\n<p>The primary validation concerns for password inputs include <strong>length boundaries</strong> (both minimum and maximum), <strong>character encoding validation</strong> (ensuring consistent Unicode handling), and <strong>entropy assessment</strong> (detecting obviously weak patterns). However, password strength validation deliberately falls outside the scope of this hashing system to maintain <strong>component separation</strong> and avoid scope creep into policy enforcement.</p>\n<table>\n<thead>\n<tr>\n<th>Validation Check</th>\n<th>Purpose</th>\n<th>Implementation</th>\n<th>Failure Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Minimum length validation</td>\n<td>Prevent trivially short passwords</td>\n<td>Length check after UTF-8 decoding</td>\n<td><code>ValidationError</code> with minimum requirement</td>\n</tr>\n<tr>\n<td>Maximum length validation</td>\n<td>Prevent DoS through excessive memory usage</td>\n<td>Length check before processing</td>\n<td><code>ValidationError</code> with maximum limit</td>\n</tr>\n<tr>\n<td>Unicode normalization</td>\n<td>Ensure consistent encoding across systems</td>\n<td>Apply NFC normalization, validate success</td>\n<td><code>ValidationError</code> for invalid sequences</td>\n</tr>\n<tr>\n<td>Null byte detection</td>\n<td>Prevent C-style string truncation</td>\n<td>Scan for embedded null characters</td>\n<td><code>ValidationError</code> indicating unsafe content</td>\n</tr>\n</tbody></table>\n<p>The <code>_validate_password_input</code> method implements these checks systematically:</p>\n<ol>\n<li><strong>UTF-8 decoding validation</strong>: Attempt to decode the input as valid UTF-8, rejecting byte sequences that don&#39;t represent valid Unicode text</li>\n<li><strong>Unicode normalization</strong>: Apply NFC (Canonical Decomposition followed by Canonical Composition) normalization to ensure consistent representation across different systems and input methods</li>\n<li><strong>Length boundary enforcement</strong>: Check that the normalized password length falls within the acceptable range (typically 1-1024 characters for security and DoS prevention)</li>\n<li><strong>Embedded null detection</strong>: Scan for null bytes that could cause truncation in C-based cryptographic libraries</li>\n<li><strong>Memory exhaustion prevention</strong>: Ensure the password doesn&#39;t consume excessive memory during processing</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Information Leakage Through Validation Errors</strong></p>\n<p>A common mistake is providing validation error messages that leak information about password policies or system configuration. For example, returning &quot;Password too short, minimum length is 12 characters&quot; reveals the exact minimum length requirement to attackers. Instead, validation errors should provide enough information for legitimate debugging while avoiding disclosure of specific security parameters. The correct approach is to return generic validation failure indicators with detailed information logged securely for administrators.</p>\n<h4 id=\"algorithm-parameter-validation\">Algorithm Parameter Validation</h4>\n<p>Algorithm parameter validation ensures that cryptographic operations will provide the intended security properties. Unlike password validation, parameter validation must be <strong>mathematically rigorous</strong>—verifying that parameters fall within ranges that provide meaningful security guarantees.</p>\n<p>The validation complexity varies significantly between algorithms. Basic SHA-256 hashing has minimal parameters (salt length), while PBKDF2 requires iteration count and key length validation, and Argon2 demands memory, time, and parallelism parameter coordination. Each algorithm&#39;s parameter validation must encode deep cryptographic knowledge about security-performance trade-offs.</p>\n<table>\n<thead>\n<tr>\n<th>Parameter Category</th>\n<th>Validation Requirements</th>\n<th>Failure Consequences</th>\n<th>Detection Method</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Salt length</td>\n<td>Must meet minimum entropy requirements</td>\n<td>Rainbow table vulnerability</td>\n<td>Length check against <code>MINIMUM_SALT_LENGTH</code></td>\n</tr>\n<tr>\n<td>Iteration count</td>\n<td>Must exceed minimum for computational security</td>\n<td>Brute force vulnerability</td>\n<td>Comparison with <code>PBKDF2_MIN_ITERATIONS</code></td>\n</tr>\n<tr>\n<td>Memory parameters</td>\n<td>Must balance security and resource constraints</td>\n<td>Memory-based attacks or DoS</td>\n<td>Range checking with system limits</td>\n</tr>\n<tr>\n<td>Parallelism settings</td>\n<td>Must align with available CPU resources</td>\n<td>Suboptimal performance or failures</td>\n<td>CPU detection and capability checking</td>\n</tr>\n</tbody></table>\n<p>The <code>ParameterValidator</code> component centralizes this logic through a <strong>constraint-based validation system</strong>. Each algorithm registers its parameter constraints as <strong>validation rules</strong>, and the validator applies these rules systematically:</p>\n<ol>\n<li><strong>Range validation</strong>: Numeric parameters must fall within minimum and maximum bounds that ensure security effectiveness</li>\n<li><strong>Relationship validation</strong>: Some parameters have interdependencies (e.g., Argon2 memory must be at least 8 times the parallelism factor)</li>\n<li><strong>Resource feasibility validation</strong>: Parameters must not exceed system capabilities (available memory, reasonable CPU utilization)</li>\n<li><strong>Security floor enforcement</strong>: Parameters must meet current security recommendations, with warnings for parameters approaching obsolescence</li>\n</ol>\n<blockquote>\n<p>The critical insight for parameter validation is that <strong>security requirements evolve over time</strong>. What constituted secure iteration counts in 2010 may be inadequate in 2024. The validation system must encode current security knowledge while supporting graceful parameter evolution.</p>\n</blockquote>\n<h4 id=\"configuration-parameter-validation\">Configuration Parameter Validation</h4>\n<p>Configuration validation operates at the system level, ensuring that the password hashing system has access to all required resources and capabilities. Unlike input validation which handles external data, configuration validation manages <strong>deployment-time dependencies</strong> and <strong>runtime resource availability</strong>.</p>\n<p>The primary configuration concerns include <strong>algorithm availability</strong> (ensuring required cryptographic libraries are present and functional), <strong>entropy source validation</strong> (confirming that random number generation works correctly), and <strong>performance parameter validation</strong> (verifying that configured parameters are achievable on the target system).</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Area</th>\n<th>Validation Checks</th>\n<th>Failure Recovery</th>\n<th>Monitoring Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Algorithm availability</td>\n<td>Library presence, version compatibility</td>\n<td>Fallback to available algorithms</td>\n<td>Algorithm capability discovery</td>\n</tr>\n<tr>\n<td>Entropy sources</td>\n<td>Randomness quality, generation speed</td>\n<td>Multiple entropy source fallback</td>\n<td>Entropy pool monitoring</td>\n</tr>\n<tr>\n<td>Performance parameters</td>\n<td>Benchmark against target hardware</td>\n<td>Auto-tuning based on capabilities</td>\n<td>Performance regression detection</td>\n</tr>\n<tr>\n<td>Storage configuration</td>\n<td>Database connectivity, schema validation</td>\n<td>Read-only mode for verification</td>\n<td>Storage health monitoring</td>\n</tr>\n</tbody></table>\n<p>The configuration validation process occurs in multiple phases:</p>\n<ol>\n<li><strong>Startup validation</strong>: During system initialization, validate that all configured algorithms are available and functional through test operations</li>\n<li><strong>Runtime validation</strong>: Periodically verify that entropy sources maintain adequate quality and generation speed</li>\n<li><strong>Parameter compatibility validation</strong>: Ensure that configured parameters are achievable on the current hardware within reasonable time bounds</li>\n<li><strong>Dependency validation</strong>: Confirm that required external libraries, databases, and services are accessible and responsive</li>\n</ol>\n<p>⚠️ <strong>Pitfall: Silent Configuration Degradation</strong></p>\n<p>A subtle but dangerous error is allowing configuration validation to silently fall back to weaker security parameters when preferred options are unavailable. For example, if bcrypt is unavailable, silently falling back to plain SHA-256 creates a massive security degradation that may go unnoticed. The correct approach is <strong>explicit degradation policies</strong> where fallback behavior is consciously configured and monitored, with clear alerting when security-impacting fallbacks occur.</p>\n<h3 id=\"graceful-degradation\">Graceful Degradation</h3>\n<p><strong>Graceful degradation</strong> in password hashing systems requires careful balance between <strong>operational continuity</strong> and <strong>security preservation</strong>. Unlike typical web applications where graceful degradation might mean showing cached content or reduced functionality, cryptographic systems must never degrade security properties to maintain availability. The challenge is defining <strong>acceptable degradation paths</strong> that preserve essential security while handling various failure modes.</p>\n<p>The degradation strategy operates on the principle of <strong>security-preserving fallbacks</strong>. When preferred algorithms or parameters are unavailable, the system can fall back to alternative approaches that maintain equivalent security properties. However, certain failures—like entropy exhaustion or complete algorithm unavailability—require <strong>fail-secure behavior</strong> where the system refuses to operate rather than compromising security.</p>\n<blockquote>\n<p><strong>Decision: Tiered Degradation with Security Floor</strong></p>\n<ul>\n<li><strong>Context</strong>: System failures can range from minor (preferred algorithm unavailable) to severe (entropy exhaustion), requiring different response strategies</li>\n<li><strong>Options Considered</strong>: Fail-fast (refuse all operations on any failure), Transparent fallback (automatic degradation), Explicit degradation (administrator-configured fallback policies)</li>\n<li><strong>Decision</strong>: Explicit degradation with mandatory security floor enforcement</li>\n<li><strong>Rationale</strong>: Cryptographic systems require predictable behavior. Transparent fallbacks can mask security degradation, while fail-fast approaches may be too rigid for operational environments. Explicit policies ensure conscious security decisions.</li>\n<li><strong>Consequences</strong>: Requires upfront planning for failure modes but eliminates surprise security degradation. Clear audit trail for degraded operations.</li>\n</ul>\n</blockquote>\n<p><img src=\"/api/project/password-hashing/architecture-doc/asset?path=diagrams%2Ferror-handling-flow.svg\" alt=\"Error Handling Decision Flow\"></p>\n<table>\n<thead>\n<tr>\n<th>Degradation Scenario</th>\n<th>Security Impact</th>\n<th>Acceptable Fallback</th>\n<th>Unacceptable Fallback</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Preferred algorithm unavailable</td>\n<td>None if equivalent security</td>\n<td>bcrypt → Argon2 or vice versa</td>\n<td>bcrypt → SHA-256</td>\n</tr>\n<tr>\n<td>Parameter tuning failure</td>\n<td>Minimal if conservative defaults used</td>\n<td>Use higher security parameters</td>\n<td>Use lower security parameters</td>\n</tr>\n<tr>\n<td>Performance degradation</td>\n<td>None if security maintained</td>\n<td>Slower but secure operations</td>\n<td>Faster but weaker operations</td>\n</tr>\n<tr>\n<td>Partial entropy exhaustion</td>\n<td>Moderate if high-quality backup available</td>\n<td>Hardware → Software entropy</td>\n<td>Fast → Predictable generation</td>\n</tr>\n</tbody></table>\n<h4 id=\"handling-missing-algorithms\">Handling Missing Algorithms</h4>\n<p>Algorithm unavailability can occur for several reasons: <strong>missing libraries</strong> (bcrypt or Argon2 not installed), <strong>version incompatibilities</strong> (library API changes), <strong>platform limitations</strong> (algorithm not supported on target architecture), or <strong>configuration errors</strong> (incorrect library paths or permissions). The degradation strategy must distinguish between <strong>temporary unavailability</strong> (which might resolve) and <strong>permanent unavailability</strong> (requiring alternative approaches).</p>\n<p>The <code>AlgorithmRegistry</code> maintains <strong>capability discovery</strong> information, tracking which algorithms are available and functional. During system startup, it attempts to initialize each configured algorithm, recording both success and detailed failure information. This capability map drives <strong>runtime algorithm selection</strong> and <strong>degradation decision-making</strong>.</p>\n<table>\n<thead>\n<tr>\n<th>Algorithm Failure Type</th>\n<th>Detection Method</th>\n<th>Degradation Strategy</th>\n<th>Recovery Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Library missing</td>\n<td>Import/load failure during initialization</td>\n<td>Use equivalent security algorithm</td>\n<td>Install missing dependencies</td>\n</tr>\n<tr>\n<td>Version incompatibility</td>\n<td>API call failure during test operations</td>\n<td>Use compatible version or alternative</td>\n<td>Update library versions</td>\n</tr>\n<tr>\n<td>Configuration error</td>\n<td>Permission denied or path not found</td>\n<td>Fix configuration or use embedded defaults</td>\n<td>Correct system configuration</td>\n</tr>\n<tr>\n<td>Runtime failure</td>\n<td>Intermittent algorithm failures during operation</td>\n<td>Temporary fallback with alerting</td>\n<td>Investigate underlying system issues</td>\n</tr>\n</tbody></table>\n<p>The degradation process follows a <strong>structured algorithm selection hierarchy</strong>:</p>\n<ol>\n<li><strong>Primary algorithm selection</strong>: Attempt to use the configured preferred algorithm for the security level</li>\n<li><strong>Equivalent algorithm fallback</strong>: If primary fails, select an alternative algorithm with equivalent or higher security properties</li>\n<li><strong>Conservative algorithm fallback</strong>: If equivalent algorithms fail, select a well-established algorithm with slightly different properties but adequate security</li>\n<li><strong>Emergency algorithm fallback</strong>: If modern algorithms fail, fall back to PBKDF2 with high iteration counts as a security floor</li>\n<li><strong>Operation refusal</strong>: If no algorithms meeting minimum security requirements are available, refuse to process passwords</li>\n</ol>\n<p>The <code>get_migration_target</code> method implements this selection logic, consulting the <strong>migration preferences list</strong> to identify appropriate fallback algorithms. The preferences list encodes security relationships between algorithms, ensuring that fallbacks never represent security downgrades.</p>\n<p>⚠️ <strong>Pitfall: Cascading Algorithm Failures</strong></p>\n<p>A dangerous scenario occurs when algorithm failures cascade—for example, when a system library update breaks multiple algorithm implementations simultaneously. Systems that assume &quot;at least one algorithm will work&quot; can fail catastrophically. The correct approach is <strong>algorithm independence validation</strong> during deployment, ensuring that algorithm failures are isolated and that sufficient fallback diversity exists.</p>\n<h4 id=\"handling-configuration-errors\">Handling Configuration Errors</h4>\n<p>Configuration errors in cryptographic systems can be particularly dangerous because they often <strong>fail silently</strong> or produce <strong>misleading error messages</strong>. Unlike application configuration errors that typically cause obvious functional failures, cryptographic configuration errors might result in subtle security degradation that passes functional testing but creates vulnerabilities.</p>\n<p>The configuration error handling strategy focuses on <strong>explicit validation</strong> and <strong>fail-secure defaults</strong>. Rather than attempting to &quot;fix&quot; configuration errors automatically, the system provides detailed diagnostic information and refuses to operate with potentially insecure configurations.</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Error Category</th>\n<th>Common Causes</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Parameter out of range</td>\n<td>Manual configuration, copy-paste errors</td>\n<td>Validation during system initialization</td>\n<td>Reject configuration with specific guidance</td>\n</tr>\n<tr>\n<td>Algorithm spelling errors</td>\n<td>Typos in configuration files</td>\n<td>String matching against known algorithms</td>\n<td>Suggest closest match, require explicit correction</td>\n</tr>\n<tr>\n<td>Resource constraint violations</td>\n<td>Misconfigured memory limits, CPU restrictions</td>\n<td>Runtime capability testing</td>\n<td>Auto-tune within constraints or fail with explanation</td>\n</tr>\n<tr>\n<td>Security policy conflicts</td>\n<td>Conflicting minimum requirements</td>\n<td>Cross-validation of policy constraints</td>\n<td>Highlight conflicts, require resolution</td>\n</tr>\n</tbody></table>\n<p>The configuration validation process implements <strong>defensive validation</strong> at multiple levels:</p>\n<ol>\n<li><strong>Syntax validation</strong>: Ensure configuration files parse correctly and contain expected data types</li>\n<li><strong>Semantic validation</strong>: Verify that configuration values make sense individually (positive numbers, valid algorithm names)</li>\n<li><strong>Constraint validation</strong>: Check that configuration values satisfy security and resource constraints</li>\n<li><strong>Compatibility validation</strong>: Ensure that different configuration sections work together coherently</li>\n<li><strong>Runtime validation</strong>: Confirm that configuration works on the actual deployment environment</li>\n</ol>\n<p>The <code>ValidationResult</code> structure provides <strong>structured error reporting</strong> that distinguishes between different severity levels. <strong>Errors</strong> represent configuration problems that prevent secure operation. <strong>Warnings</strong> indicate configuration choices that work but may not be optimal. This distinction allows administrators to make informed decisions about accepting suboptimal but functional configurations.</p>\n<blockquote>\n<p>The key insight for configuration error handling is that <strong>security misconfiguration is worse than no configuration</strong>. A system that fails to start due to configuration errors is better than a system that runs with insecure parameters.</p>\n</blockquote>\n<h4 id=\"resource-exhaustion-handling\">Resource Exhaustion Handling</h4>\n<p>Resource exhaustion in password hashing systems can manifest as <strong>entropy exhaustion</strong> (insufficient randomness for salt generation), <strong>memory exhaustion</strong> (Argon2 parameters exceeding available RAM), <strong>CPU exhaustion</strong> (iteration counts causing unacceptable delays), or <strong>storage exhaustion</strong> (inability to persist hash records). Each type requires different <strong>detection mechanisms</strong> and <strong>recovery strategies</strong>.</p>\n<p><strong>Entropy exhaustion</strong> represents the most critical resource failure because it directly compromises cryptographic security. The <code>SaltGenerator</code> must monitor entropy pool status and detect when randomness quality degrades. Modern operating systems provide entropy monitoring interfaces, but the interpretation requires careful analysis of <strong>entropy consumption patterns</strong> and <strong>regeneration rates</strong>.</p>\n<table>\n<thead>\n<tr>\n<th>Resource Type</th>\n<th>Exhaustion Symptoms</th>\n<th>Detection Method</th>\n<th>Recovery Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Entropy</td>\n<td>Slow random generation, repeated values</td>\n<td>Entropy pool monitoring, statistical testing</td>\n<td>Block operations until entropy recovers</td>\n</tr>\n<tr>\n<td>Memory</td>\n<td>Algorithm failures, system swapping</td>\n<td>Memory usage monitoring, allocation testing</td>\n<td>Reduce parameters or queue operations</td>\n</tr>\n<tr>\n<td>CPU</td>\n<td>Excessive hash computation time</td>\n<td>Timing measurements, load monitoring</td>\n<td>Reduce iteration counts or throttle requests</td>\n</tr>\n<tr>\n<td>Storage</td>\n<td>Hash record persistence failures</td>\n<td>Database monitoring, disk space checks</td>\n<td>Cleanup old records or switch to read-only</td>\n</tr>\n</tbody></table>\n<p>The resource exhaustion handling implements <strong>backpressure mechanisms</strong> that prevent system overload while maintaining security properties:</p>\n<ol>\n<li><strong>Entropy backpressure</strong>: When entropy quality drops below acceptable thresholds, block new salt generation until quality recovers</li>\n<li><strong>Memory backpressure</strong>: When memory usage approaches system limits, queue hash operations or reduce algorithm parameters</li>\n<li><strong>CPU backpressure</strong>: When hash computation times exceed thresholds, reduce iteration counts or implement request queuing</li>\n<li><strong>Storage backpressure</strong>: When storage systems approach capacity, implement cleanup policies or switch to verification-only mode</li>\n</ol>\n<p>The <code>EntropyExhaustionError</code> exception provides <strong>detailed diagnostic information</strong> about entropy status, including current pool levels, consumption rates, and estimated recovery times. This information enables <strong>intelligent retry strategies</strong> that wait for appropriate recovery periods rather than immediately retrying and further exhausting resources.</p>\n<p>⚠️ <strong>Pitfall: Resource Exhaustion Attacks</strong></p>\n<p>Malicious actors can deliberately trigger resource exhaustion through <strong>algorithmic complexity attacks</strong>—submitting requests with parameters that consume excessive resources. For example, requesting password hashes with extremely high iteration counts can cause CPU exhaustion. The correct defense is <strong>resource budgeting</strong> where each operation consumes from a limited resource pool, preventing any single request from exhausting system resources.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This error handling implementation provides comprehensive input validation, configuration management, and graceful degradation capabilities that maintain security properties even during failure conditions.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Input Validation</td>\n<td>Built-in type checking + manual validation</td>\n<td>Schema validation library (e.g., Pydantic, marshmallow)</td>\n</tr>\n<tr>\n<td>Error Reporting</td>\n<td>Standard exceptions with string messages</td>\n<td>Structured error objects with error codes and context</td>\n</tr>\n<tr>\n<td>Configuration Management</td>\n<td>JSON/YAML files with manual parsing</td>\n<td>Configuration management framework (e.g., Dynaconf, python-decouple)</td>\n</tr>\n<tr>\n<td>Resource Monitoring</td>\n<td>Basic system calls for memory/CPU</td>\n<td>Full monitoring integration (e.g., psutil, prometheus client)</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Standard logging module</td>\n<td>Structured logging with correlation IDs (e.g., structlog)</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>password_hashing/\n├── exceptions/\n│   ├── __init__.py              ← Export all exception classes\n│   ├── base.py                  ← PasswordHashingError base class\n│   ├── validation.py            ← ValidationError, ParameterValidationError\n│   ├── salt.py                  ← SaltGenerationError, EntropyExhaustionError\n│   ├── hashing.py               ← HashComputationError, AlgorithmUnavailableError\n│   └── iteration.py             ← IterationCountError, DerivationLengthError\n├── validation/\n│   ├── __init__.py              ← Export validation components\n│   ├── parameters.py            ← ParameterValidator class\n│   ├── inputs.py                ← Password and salt input validation\n│   ├── config.py                ← Configuration validation\n│   └── resources.py             ← Resource availability validation\n├── config/\n│   ├── __init__.py              ← Configuration management\n│   ├── defaults.py              ← Default parameters and constraints\n│   ├── validation_rules.py      ← Parameter validation rules by algorithm\n│   └── degradation_policies.py  ← Graceful degradation configuration\n└── monitoring/\n    ├── __init__.py              ← Resource monitoring components\n    ├── entropy.py               ← Entropy pool monitoring\n    ├── performance.py           ← CPU and memory monitoring\n    └── storage.py               ← Storage capacity monitoring</code></pre></div>\n\n<h4 id=\"exception-hierarchy-infrastructure\">Exception Hierarchy Infrastructure</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Base exception classes for password hashing system.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides structured error reporting with context preservation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> traceback</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Dict, List, Optional</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PasswordHashingError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Base exception for all password hashing errors.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Provides structured error reporting with context preservation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        error_code: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        context: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cause: </span><span style=\"color:#79B8FF\">Exception</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.message </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> message</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.error_code </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> error_code </span><span style=\"color:#F97583\">or</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__class__</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__name__</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> context </span><span style=\"color:#F97583\">or</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cause </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cause</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.timestamp </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> datetime.utcnow()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.stack_trace </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> traceback.format_stack()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> to_dict</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Convert exception to dictionary for logging/serialization.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'error_type'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__class__</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'error_code'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.error_code,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'message'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.message,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'context'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.context,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'timestamp'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.timestamp.isoformat(),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'cause'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.cause) </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.cause </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PasswordHashingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Password or parameter validation failed.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, parameter_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, value: Any, constraint: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.parameter_name </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> parameter_name</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> value</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.constraint </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> constraint</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Validation failed for </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">parameter_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">constraint</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'parameter_name'</span><span style=\"color:#E1E4E8\">: parameter_name,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'invalid_value'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">(value),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'constraint'</span><span style=\"color:#E1E4E8\">: constraint</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#FFAB70\">context</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">context, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParameterValidationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">ValidationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Algorithm parameter validation failed.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SaltGenerationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PasswordHashingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Salt generation failed.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> EntropyExhaustionError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">SaltGenerationError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Insufficient entropy for secure salt generation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, available_entropy: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, required_entropy: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.available_entropy </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> available_entropy</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.required_entropy </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> required_entropy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Insufficient entropy: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">available_entropy</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> available, </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">required_entropy</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> required\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'available_entropy'</span><span style=\"color:#E1E4E8\">: available_entropy,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'required_entropy'</span><span style=\"color:#E1E4E8\">: required_entropy,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'entropy_deficit'</span><span style=\"color:#E1E4E8\">: required_entropy </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> available_entropy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#FFAB70\">context</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">context, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HashComputationError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PasswordHashingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Hash computation failed.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> IterationCountError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PasswordHashingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Invalid iteration count for key stretching.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, minimum_required: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.count </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> count</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.minimum_required </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> minimum_required</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Iteration count </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">count</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> below minimum </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">minimum_required</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'provided_count'</span><span style=\"color:#E1E4E8\">: count,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'minimum_required'</span><span style=\"color:#E1E4E8\">: minimum_required</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#FFAB70\">context</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">context, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DerivationLengthError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PasswordHashingError</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Invalid key derivation length.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, length: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, maximum_allowed: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.length </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> length</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.maximum_allowed </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> maximum_allowed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        message </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> f</span><span style=\"color:#9ECBFF\">\"Derivation length </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">length</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> exceeds maximum </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">maximum_allowed</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'requested_length'</span><span style=\"color:#E1E4E8\">: length,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'maximum_allowed'</span><span style=\"color:#E1E4E8\">: maximum_allowed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        super</span><span style=\"color:#E1E4E8\">().</span><span style=\"color:#79B8FF\">__init__</span><span style=\"color:#E1E4E8\">(message, </span><span style=\"color:#FFAB70\">context</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">context, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span></code></pre></div>\n\n<h4 id=\"input-validation-implementation\">Input Validation Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Input validation for passwords and cryptographic parameters.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Implements security-focused validation with detailed error reporting.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> unicodedata</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Any, Dict, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ValidationError, ParameterValidationError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Security constants</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MINIMUM_SALT_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 16</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MAXIMUM_SALT_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 64</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">RECOMMENDED_SALT_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 32</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">PBKDF2_MIN_ITERATIONS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100000</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">BCRYPT_MIN_COST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 12</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ValidationResult</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Result of parameter validation with errors and warnings.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.is_valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.errors: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.warnings: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_error</span><span style=\"color:#E1E4E8\">(self, error: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add validation error.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.errors.append(error)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.is_valid </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> add_warning</span><span style=\"color:#E1E4E8\">(self, warning: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add validation warning.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.warnings.append(warning)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ParameterValidator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validates algorithm parameters against security constraints.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Load validation rules from configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Initialize constraint definitions for each algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Set up parameter relationship validation rules</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_parameters</span><span style=\"color:#E1E4E8\">(self, algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, parameters: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> ValidationResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Validate algorithm parameters meet security requirements.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            algorithm: Algorithm name (e.g., 'pbkdf2', 'bcrypt', 'argon2')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            parameters: Parameter dictionary to validate</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            ValidationResult with errors and warnings</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ValidationResult()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Look up validation rules for specified algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Apply range validation for numeric parameters  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check parameter relationships and dependencies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate resource feasibility (memory, CPU constraints)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check security floor requirements for current year</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add warnings for parameters approaching obsolescence</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_salt_length</span><span style=\"color:#E1E4E8\">(self, length: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> ValidationResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate salt length meets security requirements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ValidationResult()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check minimum salt length for rainbow table resistance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check maximum salt length for DoS prevention</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Add warning if length is below recommended value</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate length is appropriate for available entropy</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_iteration_count</span><span style=\"color:#E1E4E8\">(self, count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate PBKDF2 iteration count meets security requirements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check against current minimum iteration requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Consider current hardware capabilities and attack costs</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate count doesn't cause DoS through excessive CPU usage</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return detailed validation result with recommendations</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> count </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> PBKDF2_MIN_ITERATIONS</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> _validate_password_input</span><span style=\"color:#E1E4E8\">(password: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Validate password input meets security and encoding requirements.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Args:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        password: Raw password bytes to validate</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Raises:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        ValidationError: If password fails validation checks</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate password is valid UTF-8</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Apply Unicode normalization (NFC)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check length boundaries (minimum 1, maximum 1024 characters)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Detect embedded null bytes that could cause truncation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate password doesn't exceed memory limits during processing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Example validation structure:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        password_str </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> password.decode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    except</span><span style=\"color:#79B8FF\"> UnicodeDecodeError</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        raise</span><span style=\"color:#E1E4E8\"> ValidationError(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            parameter_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'password'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            value</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'&#x3C;binary data>'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            constraint</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'Must be valid UTF-8 text'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Additional validation steps would go here</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"configuration-management-implementation\">Configuration Management Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Configuration validation and management for password hashing system.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Handles algorithm availability, parameter constraints, and degradation policies.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> os</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> json</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, List, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ValidationError, PasswordHashingError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AlgorithmRegistry</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Registry of available password hashing algorithms with capability detection.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._algorithms: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._default_algorithm </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> 'bcrypt'</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._migration_preferences </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">'argon2id'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'bcrypt'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'pbkdf2'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Initialize algorithm capability detection</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test each algorithm during startup</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Record detailed failure information for diagnostics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register_algorithm</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, algorithm_class: Any) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register algorithm implementation with capability testing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Instantiate algorithm class and test basic operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Record algorithm capabilities and limitations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Update migration preference order if needed</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_algorithm</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Any:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Retrieve algorithm implementation by name.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return algorithm if available</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Raise specific exception if algorithm unavailable</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Provide suggestion for available alternatives</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._algorithms:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            available </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> list</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">._algorithms.keys())</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> ValidationError(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                parameter_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">'algorithm'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                value</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">name,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                constraint</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">'Must be one of: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">available</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._algorithms[name]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_migration_target</span><span style=\"color:#E1E4E8\">(self, current_algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Determine appropriate migration target for current algorithm.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Consult migration preference order</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Skip unavailable algorithms  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Ensure migration target has equivalent or better security</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return best available algorithm or raise exception if none suitable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ConfigurationValidator</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validates system configuration for security and operational requirements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_system_configuration</span><span style=\"color:#E1E4E8\">(self) -> ValidationResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate complete system configuration.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ValidationResult()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate entropy source availability and quality</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check algorithm library availability and versions</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate resource constraints (memory, CPU limits)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check storage configuration and connectivity</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate security parameter consistency across algorithms</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_entropy_sources</span><span style=\"color:#E1E4E8\">(self) -> ValidationResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate random number generation capabilities.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ValidationResult()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Test entropy source quality using statistical tests</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Measure entropy generation speed</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate multiple entropy sources for redundancy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check entropy pool monitoring capabilities</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_algorithm_availability</span><span style=\"color:#E1E4E8\">(self) -> ValidationResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test all configured algorithms for availability and correctness.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> ValidationResult()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Attempt to load each configured algorithm library</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Run test hash operations to verify functionality</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Check algorithm parameter ranges and constraints</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Validate algorithm version compatibility</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> result</span></span></code></pre></div>\n\n<h4 id=\"graceful-degradation-implementation\">Graceful Degradation Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Graceful degradation handling for password hashing system failures.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Implements security-preserving fallback strategies.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, Any, Optional, List</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> .exceptions </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> PasswordHashingError, EntropyExhaustionError</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> DegradationManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages graceful degradation policies and fallback strategies.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, registry: </span><span style=\"color:#9ECBFF\">'AlgorithmRegistry'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.registry </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> registry</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.degradation_policies: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Dict] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.security_floor_algorithms </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span><span style=\"color:#9ECBFF\">'pbkdf2'</span><span style=\"color:#E1E4E8\">]  </span><span style=\"color:#6A737D\"># Last resort algorithms</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Load degradation policies from configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Initialize fallback algorithm hierarchies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Set up resource monitoring for degradation triggers</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_algorithm_unavailable</span><span style=\"color:#E1E4E8\">(self, requested_algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle algorithm unavailability with security-preserving fallback.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Consult degradation policy for requested algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Find equivalent-security alternative from available algorithms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Log degradation event for monitoring and alerting</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Raise exception if no acceptable alternative exists</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        fallback </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.registry.get_migration_target(requested_algorithm)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> fallback:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> PasswordHashingError(</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                f</span><span style=\"color:#9ECBFF\">\"No acceptable fallback for unavailable algorithm: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">requested_algorithm</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                error_code</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"ALGORITHM_UNAVAILABLE\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                context</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">'requested_algorithm'</span><span style=\"color:#E1E4E8\">: requested_algorithm}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> fallback</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> handle_resource_exhaustion</span><span style=\"color:#E1E4E8\">(self, resource_type: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, current_usage: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Handle resource exhaustion with appropriate backpressure.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement resource-specific backpressure strategies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate safe parameter reductions that maintain security</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Implement request queuing for temporary resource constraints</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Return degraded parameters or raise exception for permanent exhaustion</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> resource_type </span><span style=\"color:#F97583\">==</span><span style=\"color:#9ECBFF\"> 'entropy'</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Block operations until entropy recovers</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#E1E4E8\"> EntropyExhaustionError(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                available_entropy</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">current_usage.get(</span><span style=\"color:#9ECBFF\">'available'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                required_entropy</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">current_usage.get(</span><span style=\"color:#9ECBFF\">'required'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Return degraded parameters for other resource types</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> assess_degradation_impact</span><span style=\"color:#E1E4E8\">(self, original_params: Dict, degraded_params: Dict) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Assess security impact of parameter degradation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Compare security properties between original and degraded parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Calculate attack cost differences</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Determine if degradation is acceptable within policy limits</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\">: Generate detailed impact report for logging and monitoring</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'security_impact'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'minimal'</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># Placeholder</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'acceptable'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'recommendations'</span><span style=\"color:#E1E4E8\">: []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After implementing input validation:</strong></p>\n<ul>\n<li>Run <code>python -m pytest tests/test_validation.py -v</code> to verify parameter validation</li>\n<li>Test password validation with various Unicode inputs: <code>python -c &quot;from password_hashing.validation import _validate_password_input; _validate_password_input(&#39;测试密码&#39;.encode(&#39;utf-8&#39;))&quot;</code></li>\n<li>Verify validation rejects dangerous inputs: null bytes, oversized parameters, invalid algorithm names</li>\n<li>Expected behavior: Clear validation errors with specific constraint information, no silent failures</li>\n</ul>\n<p><strong>After implementing configuration management:</strong></p>\n<ul>\n<li>Run algorithm availability detection: <code>python -c &quot;from password_hashing.config import AlgorithmRegistry; r = AlgorithmRegistry(); print(r.get_available_algorithms())&quot;</code></li>\n<li>Test configuration validation: <code>python -m pytest tests/test_config.py::test_configuration_validation -v</code></li>\n<li>Verify entropy source validation works: Check that entropy exhaustion is detected and reported</li>\n<li>Expected behavior: Clear reporting of available algorithms, detailed error messages for missing dependencies</li>\n</ul>\n<p><strong>After implementing graceful degradation:</strong></p>\n<ul>\n<li>Test algorithm fallback: Disable bcrypt library and verify system falls back to Argon2 or PBKDF2</li>\n<li>Test resource exhaustion handling: Simulate low memory conditions and verify appropriate parameter reduction</li>\n<li>Run degradation impact assessment: <code>python -m pytest tests/test_degradation.py::test_security_impact -v</code></li>\n<li>Expected behavior: Security-preserving fallbacks, clear degradation impact reporting, no silent security downgrades</li>\n</ul>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<p>| Symptom | Likely Cause | How to Diagnose | Fix |\n|---|---|---|\n| Validation passes but hashing fails | Parameter validation incomplete | Check if algorithm-specific constraints are enforced | Add missing parameter range checks |\n| Silent security degradation | Missing degradation impact assessment | Log all parameter changes and algorithm selections | Implement mandatory degradation reporting |\n| Intermittent entropy errors | Entropy pool exhaustion under load | Monitor <code>/proc/sys/kernel/random/entropy_avail</code> on Linux | Implement entropy backpressure and rate limiting |\n| Configuration errors ignored | Exception handling too permissive | Check exception catching in configuration loading | Make configuration validation strict and fail-fast |\n| Algorithm fallback loops | Circular dependencies in migration preferences | Trace algorithm selection logic with detailed logging | Fix migration preference ordering |\n| Resource exhaustion not detected | Missing resource monitoring | Add resource usage logging before operations | Implement proactive resource monitoring |</p>\n<h2 id=\"testing-strategy\">Testing Strategy</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (testing strategies evolve across implementation phases from basic salt/hash verification through key stretching validation to modern algorithm compatibility testing)</p>\n</blockquote>\n<h3 id=\"mental-model-the-nuclear-power-plant-safety-testing-system\">Mental Model: The Nuclear Power Plant Safety Testing System</h3>\n<p>Think of testing a password hashing system like the comprehensive safety testing protocols at a nuclear power plant. Just as a nuclear facility has multiple independent safety systems that must all work perfectly together—radiation detection, cooling systems, containment barriers, emergency shutdown procedures—a password hashing system has multiple security properties that must be rigorously verified. </p>\n<p>In a nuclear plant, you don&#39;t just test that the reactor produces power; you test that the cooling system works under extreme load, that radiation containment holds under pressure, that emergency systems activate within precise time windows, and that backup systems seamlessly take over during failures. Each system has its own specialized test protocols, but they&#39;re also tested together to ensure the entire facility operates safely under all conditions.</p>\n<p>Similarly, password hashing isn&#39;t just about producing a hash value—you must verify that salts are truly random and unique, that timing attacks are impossible, that computational costs meet security requirements, that algorithm migrations preserve security, and that the entire system degrades gracefully under failure conditions. Each component has specialized security tests, but integration testing ensures the complete system maintains cryptographic security properties under all operational scenarios.</p>\n<p>The stakes in both domains are similarly high: a nuclear safety failure can have catastrophic consequences, and a password security failure can compromise thousands of user accounts. This is why both require exhaustive, methodical testing that covers not just normal operation but also adversarial conditions, edge cases, and failure modes.</p>\n<h3 id=\"security-test-cases\">Security Test Cases</h3>\n<p>Security testing for password hashing systems requires fundamentally different approaches than functional testing. While functional tests verify that methods return expected outputs, security tests must verify that the system resists specific attack vectors and maintains cryptographic properties that are mathematically measurable but not always intuitively obvious.</p>\n<p>The core challenge is that security properties are often defined by what doesn&#39;t happen rather than what does happen. For example, timing attack resistance means that execution time doesn&#39;t vary based on input content, and cryptographic randomness means that generated values don&#39;t exhibit statistical patterns that could be exploited by attackers.</p>\n<h4 id=\"cryptographic-randomness-verification\">Cryptographic Randomness Verification</h4>\n<p>Salt generation represents the foundation of password hashing security, making randomness testing the most critical security verification. True cryptographic randomness is not just &quot;hard to predict&quot;—it must be mathematically indistinguishable from pure randomness even to an adversary with significant computational resources.</p>\n<p>The <strong>birthday paradox</strong> becomes the primary mathematical tool for randomness verification. For a truly random salt generator producing n-byte salts, the probability of generating duplicate salts follows predictable mathematical distributions. By generating large samples of salts and analyzing collision patterns, we can statistically verify that the generator exhibits true randomness properties.</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Test Method</th>\n<th>Expected Behavior</th>\n<th>Security Property Verified</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Salt Uniqueness</td>\n<td>Generate 1,000,000 salts, verify zero duplicates</td>\n<td>Zero collisions with high probability</td>\n<td>Birthday paradox resistance</td>\n</tr>\n<tr>\n<td>Entropy Distribution</td>\n<td>Chi-square test on salt byte distribution</td>\n<td>Uniform distribution across all possible values</td>\n<td>No statistical bias</td>\n</tr>\n<tr>\n<td>Sequential Independence</td>\n<td>Autocorrelation analysis between consecutive salts</td>\n<td>No detectable patterns</td>\n<td>Generator state unpredictability</td>\n</tr>\n<tr>\n<td>Bit Independence</td>\n<td>Hamming distance analysis between adjacent salts</td>\n<td>Average 50% bit differences</td>\n<td>Individual bit independence</td>\n</tr>\n<tr>\n<td>Entropy Pool Depletion</td>\n<td>Generate salts after entropy exhaustion simulation</td>\n<td>Graceful failure or secure blocking</td>\n<td>Entropy exhaustion handling</td>\n</tr>\n</tbody></table>\n<p>The <code>SecurityGoalVerifier</code> implements these statistical tests using established cryptographic testing methodologies:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Security Property</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>verify_salt_uniqueness(password_count, sample_size)</code></td>\n<td>count: int, samples: int</td>\n<td>dict with collision analysis</td>\n<td>Birthday paradox resistance</td>\n</tr>\n<tr>\n<td><code>verify_entropy_distribution(salt_list)</code></td>\n<td>salts: List[bytes]</td>\n<td>dict with chi-square results</td>\n<td>Uniform distribution</td>\n</tr>\n<tr>\n<td><code>verify_sequential_independence(salt_list)</code></td>\n<td>salts: List[bytes]</td>\n<td>dict with correlation coefficients</td>\n<td>Pattern absence</td>\n</tr>\n<tr>\n<td><code>analyze_hamming_distances(salt_pairs)</code></td>\n<td>pairs: List[Tuple[bytes, bytes]]</td>\n<td>dict with distance distribution</td>\n<td>Bit independence</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Critical Security Insight</strong>: Cryptographic randomness testing requires large sample sizes to achieve statistical significance. Testing with only dozens or hundreds of samples can miss subtle biases that become exploitable at scale.</p>\n</blockquote>\n<h4 id=\"timing-attack-resistance-verification\">Timing Attack Resistance Verification</h4>\n<p>Timing attacks represent one of the most insidious security vulnerabilities because they exploit computational side effects that are invisible during normal testing. An attacker measures minute variations in execution time to infer information about internal processing, potentially recovering passwords or detecting valid usernames.</p>\n<p>The fundamental principle of timing attack resistance is <strong>constant-time execution</strong>—the computational path through password verification must take identical time regardless of whether the password is correct, incorrect, or the username exists. This requires careful analysis of every conditional branch, memory access pattern, and computational operation.</p>\n<table>\n<thead>\n<tr>\n<th>Attack Vector</th>\n<th>Vulnerability</th>\n<th>Test Method</th>\n<th>Mitigation Verification</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Password Verification</td>\n<td>Early termination on mismatch</td>\n<td>Measure verification time variance</td>\n<td>Constant-time comparison</td>\n</tr>\n<tr>\n<td>Username Enumeration</td>\n<td>Different paths for valid/invalid users</td>\n<td>Compare timing for existing vs. non-existent users</td>\n<td>Dummy computation execution</td>\n</tr>\n<tr>\n<td>Salt Length Inference</td>\n<td>Processing time varies with salt length</td>\n<td>Test multiple salt lengths</td>\n<td>Consistent processing time</td>\n</tr>\n<tr>\n<td>Hash Algorithm Detection</td>\n<td>Different algorithms have timing signatures</td>\n<td>Compare timing across algorithms</td>\n<td>Algorithm-agnostic timing</td>\n</tr>\n<tr>\n<td>Memory Access Patterns</td>\n<td>Cache timing variations</td>\n<td>Cache timing analysis</td>\n<td>Cache-independent operations</td>\n</tr>\n</tbody></table>\n<p>The <code>TimingSecurity</code> component provides specialized testing methods for timing attack resistance:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Security Analysis</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>verify_timing_consistency(func, test_cases, tolerance_ms)</code></td>\n<td>function, inputs, threshold</td>\n<td>timing analysis</td>\n<td>Execution time variance</td>\n</tr>\n<tr>\n<td><code>measure_verification_timing(username_list, password_list)</code></td>\n<td>users, passwords</td>\n<td>timing distribution</td>\n<td>Authentication timing patterns</td>\n</tr>\n<tr>\n<td><code>detect_early_termination(comparison_func, input_pairs)</code></td>\n<td>comparator, test data</td>\n<td>termination analysis</td>\n<td>Comparison function behavior</td>\n</tr>\n<tr>\n<td><code>analyze_cache_timing(operation_func, memory_patterns)</code></td>\n<td>operation, patterns</td>\n<td>cache behavior</td>\n<td>Memory access consistency</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Decision: Timing Attack Prevention Strategy</strong></p>\n<ul>\n<li><strong>Context</strong>: Timing attacks can exploit microsecond differences in execution time to infer sensitive information</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Ignore timing attacks (assume network latency masks differences)</li>\n<li>Add random delays to mask timing differences  </li>\n<li>Implement guaranteed constant-time operations</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Implement constant-time operations with guaranteed minimum execution time</li>\n<li><strong>Rationale</strong>: Random delays can be statistically analyzed away by persistent attackers, while constant-time operations provide mathematical guarantees</li>\n<li><strong>Consequences</strong>: Requires careful implementation but provides the strongest timing attack resistance</li>\n</ul>\n</blockquote>\n<h4 id=\"algorithm-security-property-verification\">Algorithm Security Property Verification</h4>\n<p>Different password hashing algorithms provide different security properties, and testing must verify that each algorithm meets its security claims. This goes beyond functional correctness to verify computational hardness, memory requirements, and resistance to specialized attacks.</p>\n<p>For <strong>bcrypt</strong> testing, the primary security property is computational cost scaling. The work factor parameter should exponentially increase computation time, making brute force attacks proportionally more expensive. Testing must verify this exponential relationship and ensure that cost factors are appropriately calibrated for current hardware.</p>\n<p>For <strong>Argon2</strong> testing, memory hardness becomes the critical property. The algorithm should require substantial memory resources that cannot be traded off for computational resources, making attacks using specialized hardware (like ASICs) economically infeasible.</p>\n<table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Security Property</th>\n<th>Test Method</th>\n<th>Expected Behavior</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bcrypt</td>\n<td>Exponential cost scaling</td>\n<td>Time cost factors 10, 11, 12, 13</td>\n<td>Each increment roughly doubles time</td>\n</tr>\n<tr>\n<td>bcrypt</td>\n<td>Salt integration</td>\n<td>Generate multiple hashes of same password</td>\n<td>Different outputs with different salts</td>\n</tr>\n<tr>\n<td>Argon2id</td>\n<td>Memory hardness</td>\n<td>Monitor memory usage during hashing</td>\n<td>Memory usage matches parameters</td>\n</tr>\n<tr>\n<td>Argon2id</td>\n<td>Time-memory trade-off resistance</td>\n<td>Attempt reduced memory computation</td>\n<td>Failure or severe performance penalty</td>\n</tr>\n<tr>\n<td>PBKDF2</td>\n<td>Iteration scaling</td>\n<td>Test iteration counts 100K, 200K, 500K</td>\n<td>Linear time scaling with iterations</td>\n</tr>\n<tr>\n<td>SHA-256</td>\n<td>Collision resistance</td>\n<td>Hash identical inputs with different salts</td>\n<td>Different outputs verify salt integration</td>\n</tr>\n</tbody></table>\n<p>The <code>PerformanceGoalTuner</code> provides specialized benchmarking for security property verification:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Security Verification</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>benchmark_cost_scaling(algorithm, cost_range)</code></td>\n<td>algo, costs</td>\n<td>scaling analysis</td>\n<td>Exponential cost verification</td>\n</tr>\n<tr>\n<td><code>measure_memory_hardness(algorithm, memory_params)</code></td>\n<td>algo, params</td>\n<td>memory usage profile</td>\n<td>Memory requirement enforcement</td>\n</tr>\n<tr>\n<td><code>verify_iteration_scaling(iterations_list)</code></td>\n<td>iteration counts</td>\n<td>time scaling analysis</td>\n<td>Linear iteration cost</td>\n</tr>\n<tr>\n<td><code>analyze_salt_integration(password, salt_count)</code></td>\n<td>password, salts</td>\n<td>output diversity analysis</td>\n<td>Salt uniqueness verification</td>\n</tr>\n</tbody></table>\n<h4 id=\"migration-security-testing\">Migration Security Testing</h4>\n<p>Algorithm migration introduces unique security challenges because the system must maintain security while transitioning between different cryptographic approaches. Migration testing must verify that security never degrades during transitions and that legacy hash formats don&#39;t become attack vectors.</p>\n<p><strong>Lazy migration</strong> testing is particularly critical because migration occurs during live authentication attempts. The system must upgrade password hashes without compromising ongoing security, while ensuring that failed migrations don&#39;t create denial-of-service vulnerabilities.</p>\n<table>\n<thead>\n<tr>\n<th>Migration Scenario</th>\n<th>Security Risk</th>\n<th>Test Method</th>\n<th>Verification Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Algorithm Upgrade</td>\n<td>Temporary security reduction</td>\n<td>Test security during migration</td>\n<td>No security degradation</td>\n</tr>\n<tr>\n<td>Legacy Hash Support</td>\n<td>Weak algorithms remain vulnerable</td>\n<td>Analyze legacy hash strength</td>\n<td>Clear migration timelines</td>\n</tr>\n<tr>\n<td>Migration Failure</td>\n<td>System falls back to weak security</td>\n<td>Simulate migration failures</td>\n<td>Secure failure handling</td>\n</tr>\n<tr>\n<td>Concurrent Migration</td>\n<td>Race conditions during updates</td>\n<td>Multi-threaded migration testing</td>\n<td>Atomic migration operations</td>\n</tr>\n<tr>\n<td>Migration Rollback</td>\n<td>Previous hash becomes invalid</td>\n<td>Test rollback scenarios</td>\n<td>Reversible migration process</td>\n</tr>\n</tbody></table>\n<h3 id=\"milestone-checkpoints\">Milestone Checkpoints</h3>\n<p>Milestone checkpoints provide concrete verification criteria for each implementation phase. Unlike functional testing that verifies correct outputs, security milestone testing verifies that implementations resist specific attacks and maintain cryptographic properties under adversarial conditions.</p>\n<p>Each checkpoint includes both automated security tests and manual security verification procedures. The automated tests verify measurable security properties, while manual procedures verify implementation details that could introduce subtle security vulnerabilities.</p>\n<h4 id=\"milestone-1-basic-hashing-with-salt-checkpoint\">Milestone 1: Basic Hashing with Salt Checkpoint</h4>\n<p>The fundamental security properties established in Milestone 1 form the foundation for all subsequent security features. Salt uniqueness and timing attack resistance must be mathematically verifiable before proceeding to more advanced algorithms.</p>\n<p><strong>Automated Security Verification</strong></p>\n<p>The <code>SecurityGoalVerifier</code> provides comprehensive automated testing for Milestone 1 security properties:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#6A737D\"># Example automated security verification (not implementation)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> verify_milestone_1_security</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Salt uniqueness verification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    salt_results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> verify_salt_uniqueness(</span><span style=\"color:#FFAB70\">password_count</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">sample_size</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">100000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#E1E4E8\"> salt_results[</span><span style=\"color:#9ECBFF\">'collision_count'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Salt generation must be collision-free\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Timing attack resistance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timing_results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> verify_timing_attack_resistance(</span><span style=\"color:#FFAB70\">username</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"testuser\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#E1E4E8\"> timing_results[</span><span style=\"color:#9ECBFF\">'timing_variance'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 0.1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Timing variance must be minimal\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hash determinism verification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hash_results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> verify_hash_determinism(</span><span style=\"color:#FFAB70\">password</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"test\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">iterations</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    assert</span><span style=\"color:#E1E4E8\"> hash_results[</span><span style=\"color:#9ECBFF\">'consistency'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">==</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"Same inputs must produce same outputs\"</span></span></code></pre></div>\n\n<table>\n<thead>\n<tr>\n<th>Security Property</th>\n<th>Automated Test</th>\n<th>Success Criteria</th>\n<th>Failure Investigation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Salt Uniqueness</td>\n<td>Generate 100,000 salts</td>\n<td>Zero collisions</td>\n<td>Check random number generator</td>\n</tr>\n<tr>\n<td>Salt Length</td>\n<td>Validate salt length compliance</td>\n<td>All salts ≥ 16 bytes</td>\n<td>Verify length configuration</td>\n</tr>\n<tr>\n<td>Timing Consistency</td>\n<td>Measure verification timing variance</td>\n<td>Variance &lt; 100 microseconds</td>\n<td>Profile comparison functions</td>\n</tr>\n<tr>\n<td>Hash Determinism</td>\n<td>Hash same input multiple times</td>\n<td>Identical outputs</td>\n<td>Check salt handling</td>\n</tr>\n<tr>\n<td>Input Validation</td>\n<td>Test invalid inputs</td>\n<td>Graceful error handling</td>\n<td>Review validation logic</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Security Verification Procedures</strong></p>\n<p>Manual verification focuses on implementation details that automated tests cannot easily detect but that could introduce critical security vulnerabilities.</p>\n<ol>\n<li><p><strong>Salt Storage Verification</strong>: Manually inspect stored password records to verify that salts are stored alongside hashes and are different for identical passwords.</p>\n</li>\n<li><p><strong>Comparison Function Analysis</strong>: Examine the password comparison implementation to verify that it uses constant-time comparison and doesn&#39;t exit early on mismatches.</p>\n</li>\n<li><p><strong>Error Message Analysis</strong>: Verify that error messages don&#39;t leak information about salt generation failures, hash computation errors, or validation failures.</p>\n</li>\n<li><p><strong>Memory Handling Review</strong>: Check that password and salt values are properly cleared from memory after use and don&#39;t persist in swap files or core dumps.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Milestone 1 Security Checkpoint Summary</strong>: The system must demonstrate cryptographically secure salt generation, timing attack resistance, and deterministic hash computation. These properties form the security foundation for all advanced features.</p>\n</blockquote>\n<h4 id=\"milestone-2-key-stretching-checkpoint\">Milestone 2: Key Stretching Checkpoint</h4>\n<p>Key stretching introduces computational hardness as a security property, requiring verification that iteration counts provide meaningful protection against brute force attacks while maintaining reasonable authentication performance.</p>\n<p><strong>PBKDF2 Security Property Verification</strong></p>\n<p>Key stretching security depends on the mathematical relationship between iteration count and computation time. Testing must verify that this relationship holds under various conditions and that iteration counts are properly calibrated for security requirements.</p>\n<table>\n<thead>\n<tr>\n<th>Security Property</th>\n<th>Verification Method</th>\n<th>Expected Behavior</th>\n<th>Security Implication</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Iteration Scaling</td>\n<td>Time iterations 100K, 200K, 500K</td>\n<td>Linear time scaling</td>\n<td>Predictable brute force cost</td>\n</tr>\n<tr>\n<td>Minimum Iterations</td>\n<td>Enforce iteration minimums</td>\n<td>Reject &lt; 100,000 iterations</td>\n<td>Prevent weak configurations</td>\n</tr>\n<tr>\n<td>Parameter Storage</td>\n<td>Verify iteration count storage</td>\n<td>Parameters stored with hash</td>\n<td>Enable verification</td>\n</tr>\n<tr>\n<td>Backward Compatibility</td>\n<td>Test old iteration counts</td>\n<td>Support legacy parameters</td>\n<td>Enable migration</td>\n</tr>\n<tr>\n<td>Performance Tuning</td>\n<td>Benchmark target times</td>\n<td>Meet performance requirements</td>\n<td>Balance security and usability</td>\n</tr>\n</tbody></table>\n<p><strong>Automated Key Stretching Testing</strong></p>\n<p>The <code>KeyStretchingHasher</code> component includes specialized testing methods for iteration-based security verification:</p>\n<table>\n<thead>\n<tr>\n<th>Test Method</th>\n<th>Purpose</th>\n<th>Success Criteria</th>\n<th>Investigation Steps</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>benchmark_iterations(target_time_ms)</code></td>\n<td>Performance calibration</td>\n<td>Meet target timing</td>\n<td>Adjust iteration count</td>\n</tr>\n<tr>\n<td><code>verify_iteration_enforcement(count)</code></td>\n<td>Minimum iteration validation</td>\n<td>Reject weak counts</td>\n<td>Check validation logic</td>\n</tr>\n<tr>\n<td><code>test_parameter_persistence(hash_record)</code></td>\n<td>Parameter storage verification</td>\n<td>Iterations stored correctly</td>\n<td>Verify serialization</td>\n</tr>\n<tr>\n<td><code>analyze_computation_scaling(iteration_range)</code></td>\n<td>Scaling relationship verification</td>\n<td>Linear scaling observed</td>\n<td>Profile PBKDF2 implementation</td>\n</tr>\n</tbody></table>\n<p><strong>Manual Key Stretching Verification</strong></p>\n<ol>\n<li><p><strong>Iteration Count Inspection</strong>: Manually verify that stored hash records contain iteration count parameters and that these parameters are used during verification.</p>\n</li>\n<li><p><strong>Performance Impact Analysis</strong>: Measure authentication performance with different iteration counts to verify that security tuning doesn&#39;t create denial-of-service vulnerabilities.</p>\n</li>\n<li><p><strong>Migration Path Testing</strong>: Verify that systems can upgrade iteration counts without breaking existing authentication for users who haven&#39;t logged in during the migration period.</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Milestone 2 Security Checkpoint Summary</strong>: The system must demonstrate configurable computational hardness through PBKDF2 key stretching, with iteration counts properly calibrated for security requirements and performance constraints.</p>\n</blockquote>\n<h4 id=\"milestone-3-modern-password-hashing-checkpoint\">Milestone 3: Modern Password Hashing Checkpoint</h4>\n<p>Modern password hashing algorithms introduce complex security properties including memory hardness, algorithm agility, and migration management. Testing must verify that these advanced features maintain security while providing operational flexibility.</p>\n<p><strong>Algorithm Integration Security Verification</strong></p>\n<p>Modern algorithms like bcrypt and Argon2 provide different security properties that must be individually verified and compared for effectiveness against current attack methods.</p>\n<table>\n<thead>\n<tr>\n<th>Algorithm</th>\n<th>Security Property</th>\n<th>Test Method</th>\n<th>Verification Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bcrypt</td>\n<td>Cost factor scaling</td>\n<td>Benchmark costs 10, 12, 14</td>\n<td>Exponential time scaling</td>\n</tr>\n<tr>\n<td>bcrypt</td>\n<td>Salt integration</td>\n<td>Hash same password multiple times</td>\n<td>Different outputs</td>\n</tr>\n<tr>\n<td>Argon2id</td>\n<td>Memory hardness</td>\n<td>Monitor memory usage</td>\n<td>Usage matches parameters</td>\n</tr>\n<tr>\n<td>Argon2id</td>\n<td>Parallelism resistance</td>\n<td>Test parallel computation</td>\n<td>No significant speedup</td>\n</tr>\n<tr>\n<td>Algorithm Agility</td>\n<td>Migration support</td>\n<td>Test algorithm transitions</td>\n<td>Seamless migration</td>\n</tr>\n<tr>\n<td>Parameter Evolution</td>\n<td>Security parameter updates</td>\n<td>Test parameter upgrades</td>\n<td>Backward compatibility</td>\n</tr>\n</tbody></table>\n<p><strong>Migration Security Testing</strong></p>\n<p>Algorithm migration represents the most complex security testing scenario because it involves transitioning between different cryptographic approaches while maintaining continuous security coverage.</p>\n<table>\n<thead>\n<tr>\n<th>Migration Scenario</th>\n<th>Security Test</th>\n<th>Expected Behavior</th>\n<th>Failure Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Lazy Migration</td>\n<td>Authenticate with old hash</td>\n<td>Upgrade to new algorithm</td>\n<td>Preserve security during upgrade</td>\n</tr>\n<tr>\n<td>Migration Failure</td>\n<td>Simulate upgrade failure</td>\n<td>Fall back securely</td>\n<td>No security degradation</td>\n</tr>\n<tr>\n<td>Concurrent Access</td>\n<td>Multiple simultaneous migrations</td>\n<td>Atomic operations</td>\n<td>No race conditions</td>\n</tr>\n<tr>\n<td>Rollback Requirements</td>\n<td>Reverse migration</td>\n<td>Restore previous state</td>\n<td>Maintain authentication</td>\n</tr>\n<tr>\n<td>Performance Impact</td>\n<td>Migration during peak load</td>\n<td>Acceptable performance</td>\n<td>No denial-of-service</td>\n</tr>\n</tbody></table>\n<p><strong>Automated Modern Hashing Testing</strong></p>\n<p>The <code>ModernPasswordHasher</code> provides comprehensive testing for advanced algorithm features:</p>\n<table>\n<thead>\n<tr>\n<th>Test Category</th>\n<th>Method</th>\n<th>Purpose</th>\n<th>Success Criteria</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Algorithm Benchmarking</td>\n<td><code>benchmark_algorithm(algorithm, **parameters)</code></td>\n<td>Performance measurement</td>\n<td>Meet timing targets</td>\n</tr>\n<tr>\n<td>Migration Analysis</td>\n<td><code>assess_migration_need(record)</code></td>\n<td>Upgrade necessity</td>\n<td>Accurate assessment</td>\n</tr>\n<tr>\n<td>Security Assessment</td>\n<td><code>assess_hash_strength(hash_record)</code></td>\n<td>Security evaluation</td>\n<td>Current strength analysis</td>\n</tr>\n<tr>\n<td>Batch Migration</td>\n<td><code>batch_migration_analysis(hash_records)</code></td>\n<td>Large-scale migration</td>\n<td>Efficient processing</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Milestone 3 Security Checkpoint Summary</strong>: The system must demonstrate production-grade password hashing with modern algorithms, seamless migration capabilities, and algorithm agility that supports future cryptographic evolution.</p>\n</blockquote>\n<h3 id=\"common-security-testing-pitfalls\">Common Security Testing Pitfalls</h3>\n<p>Password hashing security testing involves numerous subtle requirements that are easy to overlook but critical for security. These pitfalls often involve testing methodology rather than implementation, making them particularly dangerous because they can provide false confidence in insecure implementations.</p>\n<p>⚠️ <strong>Pitfall: Insufficient Sample Sizes for Statistical Tests</strong></p>\n<p>Many developers test salt uniqueness with small sample sizes (hundreds or thousands of salts) and conclude that their generator is secure. However, statistical significance for cryptographic randomness requires much larger samples—typically hundreds of thousands or millions of values.</p>\n<p><strong>Why this is wrong</strong>: Small sample sizes can miss subtle biases that become exploitable at scale. An attacker processing millions of password hashes can detect patterns that small-scale testing misses.</p>\n<p><strong>How to fix</strong>: Use statistically appropriate sample sizes based on the security property being tested. For salt collision testing, generate at least 100,000 salts. For entropy distribution testing, analyze at least 1 million salt bytes.</p>\n<p>⚠️ <strong>Pitfall: Testing Only Happy Path Scenarios</strong></p>\n<p>Security testing often focuses on normal operation scenarios (valid passwords, proper algorithm parameters, sufficient system resources) while neglecting edge cases that attackers specifically target.</p>\n<p><strong>Why this is wrong</strong>: Attackers deliberately create abnormal conditions to exploit edge cases. Security vulnerabilities often exist at the boundaries of normal operation.</p>\n<p><strong>How to fix</strong>: Systematically test edge cases including invalid inputs, resource exhaustion, algorithm failures, and concurrent access scenarios. Use the <code>SecurityEducationDemos</code> to understand attack vectors.</p>\n<p>⚠️ <strong>Pitfall: Timing Attack Testing with Insufficient Precision</strong></p>\n<p>Developers often test timing attack resistance using system clocks with millisecond precision, missing microsecond-level timing differences that attackers can exploit.</p>\n<p><strong>Why this is wrong</strong>: Network attackers can perform statistical analysis over thousands of requests to detect timing differences much smaller than individual measurement precision.</p>\n<p><strong>How to fix</strong>: Use high-precision timing measurements (nanosecond resolution) and perform statistical analysis over large sample sizes. Test timing consistency under various system load conditions.</p>\n<p>⚠️ <strong>Pitfall: Not Testing Algorithm Migration Security</strong></p>\n<p>Many implementations test individual algorithms thoroughly but fail to test the security properties of migration between algorithms, particularly the transition period when both old and new hashes coexist.</p>\n<p><strong>Why this is wrong</strong>: Migration represents a complex operational scenario with unique security risks. Vulnerabilities during migration can compromise the entire security upgrade process.</p>\n<p><strong>How to fix</strong>: Explicitly test migration scenarios including concurrent migrations, migration failures, and rollback procedures. Verify that security never degrades during algorithm transitions.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>The testing strategy implementation provides concrete tools for verifying cryptographic security properties throughout the development process. This guidance bridges the conceptual testing framework with practical verification code.</p>\n<h4 id=\"security-testing-technology-stack\">Security Testing Technology Stack</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>When to Use</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Statistical Analysis</td>\n<td>Python built-in <code>statistics</code> module</td>\n<td>SciPy statistical functions</td>\n<td>Simple for basic tests, SciPy for cryptographic analysis</td>\n</tr>\n<tr>\n<td>Timing Measurement</td>\n<td><code>time.perf_counter()</code> for basic timing</td>\n<td><code>timeit</code> module with statistical analysis</td>\n<td>Basic for functional tests, timeit for security verification</td>\n</tr>\n<tr>\n<td>Cryptographic Testing</td>\n<td>Custom collision detection</td>\n<td>PyCrypto test vectors and NIST test suites</td>\n<td>Custom for learning, NIST standards for production</td>\n</tr>\n<tr>\n<td>Load Testing</td>\n<td>Simple loops with threading</td>\n<td><code>pytest-benchmark</code> with concurrent execution</td>\n<td>Simple for development, benchmark for performance validation</td>\n</tr>\n<tr>\n<td>Memory Analysis</td>\n<td>Basic resource monitoring</td>\n<td><code>memory_profiler</code> with detailed tracking</td>\n<td>Basic for functional tests, profiler for security analysis</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-test-file-structure\">Recommended Test File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  tests/\n    security/                          ← security-specific tests\n      test_salt_security.py           ← cryptographic randomness tests\n      test_timing_attacks.py          ← timing attack resistance tests\n      test_algorithm_security.py      ← algorithm security property tests\n      test_migration_security.py      ← migration security tests\n    integration/                       ← end-to-end testing\n      test_password_flows.py          ← complete authentication flows\n      test_performance_benchmarks.py  ← performance and scalability tests\n    utils/                            ← testing infrastructure\n      security_test_utils.py          ← shared security testing functions\n      attack_simulators.py            ← attack simulation utilities\n      benchmark_tools.py              ← performance measurement tools</code></pre></div>\n\n<h4 id=\"security-testing-infrastructure-code\">Security Testing Infrastructure Code</h4>\n<p>This infrastructure provides the foundation for security testing across all milestones. Copy this code directly and use it as the base for milestone-specific security tests:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Security Testing Infrastructure for Password Hashing System</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides statistical analysis and attack simulation capabilities.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> secrets</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> List, Dict, Any, Tuple, Callable</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> collections </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> defaultdict</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashlib</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> SecurityTestFramework</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Comprehensive security testing framework for password hashing systems.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Provides statistical analysis, timing attack detection, and cryptographic verification.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, precision_ns: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.timing_precision_ns </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> precision_ns</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.statistical_samples </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> defaultdict(</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> measure_execution_time</span><span style=\"color:#E1E4E8\">(self, func: Callable, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        High-precision execution time measurement with statistical analysis.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Returns timing statistics including mean, median, and variance.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        measurements </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Warmup runs to eliminate JIT compilation effects</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            func(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Actual measurements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter_ns()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> func(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            end_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter_ns()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            measurements.append((end_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1_000_000</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Convert to milliseconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'mean_ms'</span><span style=\"color:#E1E4E8\">: statistics.mean(measurements),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'median_ms'</span><span style=\"color:#E1E4E8\">: statistics.median(measurements),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'std_dev_ms'</span><span style=\"color:#E1E4E8\">: statistics.stdev(measurements) </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(measurements) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> else</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'min_ms'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">min</span><span style=\"color:#E1E4E8\">(measurements),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'max_ms'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">max</span><span style=\"color:#E1E4E8\">(measurements),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'sample_count'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(measurements)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> analyze_salt_randomness</span><span style=\"color:#E1E4E8\">(self, salt_generator: Callable, sample_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100000</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Comprehensive cryptographic randomness analysis for salt generation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Performs collision detection, entropy analysis, and distribution testing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        salts </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        byte_frequencies </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> defaultdict(</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        consecutive_differences </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        previous_salt </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        collision_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(sample_count):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            salt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> salt_generator()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Collision detection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> salt </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> salts:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                collision_count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            salts.add(salt)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Byte frequency analysis</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> byte_val </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> salt:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                byte_frequencies[byte_val] </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Sequential independence analysis</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> previous_salt </span><span style=\"color:#F97583\">is</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                hamming_distance </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> sum</span><span style=\"color:#E1E4E8\">(a </span><span style=\"color:#F97583\">!=</span><span style=\"color:#E1E4E8\"> b </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> a, b </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> zip</span><span style=\"color:#E1E4E8\">(salt, previous_salt))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                consecutive_differences.append(hamming_distance)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            previous_salt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> salt</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Chi-square test for uniform distribution</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expected_frequency </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> sample_count </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">next</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">iter</span><span style=\"color:#E1E4E8\">(salts))) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 256</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        chi_square </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> sum</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            (observed </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> expected_frequency) </span><span style=\"color:#F97583\">**</span><span style=\"color:#79B8FF\"> 2</span><span style=\"color:#F97583\"> /</span><span style=\"color:#E1E4E8\"> expected_frequency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> observed </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> byte_frequencies.values()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'sample_count'</span><span style=\"color:#E1E4E8\">: sample_count,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'unique_salts'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(salts),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'collision_count'</span><span style=\"color:#E1E4E8\">: collision_count,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'collision_rate'</span><span style=\"color:#E1E4E8\">: collision_count </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> sample_count,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'chi_square_statistic'</span><span style=\"color:#E1E4E8\">: chi_square,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'chi_square_critical_value'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">293.25</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># 95% confidence for 255 degrees of freedom</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'passes_chi_square'</span><span style=\"color:#E1E4E8\">: chi_square </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> 293.25</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'mean_hamming_distance'</span><span style=\"color:#E1E4E8\">: statistics.mean(consecutive_differences) </span><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> consecutive_differences </span><span style=\"color:#F97583\">else</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'hamming_distance_std'</span><span style=\"color:#E1E4E8\">: statistics.stdev(consecutive_differences) </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(consecutive_differences) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> else</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> detect_timing_attack_vulnerability</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                          verification_func: Callable, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                          valid_cases: List[Tuple], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                          invalid_cases: List[Tuple],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                          significance_threshold: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 0.05</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Statistical timing attack vulnerability detection.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Compares timing distributions between valid and invalid authentication attempts.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        valid_timings </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        invalid_timings </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Measure valid case timings</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> test_case </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> valid_cases:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            timing_stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.measure_execution_time(verification_func, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">test_case)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            valid_timings.append(timing_stats[</span><span style=\"color:#9ECBFF\">'mean_ms'</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Measure invalid case timings  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> test_case </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> invalid_cases:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            timing_stats </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.measure_execution_time(verification_func, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">test_case)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            invalid_timings.append(timing_stats[</span><span style=\"color:#9ECBFF\">'mean_ms'</span><span style=\"color:#E1E4E8\">])</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Statistical significance testing</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        valid_mean </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> statistics.mean(valid_timings)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        invalid_mean </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> statistics.mean(invalid_timings)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        timing_difference </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> abs</span><span style=\"color:#E1E4E8\">(valid_mean </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> invalid_mean)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Simplified t-test approximation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        pooled_variance </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            statistics.variance(valid_timings) </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> statistics.variance(invalid_timings)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        t_statistic </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timing_difference </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> (pooled_variance </span><span style=\"color:#F97583\">**</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#F97583\"> *</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#79B8FF\">2</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(valid_timings)) </span><span style=\"color:#F97583\">**</span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'valid_mean_ms'</span><span style=\"color:#E1E4E8\">: valid_mean,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'invalid_mean_ms'</span><span style=\"color:#E1E4E8\">: invalid_mean,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'timing_difference_ms'</span><span style=\"color:#E1E4E8\">: timing_difference,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            't_statistic'</span><span style=\"color:#E1E4E8\">: t_statistic,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'likely_vulnerable'</span><span style=\"color:#E1E4E8\">: t_statistic </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 2.0</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># Rough significance threshold</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'valid_timing_variance'</span><span style=\"color:#E1E4E8\">: statistics.variance(valid_timings),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'invalid_timing_variance'</span><span style=\"color:#E1E4E8\">: statistics.variance(invalid_timings),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">            'recommendation'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Implement constant-time comparison'</span><span style=\"color:#F97583\"> if</span><span style=\"color:#E1E4E8\"> t_statistic </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 2.0</span><span style=\"color:#F97583\"> else</span><span style=\"color:#9ECBFF\"> 'Timing appears consistent'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AttackSimulationFramework</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Framework for simulating various password hash attacks.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Used to verify that security measures are effective against real attack methods.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @</span><span style=\"color:#79B8FF\">staticmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> simulate_rainbow_table_attack</span><span style=\"color:#E1E4E8\">(target_hashes: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                    dictionary_passwords: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                    salt_list: List[</span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Simulates rainbow table attack against unsalted hashes.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Demonstrates why salting is critical for security.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> salt_list </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Unsalted hash attack - very effective</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            rainbow_table </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> password </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> dictionary_passwords:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                hash_value </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hashlib.sha256(password.encode()).hexdigest()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                rainbow_table[hash_value] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> password</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            cracked_passwords </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> target_hash </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> target_hashes:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> target_hash </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> rainbow_table:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    cracked_passwords[target_hash] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> rainbow_table[target_hash]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'attack_type'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'rainbow_table_unsalted'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'rainbow_table_size'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(rainbow_table),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'target_hashes'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(target_hashes),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'cracked_count'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(cracked_passwords),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'success_rate'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(cracked_passwords) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(target_hashes),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'cracked_passwords'</span><span style=\"color:#E1E4E8\">: cracked_passwords,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'effectiveness'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Very High - Salting Required'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Salted hash attack - much less effective</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            attempted_cracks </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            successful_cracks </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> target_hash, salt </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> zip</span><span style=\"color:#E1E4E8\">(target_hashes, salt_list):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                for</span><span style=\"color:#E1E4E8\"> password </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> dictionary_passwords:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    attempted_cracks </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    test_hash </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hashlib.sha256(salt </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> password.encode()).hexdigest()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> test_hash </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> target_hash:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        successful_cracks </span><span style=\"color:#F97583\">+=</span><span style=\"color:#79B8FF\"> 1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'attack_type'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'rainbow_table_salted'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'attempted_combinations'</span><span style=\"color:#E1E4E8\">: attempted_cracks,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'successful_cracks'</span><span style=\"color:#E1E4E8\">: successful_cracks,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'success_rate'</span><span style=\"color:#E1E4E8\">: successful_cracks </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(target_hashes),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                'effectiveness'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'Low - Salting Effective'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span></code></pre></div>\n\n<h4 id=\"milestone-specific-testing-skeletons\">Milestone-Specific Testing Skeletons</h4>\n<p><strong>Milestone 1 Security Tests (implement these TODOs):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_milestone_1_salt_security</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Comprehensive security testing for Milestone 1: Basic Hashing with Salt</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create SaltGenerator instance with default parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Use SecurityTestFramework.analyze_salt_randomness() with 100,000 samples</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Assert collision_count == 0 (no duplicate salts)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Assert passes_chi_square == True (uniform distribution)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Assert mean_hamming_distance is approximately half the salt length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Generate timing attack test cases (valid and invalid passwords)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Use SecurityTestFramework.detect_timing_attack_vulnerability()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 8: Assert likely_vulnerable == False (timing attack resistance)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_milestone_1_hash_determinism</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Verify that identical inputs produce identical outputs consistently</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create BasicHasher instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Generate fixed test salt using secrets.token_bytes(32)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Hash same password with same salt 100 times</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Assert all hash outputs are identical</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Hash same password with different salts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Assert all hash outputs are different</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>Milestone 2 Security Tests (implement these TODOs):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_milestone_2_iteration_scaling</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Verify that iteration count scaling provides linear time increase</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create KeyStretchingHasher instance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Test iteration counts: [100000, 200000, 400000]</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Measure timing for each iteration count using SecurityTestFramework</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Calculate timing ratios between iteration counts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Assert timing scales approximately linearly with iterations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Verify minimum iteration count enforcement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Assert IterationCountError raised for counts &#x3C; PBKDF2_MIN_ITERATIONS</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_milestone_2_computational_hardness</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Verify that key stretching provides meaningful brute force protection</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Benchmark single password verification time</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Calculate brute force time for 10^8 password attempts</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Assert brute force time > 1 year for reasonable hardware</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Test different iteration counts and measure scaling</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Verify that higher iteration counts provide proportional protection</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<p><strong>Milestone 3 Security Tests (implement these TODOs):</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_milestone_3_algorithm_security_properties</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Verify security properties of modern hashing algorithms</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create ModernPasswordHasher with bcrypt and Argon2</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Test bcrypt cost factor scaling (costs 10, 12, 14)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Assert exponential time scaling for bcrypt</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Test Argon2 memory usage with different memory parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Assert memory usage matches configured parameters</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Verify algorithm agility by switching between algorithms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Test migration from weak to strong algorithm parameters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> test_milestone_3_migration_security</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Verify that algorithm migration maintains security throughout transition</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Create password hashes with legacy algorithm (SHA-256)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Implement lazy migration during authentication</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Verify that migration upgrades algorithm without breaking authentication  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Test concurrent migration scenarios with threading</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Assert no race conditions during migration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Test migration failure handling and rollback</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Verify security never degrades during migration process</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"performance-benchmark-testing\">Performance Benchmark Testing</h4>\n<p>Security and performance are interconnected in password hashing systems. These benchmarks verify that security configurations meet performance requirements:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> benchmark_security_performance</span><span style=\"color:#E1E4E8\">():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Benchmark password hashing performance across security configurations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Verifies that security settings meet operational performance requirements.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Define target authentication times (&#x3C; 500ms for user experience)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Test bcrypt cost factors 10, 11, 12, 13, 14</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Test Argon2 memory parameters: 64MB, 128MB, 256MB</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Test PBKDF2 iteration counts: 100K, 200K, 500K, 1M</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Measure statistical timing distribution (mean, p95, p99)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Identify optimal security/performance balance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 7: Generate recommendation report for production deployment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    pass</span></span></code></pre></div>\n\n<h4 id=\"debugging-security-test-failures\">Debugging Security Test Failures</h4>\n<table>\n<thead>\n<tr>\n<th>Test Failure Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis Steps</th>\n<th>Fix Approach</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Salt collisions detected</td>\n<td>Weak random number generator</td>\n<td>Check entropy source, test generator directly</td>\n<td>Use secrets module, verify entropy pool</td>\n</tr>\n<tr>\n<td>Timing attack vulnerability</td>\n<td>Non-constant-time comparison</td>\n<td>Profile comparison function execution</td>\n<td>Implement constant_time_compare()</td>\n</tr>\n<tr>\n<td>Chi-square test failure</td>\n<td>Biased salt generation</td>\n<td>Analyze byte distribution patterns</td>\n<td>Review random generation algorithm</td>\n</tr>\n<tr>\n<td>Performance too slow</td>\n<td>Excessive security parameters</td>\n<td>Benchmark individual operations</td>\n<td>Reduce iteration/memory parameters</td>\n</tr>\n<tr>\n<td>Migration test failures</td>\n<td>Race conditions in updates</td>\n<td>Test concurrent access patterns</td>\n<td>Add proper synchronization</td>\n</tr>\n</tbody></table>\n<h2 id=\"debugging-guide\">Debugging Guide</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (debugging strategies are essential across all implementation phases from basic salt/hash verification through key stretching validation to modern algorithm integration)</p>\n</blockquote>\n<h3 id=\"mental-model-the-medical-diagnostic-system\">Mental Model: The Medical Diagnostic System</h3>\n<p>Think of debugging password hashing systems like a medical diagnostic process in a specialized cryptographic security clinic. Just as a doctor follows systematic diagnostic procedures to identify the root cause of symptoms—checking vital signs, running specific tests, and comparing results against known patterns—debugging password hashing requires methodical analysis of security symptoms, systematic testing of cryptographic properties, and comparison against known secure implementation patterns.</p>\n<p>When a patient arrives with chest pain, an experienced physician doesn&#39;t immediately assume heart attack—they systematically rule out other causes like muscle strain, anxiety, or digestive issues through specific tests and observations. Similarly, when a password hashing system exhibits security vulnerabilities or functional failures, an experienced security engineer follows systematic diagnostic procedures to isolate the root cause, whether it&#39;s inadequate randomness, timing vulnerabilities, or algorithm misconfiguration.</p>\n<p>The diagnostic process involves understanding both the symptoms (what&#39;s observable) and the underlying pathophysiology (why the system is behaving incorrectly). This section provides the equivalent of a medical diagnostic manual for password hashing systems—mapping symptoms to likely causes, providing specific diagnostic tests, and prescribing targeted remediation strategies.</p>\n<h3 id=\"common-implementation-bugs\">Common Implementation Bugs</h3>\n<p>Password hashing implementations frequently exhibit predictable failure patterns that manifest as specific observable symptoms. Understanding these symptom-cause-fix mappings enables rapid diagnosis and remediation of security vulnerabilities before they reach production systems.</p>\n<p>The following diagnostic reference maps observable symptoms to their underlying causes, provides specific diagnostic procedures, and prescribes targeted fixes. Each entry represents a common failure mode discovered through extensive analysis of real-world password hashing implementations.</p>\n<h4 id=\"salt-generation-failures\">Salt Generation Failures</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Underlying Cause</th>\n<th>Diagnostic Test</th>\n<th>Remediation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Identical salts across multiple password hashes</td>\n<td>Using predictable pseudorandom generator instead of cryptographically secure randomness</td>\n<td>Generate 1000 salts and check for duplicates; analyze entropy distribution</td>\n<td>Replace <code>random.random()</code> or <code>Math.random()</code> with <code>os.urandom()</code>, <code>secrets.token_bytes()</code>, or equivalent cryptographically secure source</td>\n</tr>\n<tr>\n<td>Salt generation throws entropy exhaustion errors</td>\n<td>Insufficient system entropy, particularly in containerized environments</td>\n<td>Monitor <code>/proc/sys/kernel/random/entropy_avail</code> on Linux; test salt generation under load</td>\n<td>Implement entropy pool monitoring; use <code>secrets</code> module which handles blocking appropriately; consider hardware random number generators</td>\n</tr>\n<tr>\n<td>Salts contain only ASCII characters when binary expected</td>\n<td>Incorrectly encoding random bytes as strings</td>\n<td>Examine salt bytes directly; verify salt length matches expected binary length</td>\n<td>Generate raw bytes with <code>os.urandom()</code> or <code>secrets.token_bytes()</code> instead of converting to string representations</td>\n</tr>\n<tr>\n<td>Salt length varies across password hashes</td>\n<td>Dynamic salt length calculation or truncation bugs</td>\n<td>Check <code>len(salt)</code> across multiple generated salts; verify against <code>MINIMUM_SALT_LENGTH</code> constant</td>\n<td>Use fixed salt length; validate salt length during generation with <code>validate_salt_length()</code></td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Using Time-Based Seeds</strong>\nMany developers initialize pseudorandom generators with current time as seed, believing this provides sufficient randomness. Time-based seeds are highly predictable—an attacker can enumerate possible seed values within a reasonable timeframe. The fix requires using cryptographically secure random sources that derive entropy from hardware noise sources rather than predictable system state.</p>\n<p>⚠️ <strong>Pitfall: Salt Reuse Across Applications</strong>\nUsing the same salt generation logic across multiple applications or user accounts creates correlation vulnerabilities. Even with cryptographically secure randomness, correlated salt generation patterns can leak information about password distribution. Each salt must be independently generated using the <code>SaltGenerator</code> component with proper isolation.</p>\n<h4 id=\"hash-computation-vulnerabilities\">Hash Computation Vulnerabilities</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Underlying Cause</th>\n<th>Diagnostic Test</th>\n<th>Remediation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Password verification succeeds with incorrect passwords</td>\n<td>Hash computation concatenating password and salt in wrong order</td>\n<td>Test known password/salt pair; verify hash computation matches expected output</td>\n<td>Standardize concatenation order in <code>BasicHasher.hash_password()</code> as `password</td>\n</tr>\n<tr>\n<td>Hash verification fails for previously stored valid passwords</td>\n<td>Character encoding inconsistencies between storage and verification</td>\n<td>Test with Unicode passwords containing special characters; verify byte-level hash computation</td>\n<td>Ensure consistent UTF-8 encoding using <code>.encode(&#39;utf-8&#39;)</code> before hash computation</td>\n</tr>\n<tr>\n<td>Timing attack vulnerability in password comparison</td>\n<td>Using standard string comparison instead of constant-time comparison</td>\n<td>Measure verification time with correct vs incorrect passwords using <code>measure_execution_time()</code></td>\n<td>Replace string comparison with <code>constant_time_compare()</code> function</td>\n</tr>\n<tr>\n<td>Hash computation crashes with certain password inputs</td>\n<td>Input validation missing for password edge cases</td>\n<td>Test with empty passwords, very long passwords, and None/null inputs</td>\n<td>Implement <code>_validate_password_input()</code> to reject invalid inputs before processing</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Hash Algorithm Confusion</strong>\nMixing different hash algorithms during computation and verification creates subtle bugs where hashes appear valid but never match. For example, using SHA-256 during registration but SHA-1 during verification. The <code>PasswordHashRecord</code> must store algorithm metadata to ensure verification uses identical hash computation.</p>\n<p>⚠️ <strong>Pitfall: Platform-Dependent Hash Computation</strong>\nHash computation that works differently across operating systems or Python versions indicates platform-dependent behavior, usually from encoding or library differences. All hash computation should use explicit byte-level operations with the <code>hashlib</code> module to ensure cross-platform consistency.</p>\n<h4 id=\"pbkdf2-implementation-errors\">PBKDF2 Implementation Errors</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Underlying Cause</th>\n<th>Diagnostic Test</th>\n<th>Remediation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PBKDF2 verification extremely slow compared to generation</td>\n<td>Iteration count not stored with hash, defaulting to maximum during verification</td>\n<td>Compare iteration counts between generation and verification; check <code>PasswordHashRecord.parameters[&#39;iterations&#39;]</code></td>\n<td>Store iteration count in hash record parameters; verify <code>KeyStretchingHasher</code> retrieves stored iterations</td>\n</tr>\n<tr>\n<td>Key stretching provides no security benefit</td>\n<td>Iteration count too low or PBKDF2 implementation bypassed</td>\n<td>Benchmark hash computation time; verify minimum <code>PBKDF2_MIN_ITERATIONS</code> enforcement</td>\n<td>Increase iteration count to meet timing targets; implement <code>validate_iteration_count()</code></td>\n</tr>\n<tr>\n<td>PBKDF2 crashes with certain parameter combinations</td>\n<td>Parameter validation missing or incorrect</td>\n<td>Test with edge case parameters: zero iterations, negative key length, None salt</td>\n<td>Implement comprehensive parameter validation in <code>validate_pbkdf2_parameters()</code></td>\n</tr>\n<tr>\n<td>Derived key length inconsistent across verifications</td>\n<td>Dynamic key length calculation or parameter corruption</td>\n<td>Verify consistent key length in <code>PasswordHashRecord.hash</code> field</td>\n<td>Store derived key length in hash record parameters; validate during verification</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Iteration Count Security Decay</strong>\nSetting iteration count once and never updating it creates security decay as hardware performance improves. Iteration counts appropriate in 2020 may provide insufficient protection in 2025. Implement <code>evolve_security_parameters()</code> to recommend iteration count increases based on current hardware benchmarks.</p>\n<p>⚠️ <strong>Pitfall: PBKDF2 Salt Confusion</strong>\nUsing different salt values for PBKDF2 key derivation versus the stored salt creates verification failures. The identical salt used during hash generation must be used during verification. The <code>KeyStretchingHasher</code> must retrieve salt from the <code>PasswordHashRecord</code> rather than generating fresh salt.</p>\n<h4 id=\"modern-algorithm-integration-problems\">Modern Algorithm Integration Problems</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Underlying Cause</th>\n<th>Diagnostic Test</th>\n<th>Remediation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Bcrypt verification fails with &quot;invalid hash&quot; errors</td>\n<td>Incorrect bcrypt hash parsing or format corruption</td>\n<td>Validate bcrypt hash format using regex; check for truncation or encoding issues</td>\n<td>Use standard bcrypt library functions; validate hash format before verification</td>\n</tr>\n<tr>\n<td>Argon2 memory consumption exceeds system limits</td>\n<td>Memory parameters configured beyond system capabilities</td>\n<td>Monitor memory usage during hash computation; test with <code>ARGON2_DEFAULT_MEMORY</code></td>\n<td>Implement memory parameter validation; tune parameters for deployment environment</td>\n</tr>\n<tr>\n<td>Algorithm migration fails silently</td>\n<td>Migration assessment logic incorrect or migration triggers not firing</td>\n<td>Test migration with known old hash formats; verify <code>MigrationAssessment.needs_migration</code></td>\n<td>Implement comprehensive migration testing; validate algorithm detection logic</td>\n</tr>\n<tr>\n<td>Modern hashing performance dramatically slower than expected</td>\n<td>Cost parameters configured for different hardware generation</td>\n<td>Benchmark algorithm performance with <code>benchmark_algorithm()</code>; compare against target timing</td>\n<td>Tune algorithm parameters for current hardware using <code>PerformanceBenchmarker</code></td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Algorithm Availability Assumptions</strong>\nAssuming bcrypt or Argon2 libraries are always available creates runtime failures in restricted environments. The <code>DegradationManager</code> must handle algorithm unavailability gracefully, falling back to available algorithms while maintaining security properties.</p>\n<p>⚠️ <strong>Pitfall: Migration Loop Scenarios</strong>\nIncorrect migration logic can create infinite migration loops where hash records are repeatedly &quot;upgraded&quot; without actually improving security. Migration assessment must include timestamp checks and algorithm advancement verification to prevent degradation loops.</p>\n<h4 id=\"timing-attack-vulnerabilities\">Timing Attack Vulnerabilities</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Underlying Cause</th>\n<th>Diagnostic Test</th>\n<th>Remediation Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Password verification time varies significantly with input length</td>\n<td>String comparison short-circuiting on first character mismatch</td>\n<td>Measure verification time with passwords of different lengths using <code>detect_timing_attack_vulnerability()</code></td>\n<td>Implement <code>constant_time_compare()</code> for all password-derived comparisons</td>\n</tr>\n<tr>\n<td>Verification time differs between valid and invalid usernames</td>\n<td>Different code paths for existing vs non-existing users</td>\n<td>Time password verification for valid vs invalid usernames</td>\n<td>Implement <code>_execute_dummy_verification()</code> to normalize timing</td>\n</tr>\n<tr>\n<td>Hash computation time leaks information about password content</td>\n<td>Variable-time operations in hash preprocessing</td>\n<td>Measure hash computation time across different password patterns</td>\n<td>Ensure all hash computation uses constant-time operations</td>\n</tr>\n<tr>\n<td>Database query time varies with user existence</td>\n<td>Database query optimization differences for existing vs missing records</td>\n<td>Profile database query performance for user lookup operations</td>\n<td>Implement consistent database query patterns; consider caching strategies</td>\n</tr>\n</tbody></table>\n<p>⚠️ <strong>Pitfall: Timing Consistency Testing Inadequate</strong>\nTesting timing attack resistance with artificial delays or insufficient precision measurements fails to detect real timing vulnerabilities. Use high-precision timing measurement with <code>measure_execution_time()</code> and statistical analysis to detect timing differences smaller than network jitter.</p>\n<p>⚠️ <strong>Pitfall: Side-Channel Information Leakage</strong>\nBeyond timing attacks, password hashing can leak information through memory allocation patterns, CPU cache behavior, or power consumption. While difficult to exploit remotely, these side channels become relevant in shared hosting environments or specialized attack scenarios.</p>\n<h3 id=\"debugging-techniques\">Debugging Techniques</h3>\n<p>Effective debugging of password hashing systems requires specialized tools and methodologies that account for the cryptographic nature of the operations. Standard application debugging approaches must be supplemented with cryptographic analysis techniques, security property verification, and performance profiling tailored to authentication workloads.</p>\n<h4 id=\"cryptographic-analysis-toolkit\">Cryptographic Analysis Toolkit</h4>\n<p>The foundation of password hashing debugging involves verifying cryptographic properties that ensure security. These analysis techniques focus on detecting entropy deficiencies, randomness patterns, and cryptographic implementation errors that compromise security.</p>\n<p><strong>Entropy and Randomness Analysis</strong></p>\n<p>Salt generation quality directly impacts security, making randomness analysis critical for debugging. The <code>SecurityTestFramework</code> provides statistical tests for detecting entropy deficiencies and randomness pattern violations.</p>\n<table>\n<thead>\n<tr>\n<th>Analysis Type</th>\n<th>Tool Function</th>\n<th>Detection Capability</th>\n<th>Interpretation Guidance</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Salt uniqueness analysis</td>\n<td><code>analyze_salt_randomness(salt_generator, sample_count)</code></td>\n<td>Detects salt collisions and distribution bias</td>\n<td>Zero collisions expected in 10,000 samples; Chi-square test should show uniform distribution</td>\n</tr>\n<tr>\n<td>Entropy distribution testing</td>\n<td><code>verify_salt_uniqueness(password_count, sample_size)</code></td>\n<td>Identifies entropy exhaustion or generator bias</td>\n<td>Birthday paradox analysis; collision probability should match theoretical expectations</td>\n</tr>\n<tr>\n<td>Pattern detection analysis</td>\n<td>Statistical analysis of generated salt sequences</td>\n<td>Detects linear congruential generator patterns or seed correlation</td>\n<td>Autocorrelation should approach zero; frequency analysis should show uniform byte distribution</td>\n</tr>\n<tr>\n<td>Cross-platform consistency</td>\n<td>Generate salts on different systems; compare distributions</td>\n<td>Identifies platform-dependent randomness sources</td>\n<td>Statistical properties should be identical across platforms and Python versions</td>\n</tr>\n</tbody></table>\n<p><strong>Hash Computation Verification</strong></p>\n<p>Hash computation debugging requires verifying that identical inputs produce identical outputs across different execution contexts, while ensuring that timing characteristics don&#39;t leak information about input properties.</p>\n<table>\n<thead>\n<tr>\n<th>Verification Type</th>\n<th>Diagnostic Approach</th>\n<th>Expected Outcome</th>\n<th>Failure Investigation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cross-platform hash consistency</td>\n<td>Generate hash with identical salt/password on different systems</td>\n<td>Identical hash bytes across all platforms</td>\n<td>Check encoding, hash algorithm implementation, library versions</td>\n</tr>\n<tr>\n<td>Algorithm parameter verification</td>\n<td>Compare hash generation with known test vectors</td>\n<td>Hash matches published test vectors for algorithm</td>\n<td>Verify parameter parsing, algorithm selection, library compatibility</td>\n</tr>\n<tr>\n<td>Timing consistency analysis</td>\n<td><code>verify_timing_consistency(func, test_cases, tolerance_ms)</code></td>\n<td>Execution time variance within acceptable bounds</td>\n<td>Profile timing distribution; identify variable-time operations</td>\n</tr>\n<tr>\n<td>Input sanitization testing</td>\n<td>Test hash computation with malicious or edge case inputs</td>\n<td>Graceful failure or correct processing</td>\n<td>Review input validation; test Unicode normalization</td>\n</tr>\n</tbody></table>\n<h4 id=\"performance-and-security-profiling\">Performance and Security Profiling</h4>\n<p>Password hashing performance directly relates to security properties, making performance profiling essential for debugging both functional correctness and security adequacy.</p>\n<p><strong>Algorithm Performance Characterization</strong></p>\n<p>Understanding algorithm performance characteristics helps debug configuration issues, detect performance regressions, and validate security parameter tuning.</p>\n<table>\n<thead>\n<tr>\n<th>Profiling Focus</th>\n<th>Measurement Technique</th>\n<th>Security Implications</th>\n<th>Debugging Insights</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Iteration count scaling</td>\n<td><code>benchmark_cost_scaling(algorithm, cost_range)</code></td>\n<td>Higher iteration counts provide exponentially better brute force resistance</td>\n<td>Linear scaling indicates implementation problems; step functions suggest caching issues</td>\n</tr>\n<tr>\n<td>Memory usage profiling</td>\n<td>Monitor memory consumption during Argon2 operations</td>\n<td>Memory-hard algorithms should use configured memory amounts</td>\n<td>Insufficient memory usage indicates parameter validation failures</td>\n</tr>\n<tr>\n<td>Parallel execution analysis</td>\n<td>Test algorithm performance with concurrent operations</td>\n<td>Some algorithms may have unexpected contention or scaling issues</td>\n<td>Lock contention or shared resource bottlenecks affect production performance</td>\n</tr>\n<tr>\n<td>Hardware sensitivity testing</td>\n<td>Benchmark across different CPU architectures</td>\n<td>Algorithm performance varies significantly across hardware generations</td>\n<td>Parameter tuning must account for deployment environment characteristics</td>\n</tr>\n</tbody></table>\n<p><strong>Security Property Verification</strong></p>\n<p>Debugging security properties requires specialized testing that goes beyond functional correctness to verify that the implementation maintains security guarantees under various conditions.</p>\n<table>\n<thead>\n<tr>\n<th>Security Property</th>\n<th>Verification Method</th>\n<th>Expected Behavior</th>\n<th>Debugging Red Flags</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Timing attack resistance</td>\n<td><code>detect_timing_attack_vulnerability(verification_func, valid_cases, invalid_cases, threshold)</code></td>\n<td>Execution time independent of password correctness</td>\n<td>Significant timing differences indicate comparison vulnerabilities</td>\n</tr>\n<tr>\n<td>Salt correlation analysis</td>\n<td>Generate salts for related passwords; analyze for patterns</td>\n<td>No correlation between password similarity and salt patterns</td>\n<td>Correlation suggests salt generation depends on password content</td>\n</tr>\n<tr>\n<td>Algorithm downgrade resistance</td>\n<td>Test system behavior when preferred algorithms unavailable</td>\n<td>Graceful degradation to equivalent security alternatives</td>\n<td>Automatic downgrade to weaker algorithms indicates configuration problems</td>\n</tr>\n<tr>\n<td>Migration security preservation</td>\n<td>Verify migrated hashes maintain equivalent security properties</td>\n<td>Security level should improve or remain constant during migration</td>\n<td>Security degradation during migration suggests migration logic errors</td>\n</tr>\n</tbody></table>\n<h4 id=\"production-debugging-strategies\">Production Debugging Strategies</h4>\n<p>Debugging password hashing issues in production environments requires techniques that preserve security while enabling diagnosis of authentication failures and performance problems.</p>\n<p><strong>Safe Production Debugging</strong></p>\n<p>Production debugging must avoid logging sensitive information while providing sufficient detail for diagnosis.</p>\n<table>\n<thead>\n<tr>\n<th>Debugging Challenge</th>\n<th>Safe Approach</th>\n<th>Information Available</th>\n<th>Security Boundaries</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Authentication failure diagnosis</td>\n<td>Log algorithm metadata, timing information, but never password content</td>\n<td>Hash algorithm, parameter values, execution timing, error codes</td>\n<td>Never log passwords, salts, or hash values</td>\n</tr>\n<tr>\n<td>Performance issue investigation</td>\n<td>Sample timing distributions and algorithm usage patterns</td>\n<td>Statistical timing data, algorithm distribution, resource utilization</td>\n<td>Avoid user correlation or password-dependent measurements</td>\n</tr>\n<tr>\n<td>Migration progress monitoring</td>\n<td>Track migration completion percentages and algorithm distribution</td>\n<td>Migration statistics, algorithm adoption rates, error frequencies</td>\n<td>User identifiers and password data remain protected</td>\n</tr>\n<tr>\n<td>Configuration validation</td>\n<td>Validate algorithm availability and parameter ranges</td>\n<td>Algorithm capabilities, parameter validation results, system limits</td>\n<td>Configuration details safe to log; avoid user-specific data</td>\n</tr>\n</tbody></table>\n<p><strong>Error Pattern Analysis</strong></p>\n<p>Systematic analysis of error patterns helps identify configuration issues, deployment problems, and attack patterns without exposing sensitive authentication data.</p>\n<table>\n<thead>\n<tr>\n<th>Error Pattern</th>\n<th>Diagnostic Approach</th>\n<th>Root Cause Investigation</th>\n<th>Resolution Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Sudden authentication failure spikes</td>\n<td>Analyze error timing, affected user patterns, deployment correlation</td>\n<td>Check for configuration changes, algorithm availability, system resource limits</td>\n<td>Roll back configuration changes; verify algorithm dependencies</td>\n</tr>\n<tr>\n<td>Performance degradation trends</td>\n<td>Monitor authentication timing distributions over time</td>\n<td>Hardware changes, algorithm parameter drift, database performance</td>\n<td>Benchmark current performance against baselines; retune parameters</td>\n</tr>\n<tr>\n<td>Migration failure clusters</td>\n<td>Group migration failures by algorithm, timing, user characteristics</td>\n<td>Algorithm compatibility, parameter validation, resource constraints</td>\n<td>Validate migration logic; test algorithm transitions</td>\n</tr>\n<tr>\n<td>Intermittent verification failures</td>\n<td>Correlate failures with system load, resource availability, timing</td>\n<td>Resource exhaustion, timing threshold violations, concurrency issues</td>\n<td>Load test authentication under realistic conditions</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This implementation guidance provides concrete debugging tools and diagnostic utilities that enable systematic diagnosis of password hashing implementation issues. The tools focus on security property verification, performance analysis, and production-safe debugging techniques.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Debugging Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Timing Measurement</td>\n<td><code>time.time()</code> with manual statistics</td>\n<td><code>timeit</code> module with statistical analysis</td>\n</tr>\n<tr>\n<td>Cryptographic Analysis</td>\n<td>Manual salt inspection</td>\n<td><code>scipy.stats</code> for entropy analysis</td>\n</tr>\n<tr>\n<td>Performance Profiling</td>\n<td>Basic timing loops</td>\n<td><code>cProfile</code> with custom metrics</td>\n</tr>\n<tr>\n<td>Test Vector Validation</td>\n<td>Hardcoded test cases</td>\n<td>External test vector databases</td>\n</tr>\n<tr>\n<td>Production Monitoring</td>\n<td>File-based logging</td>\n<td>Structured logging with metrics</td>\n</tr>\n</tbody></table>\n<h4 id=\"file-structure-for-debugging-components\">File Structure for Debugging Components</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>password_hashing/\n├── debugging/\n│   ├── __init__.py\n│   ├── crypto_analyzer.py      ← cryptographic property analysis\n│   ├── performance_profiler.py ← algorithm performance testing\n│   ├── timing_security.py      ← timing attack detection\n│   ├── migration_validator.py  ← migration logic testing\n│   └── production_monitor.py   ← safe production debugging\n├── test_vectors/\n│   ├── salt_samples.json       ← known good salt test data\n│   ├── hash_test_vectors.json  ← algorithm test vectors\n│   └── timing_baselines.json   ← performance baselines\n└── scripts/\n    ├── validate_implementation.py ← comprehensive validation\n    └── benchmark_algorithms.py    ← parameter tuning utility</code></pre></div>\n\n<h4 id=\"cryptographic-analysis-implementation\">Cryptographic Analysis Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> secrets</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> statistics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Any</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> collections </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Counter</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RandomnessAnalysis</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Analysis results for cryptographic randomness quality.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    sample_count: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    collision_count: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    entropy_estimate: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    distribution_uniformity: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    autocorrelation_coefficient: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    passes_statistical_tests: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> CryptographicAnalyzer</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Comprehensive cryptographic property analysis for password hashing.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, precision_ns: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1000</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.precision_ns </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> precision_ns</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.test_samples </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> analyze_salt_randomness</span><span style=\"color:#E1E4E8\">(self, salt_generator, sample_count: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 10000</span><span style=\"color:#E1E4E8\">) -> RandomnessAnalysis:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Perform comprehensive randomness analysis on salt generation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Generates large sample of salts and performs statistical tests</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        to detect entropy deficiencies, pattern correlations, and</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        distribution bias that could compromise security.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Generate sample_count salts using salt_generator.generate_salt()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Check for exact duplicate salts (should be zero)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Calculate byte distribution uniformity using Chi-square test</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Compute autocorrelation coefficient for sequence analysis</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Estimate entropy per byte using Shannon entropy formula</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return RandomnessAnalysis with all computed metrics</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> verify_hash_consistency</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, salt: </span><span style=\"color:#79B8FF\">bytes</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                              hash_record: </span><span style=\"color:#9ECBFF\">'PasswordHashRecord'</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Verify hash computation produces consistent results across</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        multiple invocations and different execution contexts.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Re-compute hash using identical password, salt, algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Compare computed hash against hash_record.hash byte-for-byte</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Test hash computation 100 times to verify consistency</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Measure timing variance to detect timing inconsistencies</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return detailed consistency analysis results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> detect_timing_vulnerabilities</span><span style=\"color:#E1E4E8\">(self, verify_func, test_cases: List[</span><span style=\"color:#79B8FF\">tuple</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                    threshold_ms: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 1.0</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Detect timing attack vulnerabilities in password verification.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Measures execution time distributions for correct vs incorrect</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        passwords to identify timing side channels that leak information</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        about password correctness.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Execute verify_func for each test case 1000 times</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Measure high-precision timing using time.perf_counter_ns()</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Group timing measurements by password correctness</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Perform statistical t-test to detect timing differences</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return vulnerability assessment with statistical confidence</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> measure_execution_time</span><span style=\"color:#E1E4E8\">(func, </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    High-precision timing measurement for cryptographic operations.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Uses performance counter for nanosecond precision and performs</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    multiple measurements to account for system noise and scheduling.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    measurements </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    warmup_iterations </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 10</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    measurement_iterations </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 100</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Warmup phase to stabilize CPU caches and memory allocation</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(warmup_iterations):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        func(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Measurement phase with high-precision timing</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(measurement_iterations):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter_ns()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> func(</span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\">args, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">kwargs)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        end_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.perf_counter_ns()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        measurements.append((end_time </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time) </span><span style=\"color:#F97583\">/</span><span style=\"color:#79B8FF\"> 1_000_000</span><span style=\"color:#E1E4E8\">)  </span><span style=\"color:#6A737D\"># Convert to milliseconds</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'mean_time_ms'</span><span style=\"color:#E1E4E8\">: statistics.mean(measurements),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'median_time_ms'</span><span style=\"color:#E1E4E8\">: statistics.median(measurements),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'std_deviation_ms'</span><span style=\"color:#E1E4E8\">: statistics.stdev(measurements) </span><span style=\"color:#F97583\">if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(measurements) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 1</span><span style=\"color:#F97583\"> else</span><span style=\"color:#79B8FF\"> 0.0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'min_time_ms'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">min</span><span style=\"color:#E1E4E8\">(measurements),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'max_time_ms'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">max</span><span style=\"color:#E1E4E8\">(measurements),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'sample_count'</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(measurements),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        'result'</span><span style=\"color:#E1E4E8\">: result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span></code></pre></div>\n\n<h4 id=\"performance-analysis-implementation\">Performance Analysis Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> psutil</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> threading</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Tuple, Optional</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass, field</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> concurrent.futures </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> ThreadPoolExecutor</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PerformanceProfile</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Comprehensive performance analysis results.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    algorithm: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    parameters: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    timing_statistics: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    memory_usage: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cpu_utilization: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    scalability_metrics: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    recommendations: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> field(</span><span style=\"color:#FFAB70\">default_factory</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PerformanceProfiler</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Algorithm performance analysis and parameter tuning.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, target_time_ms: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 500.0</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.target_time_ms </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> target_time_ms</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.baseline_measurements </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> profile_algorithm_performance</span><span style=\"color:#E1E4E8\">(self, algorithm_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                    parameters: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                    test_password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"test_password_123\"</span><span style=\"color:#E1E4E8\">) -> PerformanceProfile:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Comprehensive performance profiling of password hashing algorithm.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Measures timing, memory usage, CPU utilization, and scalability</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        characteristics under realistic load patterns.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Initialize performance monitoring with psutil</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Measure single-threaded hash computation performance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Test concurrent hash operations to measure scalability</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Monitor memory allocation during hash computation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Generate performance recommendations based on measurements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return PerformanceProfile with comprehensive analysis</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> tune_algorithm_parameters</span><span style=\"color:#E1E4E8\">(self, algorithm_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                target_time_ms: </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Automatically tune algorithm parameters to meet target timing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Uses binary search approach to find optimal parameter values</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        that achieve target execution time on current hardware.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Define parameter search ranges for algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Implement binary search for iteration count or cost factor</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Measure actual performance at each parameter level</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Converge on parameters achieving target_time_ms ± 10%</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Validate final parameters meet security minimums</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return optimized parameter dictionary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> benchmark_hardware_capabilities</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Benchmark current hardware capabilities for password hashing.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Establishes performance baselines that can be used to detect</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        performance regressions or validate deployment environments.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Measure CPU single-core and multi-core performance</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Test memory bandwidth for memory-hard algorithms</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Establish baseline timing for each supported algorithm</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Measure system entropy generation rate</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return hardware capability assessment</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_implementation_security</span><span style=\"color:#E1E4E8\">(hasher_components: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Comprehensive validation of password hashing implementation security.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Performs automated testing of security properties across all</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    implementation components to verify cryptographic correctness.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    validation_results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Salt generation validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    salt_generator </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hasher_components.get(</span><span style=\"color:#9ECBFF\">'salt_generator'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> salt_generator:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Test salt uniqueness over large sample</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        salts </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> _ </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> range</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10000</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            salt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> salt_generator.generate_salt()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            validation_results[</span><span style=\"color:#9ECBFF\">'salt_no_collisions'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> salt </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> salts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            salts.add(salt)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Test salt length compliance</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sample_salt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> salt_generator.generate_salt()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        validation_results[</span><span style=\"color:#9ECBFF\">'salt_minimum_length'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(sample_salt) </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> 16</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    # Hash computation validation</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    hasher </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hasher_components.get(</span><span style=\"color:#9ECBFF\">'hasher'</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\"> hasher:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        test_password </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"validation_test_password\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        test_salt </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> secrets.token_bytes(</span><span style=\"color:#79B8FF\">32</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Test hash consistency</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        hash1 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hasher.hash_password(test_password, test_salt)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        hash2 </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hasher.hash_password(test_password, test_salt)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        validation_results[</span><span style=\"color:#9ECBFF\">'hash_deterministic'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hash1 </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> hash2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Test password verification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        verification_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hasher.verify_password(test_password, hash1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        validation_results[</span><span style=\"color:#9ECBFF\">'verification_correct'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> verification_result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Test incorrect password rejection</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        wrong_verification </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hasher.verify_password(</span><span style=\"color:#9ECBFF\">\"wrong_password\"</span><span style=\"color:#E1E4E8\">, hash1)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        validation_results[</span><span style=\"color:#9ECBFF\">'verification_rejects_incorrect'</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> wrong_verification</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    return</span><span style=\"color:#E1E4E8\"> validation_results</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints\">Milestone Checkpoints</h4>\n<p><strong>After Milestone 1 (Basic Hashing with Salt):</strong></p>\n<ul>\n<li>Run: <code>python -m debugging.crypto_analyzer</code> to verify salt randomness</li>\n<li>Expected: Zero salt collisions in 10,000 samples, uniform distribution</li>\n<li>Manual test: Generate same password hash twice with different salts—results should differ</li>\n<li>Debug check: Verify <code>constant_time_compare()</code> takes consistent time regardless of input</li>\n</ul>\n<p><strong>After Milestone 2 (Key Stretching):</strong></p>\n<ul>\n<li>Run: <code>python -m debugging.performance_profiler --algorithm pbkdf2</code> to validate iteration count</li>\n<li>Expected: Hash computation takes 200-500ms with minimum 100,000 iterations</li>\n<li>Manual test: Increase iteration count 2x, verify timing approximately doubles</li>\n<li>Debug check: Stored iteration count matches actual PBKDF2 computation</li>\n</ul>\n<p><strong>After Milestone 3 (Modern Password Hashing):</strong></p>\n<ul>\n<li>Run: <code>python scripts/validate_implementation.py --comprehensive</code> for full validation</li>\n<li>Expected: All security tests pass, migration logic handles algorithm transitions</li>\n<li>Manual test: Hash password with bcrypt, verify with Argon2 fails appropriately</li>\n<li>Debug check: Algorithm parameter tuning achieves target timing within 10%</li>\n</ul>\n<h4 id=\"debugging-red-flags\">Debugging Red Flags</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Immediate Investigation</th>\n<th>Critical Check</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Authentication randomly fails</td>\n<td>Check for race conditions in salt storage</td>\n<td>Verify thread safety of hash record access</td>\n</tr>\n<tr>\n<td>Performance suddenly degrades</td>\n<td>Monitor system entropy availability</td>\n<td>Check <code>/proc/sys/kernel/random/entropy_avail</code></td>\n</tr>\n<tr>\n<td>Timing measurements inconsistent</td>\n<td>Disable CPU frequency scaling during tests</td>\n<td>Use <code>time.perf_counter_ns()</code> for precision</td>\n</tr>\n<tr>\n<td>Migration never triggers</td>\n<td>Verify algorithm version detection logic</td>\n<td>Test with manually created old hash formats</td>\n</tr>\n<tr>\n<td>Memory usage exceeds limits</td>\n<td>Check Argon2 memory parameter validation</td>\n<td>Monitor actual vs configured memory usage</td>\n</tr>\n</tbody></table>\n<h2 id=\"future-extensions\">Future Extensions</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> Post-Milestone 3 (Advanced features building on modern password hashing foundation)</p>\n</blockquote>\n<h3 id=\"mental-model-the-evolving-security-ecosystem-analogy\">Mental Model: The Evolving Security Ecosystem Analogy</h3>\n<p>Think of future extensions like the evolution of a modern security ecosystem around a bank vault. Initially, you have a basic vault with strong locks and time delays (our password hashing system). But over time, the security needs evolve - you add biometric scanners, you integrate with national security databases to check for known threats, you implement policies about who can access what based on their role, and you add monitoring systems that alert you when someone&#39;s credentials appear in a data breach. Each extension builds on the solid foundation but adds new capabilities that weren&#39;t part of the original requirements. The vault itself remains unchanged, but the ecosystem around it becomes more sophisticated and responsive to emerging threats.</p>\n<p>The key insight is that password hashing is just one component in a broader authentication security ecosystem. While our core hashing implementation provides cryptographic security against offline attacks, real-world applications need additional layers of protection against evolving threat vectors like credential stuffing, password reuse, and social engineering attacks.</p>\n<blockquote>\n<p><strong>Design Principle: Extensible Security Architecture</strong>\nA well-designed password hashing system serves as a stable foundation that can be enhanced with additional security features without requiring changes to the core cryptographic implementation. Extensions should integrate through clean interfaces rather than modifying the fundamental hashing logic.</p>\n</blockquote>\n<h3 id=\"password-policy-integration-adding-strength-validation-and-policy-enforcement\">Password Policy Integration: Adding Strength Validation and Policy Enforcement</h3>\n<p>Password policy integration transforms our password hashing system from a passive cryptographic service into an active security gatekeeper. Think of it like upgrading from a simple door lock to a smart security system that not only secures the door but also evaluates whether visitors should be allowed entry based on various criteria.</p>\n<p>The fundamental challenge in password policy integration is balancing security requirements with user experience while maintaining clear separation of concerns between policy enforcement and cryptographic operations. Our hashing components should remain focused purely on secure storage and verification, while policy components handle the business logic of what constitutes an acceptable password.</p>\n<h4 id=\"architecture-decision-policy-integration-strategy\">Architecture Decision: Policy Integration Strategy</h4>\n<blockquote>\n<p><strong>Decision: Separate Policy Validation from Cryptographic Operations</strong></p>\n<ul>\n<li><strong>Context</strong>: Password policies involve business logic (minimum length, character requirements, dictionary checks) while hashing involves cryptographic security. These concerns have different update cycles and complexity profiles.</li>\n<li><strong>Options Considered</strong>: <ol>\n<li>Embed policy validation directly in hashing components</li>\n<li>Create separate policy validation layer that integrates with hashing</li>\n<li>Make policy validation completely independent with no integration</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Create separate policy validation layer with integration points</li>\n<li><strong>Rationale</strong>: Maintains single responsibility principle, allows policy updates without touching cryptographic code, enables different applications to use different policies with same hashing foundation</li>\n<li><strong>Consequences</strong>: Requires additional integration complexity but provides maximum flexibility and maintainability</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Policy Integration Option</th>\n<th>Pros</th>\n<th>Cons</th>\n<th>Maintainability</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Embedded in Hasher</td>\n<td>Simple integration, atomic validation</td>\n<td>Violates separation of concerns, hard to update policies</td>\n<td>Poor</td>\n</tr>\n<tr>\n<td>Separate Layer</td>\n<td>Clean separation, flexible policies, testable</td>\n<td>Additional integration complexity</td>\n<td>Excellent</td>\n</tr>\n<tr>\n<td>Completely Independent</td>\n<td>Maximum decoupling</td>\n<td>No integration benefits, duplicate error handling</td>\n<td>Good</td>\n</tr>\n</tbody></table>\n<p>The policy validation architecture centers around a <code>PasswordPolicyEngine</code> that evaluates passwords against configurable rules before they reach the hashing components. This engine maintains a registry of policy rules, each implementing a common interface for password evaluation.</p>\n<h4 id=\"policy-engine-data-structures\">Policy Engine Data Structures</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>PasswordPolicyEngine</code></td>\n<td>class</td>\n<td>Core engine coordinating policy evaluation</td>\n</tr>\n<tr>\n<td><code>policy_registry</code></td>\n<td>dict[str, PolicyRule]</td>\n<td>Registry mapping rule names to implementations</td>\n</tr>\n<tr>\n<td><code>active_policies</code></td>\n<td>list[str]</td>\n<td>Currently enabled policy rule names</td>\n</tr>\n<tr>\n<td><code>policy_configuration</code></td>\n<td>dict[str, Any]</td>\n<td>Configuration parameters for each policy</td>\n</tr>\n<tr>\n<td><code>evaluation_cache</code></td>\n<td>LRUCache</td>\n<td>Cache for expensive policy evaluations</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>register_policy(name, rule_class)</code></td>\n<td>name: str, rule_class: PolicyRule</td>\n<td>None</td>\n<td>Register new policy rule implementation</td>\n</tr>\n<tr>\n<td><code>configure_policy(name, **params)</code></td>\n<td>name: str, params: dict</td>\n<td>None</td>\n<td>Update configuration for specific policy</td>\n</tr>\n<tr>\n<td><code>enable_policies(policy_names)</code></td>\n<td>policy_names: list[str]</td>\n<td>None</td>\n<td>Activate specified policies for evaluation</td>\n</tr>\n<tr>\n<td><code>evaluate_password(password, context)</code></td>\n<td>password: str, context: dict</td>\n<td>PolicyEvaluationResult</td>\n<td>Run password through all active policies</td>\n</tr>\n<tr>\n<td><code>get_policy_requirements()</code></td>\n<td>None</td>\n<td>dict</td>\n<td>Return human-readable policy requirements</td>\n</tr>\n</tbody></table>\n<h4 id=\"policy-rule-interface\">Policy Rule Interface</h4>\n<p>The <code>PolicyRule</code> abstract base class defines the interface that all password policies must implement. This enables extensibility while maintaining consistent evaluation patterns.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>evaluate(password, context)</code></td>\n<td>password: str, context: dict</td>\n<td>RuleEvaluationResult</td>\n<td>Evaluate password against this specific rule</td>\n</tr>\n<tr>\n<td><code>get_requirements()</code></td>\n<td>None</td>\n<td>dict</td>\n<td>Return human-readable rule requirements</td>\n</tr>\n<tr>\n<td><code>get_configuration_schema()</code></td>\n<td>None</td>\n<td>dict</td>\n<td>Return JSON schema for rule configuration</td>\n</tr>\n<tr>\n<td><code>estimate_evaluation_cost()</code></td>\n<td>None</td>\n<td>float</td>\n<td>Return relative computational cost estimate</td>\n</tr>\n</tbody></table>\n<h4 id=\"built-in-policy-implementations\">Built-in Policy Implementations</h4>\n<p>The system provides several common policy rules that address the most frequent password security requirements:</p>\n<p><strong>Length Requirements Policy</strong>\nEnforces minimum and maximum password length constraints with configurable parameters.</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Parameter</th>\n<th>Type</th>\n<th>Default</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>minimum_length</code></td>\n<td>int</td>\n<td>8</td>\n<td>Minimum acceptable password length</td>\n</tr>\n<tr>\n<td><code>maximum_length</code></td>\n<td>int</td>\n<td>128</td>\n<td>Maximum acceptable password length</td>\n</tr>\n<tr>\n<td><code>encoding</code></td>\n<td>str</td>\n<td>&#39;utf-8&#39;</td>\n<td>Character encoding for length calculation</td>\n</tr>\n</tbody></table>\n<p><strong>Character Composition Policy</strong>\nRequires passwords to contain specified character types (uppercase, lowercase, digits, symbols).</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Parameter</th>\n<th>Type</th>\n<th>Default</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>require_uppercase</code></td>\n<td>bool</td>\n<td>True</td>\n<td>Must contain uppercase letters</td>\n</tr>\n<tr>\n<td><code>require_lowercase</code></td>\n<td>bool</td>\n<td>True</td>\n<td>Must contain lowercase letters</td>\n</tr>\n<tr>\n<td><code>require_digits</code></td>\n<td>bool</td>\n<td>True</td>\n<td>Must contain numeric digits</td>\n</tr>\n<tr>\n<td><code>require_symbols</code></td>\n<td>bool</td>\n<td>True</td>\n<td>Must contain non-alphanumeric symbols</td>\n</tr>\n<tr>\n<td><code>minimum_character_types</code></td>\n<td>int</td>\n<td>3</td>\n<td>Minimum distinct character types required</td>\n</tr>\n</tbody></table>\n<p><strong>Dictionary Attack Prevention Policy</strong>\nPrevents use of common passwords from known dictionaries and breach databases.</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Parameter</th>\n<th>Type</th>\n<th>Default</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>common_passwords_file</code></td>\n<td>str</td>\n<td>None</td>\n<td>Path to common passwords dictionary</td>\n</tr>\n<tr>\n<td><code>maximum_dictionary_size</code></td>\n<td>int</td>\n<td>100000</td>\n<td>Maximum dictionary entries to load</td>\n</tr>\n<tr>\n<td><code>case_sensitive</code></td>\n<td>bool</td>\n<td>False</td>\n<td>Whether dictionary matching is case sensitive</td>\n</tr>\n<tr>\n<td><code>allow_dictionary_substrings</code></td>\n<td>bool</td>\n<td>False</td>\n<td>Whether dictionary words can appear as substrings</td>\n</tr>\n</tbody></table>\n<h4 id=\"policy-evaluation-flow\">Policy Evaluation Flow</h4>\n<p>The password policy evaluation follows a structured process that balances thorough validation with performance:</p>\n<ol>\n<li><p><strong>Pre-evaluation Validation</strong>: The engine first validates that the password meets basic requirements (not None, proper encoding, reasonable length bounds) before proceeding with policy-specific evaluation.</p>\n</li>\n<li><p><strong>Context Preparation</strong>: The evaluation context is prepared, including user information (if available), previous password history, and any application-specific metadata that policies might need.</p>\n</li>\n<li><p><strong>Cost-based Rule Ordering</strong>: Policy rules are ordered by their estimated evaluation cost, with cheaper rules (like length checks) executed before expensive rules (like dictionary lookups or entropy calculations).</p>\n</li>\n<li><p><strong>Short-circuit Evaluation</strong>: If any policy rule fails with a hard rejection, evaluation stops immediately to avoid unnecessary computation. Warnings are accumulated but don&#39;t stop evaluation.</p>\n</li>\n<li><p><strong>Result Aggregation</strong>: All policy evaluation results are combined into a comprehensive result that includes pass/fail status, warning messages, and specific requirement violations.</p>\n</li>\n<li><p><strong>Caching Strategy</strong>: Results for expensive evaluations (like dictionary lookups) are cached based on password hash to avoid repeated computation, with appropriate cache invalidation when dictionaries are updated.</p>\n</li>\n</ol>\n<h4 id=\"integration-with-password-registration-flow\">Integration with Password Registration Flow</h4>\n<p>The policy engine integrates with the password registration flow at the validation stage, before any cryptographic operations occur:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Password Input → Policy Validation → Hash Generation → Storage\n     ↓                    ↓                 ↓           ↓\nRaw Password → PolicyEvaluationResult → PasswordHashRecord → Database</code></pre></div>\n\n<p>The integration maintains clear error handling boundaries. Policy validation failures result in user-friendly error messages that explain specific requirements, while cryptographic failures result in technical error messages appropriate for logging and debugging.</p>\n<h4 id=\"advanced-policy-features\">Advanced Policy Features</h4>\n<p><strong>Password History Integration</strong>\nAdvanced implementations can integrate with user password history to prevent password reuse:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>check_password_history(user_id, new_password, history_depth)</code></td>\n<td>user_id: str, new_password: str, history_depth: int</td>\n<td>HistoryCheckResult</td>\n<td>Verify new password against previous passwords</td>\n</tr>\n<tr>\n<td><code>store_password_history(user_id, password_hash)</code></td>\n<td>user_id: str, password_hash: str</td>\n<td>None</td>\n<td>Add password to user&#39;s history</td>\n</tr>\n<tr>\n<td><code>clean_expired_history(retention_days)</code></td>\n<td>retention_days: int</td>\n<td>int</td>\n<td>Remove old password history entries</td>\n</tr>\n</tbody></table>\n<p><strong>Entropy-based Strength Assessment</strong>\nSophisticated policies can calculate password entropy to assess true randomness rather than relying only on character composition:</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>calculate_password_entropy(password)</code></td>\n<td>password: str</td>\n<td>float</td>\n<td>Calculate estimated password entropy in bits</td>\n</tr>\n<tr>\n<td><code>assess_character_patterns(password)</code></td>\n<td>password: str</td>\n<td>PatternAnalysis</td>\n<td>Identify common patterns that reduce entropy</td>\n</tr>\n<tr>\n<td><code>estimate_crack_time(password, attack_scenario)</code></td>\n<td>password: str, attack_scenario: str</td>\n<td>TimingEstimate</td>\n<td>Estimate time to crack under different attack models</td>\n</tr>\n</tbody></table>\n<h4 id=\"common-pitfalls-in-policy-integration\">Common Pitfalls in Policy Integration</h4>\n<p>⚠️ <strong>Pitfall: Validating Passwords After Hashing</strong>\nValidating password policies after the password has already been hashed makes it impossible to analyze the actual password content. Policy validation must occur before any one-way cryptographic transformations.</p>\n<p>⚠️ <strong>Pitfall: Storing Policy Configuration in Hash Records</strong>\nEmbedding policy configuration in individual hash records creates consistency problems when policies need to be updated globally. Policy configuration should be maintained separately from individual password hashes.</p>\n<p>⚠️ <strong>Pitfall: Synchronous Dictionary Lookups in Request Path</strong>\nLoading large password dictionaries or making network calls during password validation can create performance bottlenecks. Use asynchronous loading, caching, and background updates for expensive policy operations.</p>\n<p>⚠️ <strong>Pitfall: Revealing Information Through Policy Messages</strong>\nDetailed policy violation messages can reveal information about existing passwords or system configuration to attackers. Balance helpfulness with security in error message design.</p>\n<h3 id=\"breach-monitoring-integration-with-haveibeenpwned-and-similar-services\">Breach Monitoring: Integration with HaveIBeenPwned and Similar Services</h3>\n<p>Breach monitoring extends our password hashing system with real-world threat intelligence by checking whether passwords appear in known data breaches. Think of it like adding a security alert system that monitors global threat databases and warns you when credentials in your system might be compromised, similar to how credit monitoring services alert you when your personal information appears in data breaches.</p>\n<p>The architectural challenge in breach monitoring is integrating external threat intelligence services while maintaining privacy, performance, and reliability. Users&#39; passwords should never be transmitted in plain text to external services, and the system must gracefully handle service unavailability without blocking legitimate authentication.</p>\n<h4 id=\"architecture-decision-privacy-preserving-breach-checking\">Architecture Decision: Privacy-Preserving Breach Checking</h4>\n<blockquote>\n<p><strong>Decision: Use k-Anonymity with Hash Prefixes for Breach Checking</strong></p>\n<ul>\n<li><strong>Context</strong>: Direct password submission to breach services violates privacy. Hash submission reveals password hashes to third parties. Need balance between security checking and privacy preservation.</li>\n<li><strong>Options Considered</strong>:<ol>\n<li>Submit full password hashes to breach services</li>\n<li>Use k-anonymity with hash prefixes (HaveIBeenPwned model)</li>\n<li>Download full breach databases locally</li>\n<li>Skip breach checking entirely</li>\n</ol>\n</li>\n<li><strong>Decision</strong>: Use k-anonymity with hash prefixes</li>\n<li><strong>Rationale</strong>: Provides meaningful security checking while preserving privacy. Hash prefixes (first 5 characters) create anonymity sets of thousands of hashes. No full passwords or complete hashes transmitted.</li>\n<li><strong>Consequences</strong>: Requires careful implementation of prefix matching and local verification. Adds network dependency but with privacy protection.</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Breach Checking Option</th>\n<th>Privacy Level</th>\n<th>Security Effectiveness</th>\n<th>Operational Complexity</th>\n<th>Network Dependency</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Full Hash Submission</td>\n<td>Poor</td>\n<td>Excellent</td>\n<td>Low</td>\n<td>High</td>\n</tr>\n<tr>\n<td>k-Anonymity Prefixes</td>\n<td>Excellent</td>\n<td>Very Good</td>\n<td>Medium</td>\n<td>High</td>\n</tr>\n<tr>\n<td>Local Database</td>\n<td>Excellent</td>\n<td>Good</td>\n<td>Very High</td>\n<td>Low</td>\n</tr>\n<tr>\n<td>No Breach Checking</td>\n<td>N/A</td>\n<td>Poor</td>\n<td>None</td>\n<td>None</td>\n</tr>\n</tbody></table>\n<p>The breach monitoring architecture centers around a <code>BreachMonitoringService</code> that integrates with external threat intelligence APIs while maintaining strict privacy and performance requirements.</p>\n<h4 id=\"breach-monitoring-service-architecture\">Breach Monitoring Service Architecture</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>BreachMonitoringService</code></td>\n<td>class</td>\n<td>Main service coordinating breach checking operations</td>\n</tr>\n<tr>\n<td><code>api_clients</code></td>\n<td>dict[str, BreachAPIClient]</td>\n<td>Registry of breach checking service clients</td>\n</tr>\n<tr>\n<td><code>cache_manager</code></td>\n<td>BreachCacheManager</td>\n<td>Local caching for breach check results</td>\n</tr>\n<tr>\n<td><code>privacy_manager</code></td>\n<td>PrivacyPreservingHasher</td>\n<td>Handles k-anonymity and prefix generation</td>\n</tr>\n<tr>\n<td><code>monitoring_config</code></td>\n<td>BreachMonitoringConfig</td>\n<td>Configuration for breach checking behavior</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>register_breach_service(name, client)</code></td>\n<td>name: str, client: BreachAPIClient</td>\n<td>None</td>\n<td>Register new breach checking service</td>\n</tr>\n<tr>\n<td><code>check_password_breach(password, services)</code></td>\n<td>password: str, services: list[str]</td>\n<td>BreachCheckResult</td>\n<td>Check password against specified breach services</td>\n</tr>\n<tr>\n<td><code>check_hash_breach(password_hash, services)</code></td>\n<td>password_hash: str, services: list[str]</td>\n<td>BreachCheckResult</td>\n<td>Check existing hash against breach services</td>\n</tr>\n<tr>\n<td><code>enable_continuous_monitoring(user_id)</code></td>\n<td>user_id: str</td>\n<td>None</td>\n<td>Enable ongoing breach monitoring for user</td>\n</tr>\n<tr>\n<td><code>get_breach_statistics()</code></td>\n<td>None</td>\n<td>dict</td>\n<td>Return monitoring statistics and health metrics</td>\n</tr>\n</tbody></table>\n<h4 id=\"k-anonymity-implementation\">k-Anonymity Implementation</h4>\n<p>The k-anonymity approach for privacy-preserving breach checking works by submitting only a prefix of the password hash to external services, then performing local verification of the complete hash against the returned dataset.</p>\n<p><strong>Hash Prefix Generation Process:</strong></p>\n<ol>\n<li><strong>Password Hashing</strong>: The input password is hashed using SHA-1 (the standard for breach databases) to produce a 40-character hexadecimal hash</li>\n<li><strong>Prefix Extraction</strong>: The first 5 characters of the hash are extracted as the anonymity prefix</li>\n<li><strong>API Request</strong>: Only the 5-character prefix is submitted to the breach service</li>\n<li><strong>Response Processing</strong>: The service returns all breach hashes that share the same prefix (typically 800-1000 hashes)</li>\n<li><strong>Local Verification</strong>: The complete hash is checked locally against the returned set to determine breach status</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>Step</th>\n<th>Input</th>\n<th>Process</th>\n<th>Output</th>\n<th>Privacy Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Password: &quot;password123&quot;</td>\n<td>SHA-1 Hash</td>\n<td>&quot;482c811da5d5b4bc6d497ffa98491e38&quot;</td>\n<td>Full password protected</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Full Hash</td>\n<td>Extract Prefix</td>\n<td>&quot;482c8&quot;</td>\n<td>Hash anonymized in set of ~1000</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Prefix Only</td>\n<td>API Request</td>\n<td>List of ~1000 hashes starting with &quot;482c8&quot;</td>\n<td>No individual identification possible</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Full Hash + Response</td>\n<td>Local Matching</td>\n<td>Match Found: True/False</td>\n<td>Full privacy maintained</td>\n</tr>\n</tbody></table>\n<h4 id=\"breach-api-client-interface\">Breach API Client Interface</h4>\n<p>The <code>BreachAPIClient</code> abstract base class enables integration with multiple breach checking services while maintaining consistent behavior patterns.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Parameters</th>\n<th>Returns</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>check_hash_prefix(hash_prefix)</code></td>\n<td>hash_prefix: str</td>\n<td>PrefixCheckResult</td>\n<td>Query service for hashes matching prefix</td>\n</tr>\n<tr>\n<td><code>get_service_metadata()</code></td>\n<td>None</td>\n<td>ServiceMetadata</td>\n<td>Return service capabilities and update frequency</td>\n</tr>\n<tr>\n<td><code>estimate_request_cost(hash_prefix)</code></td>\n<td>hash_prefix: str</td>\n<td>RequestCostEstimate</td>\n<td>Estimate API cost and timing for request</td>\n</tr>\n<tr>\n<td><code>validate_service_health()</code></td>\n<td>None</td>\n<td>HealthCheckResult</td>\n<td>Verify service availability and response quality</td>\n</tr>\n</tbody></table>\n<h4 id=\"haveibeenpwned-client-implementation\">HaveIBeenPwned Client Implementation</h4>\n<p>The HaveIBeenPwned service client implements the most widely-used breach checking API:</p>\n<table>\n<thead>\n<tr>\n<th>Configuration Parameter</th>\n<th>Type</th>\n<th>Default</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>api_endpoint</code></td>\n<td>str</td>\n<td>&quot;<a href=\"https://api.pwnedpasswords.com/range/\">https://api.pwnedpasswords.com/range/</a>&quot;</td>\n<td>Base URL for API requests</td>\n</tr>\n<tr>\n<td><code>request_timeout_seconds</code></td>\n<td>int</td>\n<td>5</td>\n<td>Maximum time to wait for API response</td>\n</tr>\n<tr>\n<td><code>rate_limit_requests_per_minute</code></td>\n<td>int</td>\n<td>100</td>\n<td>Maximum requests per minute to avoid throttling</td>\n</tr>\n<tr>\n<td><code>retry_attempts</code></td>\n<td>int</td>\n<td>3</td>\n<td>Number of retry attempts for failed requests</td>\n</tr>\n<tr>\n<td><code>user_agent</code></td>\n<td>str</td>\n<td>Application-specific</td>\n<td>User agent string for API requests</td>\n</tr>\n</tbody></table>\n<p>The client handles the specific response format from HaveIBeenPwned, which returns data in the format:</p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>HASH_SUFFIX:OCCURRENCE_COUNT\nHASH_SUFFIX:OCCURRENCE_COUNT\n...</code></pre></div>\n\n<p>Where HASH_SUFFIX is the remaining 35 characters of each hash that shares the requested prefix, and OCCURRENCE_COUNT is the number of times that password appeared in breach databases.</p>\n<h4 id=\"caching-strategy-for-breach-results\">Caching Strategy for Breach Results</h4>\n<p>Breach checking results are cached locally to improve performance and reduce API dependency:</p>\n<table>\n<thead>\n<tr>\n<th>Cache Type</th>\n<th>Duration</th>\n<th>Invalidation Strategy</th>\n<th>Storage Location</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Prefix Results</td>\n<td>24 hours</td>\n<td>Time-based expiration</td>\n<td>Memory + Disk</td>\n</tr>\n<tr>\n<td>Negative Results</td>\n<td>7 days</td>\n<td>Manual invalidation on breach updates</td>\n<td>Disk only</td>\n</tr>\n<tr>\n<td>Service Health</td>\n<td>1 hour</td>\n<td>Error-based invalidation</td>\n<td>Memory only</td>\n</tr>\n<tr>\n<td>Rate Limit State</td>\n<td>1 minute</td>\n<td>Rolling window reset</td>\n<td>Memory only</td>\n</tr>\n</tbody></table>\n<p>The caching system must balance performance with security effectiveness. Cached negative results (passwords not found in breaches) can be stored longer than positive results, since new breach databases are published relatively infrequently.</p>\n<h4 id=\"integration-with-password-registration-and-verification\">Integration with Password Registration and Verification</h4>\n<p>Breach monitoring integrates with both password registration (preventing use of known breached passwords) and ongoing monitoring (alerting users when their existing passwords appear in new breaches).</p>\n<p><strong>Registration-Time Breach Checking:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Password Input → Policy Validation → Breach Check → Hash Generation → Storage\n     ↓                    ↓              ↓              ↓           ↓\nRaw Password → PolicyResult → BreachResult → HashRecord → Database</code></pre></div>\n\n<p><strong>Ongoing Breach Monitoring:</strong></p>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>Periodic Job → Retrieve User Hashes → Check Against New Breaches → Alert Users\n     ↓                ↓                        ↓                      ↓\nScheduler → Hash Database → Breach Services → Notification System</code></pre></div>\n\n<h4 id=\"asynchronous-monitoring-implementation\">Asynchronous Monitoring Implementation</h4>\n<p>Continuous breach monitoring requires background processing that doesn&#39;t block user authentication:</p>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Responsibility</th>\n<th>Execution Pattern</th>\n<th>Failure Handling</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>BreachMonitoringScheduler</code></td>\n<td>Schedule periodic breach checks</td>\n<td>Cron-like scheduling</td>\n<td>Exponential backoff on failures</td>\n</tr>\n<tr>\n<td><code>BatchBreachChecker</code></td>\n<td>Process multiple hashes efficiently</td>\n<td>Batch API requests</td>\n<td>Individual hash retry on batch failure</td>\n</tr>\n<tr>\n<td><code>NotificationManager</code></td>\n<td>Alert users of breached passwords</td>\n<td>Async message queuing</td>\n<td>Dead letter queue for failed notifications</td>\n</tr>\n<tr>\n<td><code>MonitoringMetrics</code></td>\n<td>Track monitoring effectiveness</td>\n<td>Real-time metrics collection</td>\n<td>Graceful degradation on metrics failure</td>\n</tr>\n</tbody></table>\n<h4 id=\"privacy-and-security-considerations\">Privacy and Security Considerations</h4>\n<p>Breach monitoring introduces several privacy and security considerations that must be carefully managed:</p>\n<p><strong>Data Minimization</strong>: Only hash prefixes are transmitted to external services, and full hashes are processed locally. No plain text passwords ever leave the system.</p>\n<p><strong>Service Provider Trust</strong>: While hash prefixes provide k-anonymity, there&#39;s still trust required in external breach checking services. The system should support multiple providers and allow organizations to choose their preferred services.</p>\n<p><strong>Network Security</strong>: All communications with breach checking services must use TLS encryption and certificate validation to prevent man-in-the-middle attacks.</p>\n<p><strong>Rate Limiting and Abuse Prevention</strong>: Breach checking services have rate limits that must be respected to maintain service availability. The system implements request queuing and backoff strategies.</p>\n<h4 id=\"advanced-monitoring-features\">Advanced Monitoring Features</h4>\n<p><strong>Breach Severity Assessment</strong>: Not all breaches are equal in terms of risk. The system can evaluate breach severity based on factors like the quality of original hashing, breach size, and data sensitivity.</p>\n<table>\n<thead>\n<tr>\n<th>Severity Factor</th>\n<th>Weight</th>\n<th>Assessment Criteria</th>\n<th>Impact on User Notification</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Original Hash Quality</td>\n<td>0.4</td>\n<td>MD5/SHA-1 (high risk) vs bcrypt/Argon2 (lower risk)</td>\n<td>Immediate vs delayed notification</td>\n</tr>\n<tr>\n<td>Breach Size</td>\n<td>0.3</td>\n<td>Number of affected accounts</td>\n<td>Priority level in notification queue</td>\n</tr>\n<tr>\n<td>Data Sensitivity</td>\n<td>0.2</td>\n<td>Financial vs social media accounts</td>\n<td>Notification urgency and content</td>\n</tr>\n<tr>\n<td>Breach Recency</td>\n<td>0.1</td>\n<td>How recently breach was discovered</td>\n<td>Notification timing</td>\n</tr>\n</tbody></table>\n<p><strong>User Response Automation</strong>: When breached passwords are detected, the system can automatically trigger security responses:</p>\n<table>\n<thead>\n<tr>\n<th>Response Type</th>\n<th>Trigger Condition</th>\n<th>Automation Level</th>\n<th>User Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Force Password Reset</td>\n<td>High severity breach</td>\n<td>Automatic</td>\n<td>Immediate login block</td>\n</tr>\n<tr>\n<td>Recommend Password Change</td>\n<td>Medium severity breach</td>\n<td>User choice</td>\n<td>Dashboard notification</td>\n</tr>\n<tr>\n<td>Security Audit Log</td>\n<td>Any breach detection</td>\n<td>Automatic</td>\n<td>Background logging</td>\n</tr>\n<tr>\n<td>Account Monitoring</td>\n<td>Repeated breach exposure</td>\n<td>Enhanced</td>\n<td>Additional security checks</td>\n</tr>\n</tbody></table>\n<h4 id=\"common-pitfalls-in-breach-monitoring\">Common Pitfalls in Breach Monitoring</h4>\n<p>⚠️ <strong>Pitfall: Submitting Full Hashes to External Services</strong>\nTransmitting complete password hashes to breach checking services creates privacy risks and potential attack vectors. Always use k-anonymity techniques with hash prefixes to protect user privacy while maintaining security effectiveness.</p>\n<p>⚠️ <strong>Pitfall: Blocking Authentication on Breach Service Failures</strong>\nMaking breach checking a hard requirement for authentication can create denial-of-service vulnerabilities when external services are unavailable. Implement graceful degradation where breach checking failures log warnings but don&#39;t prevent legitimate authentication.</p>\n<p>⚠️ <strong>Pitfall: Ignoring Rate Limits and Service Terms</strong>\nBreach checking services have usage limits and terms of service that must be respected. Implement proper rate limiting, request queuing, and exponential backoff to avoid service disruption and potential API key revocation.</p>\n<p>⚠️ <strong>Pitfall: Storing Breach Results Without Expiration</strong>\nCached breach checking results can become stale as new breach databases are published. Implement appropriate cache expiration policies and invalidation strategies to ensure breach checking remains effective over time.</p>\n<p>⚠️ <strong>Pitfall: Revealing Breach Status in Error Messages</strong>\nExposing whether specific passwords have been breached in API error messages or logs can reveal sensitive information. Design error handling and logging to protect breach status information while still providing useful debugging information.</p>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This implementation guidance provides the foundational code structures and integration patterns needed to extend the password hashing system with policy validation and breach monitoring capabilities.</p>\n<h4 id=\"technology-recommendations\">Technology Recommendations</h4>\n<table>\n<thead>\n<tr>\n<th>Component</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n<th>Production Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HTTP Client</td>\n<td><code>requests</code> library</td>\n<td><code>aiohttp</code> with async/await</td>\n<td>Connection pooling, timeout handling</td>\n</tr>\n<tr>\n<td>Caching</td>\n<td>In-memory dictionary</td>\n<td><code>Redis</code> with expiration</td>\n<td>Distributed caching, persistence</td>\n</tr>\n<tr>\n<td>Background Jobs</td>\n<td><code>threading.Timer</code></td>\n<td><code>Celery</code> with Redis broker</td>\n<td>Scalability, failure recovery</td>\n</tr>\n<tr>\n<td>Configuration</td>\n<td>JSON/YAML files</td>\n<td><code>pydantic</code> with environment variables</td>\n<td>Validation, type safety</td>\n</tr>\n<tr>\n<td>Logging</td>\n<td>Python <code>logging</code> module</td>\n<td>Structured logging with <code>structlog</code></td>\n<td>Log aggregation, correlation IDs</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-file-structure\">Recommended File Structure</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>password_hashing/\n  extensions/\n    __init__.py\n    policy/\n      __init__.py\n      engine.py              ← PasswordPolicyEngine\n      rules/\n        __init__.py\n        base.py             ← PolicyRule abstract base\n        length.py           ← LengthRequirementsPolicy  \n        composition.py      ← CharacterCompositionPolicy\n        dictionary.py       ← DictionaryAttackPreventionPolicy\n        entropy.py          ← EntropyBasedStrengthPolicy\n      integration.py        ← Integration with main hashing system\n    breach_monitoring/\n      __init__.py\n      service.py           ← BreachMonitoringService\n      clients/\n        __init__.py\n        base.py            ← BreachAPIClient abstract base\n        haveibeenpwned.py  ← HaveIBeenPwned client implementation\n        custom.py          ← Custom breach service clients\n      cache.py             ← BreachCacheManager\n      privacy.py           ← Privacy-preserving hash operations\n      monitoring.py        ← Continuous monitoring and alerting\n  tests/\n    extensions/\n      test_policy_engine.py\n      test_breach_monitoring.py\n      test_integration.py</code></pre></div>\n\n<h4 id=\"password-policy-engine-infrastructure-code\">Password Policy Engine Infrastructure Code</h4>\n<p>Complete implementation of the policy validation framework:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Password Policy Engine - Complete Infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides extensible framework for password validation rules.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span><span style=\"color:#E1E4E8\">, abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Any, Optional, Set</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> enum </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Enum</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> re</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timedelta</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PolicySeverity</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">Enum</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Severity levels for policy violations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    INFO</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"info\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    WARNING</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"warning\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ERROR</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"error\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    CRITICAL</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"critical\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> RuleEvaluationResult</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Result from evaluating a single policy rule.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rule_name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    passed: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    severity: PolicySeverity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    message: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    details: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    evaluation_time_ms: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span><span style=\"color:#E1E4E8\">  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PolicyEvaluationResult</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Complete result from policy engine evaluation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    overall_passed: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rule_results: List[RuleEvaluationResult]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    warnings: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    errors: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    evaluation_metadata: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PolicyRule</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Abstract base class for all password policy rules.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, config: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.config </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> config</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.validate_config()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, context: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> RuleEvaluationResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate password against this rule.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_requirements</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return human-readable requirements description.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_configuration_schema</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return JSON schema for configuration validation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_config</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Validate configuration against schema.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Implementation would use jsonschema library</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> estimate_evaluation_cost</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">float</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return relative computational cost (1.0 = baseline).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> 1.0</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PasswordPolicyEngine</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Main engine for coordinating password policy evaluation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.policy_registry: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">type</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.active_policies: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.policy_configurations: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.policy_instances: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, PolicyRule] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register_policy</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, rule_class: </span><span style=\"color:#79B8FF\">type</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register a new policy rule class.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#79B8FF\"> issubclass</span><span style=\"color:#E1E4E8\">(rule_class, PolicyRule):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Policy </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\"> must inherit from PolicyRule\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.policy_registry[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> rule_class</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> configure_policy</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#F97583\">**</span><span style=\"color:#E1E4E8\">params) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Configure parameters for a specific policy.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.policy_registry:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unknown policy: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.policy_configurations[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> params</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Recreate instance with new configuration</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.policy_instances:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.policy_instances[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.policy_registry[name](params)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> enable_policies</span><span style=\"color:#E1E4E8\">(self, policy_names: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Enable specified policies for evaluation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> policy_names:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.policy_registry:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Unknown policy: </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.active_policies </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> policy_names</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Create policy instances</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> name </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> policy_names:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            config </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.policy_configurations.get(name, {})</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.policy_instances[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.policy_registry[name](config)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> evaluate_password</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, context: Optional[Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> PolicyEvaluationResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Evaluate password against all active policies.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> context </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            context </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        rule_results </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        warnings </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        errors </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        overall_passed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Sort policies by evaluation cost (cheapest first)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        sorted_policies </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> sorted</span><span style=\"color:#E1E4E8\">(</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.active_policies,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            key</span><span style=\"color:#F97583\">=lambda</span><span style=\"color:#E1E4E8\"> name: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.policy_instances[name].estimate_evaluation_cost()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> datetime.now()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> policy_name </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> sorted_policies:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            policy </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.policy_instances[policy_name]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> policy.evaluate(password, context)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                rule_results.append(result)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> result.passed:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> result.severity </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> [PolicySeverity.</span><span style=\"color:#79B8FF\">ERROR</span><span style=\"color:#E1E4E8\">, PolicySeverity.</span><span style=\"color:#79B8FF\">CRITICAL</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        errors.append(result.message)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        overall_passed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        warnings.append(result.message)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Policy evaluation should never crash the system</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                error_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> RuleEvaluationResult(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    rule_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">policy_name,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    passed</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    severity</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">PolicySeverity.</span><span style=\"color:#79B8FF\">CRITICAL</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    message</span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Policy evaluation failed: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    details</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span><span style=\"color:#9ECBFF\">\"exception_type\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">type</span><span style=\"color:#E1E4E8\">(e).</span><span style=\"color:#79B8FF\">__name__</span><span style=\"color:#E1E4E8\">},</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                    evaluation_time_ms</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                rule_results.append(error_result)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                errors.append(error_result.message)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                overall_passed </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (datetime.now() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time).total_seconds() </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> PolicyEvaluationResult(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            overall_passed</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">overall_passed,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            rule_results</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">rule_results,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            warnings</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">warnings,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            errors</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">errors,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            evaluation_metadata</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"total_evaluation_time_ms\"</span><span style=\"color:#E1E4E8\">: total_time,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"policies_evaluated\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">len</span><span style=\"color:#E1E4E8\">(sorted_policies),</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">                \"context_provided\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">(context)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span></code></pre></div>\n\n<h4 id=\"breach-monitoring-service-infrastructure-code\">Breach Monitoring Service Infrastructure Code</h4>\n<p>Complete implementation of the breach monitoring framework:</p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Breach Monitoring Service - Complete Infrastructure</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Provides privacy-preserving password breach checking capabilities.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> hashlib</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> asyncio</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> typing </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> Dict, List, Optional, Set, Tuple</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> dataclasses </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> datetime </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> datetime, timedelta</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> abc </span><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> ABC</span><span style=\"color:#E1E4E8\">, abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> requests</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">from</span><span style=\"color:#E1E4E8\"> urllib.parse </span><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> urljoin</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BreachCheckResult</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Result from checking password against breach databases.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    is_breached: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    breach_count: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    services_checked: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    check_timestamp: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    privacy_preserved: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    cache_hit: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    response_time_ms: </span><span style=\"color:#79B8FF\">float</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#B392F0\">@dataclass</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ServiceMetadata</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Metadata about a breach checking service.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    service_name: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    last_updated: datetime</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    database_size_estimate: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    api_version: </span><span style=\"color:#79B8FF\">str</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    rate_limit_per_minute: </span><span style=\"color:#79B8FF\">int</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    supports_batch: </span><span style=\"color:#79B8FF\">bool</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BreachAPIClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">ABC</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Abstract base class for breach checking service clients.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> check_hash_prefix</span><span style=\"color:#E1E4E8\">(self, hash_prefix: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Tuple[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check hash prefix against service. Returns (hash_suffixes, breach_counts).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_service_metadata</span><span style=\"color:#E1E4E8\">(self) -> ServiceMetadata:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return metadata about this service.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    @abstractmethod</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_service_health</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if service is available and responding correctly.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> HaveIBeenPwnedClient</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">BreachAPIClient</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Client for HaveIBeenPwned Pwned Passwords API.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 api_endpoint: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"https://api.pwnedpasswords.com/range/\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 request_timeout: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 rate_limit_per_minute: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 user_agent: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"PasswordHashingSystem/1.0\"</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.api_endpoint </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> api_endpoint</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.request_timeout </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> request_timeout</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.rate_limit_per_minute </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> rate_limit_per_minute</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.user_agent </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> user_agent</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.last_request_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0.0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> check_hash_prefix</span><span style=\"color:#E1E4E8\">(self, hash_prefix: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Tuple[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check 5-character hash prefix against HaveIBeenPwned.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(hash_prefix) </span><span style=\"color:#F97583\">!=</span><span style=\"color:#79B8FF\"> 5</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> ValueError</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Hash prefix must be exactly 5 characters\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Enforce rate limiting</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">._enforce_rate_limit()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        url </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> urljoin(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.api_endpoint, hash_prefix.upper())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        headers </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {</span><span style=\"color:#9ECBFF\">\"User-Agent\"</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.user_agent}</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            response </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> requests.get(url, </span><span style=\"color:#FFAB70\">headers</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">headers, </span><span style=\"color:#FFAB70\">timeout</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.request_timeout)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            response.raise_for_status()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Parse response format: SUFFIX:COUNT\\nSUFFIX:COUNT\\n...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            hash_suffixes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            breach_counts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            for</span><span style=\"color:#E1E4E8\"> line </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> response.text.strip().split(</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#79B8FF\">\\n</span><span style=\"color:#9ECBFF\">'</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#9ECBFF\"> ':'</span><span style=\"color:#F97583\"> in</span><span style=\"color:#E1E4E8\"> line:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    suffix, count_str </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> line.split(</span><span style=\"color:#9ECBFF\">':'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    hash_suffixes.append(suffix)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    breach_counts.append(</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">(count_str))</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> hash_suffixes, breach_counts</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\"> requests.RequestException </span><span style=\"color:#F97583\">as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            raise</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"HaveIBeenPwned API request failed: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        finally</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.last_request_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_service_metadata</span><span style=\"color:#E1E4E8\">(self) -> ServiceMetadata:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Return HaveIBeenPwned service metadata.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> ServiceMetadata(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            service_name</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"HaveIBeenPwned\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            last_updated</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">datetime.now() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> timedelta(</span><span style=\"color:#FFAB70\">days</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">),  </span><span style=\"color:#6A737D\"># Approximate</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            database_size_estimate</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">847000000</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\"># Approximate as of 2024</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            api_version</span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\">\"3\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            rate_limit_per_minute</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.rate_limit_per_minute,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            supports_batch</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> validate_service_health</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Test service health with known hash prefix.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">            # Use known hash prefix that should always return results</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            test_prefix </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> \"5e884\"</span><span style=\"color:#6A737D\">  # Prefix of SHA-1(\"hello\")</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            suffixes, counts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> asyncio.run(</span><span style=\"color:#79B8FF\">self</span><span style=\"color:#E1E4E8\">.check_hash_prefix(test_prefix))</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> len</span><span style=\"color:#E1E4E8\">(suffixes) </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        except</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> _enforce_rate_limit</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Enforce rate limiting between requests.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        min_interval </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 60.0</span><span style=\"color:#F97583\"> /</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.rate_limit_per_minute</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        time_since_last </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.last_request_time</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> time_since_last </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> min_interval:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            await</span><span style=\"color:#E1E4E8\"> asyncio.sleep(min_interval </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> time_since_last)</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BreachCacheManager</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Manages caching of breach checking results.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 prefix_cache_ttl_hours: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 24</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                 negative_cache_ttl_days: </span><span style=\"color:#79B8FF\">int</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 7</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.prefix_cache: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Tuple[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">], datetime]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.negative_cache: Set[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> set</span><span style=\"color:#E1E4E8\">()  </span><span style=\"color:#6A737D\"># Hashes known to not be breached</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.prefix_cache_ttl </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timedelta(</span><span style=\"color:#FFAB70\">hours</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">prefix_cache_ttl_hours)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.negative_cache_ttl </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> timedelta(</span><span style=\"color:#FFAB70\">days</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">negative_cache_ttl_days)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_prefix_result</span><span style=\"color:#E1E4E8\">(self, hash_prefix: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> Optional[Tuple[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]]]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Get cached result for hash prefix.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> hash_prefix </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.prefix_cache:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            suffixes, counts, timestamp </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.prefix_cache[hash_prefix]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> datetime.now() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> timestamp </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.prefix_cache_ttl:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                return</span><span style=\"color:#E1E4E8\"> suffixes, counts</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Cache expired</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                del</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.prefix_cache[hash_prefix]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#79B8FF\"> None</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> cache_prefix_result</span><span style=\"color:#E1E4E8\">(self, hash_prefix: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, suffixes: List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">], counts: List[</span><span style=\"color:#79B8FF\">int</span><span style=\"color:#E1E4E8\">]) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Cache result for hash prefix.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.prefix_cache[hash_prefix] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> (suffixes, counts, datetime.now())</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> is_known_clean</span><span style=\"color:#E1E4E8\">(self, full_hash: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check if hash is in negative cache (known not breached).\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> full_hash </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.negative_cache</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> mark_clean</span><span style=\"color:#E1E4E8\">(self, full_hash: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Add hash to negative cache.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.negative_cache.add(full_hash)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> clear_expired_cache</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Remove expired cache entries.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        now </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> datetime.now()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Clear expired prefix cache</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        expired_prefixes </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            prefix </span><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> prefix, (_, _, timestamp) </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.prefix_cache.items()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> now </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> timestamp </span><span style=\"color:#F97583\">>=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.prefix_cache_ttl</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        ]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> prefix </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> expired_prefixes:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            del</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.prefix_cache[prefix]</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> BreachMonitoringService</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Main service for coordinating breach checking operations.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.api_clients: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, BreachAPIClient] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> {}</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.cache_manager </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BreachCacheManager()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.default_services </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> register_breach_service</span><span style=\"color:#E1E4E8\">(self, name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, client: BreachAPIClient) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register a new breach checking service client.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.api_clients[name] </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> client</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> check_password_breach</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                  services: Optional[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> BreachCheckResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check password against breach databases using k-anonymity.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> services </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            services </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.default_services</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Generate SHA-1 hash (standard for breach databases)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        password_hash </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hashlib.sha1(password.encode(</span><span style=\"color:#9ECBFF\">'utf-8'</span><span style=\"color:#E1E4E8\">)).hexdigest().upper()</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#F97583\"> await</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.check_hash_breach(password_hash, services)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> check_hash_breach</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               password_hash: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                               services: Optional[List[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">]] </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">) -> BreachCheckResult:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Check existing hash against breach databases.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> services </span><span style=\"color:#F97583\">is</span><span style=\"color:#79B8FF\"> None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            services </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.default_services</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Check negative cache first</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.cache_manager.is_known_clean(password_hash):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            return</span><span style=\"color:#E1E4E8\"> BreachCheckResult(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                is_breached</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">False</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                breach_count</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                services_checked</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">services,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                check_timestamp</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">datetime.now(),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                privacy_preserved</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                cache_hit</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">                response_time_ms</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">(time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            )</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Extract 5-character prefix for k-anonymity</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        hash_prefix </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> password_hash[:</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        hash_suffix </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> password_hash[</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">:]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        is_breached </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        total_breach_count </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        services_checked </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> []</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        cache_hit </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> False</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        for</span><span style=\"color:#E1E4E8\"> service_name </span><span style=\"color:#F97583\">in</span><span style=\"color:#E1E4E8\"> services:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            if</span><span style=\"color:#E1E4E8\"> service_name </span><span style=\"color:#F97583\">not</span><span style=\"color:#F97583\"> in</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.api_clients:</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                continue</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            client </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.api_clients[service_name]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">            </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            try</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Check cache first</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                cached_result </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> self</span><span style=\"color:#E1E4E8\">.cache_manager.get_prefix_result(hash_prefix)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                if</span><span style=\"color:#E1E4E8\"> cached_result:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    suffixes, counts </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> cached_result</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    cache_hit </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                else</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                    # Make API request</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                    suffixes, counts </span><span style=\"color:#F97583\">=</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> client.check_hash_prefix(hash_prefix)</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                    self</span><span style=\"color:#E1E4E8\">.cache_manager.cache_prefix_result(hash_prefix, suffixes, counts)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Check if our hash suffix is in the results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                for</span><span style=\"color:#E1E4E8\"> suffix, count </span><span style=\"color:#F97583\">in</span><span style=\"color:#79B8FF\"> zip</span><span style=\"color:#E1E4E8\">(suffixes, counts):</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                    if</span><span style=\"color:#E1E4E8\"> suffix.upper() </span><span style=\"color:#F97583\">==</span><span style=\"color:#E1E4E8\"> hash_suffix:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        is_breached </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> True</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                        total_breach_count </span><span style=\"color:#F97583\">+=</span><span style=\"color:#E1E4E8\"> count</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">                        break</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                services_checked.append(service_name)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">            except</span><span style=\"color:#79B8FF\"> Exception</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> e:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">                # Log error but continue with other services</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">                print</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">f</span><span style=\"color:#9ECBFF\">\"Breach check failed for service </span><span style=\"color:#79B8FF\">{</span><span style=\"color:#E1E4E8\">service_name</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">: </span><span style=\"color:#79B8FF\">{str</span><span style=\"color:#E1E4E8\">(e)</span><span style=\"color:#79B8FF\">}</span><span style=\"color:#9ECBFF\">\"</span><span style=\"color:#E1E4E8\">)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Cache negative results</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#F97583\"> not</span><span style=\"color:#E1E4E8\"> is_breached:</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">            self</span><span style=\"color:#E1E4E8\">.cache_manager.mark_clean(password_hash)</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        return</span><span style=\"color:#E1E4E8\"> BreachCheckResult(</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            is_breached</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">is_breached,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            breach_count</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">total_breach_count,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            services_checked</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">services_checked,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            check_timestamp</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">datetime.now(),</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            privacy_preserved</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">True</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            cache_hit</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">cache_hit,</span></span>\n<span class=\"line\"><span style=\"color:#FFAB70\">            response_time_ms</span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\">(time.time() </span><span style=\"color:#F97583\">-</span><span style=\"color:#E1E4E8\"> start_time) </span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\"> 1000</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        )</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-policy-rule-implementation\">Core Logic Skeleton: Policy Rule Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> LengthRequirementsPolicy</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#B392F0\">PolicyRule</span><span style=\"color:#E1E4E8\">):</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Validates password meets length requirements.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> evaluate</span><span style=\"color:#E1E4E8\">(self, password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, context: Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]) -> RuleEvaluationResult:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        start_time </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> time.time()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Extract configuration parameters (minimum_length, maximum_length)</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Calculate password length considering Unicode encoding</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Check against minimum length requirement</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Check against maximum length requirement  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Generate appropriate error messages for violations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 6: Return RuleEvaluationResult with timing information</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use len(password.encode('utf-8')) for byte length</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Consider both character count and byte count depending on requirements</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_requirements</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Return human-readable description of length requirements</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Include both minimum and maximum in description</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Specify whether requirement is characters or bytes</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> get_configuration_schema</span><span style=\"color:#E1E4E8\">(self) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Return JSON schema defining valid configuration</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Include type constraints and value ranges</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Mark required vs optional parameters</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"core-logic-skeleton-integration-layer\">Core Logic Skeleton: Integration Layer</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> PasswordServiceWithExtensions</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Enhanced password service with policy and breach checking.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#79B8FF\"> __init__</span><span style=\"color:#E1E4E8\">(self, hasher: ModernPasswordHasher):</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.hasher </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> hasher</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.policy_engine </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> PasswordPolicyEngine()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">.breach_monitor </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> BreachMonitoringService()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._setup_default_policies()</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">        self</span><span style=\"color:#E1E4E8\">._setup_default_breach_services()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    async</span><span style=\"color:#F97583\"> def</span><span style=\"color:#B392F0\"> register_password_with_validation</span><span style=\"color:#E1E4E8\">(self, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                              user_id: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                              password: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">                                              enable_breach_check: </span><span style=\"color:#79B8FF\">bool</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> True</span><span style=\"color:#E1E4E8\">) -> Dict[</span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, Any]:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Register password with full policy and breach validation.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Run password through policy validation</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: If breach checking enabled, check against breach databases</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: If all validations pass, generate hash using existing hasher</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Store hash record and validation metadata</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Return comprehensive result with all validation details</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Use asyncio.gather() to run breach check in parallel with other operations</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # Hint: Aggregate all validation results into single response structure</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _setup_default_policies</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Configure standard password policies.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Register length requirements policy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Register character composition policy  </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Register dictionary attack prevention policy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Configure reasonable defaults for each policy</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 5: Enable all registered policies</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> _setup_default_breach_services</span><span style=\"color:#E1E4E8\">(self) -> </span><span style=\"color:#79B8FF\">None</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"Configure breach monitoring services.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 1: Register HaveIBeenPwned client</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 2: Configure rate limiting and caching</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 3: Set as default service for breach checking</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">        # </span><span style=\"color:#F97583\">TODO</span><span style=\"color:#6A737D\"> 4: Initialize background monitoring if configured</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        pass</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoint\">Milestone Checkpoint</h4>\n<p>After implementing the extensions framework:</p>\n<p><strong>Policy Engine Validation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -m</span><span style=\"color:#9ECBFF\"> pytest</span><span style=\"color:#9ECBFF\"> tests/extensions/test_policy_engine.py</span><span style=\"color:#79B8FF\"> -v</span></span></code></pre></div>\n\n<p>Expected output should show:</p>\n<ul>\n<li>All policy rules evaluate correctly with various password inputs</li>\n<li>Configuration validation catches invalid parameters</li>\n<li>Policy engine handles rule failures gracefully</li>\n<li>Performance is acceptable for typical password validation flows</li>\n</ul>\n<p><strong>Breach Monitoring Validation:</strong></p>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">bash</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#B392F0\">python</span><span style=\"color:#79B8FF\"> -c</span><span style=\"color:#9ECBFF\"> \"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">import asyncio</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from extensions.breach_monitoring.service import BreachMonitoringService</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">from extensions.breach_monitoring.clients.haveibeenpwned import HaveIBeenPwnedClient</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">async def test_breach_check():</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    service = BreachMonitoringService()</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    service.register_breach_service('hibp', HaveIBeenPwnedClient())</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    # Test known breached password</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    result = await service.check_password_breach('password123', ['hibp'])</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    print(f'Breached: {result.is_breached}, Count: {result.breach_count}')</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    # Test likely clean password  </span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    result = await service.check_password_breach('MyVeryUniquePassword2024!', ['hibp'])</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    print(f'Breached: {result.is_breached}, Privacy preserved: {result.privacy_preserved}')</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">asyncio.run(test_breach_check())</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"</span></span></code></pre></div>\n\n<p>Expected behavior:</p>\n<ul>\n<li>Known weak passwords return <code>is_breached=True</code> with breach count</li>\n<li>Strong unique passwords return <code>is_breached=False</code> </li>\n<li>All requests preserve privacy using k-anonymity</li>\n<li>Caching improves performance on subsequent requests</li>\n<li>Service gracefully handles API failures and rate limiting</li>\n</ul>\n<h4 id=\"debugging-tips\">Debugging Tips</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Likely Cause</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Policy validation always fails</td>\n<td>Configuration not loaded correctly</td>\n<td>Check policy_configurations dict</td>\n<td>Verify config loading and policy registration order</td>\n</tr>\n<tr>\n<td>Breach checking times out</td>\n<td>Rate limiting or network issues</td>\n<td>Check request timing and API limits</td>\n<td>Implement proper rate limiting and timeout handling</td>\n</tr>\n<tr>\n<td>Cache not improving performance</td>\n<td>Cache keys not matching properly</td>\n<td>Log cache hits/misses</td>\n<td>Ensure consistent hash formatting and key generation</td>\n</tr>\n<tr>\n<td>Privacy concerns with breach checking</td>\n<td>Full hashes being transmitted</td>\n<td>Review API client implementation</td>\n<td>Verify only 5-character prefixes are sent to external services</td>\n</tr>\n<tr>\n<td>Background monitoring consuming too much CPU</td>\n<td>Inefficient batch processing</td>\n<td>Profile monitoring job performance</td>\n<td>Implement proper batching and sleep intervals</td>\n</tr>\n</tbody></table>\n<h2 id=\"glossary\">Glossary</h2>\n<blockquote>\n<p><strong>Milestone(s):</strong> All milestones (cryptographic and security terminology is essential across all implementation phases from basic salt/hash verification through key stretching validation to modern algorithm integration)</p>\n</blockquote>\n<h3 id=\"mental-model-the-technical-reference-library\">Mental Model: The Technical Reference Library</h3>\n<p>Think of this glossary like a specialized technical reference library in a cryptography research institute. Just as researchers need precise definitions for mathematical concepts, security properties, and algorithmic terminology to communicate effectively and avoid dangerous misunderstandings, developers implementing password hashing systems need exact definitions of cryptographic terms, algorithm names, and security concepts. Each term in this library has been carefully defined with its specific meaning in the context of password security, preventing the kind of ambiguous interpretations that lead to security vulnerabilities.</p>\n<p>The library is organized into sections - cryptographic algorithms, security properties, attack techniques, and implementation concepts - allowing developers to quickly locate the precise meaning of terms they encounter while building secure password storage systems. Understanding these definitions is crucial because in cryptography, small misunderstandings about terminology often lead to implementation mistakes that completely compromise security.</p>\n<h3 id=\"cryptographic-algorithms-and-standards\">Cryptographic Algorithms and Standards</h3>\n<p>The following table defines the specific cryptographic algorithms and standards referenced throughout this password hashing system design:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Context in Password Hashing</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>SHA-256</strong></td>\n<td>Secure Hash Algorithm producing 256-bit digest from arbitrary input data using cryptographic one-way function</td>\n<td>Used in Milestone 1 for basic password hashing with salt, providing collision resistance and preimage resistance</td>\n</tr>\n<tr>\n<td><strong>PBKDF2</strong></td>\n<td>Password-Based Key Derivation Function 2, applying iterative HMAC to derive keys from passwords with configurable cost</td>\n<td>Core algorithm in Milestone 2 for key stretching, using HMAC-SHA256 with minimum 100,000 iterations</td>\n</tr>\n<tr>\n<td><strong>HMAC</strong></td>\n<td>Hash-based Message Authentication Code combining cryptographic hash with secret key for integrity and authenticity</td>\n<td>Internal primitive within PBKDF2 implementation, using SHA-256 as underlying hash function</td>\n</tr>\n<tr>\n<td><strong>bcrypt</strong></td>\n<td>Blowfish-based password hashing algorithm with built-in salt generation and adaptive cost factor</td>\n<td>Primary modern algorithm in Milestone 3, with minimum cost factor 12 for current hardware capabilities</td>\n</tr>\n<tr>\n<td><strong>Argon2</strong></td>\n<td>Memory-hard password hashing algorithm designed to resist GPU and ASIC attacks through high memory usage</td>\n<td>Advanced modern algorithm option in Milestone 3, specifically Argon2id variant balancing side-channel resistance</td>\n</tr>\n<tr>\n<td><strong>scrypt</strong></td>\n<td>Memory-hard key derivation function using sequential memory access patterns to increase attack cost</td>\n<td>Alternative modern algorithm mentioned for comparison, though not implemented in core milestones</td>\n</tr>\n<tr>\n<td><strong>PBKDF2-HMAC-SHA256</strong></td>\n<td>Specific PBKDF2 variant using HMAC with SHA-256 as pseudorandom function</td>\n<td>Exact specification used in Milestone 2 implementation</td>\n</tr>\n<tr>\n<td><strong>Argon2id</strong></td>\n<td>Argon2 variant combining data-independent and data-dependent memory access for balanced security</td>\n<td>Recommended Argon2 variant preventing both timing attacks and memory reduction attacks</td>\n</tr>\n<tr>\n<td><strong>Base64</strong></td>\n<td>Binary-to-text encoding representing binary data using 64-character alphabet</td>\n<td>Used for encoding salt and hash values in string representations</td>\n</tr>\n<tr>\n<td><strong>Hexadecimal</strong></td>\n<td>Base-16 encoding representing binary data using digits 0-9 and letters A-F</td>\n<td>Alternative encoding for displaying binary hash and salt values</td>\n</tr>\n</tbody></table>\n<h3 id=\"security-properties-and-concepts\">Security Properties and Concepts</h3>\n<p>Security properties define the mathematical and cryptographic guarantees that password hashing algorithms must provide to protect against various attack techniques:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Importance for Password Security</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>cryptographic security</strong></td>\n<td>Protection using mathematical algorithms and randomness with computational hardness assumptions</td>\n<td>Foundation ensuring password hashes cannot be reversed through mathematical analysis</td>\n</tr>\n<tr>\n<td><strong>preimage resistance</strong></td>\n<td>Cryptographic property making it computationally infeasible to find input producing specific hash output</td>\n<td>Prevents attackers from working backward from stolen hash to discover original password</td>\n</tr>\n<tr>\n<td><strong>collision resistance</strong></td>\n<td>Cryptographic property making it computationally infeasible to find two different inputs producing same hash</td>\n<td>Prevents attackers from finding alternative passwords that hash to same value</td>\n</tr>\n<tr>\n<td><strong>one-way function</strong></td>\n<td>Mathematical function easy to compute forward but computationally infeasible to reverse</td>\n<td>Fundamental property ensuring hashed passwords cannot be mathematically inverted</td>\n</tr>\n<tr>\n<td><strong>entropy</strong></td>\n<td>Measure of randomness or unpredictability in data, typically expressed in bits</td>\n<td>Critical for salt generation - insufficient entropy makes salt values predictable</td>\n</tr>\n<tr>\n<td><strong>cryptographic randomness</strong></td>\n<td>Mathematically unpredictable value generation using entropy sources and cryptographic algorithms</td>\n<td>Required for generating unique salts that resist statistical analysis and prediction</td>\n</tr>\n<tr>\n<td><strong>side-channel resistance</strong></td>\n<td>Protection against information leakage through execution patterns, timing, or resource usage</td>\n<td>Essential for preventing timing attacks during password verification comparisons</td>\n</tr>\n<tr>\n<td><strong>computational hardness</strong></td>\n<td>Mathematical assumption that certain problems require significant computational resources to solve</td>\n<td>Basis for security claims - breaking hash requires more computation than attacker can afford</td>\n</tr>\n<tr>\n<td><strong>perfect forward secrecy</strong></td>\n<td>Security property ensuring compromise of long-term keys doesn&#39;t reveal past session data</td>\n<td>Not directly applicable to password hashing but influences key derivation design</td>\n</tr>\n</tbody></table>\n<h3 id=\"attack-techniques-and-vulnerabilities\">Attack Techniques and Vulnerabilities</h3>\n<p>Understanding attack techniques helps developers recognize what their password hashing implementation must defend against:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>How Password Hashing Defends</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>rainbow table</strong></td>\n<td>Precomputed hash-to-password lookup database covering common passwords and hash functions</td>\n<td>Defeated by unique salt values making precomputation infeasible</td>\n</tr>\n<tr>\n<td><strong>brute force attack</strong></td>\n<td>Systematic attempt to guess passwords by trying all possible combinations</td>\n<td>Slowed by key stretching algorithms requiring significant computation per guess</td>\n</tr>\n<tr>\n<td><strong>dictionary attack</strong></td>\n<td>Password guessing using common passwords, words, and known patterns</td>\n<td>Combined with salting and key stretching to increase attack cost</td>\n</tr>\n<tr>\n<td><strong>timing attack</strong></td>\n<td>Side-channel attack exploiting execution time differences to extract secret information</td>\n<td>Prevented by constant-time comparison functions during password verification</td>\n</tr>\n<tr>\n<td><strong>birthday paradox</strong></td>\n<td>Collision probability analysis showing surprising frequency of duplicates in random data</td>\n<td>Considered when choosing salt length to ensure negligible collision probability</td>\n</tr>\n<tr>\n<td><strong>birthday attack</strong></td>\n<td>Cryptographic attack exploiting birthday paradox to find hash collisions more efficiently</td>\n<td>Mitigated by using collision-resistant hash functions and sufficient output length</td>\n</tr>\n<tr>\n<td><strong>GPU acceleration</strong></td>\n<td>Using graphics processing units to parallelize password cracking operations</td>\n<td>Countered by memory-hard algorithms like Argon2 that don&#39;t parallelize efficiently</td>\n</tr>\n<tr>\n<td><strong>ASIC acceleration</strong></td>\n<td>Custom hardware designed specifically for password cracking operations</td>\n<td>Resisted by algorithms requiring large memory or irregular access patterns</td>\n</tr>\n<tr>\n<td><strong>offline attack</strong></td>\n<td>Password cracking performed on stolen database without interacting with target system</td>\n<td>Primary threat model - assumes attacker has unlimited time with stolen password hashes</td>\n</tr>\n</tbody></table>\n<h3 id=\"salt-related-terminology\">Salt-Related Terminology</h3>\n<p>Salt generation and usage involves specific terminology critical for understanding protection against precomputed attacks:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Implementation Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>salt</strong></td>\n<td>Unique random value preventing precomputed attacks by making each hash computation unique</td>\n<td>Must be cryptographically random, at least 16 bytes, stored alongside hash</td>\n</tr>\n<tr>\n<td><strong>salting</strong></td>\n<td>Process of combining random salt value with password before hash computation</td>\n<td>Applied before hashing to ensure identical passwords produce different hash values</td>\n</tr>\n<tr>\n<td><strong>salt uniqueness</strong></td>\n<td>Property ensuring each password hash uses different salt value</td>\n<td>Achieved through cryptographically secure random generation for each hash operation</td>\n</tr>\n<tr>\n<td><strong>salt length</strong></td>\n<td>Number of bytes in salt value, affecting collision probability and storage requirements</td>\n<td>Minimum 16 bytes recommended, 32 bytes provides excellent security margin</td>\n</tr>\n<tr>\n<td><strong>salt format</strong></td>\n<td>Encoding method for representing binary salt data as text</td>\n<td>Supports binary, Base64, and hexadecimal formats for different storage systems</td>\n</tr>\n<tr>\n<td><strong>salt concatenation</strong></td>\n<td>Method of combining salt and password data before hash computation</td>\n<td>Order and method affect hash output - must be consistent across hash and verification</td>\n</tr>\n<tr>\n<td><strong>pepper</strong></td>\n<td>Secret value stored separately from database and applied during hash computation</td>\n<td>Not implemented in core milestones but mentioned as advanced security technique</td>\n</tr>\n</tbody></table>\n<h3 id=\"key-stretching-and-iteration-terminology\">Key Stretching and Iteration Terminology</h3>\n<p>Key stretching involves specific concepts around making hash computation intentionally expensive:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Performance and Security Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>key stretching</strong></td>\n<td>Iterative hashing to slow brute force attacks by increasing computation time per password guess</td>\n<td>Core security technique making offline attacks computationally expensive</td>\n</tr>\n<tr>\n<td><strong>iteration count</strong></td>\n<td>Number of internal hash rounds in key stretching algorithms</td>\n<td>Must be at least 100,000 for PBKDF2, tuned to achieve target computation time</td>\n</tr>\n<tr>\n<td><strong>cost factor</strong></td>\n<td>Algorithm parameter controlling computational expense, typically logarithmic scale</td>\n<td>bcrypt uses cost factor 12+ to achieve several hundred millisecond computation time</td>\n</tr>\n<tr>\n<td><strong>time cost</strong></td>\n<td>Argon2 parameter controlling number of iterations through memory</td>\n<td>Balanced with memory cost to achieve target computation time</td>\n</tr>\n<tr>\n<td><strong>memory cost</strong></td>\n<td>Argon2 parameter controlling memory usage during hash computation</td>\n<td>Measured in kilobytes, typically 64MB+ to resist GPU acceleration</td>\n</tr>\n<tr>\n<td><strong>parallelism</strong></td>\n<td>Number of parallel threads used in Argon2 computation</td>\n<td>Usually set to number of CPU cores, affects memory layout and timing</td>\n</tr>\n<tr>\n<td><strong>derived key length</strong></td>\n<td>Length of final key output from key derivation function</td>\n<td>Typically 32 bytes for password hashing, matches underlying hash function output</td>\n</tr>\n<tr>\n<td><strong>computational bottleneck</strong></td>\n<td>Intentional performance constraint for security purposes</td>\n<td>Key stretching creates bottleneck that affects both legitimate users and attackers</td>\n</tr>\n</tbody></table>\n<h3 id=\"algorithm-agility-and-migration-terminology\">Algorithm Agility and Migration Terminology</h3>\n<p>Supporting multiple algorithms and migration paths involves specific terminology around system evolution:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>System Design Implications</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>algorithm agility</strong></td>\n<td>Supporting multiple algorithms with migration between them as security requirements evolve</td>\n<td>Requires versioned hash records and migration assessment capabilities</td>\n</tr>\n<tr>\n<td><strong>lazy migration</strong></td>\n<td>Opportunistic hash upgrades during authentication without requiring password reset</td>\n<td>Executed when user provides password during normal login process</td>\n</tr>\n<tr>\n<td><strong>migration assessment</strong></td>\n<td>Evaluation of hash upgrade necessity based on algorithm strength and age</td>\n<td>Compares current hash against modern security standards and hardware capabilities</td>\n</tr>\n<tr>\n<td><strong>backward compatibility</strong></td>\n<td>Supporting verification of legacy hashes while preferring modern algorithms</td>\n<td>Maintains system functionality during gradual migration to stronger algorithms</td>\n</tr>\n<tr>\n<td><strong>version metadata</strong></td>\n<td>Information identifying algorithm and parameters used for specific hash</td>\n<td>Stored in hash record to enable correct verification and migration decisions</td>\n</tr>\n<tr>\n<td><strong>deprecation timeline</strong></td>\n<td>Schedule for phasing out legacy algorithms and requiring migration</td>\n<td>Balances security improvements against operational disruption</td>\n</tr>\n<tr>\n<td><strong>security decay</strong></td>\n<td>Gradual weakening of protection over time due to hardware improvements</td>\n<td>Motivates proactive migration to stronger algorithms and parameters</td>\n</tr>\n</tbody></table>\n<h3 id=\"constant-time-operations-and-timing-security\">Constant-Time Operations and Timing Security</h3>\n<p>Preventing timing attacks requires specific implementation techniques and terminology:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Security Requirement</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>constant-time comparison</strong></td>\n<td>Comparison taking same execution duration regardless of input values or differences</td>\n<td>Essential for password verification to prevent timing-based password recovery</td>\n</tr>\n<tr>\n<td><strong>timing consistency</strong></td>\n<td>Uniform execution duration regardless of input characteristics or code paths</td>\n<td>Applied to entire verification process, not just final comparison</td>\n</tr>\n<tr>\n<td><strong>timing attack</strong></td>\n<td>Side-channel attack exploiting execution time differences to extract secret information</td>\n<td>Prevented through careful implementation ensuring consistent timing</td>\n</tr>\n<tr>\n<td><strong>side-channel resistance</strong></td>\n<td>Protection against information leakage through execution patterns, timing, or resource usage</td>\n<td>Broader concept including timing attacks, power analysis, and electromagnetic emanations</td>\n</tr>\n<tr>\n<td><strong>temporal coupling</strong></td>\n<td>Dependency on external state that may change over time, affecting timing consistency</td>\n<td>Avoided by self-contained hash records including all verification parameters</td>\n</tr>\n<tr>\n<td><strong>execution pattern</strong></td>\n<td>Sequence of operations and conditional branches during algorithm execution</td>\n<td>Must be independent of secret data to prevent side-channel information leakage</td>\n</tr>\n</tbody></table>\n<h3 id=\"data-format-and-storage-terminology\">Data Format and Storage Terminology</h3>\n<p>Password hash storage and serialization involves specific format and encoding concepts:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Storage and Interoperability Requirements</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>hash record</strong></td>\n<td>Complete data structure containing algorithm, salt, hash, parameters, and metadata for password verification</td>\n<td>Self-contained unit storing all information needed for verification</td>\n</tr>\n<tr>\n<td><strong>serialization</strong></td>\n<td>Converting hash record data structure to string or binary format for storage</td>\n<td>Supports JSON and compact string formats for different storage systems</td>\n</tr>\n<tr>\n<td><strong>self-contained verification</strong></td>\n<td>Hash record contains all information needed for verification without external dependencies</td>\n<td>Prevents temporal coupling and ensures verification consistency over time</td>\n</tr>\n<tr>\n<td><strong>immutable archives</strong></td>\n<td>Hash records preserve exact creation-time configuration preventing modification</td>\n<td>Maintains verification integrity and supports forensic analysis</td>\n</tr>\n<tr>\n<td><strong>parameter encoding</strong></td>\n<td>Method for storing algorithm-specific configuration within hash record</td>\n<td>Enables correct verification and supports algorithm-specific requirements</td>\n</tr>\n<tr>\n<td><strong>version tagging</strong></td>\n<td>Including algorithm version information in hash record for compatibility tracking</td>\n<td>Supports migration decisions and backward compatibility requirements</td>\n</tr>\n</tbody></table>\n<h3 id=\"error-handling-and-validation-terminology\">Error Handling and Validation Terminology</h3>\n<p>Robust password hashing systems require comprehensive error handling with specific terminology:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Error Handling Strategy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>graceful degradation</strong></td>\n<td>Maintaining security while handling failures by reducing functionality rather than compromising protection</td>\n<td>Refuses operation rather than proceeding with weakened security</td>\n</tr>\n<tr>\n<td><strong>fail-secure behavior</strong></td>\n<td>Security design principle ensuring system fails to secure state rather than insecure state</td>\n<td>Critical for password hashing - never store weak hashes due to errors</td>\n</tr>\n<tr>\n<td><strong>input validation</strong></td>\n<td>Checking parameters meet security requirements before proceeding with operations</td>\n<td>Validates passwords, iteration counts, salt lengths, and algorithm parameters</td>\n</tr>\n<tr>\n<td><strong>parameter validation</strong></td>\n<td>Checking algorithm parameters meet security requirements and system constraints</td>\n<td>Enforces minimum iteration counts, appropriate memory costs, and valid configurations</td>\n</tr>\n<tr>\n<td><strong>entropy exhaustion</strong></td>\n<td>Insufficient randomness available for secure operations requiring high-quality random numbers</td>\n<td>Detected and handled by refusing to generate predictable salt values</td>\n</tr>\n<tr>\n<td><strong>resource exhaustion</strong></td>\n<td>System resources insufficient for secure operations within acceptable time limits</td>\n<td>Handled through parameter adjustment or operational fallback procedures</td>\n</tr>\n<tr>\n<td><strong>configuration validation</strong></td>\n<td>Verifying system configuration meets security requirements before enabling password operations</td>\n<td>Ensures algorithms are properly configured and security parameters are appropriate</td>\n</tr>\n</tbody></table>\n<h3 id=\"performance-and-benchmarking-terminology\">Performance and Benchmarking Terminology</h3>\n<p>Password hashing performance measurement and tuning involves specific terminology around timing and resource usage:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Performance Tuning Application</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>adaptive security tuning</strong></td>\n<td>Adjusting security parameters based on hardware capabilities to maintain consistent security level</td>\n<td>Automatically configures iteration counts and memory costs for current hardware</td>\n</tr>\n<tr>\n<td><strong>performance profiling</strong></td>\n<td>Systematic measurement of algorithm execution characteristics including timing and resource usage</td>\n<td>Guides parameter selection and identifies performance bottlenecks</td>\n</tr>\n<tr>\n<td><strong>benchmark calibration</strong></td>\n<td>Process of measuring algorithm performance to determine appropriate security parameters</td>\n<td>Ensures consistent computation time across different hardware configurations</td>\n</tr>\n<tr>\n<td><strong>target timing</strong></td>\n<td>Desired computation duration for password hashing operations balancing security and usability</td>\n<td>Typically 250-500ms for interactive authentication, longer for high-security applications</td>\n</tr>\n<tr>\n<td><strong>scalability metrics</strong></td>\n<td>Measurements of how algorithm performance changes with increased load or parallel operations</td>\n<td>Important for server applications handling multiple concurrent authentications</td>\n</tr>\n<tr>\n<td><strong>hardware capabilities</strong></td>\n<td>Computational and memory resources available for password hashing operations</td>\n<td>Influences algorithm selection and parameter configuration</td>\n</tr>\n</tbody></table>\n<h3 id=\"privacy-and-data-protection-terminology\">Privacy and Data Protection Terminology</h3>\n<p>Modern password security includes privacy-preserving techniques and data protection concepts:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Privacy Protection Application</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>k-anonymity</strong></td>\n<td>Privacy technique ensuring individual cannot be distinguished within group of k individuals</td>\n<td>Applied in breach checking using hash prefixes to maintain user privacy</td>\n</tr>\n<tr>\n<td><strong>hash prefix</strong></td>\n<td>First few characters of password hash used for privacy-preserving breach checking</td>\n<td>Typically 5 characters creating large anonymity set while enabling breach detection</td>\n</tr>\n<tr>\n<td><strong>privacy-preserving</strong></td>\n<td>Techniques protecting user data while enabling security checking and analysis</td>\n<td>Enables breach monitoring without revealing specific passwords to external services</td>\n</tr>\n<tr>\n<td><strong>breach monitoring</strong></td>\n<td>Checking passwords against known data breach databases to identify compromised credentials</td>\n<td>Integrated with privacy-preserving techniques to protect user confidentiality</td>\n</tr>\n<tr>\n<td><strong>data minimization</strong></td>\n<td>Privacy principle limiting data collection and retention to minimum necessary for function</td>\n<td>Applied to breach checking by using hash prefixes rather than complete hashes</td>\n</tr>\n</tbody></table>\n<h3 id=\"extension-and-integration-terminology\">Extension and Integration Terminology</h3>\n<p>Future system extensions and integrations involve specific terminology around modular design:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>System Architecture Impact</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>extension architecture</strong></td>\n<td>System design supporting additional features without modifying core password hashing functionality</td>\n<td>Enables policy engines, breach monitoring, and other advanced features</td>\n</tr>\n<tr>\n<td><strong>policy engine</strong></td>\n<td>System for coordinating password validation rules beyond cryptographic security</td>\n<td>Supports password complexity requirements, dictionary checking, and organizational policies</td>\n</tr>\n<tr>\n<td><strong>plugin architecture</strong></td>\n<td>Design pattern allowing modular addition of functionality through well-defined interfaces</td>\n<td>Enables algorithm plugins, storage backends, and monitoring integrations</td>\n</tr>\n<tr>\n<td><strong>integration boundaries</strong></td>\n<td>Defined interfaces between password hashing system and external components</td>\n<td>Maintains security isolation while enabling necessary interactions</td>\n</tr>\n<tr>\n<td><strong>rate limiting</strong></td>\n<td>Controlling request frequency to prevent service abuse and resource exhaustion</td>\n<td>Applied to authentication attempts and external service queries</td>\n</tr>\n</tbody></table>\n<h3 id=\"mathematical-and-cryptographic-foundations\">Mathematical and Cryptographic Foundations</h3>\n<p>Understanding the mathematical foundations underlying password hashing security:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Mathematical Security Basis</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>discrete logarithm problem</strong></td>\n<td>Mathematical problem underlying many cryptographic security assumptions</td>\n<td>Not directly used in password hashing but influences overall cryptographic security</td>\n</tr>\n<tr>\n<td><strong>proof of work</strong></td>\n<td>Cryptographic requirement to demonstrate computational effort through solving mathematical puzzle</td>\n<td>Conceptual foundation for key stretching - proving computational expense</td>\n</tr>\n<tr>\n<td><strong>memory-hard</strong></td>\n<td>Algorithm requiring significant memory resources that cannot be efficiently reduced</td>\n<td>Argon2 property making parallel attacks using specialized hardware more difficult</td>\n</tr>\n<tr>\n<td><strong>time-memory tradeoff</strong></td>\n<td>Attack technique trading computation time against memory storage in cryptographic attacks</td>\n<td>Considered in algorithm design to ensure no efficient shortcuts exist</td>\n</tr>\n<tr>\n<td><strong>cryptographic primitive</strong></td>\n<td>Basic cryptographic operation used as building block for more complex algorithms</td>\n<td>Includes hash functions, HMAC, and random number generation</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-and-development-terminology\">Implementation and Development Terminology</h3>\n<p>Practical terminology for implementing password hashing systems:</p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Definition</th>\n<th>Development Considerations</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>component architecture</strong></td>\n<td>System design with focused single-responsibility components having clear interfaces</td>\n<td>Separates salt generation, hashing, verification, and migration concerns</td>\n</tr>\n<tr>\n<td><strong>defense in depth</strong></td>\n<td>Multiple independent security barriers providing layered protection</td>\n<td>Combines salting, key stretching, algorithm agility, and timing attack protection</td>\n</tr>\n<tr>\n<td><strong>vulnerability demonstration</strong></td>\n<td>Showing security weaknesses through concrete examples and attack simulations</td>\n<td>Educational technique helping developers understand threat models</td>\n</tr>\n<tr>\n<td><strong>scope creep</strong></td>\n<td>Expanding project requirements beyond defined boundaries</td>\n<td>Avoided by focusing on password hashing rather than broader authentication systems</td>\n</tr>\n<tr>\n<td><strong>milestone progression</strong></td>\n<td>Incremental development approach building complexity through defined stages</td>\n<td>Progresses from basic hashing through key stretching to modern algorithms</td>\n</tr>\n</tbody></table>\n<h3 id=\"implementation-guidance\">Implementation Guidance</h3>\n<p>This section provides practical guidance for understanding and using cryptographic terminology while implementing password hashing systems.</p>\n<h4 id=\"technology-recommendations-for-cryptographic-operations\">Technology Recommendations for Cryptographic Operations</h4>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Simple Option</th>\n<th>Advanced Option</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Random Generation</td>\n<td><code>secrets.token_bytes()</code> (Python built-in)</td>\n<td>Custom entropy pooling with <code>os.urandom()</code></td>\n</tr>\n<tr>\n<td>Hash Computation</td>\n<td><code>hashlib.sha256()</code> (Python built-in)</td>\n<td>Hardware-accelerated cryptographic libraries</td>\n</tr>\n<tr>\n<td>Base64 Encoding</td>\n<td><code>base64.b64encode()</code> (Python built-in)</td>\n<td>URL-safe variants with custom alphabet</td>\n</tr>\n<tr>\n<td>Constant-Time Comparison</td>\n<td><code>hmac.compare_digest()</code> (Python built-in)</td>\n<td>Custom implementation with explicit timing control</td>\n</tr>\n<tr>\n<td>PBKDF2 Implementation</td>\n<td><code>hashlib.pbkdf2_hmac()</code> (Python built-in)</td>\n<td>Dedicated cryptographic libraries like <code>cryptography</code></td>\n</tr>\n<tr>\n<td>bcrypt Integration</td>\n<td><code>bcrypt</code> package (external dependency)</td>\n<td><code>passlib</code> for algorithm abstraction</td>\n</tr>\n<tr>\n<td>JSON Serialization</td>\n<td><code>json</code> module (Python built-in)</td>\n<td><code>orjson</code> for performance-critical applications</td>\n</tr>\n</tbody></table>\n<h4 id=\"recommended-project-structure-for-glossary-integration\">Recommended Project Structure for Glossary Integration</h4>\n<div class=\"code-block-wrapper\"><pre class=\"arch-pre shiki-highlighted\"><code>project-root/\n  docs/\n    glossary.md                    ← this comprehensive glossary\n    algorithm-comparison.md        ← algorithm selection guidance\n  src/password_hashing/\n    core/\n      __init__.py                 ← core exports and terminology constants\n      terminology.py              ← programmatic access to definitions\n    algorithms/\n      __init__.py                 ← algorithm registry\n      basic_hasher.py            ← SHA-256 with terminology documentation\n      key_stretching.py          ← PBKDF2 with terminology documentation  \n      modern_hasher.py           ← bcrypt/Argon2 with terminology documentation\n    utils/\n      constants.py               ← cryptographic constants with definitions\n      validation.py              ← parameter validation with terminology\n  tests/\n    test_terminology.py          ← verify terminology usage consistency\n    test_documentation.py        ← validate documentation accuracy</code></pre></div>\n\n<h4 id=\"terminology-constants-implementation\">Terminology Constants Implementation</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Cryptographic constants with precise terminology definitions.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">Each constant includes comprehensive documentation explaining its purpose,</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">security implications, and relationship to industry standards.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Salt generation constants with security rationale</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MINIMUM_SALT_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 16</span><span style=\"color:#6A737D\">  # bytes - sufficient to prevent birthday attacks</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">RECOMMENDED_SALT_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 32</span><span style=\"color:#6A737D\">  # bytes - provides excellent security margin</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">MAXIMUM_SALT_LENGTH</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 64</span><span style=\"color:#6A737D\">  # bytes - practical upper limit for storage efficiency</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Key stretching parameters with performance guidance  </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">PBKDF2_MIN_ITERATIONS</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 100_000</span><span style=\"color:#6A737D\">  # minimum iterations for current hardware</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">BCRYPT_MIN_COST</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 12</span><span style=\"color:#6A737D\">  # minimum cost factor achieving ~250ms computation time</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Algorithm identifiers using standard terminology</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> AlgorithmNames</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Standard algorithm names matching cryptographic literature.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    SHA256_BASIC</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"sha256-basic\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PBKDF2_HMAC_SHA256</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"pbkdf2-hmac-sha256\"</span><span style=\"color:#E1E4E8\"> </span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    BCRYPT</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"bcrypt\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ARGON2ID</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"argon2id\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"># Error codes using precise terminology</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> ErrorCodes</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"Error classification using standard cryptographic terminology.\"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ENTROPY_EXHAUSTION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"entropy-exhaustion\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    PARAMETER_VALIDATION</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"parameter-validation\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    ALGORITHM_UNAVAILABLE</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"algorithm-unavailable\"</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">    TIMING_ATTACK_DETECTED</span><span style=\"color:#F97583\"> =</span><span style=\"color:#9ECBFF\"> \"timing-attack-detected\"</span></span></code></pre></div>\n\n<h4 id=\"glossary-integration-helper-functions\">Glossary Integration Helper Functions</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> get_algorithm_terminology</span><span style=\"color:#E1E4E8\">(algorithm_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">dict</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Return comprehensive terminology and definitions for specified algorithm.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Helps developers understand precise meaning of algorithm-specific concepts.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 1: Validate algorithm_name against known algorithms</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 2: Return dictionary with algorithm-specific terminology</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 3: Include security properties, parameters, and usage guidelines</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 4: Add references to relevant standards and specifications</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> validate_terminology_usage</span><span style=\"color:#E1E4E8\">(code_text: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">list</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Analyze code for consistent terminology usage matching glossary definitions.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Helps maintain precise language throughout implementation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 1: Parse code for cryptographic terminology usage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 2: Check against glossary definitions for consistency</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 3: Identify deprecated or imprecise terminology</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 4: Return list of terminology issues with suggestions</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">def</span><span style=\"color:#B392F0\"> generate_documentation_template</span><span style=\"color:#E1E4E8\">(component_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Generate documentation template with appropriate terminology sections.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Ensures comprehensive coverage of cryptographic concepts.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 1: Identify relevant terminology categories for component</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 2: Generate template with terminology definition sections  </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 3: Include placeholder text with proper terminology usage</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    TODO</span><span style=\"color:#9ECBFF\"> 4: Add cross-references to related glossary entries</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span></code></pre></div>\n\n<h4 id=\"common-terminology-usage-patterns\">Common Terminology Usage Patterns</h4>\n<div class=\"code-block-wrapper\"><span class=\"code-lang\">python</span><pre class=\"arch-pre shiki-highlighted\"><code><span class=\"line\"><span style=\"color:#F97583\">class</span><span style=\"color:#B392F0\"> TerminologyPatterns</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    Common patterns for using cryptographic terminology consistently</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    throughout password hashing implementation.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">    \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> describe_security_property</span><span style=\"color:#E1E4E8\">(self, property_name: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, context: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Generate standardized description of security property in context.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Look up property definition in glossary</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Adapt description for specific context</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: Include relevant threat model information</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: Add implementation guidance references</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    def</span><span style=\"color:#B392F0\"> explain_algorithm_choice</span><span style=\"color:#E1E4E8\">(self, algorithm: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">, rationale: </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">) -> </span><span style=\"color:#79B8FF\">str</span><span style=\"color:#E1E4E8\">:</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        Generate explanation of algorithm selection using precise terminology.</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 1: Include algorithm-specific security properties</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 2: Compare against alternative algorithms</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 3: Explain security/performance tradeoffs</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        TODO</span><span style=\"color:#9ECBFF\"> 4: Reference industry standards and recommendations</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">        \"\"\"</span></span></code></pre></div>\n\n<h4 id=\"milestone-checkpoints-for-terminology-understanding\">Milestone Checkpoints for Terminology Understanding</h4>\n<p>After implementing each milestone, verify terminology understanding:</p>\n<p><strong>Milestone 1 Checkpoint:</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> Can explain difference between &quot;salt&quot; and &quot;pepper&quot; terminology</li>\n<li><input disabled=\"\" type=\"checkbox\"> Understands &quot;rainbow table&quot; attack and defense mechanisms  </li>\n<li><input disabled=\"\" type=\"checkbox\"> Uses &quot;cryptographic security&quot; vs &quot;computational security&quot; appropriately</li>\n<li><input disabled=\"\" type=\"checkbox\"> Correctly describes &quot;timing attack&quot; vulnerability and prevention</li>\n</ul>\n<p><strong>Milestone 2 Checkpoint:</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> Explains &quot;key stretching&quot; vs &quot;key derivation&quot; terminology distinction</li>\n<li><input disabled=\"\" type=\"checkbox\"> Understands &quot;iteration count&quot; vs &quot;cost factor&quot; in different algorithms</li>\n<li><input disabled=\"\" type=\"checkbox\"> Uses &quot;computational hardness&quot; terminology correctly in security analysis</li>\n<li><input disabled=\"\" type=\"checkbox\"> Describes &quot;side-channel resistance&quot; requirements accurately</li>\n</ul>\n<p><strong>Milestone 3 Checkpoint:</strong></p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> Distinguishes &quot;algorithm agility&quot; from simple algorithm support</li>\n<li><input disabled=\"\" type=\"checkbox\"> Explains &quot;memory-hard&quot; properties and their security implications</li>\n<li><input disabled=\"\" type=\"checkbox\"> Uses &quot;lazy migration&quot; terminology in upgrade strategy discussions</li>\n<li><input disabled=\"\" type=\"checkbox\"> Correctly describes &quot;fail-secure behavior&quot; in error handling</li>\n</ul>\n<h4 id=\"debugging-terminology-confusion\">Debugging Terminology Confusion</h4>\n<table>\n<thead>\n<tr>\n<th>Symptom</th>\n<th>Terminology Issue</th>\n<th>Diagnosis</th>\n<th>Fix</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Code comments use &quot;encryption&quot; for hashing</td>\n<td>Confusing reversible vs irreversible operations</td>\n<td>Review cryptographic operation types</td>\n<td>Use &quot;hashing&quot; for one-way operations, &quot;encryption&quot; for reversible</td>\n</tr>\n<tr>\n<td>Documentation mentions &quot;decrypting passwords&quot;</td>\n<td>Fundamental misunderstanding of password storage</td>\n<td>Check understanding of one-way functions</td>\n<td>Passwords are verified, not decrypted - hashing is irreversible</td>\n</tr>\n<tr>\n<td>Variable names like <code>password_key</code></td>\n<td>Mixing password and key terminology</td>\n<td>Review terminology for derived values</td>\n<td>Use <code>derived_key</code> for PBKDF2 output, <code>password_hash</code> for storage</td>\n</tr>\n<tr>\n<td>Comments refer to &quot;salted encryption&quot;</td>\n<td>Combining unrelated cryptographic concepts</td>\n<td>Clarify salting vs encryption purposes</td>\n<td>Salting prevents precomputation, encryption provides confidentiality</td>\n</tr>\n<tr>\n<td>Error messages mention &quot;hash decryption failed&quot;</td>\n<td>Incorrect mental model of verification process</td>\n<td>Review verification algorithm steps</td>\n<td>Verification re-computes hash, doesn&#39;t &quot;decrypt&quot; anything</td>\n</tr>\n</tbody></table>\n","toc":[{"level":1,"text":"Password Hashing: Design Document","id":"password-hashing-design-document"},{"level":2,"text":"Overview","id":"overview"},{"level":2,"text":"Context and Problem Statement","id":"context-and-problem-statement"},{"level":3,"text":"Mental Model: The Security Safe Analogy","id":"mental-model-the-security-safe-analogy"},{"level":3,"text":"Password Storage Vulnerabilities","id":"password-storage-vulnerabilities"},{"level":3,"text":"Threat Model","id":"threat-model"},{"level":3,"text":"Existing Approaches Comparison","id":"existing-approaches-comparison"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Goals and Non-Goals","id":"goals-and-non-goals"},{"level":3,"text":"Mental Model: The Security Perimeter Analogy","id":"mental-model-the-security-perimeter-analogy"},{"level":3,"text":"Core Goals","id":"core-goals"},{"level":4,"text":"Security Goal Deep Dive","id":"security-goal-deep-dive"},{"level":3,"text":"Integration Goals","id":"integration-goals"},{"level":3,"text":"Performance Goals","id":"performance-goals"},{"level":3,"text":"Educational Goals","id":"educational-goals"},{"level":3,"text":"Explicit Non-Goals","id":"explicit-non-goals"},{"level":4,"text":"Authentication System Non-Goals","id":"authentication-system-non-goals"},{"level":4,"text":"Database Integration Non-Goals","id":"database-integration-non-goals"},{"level":4,"text":"Deployment and Operations Non-Goals","id":"deployment-and-operations-non-goals"},{"level":4,"text":"Security Infrastructure Non-Goals","id":"security-infrastructure-non-goals"},{"level":3,"text":"Architecture Decision: Scope Boundaries","id":"architecture-decision-scope-boundaries"},{"level":3,"text":"Success Metrics","id":"success-metrics"},{"level":3,"text":"Common Pitfalls in Goal Definition","id":"common-pitfalls-in-goal-definition"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Project Structure for Goals Implementation","id":"project-structure-for-goals-implementation"},{"level":4,"text":"Goal Verification Starter Code","id":"goal-verification-starter-code"},{"level":4,"text":"Performance Goal Implementation","id":"performance-goal-implementation"},{"level":4,"text":"Educational Goal Demonstrations","id":"educational-goal-demonstrations"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":2,"text":"High-Level Architecture","id":"high-level-architecture"},{"level":3,"text":"Mental Model: The Security Checkpoint System Analogy","id":"mental-model-the-security-checkpoint-system-analogy"},{"level":3,"text":"Component Overview","id":"component-overview"},{"level":4,"text":"Core Components and Responsibilities","id":"core-components-and-responsibilities"},{"level":4,"text":"Component Dependencies and Integration Boundaries","id":"component-dependencies-and-integration-boundaries"},{"level":4,"text":"Data Flow and Component Interactions","id":"data-flow-and-component-interactions"},{"level":4,"text":"Common Integration Patterns","id":"common-integration-patterns"},{"level":3,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Project Root Structure","id":"project-root-structure"},{"level":4,"text":"Component Module Design Rationale","id":"component-module-design-rationale"},{"level":4,"text":"Educational Structure Integration","id":"educational-structure-integration"},{"level":4,"text":"Testing Strategy Integration","id":"testing-strategy-integration"},{"level":4,"text":"File Organization Benefits and Trade-offs","id":"file-organization-benefits-and-trade-offs"},{"level":3,"text":"Common Pitfalls in Component Architecture","id":"common-pitfalls-in-component-architecture"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Component Skeletons","id":"core-component-skeletons"},{"level":4,"text":"Milestone Checkpoint: Basic Hashing Implementation","id":"milestone-checkpoint-basic-hashing-implementation"},{"level":2,"text":"Data Model","id":"data-model"},{"level":3,"text":"Mental Model: The Medical Chart System Analogy","id":"mental-model-the-medical-chart-system-analogy"},{"level":3,"text":"Password Hash Record","id":"password-hash-record"},{"level":4,"text":"Parameter Storage by Algorithm","id":"parameter-storage-by-algorithm"},{"level":4,"text":"Hash Record Serialization Formats","id":"hash-record-serialization-formats"},{"level":3,"text":"Algorithm Parameters","id":"algorithm-parameters"},{"level":4,"text":"Algorithm-Specific Parameter Structures","id":"algorithm-specific-parameter-structures"},{"level":4,"text":"Parameter Validation and Constraints","id":"parameter-validation-and-constraints"},{"level":4,"text":"Parameter Evolution and Migration Strategy","id":"parameter-evolution-and-migration-strategy"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Salt Generation Component","id":"salt-generation-component"},{"level":3,"text":"Mental Model: The Fingerprint Database Security System","id":"mental-model-the-fingerprint-database-security-system"},{"level":3,"text":"Component Responsibilities","id":"component-responsibilities"},{"level":3,"text":"Cryptographic Randomness Requirements","id":"cryptographic-randomness-requirements"},{"level":4,"text":"Understanding Entropy Sources","id":"understanding-entropy-sources"},{"level":4,"text":"Platform-Specific Entropy Sources","id":"platform-specific-entropy-sources"},{"level":4,"text":"Detecting Entropy Exhaustion","id":"detecting-entropy-exhaustion"},{"level":3,"text":"Salt Length Architecture Decisions","id":"salt-length-architecture-decisions"},{"level":4,"text":"Security Analysis of Salt Length","id":"security-analysis-of-salt-length"},{"level":4,"text":"Storage Format Considerations","id":"storage-format-considerations"},{"level":4,"text":"Salt Uniqueness Requirements","id":"salt-uniqueness-requirements"},{"level":3,"text":"Salt Generation Algorithm","id":"salt-generation-algorithm"},{"level":3,"text":"Integration with Password Hashing Components","id":"integration-with-password-hashing-components"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Basic Hashing Component","id":"basic-hashing-component"},{"level":3,"text":"Mental Model: The Sealed Envelope Authentication System","id":"mental-model-the-sealed-envelope-authentication-system"},{"level":3,"text":"Hash Computation Algorithm","id":"hash-computation-algorithm"},{"level":3,"text":"Timing Attack Prevention","id":"timing-attack-prevention"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Key Stretching Component","id":"key-stretching-component"},{"level":3,"text":"Mental Model: The Time Lock Vault Analogy","id":"mental-model-the-time-lock-vault-analogy"},{"level":3,"text":"PBKDF2 Algorithm Implementation","id":"pbkdf2-algorithm-implementation"},{"level":4,"text":"Core PBKDF2 Architecture","id":"core-pbkdf2-architecture"},{"level":4,"text":"PBKDF2 Internal Algorithm Flow","id":"pbkdf2-internal-algorithm-flow"},{"level":4,"text":"Cryptographic Security Properties","id":"cryptographic-security-properties"},{"level":4,"text":"Implementation Architecture Decisions","id":"implementation-architecture-decisions"},{"level":3,"text":"Iteration Count Tuning","id":"iteration-count-tuning"},{"level":4,"text":"Performance-Security Trade-off Analysis","id":"performance-security-trade-off-analysis"},{"level":4,"text":"Hardware-Based Tuning Methodology","id":"hardware-based-tuning-methodology"},{"level":4,"text":"Dynamic Iteration Count Management","id":"dynamic-iteration-count-management"},{"level":4,"text":"Security Monitoring and Validation","id":"security-monitoring-and-validation"},{"level":3,"text":"Common Pitfalls","id":"common-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":2,"text":"Modern Hashing Component","id":"modern-hashing-component"},{"level":3,"text":"Mental Model: The Bank Vault Evolution System","id":"mental-model-the-bank-vault-evolution-system"},{"level":3,"text":"Bcrypt Integration: Using Bcrypt&#39;s Built-in Salt Generation and Cost Factor Management","id":"bcrypt-integration-using-bcrypt39s-built-in-salt-generation-and-cost-factor-management"},{"level":3,"text":"Argon2 Support: Memory-Hard Hashing for Enhanced Security Against Specialized Hardware","id":"argon2-support-memory-hard-hashing-for-enhanced-security-against-specialized-hardware"},{"level":3,"text":"Algorithm Agility Design: Supporting Multiple Algorithms and Migration Paths for Future Upgrades","id":"algorithm-agility-design-supporting-multiple-algorithms-and-migration-paths-for-future-upgrades"},{"level":3,"text":"Common Pitfalls in Modern Hashing Implementation","id":"common-pitfalls-in-modern-hashing-implementation"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":2,"text":"Interactions and Data Flow","id":"interactions-and-data-flow"},{"level":3,"text":"Mental Model: The Airport Security Processing Pipeline","id":"mental-model-the-airport-security-processing-pipeline"},{"level":3,"text":"Password Registration Flow","id":"password-registration-flow"},{"level":4,"text":"Registration Flow Architecture","id":"registration-flow-architecture"},{"level":4,"text":"Detailed Registration Process","id":"detailed-registration-process"},{"level":4,"text":"Registration Data Flow Example","id":"registration-data-flow-example"},{"level":4,"text":"Registration Error Handling","id":"registration-error-handling"},{"level":4,"text":"Registration Performance Monitoring","id":"registration-performance-monitoring"},{"level":3,"text":"Password Verification Flow","id":"password-verification-flow"},{"level":4,"text":"Verification Flow Architecture","id":"verification-flow-architecture"},{"level":4,"text":"Detailed Verification Process","id":"detailed-verification-process"},{"level":4,"text":"Verification Data Flow Example","id":"verification-data-flow-example"},{"level":4,"text":"Verification Timing Attack Prevention","id":"verification-timing-attack-prevention"},{"level":4,"text":"Verification Error Handling and Recovery","id":"verification-error-handling-and-recovery"},{"level":4,"text":"Lazy Migration During Verification","id":"lazy-migration-during-verification"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Infrastructure Starter Code","id":"infrastructure-starter-code"},{"level":4,"text":"Core Logic Skeleton Code","id":"core-logic-skeleton-code"},{"level":4,"text":"Language-Specific Hints","id":"language-specific-hints"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Error Handling and Edge Cases","id":"error-handling-and-edge-cases"},{"level":3,"text":"Mental Model: The Airport Security Crisis Management System","id":"mental-model-the-airport-security-crisis-management-system"},{"level":3,"text":"Input Validation","id":"input-validation"},{"level":4,"text":"Password Input Validation","id":"password-input-validation"},{"level":4,"text":"Algorithm Parameter Validation","id":"algorithm-parameter-validation"},{"level":4,"text":"Configuration Parameter Validation","id":"configuration-parameter-validation"},{"level":3,"text":"Graceful Degradation","id":"graceful-degradation"},{"level":4,"text":"Handling Missing Algorithms","id":"handling-missing-algorithms"},{"level":4,"text":"Handling Configuration Errors","id":"handling-configuration-errors"},{"level":4,"text":"Resource Exhaustion Handling","id":"resource-exhaustion-handling"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Exception Hierarchy Infrastructure","id":"exception-hierarchy-infrastructure"},{"level":4,"text":"Input Validation Implementation","id":"input-validation-implementation"},{"level":4,"text":"Configuration Management Implementation","id":"configuration-management-implementation"},{"level":4,"text":"Graceful Degradation Implementation","id":"graceful-degradation-implementation"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Testing Strategy","id":"testing-strategy"},{"level":3,"text":"Mental Model: The Nuclear Power Plant Safety Testing System","id":"mental-model-the-nuclear-power-plant-safety-testing-system"},{"level":3,"text":"Security Test Cases","id":"security-test-cases"},{"level":4,"text":"Cryptographic Randomness Verification","id":"cryptographic-randomness-verification"},{"level":4,"text":"Timing Attack Resistance Verification","id":"timing-attack-resistance-verification"},{"level":4,"text":"Algorithm Security Property Verification","id":"algorithm-security-property-verification"},{"level":4,"text":"Migration Security Testing","id":"migration-security-testing"},{"level":3,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Milestone 1: Basic Hashing with Salt Checkpoint","id":"milestone-1-basic-hashing-with-salt-checkpoint"},{"level":4,"text":"Milestone 2: Key Stretching Checkpoint","id":"milestone-2-key-stretching-checkpoint"},{"level":4,"text":"Milestone 3: Modern Password Hashing Checkpoint","id":"milestone-3-modern-password-hashing-checkpoint"},{"level":3,"text":"Common Security Testing Pitfalls","id":"common-security-testing-pitfalls"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Security Testing Technology Stack","id":"security-testing-technology-stack"},{"level":4,"text":"Recommended Test File Structure","id":"recommended-test-file-structure"},{"level":4,"text":"Security Testing Infrastructure Code","id":"security-testing-infrastructure-code"},{"level":4,"text":"Milestone-Specific Testing Skeletons","id":"milestone-specific-testing-skeletons"},{"level":4,"text":"Performance Benchmark Testing","id":"performance-benchmark-testing"},{"level":4,"text":"Debugging Security Test Failures","id":"debugging-security-test-failures"},{"level":2,"text":"Debugging Guide","id":"debugging-guide"},{"level":3,"text":"Mental Model: The Medical Diagnostic System","id":"mental-model-the-medical-diagnostic-system"},{"level":3,"text":"Common Implementation Bugs","id":"common-implementation-bugs"},{"level":4,"text":"Salt Generation Failures","id":"salt-generation-failures"},{"level":4,"text":"Hash Computation Vulnerabilities","id":"hash-computation-vulnerabilities"},{"level":4,"text":"PBKDF2 Implementation Errors","id":"pbkdf2-implementation-errors"},{"level":4,"text":"Modern Algorithm Integration Problems","id":"modern-algorithm-integration-problems"},{"level":4,"text":"Timing Attack Vulnerabilities","id":"timing-attack-vulnerabilities"},{"level":3,"text":"Debugging Techniques","id":"debugging-techniques"},{"level":4,"text":"Cryptographic Analysis Toolkit","id":"cryptographic-analysis-toolkit"},{"level":4,"text":"Performance and Security Profiling","id":"performance-and-security-profiling"},{"level":4,"text":"Production Debugging Strategies","id":"production-debugging-strategies"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"File Structure for Debugging Components","id":"file-structure-for-debugging-components"},{"level":4,"text":"Cryptographic Analysis Implementation","id":"cryptographic-analysis-implementation"},{"level":4,"text":"Performance Analysis Implementation","id":"performance-analysis-implementation"},{"level":4,"text":"Milestone Checkpoints","id":"milestone-checkpoints"},{"level":4,"text":"Debugging Red Flags","id":"debugging-red-flags"},{"level":2,"text":"Future Extensions","id":"future-extensions"},{"level":3,"text":"Mental Model: The Evolving Security Ecosystem Analogy","id":"mental-model-the-evolving-security-ecosystem-analogy"},{"level":3,"text":"Password Policy Integration: Adding Strength Validation and Policy Enforcement","id":"password-policy-integration-adding-strength-validation-and-policy-enforcement"},{"level":4,"text":"Architecture Decision: Policy Integration Strategy","id":"architecture-decision-policy-integration-strategy"},{"level":4,"text":"Policy Engine Data Structures","id":"policy-engine-data-structures"},{"level":4,"text":"Policy Rule Interface","id":"policy-rule-interface"},{"level":4,"text":"Built-in Policy Implementations","id":"built-in-policy-implementations"},{"level":4,"text":"Policy Evaluation Flow","id":"policy-evaluation-flow"},{"level":4,"text":"Integration with Password Registration Flow","id":"integration-with-password-registration-flow"},{"level":4,"text":"Advanced Policy Features","id":"advanced-policy-features"},{"level":4,"text":"Common Pitfalls in Policy Integration","id":"common-pitfalls-in-policy-integration"},{"level":3,"text":"Breach Monitoring: Integration with HaveIBeenPwned and Similar Services","id":"breach-monitoring-integration-with-haveibeenpwned-and-similar-services"},{"level":4,"text":"Architecture Decision: Privacy-Preserving Breach Checking","id":"architecture-decision-privacy-preserving-breach-checking"},{"level":4,"text":"Breach Monitoring Service Architecture","id":"breach-monitoring-service-architecture"},{"level":4,"text":"k-Anonymity Implementation","id":"k-anonymity-implementation"},{"level":4,"text":"Breach API Client Interface","id":"breach-api-client-interface"},{"level":4,"text":"HaveIBeenPwned Client Implementation","id":"haveibeenpwned-client-implementation"},{"level":4,"text":"Caching Strategy for Breach Results","id":"caching-strategy-for-breach-results"},{"level":4,"text":"Integration with Password Registration and Verification","id":"integration-with-password-registration-and-verification"},{"level":4,"text":"Asynchronous Monitoring Implementation","id":"asynchronous-monitoring-implementation"},{"level":4,"text":"Privacy and Security Considerations","id":"privacy-and-security-considerations"},{"level":4,"text":"Advanced Monitoring Features","id":"advanced-monitoring-features"},{"level":4,"text":"Common Pitfalls in Breach Monitoring","id":"common-pitfalls-in-breach-monitoring"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations","id":"technology-recommendations"},{"level":4,"text":"Recommended File Structure","id":"recommended-file-structure"},{"level":4,"text":"Password Policy Engine Infrastructure Code","id":"password-policy-engine-infrastructure-code"},{"level":4,"text":"Breach Monitoring Service Infrastructure Code","id":"breach-monitoring-service-infrastructure-code"},{"level":4,"text":"Core Logic Skeleton: Policy Rule Implementation","id":"core-logic-skeleton-policy-rule-implementation"},{"level":4,"text":"Core Logic Skeleton: Integration Layer","id":"core-logic-skeleton-integration-layer"},{"level":4,"text":"Milestone Checkpoint","id":"milestone-checkpoint"},{"level":4,"text":"Debugging Tips","id":"debugging-tips"},{"level":2,"text":"Glossary","id":"glossary"},{"level":3,"text":"Mental Model: The Technical Reference Library","id":"mental-model-the-technical-reference-library"},{"level":3,"text":"Cryptographic Algorithms and Standards","id":"cryptographic-algorithms-and-standards"},{"level":3,"text":"Security Properties and Concepts","id":"security-properties-and-concepts"},{"level":3,"text":"Attack Techniques and Vulnerabilities","id":"attack-techniques-and-vulnerabilities"},{"level":3,"text":"Salt-Related Terminology","id":"salt-related-terminology"},{"level":3,"text":"Key Stretching and Iteration Terminology","id":"key-stretching-and-iteration-terminology"},{"level":3,"text":"Algorithm Agility and Migration Terminology","id":"algorithm-agility-and-migration-terminology"},{"level":3,"text":"Constant-Time Operations and Timing Security","id":"constant-time-operations-and-timing-security"},{"level":3,"text":"Data Format and Storage Terminology","id":"data-format-and-storage-terminology"},{"level":3,"text":"Error Handling and Validation Terminology","id":"error-handling-and-validation-terminology"},{"level":3,"text":"Performance and Benchmarking Terminology","id":"performance-and-benchmarking-terminology"},{"level":3,"text":"Privacy and Data Protection Terminology","id":"privacy-and-data-protection-terminology"},{"level":3,"text":"Extension and Integration Terminology","id":"extension-and-integration-terminology"},{"level":3,"text":"Mathematical and Cryptographic Foundations","id":"mathematical-and-cryptographic-foundations"},{"level":3,"text":"Implementation and Development Terminology","id":"implementation-and-development-terminology"},{"level":3,"text":"Implementation Guidance","id":"implementation-guidance"},{"level":4,"text":"Technology Recommendations for Cryptographic Operations","id":"technology-recommendations-for-cryptographic-operations"},{"level":4,"text":"Recommended Project Structure for Glossary Integration","id":"recommended-project-structure-for-glossary-integration"},{"level":4,"text":"Terminology Constants Implementation","id":"terminology-constants-implementation"},{"level":4,"text":"Glossary Integration Helper Functions","id":"glossary-integration-helper-functions"},{"level":4,"text":"Common Terminology Usage Patterns","id":"common-terminology-usage-patterns"},{"level":4,"text":"Milestone Checkpoints for Terminology Understanding","id":"milestone-checkpoints-for-terminology-understanding"},{"level":4,"text":"Debugging Terminology Confusion","id":"debugging-terminology-confusion"}],"title":"Password Hashing: Design Document","markdown":"# Password Hashing: Design Document\n\n\n## Overview\n\nThis system implements secure password storage and verification using cryptographic hashing, salting, and key stretching techniques. The key architectural challenge is balancing security against brute force attacks while maintaining reasonable performance for legitimate authentication attempts.\n\n\n> This guide is meant to help you understand the big picture before diving into each milestone. Refer back to it whenever you need context on how components connect.\n\n\n## Context and Problem Statement\n\n> **Milestone(s):** All milestones (foundational concepts underlying the entire project)\n\n### Mental Model: The Security Safe Analogy\n\nThink of password storage like protecting valuables in a safe. A naive approach would be like writing down the safe combination on a sticky note and putting it on the safe door — anyone who finds it has immediate access. A slightly better approach might be hiding the combination in a desk drawer, but a determined thief will eventually find it. Secure password storage is like using multiple layers of protection: a time-locked safe (slow to open even with the right combination), a unique key for each safe (salt), and a combination that takes significant effort to discover even if you know the algorithm.\n\nThe fundamental challenge in password storage is asymmetry: legitimate users need fast authentication (milliseconds), but attackers with stolen data have unlimited time and computational resources. Our security model must make authentication convenient for legitimate use while making brute force attacks computationally infeasible.\n\n### Password Storage Vulnerabilities\n\nPassword storage vulnerabilities represent one of the most critical security risks in modern applications. Understanding these vulnerabilities is essential because they directly impact user safety across multiple services — users frequently reuse passwords, so a breach in one system can cascade to compromise accounts elsewhere.\n\n**Plain Text Storage** represents the most severe vulnerability. When passwords are stored in readable form, any system compromise immediately exposes all user credentials. Consider a database containing user records where the password field contains actual passwords like \"mypassword123\". An attacker gaining read access through SQL injection, backup theft, or insider threat immediately obtains every user's authentication credentials. This vulnerability extends beyond the immediate system — if users have reused these passwords on other services (email, banking, social media), the attacker gains access to those accounts as well.\n\n**Simple Hashing Without Salt** appears secure on the surface but falls victim to precomputed attacks. When passwords are hashed using algorithms like MD5 or SHA-256 without additional randomization, identical passwords produce identical hashes. An attacker can build rainbow tables — precomputed databases mapping common passwords to their hash values. For example, the password \"password123\" always produces the SHA-256 hash `ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f`. Rainbow tables for common passwords and hash algorithms are readily available online, making this attack trivial to execute.\n\n**Inadequate Salt Implementation** introduces several attack vectors. Using predictable salts (like user ID or username) allows attackers to build targeted rainbow tables. Using short salts (less than 16 bytes) makes brute force attacks against the salt space feasible. Not storing the salt alongside the hash makes verification impossible. Using the same salt for multiple passwords eliminates the salt's protective benefit.\n\n**Fast Hashing Algorithm Selection** enables high-speed brute force attacks. Algorithms like MD5, SHA-1, and SHA-256 were designed for speed and can compute millions of hashes per second on modern hardware. Graphics cards and specialized ASIC hardware can achieve billions of hash computations per second. An attacker with stolen password hashes can systematically try password combinations at these speeds, making weak passwords vulnerable within hours or days.\n\n> **Critical Security Insight**: The attacker's advantage is time and computational resources. While legitimate authentication happens once per login session, an attacker with stolen hashes can attempt billions of password guesses offline without detection or rate limiting.\n\n| Vulnerability Type | Attack Vector | Impact Severity | Detection Difficulty | Exploitation Speed |\n|-------------------|---------------|-----------------|---------------------|-------------------|\n| Plain Text Storage | Direct database access | Critical - immediate full compromise | Easy - obvious in data | Instant |\n| Simple Hash (MD5/SHA256) | Rainbow table lookup | High - common passwords compromised | Medium - requires hash analysis | Seconds to minutes |\n| Predictable Salt | Targeted rainbow tables | High - targeted attack possible | Medium - pattern analysis needed | Minutes to hours |\n| Short Salt (<16 bytes) | Salt space brute force | Medium - increases attack feasibility | Hard - statistical analysis | Hours to days |\n| Fast Algorithm (SHA256) | High-speed brute force | Medium to High - depends on password strength | Hard - requires hash rate analysis | Hours to weeks |\n\n**Timing Attack Vulnerabilities** occur during password verification when comparison operations leak information through execution time differences. A naive string comparison function that returns false immediately upon finding a mismatched character allows attackers to measure response times and gradually discover the correct hash byte by byte. This side-channel attack can completely bypass the cryptographic protection.\n\n### Threat Model\n\nUnderstanding our adversaries and their capabilities shapes every design decision in our password hashing system. We must defend against multiple threat categories with varying resources, motivations, and attack vectors.\n\n**Script Kiddie Attackers** represent the most common threat category. These attackers use readily available tools and databases without deep technical understanding. They rely on automated vulnerability scanners, pre-built exploitation frameworks, and publicly available password lists. Their attacks typically target known vulnerabilities and common misconfigurations. They have limited computational resources (personal computers) and patience (looking for quick wins).\n\nScript kiddies primarily use rainbow table attacks against unsalted hashes and dictionary attacks against weakly salted hashes. They download password lists from previous breaches and hash them using common algorithms, hoping for matches. Their attack duration typically spans hours to days — they move on to easier targets if immediate success isn't achieved.\n\n**Organized Cybercriminal Groups** operate with significantly more resources and sophistication. They maintain specialized hardware for password cracking, including GPU farms capable of billions of hash computations per second. These groups have access to comprehensive password databases compiled from years of breaches, sophisticated rule-based attack generators, and custom software optimized for specific hashing algorithms.\n\nCriminal organizations can sustain attacks for weeks or months, especially when targeting high-value accounts. They employ hybrid attacks combining dictionary words with common patterns, social engineering to discover password hints, and correlation attacks using data from multiple breaches to identify password reuse patterns.\n\n**Nation-State Actors** possess the highest level of resources and technical capability. They have access to specialized hardware, custom silicon designed for cryptographic attacks, and significant computational budgets. Nation-state attackers can develop zero-day exploits against systems, conduct long-term persistent attacks, and correlate vast amounts of data from multiple sources.\n\nThese actors can sustain attacks for months or years against specific high-value targets. They may compromise the systems where password hashing occurs rather than attacking the hashes themselves. Their threat extends beyond password cracking to include supply chain attacks against cryptographic libraries and side-channel attacks against hardware implementations.\n\n> **Design Principle**: Defense in depth requires protecting against the most sophisticated attackers while maintaining usability. If our system can resist nation-state level attacks, it will easily handle lesser threats.\n\n**Attack Scenarios and System Response**\n\nConsider a data breach where attackers gain access to our password database. The attack progression depends on our security implementations:\n\n1. **Database Extraction**: Attackers export user authentication data containing usernames and password hashes\n2. **Hash Analysis**: They analyze the hash format to identify the algorithm, salt presence, and iteration parameters  \n3. **Attack Preparation**: Based on the analysis, they select appropriate cracking tools and resource allocation\n4. **Credential Recovery**: They execute brute force, dictionary, or rule-based attacks to recover plaintext passwords\n5. **Credential Validation**: Recovered passwords are tested against the original system and other services\n6. **Account Takeover**: Successful password recovery enables unauthorized access to user accounts\n\n| Attack Scenario | Attacker Resources | Attack Duration | Success Rate vs Our System |\n|----------------|-------------------|-----------------|---------------------------|\n| Rainbow table (unsalted SHA256) | Personal computer | Minutes | 90%+ of common passwords |\n| Dictionary attack (salted SHA256) | GPU rig | Days | 60-80% of weak passwords |\n| Brute force (PBKDF2, 100k iterations) | GPU farm | Weeks | 20-40% of weak passwords |\n| Advanced rules (bcrypt, cost 12) | Specialized hardware | Months | 5-15% of weak passwords |\n| Quantum-resistant (Argon2id, high memory) | Nation-state resources | Years | <5% of weak passwords |\n\n**Insider Threat Considerations**\n\nInsider threats represent a unique challenge because insiders may have elevated access to systems and data. A malicious administrator could potentially access password hashes directly from database backups, memory dumps, or log files. Our system must protect against insider threats through several mechanisms:\n\n- Password hashes remain computationally expensive to crack even with administrator access\n- Audit logging captures all access to authentication data\n- Separation of duties prevents single administrators from accessing both encrypted backups and decryption keys\n- Time-based security ensures that even compromised hashes become less valuable as users change passwords\n\n### Existing Approaches Comparison\n\nUnderstanding the evolution of password storage approaches provides critical context for our design decisions. Each approach represents a response to attacks against its predecessors, building layers of protection against increasingly sophisticated threats.\n\n**Plain Text Storage** offers no cryptographic protection but maximum simplicity. Legacy systems sometimes used plain text for debugging convenience or due to developer inexperience. The complete lack of security makes this approach unsuitable for any production system, but understanding it provides a baseline for comparison.\n\n**Simple Cryptographic Hashing** applies one-way functions like MD5, SHA-1, or SHA-256 directly to passwords. The mathematical properties of cryptographic hash functions make password recovery theoretically difficult — finding an input that produces a specific hash output requires trying numerous possibilities. However, this approach fails against precomputed attacks because identical passwords always produce identical hashes.\n\nThe fundamental weakness lies in the deterministic nature of cryptographic hashes. When millions of users choose \"password123\" as their password, all produce the same SHA-256 hash. An attacker can precompute hashes for common passwords and instantly identify users with those passwords in any breached database.\n\n> **Architecture Decision: Salt Requirement**\n> - **Context**: Simple hashing fails against rainbow table attacks due to deterministic hash outputs\n> - **Options Considered**: \n>   1. Faster hashing with larger password requirements\n>   2. Salted hashing with random values per password\n>   3. Encrypted storage with shared keys\n> - **Decision**: Require unique random salt for each password\n> - **Rationale**: Salts make precomputed attacks impractical by ensuring unique hash outputs even for identical passwords, while maintaining the simplicity of one-way hashing\n> - **Consequences**: Increased storage requirements (salt + hash per password) but elimination of rainbow table vulnerabilities\n\n| Approach | Computation Speed | Precomputed Attack Resistance | Storage Requirements | Implementation Complexity |\n|----------|-------------------|------------------------------|---------------------|--------------------------|\n| Plain Text | Instant | None - no protection | Minimal | Trivial |\n| MD5 Hash | ~1 billion/sec/GPU | None - rainbow tables available | 32 bytes | Simple |\n| SHA-256 Hash | ~100 million/sec/GPU | None - rainbow tables available | 64 bytes | Simple |\n| SHA-256 + Salt | ~100 million/sec/GPU | High - unique hashes | 80+ bytes | Moderate |\n\n**Salted Hashing** addresses rainbow table attacks by concatenating a unique random value (salt) with each password before hashing. Even if two users choose identical passwords, their different salts produce completely different hash outputs. This forces attackers to compute password guesses individually for each user rather than using precomputed tables.\n\nEffective salting requires cryptographically secure random salt generation, adequate salt length (minimum 16 bytes), and salt storage alongside the hash for verification. The salt doesn't need to be secret — it can be stored in plain text in the same database as the hash. Its security comes from uniqueness, not secrecy.\n\nHowever, salted hashing with fast algorithms still enables high-speed brute force attacks against individual users. Modern GPUs can compute millions of salted SHA-256 hashes per second, making weak passwords vulnerable within reasonable time frames.\n\n**Key Stretching Algorithms** like PBKDF2, bcrypt, and scrypt intentionally slow down hash computation to make brute force attacks more expensive. Instead of computing a hash once, key stretching applies the hash function thousands or millions of times in sequence. This multiplicatively increases the computational cost for both legitimate verification and attacker password guessing.\n\nPBKDF2 (Password-Based Key Derivation Function 2) applies a pseudorandom function (typically HMAC-SHA256) iteratively. The iteration count parameter allows tuning the computational cost to match available hardware capabilities. Increasing the iteration count proportionally increases both verification time and brute force attack time.\n\n> **Architecture Decision: Minimum Iteration Count**\n> - **Context**: PBKDF2 security depends on sufficient iterations to slow brute force attacks\n> - **Options Considered**:\n>   1. Fixed 10,000 iterations (fast but potentially weak)\n>   2. Configurable minimum 100,000 iterations (balanced)\n>   3. Dynamic iteration count targeting specific verification time\n> - **Decision**: Configurable minimum 100,000 iterations with ability to increase\n> - **Rationale**: 100,000 iterations provides reasonable protection against current GPU capabilities while allowing future increases as hardware improves\n> - **Consequences**: Longer verification times (100-500ms) but significant increase in brute force attack cost\n\n**Modern Adaptive Hashing** algorithms like bcrypt, scrypt, and Argon2 incorporate additional security features beyond simple iteration counting. These algorithms adapt to hardware capabilities and include memory-hard components that resist specialized attack hardware.\n\nbcrypt incorporates both time cost (iteration rounds) and built-in salt management. Its key innovation is adaptive cost — the work factor can be increased over time as hardware capabilities improve. bcrypt's design also includes resistance to timing attacks and side-channel analysis.\n\nArgon2 represents the current state-of-the-art in password hashing. It incorporates three cost parameters: time cost (iterations), memory cost (RAM usage), and parallelism (thread count). The memory-hard property makes attacks expensive even with specialized hardware like ASICs or FPGAs, which typically have limited memory compared to general-purpose computers.\n\n| Algorithm | Time Cost Control | Memory Cost | Parallel Resistance | Hardware Resistance | Standardization |\n|-----------|------------------|-------------|--------------------|--------------------|-----------------|\n| PBKDF2 | Iteration count | Minimal | Good | Limited - GPU friendly | NIST approved |\n| bcrypt | Work factor (2^n) | Moderate | Good | Good - memory access patterns | Widely deployed |\n| scrypt | Time + memory parameters | High - configurable | Moderate | Excellent - memory hard | Some adoption |\n| Argon2 | Time + memory + threads | High - configurable | Excellent | Excellent - memory hard | PHC winner |\n\n**Comparative Security Analysis**\n\nThe security effectiveness of each approach depends on the attacker's computational resources and time constraints. Against a moderately resourced attacker with GPU hardware, the time required to crack passwords varies dramatically:\n\nFor a 8-character mixed-case alphanumeric password against different storage methods:\n- Plain text: Instant compromise upon data access\n- MD5 hash: Seconds (rainbow table lookup)  \n- SHA-256 + salt: Hours (direct GPU brute force)\n- PBKDF2 (100k iterations): Weeks (GPU farm required)\n- bcrypt (cost 12): Months (significant computational investment)\n- Argon2id (high memory): Years (requires massive memory + computation)\n\n**Migration Strategy Considerations**\n\nReal-world systems often need to support multiple password hashing approaches simultaneously during migration periods. Users' passwords were hashed using different algorithms over the system's lifetime, and forcing all users to reset passwords during security upgrades creates poor user experience.\n\nAn effective migration strategy identifies the hashing algorithm used for each password and upgrades to stronger algorithms opportunistically during successful login attempts. When a user authenticates successfully using an older, weaker hash, the system immediately rehashes their password using the current strongest algorithm and updates the stored hash.\n\n> **Design Principle: Algorithm Agility**\n> Systems must support multiple hashing algorithms simultaneously and provide clear migration paths to stronger algorithms as cryptographic recommendations evolve.\n\nThis comparison analysis drives our architectural decisions to implement multiple hashing approaches with clear upgrade paths, starting from educational implementations (salted SHA-256) and progressing to production-grade security (bcrypt and Argon2).\n\n### Implementation Guidance\n\nUnderstanding password storage vulnerabilities and threats provides the foundation for implementing secure hashing systems. This guidance bridges the conceptual understanding to practical implementation decisions.\n\n**A. Technology Recommendations**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Random Generation | `os.urandom()` / `secrets` module | Hardware security module integration |\n| Hash Computation | `hashlib` standard library | Cryptographic acceleration libraries |\n| Key Stretching | `hashlib.pbkdf2_hmac()` built-in | Custom PBKDF2 with configurable PRF |\n| Modern Hashing | `bcrypt` library | `argon2-cffi` with memory tuning |\n| Constant-Time Comparison | `secrets.compare_digest()` | Custom implementation with timing analysis |\n| Storage Format | JSON serialization | Binary format with version headers |\n\n**B. Recommended File Structure**\n\n```\npassword-hashing/\n  src/\n    password_hash/\n      __init__.py              ← Public API exports\n      vulnerabilities.py       ← Demonstration of vulnerable approaches\n      threat_model.py          ← Attack simulation and testing\n      comparison.py            ← Algorithm comparison utilities\n    tests/\n      test_vulnerabilities.py  ← Tests demonstrating attack vectors\n      test_timing.py          ← Timing attack verification\n  examples/\n    vulnerable_examples.py     ← Educational examples of bad practices\n    secure_examples.py        ← Best practice demonstrations\n  docs/\n    vulnerability_analysis.md  ← Detailed attack documentation\n```\n\n**C. Infrastructure Starter Code**\n\n**Vulnerable Implementation Demonstrator** (Complete working code for educational purposes):\n\n```python\n\"\"\"\nEDUCATIONAL ONLY - Demonstrates password storage vulnerabilities\nDO NOT USE IN PRODUCTION - These implementations are intentionally insecure\n\"\"\"\nimport hashlib\nimport json\nimport time\nimport os\n\nclass VulnerablePasswordStorage:\n    \"\"\"Demonstrates common password storage vulnerabilities for educational analysis.\"\"\"\n    \n    def __init__(self):\n        self.users = {}\n    \n    def store_plaintext(self, username: str, password: str):\n        \"\"\"VULNERABLE: Stores password in plain text - never do this.\"\"\"\n        self.users[username] = {\n            'method': 'plaintext',\n            'password': password  # Critical vulnerability - readable password\n        }\n    \n    def store_simple_hash(self, username: str, password: str):\n        \"\"\"VULNERABLE: Simple hash without salt - vulnerable to rainbow tables.\"\"\"\n        password_hash = hashlib.sha256(password.encode()).hexdigest()\n        self.users[username] = {\n            'method': 'simple_hash',\n            'hash': password_hash  # Vulnerable to precomputed attacks\n        }\n    \n    def store_predictable_salt(self, username: str, password: str):\n        \"\"\"VULNERABLE: Uses predictable salt - enables targeted attacks.\"\"\"\n        salt = username.encode()  # Predictable salt based on username\n        salted = salt + password.encode()\n        password_hash = hashlib.sha256(salted).hexdigest()\n        self.users[username] = {\n            'method': 'predictable_salt',\n            'salt': salt.hex(),\n            'hash': password_hash\n        }\n    \n    def verify_with_timing_leak(self, username: str, password: str) -> bool:\n        \"\"\"VULNERABLE: Timing attack via non-constant-time comparison.\"\"\"\n        if username not in self.users:\n            return False\n        \n        stored = self.users[username]\n        if stored['method'] == 'simple_hash':\n            candidate_hash = hashlib.sha256(password.encode()).hexdigest()\n            # VULNERABILITY: Character-by-character comparison leaks timing info\n            return self._naive_string_compare(stored['hash'], candidate_hash)\n        \n        return False\n    \n    def _naive_string_compare(self, a: str, b: str) -> bool:\n        \"\"\"VULNERABLE: Returns immediately on first mismatch - enables timing attacks.\"\"\"\n        if len(a) != len(b):\n            return False\n        for i in range(len(a)):\n            if a[i] != b[i]:\n                return False  # Early return leaks position of mismatch\n        return True\n\nclass AttackSimulator:\n    \"\"\"Simulates common attacks against password storage for educational purposes.\"\"\"\n    \n    @staticmethod\n    def rainbow_table_attack(hash_list: list) -> dict:\n        \"\"\"Simulates rainbow table lookup for common passwords.\"\"\"\n        common_passwords = ['password', '123456', 'password123', 'admin', 'letmein']\n        rainbow_table = {}\n        \n        # Build rainbow table for common passwords\n        for pwd in common_passwords:\n            hash_value = hashlib.sha256(pwd.encode()).hexdigest()\n            rainbow_table[hash_value] = pwd\n        \n        # Attempt to crack hashes\n        cracked = {}\n        for hash_val in hash_list:\n            if hash_val in rainbow_table:\n                cracked[hash_val] = rainbow_table[hash_val]\n        \n        return cracked\n    \n    @staticmethod\n    def timing_attack_demo(storage: VulnerablePasswordStorage, username: str) -> dict:\n        \"\"\"Demonstrates timing attack against non-constant-time comparison.\"\"\"\n        if username not in storage.users:\n            return {'error': 'User not found'}\n        \n        timings = {}\n        test_passwords = ['a', 'ab', 'abc', 'abcd', 'abcde']  # Progressively longer\n        \n        for pwd in test_passwords:\n            start_time = time.perf_counter()\n            storage.verify_with_timing_leak(username, pwd)\n            end_time = time.perf_counter()\n            timings[pwd] = end_time - start_time\n        \n        return timings\n```\n\n**D. Core Logic Skeleton Code**\n\n```python\nclass SecurePasswordAnalyzer:\n    \"\"\"Analyze and demonstrate secure password storage principles.\"\"\"\n    \n    def analyze_hash_strength(self, password_hash: str, algorithm: str, \n                            salt: str = None, iterations: int = None) -> dict:\n        \"\"\"\n        Analyze the cryptographic strength of a password hash configuration.\n        \n        Args:\n            password_hash: The hash value to analyze\n            algorithm: Hash algorithm used ('md5', 'sha256', 'pbkdf2', 'bcrypt', 'argon2')\n            salt: Salt value if used\n            iterations: Iteration count if applicable\n            \n        Returns:\n            Dictionary with strength analysis and recommendations\n        \"\"\"\n        # TODO 1: Validate algorithm type and identify known vulnerabilities\n        # TODO 2: Check salt quality - length, randomness, uniqueness\n        # TODO 3: Evaluate iteration count against current hardware capabilities\n        # TODO 4: Calculate estimated brute force time for different attack scenarios\n        # TODO 5: Provide specific recommendations for improvement\n        # TODO 6: Generate security score (1-100) based on all factors\n        pass\n    \n    def simulate_attack_cost(self, algorithm: str, iterations: int, \n                           hardware_type: str) -> dict:\n        \"\"\"\n        Calculate computational cost for brute force attacks.\n        \n        Args:\n            algorithm: Hash algorithm ('pbkdf2', 'bcrypt', 'argon2')\n            iterations: Number of iterations/rounds\n            hardware_type: 'cpu', 'gpu', 'asic', 'quantum'\n            \n        Returns:\n            Cost analysis with time estimates and hardware requirements\n        \"\"\"\n        # TODO 1: Define hash rates for different algorithm/hardware combinations\n        # TODO 2: Calculate hashes per second for given configuration  \n        # TODO 3: Estimate time to crack passwords of different strengths\n        # TODO 4: Calculate monetary cost based on hardware and electricity\n        # TODO 5: Factor in memory requirements for memory-hard algorithms\n        # TODO 6: Provide timeline estimates (hours/days/months/years)\n        pass\n        \n    def compare_algorithms(self, password: str) -> dict:\n        \"\"\"\n        Compare multiple hashing algorithms applied to the same password.\n        \n        Args:\n            password: Test password to hash with different algorithms\n            \n        Returns:\n            Comparison matrix showing security properties and performance\n        \"\"\"\n        # TODO 1: Generate secure random salt for each algorithm test\n        # TODO 2: Hash password using MD5, SHA256, PBKDF2, bcrypt, Argon2\n        # TODO 3: Measure computation time for each algorithm\n        # TODO 4: Calculate attack resistance estimates\n        # TODO 5: Analyze storage requirements for each approach\n        # TODO 6: Create recommendation matrix for different use cases\n        pass\n```\n\n**E. Language-Specific Hints**\n\n- **Secure Random Generation**: Use `secrets.token_bytes(32)` for cryptographically secure salt generation, never `random.randint()`\n- **Hash Libraries**: `hashlib` provides basic cryptographic hashes, `bcrypt` and `argon2-cffi` for advanced algorithms\n- **Timing Attack Prevention**: Always use `secrets.compare_digest()` for hash comparison - it runs in constant time\n- **Memory Management**: Clear password variables after use with `del password` to minimize plaintext exposure time\n- **Error Handling**: Never leak timing information through different error paths - authenticate() should take the same time whether user exists or not\n\n**F. Milestone Checkpoint**\n\nAfter implementing vulnerability demonstrations and attack simulations:\n\n**Test Command**: `python -m pytest tests/test_vulnerabilities.py -v`\n\n**Expected Behavior**:\n- Rainbow table attack should crack simple MD5/SHA256 hashes of common passwords within seconds\n- Timing attack demonstration should show measurable time differences for wrong password lengths\n- Salt analysis should correctly identify predictable vs random salts\n- Attack cost calculator should provide realistic time estimates for different scenarios\n\n**Manual Verification**:\n1. Run `python examples/vulnerable_examples.py` and observe that common passwords are cracked instantly\n2. Test timing attack demo - verify that longer incorrect passwords take slightly more time to reject\n3. Compare hash outputs - same password with different salts should produce completely different hashes\n\n**Signs of Problems**:\n- **All hashes look similar**: Salt generation may not be truly random\n- **Timing attack shows no difference**: System timer resolution may be insufficient or comparison is already constant-time\n- **Rainbow table attack fails**: Password list may be too complex or hash format incorrect\n\n\n## Goals and Non-Goals\n\n> **Milestone(s):** All milestones (foundational scope definition underlying the entire project)\n\n### Mental Model: The Security Perimeter Analogy\n\nThink of designing a password hashing system like building a secure vault. Your primary job is to protect the vault's contents (passwords) using sophisticated locking mechanisms (cryptographic hashing). However, you're not responsible for the entire bank building - you don't need to design the customer lobby (user interface), the teller windows (authentication workflows), or the alarm system monitoring (logging infrastructure). Your vault must have specific interfaces where other systems can interact with it, but your core responsibility is ensuring that even if someone breaks into the bank, they cannot extract usable passwords from your vault.\n\nThis analogy helps clarify the boundaries of our password hashing system. We focus intensely on the cryptographic protection mechanisms while providing clean interfaces for integration with broader authentication systems.\n\n### Core Goals\n\nThe password hashing system must accomplish several critical security and usability objectives. These goals directly map to the three milestone progression, building from basic cryptographic primitives to production-ready password protection.\n\n| Goal Category | Specific Objective | Success Criteria | Related Milestone |\n|---------------|-------------------|------------------|-------------------|\n| Cryptographic Security | Prevent rainbow table attacks | Generate cryptographically secure random salt of at least 16 bytes per password | Milestone 1 |\n| Cryptographic Security | Resist brute force attacks | Implement configurable key stretching with minimum 100,000 PBKDF2 iterations | Milestone 2 |\n| Cryptographic Security | Use industry-standard algorithms | Support bcrypt with configurable cost factor and optionally Argon2id | Milestone 3 |\n| Side-Channel Resistance | Prevent timing attacks | Implement constant-time password comparison preventing information leakage | Milestone 2 |\n| Algorithm Agility | Support multiple hash algorithms | Enable migration between SHA-256, PBKDF2, bcrypt, and Argon2 without breaking existing passwords | Milestone 3 |\n| Performance Tuning | Balance security and usability | Provide utilities to tune algorithm parameters based on target hardware performance | Milestone 3 |\n| Data Integrity | Preserve algorithm parameters | Store all necessary information (salt, iterations, algorithm identifier) for future verification | All Milestones |\n| Integration Ready | Clean API boundaries | Provide simple register/verify interface that external systems can easily consume | All Milestones |\n\n#### Security Goal Deep Dive\n\nThe security objectives require careful consideration of threat models and attack vectors. **Rainbow table prevention** means that identical passwords must produce different stored hashes, achieved through unique salt generation using cryptographically secure random number generators. The system must generate salts with sufficient entropy - a minimum of 16 bytes provides 128 bits of randomness, making precomputed attacks computationally infeasible.\n\n**Brute force resistance** requires making password verification computationally expensive for attackers while remaining reasonable for legitimate authentication. Key stretching algorithms like PBKDF2 achieve this by performing many iterations of cryptographic operations. The system must support configurable iteration counts, with a minimum of 100,000 PBKDF2-HMAC-SHA256 iterations to meet current security recommendations.\n\n**Side-channel attack prevention** addresses subtle information leakage through execution timing differences. When comparing a provided password against a stored hash, the comparison operation must take the same amount of time regardless of where the passwords differ, preventing attackers from gradually discovering correct password characters through timing measurements.\n\n> **Decision: Multi-Algorithm Support Strategy**\n> - **Context**: Password hashing recommendations evolve as computing power increases and new attacks are discovered\n> - **Options Considered**: Single algorithm (simple but inflexible), plugin architecture (complex but extensible), built-in multi-algorithm support (moderate complexity, good flexibility)\n> - **Decision**: Built-in support for SHA-256+salt, PBKDF2, bcrypt, and Argon2 with migration utilities\n> - **Rationale**: Provides upgrade paths for deployed systems while keeping implementation complexity manageable for learning purposes\n> - **Consequences**: Enables real-world deployment scenarios but requires careful parameter management and format parsing\n\n| Algorithm Option | Implementation Complexity | Security Properties | Adoption Timeline |\n|-------------------|--------------------------|-------------------|-------------------|\n| SHA-256 + Salt | Low - basic cryptographic primitives | Vulnerable to specialized hardware attacks | Educational only |\n| PBKDF2 | Medium - requires iteration management | Good general-purpose security | Legacy systems |\n| bcrypt | Low - well-tested library integration | Excellent security with automatic salt | Current standard |\n| Argon2id | Medium - memory parameter tuning | Best-in-class memory-hard function | Future-proofing |\n\n### Integration Goals\n\nThe password hashing system must integrate cleanly with external authentication systems without imposing architectural constraints on the consuming application. This requires well-defined interface boundaries and data formats.\n\n**API Simplicity** means external systems should interact with the password hasher through two primary operations: `register_password(username, password) -> stored_hash` and `verify_password(username, password, stored_hash) -> boolean`. The complexity of salt generation, algorithm selection, and parameter tuning should be hidden behind these simple interfaces.\n\n**Format Compatibility** requires that stored password hashes include all necessary metadata for future verification. The system must encode the algorithm identifier, parameters (iterations, cost factors, memory settings), salt, and hash result in a single string that can be stored in existing database schemas without requiring additional columns.\n\n**Migration Support** acknowledges that password databases evolve over time. The system must detect legacy hash formats and provide upgrade paths, potentially re-hashing passwords with stronger algorithms during successful authentication attempts.\n\n### Performance Goals\n\nPerformance objectives balance security requirements with user experience expectations. Authentication systems typically target sub-100ms response times for password verification, which constrains the computational complexity of hashing algorithms.\n\n| Performance Metric | Target Value | Rationale |\n|-------------------|--------------|-----------|\n| Verification Time | 50-200ms on modern CPU | Fast enough for interactive login, slow enough to limit brute force |\n| Memory Usage | < 64MB per verification | Reasonable for web applications, prevents memory exhaustion attacks |\n| Concurrent Verifications | Support 100+ simultaneous | Handles typical web application load patterns |\n| Parameter Tuning | < 1 second benchmark runs | Enables administrators to configure optimal security/performance balance |\n\n**Adaptive Performance Tuning** means the system should provide utilities to measure actual hashing performance on deployment hardware, recommending optimal parameters for bcrypt cost factors, Argon2 memory settings, and PBKDF2 iteration counts. This addresses the reality that security recommendations must adapt to hardware capabilities.\n\n### Educational Goals\n\nSince this project serves as a learning vehicle for cryptographic security concepts, the implementation must clearly demonstrate security principles and common vulnerabilities.\n\n**Vulnerability Demonstration** requires implementing deliberately insecure approaches alongside secure ones, showing why plain text storage, simple hashing, and predictable salts are inadequate. The `VulnerablePasswordStorage` class demonstrates these anti-patterns with methods like `store_plaintext()`, `store_simple_hash()`, and `store_predictable_salt()`.\n\n**Attack Simulation** capabilities help learners understand threat models through concrete examples. The `AttackSimulator` class provides methods like `rainbow_table_attack()` and `timing_attack_demo()` that demonstrate how these attacks work against vulnerable implementations.\n\n**Security Analysis Tools** enable learners to evaluate the strength of different approaches. The `SecurePasswordAnalyzer` class offers methods like `analyze_hash_strength()` and `compare_algorithms()` that quantify security properties and attack costs.\n\n### Explicit Non-Goals\n\nDefining what this system does NOT handle prevents scope creep and clarifies integration boundaries. These non-goals are equally important as the goals themselves.\n\n#### Authentication System Non-Goals\n\nThe password hashing system explicitly does not implement broader authentication concerns:\n\n| Non-Goal Area | Specific Exclusions | Rationale |\n|---------------|-------------------|-----------|\n| Session Management | Login sessions, tokens, cookies | Separate concern with different security properties |\n| User Management | User registration, profile storage, account lifecycle | Database and business logic concerns outside cryptography scope |\n| Password Policy | Strength validation, complexity requirements, history tracking | Policy enforcement is application-specific |\n| Account Security | Lockouts, rate limiting, breach detection | Requires application-level state management |\n| Multi-Factor Authentication | TOTP, SMS codes, hardware tokens | Different cryptographic techniques and user experience flows |\n| Authorization | Permissions, roles, access control | Separate security domain after authentication |\n\n#### Database Integration Non-Goals\n\nWhile the system must produce data suitable for database storage, it does not handle database-specific concerns:\n\n**Schema Management**: The system provides serialized hash strings but does not define database schemas, manage migrations, or handle indexing strategies. Applications must design appropriate user tables and password storage columns.\n\n**Connection Management**: Database connectivity, connection pooling, transaction management, and error handling remain application responsibilities. The password hasher is a pure function that transforms inputs to outputs.\n\n**Query Optimization**: While hash verification must be fast, optimizing database queries for user lookup, implementing caching strategies, or managing read replicas are application concerns.\n\n#### Deployment and Operations Non-Goals\n\nOperational concerns remain outside the password hashing system scope:\n\n**Monitoring and Alerting**: While the system may log security events, implementing comprehensive monitoring, alerting on suspicious activity, or integrating with SIEM systems are infrastructure concerns.\n\n**Configuration Management**: The system accepts configuration parameters but does not handle configuration file parsing, environment variable management, or dynamic configuration updates.\n\n**Performance Monitoring**: While the system provides tuning utilities, production performance monitoring, capacity planning, and auto-scaling decisions are operational responsibilities.\n\n#### Security Infrastructure Non-Goals\n\nCertain security concerns remain outside scope despite their relevance to password protection:\n\n**Breach Response**: If a password database is compromised, coordinating user notifications, forced password resets, and forensic analysis are incident response activities beyond the hashing system's scope.\n\n**Compliance Reporting**: While the system implements security best practices, generating compliance reports, audit trails, or regulatory documentation are governance concerns.\n\n**Network Security**: Protecting passwords in transit through TLS, implementing certificate management, or preventing network-level attacks are transport layer responsibilities.\n\n### Architecture Decision: Scope Boundaries\n\n> **Decision: Minimal Core with Clean Integration Points**\n> - **Context**: Balancing educational clarity with real-world applicability while preventing scope creep\n> - **Options Considered**: Monolithic authentication system (too complex for learning), bare cryptographic primitives (insufficient for practical use), focused password hashing with integration interfaces (balanced approach)\n> - **Decision**: Implement core password hashing functionality with well-defined interfaces for external integration\n> - **Rationale**: Allows learners to focus on cryptographic concepts while producing components suitable for real applications\n> - **Consequences**: Requires careful interface design but enables integration with diverse authentication architectures\n\nThis scope decision directly influences the component architecture and testing strategy. By focusing intensely on password hashing while providing clean interfaces, learners can master cryptographic security concepts without getting overwhelmed by authentication system complexity.\n\n### Success Metrics\n\nThe system's success will be measured through specific, testable criteria that align with both educational and practical objectives:\n\n| Success Category | Measurement Criteria | Verification Method |\n|------------------|---------------------|-------------------|\n| Security Implementation | All stored passwords use unique salts | Automated test verifying no salt reuse across 1000+ passwords |\n| Security Implementation | Timing attacks fail against verification | Benchmark showing constant verification time regardless of password similarity |\n| Algorithm Support | Multiple algorithms work correctly | Test suite verifying SHA-256, PBKDF2, bcrypt, and Argon2 implementations |\n| Performance Tuning | Parameters optimize for target hardware | Utility that recommends cost factors achieving 100ms verification time |\n| Migration Support | Legacy hashes upgrade transparently | Test demonstrating seamless upgrade from PBKDF2 to bcrypt during authentication |\n| Educational Value | Vulnerability demonstrations work | Attack simulations successfully exploit insecure implementations |\n\n### Common Pitfalls in Goal Definition\n\n⚠️ **Pitfall: Scope Creep into Authentication Systems**\nMany implementations attempt to solve broader authentication problems, creating unnecessary complexity. This occurs when developers think \"since I'm handling passwords, I should also handle user sessions.\" This leads to mixing cryptographic logic with web application concerns, making the code harder to understand and test. Instead, maintain strict boundaries - the password hasher transforms passwords into secure storage formats and verifies them, nothing more.\n\n⚠️ **Pitfall: Underestimating Performance Goals**\nDevelopers often focus exclusively on security without considering performance implications, leading to authentication systems that timeout under load. Setting overly aggressive security parameters (like 1 million PBKDF2 iterations) can make systems unusable. Always benchmark on target hardware and consider concurrent load when setting algorithm parameters.\n\n⚠️ **Pitfall: Ignoring Migration Requirements**\nInitial implementations often assume they'll use the same algorithm forever, creating no upgrade path for stronger algorithms. This leaves deployed systems stuck with weakening security over time. Always design hash formats to include algorithm identifiers and version information, enabling future upgrades.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Cryptographic Library | Python `hashlib` + `secrets` | Python `cryptography` package |\n| Random Generation | `secrets.token_bytes()` for salt | Hardware RNG integration |\n| Algorithm Support | Built-in `hashlib.pbkdf2_hmac()` | `bcrypt` and `argon2` packages |\n| Performance Measurement | `time.time()` for basic benchmarks | `timeit` module for precise measurements |\n| Data Serialization | Base64 encoding for hash storage | Custom binary format with length prefixes |\n\n#### Project Structure for Goals Implementation\n\n```python\npassword_hashing/\n  __init__.py                    # Main API exports\n  goals/\n    __init__.py\n    security_goals.py            # Security objective verification\n    performance_goals.py         # Performance measurement utilities  \n    educational_goals.py         # Vulnerability demonstrations\n  core/\n    __init__.py\n    hasher.py                   # Main password hashing implementation\n    vulnerabilities.py          # Deliberately insecure implementations\n    analysis.py                 # Security analysis tools\n  tests/\n    test_goals.py               # Goal verification tests\n    test_security_properties.py # Cryptographic property tests\n    test_performance.py         # Performance benchmark tests\n```\n\n#### Goal Verification Starter Code\n\n```python\n# password_hashing/goals/security_goals.py\n\"\"\"Security goal verification utilities.\"\"\"\n\nimport secrets\nimport time\nfrom typing import Dict, List, Tuple\nfrom ..core.hasher import SecurePasswordHasher\nfrom ..core.vulnerabilities import VulnerablePasswordStorage\n\nclass SecurityGoalVerifier:\n    \"\"\"Verifies that security objectives are met.\"\"\"\n    \n    def __init__(self):\n        self.secure_hasher = SecurePasswordHasher()\n        self.vulnerable_storage = VulnerablePasswordStorage()\n    \n    def verify_salt_uniqueness(self, password_count: int = 1000) -> Dict[str, bool]:\n        \"\"\"Verify that identical passwords produce unique hashes.\n        \n        Args:\n            password_count: Number of identical passwords to hash\n            \n        Returns:\n            Dict with verification results and statistics\n        \"\"\"\n        # TODO 1: Hash the same password multiple times using secure hasher\n        # TODO 2: Extract salt values from each hash result\n        # TODO 3: Verify all salts are unique (no duplicates)\n        # TODO 4: Calculate entropy statistics for salt randomness\n        # TODO 5: Return verification results with pass/fail status\n        pass\n    \n    def verify_timing_attack_resistance(self, username: str) -> Dict[str, bool]:\n        \"\"\"Verify that password verification takes constant time.\n        \n        Args:\n            username: Test username for timing measurements\n            \n        Returns:\n            Dict with timing analysis and resistance verification\n        \"\"\"\n        # TODO 1: Store a test password hash for the username\n        # TODO 2: Measure verification time for correct password\n        # TODO 3: Measure verification time for incorrect passwords of various lengths\n        # TODO 4: Calculate timing variance across different inputs\n        # TODO 5: Verify variance is below threshold indicating constant-time behavior\n        pass\n```\n\n#### Performance Goal Implementation\n\n```python\n# password_hashing/goals/performance_goals.py\n\"\"\"Performance goal measurement and tuning utilities.\"\"\"\n\nimport time\nimport statistics\nfrom typing import Dict, List\nfrom ..core.hasher import SecurePasswordHasher\n\nclass PerformanceGoalTuner:\n    \"\"\"Measures and tunes password hashing performance.\"\"\"\n    \n    def __init__(self):\n        self.hasher = SecurePasswordHasher()\n        self.target_verification_time = 0.1  # 100ms target\n    \n    def benchmark_algorithm(self, algorithm: str, test_password: str = \"test123\") -> Dict[str, float]:\n        \"\"\"Benchmark hashing algorithm performance.\n        \n        Args:\n            algorithm: Algorithm name ('pbkdf2', 'bcrypt', 'argon2')\n            test_password: Password to use for benchmarking\n            \n        Returns:\n            Dict with timing statistics and recommended parameters\n        \"\"\"\n        # TODO 1: Configure algorithm with default parameters\n        # TODO 2: Run multiple hash operations measuring execution time\n        # TODO 3: Calculate mean, median, and standard deviation of timing\n        # TODO 4: Determine parameter adjustments to hit target timing\n        # TODO 5: Return timing statistics and recommended configuration\n        pass\n    \n    def tune_parameters_for_hardware(self) -> Dict[str, int]:\n        \"\"\"Automatically tune algorithm parameters for current hardware.\n        \n        Returns:\n            Dict mapping algorithm names to recommended parameters\n        \"\"\"\n        # TODO 1: Benchmark each supported algorithm with default parameters\n        # TODO 2: Adjust parameters (iterations, cost, memory) based on timing\n        # TODO 3: Verify adjusted parameters still meet minimum security requirements\n        # TODO 4: Return recommended parameter configuration\n        pass\n```\n\n#### Educational Goal Demonstrations\n\n```python\n# password_hashing/goals/educational_goals.py\n\"\"\"Educational demonstrations of security concepts.\"\"\"\n\nfrom typing import Dict, List\nfrom ..core.vulnerabilities import VulnerablePasswordStorage, AttackSimulator\n\nclass SecurityEducationDemos:\n    \"\"\"Demonstrates security concepts through working examples.\"\"\"\n    \n    def __init__(self):\n        self.vulnerable = VulnerablePasswordStorage()\n        self.attacker = AttackSimulator()\n    \n    def demonstrate_rainbow_table_attack(self) -> Dict[str, any]:\n        \"\"\"Show how rainbow tables crack unsalted hashes.\n        \n        Returns:\n            Dict with attack results and educational insights\n        \"\"\"\n        # TODO 1: Create several user accounts with simple passwords using store_simple_hash\n        # TODO 2: Extract the unsalted hashes from storage\n        # TODO 3: Use AttackSimulator.rainbow_table_attack to crack hashes\n        # TODO 4: Show which passwords were cracked and why\n        # TODO 5: Contrast with salted hash security\n        pass\n    \n    def demonstrate_timing_attack(self) -> Dict[str, any]:\n        \"\"\"Show how timing differences leak password information.\n        \n        Returns:\n            Dict with attack results demonstrating information leakage\n        \"\"\"\n        # TODO 1: Store a test password using vulnerable timing-leak verification\n        # TODO 2: Use AttackSimulator.timing_attack_demo to measure timing differences\n        # TODO 3: Show how timing varies based on password similarity\n        # TODO 4: Demonstrate gradual password discovery through timing\n        # TODO 5: Contrast with constant-time verification\n        pass\n```\n\n#### Milestone Checkpoints\n\n**Milestone 1 Checkpoint - Basic Security Goals:**\n- Run `python -m pytest tests/test_goals.py::test_salt_uniqueness` - should verify 1000 identical passwords produce unique hashes\n- Execute `python -c \"from password_hashing.goals.educational_goals import *; demo = SecurityEducationDemos(); print(demo.demonstrate_rainbow_table_attack())\"` - should show successful rainbow table attack against unsalted hashes\n- Verify that `MINIMUM_SALT_LENGTH` constant is set to 16 bytes minimum\n\n**Milestone 2 Checkpoint - Performance and Timing Goals:**\n- Run performance tuner: `python -c \"from password_hashing.goals.performance_goals import *; tuner = PerformanceGoalTuner(); print(tuner.benchmark_algorithm('pbkdf2'))\"` - should complete within target timing\n- Execute timing attack resistance test - should show constant verification time regardless of password differences\n- Verify `PBKDF2_MIN_ITERATIONS` meets 100,000 minimum requirement\n\n**Milestone 3 Checkpoint - Algorithm Agility Goals:**\n- Test algorithm migration: create password with PBKDF2, verify successful upgrade to bcrypt during authentication\n- Benchmark all algorithms: `tuner.tune_parameters_for_hardware()` should return recommendations for bcrypt and Argon2\n- Verify `BCRYPT_MIN_COST` meets security recommendations for current hardware\n\n\n## High-Level Architecture\n\n> **Milestone(s):** All milestones (architectural foundation supporting all implementation phases)\n\n### Mental Model: The Security Checkpoint System Analogy\n\nThink of a secure password hashing system like a multi-stage security checkpoint at a high-security facility. When someone presents their credentials (password), they don't just get waved through with a simple ID check. Instead, their identity verification goes through multiple specialized stations, each with a specific security purpose:\n\n1. **Salt Generation Station** - Like issuing a unique, random visitor badge number that can't be predicted or reused, ensuring no two people get the same treatment even if they have the same name\n2. **Basic Hashing Station** - Like taking a photograph that transforms the person's appearance into a standardized format that can't be reversed back to the original\n3. **Key Stretching Station** - Like requiring the verification process to take a deliberately slow, resource-intensive amount of time to prevent someone from rapidly testing thousands of fake IDs\n4. **Modern Hashing Station** - Like using the latest biometric scanners with adaptive security that automatically adjusts difficulty based on current threat levels\n\nEach station has specialized equipment and trained personnel who excel at their specific security function. The stations work together in sequence, but each can be upgraded independently as security threats evolve. Most importantly, even if an attacker somehow gets access to the verification records, they can't use them to impersonate legitimate visitors because the transformation process can't be reversed.\n\nThis architectural approach provides **defense in depth** - multiple independent security barriers that an attacker must overcome, with each barrier specifically designed to defeat different attack methods like rainbow tables, brute force attempts, and timing analysis.\n\n### Component Overview\n\nThe password hashing system consists of four primary components that work together to transform user passwords into securely stored verification data. Each component has a focused responsibility and clear integration boundaries with the others.\n\n![Password Hashing System Components](./diagrams/system-components.svg)\n\n#### Core Components and Responsibilities\n\n| Component | Primary Responsibility | Security Property | Data Inputs | Data Outputs |\n|-----------|----------------------|-------------------|-------------|--------------|\n| `SaltGenerator` | Generate cryptographically secure random salts | Prevents rainbow table attacks | Entropy from OS random source | Unique random byte sequences |\n| `BasicHasher` | Apply SHA-256 hashing with salt concatenation | Provides one-way transformation | Password + salt | SHA-256 digest |\n| `KeyStretcher` | Apply PBKDF2 with configurable iterations | Slows brute force attacks | Password + salt + iteration count | Derived key bytes |\n| `ModernHasher` | Interface to bcrypt/Argon2 libraries | Production-grade memory-hard hashing | Password + algorithm parameters | Algorithm-specific hash format |\n\n#### Component Dependencies and Integration Boundaries\n\nThe components form a dependency hierarchy where later milestones build upon earlier ones, but each maintains clear integration boundaries:\n\n**SaltGenerator** serves as the foundation component with no dependencies. It encapsulates all OS-specific entropy gathering and provides a consistent interface for secure random generation across different platforms. The component guarantees that every salt it produces has sufficient entropy and length to prevent rainbow table attacks.\n\n**BasicHasher** depends on `SaltGenerator` for salt creation but implements its own hash computation logic. It handles the critical security requirement of salt concatenation order and provides constant-time comparison to prevent timing attacks. This component serves as the educational foundation for understanding core hashing concepts before moving to more sophisticated approaches.\n\n**KeyStretcher** also depends on `SaltGenerator` and implements the PBKDF2 algorithm with HMAC-SHA256. It introduces the concept of configurable computational cost through iteration counts and demonstrates how to balance security against performance. This component bridges the gap between basic hashing and production-ready approaches.\n\n**ModernHasher** represents the production-ready endpoint that integrates with established cryptographic libraries. It depends on `SaltGenerator` for consistency in salt handling but delegates the complex hashing logic to proven implementations like bcrypt and Argon2. This component emphasizes algorithm agility and migration planning.\n\n> **Decision: Layered Component Architecture**\n> - **Context**: Password hashing involves multiple distinct security concerns (randomness, transformation, timing resistance, algorithm evolution) that beginners need to understand incrementally\n> - **Options Considered**: \n>   1. Monolithic component handling all hashing logic\n>   2. Layered components with milestone-based progression\n>   3. Plugin-based architecture with interchangeable algorithms\n> - **Decision**: Layered components with clear dependencies and milestone alignment\n> - **Rationale**: Allows learners to build understanding progressively while maintaining clear separation of concerns. Each component can be tested independently and later components demonstrate evolution of security practices\n> - **Consequences**: Enables incremental learning but requires careful interface design to prevent scope creep between components\n\n#### Data Flow and Component Interactions\n\nPassword processing flows through the components in a predictable sequence, with each component adding a specific security transformation:\n\n1. **Registration Flow**: `SaltGenerator` creates unique salt → `[Chosen Hasher]` combines password and salt → Result stored with algorithm metadata\n2. **Verification Flow**: Stored hash retrieved with algorithm metadata → Same hasher recreates hash with provided password → Constant-time comparison determines match\n\nThe architecture supports **algorithm agility** by allowing different hasher components to be selected based on stored metadata, enabling seamless migration from basic approaches to production-grade algorithms as learners progress through milestones.\n\n#### Common Integration Patterns\n\n| Integration Pattern | Use Case | Components Involved | Benefits | Trade-offs |\n|-------------------|----------|-------------------|----------|------------|\n| Direct Component Chaining | Educational progression through milestones | All components in sequence | Clear learning path, explicit dependencies | More verbose integration code |\n| Factory Pattern | Algorithm selection based on stored metadata | `ModernHasher` with algorithm-specific implementations | Clean abstraction, easy algorithm switching | Additional indirection complexity |\n| Strategy Pattern | Runtime algorithm configuration | All hasher components implementing common interface | Flexible algorithm choice, consistent API | Interface design complexity |\n\n### Recommended File Structure\n\nThe codebase organization reflects the component architecture and supports both educational progression and maintainable code structure. The file layout separates core components from educational demonstrations and provides clear module boundaries.\n\n#### Project Root Structure\n\n```\npassword-hashing/\n├── README.md                          # Project overview and milestone roadmap\n├── requirements.txt                   # Python dependencies (bcrypt, argon2-cffi)\n├── main.py                           # CLI interface and usage examples\n├── config/\n│   └── security_settings.py         # Configurable security parameters\n├── src/\n│   ├── __init__.py\n│   ├── components/                   # Core hashing components\n│   │   ├── __init__.py\n│   │   ├── salt_generator.py         # Milestone 1: Secure random salt generation\n│   │   ├── basic_hasher.py          # Milestone 1: SHA-256 with salt\n│   │   ├── key_stretcher.py         # Milestone 2: PBKDF2 implementation\n│   │   └── modern_hasher.py         # Milestone 3: bcrypt/Argon2 integration\n│   ├── storage/                     # Hash storage and retrieval\n│   │   ├── __init__.py\n│   │   ├── hash_record.py           # Data models for stored hashes\n│   │   └── storage_manager.py       # Persistent storage interface\n│   ├── security/                    # Security analysis and verification\n│   │   ├── __init__.py\n│   │   ├── timing_safe.py           # Constant-time comparison utilities\n│   │   └── security_analyzer.py     # Hash strength analysis\n│   └── utils/                       # Common utilities\n│       ├── __init__.py\n│       ├── constants.py             # Security constants and minimums\n│       └── exceptions.py            # Custom exception types\n├── educational/                     # Educational demonstrations and attacks\n│   ├── __init__.py\n│   ├── vulnerable_storage.py        # Anti-patterns and vulnerability demos\n│   ├── attack_simulator.py          # Rainbow table and timing attack demos\n│   └── security_education.py       # Interactive security concept demonstrations\n├── tests/                          # Test suites organized by milestone\n│   ├── __init__.py\n│   ├── test_milestone1.py          # Basic hashing and salt tests\n│   ├── test_milestone2.py          # Key stretching and PBKDF2 tests\n│   ├── test_milestone3.py          # Modern hashing integration tests\n│   ├── security/\n│   │   ├── test_timing_attacks.py  # Timing attack resistance verification\n│   │   ├── test_salt_uniqueness.py # Salt randomness statistical tests\n│   │   └── test_performance.py     # Algorithm performance benchmarks\n│   └── integration/\n│       └── test_full_system.py     # End-to-end system integration tests\n└── docs/                          # Additional documentation\n    ├── milestones/                # Detailed milestone requirements\n    ├── security_analysis.md       # Security property verification\n    └── performance_tuning.md      # Algorithm parameter tuning guide\n```\n\n#### Component Module Design Rationale\n\n> **Decision: Component-Based Module Organization**\n> - **Context**: Educational project needs to support incremental learning while maintaining professional code organization standards\n> - **Options Considered**:\n>   1. Single file with all hashing logic\n>   2. Separate files by algorithm (sha256.py, pbkdf2.py, bcrypt.py)\n>   3. Component-based organization matching architectural boundaries\n> - **Decision**: Component-based modules with clear milestone alignment\n> - **Rationale**: Each component encapsulates a specific security responsibility and learning objective, making it easier to understand, test, and extend individual components\n> - **Consequences**: Slightly more complex imports but much clearer separation of concerns and better support for incremental development\n\n#### Educational Structure Integration\n\nThe `educational/` directory serves as a critical component for understanding security concepts through concrete examples. This separation ensures that demonstration code (including intentionally vulnerable implementations) doesn't accidentally get used in production while providing hands-on learning about security pitfalls.\n\n| Educational Module | Learning Purpose | Security Demonstrations | Integration with Core Components |\n|-------------------|------------------|------------------------|--------------------------------|\n| `VulnerablePasswordStorage` | Show common security mistakes | Plain text storage, unsalted hashes, predictable salts | Contrasts with secure implementations |\n| `AttackSimulator` | Demonstrate attack vectors | Rainbow table lookups, timing attacks, brute force cost analysis | Uses same interfaces as secure components for comparison |\n| `SecurityEducationDemos` | Interactive security concept exploration | Hash collision demonstrations, entropy visualization, algorithm comparison | Leverages core components to show security properties |\n\n#### Testing Strategy Integration\n\nThe test organization supports both milestone-based development and comprehensive security verification:\n\n**Milestone Tests** validate that each implementation phase meets its acceptance criteria and security requirements. These tests serve as automated checkpoints for learners to verify their implementations.\n\n**Security Tests** go beyond functional correctness to verify cryptographic properties like timing attack resistance, salt uniqueness, and proper entropy utilization. These tests help learners understand how to validate security properties programmatically.\n\n**Integration Tests** verify that components work together correctly and that the system maintains security properties when components are combined. This testing layer catches issues that might not appear when testing components in isolation.\n\n#### File Organization Benefits and Trade-offs\n\n| Organizational Decision | Benefits | Trade-offs | Mitigation Strategies |\n|------------------------|----------|------------|----------------------|\n| Separate component modules | Clear responsibility boundaries, easier testing, supports incremental learning | More import complexity, potential circular dependencies | Careful interface design, dependency injection patterns |\n| Educational code separation | Safe demonstration of vulnerabilities, clear contrast with secure approaches | Duplication of some interfaces, maintenance overhead | Shared interface definitions, automated consistency checks |\n| Milestone-aligned testing | Clear progression checkpoints, targeted feedback for learners | Test organization complexity, potential redundancy | Test utilities for common patterns, clear test naming conventions |\n\n### Common Pitfalls in Component Architecture\n\n⚠️ **Pitfall: Circular Dependencies Between Components**\nMany learners create circular dependencies by having `BasicHasher` import from `KeyStretcher` for \"shared utilities\" while `KeyStretcher` imports from `BasicHasher` for \"basic hashing operations.\" This breaks the clean milestone progression and makes testing difficult. Instead, extract shared utilities into the `utils/` package and maintain the clear dependency hierarchy: `SaltGenerator` → `BasicHasher` → `KeyStretcher` → `ModernHasher`.\n\n⚠️ **Pitfall: Mixing Educational and Production Code**\nLearners often put vulnerable demonstration code in the same modules as secure implementations, risking accidental use of insecure functions. The `educational/` directory separation prevents this by clearly marking demonstration code and ensuring it doesn't get imported into production paths.\n\n⚠️ **Pitfall: Component Responsibility Creep**\nA common mistake is having `SaltGenerator` also handle hash storage, or having `BasicHasher` implement its own salt generation. This violates separation of concerns and makes individual components harder to test and understand. Each component should have a single, well-defined responsibility aligned with its security purpose.\n\n⚠️ **Pitfall: Inadequate Integration Boundaries**\nWithout clear interfaces between components, learners often create tight coupling that prevents individual component testing and makes algorithm migration difficult. Define explicit interfaces for each component and use dependency injection to support testing and flexibility.\n\n### Implementation Guidance\n\nThis section provides concrete technical recommendations for implementing the component architecture in Python, including complete starter code for infrastructure components and detailed skeletons for the core learning components.\n\n#### Technology Recommendations\n\n| Component | Simple Option (Milestone 1-2) | Advanced Option (Milestone 3) |\n|-----------|-------------------------------|------------------------------|\n| Random Generation | `os.urandom()` + `secrets` module | Same (Python stdlib is sufficient) |\n| Basic Hashing | `hashlib.sha256()` | Same (part of learning objectives) |\n| Key Stretching | Custom PBKDF2 with `hashlib.pbkdf2_hmac()` | Same (educational implementation) |\n| Modern Hashing | `bcrypt` library | `bcrypt` + `argon2-cffi` libraries |\n| Storage Format | JSON with base64 encoding | Same (human-readable for debugging) |\n| Testing | `unittest` (stdlib) | `pytest` with security-specific assertions |\n\n#### Infrastructure Starter Code\n\n**File: `src/utils/constants.py`** (Complete implementation - copy and use)\n\n```python\n\"\"\"\nSecurity constants and minimum recommended values.\nThese values reflect current best practices as of 2024.\n\"\"\"\n\n# Salt generation requirements\nMINIMUM_SALT_LENGTH = 16  # bytes - cryptographic security requirement\nRECOMMENDED_SALT_LENGTH = 32  # bytes - provides extra security margin\n\n# Key stretching minimum requirements  \nPBKDF2_MIN_ITERATIONS = 100000  # OWASP 2024 recommendation for PBKDF2-HMAC-SHA256\nPBKDF2_RECOMMENDED_ITERATIONS = 600000  # Higher security margin\n\n# Modern hashing algorithm parameters\nBCRYPT_MIN_COST = 12  # 2^12 = 4096 iterations minimum\nBCRYPT_RECOMMENDED_COST = 14  # 2^14 = 16384 iterations for better security\n\n# Argon2 parameters (if implementing milestone 3 advanced option)\nARGON2_TIME_COST = 3  # iterations\nARGON2_MEMORY_COST = 65536  # 64 MB memory usage  \nARGON2_PARALLELISM = 1  # single thread for simplicity\n\n# Hash output format constants\nHASH_RECORD_VERSION = \"1.0\"  # for future algorithm migration support\nSUPPORTED_ALGORITHMS = [\"sha256\", \"pbkdf2\", \"bcrypt\", \"argon2id\"]\n\n# Security verification constants\nTIMING_ATTACK_TEST_SAMPLES = 1000  # statistical samples for timing analysis\nMIN_HASH_COMPUTATION_TIME_MS = 250  # minimum acceptable hash time for security\n```\n\n**File: `src/utils/exceptions.py`** (Complete implementation - copy and use)\n\n```python\n\"\"\"\nCustom exception types for password hashing operations.\nProvides specific error handling for different failure modes.\n\"\"\"\n\nclass PasswordHashingError(Exception):\n    \"\"\"Base exception for all password hashing operations.\"\"\"\n    pass\n\nclass SaltGenerationError(PasswordHashingError):\n    \"\"\"Raised when cryptographically secure salt generation fails.\"\"\"\n    pass\n\nclass HashComputationError(PasswordHashingError):\n    \"\"\"Raised when hash computation encounters an error.\"\"\"\n    pass\n\nclass AlgorithmNotSupportedError(PasswordHashingError):\n    \"\"\"Raised when requested hashing algorithm is not available.\"\"\"\n    def __init__(self, algorithm_name: str, supported_algorithms: list):\n        self.algorithm_name = algorithm_name\n        self.supported_algorithms = supported_algorithms\n        super().__init__(f\"Algorithm '{algorithm_name}' not supported. \"\n                        f\"Available: {', '.join(supported_algorithms)}\")\n\nclass InvalidHashFormatError(PasswordHashingError):\n    \"\"\"Raised when stored hash format cannot be parsed.\"\"\"\n    pass\n\nclass TimingAttackVulnerabilityError(PasswordHashingError):\n    \"\"\"Raised when timing attack vulnerability is detected during testing.\"\"\"\n    pass\n```\n\n**File: `src/security/timing_safe.py`** (Complete implementation - copy and use)\n\n```python\n\"\"\"\nTiming-safe comparison utilities to prevent timing attack vulnerabilities.\nThese functions ensure constant execution time regardless of input differences.\n\"\"\"\n\nimport hmac\nfrom typing import Union\n\ndef constant_time_compare(a: Union[str, bytes], b: Union[str, bytes]) -> bool:\n    \"\"\"\n    Compare two values in constant time to prevent timing attacks.\n    \n    Uses HMAC's constant-time comparison internally, which is implemented\n    to take the same amount of time regardless of where the first difference\n    appears in the compared values.\n    \n    Args:\n        a: First value to compare (string or bytes)\n        b: Second value to compare (string or bytes)\n        \n    Returns:\n        True if values are equal, False otherwise\n        \n    Security Note:\n        This function takes the same time to execute whether the values\n        match completely, differ in the first byte, or differ in the last byte.\n    \"\"\"\n    # Convert strings to bytes for consistent comparison\n    if isinstance(a, str):\n        a = a.encode('utf-8')\n    if isinstance(b, str):\n        b = b.encode('utf-8')\n    \n    # hmac.compare_digest provides cryptographically secure constant-time comparison\n    return hmac.compare_digest(a, b)\n\ndef verify_timing_safety(comparison_func, test_cases: list, tolerance_ms: float = 5.0) -> dict:\n    \"\"\"\n    Statistical test to verify that a comparison function has constant timing.\n    \n    Tests the comparison function with various inputs and measures execution time\n    to detect potential timing attack vulnerabilities.\n    \n    Args:\n        comparison_func: Function to test for timing safety\n        test_cases: List of (input1, input2, expected_result) tuples\n        tolerance_ms: Maximum acceptable timing variance in milliseconds\n        \n    Returns:\n        dict with timing analysis results and vulnerability assessment\n    \"\"\"\n    import time\n    import statistics\n    \n    timing_results = []\n    \n    for input1, input2, expected in test_cases:\n        start_time = time.perf_counter()\n        result = comparison_func(input1, input2)\n        end_time = time.perf_counter()\n        \n        execution_time_ms = (end_time - start_time) * 1000\n        timing_results.append({\n            'inputs': (input1, input2),\n            'expected': expected,\n            'actual': result,\n            'time_ms': execution_time_ms,\n            'correct': result == expected\n        })\n    \n    # Statistical analysis of timing variance\n    times = [r['time_ms'] for r in timing_results]\n    mean_time = statistics.mean(times)\n    std_dev = statistics.stdev(times) if len(times) > 1 else 0\n    max_variance = max(times) - min(times)\n    \n    is_timing_safe = max_variance <= tolerance_ms\n    \n    return {\n        'is_timing_safe': is_timing_safe,\n        'mean_time_ms': mean_time,\n        'std_deviation_ms': std_dev,\n        'max_variance_ms': max_variance,\n        'tolerance_ms': tolerance_ms,\n        'sample_count': len(timing_results),\n        'detailed_results': timing_results\n    }\n```\n\n#### Core Component Skeletons\n\n**File: `src/components/salt_generator.py`** (Skeleton - implement the TODOs)\n\n```python\n\"\"\"\nCryptographically secure salt generation for password hashing.\nMilestone 1: Provides foundation for all subsequent hashing operations.\n\"\"\"\n\nimport os\nimport secrets\nfrom typing import Optional\nfrom ..utils.constants import MINIMUM_SALT_LENGTH, RECOMMENDED_SALT_LENGTH\nfrom ..utils.exceptions import SaltGenerationError\n\nclass SaltGenerator:\n    \"\"\"\n    Generates cryptographically secure random salts for password hashing.\n    \n    Ensures each password gets a unique salt to prevent rainbow table attacks\n    and provides sufficient entropy for cryptographic security.\n    \"\"\"\n    \n    def __init__(self, default_length: int = RECOMMENDED_SALT_LENGTH):\n        \"\"\"\n        Initialize salt generator with configurable default length.\n        \n        Args:\n            default_length: Default salt length in bytes (minimum 16)\n        \"\"\"\n        # TODO 1: Validate that default_length meets MINIMUM_SALT_LENGTH requirement\n        # TODO 2: Store default_length as instance variable\n        # TODO 3: Verify that OS provides cryptographically secure randomness\n        # Hint: Check that os.urandom and secrets module are available\n        pass\n    \n    def generate_salt(self, length: Optional[int] = None) -> bytes:\n        \"\"\"\n        Generate a cryptographically secure random salt.\n        \n        Args:\n            length: Salt length in bytes (uses default if None)\n            \n        Returns:\n            Random salt bytes suitable for cryptographic use\n            \n        Raises:\n            SaltGenerationError: If secure random generation fails\n        \"\"\"\n        # TODO 1: Use provided length or fall back to default_length\n        # TODO 2: Validate length meets MINIMUM_SALT_LENGTH requirement  \n        # TODO 3: Generate random bytes using os.urandom() for cryptographic security\n        # TODO 4: Handle potential OS errors and raise SaltGenerationError with context\n        # TODO 5: Return the generated salt bytes\n        # Hint: os.urandom() can raise OSError if entropy is insufficient\n        pass\n    \n    def generate_salt_hex(self, length: Optional[int] = None) -> str:\n        \"\"\"\n        Generate salt and return as hexadecimal string for easy storage.\n        \n        Args:\n            length: Salt length in bytes (uses default if None)\n            \n        Returns:\n            Salt encoded as lowercase hexadecimal string\n        \"\"\"\n        # TODO 1: Call generate_salt() to get raw bytes\n        # TODO 2: Convert bytes to hexadecimal string using .hex() method\n        # TODO 3: Return hex string (will be 2x length due to hex encoding)\n        pass\n    \n    def validate_salt(self, salt: bytes) -> bool:\n        \"\"\"\n        Validate that provided salt meets security requirements.\n        \n        Args:\n            salt: Salt bytes to validate\n            \n        Returns:\n            True if salt meets security requirements, False otherwise\n        \"\"\"\n        # TODO 1: Check that salt is bytes type (not string)\n        # TODO 2: Verify salt length meets MINIMUM_SALT_LENGTH\n        # TODO 3: Return True if valid, False otherwise\n        # Note: We can't verify randomness, only length and type\n        pass\n```\n\n**File: `src/components/basic_hasher.py`** (Skeleton - implement the TODOs)\n\n```python\n\"\"\"\nBasic password hashing with SHA-256 and salt.\nMilestone 1: Foundation for understanding salted password hashing concepts.\n\"\"\"\n\nimport hashlib\nfrom typing import Dict, Any\nfrom .salt_generator import SaltGenerator\nfrom ..security.timing_safe import constant_time_compare\nfrom ..utils.exceptions import HashComputationError\n\nclass BasicHasher:\n    \"\"\"\n    Implements salted password hashing using SHA-256.\n    \n    Provides educational foundation for password hashing concepts including\n    salt concatenation, one-way transformation, and timing-safe verification.\n    \"\"\"\n    \n    def __init__(self, salt_generator: SaltGenerator):\n        \"\"\"\n        Initialize hasher with salt generation capability.\n        \n        Args:\n            salt_generator: SaltGenerator instance for creating salts\n        \"\"\"\n        # TODO 1: Store salt_generator as instance variable\n        # TODO 2: Set algorithm identifier for hash record metadata\n        self.algorithm = \"sha256\"  # Algorithm identifier for storage\n    \n    def hash_password(self, password: str, salt: bytes = None) -> Dict[str, Any]:\n        \"\"\"\n        Hash password with salt using SHA-256.\n        \n        Args:\n            password: Plain text password to hash\n            salt: Optional salt bytes (generates new salt if None)\n            \n        Returns:\n            Dictionary containing salt, hash, and algorithm metadata\n            \n        Raises:\n            HashComputationError: If hashing operation fails\n        \"\"\"\n        try:\n            # TODO 1: Generate new salt if none provided using self.salt_generator\n            # TODO 2: Convert password string to UTF-8 bytes\n            # TODO 3: Concatenate salt + password bytes (salt first for consistency)\n            # TODO 4: Create SHA-256 hash object and update with concatenated data\n            # TODO 5: Get final hash digest as bytes\n            # TODO 6: Return dictionary with salt, hash, algorithm, and any metadata\n            # Hint: Use hashlib.sha256() and .digest() method\n            # Hint: Dictionary should include 'salt', 'hash', 'algorithm' keys\n            pass\n        except Exception as e:\n            raise HashComputationError(f\"SHA-256 hash computation failed: {e}\")\n    \n    def verify_password(self, password: str, hash_record: Dict[str, Any]) -> bool:\n        \"\"\"\n        Verify password against stored hash using timing-safe comparison.\n        \n        Args:\n            password: Plain text password to verify\n            hash_record: Stored hash record from hash_password()\n            \n        Returns:\n            True if password matches, False otherwise\n        \"\"\"\n        try:\n            # TODO 1: Extract salt from hash_record dictionary\n            # TODO 2: Re-hash the provided password with stored salt\n            # TODO 3: Extract stored hash from hash_record\n            # TODO 4: Compare computed hash with stored hash using constant_time_compare\n            # TODO 5: Return comparison result\n            # Hint: Call self.hash_password(password, salt) to recompute hash\n            # Hint: Use constant_time_compare to prevent timing attacks\n            pass\n        except Exception as e:\n            # Security: Always return False for any verification errors\n            # This prevents information leakage about hash storage format\n            return False\n    \n    def get_algorithm_info(self) -> Dict[str, Any]:\n        \"\"\"\n        Get information about this hashing algorithm.\n        \n        Returns:\n            Dictionary with algorithm metadata and security properties\n        \"\"\"\n        # TODO 1: Return dictionary with algorithm name, security properties\n        # TODO 2: Include information about salt length, hash output size\n        # TODO 3: Include security notes about this algorithm's limitations\n        # Hint: SHA-256 output is always 32 bytes (256 bits)\n        pass\n```\n\n#### Milestone Checkpoint: Basic Hashing Implementation\n\nAfter implementing `SaltGenerator` and `BasicHasher`, verify your implementation with this checkpoint:\n\n**Test Command:**\n```bash\npython -m pytest tests/test_milestone1.py -v\n```\n\n**Manual Verification Script:** Create `test_basic_implementation.py`:\n```python\nfrom src.components.salt_generator import SaltGenerator\nfrom src.components.basic_hasher import BasicHasher\n\n# Test salt generation\nsalt_gen = SaltGenerator()\nsalt1 = salt_gen.generate_salt()\nsalt2 = salt_gen.generate_salt()\nprint(f\"Salt 1: {salt1.hex()[:16]}... (length: {len(salt1)} bytes)\")\nprint(f\"Salt 2: {salt2.hex()[:16]}... (length: {len(salt2)} bytes)\")\nprint(f\"Salts are unique: {salt1 != salt2}\")\n\n# Test basic hashing\nhasher = BasicHasher(salt_gen)\npassword = \"test_password_123\"\nhash_record = hasher.hash_password(password)\nprint(f\"Hash algorithm: {hash_record['algorithm']}\")\nprint(f\"Hash length: {len(hash_record['hash'])} bytes\")\n\n# Test verification\nverify_correct = hasher.verify_password(password, hash_record)\nverify_wrong = hasher.verify_password(\"wrong_password\", hash_record)\nprint(f\"Correct password verification: {verify_correct}\")\nprint(f\"Wrong password verification: {verify_wrong}\")\n```\n\n**Expected Output:**\n- Salt 1 and Salt 2 should be different hex strings, each 64 characters long (32 bytes)\n- Hash algorithm should be \"sha256\"\n- Hash length should be 32 bytes\n- Correct password verification should return `True`\n- Wrong password verification should return `False`\n\n**Common Issues and Debugging:**\n| Symptom | Likely Cause | How to Fix |\n|---------|-------------|------------|\n| `SaltGenerationError` on startup | OS entropy insufficient | Check that `/dev/urandom` exists (Linux/Mac) or CryptGenRandom available (Windows) |\n| Same salt generated twice | Using `random` instead of `secrets` | Use `os.urandom()` or `secrets.token_bytes()` |\n| Hash verification always fails | Salt concatenation order mismatch | Ensure same order (salt + password) in both hash and verify |\n| Timing attack vulnerability detected | Using `==` for hash comparison | Use `constant_time_compare()` function |\n\n\n## Data Model\n\n> **Milestone(s):** All milestones (data structures evolve across implementation phases)\n\n### Mental Model: The Medical Chart System Analogy\n\nThink of a password hash record like a patient's medical chart at a hospital. Just as each patient has a comprehensive medical record containing their identification, medical history, current medications, dosage instructions, and treatment protocols, each password requires a complete record containing the original salt, the computed hash, the algorithm used, and all the parameters needed to recreate the same result during verification.\n\nThe medical chart analogy extends further: just as different doctors might use different treatment protocols (some prefer newer medications, others stick with proven classics), our password system must support multiple hashing algorithms. A patient's chart includes not just what medication they're taking, but the exact dosage, frequency, and administration method. Similarly, our password hash record must capture not just which algorithm was used, but the exact iteration counts, memory parameters, and salt lengths required to reproduce the hash.\n\nMost importantly, just as a medical chart must be completely self-contained (a doctor in the emergency room must be able to understand a patient's entire treatment history from the chart alone), our password hash record must contain everything needed for verification. We cannot rely on external configuration files or global settings that might change over time.\n\n### Password Hash Record\n\nThe `PasswordHashRecord` serves as the authoritative data structure containing all information necessary to verify a password against its stored representation. This structure embodies the principle of **self-contained verification** - every piece of information needed to recreate the hash and perform comparison must be preserved within the record itself.\n\n![Password Hash Data Model](./diagrams/data-model.svg)\n\nThe design challenge lies in creating a format that can accommodate multiple hashing algorithms while maintaining forward and backward compatibility. As our system evolves from basic SHA-256 hashing in Milestone 1 through PBKDF2 in Milestone 2 to bcrypt and Argon2 in Milestone 3, the data model must gracefully handle this progression without breaking existing stored passwords.\n\n> **Decision: Unified Hash Record Structure**\n> - **Context**: Multiple hashing algorithms require different parameters (iterations for PBKDF2, cost factors for bcrypt, memory parameters for Argon2), but we need a single storage format\n> - **Options Considered**: Separate record types per algorithm, JSON blob for parameters, fixed fields for all possible parameters\n> - **Decision**: Single record type with algorithm identifier and flexible parameter dictionary\n> - **Rationale**: Enables algorithm agility and future algorithm addition without schema changes, while maintaining type safety for critical fields like salt and hash\n> - **Consequences**: Slightly more complex parsing logic, but enables seamless algorithm migration and future-proofing\n\n| Field Name | Type | Description |\n|------------|------|-------------|\n| `algorithm` | string | Algorithm identifier (e.g., \"sha256\", \"pbkdf2-sha256\", \"bcrypt\", \"argon2id\") |\n| `salt` | bytes | Cryptographically random salt of at least `MINIMUM_SALT_LENGTH` bytes |\n| `hash` | bytes | The computed password hash output |\n| `parameters` | dict | Algorithm-specific parameters (iterations, cost factors, memory limits) |\n| `version` | int | Schema version for future compatibility and migration support |\n| `created_at` | timestamp | When this hash was created (for algorithm upgrade scheduling) |\n\nThe `salt` field represents the cryptographically secure random value that prevents rainbow table attacks. Its length must meet or exceed `MINIMUM_SALT_LENGTH` (16 bytes) for cryptographic security, though `RECOMMENDED_SALT_LENGTH` (32 bytes) provides additional security margin. The salt remains constant for the lifetime of the password - it is generated once during initial hashing and reused during every verification.\n\nThe `hash` field contains the final output of the hashing algorithm. For SHA-256, this will be exactly 32 bytes. For PBKDF2, the length is configurable but typically 32 bytes. For bcrypt, the output includes algorithm metadata and is variable length. For Argon2, the output length is configurable based on security requirements.\n\nThe `parameters` dictionary provides algorithm-specific configuration without requiring schema changes as new algorithms are added. This flexibility enables the system to evolve while maintaining compatibility with existing stored hashes.\n\n> The critical insight here is that password hash records must be **immutable archives** - once created, they preserve exactly the algorithm and parameters that were current at the time of creation, enabling verification years later even as the system's default algorithms evolve.\n\n#### Parameter Storage by Algorithm\n\nDifferent hashing algorithms require distinct parameter sets, all stored within the unified `parameters` dictionary:\n\n| Algorithm | Required Parameters | Optional Parameters | Example Values |\n|-----------|-------------------|-------------------|----------------|\n| `sha256` | None | None | `{}` |\n| `pbkdf2-sha256` | `iterations` | `derived_key_length` | `{\"iterations\": 100000, \"derived_key_length\": 32}` |\n| `bcrypt` | `cost` | None | `{\"cost\": 12}` |\n| `argon2id` | `memory_cost`, `time_cost`, `parallelism` | `hash_length` | `{\"memory_cost\": 65536, \"time_cost\": 3, \"parallelism\": 4, \"hash_length\": 32}` |\n\nThe `version` field enables schema evolution without breaking compatibility. Version 1 represents the initial implementation supporting basic algorithms. Future versions might add fields for password policy compliance, breach detection results, or enhanced security metadata.\n\nThe `created_at` timestamp serves multiple purposes: it enables gradual migration from weaker to stronger algorithms, supports compliance requirements that mandate password age tracking, and provides forensic information for security incident analysis.\n\n#### Hash Record Serialization Formats\n\nThe password hash record must be serialized for storage in databases, files, or other persistent storage systems. The design supports multiple serialization formats depending on deployment requirements:\n\n> **Decision: Primary Serialization Format**\n> - **Context**: Hash records need persistent storage across different database systems and file formats\n> - **Options Considered**: Binary format for compactness, JSON for human readability, custom string format for simplicity\n> - **Decision**: JSON as primary format with optional binary encoding for performance-critical applications\n> - **Rationale**: JSON provides human readability for debugging, universal parsing support, and natural handling of the flexible parameters dictionary\n> - **Consequences**: Slightly larger storage footprint than binary, but significantly improved maintainability and debugging capability\n\n**JSON Format Example:**\n```json\n{\n  \"algorithm\": \"pbkdf2-sha256\",\n  \"salt\": \"base64-encoded-salt-bytes\",\n  \"hash\": \"base64-encoded-hash-bytes\", \n  \"parameters\": {\n    \"iterations\": 100000,\n    \"derived_key_length\": 32\n  },\n  \"version\": 1,\n  \"created_at\": \"2024-01-15T10:30:00Z\"\n}\n```\n\n**String Format for Simple Storage:**\nFor applications requiring single-string storage (like database varchar columns), the system supports a compact encoding format:\n`algorithm$version$base64-salt$base64-hash$base64-parameters`\n\nThis format enables storage in systems with limited schema flexibility while preserving all necessary information for verification.\n\n### Algorithm Parameters\n\nThe `AlgorithmParameters` structure defines the configuration settings that control the behavior and security properties of each hashing algorithm. These parameters directly impact the trade-off between security and performance - higher parameter values increase resistance to brute force attacks but require more computational resources for legitimate verification.\n\nThe fundamental principle underlying parameter selection is **adaptive security tuning** - the ability to adjust security levels based on current hardware capabilities and threat landscape changes. What represents strong security today may become weak as computing power advances, requiring parameter upgrades over time.\n\n| Parameter Category | Purpose | Security Impact | Performance Impact |\n|-------------------|---------|-----------------|-------------------|\n| Iteration Counts | Increase computation time | Higher = more brute force resistance | Higher = slower legitimate verification |\n| Memory Requirements | Force memory usage | Higher = specialized hardware resistance | Higher = more RAM consumption |\n| Parallelism Factors | Control thread usage | Tuned for defender hardware | Must match deployment environment |\n| Output Lengths | Control hash size | Longer = more collision resistance | Minimal impact |\n\n#### Algorithm-Specific Parameter Structures\n\nEach hashing algorithm requires a distinct parameter configuration that captures its unique security and performance characteristics:\n\n**SHA-256 Parameters (Milestone 1):**\n\n| Parameter | Type | Default Value | Security Rationale |\n|-----------|------|---------------|-------------------|\n| `salt_length` | int | `RECOMMENDED_SALT_LENGTH` (32) | Longer salts provide stronger rainbow table protection |\n\nThe simplicity of SHA-256 parameters reflects its role as a foundational building block rather than a complete password hashing solution. SHA-256 alone, even with salting, provides insufficient protection against modern brute force attacks due to its computational speed.\n\n**PBKDF2 Parameters (Milestone 2):**\n\n| Parameter | Type | Default Value | Valid Range | Security Rationale |\n|-----------|------|---------------|-------------|-------------------|\n| `iterations` | int | `PBKDF2_MIN_ITERATIONS` (100,000) | 100,000+ | Each iteration requires full HMAC computation, multiplying brute force cost |\n| `derived_key_length` | int | 32 | 16-128 | Longer keys provide more entropy and collision resistance |\n| `hash_function` | string | \"sha256\" | sha256, sha512 | SHA-256 balances security and performance for most applications |\n\n> **Decision: PBKDF2 Iteration Count Defaults**\n> - **Context**: Iteration count directly controls security vs performance trade-off, but optimal values change as hardware improves\n> - **Options Considered**: Fixed high count (500K+), adaptive based on hardware benchmarking, conservative minimum with manual tuning\n> - **Decision**: Conservative minimum (100K) with benchmarking utilities to guide tuning\n> - **Rationale**: Provides baseline security while enabling applications to tune for their specific hardware and security requirements\n> - **Consequences**: Applications must actively tune parameters rather than relying entirely on defaults, but this encourages security-conscious configuration\n\n**bcrypt Parameters (Milestone 3):**\n\n| Parameter | Type | Default Value | Valid Range | Security Rationale |\n|-----------|------|---------------|-------------|-------------------|\n| `cost` | int | `BCRYPT_MIN_COST` (12) | 10-15 | Cost factor is logarithmic - each increment doubles computation time |\n| `salt_length` | int | 16 | 16 (fixed) | bcrypt internally generates and manages 16-byte salts |\n\nThe bcrypt cost parameter represents a logarithmic scale where cost N requires 2^N iterations internally. This design enables fine-grained security tuning while maintaining reasonable parameter values (12 instead of 4096).\n\n**Argon2id Parameters (Milestone 3):**\n\n| Parameter | Type | Default Value | Valid Range | Security Rationale |\n|-----------|------|---------------|-------------|-------------------|\n| `memory_cost` | int | 65536 (64 MB) | 1024-1048576 | Memory requirement prevents ASIC/GPU optimization |\n| `time_cost` | int | 3 | 1-10 | Time iterations increase computation without proportional memory growth |\n| `parallelism` | int | 4 | 1-16 | Thread count must match deployment hardware |\n| `hash_length` | int | 32 | 16-128 | Output length affects collision resistance |\n\nArgon2id parameters require careful balancing since they interact with each other. High memory costs provide ASIC resistance but may exceed available system memory. Parallelism factors must match the deployment environment's CPU capabilities to achieve intended performance.\n\n#### Parameter Validation and Constraints\n\nThe system enforces parameter validation to prevent configuration errors that could compromise security:\n\n**Security Minimum Enforcement:**\n\n| Algorithm | Parameter | Minimum Value | Rejection Reason |\n|-----------|-----------|---------------|------------------|\n| PBKDF2 | iterations | `PBKDF2_MIN_ITERATIONS` | Below minimum provides inadequate brute force protection |\n| bcrypt | cost | `BCRYPT_MIN_COST` | Low cost factors can be brute forced with modern hardware |\n| Argon2 | memory_cost | 1024 | Insufficient memory requirement enables specialized hardware attacks |\n| All | salt_length | `MINIMUM_SALT_LENGTH` | Short salts vulnerable to rainbow table attacks |\n\n**Resource Limit Protection:**\n\nThe system also validates that parameters don't exceed reasonable resource limits that could cause denial of service:\n\n| Parameter Category | Maximum Limit | Protection Against |\n|-------------------|---------------|-------------------|\n| Memory Usage | 1 GB per hash | Memory exhaustion attacks |\n| Iteration Counts | 10 million | CPU exhaustion attacks |\n| Hash Lengths | 256 bytes | Storage bloat attacks |\n\n> ⚠️ **Pitfall: Parameter Validation Bypass**\n> Developers often implement parameter validation only in user-facing APIs, forgetting that stored hash records might contain parameters that were valid when created but exceed current limits. Always validate parameters during hash record parsing, not just during initial configuration.\n\n#### Parameter Evolution and Migration Strategy\n\nAs hardware capabilities advance and cryptographic research progresses, parameter requirements evolve. The system design accommodates this evolution through **versioned parameter schemas** and **gradual migration strategies**.\n\n**Migration Trigger Conditions:**\n\n| Condition | Action Required | Migration Strategy |\n|-----------|----------------|-------------------|\n| Algorithm deprecated | Replace with modern alternative | Transparent upgrade during next password change |\n| Parameters below current minimums | Increase to current standards | Background migration with performance monitoring |\n| New security research | Evaluate parameter adjustments | Phased rollout with fallback capability |\n\nThe parameter evolution strategy balances security improvements against operational disruption. Rather than forcing immediate migration of all stored hashes, the system upgrades hashes gradually as users authenticate, spreading the computational load over time.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Parameter Storage Separation**\n\nA frequent mistake involves storing algorithm parameters separately from the hash record itself, often in configuration files or global application settings. This creates a **temporal coupling** problem - the parameters used to create a hash must remain available and unchanged throughout the hash's lifetime, potentially years later.\n\n**Why this breaks:** Configuration files get updated, applications get redeployed with new defaults, and servers get migrated. If parameters are stored separately, hash verification fails unpredictably when configurations change.\n\n**How to fix:** Always embed all necessary parameters directly within the hash record. The `parameters` dictionary ensures that each hash remains verifiable regardless of configuration changes.\n\n⚠️ **Pitfall: Algorithm Parameter Mixing**\n\nDevelopers sometimes accidentally apply parameters from one algorithm to another, such as passing bcrypt cost factors to PBKDF2 iterations or using Argon2 memory costs with bcrypt.\n\n**Why this breaks:** Each algorithm interprets parameters differently. A bcrypt cost of 12 means 2^12 iterations, while PBKDF2 iterations of 12 would provide virtually no security.\n\n**How to fix:** Implement strict parameter validation that checks parameter compatibility with the specified algorithm. Use typed parameter structures rather than generic dictionaries when possible.\n\n⚠️ **Pitfall: Default Parameter Stagnation**\n\nApplications often hardcode \"reasonable\" default parameters at development time, then never update them as hardware capabilities advance or security recommendations evolve.\n\n**Why this breaks:** Security parameters that were appropriate in 2020 may provide inadequate protection by 2025 as computing power increases and attack techniques improve.\n\n**How to fix:** Implement parameter benchmarking utilities that measure current hardware performance and recommend appropriate parameter values. Schedule regular security reviews that evaluate parameter adequacy against current threat models.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Serialization | Python `json` module with base64 encoding | `msgpack` or Protocol Buffers for binary efficiency |\n| Parameter Validation | Manual validation with explicit checks | `pydantic` or `marshmallow` for schema validation |\n| Data Storage | Dictionary-based in-memory storage | SQLAlchemy models for database persistence |\n| Timestamp Handling | ISO 8601 strings with `datetime` module | Unix timestamps with timezone awareness |\n\n#### Recommended File Structure\n\nThe data model components should be organized to separate concerns and enable easy testing:\n\n```\nproject-root/\n  src/\n    password_hashing/\n      data_model.py              ← Core data structures (this section)\n      __init__.py\n      algorithms/                ← Algorithm implementations  \n        __init__.py\n        basic_hasher.py\n        pbkdf2_hasher.py\n        modern_hasher.py\n      storage/                   ← Persistence layer\n        __init__.py\n        json_storage.py\n        database_storage.py\n      validation/                ← Parameter validation\n        __init__.py\n        parameter_validator.py\n  tests/\n    test_data_model.py          ← Data model tests\n    test_parameter_validation.py ← Parameter validation tests\n  examples/\n    hash_record_examples.py     ← Usage examples\n```\n\n#### Infrastructure Starter Code\n\n**Complete Parameter Validation Infrastructure:**\n\n```python\n\"\"\"\nParameter validation infrastructure - complete implementation ready to use.\nThis handles all the validation logic so you can focus on the core hashing algorithms.\n\"\"\"\n\nimport time\nfrom typing import Dict, Any, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime, timezone\n\n# Constants from project naming conventions\nMINIMUM_SALT_LENGTH = 16\nRECOMMENDED_SALT_LENGTH = 32\nPBKDF2_MIN_ITERATIONS = 100000\nBCRYPT_MIN_COST = 12\n\nclass ParameterValidationError(Exception):\n    \"\"\"Raised when algorithm parameters fail validation.\"\"\"\n    pass\n\n@dataclass\nclass ValidationResult:\n    \"\"\"Result of parameter validation with detailed feedback.\"\"\"\n    is_valid: bool\n    errors: List[str]\n    warnings: List[str]\n    \n    def raise_if_invalid(self):\n        \"\"\"Raise ParameterValidationError if validation failed.\"\"\"\n        if not self.is_valid:\n            raise ParameterValidationError(f\"Parameter validation failed: {', '.join(self.errors)}\")\n\nclass ParameterValidator:\n    \"\"\"Validates algorithm parameters against security and resource constraints.\"\"\"\n    \n    # Maximum limits to prevent resource exhaustion\n    MAX_MEMORY_MB = 1024  # 1 GB maximum memory usage\n    MAX_ITERATIONS = 10_000_000  # 10 million iteration maximum\n    MAX_HASH_LENGTH = 256  # Maximum output hash length\n    \n    def validate_parameters(self, algorithm: str, parameters: Dict[str, Any]) -> ValidationResult:\n        \"\"\"Validate parameters for the specified algorithm.\"\"\"\n        errors = []\n        warnings = []\n        \n        if algorithm == \"sha256\":\n            errors.extend(self._validate_sha256_params(parameters))\n        elif algorithm == \"pbkdf2-sha256\":\n            errors.extend(self._validate_pbkdf2_params(parameters))\n        elif algorithm == \"bcrypt\":\n            errors.extend(self._validate_bcrypt_params(parameters))\n        elif algorithm == \"argon2id\":\n            errors.extend(self._validate_argon2_params(parameters))\n        else:\n            errors.append(f\"Unknown algorithm: {algorithm}\")\n        \n        return ValidationResult(\n            is_valid=len(errors) == 0,\n            errors=errors,\n            warnings=warnings\n        )\n    \n    def _validate_sha256_params(self, params: Dict[str, Any]) -> List[str]:\n        \"\"\"Validate SHA-256 specific parameters.\"\"\"\n        errors = []\n        salt_length = params.get(\"salt_length\", RECOMMENDED_SALT_LENGTH)\n        \n        if salt_length < MINIMUM_SALT_LENGTH:\n            errors.append(f\"salt_length {salt_length} below minimum {MINIMUM_SALT_LENGTH}\")\n        \n        return errors\n    \n    def _validate_pbkdf2_params(self, params: Dict[str, Any]) -> List[str]:\n        \"\"\"Validate PBKDF2 specific parameters.\"\"\"\n        errors = []\n        \n        iterations = params.get(\"iterations\", PBKDF2_MIN_ITERATIONS)\n        if iterations < PBKDF2_MIN_ITERATIONS:\n            errors.append(f\"iterations {iterations} below minimum {PBKDF2_MIN_ITERATIONS}\")\n        if iterations > self.MAX_ITERATIONS:\n            errors.append(f\"iterations {iterations} exceeds maximum {self.MAX_ITERATIONS}\")\n        \n        key_length = params.get(\"derived_key_length\", 32)\n        if key_length > self.MAX_HASH_LENGTH:\n            errors.append(f\"derived_key_length {key_length} exceeds maximum {self.MAX_HASH_LENGTH}\")\n        \n        return errors\n    \n    def _validate_bcrypt_params(self, params: Dict[str, Any]) -> List[str]:\n        \"\"\"Validate bcrypt specific parameters.\"\"\"\n        errors = []\n        \n        cost = params.get(\"cost\", BCRYPT_MIN_COST)\n        if cost < BCRYPT_MIN_COST:\n            errors.append(f\"cost {cost} below minimum {BCRYPT_MIN_COST}\")\n        if cost > 18:  # bcrypt practical maximum\n            errors.append(f\"cost {cost} exceeds practical maximum 18\")\n        \n        return errors\n    \n    def _validate_argon2_params(self, params: Dict[str, Any]) -> List[str]:\n        \"\"\"Validate Argon2 specific parameters.\"\"\"\n        errors = []\n        \n        memory_cost = params.get(\"memory_cost\", 65536)\n        if memory_cost < 1024:\n            errors.append(f\"memory_cost {memory_cost} below minimum 1024\")\n        if memory_cost > self.MAX_MEMORY_MB * 1024:\n            errors.append(f\"memory_cost {memory_cost} exceeds maximum {self.MAX_MEMORY_MB * 1024}\")\n        \n        time_cost = params.get(\"time_cost\", 3)\n        if time_cost < 1:\n            errors.append(\"time_cost must be at least 1\")\n        \n        parallelism = params.get(\"parallelism\", 4)\n        if parallelism < 1 or parallelism > 16:\n            errors.append(\"parallelism must be between 1 and 16\")\n        \n        return errors\n\n# Global validator instance for convenience\nparameter_validator = ParameterValidator()\n```\n\n#### Core Logic Skeleton Code\n\n**PasswordHashRecord Class Structure:**\n\n```python\n\"\"\"\nCore data model for password hash storage - implement the TODO sections.\nThis represents the heart of the password hashing system's data layer.\n\"\"\"\n\nimport json\nimport base64\nfrom typing import Dict, Any, Optional\nfrom datetime import datetime, timezone\nfrom dataclasses import dataclass, asdict\n\n@dataclass\nclass PasswordHashRecord:\n    \"\"\"\n    Complete password hash record containing all information needed for verification.\n    \n    This class embodies the principle of self-contained verification - everything\n    needed to verify a password must be preserved within this record.\n    \"\"\"\n    \n    algorithm: str\n    salt: bytes\n    hash: bytes\n    parameters: Dict[str, Any]\n    version: int = 1\n    created_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        \"\"\"Initialize created_at if not provided.\"\"\"\n        if self.created_at is None:\n            self.created_at = datetime.now(timezone.utc)\n    \n    def to_json(self) -> str:\n        \"\"\"\n        Serialize hash record to JSON format for storage.\n        \n        Returns:\n            JSON string representation of the hash record\n        \"\"\"\n        # TODO 1: Convert salt bytes to base64 string for JSON serialization\n        # TODO 2: Convert hash bytes to base64 string for JSON serialization\n        # TODO 3: Convert datetime to ISO 8601 string format\n        # TODO 4: Build dictionary with all fields using proper encodings\n        # TODO 5: Return json.dumps() result with consistent formatting\n        # Hint: Use base64.b64encode().decode() for bytes to string conversion\n        pass\n    \n    @classmethod\n    def from_json(cls, json_str: str) -> 'PasswordHashRecord':\n        \"\"\"\n        Deserialize hash record from JSON format.\n        \n        Args:\n            json_str: JSON string representation\n            \n        Returns:\n            PasswordHashRecord instance\n            \n        Raises:\n            ValueError: If JSON is invalid or missing required fields\n        \"\"\"\n        # TODO 1: Parse JSON string using json.loads() with error handling\n        # TODO 2: Decode base64 salt string back to bytes\n        # TODO 3: Decode base64 hash string back to bytes  \n        # TODO 4: Parse ISO 8601 created_at string to datetime object\n        # TODO 5: Validate all required fields are present\n        # TODO 6: Create and return PasswordHashRecord instance\n        # Hint: Use base64.b64decode() and datetime.fromisoformat() for decoding\n        pass\n    \n    def to_string_format(self) -> str:\n        \"\"\"\n        Serialize to compact string format: algorithm$version$salt$hash$params\n        \n        Returns:\n            Compact string representation for simple storage systems\n        \"\"\"\n        # TODO 1: Encode salt as base64 string\n        # TODO 2: Encode hash as base64 string\n        # TODO 3: Encode parameters dict as base64-encoded JSON\n        # TODO 4: Join all components with '$' delimiter\n        # TODO 5: Return complete string format\n        # Hint: json.dumps(parameters) then base64 encode the JSON string\n        pass\n    \n    @classmethod\n    def from_string_format(cls, string_repr: str) -> 'PasswordHashRecord':\n        \"\"\"\n        Deserialize from compact string format.\n        \n        Args:\n            string_repr: String in format algorithm$version$salt$hash$params\n            \n        Returns:\n            PasswordHashRecord instance\n            \n        Raises:\n            ValueError: If string format is invalid\n        \"\"\"\n        # TODO 1: Split string on '$' delimiter and validate part count\n        # TODO 2: Extract algorithm and version from first two parts\n        # TODO 3: Base64 decode salt and hash from next two parts\n        # TODO 4: Base64 decode and JSON parse parameters from last part\n        # TODO 5: Create PasswordHashRecord with decoded values\n        # Hint: Expect exactly 5 parts after splitting on '$'\n        pass\n    \n    def validate(self) -> None:\n        \"\"\"\n        Validate hash record fields and parameters.\n        \n        Raises:\n            ValueError: If any field is invalid\n        \"\"\"\n        # TODO 1: Check algorithm is not empty string\n        # TODO 2: Check salt length meets MINIMUM_SALT_LENGTH requirement\n        # TODO 3: Check hash is not empty\n        # TODO 4: Use parameter_validator to validate algorithm parameters\n        # TODO 5: Raise ValueError with specific error messages for failures\n        # Hint: Import parameter_validator from the infrastructure code above\n        pass\n    \n    def get_parameter(self, name: str, default: Any = None) -> Any:\n        \"\"\"\n        Get algorithm parameter with default fallback.\n        \n        Args:\n            name: Parameter name\n            default: Default value if parameter not found\n            \n        Returns:\n            Parameter value or default\n        \"\"\"\n        # TODO: Return parameter from self.parameters dict with default fallback\n        pass\n    \n    def update_parameters(self, new_params: Dict[str, Any]) -> 'PasswordHashRecord':\n        \"\"\"\n        Create new hash record with updated parameters.\n        \n        Note: This creates a new record rather than modifying existing one\n        to maintain immutability of stored hash records.\n        \n        Args:\n            new_params: Parameters to add or update\n            \n        Returns:\n            New PasswordHashRecord with merged parameters\n        \"\"\"\n        # TODO 1: Create copy of existing parameters\n        # TODO 2: Update copy with new_params using dict.update()\n        # TODO 3: Create new PasswordHashRecord with updated parameters\n        # TODO 4: Validate new record before returning\n        # TODO 5: Return new record instance\n        # Hint: Use dataclass replace() or create new instance manually\n        pass\n```\n\n**Algorithm Parameter Management:**\n\n```python\n\"\"\"\nAlgorithm parameter configuration and management - implement parameter logic.\n\"\"\"\n\nfrom typing import Dict, Any, Union\nfrom dataclasses import dataclass\n\nclass AlgorithmParameters:\n    \"\"\"\n    Manages algorithm-specific parameter configurations and defaults.\n    \n    This class provides the interface between high-level algorithm selection\n    and low-level parameter tuning for each supported hashing method.\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize with default parameter sets for all algorithms.\"\"\"\n        # TODO 1: Create default parameters dictionary for each algorithm\n        # TODO 2: Include sha256, pbkdf2-sha256, bcrypt, and argon2id defaults\n        # TODO 3: Use constants from naming conventions for minimum values\n        # TODO 4: Store in self._defaults for later reference\n        # Hint: Structure as {\"algorithm\": {\"param\": value, ...}, ...}\n        pass\n    \n    def get_defaults(self, algorithm: str) -> Dict[str, Any]:\n        \"\"\"\n        Get default parameters for specified algorithm.\n        \n        Args:\n            algorithm: Algorithm name (e.g., \"pbkdf2-sha256\")\n            \n        Returns:\n            Dictionary of default parameters\n            \n        Raises:\n            ValueError: If algorithm is not supported\n        \"\"\"\n        # TODO 1: Check if algorithm exists in self._defaults\n        # TODO 2: Return copy of default parameters (not reference)\n        # TODO 3: Raise ValueError for unsupported algorithms\n        # Hint: Use dict.copy() to avoid modifying defaults\n        pass\n    \n    def create_parameters(self, algorithm: str, overrides: Dict[str, Any] = None) -> Dict[str, Any]:\n        \"\"\"\n        Create parameter set by merging defaults with custom overrides.\n        \n        Args:\n            algorithm: Algorithm name\n            overrides: Custom parameter values to override defaults\n            \n        Returns:\n            Complete parameter dictionary ready for use\n        \"\"\"\n        # TODO 1: Get default parameters for algorithm\n        # TODO 2: Apply overrides if provided using dict.update()\n        # TODO 3: Validate merged parameters using parameter_validator\n        # TODO 4: Return validated parameter set\n        # TODO 5: Handle validation errors appropriately\n        pass\n    \n    def benchmark_parameters(self, algorithm: str, target_time_ms: float = 250.0) -> Dict[str, Any]:\n        \"\"\"\n        Automatically tune parameters to achieve target verification time.\n        \n        This helps applications set appropriate security levels based on their\n        hardware capabilities and performance requirements.\n        \n        Args:\n            algorithm: Algorithm to benchmark\n            target_time_ms: Target verification time in milliseconds\n            \n        Returns:\n            Optimized parameters achieving approximately target time\n        \"\"\"\n        # TODO 1: Start with default parameters for algorithm\n        # TODO 2: Implement binary search or iterative tuning approach\n        # TODO 3: Measure actual hash computation time using test password\n        # TODO 4: Adjust key parameters (iterations, cost, memory) based on timing\n        # TODO 5: Return parameters that achieve target timing within tolerance\n        # Hint: Use time.time() to measure hash computation duration\n        # Note: This is advanced functionality - implement basic version first\n        pass\n    \n    def compare_security_levels(self, algorithm1: str, params1: Dict[str, Any], \n                              algorithm2: str, params2: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        Compare relative security levels between two parameter configurations.\n        \n        Args:\n            algorithm1, params1: First configuration\n            algorithm2, params2: Second configuration\n            \n        Returns:\n            Dictionary containing security comparison metrics\n        \"\"\"\n        # TODO 1: Calculate approximate operation counts for each configuration\n        # TODO 2: Estimate memory requirements for each configuration\n        # TODO 3: Compare brute force attack costs based on parameters\n        # TODO 4: Return structured comparison with recommendations\n        # TODO 5: Include warnings for configurations below security minimums\n        # Note: This requires security modeling - implement basic version\n        pass\n```\n\n#### Language-Specific Hints\n\n**Python Data Model Best Practices:**\n- Use `dataclasses` for structured data with automatic `__init__`, `__repr__`, and comparison methods\n- Leverage `typing` module for clear type annotations that document expected data types\n- Use `datetime.timezone.utc` for consistent timezone handling across deployments\n- Handle `bytes` vs `str` carefully - passwords are text but salts and hashes are binary data\n- Use `json.dumps(sort_keys=True)` for consistent JSON serialization across Python versions\n\n**Binary Data Handling:**\n- Use `base64.b64encode().decode()` to convert bytes to JSON-safe strings\n- Use `base64.b64decode()` to convert base64 strings back to bytes\n- Always specify encoding explicitly: `\"utf-8\"` for text, base64 for binary data\n- Validate base64 strings before decoding to provide clear error messages\n\n**Error Handling Patterns:**\n- Create custom exception classes (`ParameterValidationError`, `HashRecordError`) for specific failure modes\n- Use `ValueError` for data validation failures with descriptive messages\n- Use `TypeError` for incorrect data types passed to functions\n- Include the invalid value in error messages to aid debugging\n\n#### Milestone Checkpoints\n\n**After implementing PasswordHashRecord:**\n- Run: `python -c \"from data_model import PasswordHashRecord; print('Import successful')\"`\n- Test JSON serialization round-trip: create record, serialize to JSON, deserialize, verify equality\n- Test string format round-trip: create record, convert to string format, parse back, verify equality\n- Verify validation catches invalid salt lengths and unknown algorithms\n\n**After implementing AlgorithmParameters:**\n- Run parameter validation tests: `python -m pytest tests/test_parameter_validation.py -v`\n- Test default parameter retrieval for all supported algorithms\n- Verify parameter override functionality works correctly\n- Test that validation catches security violations (too few iterations, etc.)\n\n**Integration Test:**\nCreate a complete password hash record with PBKDF2 parameters, serialize to JSON, store in file, read back, and verify the password - this tests the entire data model pipeline.\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| JSON serialization fails with \"not serializable\" | bytes fields not base64 encoded | Check if salt/hash are bytes objects | Convert bytes to base64 strings before JSON |\n| Parameter validation passes but hashing fails | Wrong parameter types (int vs str) | Print parameter types and values | Ensure parameters match algorithm expectations |\n| Hash records can't be parsed after storage | Encoding/decoding mismatch | Compare original vs stored JSON | Use consistent base64 encoding for all bytes |\n| Created timestamps cause JSON errors | Timezone-aware datetime objects | Check datetime.isoformat() output | Use UTC timezone consistently |\n| String format parsing fails | Wrong delimiter count or encoding | Count '$' delimiters in string | Verify 5 parts: algorithm$version$salt$hash$params |\n\n\n## Salt Generation Component\n\n> **Milestone(s):** Milestone 1 (Basic Hashing with Salt)\n\n### Mental Model: The Fingerprint Database Security System\n\nThink of salt generation like a fingerprint database security system at a high-security facility. Every person who enters gets their fingerprint scanned, but instead of storing the raw fingerprint (which could be stolen and replicated), the system combines each fingerprint with a unique, random \"case number\" before storing it. This case number is different for every person, even if they have identical fingerprints (like identical twins). The case number is stored alongside the processed fingerprint data, so when someone returns, the system can retrieve their specific case number and re-process their fingerprint the same way for comparison.\n\nIn password hashing, the **salt** is like that unique case number. It's a cryptographically random value that gets combined with every password before hashing. Even if two users have the same password (\"password123\"), their stored hashes will be completely different because each got a different salt. This prevents attackers from using **rainbow tables** (precomputed hash-to-password lookup databases) because they would need to recompute their entire attack database for every possible salt value - an computationally infeasible task.\n\nThe `SaltGenerator` component serves as the secure random number generator for our password hashing system. Its primary responsibility is producing cryptographically secure random values that serve as unique inputs to the hashing process. This component must guarantee that each generated salt is unpredictable, unique, and of sufficient length to provide cryptographic security against precomputed attacks.\n\n![Password Registration Sequence](./diagrams/registration-sequence.svg)\n\n### Component Responsibilities\n\nThe `SaltGenerator` component owns several critical security functions within the broader password hashing architecture. Its core responsibility is generating cryptographically secure random values, but this seemingly simple task encompasses multiple technical requirements and security considerations.\n\nThe component must produce random values using cryptographically secure random number generators that draw from sufficient entropy sources. This means utilizing operating system-provided entropy pools rather than pseudo-random number generators designed for statistical randomness. The difference is crucial: statistical randomness might pass mathematical tests for randomness but could still be predictable to an attacker who understands the algorithm, while cryptographic randomness is designed to be unpredictable even to attackers with significant computational resources.\n\nBeyond random generation, the component must enforce minimum security standards for salt length and format. Different cryptographic contexts require different minimum salt lengths, and the component must reject requests that fall below these thresholds. It also handles salt encoding and serialization, ensuring that generated salts can be safely stored alongside password hashes and reliably reconstructed during verification.\n\n| Responsibility | Description | Security Requirement |\n|---------------|-------------|---------------------|\n| Random Generation | Produce cryptographically secure random bytes | Must use OS entropy sources, not PRNG |\n| Length Validation | Enforce minimum salt lengths for security | Reject salts shorter than `MINIMUM_SALT_LENGTH` |\n| Encoding Management | Convert random bytes to storable format | Support both binary and text representations |\n| Uniqueness Assurance | Ensure statistical uniqueness across generations | Collision probability must be negligible |\n| Format Standardization | Provide consistent salt output format | Enable interoperability between components |\n\n### Cryptographic Randomness Requirements\n\nCryptographic randomness represents the foundation of salt security, yet many developers underestimate the complexity and importance of proper random number generation. The distinction between \"random enough for testing\" and \"random enough for cryptographic security\" can mean the difference between robust security and trivial compromise.\n\n#### Understanding Entropy Sources\n\nTrue randomness in computer systems originates from physical processes that are inherently unpredictable. Modern operating systems collect entropy from various sources: keyboard timing variations, mouse movement patterns, disk seek time fluctuations, network packet arrival timing, and dedicated hardware random number generators. These entropy sources feed into kernel-maintained entropy pools that cryptographic random number generators draw from.\n\nThe critical architectural decision for salt generation involves choosing between different classes of random number generators. Pseudo-random number generators (PRNGs) like those used for statistical simulations produce mathematically random sequences but are completely deterministic given their seed value. An attacker who discovers the seed or internal state can predict all future outputs. Cryptographically secure pseudo-random number generators (CSPRNGs) are designed to remain unpredictable even if attackers learn some previous outputs, but they still require high-quality seed material from true entropy sources.\n\n> **Decision: Use Operating System Cryptographic APIs**\n> - **Context**: Need cryptographically secure random values for salt generation with guarantee of sufficient entropy\n> - **Options Considered**: \n>   1. Standard library PRNG (like `random.random()`)\n>   2. Custom cryptographic PRNG implementation\n>   3. Operating system cryptographic APIs (like `/dev/urandom` or `CryptGenRandom`)\n> - **Decision**: Use operating system cryptographic APIs exclusively\n> - **Rationale**: OS APIs provide access to kernel entropy pools with hardware entropy sources, have been extensively audited, and handle entropy estimation automatically. Custom implementations risk subtle vulnerabilities, while standard PRNGs offer no cryptographic security.\n> - **Consequences**: Dependency on OS cryptographic subsystem, but eliminates entire classes of implementation vulnerabilities and ensures access to best available entropy sources.\n\n| Option | Entropy Quality | Predictability Risk | Implementation Complexity | Performance | Security Audit History |\n|--------|----------------|-------------------|-------------------------|-------------|----------------------|\n| Standard PRNG | Low | High - fully predictable | Low | Excellent | Not designed for security |\n| Custom CSPRNG | Variable | Medium - depends on implementation | Very High | Good | None - new implementation |\n| OS Crypto APIs | High | Very Low | Low | Good | Extensively audited |\n\n#### Platform-Specific Entropy Sources\n\nDifferent operating systems provide cryptographically secure random numbers through different interfaces, each with specific characteristics and guarantees. Understanding these differences helps explain why the `SaltGenerator` component abstracts platform-specific details behind a common interface.\n\nOn Unix-like systems (Linux, macOS, BSD variants), `/dev/urandom` provides the standard interface to kernel entropy. Despite its name suggesting \"unreliable\" randomness, `/dev/urandom` provides cryptographically secure random numbers in all practical scenarios. It draws from the same entropy pool as `/dev/random` but doesn't block when entropy estimates are low. The blocking behavior of `/dev/random` can cause denial-of-service conditions in server applications, while the theoretical security difference is negligible for salt generation use cases.\n\nWindows systems provide cryptographically secure randomness through the CryptoAPI, specifically the `CryptGenRandom` function or the newer Cryptography API: Next Generation (CNG) `BCryptGenRandom` function. These APIs access hardware random number generators when available and fall back to software-based CSPRNGs seeded from multiple entropy sources including hardware timing, process information, and user input.\n\nModern programming language standard libraries abstract these platform differences, providing portable interfaces that select the appropriate OS-level mechanism. Python's `secrets` module, Go's `crypto/rand` package, and Node.js's `crypto.randomBytes()` function all provide this abstraction while maintaining cryptographic security guarantees.\n\n> The key architectural insight is that salt generation must never compromise on entropy quality for convenience or performance. A single weak salt compromises the security of that password hash permanently, making the entropy quality decision one of the most critical in the entire system.\n\n#### Detecting Entropy Exhaustion\n\nWhile modern systems rarely exhaust entropy pools, understanding entropy exhaustion scenarios helps explain why certain implementation choices matter. Entropy exhaustion occurs when random number generation outpaces the rate at which the system can collect new entropy from physical sources. This can happen during system boot before entropy sources have provided sufficient randomness, in virtualized environments with limited entropy sources, or under extremely high random number generation loads.\n\nThe `SaltGenerator` component must handle potential entropy exhaustion gracefully. Rather than generating predictable values or hanging indefinitely, it should detect low entropy conditions and either wait for entropy recovery or fail securely by refusing to generate salts. Most modern OS cryptographic APIs handle this automatically, but understanding the underlying concepts helps explain why certain APIs are preferred.\n\n| Entropy Condition | `/dev/random` Behavior | `/dev/urandom` Behavior | Windows CryptoAPI | Recommended Action |\n|-------------------|----------------------|------------------------|-------------------|-------------------|\n| High Entropy | Returns immediately | Returns immediately | Returns immediately | Normal operation |\n| Low Entropy | Blocks until entropy available | Returns immediately | Returns immediately | Monitor but continue |\n| Critical Low Entropy | Blocks indefinitely | May return predictable values | Fails securely | Fail salt generation |\n| Boot Time | Blocks | May be predictable | Waits for entropy seeding | Delay application start |\n\n### Salt Length Architecture Decisions\n\nSalt length directly impacts security effectiveness, storage requirements, and computational overhead. While longer salts provide stronger security guarantees, they also increase storage costs and may impact performance in high-throughput scenarios. The architectural challenge involves balancing these factors while ensuring adequate security for the foreseeable future.\n\n#### Security Analysis of Salt Length\n\nThe primary security function of salts is preventing **rainbow table attacks** - precomputed hash-to-password lookup tables that accelerate password cracking. To understand salt length requirements, consider the economics of rainbow table construction. An attacker building rainbow tables must compute and store hash values for every combination of likely passwords and possible salt values. The computational and storage costs scale linearly with the number of possible salt values.\n\nWith a salt length of `n` bits, there are `2^n` possible salt values. An attacker wanting comprehensive rainbow table coverage must compute approximately `2^n` times as many hashes as they would for unsalted passwords. For practical attack scenarios, this quickly becomes computationally infeasible.\n\nA 128-bit salt (16 bytes) provides `2^128` possible values - approximately `3.4 × 10^38` possibilities. Even with advanced hardware capable of computing billions of hashes per second, building comprehensive rainbow tables for all possible 128-bit salts would require more computational resources than are practically available. This analysis provides the foundation for the `MINIMUM_SALT_LENGTH` constant.\n\n> **Decision: 128-bit Minimum Salt Length**\n> - **Context**: Need to determine minimum salt length that provides cryptographic security against rainbow table attacks while considering storage and performance constraints\n> - **Options Considered**:\n>   1. 64-bit salts (8 bytes) - minimal storage overhead\n>   2. 128-bit salts (16 bytes) - current cryptographic standard\n>   3. 256-bit salts (32 bytes) - future-proofing against quantum attacks\n> - **Decision**: 128-bit minimum with 256-bit recommended default\n> - **Rationale**: 128-bit salts provide `2^128` possible values, making rainbow table attacks computationally infeasible with current and foreseeable technology. 64-bit salts might become vulnerable to well-funded attackers, while 256-bit salts provide quantum resistance with minimal additional overhead.\n> - **Consequences**: Requires 16 bytes storage per password hash minimum, 32 bytes recommended. Provides long-term security against rainbow table attacks and some quantum computing scenarios.\n\n| Salt Length | Possible Values | Rainbow Table Storage (1TB passwords) | Attack Feasibility | Quantum Resistance |\n|-------------|----------------|--------------------------------------|-------------------|-------------------|\n| 64-bit | `2^64` ≈ 18 × 10^18 | 18 exabytes | Potentially feasible for nation-states | Vulnerable |\n| 128-bit | `2^128` ≈ 3.4 × 10^38 | 340 undecillion bytes | Computationally infeasible | Reduced but significant |\n| 256-bit | `2^256` ≈ 1.2 × 10^77 | Impossibly large | Impossible with known physics | Strong resistance |\n\n#### Storage Format Considerations\n\nSalt storage format affects interoperability, debugging capabilities, and integration with existing systems. The `SaltGenerator` must produce salts in formats that can be efficiently stored alongside password hashes and reliably reconstructed during verification.\n\nBinary storage provides optimal space efficiency, storing salts as raw byte arrays without encoding overhead. A 128-bit salt requires exactly 16 bytes in binary format. However, binary storage complicates debugging (binary data isn't human-readable), integration with text-based systems, and serialization to formats like JSON that don't handle arbitrary binary data well.\n\nBase64 encoding converts binary salt data to printable ASCII characters, enabling storage in text databases and easy serialization to standard formats. Base64 encoding adds approximately 33% storage overhead (a 16-byte salt becomes a 24-character string), but the overhead is generally acceptable given the benefits for system integration and debugging.\n\nHexadecimal encoding provides another text representation option, converting each byte to two hexadecimal digits. A 16-byte salt becomes a 32-character hex string, doubling storage requirements but providing human-readable output that's easier to debug than Base64.\n\n| Storage Format | 128-bit Salt Size | 256-bit Salt Size | Human Readable | JSON Compatible | Storage Efficiency |\n|----------------|------------------|------------------|----------------|-----------------|-------------------|\n| Binary | 16 bytes | 32 bytes | No | No | 100% |\n| Base64 | 24 characters | 44 characters | Partially | Yes | 75% |\n| Hexadecimal | 32 characters | 64 characters | Yes | Yes | 50% |\n\n> The architectural decision to support multiple encoding formats within the `SaltGenerator` provides flexibility for different deployment scenarios while maintaining a consistent internal binary representation for cryptographic operations.\n\n#### Salt Uniqueness Requirements\n\nWhile cryptographically secure random generation makes salt collisions extremely unlikely, understanding the mathematical foundations helps explain why certain implementation practices matter. Salt uniqueness isn't just about avoiding identical salts - it's about ensuring that the distribution of salt values provides maximum entropy for the hashing process.\n\nThe birthday paradox provides insight into collision probabilities for different salt lengths. For randomly generated values from a space of `N` possibilities, the probability of collision becomes significant when approximately `√N` values have been generated. For 128-bit salts with `2^128` possible values, collision probability becomes meaningful only after generating approximately `2^64` salts - far more than any practical system would generate.\n\nHowever, cryptographic security requires considering not just average-case collision probability but also worst-case scenarios where attackers might deliberately attempt to generate salt collisions. The `SaltGenerator` component must use cryptographically secure random sources that resist prediction and manipulation, ensuring that salt generation remains secure even under adversarial conditions.\n\n| Salt Length | Collision Probability (1 million salts) | Collision Probability (1 billion salts) | Practical Impact |\n|-------------|----------------------------------------|----------------------------------------|------------------|\n| 64-bit | ~1 in 18 × 10^12 | ~1 in 18 × 10^6 | Possible in large systems |\n| 128-bit | ~1 in 3.4 × 10^32 | ~1 in 3.4 × 10^26 | Negligible |\n| 256-bit | ~1 in 1.2 × 10^71 | ~1 in 1.2 × 10^65 | Impossible |\n\n### Salt Generation Algorithm\n\nThe salt generation algorithm implements the architectural decisions described above while providing a clean interface for other system components. The algorithm must balance security, performance, and usability requirements while maintaining consistent behavior across different deployment environments.\n\nThe core salt generation process follows these steps:\n\n1. **Validate Input Parameters**: Check that the requested salt length meets minimum security requirements defined by `MINIMUM_SALT_LENGTH`. Reject requests for shorter salts to prevent security degradation through misconfiguration.\n\n2. **Access System Entropy Source**: Establish connection to the operating system's cryptographic random number generator. This involves opening `/dev/urandom` on Unix systems or initializing Windows CryptoAPI handles.\n\n3. **Generate Random Bytes**: Request the specified number of random bytes from the entropy source. Handle potential errors like entropy exhaustion or system call failures that could compromise security.\n\n4. **Validate Output Quality**: Perform basic sanity checks on generated random data. While cryptographic entropy sources should never produce obviously non-random output, defensive programming principles suggest validating that the output isn't all zeros or other obviously wrong patterns.\n\n5. **Format for Storage**: Convert raw binary random data to the requested output format (binary, Base64, or hexadecimal) based on system requirements and storage constraints.\n\n6. **Return Salt with Metadata**: Provide the generated salt along with metadata about its generation (timestamp, length, format) to support debugging and system monitoring.\n\nThe algorithm must handle several error conditions gracefully. Entropy source unavailability should cause immediate failure rather than falling back to weaker randomness sources. Invalid length requests should be rejected with clear error messages explaining security requirements. System resource exhaustion should result in temporary failure with retry guidance rather than generating potentially weak salts.\n\n> **Critical Design Principle**: The salt generation algorithm must fail securely. It's better to refuse salt generation than to generate cryptographically weak salts that compromise password security permanently.\n\n### Integration with Password Hashing Components\n\nThe `SaltGenerator` component integrates with other password hashing system components through well-defined interfaces that maintain security boundaries while enabling flexible system architecture. Understanding these integration points helps clarify the component's role within the broader system.\n\nThe primary integration occurs with the `BasicHasher` component, which calls `generate_salt()` during password registration to obtain unique random values for each password. This integration must ensure that salt generation happens immediately before password hashing to minimize the window where salts might be cached in memory or temporary storage.\n\nIntegration with the `PasswordHashRecord` data structure requires consistent salt formatting that supports both storage and retrieval operations. The generated salt becomes part of the permanent password hash record, so format decisions made during generation affect the system permanently.\n\nThe component also integrates with system monitoring and logging infrastructure to provide visibility into salt generation operations without compromising security. This includes metrics about generation rates, error conditions, and entropy source health, but never logs the actual salt values which would compromise their security properties.\n\n| Integration Point | Interface | Security Boundary | Failure Handling |\n|------------------|-----------|-------------------|------------------|\n| BasicHasher | `generate_salt(length) -> bytes` | Salt values never logged or cached | Propagate failures to prevent weak hashing |\n| PasswordHashRecord | Salt serialization/deserialization | Immutable salt storage | Validation during record creation |\n| Monitoring System | Performance and error metrics | No salt value exposure | Aggregate statistics only |\n| Configuration System | Length and format parameters | Enforce minimum security requirements | Reject unsafe configurations |\n\n### Common Pitfalls\n\nUnderstanding common mistakes in salt generation helps avoid subtle security vulnerabilities that might not manifest until systems face real attacks. These pitfalls often arise from misconceptions about randomness, security requirements, or implementation details.\n\n⚠️ **Pitfall: Using Standard Library Random Functions**\n\nMany developers instinctively reach for their language's standard `random()` function when implementing salt generation. Functions like Python's `random.random()`, JavaScript's `Math.random()`, or C's `rand()` are designed for statistical randomness in simulations and games, not cryptographic security. These functions are completely predictable if an attacker can determine their internal state or seed value.\n\n**Why it's wrong**: Standard random functions use algorithms optimized for speed and statistical properties, not unpredictability. An attacker who observes several salt values might be able to predict future salts, enabling targeted attacks against new password hashes.\n\n**How to fix**: Always use cryptographically secure random functions: Python's `secrets.token_bytes()`, Go's `crypto/rand.Read()`, Node.js's `crypto.randomBytes()`, or direct OS interfaces like `/dev/urandom`.\n\n⚠️ **Pitfall: Reusing Salts Across Users**\n\nSome implementations attempt to optimize storage or simplify code by using a single \"global salt\" for all users or generating salts based on predictable values like usernames or timestamps.\n\n**Why it's wrong**: Salt reuse eliminates the primary security benefit - preventing rainbow table attacks. If multiple users share the same salt, an attacker can build rainbow tables for that salt and crack multiple passwords efficiently.\n\n**How to fix**: Generate a unique, random salt for every individual password. Never derive salts from predictable inputs or reuse them across different passwords.\n\n⚠️ **Pitfall: Insufficient Salt Length**\n\nDevelopers sometimes choose salt lengths based on convenience (like 4 or 8 bytes) rather than security requirements, not understanding that shorter salts provide exponentially less security.\n\n**Why it's wrong**: Short salts create feasible rainbow table attack scenarios. An 8-byte salt has only `2^64` possible values - large but potentially manageable for well-funded attackers with specialized hardware.\n\n**How to fix**: Use minimum 16-byte (128-bit) salts as defined by `MINIMUM_SALT_LENGTH`. Prefer 32-byte (256-bit) salts when storage overhead isn't critical.\n\n⚠️ **Pitfall: Not Handling Entropy Exhaustion**\n\nSome implementations assume that random number generation always succeeds immediately and don't handle scenarios where entropy sources might be temporarily unavailable or exhausted.\n\n**Why it's wrong**: Entropy exhaustion can cause systems to hang indefinitely, create denial-of-service conditions, or in worst cases, fall back to predictable randomness that compromises security.\n\n**How to fix**: Use non-blocking entropy sources like `/dev/urandom`, implement timeouts for random number generation, and fail securely if entropy sources become unavailable rather than generating potentially weak salts.\n\n⚠️ **Pitfall: Salt Storage Format Inconsistencies**\n\nInconsistent handling of salt encoding can lead to verification failures where the same password appears invalid due to salt format mismatches between generation and verification.\n\n**Why it's wrong**: If salt generation produces Base64-encoded values but verification expects binary data, password verification will always fail even with correct passwords, creating a complete authentication system failure.\n\n**How to fix**: Standardize on a single salt storage format within the system and ensure all components handle the same encoding consistently. Document format decisions clearly and validate format consistency in tests.\n\n### Implementation Guidance\n\nThe `SaltGenerator` component translates cryptographic security requirements into practical code that developers can integrate into their password hashing systems. This implementation guidance provides complete, production-ready code for infrastructure components while offering detailed skeleton code for the core salt generation logic that learners should implement themselves.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Random Generation | `secrets` module (Python) | Direct OS crypto APIs with error handling |\n| Salt Encoding | Base64 with standard library | Custom binary format with version headers |\n| Configuration | Hard-coded constants | Runtime configuration with validation |\n| Testing | Unit tests with fixed test vectors | Property-based testing with entropy analysis |\n| Monitoring | Basic logging | Metrics collection with entropy health monitoring |\n\n#### Recommended File Structure\n\n```\npassword-hashing/\n  src/\n    salt_generation/\n      __init__.py              ← Component public interface\n      salt_generator.py        ← Core SaltGenerator class\n      entropy_monitor.py       ← Entropy source health monitoring\n      test_salt_generation.py  ← Comprehensive test suite\n    common/\n      constants.py             ← Security constants and limits\n      exceptions.py            ← Custom exception types\n      validation.py            ← Input validation utilities\n  tests/\n    integration/\n      test_salt_uniqueness.py  ← Statistical uniqueness testing\n    security/\n      test_entropy_quality.py  ← Entropy quality validation\n```\n\n#### Infrastructure Starter Code\n\n**File: `src/common/constants.py`** (Complete implementation - copy and use)\n\n```python\n\"\"\"\nSecurity constants for password hashing system.\nThese values are based on current cryptographic best practices.\n\"\"\"\n\n# Salt generation security parameters\nMINIMUM_SALT_LENGTH = 16        # 128 bits - cryptographic minimum\nRECOMMENDED_SALT_LENGTH = 32    # 256 bits - recommended for new systems\nMAX_SALT_LENGTH = 64           # 512 bits - reasonable upper limit\n\n# Supported salt encoding formats\nSALT_FORMAT_BINARY = \"binary\"\nSALT_FORMAT_BASE64 = \"base64\"  \nSALT_FORMAT_HEX = \"hex\"\n\n# Default configuration\nDEFAULT_SALT_FORMAT = SALT_FORMAT_BASE64\nDEFAULT_SALT_LENGTH = RECOMMENDED_SALT_LENGTH\n\n# Error messages\nERROR_SALT_TOO_SHORT = f\"Salt length must be at least {MINIMUM_SALT_LENGTH} bytes\"\nERROR_SALT_TOO_LONG = f\"Salt length must not exceed {MAX_SALT_LENGTH} bytes\"\nERROR_INVALID_FORMAT = f\"Salt format must be one of: {SALT_FORMAT_BINARY}, {SALT_FORMAT_BASE64}, {SALT_FORMAT_HEX}\"\n```\n\n**File: `src/common/exceptions.py`** (Complete implementation - copy and use)\n\n```python\n\"\"\"\nCustom exceptions for password hashing system.\n\"\"\"\n\nclass PasswordHashingError(Exception):\n    \"\"\"Base exception for password hashing system errors.\"\"\"\n    pass\n\nclass SaltGenerationError(PasswordHashingError):\n    \"\"\"Raised when salt generation fails.\"\"\"\n    pass\n\nclass EntropyExhaustionError(SaltGenerationError):\n    \"\"\"Raised when system entropy is insufficient for secure salt generation.\"\"\"\n    pass\n\nclass ParameterValidationError(PasswordHashingError):\n    \"\"\"Raised when algorithm parameters fail validation.\"\"\"\n    def __init__(self, message, field_name=None, provided_value=None):\n        super().__init__(message)\n        self.field_name = field_name\n        self.provided_value = provided_value\n```\n\n**File: `src/common/validation.py`** (Complete implementation - copy and use)\n\n```python\n\"\"\"\nInput validation utilities for password hashing system.\n\"\"\"\nimport re\nfrom typing import Any, List, Optional\nfrom .constants import (\n    MINIMUM_SALT_LENGTH, MAX_SALT_LENGTH,\n    SALT_FORMAT_BINARY, SALT_FORMAT_BASE64, SALT_FORMAT_HEX,\n    ERROR_SALT_TOO_SHORT, ERROR_SALT_TOO_LONG, ERROR_INVALID_FORMAT\n)\nfrom .exceptions import ParameterValidationError\n\nclass ValidationResult:\n    \"\"\"Result of parameter validation with errors and warnings.\"\"\"\n    def __init__(self):\n        self.is_valid = True\n        self.errors = []\n        self.warnings = []\n    \n    def add_error(self, message: str):\n        self.is_valid = False\n        self.errors.append(message)\n    \n    def add_warning(self, message: str):\n        self.warnings.append(message)\n\ndef validate_salt_length(length: int) -> ValidationResult:\n    \"\"\"Validate salt length meets security requirements.\"\"\"\n    result = ValidationResult()\n    \n    if not isinstance(length, int):\n        result.add_error(\"Salt length must be an integer\")\n        return result\n    \n    if length < MINIMUM_SALT_LENGTH:\n        result.add_error(ERROR_SALT_TOO_SHORT)\n    elif length > MAX_SALT_LENGTH:\n        result.add_error(ERROR_SALT_TOO_LONG)\n    elif length < RECOMMENDED_SALT_LENGTH:\n        result.add_warning(f\"Salt length {length} is below recommended {RECOMMENDED_SALT_LENGTH} bytes\")\n    \n    return result\n\ndef validate_salt_format(format_name: str) -> ValidationResult:\n    \"\"\"Validate salt output format is supported.\"\"\"\n    result = ValidationResult()\n    \n    if not isinstance(format_name, str):\n        result.add_error(\"Salt format must be a string\")\n        return result\n    \n    valid_formats = [SALT_FORMAT_BINARY, SALT_FORMAT_BASE64, SALT_FORMAT_HEX]\n    if format_name not in valid_formats:\n        result.add_error(ERROR_INVALID_FORMAT)\n    \n    return result\n```\n\n#### Core Logic Skeleton Code\n\n**File: `src/salt_generation/salt_generator.py`** (Skeleton for learner implementation)\n\n```python\n\"\"\"\nCryptographically secure salt generation for password hashing.\n\nThis module provides the SaltGenerator class responsible for generating\nunique, random salt values that prevent rainbow table attacks.\n\"\"\"\nimport secrets\nimport base64\nimport time\nfrom typing import Optional, Dict, Any\nfrom datetime import datetime\n\nfrom ..common.constants import (\n    DEFAULT_SALT_LENGTH, DEFAULT_SALT_FORMAT,\n    SALT_FORMAT_BINARY, SALT_FORMAT_BASE64, SALT_FORMAT_HEX\n)\nfrom ..common.validation import validate_salt_length, validate_salt_format\nfrom ..common.exceptions import SaltGenerationError, ParameterValidationError\n\nclass SaltGenerator:\n    \"\"\"\n    Generates cryptographically secure random salts for password hashing.\n    \n    This component uses the operating system's cryptographic entropy sources\n    to generate unique, unpredictable salt values that prevent rainbow table\n    attacks and ensure each password hash is unique even for identical passwords.\n    \"\"\"\n    \n    def __init__(self, default_length: int = DEFAULT_SALT_LENGTH, \n                 algorithm: str = \"system_random\"):\n        \"\"\"\n        Initialize salt generator with security parameters.\n        \n        Args:\n            default_length: Default salt length in bytes\n            algorithm: Random generation algorithm (currently only \"system_random\")\n        \"\"\"\n        # TODO 1: Validate default_length using validate_salt_length()\n        # TODO 2: Store default_length and algorithm as instance variables\n        # TODO 3: Initialize any monitoring counters (salts_generated, errors_encountered)\n        # Hint: Reject invalid parameters immediately to fail fast\n        pass\n    \n    def generate_salt(self, length: Optional[int] = None) -> bytes:\n        \"\"\"\n        Generate cryptographically secure random salt.\n        \n        Args:\n            length: Salt length in bytes (uses default if None)\n            \n        Returns:\n            Random salt as bytes\n            \n        Raises:\n            SaltGenerationError: If salt generation fails\n            ParameterValidationError: If length parameter is invalid\n        \"\"\"\n        # TODO 1: Use self.default_length if length is None\n        # TODO 2: Validate length parameter using validate_salt_length()\n        # TODO 3: If validation fails, raise ParameterValidationError with validation.errors\n        # TODO 4: Use secrets.token_bytes(length) to generate cryptographically secure random bytes\n        # TODO 5: Validate that returned bytes are not all zeros (basic sanity check)\n        # TODO 6: Update internal counters (self.salts_generated += 1)\n        # TODO 7: Return the random bytes\n        # Hint: Wrap secrets.token_bytes() in try/except to catch OS-level entropy errors\n        pass\n    \n    def generate_salt_string(self, length: Optional[int] = None, \n                           format_name: str = DEFAULT_SALT_FORMAT) -> str:\n        \"\"\"\n        Generate salt and encode as string for text storage.\n        \n        Args:\n            length: Salt length in bytes\n            format_name: Output format (\"binary\", \"base64\", or \"hex\")\n            \n        Returns:\n            Encoded salt as string\n            \n        Raises:\n            SaltGenerationError: If salt generation fails\n            ParameterValidationError: If parameters are invalid\n        \"\"\"\n        # TODO 1: Validate format_name using validate_salt_format()\n        # TODO 2: Call self.generate_salt(length) to get raw bytes\n        # TODO 3: Encode bytes based on format_name:\n        #         - SALT_FORMAT_BASE64: use base64.b64encode().decode('ascii')\n        #         - SALT_FORMAT_HEX: use salt_bytes.hex()\n        #         - SALT_FORMAT_BINARY: raise error (binary data can't be string)\n        # TODO 4: Return encoded string\n        # Hint: Handle encoding errors by raising SaltGenerationError\n        pass\n    \n    def generate_salt_with_metadata(self, length: Optional[int] = None) -> Dict[str, Any]:\n        \"\"\"\n        Generate salt with additional metadata for monitoring and debugging.\n        \n        Args:\n            length: Salt length in bytes\n            \n        Returns:\n            Dictionary with salt bytes, length, timestamp, and generation info\n        \"\"\"\n        # TODO 1: Record start_time = time.time() for performance monitoring\n        # TODO 2: Call self.generate_salt(length) to generate salt bytes\n        # TODO 3: Calculate generation_time_ms = (time.time() - start_time) * 1000\n        # TODO 4: Build result dictionary with keys:\n        #         - 'salt': salt bytes\n        #         - 'length': actual length\n        #         - 'generated_at': datetime.now().isoformat()\n        #         - 'generation_time_ms': time taken\n        #         - 'algorithm': self.algorithm\n        # TODO 5: Return result dictionary\n        # Hint: This method is useful for testing and monitoring salt generation performance\n        pass\n    \n    def verify_salt_uniqueness(self, password_count: int, \n                              sample_size: int = 1000) -> Dict[str, Any]:\n        \"\"\"\n        Generate multiple salts and verify statistical uniqueness.\n        Used for testing and system validation.\n        \n        Args:\n            password_count: Simulated number of passwords in system\n            sample_size: Number of salts to generate for testing\n            \n        Returns:\n            Dictionary with uniqueness analysis results\n        \"\"\"\n        # TODO 1: Generate sample_size salts using self.generate_salt()\n        # TODO 2: Check for duplicate salts using set() or Counter\n        # TODO 3: Calculate collision probability based on birthday paradox\n        # TODO 4: Compare against theoretical collision probability for salt length\n        # TODO 5: Return analysis with keys:\n        #         - 'sample_size': number of salts generated\n        #         - 'unique_count': number of unique salts\n        #         - 'collision_count': number of collisions found\n        #         - 'theoretical_collision_prob': expected probability\n        #         - 'actual_collision_rate': observed rate\n        #         - 'uniqueness_acceptable': boolean assessment\n        # Hint: For 128-bit salts, collision probability should be negligible for reasonable sample sizes\n        pass\n    \n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get salt generation statistics for monitoring.\"\"\"\n        # TODO 1: Return dictionary with internal counters and configuration\n        # TODO 2: Include: salts_generated, default_length, algorithm, errors_encountered\n        # TODO 3: Add current timestamp as 'statistics_generated_at'\n        # Hint: Don't include any actual salt values in statistics\n        pass\n```\n\n#### Language-Specific Hints\n\n**Python Cryptographic Random Generation:**\n- Always use `secrets` module, never `random` module for cryptographic purposes\n- `secrets.token_bytes(n)` generates `n` cryptographically secure random bytes\n- `secrets.token_hex(n)` generates `2n` character hex string (n bytes worth)\n- Handle `OSError` from `secrets` functions - indicates entropy source problems\n\n**Error Handling Best Practices:**\n- Use custom exception types (`SaltGenerationError`) rather than generic exceptions\n- Include diagnostic information in exception messages (requested length, available entropy)\n- Log generation failures for monitoring but never log actual salt values\n- Fail fast on configuration errors rather than using unsafe defaults\n\n**Performance Considerations:**\n- Salt generation is typically fast (microseconds) but can vary with system load\n- Don't cache salts - generate fresh for each password\n- Monitor generation times to detect entropy source health issues\n- Consider rate limiting in high-throughput scenarios to prevent entropy exhaustion\n\n#### Milestone Checkpoint\n\nAfter implementing the `SaltGenerator` component, verify correct behavior with these tests:\n\n**Command to run:** `python -m pytest src/salt_generation/test_salt_generation.py -v`\n\n**Expected output:**\n```\ntest_generate_salt_length ✓ - Generates salts of requested length\ntest_generate_salt_uniqueness ✓ - All generated salts are unique\ntest_generate_salt_randomness ✓ - Salts pass basic randomness checks\ntest_invalid_length_rejection ✓ - Rejects salts shorter than minimum\ntest_format_encoding ✓ - Properly encodes salts in different formats\n```\n\n**Manual verification steps:**\n1. Generate 1000 salts and verify all are unique: `salt_gen.verify_salt_uniqueness(10000)`\n2. Test minimum length enforcement: try generating 8-byte salt (should fail)\n3. Test format encoding: generate salt in Base64 and hex formats\n4. Monitor generation timing: typical generation should take < 1ms\n\n**Signs something is wrong:**\n- **Symptom**: All generated salts are identical → **Cause**: Using `random` instead of `secrets`\n- **Symptom**: Salt generation raises `OSError` → **Cause**: Entropy exhaustion, test in VM with more entropy\n- **Symptom**: Base64 encoded salts contain invalid characters → **Cause**: Encoding raw bytes incorrectly\n- **Symptom**: Validation always fails → **Cause**: Length validation logic incorrect\n\n\n## Basic Hashing Component\n\n> **Milestone(s):** Milestone 1 (Basic Hashing with Salt)\n\n### Mental Model: The Sealed Envelope Authentication System\n\nThink of the basic hashing component like a postal authentication system for confidential documents. When someone sends a confidential message, they don't just put it in a plain envelope that anyone could intercept and read. Instead, they use a sophisticated sealing process: they mix their message with a unique, unpredictable substance (like invisible ink with a random chemical composition), then run the entire mixture through a document shredder that creates a distinctive pattern of confetti. The resulting confetti pattern becomes the \"proof\" that the original message existed, without revealing what the message actually said.\n\nLater, when someone claims to have the original message, the authentication process reverses this: they mix their claimed message with the same random substance (which was stored alongside the confetti pattern), shred it the same way, and check if the new confetti pattern matches the stored one. If the patterns match exactly, the message is authentic. If even one word was different, the confetti patterns would be completely different due to the chaotic nature of the shredding process.\n\nThe `BasicHasher` component implements this sealed envelope system for passwords. It combines each password with a unique random salt (the invisible ink), runs the mixture through SHA-256 hashing (the document shredder), and stores both the resulting hash (confetti pattern) and the salt for later verification. The component also ensures that the comparison process takes exactly the same amount of time regardless of whether the password is correct or incorrect, preventing attackers from using timing differences to gradually guess the password.\n\n### Hash Computation Algorithm\n\nThe hash computation process transforms a plain password into a cryptographically secure representation that cannot be reversed to recover the original password. This transformation involves carefully combining the password with random data before applying the hash function to prevent precomputed attack strategies.\n\nThe `BasicHasher` component implements a systematic approach to password hashing that builds upon the salt generation capabilities established in the previous component. The hasher maintains a reference to a `SaltGenerator` instance and uses SHA-256 as its underlying cryptographic primitive. This combination provides the foundation for secure password storage while remaining computationally efficient for legitimate authentication attempts.\n\n> **Decision: Salt-Password Concatenation Strategy**\n> - **Context**: The system must combine the password with the salt before hashing, and the order and method of combination affects security properties and implementation complexity.\n> - **Options Considered**: \n>   1. Simple concatenation (salt + password)\n>   2. Interleaved combination (alternating salt and password bytes)\n>   3. HMAC-style construction with salt as key\n> - **Decision**: Simple concatenation with salt prepended to password\n> - **Rationale**: Simple concatenation provides equivalent security to more complex schemes when using a cryptographically secure hash function like SHA-256, while being easier to implement correctly and debug. The prepended salt position follows common cryptographic library conventions and ensures the salt affects the hash computation from the first block.\n> - **Consequences**: Enables straightforward implementation with minimal error potential, maintains compatibility with standard practices, and provides full protection against rainbow table attacks.\n\n| Concatenation Strategy | Security Level | Implementation Complexity | Performance | Chosen? |\n|------------------------|----------------|---------------------------|-------------|---------|\n| Salt + Password | High | Low | Fast | ✓ |\n| Interleaved bytes | High | Medium | Slower | |\n| HMAC construction | High | High | Slower | |\n\nThe hash computation algorithm follows a precise sequence of steps that ensures consistent and secure processing of password data:\n\n1. **Input Validation**: The algorithm begins by validating that the input password is provided as a string or bytes object and that it meets basic length requirements (not empty, not exceeding reasonable maximum length).\n\n2. **Salt Generation Invocation**: The hasher calls its `SaltGenerator` instance to produce a cryptographically random salt of the configured length (typically 32 bytes for enhanced security).\n\n3. **Encoding Normalization**: The password string undergoes UTF-8 encoding to convert it into a consistent byte representation, ensuring that identical passwords produce identical byte sequences regardless of how they were input.\n\n4. **Salt-Password Concatenation**: The algorithm concatenates the raw salt bytes directly with the UTF-8 encoded password bytes, placing the salt at the beginning of the combined sequence to ensure it influences the hash computation from the first hash block.\n\n5. **SHA-256 Hash Computation**: The concatenated byte sequence passes through the SHA-256 hash function, which produces a deterministic 256-bit (32-byte) hash output that appears random and cannot be reversed to recover the input.\n\n6. **Result Structure Creation**: The algorithm constructs a `PasswordHashRecord` containing the original salt, the computed hash, algorithm metadata, and timestamp information for future verification needs.\n\n7. **Security Metadata Population**: The hash record receives additional security metadata including the algorithm name (\"sha256_with_salt\"), version identifier, and creation timestamp for audit and migration purposes.\n\nThe `hash_password` method implements this algorithm with careful attention to memory management and error handling:\n\n| Method Component | Input Type | Output Type | Purpose |\n|------------------|------------|-------------|---------|\n| `password` parameter | `str` or `bytes` | N/A | Raw password to be hashed |\n| `salt` parameter | `bytes` (optional) | N/A | Pre-generated salt or None for auto-generation |\n| Salt generation | N/A | `bytes` | Cryptographically random salt |\n| UTF-8 encoding | `str` | `bytes` | Normalized password representation |\n| Concatenation | `bytes` + `bytes` | `bytes` | Combined salt and password |\n| SHA-256 hashing | `bytes` | `bytes` | Irreversible hash computation |\n| Record creation | Multiple inputs | `PasswordHashRecord` | Complete hash information package |\n\n> The critical insight here is that the salt must be generated fresh for each password hashing operation, never reused across different passwords, and stored alongside the hash for verification. Reusing salts across passwords would allow attackers to optimize their attacks across multiple accounts simultaneously.\n\n**Walk-through Example**: Consider hashing the password \"SecurePass123\" with a randomly generated 32-byte salt. The salt generation produces bytes like `[0x4a, 0x7b, 0x2f, ...]` (32 bytes total). The password encodes to UTF-8 bytes `[0x53, 0x65, 0x63, 0x75, 0x72, 0x65, 0x50, 0x61, 0x73, 0x73, 0x31, 0x32, 0x33]`. Concatenation produces a 45-byte sequence starting with the 32 salt bytes followed by the 13 password bytes. SHA-256 processes this combined sequence and outputs a 32-byte hash like `[0xa4, 0xd2, 0x9e, ...]`. The resulting `PasswordHashRecord` stores both the original salt and the computed hash, enabling future verification of the same password.\n\n### Timing Attack Prevention\n\nTiming attacks represent a subtle but serious vulnerability in password verification systems where attackers can extract information about stored passwords by measuring how long verification operations take to complete. These attacks exploit the fact that many comparison operations terminate early when they encounter the first differing byte, causing shorter execution times for incorrect guesses that differ early in the sequence compared to incorrect guesses that match more of the stored hash.\n\nThe `BasicHasher` component implements **constant-time comparison** techniques to ensure that password verification operations consume identical amounts of time regardless of whether the provided password is correct, incorrect, or how many bytes of the computed hash match the stored hash. This timing consistency prevents attackers from using execution time measurements to gradually deduce information about the stored password hashes.\n\n> **Decision: Constant-Time Comparison Implementation Strategy**\n> - **Context**: Password verification must compare computed hashes with stored hashes without leaking timing information that could enable side-channel attacks.\n> - **Options Considered**:\n>   1. Built-in language comparison operators (`==`, `equals()`)\n>   2. Custom byte-by-byte XOR accumulation\n>   3. Cryptographic library constant-time comparison functions\n> - **Decision**: Custom XOR accumulation with full-length processing\n> - **Rationale**: Built-in operators typically use optimized short-circuit logic that terminates on first difference, creating timing variations. Custom implementation provides full control over timing behavior and doesn't depend on external library availability. XOR accumulation processes every byte regardless of matches, ensuring consistent timing.\n> - **Consequences**: Eliminates timing side-channel vulnerabilities at the cost of slightly more complex implementation and marginally slower comparisons for obviously incorrect inputs.\n\n| Comparison Approach | Timing Consistency | Implementation Complexity | Library Dependency | Chosen? |\n|---------------------|-------------------|---------------------------|-------------------|---------|\n| Built-in operators | Poor (short-circuit) | Low | None | |\n| XOR accumulation | Excellent | Medium | None | ✓ |\n| Library functions | Excellent | Low | High | |\n\nThe timing attack vulnerability manifests when verification code uses standard comparison operations that optimize for speed by returning immediately upon finding the first differing byte. An attacker can exploit this by:\n\n1. **Baseline Measurement**: Measuring the time required for obviously incorrect password attempts to establish baseline verification timing.\n\n2. **Systematic Probing**: Attempting password guesses designed to match progressively more bytes of the actual hash, looking for timing increases that indicate longer partial matches.\n\n3. **Statistical Analysis**: Performing multiple timing measurements for each guess to filter out system noise and identify consistent timing patterns.\n\n4. **Progressive Reconstruction**: Using timing differences to gradually reconstruct information about the stored hash, potentially enabling more efficient brute force attacks.\n\nThe `constant_time_compare` function implements timing attack resistance through several carefully designed mechanisms:\n\n**Algorithm Steps for Constant-Time Comparison**:\n\n1. **Length Preprocessing**: The function first checks if the two input byte sequences have different lengths, but continues processing rather than returning immediately to avoid length-based timing leaks.\n\n2. **Accumulator Initialization**: An integer accumulator variable initializes to zero and will collect the XOR results of all byte comparisons throughout the entire comparison process.\n\n3. **Full-Length Iteration**: The function iterates through every byte position in both sequences, always processing the full length of the longer sequence to ensure consistent iteration counts.\n\n4. **Byte-Wise XOR Accumulation**: For each byte position, the function XORs the corresponding bytes from both sequences and accumulates the result, ensuring that identical bytes contribute zero to the accumulator while different bytes contribute non-zero values.\n\n5. **Padding Handling**: When sequences have different lengths, the shorter sequence is effectively padded with zero bytes for comparison purposes, ensuring length differences still produce non-zero accumulator results.\n\n6. **Final Result Determination**: After processing all byte positions, the function returns True if and only if the accumulator equals zero (indicating all bytes matched) and the lengths were identical.\n\n7. **Timing Consistency Verification**: The entire process consumes the same number of CPU cycles regardless of where differences occur in the sequences or whether the sequences match completely.\n\n| Function Component | Input Processing | Timing Behavior | Security Property |\n|--------------------|------------------|-----------------|-------------------|\n| Length check | Always performed | Constant | Prevents length-based timing leaks |\n| XOR accumulation | All bytes processed | Constant per byte | Eliminates position-based timing leaks |\n| Loop iteration | Full length always | Constant iteration count | Prevents short-circuit timing variations |\n| Result computation | Single comparison | Constant | No early termination timing leaks |\n\nThe `verify_password` method integrates constant-time comparison into the complete verification workflow:\n\n1. **Hash Recomputation**: The method takes the provided password, extracts the stored salt from the `PasswordHashRecord`, and recomputes the hash using identical steps to the original hashing process.\n\n2. **Constant-Time Hash Comparison**: The method invokes `constant_time_compare` to compare the newly computed hash with the stored hash from the record, ensuring timing consistency regardless of the comparison outcome.\n\n3. **Boolean Result Return**: The method returns True if the hashes match (indicating correct password) or False otherwise, with identical timing characteristics for both cases.\n\n> ⚠️ **Pitfall: Using Built-in Comparison Operators**\n> Many developers instinctively use language built-in comparison operators like `==` in Python or `bytes.Equal()` in Go for hash comparison. These operators are optimized for performance and typically implement short-circuit logic that returns False as soon as the first differing byte is found. This creates a timing side-channel where incorrect passwords that happen to match more bytes of the stored hash take longer to reject than passwords that differ in early bytes. Attackers can exploit this timing difference to gradually extract information about the stored hash. The fix is to always use constant-time comparison functions that process every byte of both sequences regardless of where differences occur.\n\n**Timing Attack Demonstration Example**: Consider an attacker probing a system that uses vulnerable comparison logic. The stored hash begins with bytes `[0xa4, 0xd2, 0x9e, 0x7f, ...]`. The attacker submits passwords that generate hashes beginning with `[0x12, ...]`, `[0xa4, 0x13, ...]`, and `[0xa4, 0xd2, 0x15, ...]`. The first guess fails immediately at byte 0, taking ~10 microseconds. The second guess fails at byte 1, taking ~12 microseconds. The third guess fails at byte 2, taking ~14 microseconds. This timing progression reveals that the stored hash begins with `[0xa4, 0xd2, ...]`, giving the attacker partial information to optimize subsequent attacks. With constant-time comparison, all three guesses would take exactly ~50 microseconds regardless of where they differ, preventing information leakage.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Salt Reuse Across Password Changes**\nSome implementations attempt to \"optimize\" storage by reusing the same salt when a user changes their password, thinking this saves space or computation time. This approach catastrophically weakens security because it allows attackers who compromise one hash to immediately apply the same rainbow table or precomputed attacks to the user's new password. Each password hashing operation must generate a fresh, cryptographically random salt, even for the same user account. The storage overhead of additional salt bytes is negligible compared to the security benefit.\n\n⚠️ **Pitfall: Concatenating Password Before Salt**\nWhile either concatenation order (salt+password or password+salt) provides equivalent cryptographic security, choosing password+salt creates compatibility issues with many standard tools and libraries that expect salt-first ordering. More critically, some developers mistakenly believe they can optimize by putting the password first and truncating the hash computation early, which would eliminate the salt's protection entirely. Always concatenate salt+password to follow established conventions and avoid implementation mistakes.\n\n⚠️ **Pitfall: Converting Strings to Bytes Inconsistently**\nPassword strings must undergo consistent encoding to bytes before hashing, typically using UTF-8. Some implementations mix encoding schemes (UTF-8 for registration, Latin-1 for verification) or apply platform-specific default encodings that vary between systems. This creates a situation where the same password string produces different byte sequences and therefore different hashes, making verification impossible. Always explicitly specify UTF-8 encoding for password-to-bytes conversion and use the same encoding consistently across all operations.\n\n⚠️ **Pitfall: Ignoring Timing Attack Vectors Beyond Hash Comparison**\nWhile implementing constant-time hash comparison is crucial, some developers focus only on the final comparison step and ignore timing leaks in other parts of the verification process. For example, spending different amounts of time on salt extraction, hash recomputation setup, or error handling based on the input characteristics can still leak information. The entire verification function should maintain consistent timing characteristics, not just the final comparison operation.\n\n⚠️ **Pitfall: Inadequate Error Information in Hash Records**\nWhen hash computation fails due to invalid inputs, memory exhaustion, or algorithm unavailability, some implementations either crash the application or return incomplete hash records that cause verification failures later. The `BasicHasher` should validate inputs thoroughly, handle all anticipated error conditions gracefully, and ensure that any successfully returned `PasswordHashRecord` contains all information needed for future verification. Failed operations should raise specific exception types that calling code can handle appropriately.\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Hash Library | `hashlib` (Python standard library) | `cryptography` library with FIPS compliance |\n| Salt Generation | `secrets` module (Python 3.6+) | Hardware security module integration |\n| Timing Functions | `time.perf_counter()` for benchmarking | `timeit` module for statistical analysis |\n| Serialization | JSON with base64 encoding | Protocol Buffers with binary efficiency |\n| Testing | `unittest` with manual test cases | `pytest` with property-based testing |\n\n#### Recommended File Structure\n\nThe basic hashing component integrates into the overall project structure as a focused module with clear dependencies:\n\n```\nproject-root/\n  src/password_hashing/\n    __init__.py                 ← package initialization\n    salt_generator.py           ← SaltGenerator implementation (from previous milestone)\n    basic_hasher.py            ← BasicHasher implementation (this component)\n    data_models.py             ← PasswordHashRecord and related structures\n    exceptions.py              ← Custom exception classes\n    utils/\n      timing_utils.py          ← Constant-time comparison utilities\n      validation_utils.py      ← Input validation helpers\n  tests/\n    test_basic_hasher.py       ← BasicHasher unit tests\n    test_timing_attacks.py     ← Timing attack resistance verification\n    test_integration.py        ← End-to-end password hashing workflows\n  examples/\n    basic_usage.py             ← Simple usage demonstrations\n```\n\n#### Infrastructure Starter Code\n\n**File: `src/password_hashing/exceptions.py`**\n```python\n\"\"\"Custom exception classes for password hashing operations.\"\"\"\n\nclass PasswordHashingError(Exception):\n    \"\"\"Base exception class for password hashing failures.\"\"\"\n    pass\n\nclass SaltGenerationError(PasswordHashingError):\n    \"\"\"Raised when salt generation fails due to entropy or system issues.\"\"\"\n    pass\n\nclass HashComputationError(PasswordHashingError):\n    \"\"\"Raised when hash computation fails due to algorithm or input issues.\"\"\"\n    pass\n\nclass ValidationError(PasswordHashingError):\n    \"\"\"Raised when input validation fails due to invalid parameters.\"\"\"\n    pass\n```\n\n**File: `src/password_hashing/utils/timing_utils.py`**\n```python\n\"\"\"Timing attack prevention utilities.\"\"\"\n\nimport time\nfrom typing import List, Dict, Any\n\ndef constant_time_compare(a: bytes, b: bytes) -> bool:\n    \"\"\"\n    Compare two byte sequences in constant time to prevent timing attacks.\n    \n    Args:\n        a: First byte sequence\n        b: Second byte sequence\n        \n    Returns:\n        True if sequences are identical, False otherwise\n        \n    Note:\n        This function always processes the full length of both sequences\n        and takes the same amount of time regardless of where differences\n        occur or whether the sequences match.\n    \"\"\"\n    # Implementation provided as starter code since timing attacks\n    # are subtle and easy to implement incorrectly\n    \n    if len(a) != len(b):\n        # Still process bytes to maintain timing consistency\n        result = 1  # Mark as different due to length mismatch\n    else:\n        result = 0\n    \n    # Process all bytes in the longer sequence\n    max_len = max(len(a), len(b)) if a or b else 0\n    \n    for i in range(max_len):\n        byte_a = a[i] if i < len(a) else 0\n        byte_b = b[i] if i < len(b) else 0\n        result |= byte_a ^ byte_b\n    \n    return result == 0\n\ndef verify_timing_safety(func, test_cases: List[Any], tolerance_ms: float = 1.0) -> Dict[str, Any]:\n    \"\"\"\n    Verify that a function has consistent timing across different inputs.\n    \n    Args:\n        func: Function to test for timing consistency\n        test_cases: List of input parameters to test\n        tolerance_ms: Maximum acceptable timing variation in milliseconds\n        \n    Returns:\n        Dictionary with timing analysis results\n    \"\"\"\n    timings = []\n    \n    for case in test_cases:\n        start_time = time.perf_counter()\n        func(*case if isinstance(case, tuple) else (case,))\n        end_time = time.perf_counter()\n        timings.append((end_time - start_time) * 1000)  # Convert to milliseconds\n    \n    min_time = min(timings)\n    max_time = max(timings)\n    avg_time = sum(timings) / len(timings)\n    variation = max_time - min_time\n    \n    return {\n        'min_time_ms': min_time,\n        'max_time_ms': max_time,\n        'avg_time_ms': avg_time,\n        'variation_ms': variation,\n        'is_timing_safe': variation <= tolerance_ms,\n        'timing_measurements': timings\n    }\n```\n\n#### Core Logic Skeleton Code\n\n**File: `src/password_hashing/basic_hasher.py`**\n```python\n\"\"\"BasicHasher implementation for SHA-256 password hashing with salt.\"\"\"\n\nimport hashlib\nimport json\nfrom datetime import datetime\nfrom typing import Optional, Dict, Any\n\nfrom .salt_generator import SaltGenerator\nfrom .data_models import PasswordHashRecord\nfrom .exceptions import HashComputationError, ValidationError\nfrom .utils.timing_utils import constant_time_compare\n\nclass BasicHasher:\n    \"\"\"\n    Implements SHA-256 based password hashing with cryptographic salt.\n    \n    This hasher provides the foundation for secure password storage by\n    combining passwords with random salts before hashing to prevent\n    rainbow table attacks and ensure unique hashes for identical passwords.\n    \"\"\"\n    \n    def __init__(self, salt_generator: Optional[SaltGenerator] = None, algorithm: str = \"sha256_with_salt\"):\n        # TODO 1: Initialize salt_generator (create default if None provided)\n        # TODO 2: Store algorithm identifier for hash record metadata\n        # TODO 3: Validate that algorithm parameter is supported\n        # Hint: Store both salt_generator and algorithm as instance variables\n        pass\n    \n    def hash_password(self, password: str, salt: Optional[bytes] = None) -> Dict[str, Any]:\n        \"\"\"\n        Hash a password with cryptographic salt using SHA-256.\n        \n        Args:\n            password: Plain text password to hash\n            salt: Optional pre-generated salt (generates new salt if None)\n            \n        Returns:\n            Dictionary containing hash record information\n            \n        Raises:\n            ValidationError: If password is invalid\n            HashComputationError: If hashing operation fails\n        \"\"\"\n        # TODO 1: Validate password input (not None, not empty, reasonable length)\n        # TODO 2: Generate salt if not provided (use self.salt_generator.generate_salt())\n        # TODO 3: Encode password to UTF-8 bytes for consistent processing\n        # TODO 4: Concatenate salt bytes with password bytes (salt first)\n        # TODO 5: Compute SHA-256 hash of concatenated bytes\n        # TODO 6: Create PasswordHashRecord with salt, hash, and metadata\n        # TODO 7: Return hash record as dictionary for easy serialization\n        # Hint: Use hashlib.sha256() and .digest() for hash computation\n        # Hint: Include algorithm, version, and timestamp in hash record\n        pass\n    \n    def verify_password(self, password: str, hash_record: PasswordHashRecord) -> bool:\n        \"\"\"\n        Verify a password against a stored hash record using constant-time comparison.\n        \n        Args:\n            password: Plain text password to verify\n            hash_record: Stored hash record containing salt and hash\n            \n        Returns:\n            True if password matches the hash record, False otherwise\n            \n        Note:\n            This method uses constant-time comparison to prevent timing attacks\n            that could leak information about the stored hash.\n        \"\"\"\n        # TODO 1: Validate input parameters (password not None, hash_record valid)\n        # TODO 2: Extract salt from hash record\n        # TODO 3: Recompute hash using the same algorithm as original hashing\n        # TODO 4: Use constant_time_compare to compare computed hash with stored hash\n        # TODO 5: Return comparison result (True for match, False for mismatch)\n        # Hint: Reuse hash_password method with extracted salt for consistency\n        # Hint: Handle any exceptions from hash computation gracefully\n        pass\n    \n    def _validate_password_input(self, password: str) -> None:\n        \"\"\"\n        Validate password input for security and correctness requirements.\n        \n        Args:\n            password: Password string to validate\n            \n        Raises:\n            ValidationError: If password fails validation checks\n        \"\"\"\n        # TODO 1: Check that password is not None\n        # TODO 2: Check that password is not empty string\n        # TODO 3: Check that password length is reasonable (not too long for DoS prevention)\n        # TODO 4: Verify password is string type (not bytes or other types)\n        # Hint: Maximum reasonable password length might be 1000-4096 characters\n        # Hint: Raise ValidationError with descriptive message for each failure\n        pass\n```\n\n#### Language-Specific Hints\n\n**Python-Specific Implementation Details:**\n\n- Use `hashlib.sha256()` from the standard library for hash computation rather than third-party libraries for maximum compatibility\n- Call `.digest()` on hash objects to get raw bytes rather than `.hexdigest()` which returns hex strings and wastes storage space\n- Use `secrets.token_bytes()` for salt generation as it provides cryptographically secure randomness on all platforms\n- Store the `SaltGenerator` instance as `self.salt_generator` to enable dependency injection and testing flexibility\n- Import `datetime.datetime.now()` for timestamp generation, but consider using UTC with `datetime.utcnow()` for consistency across timezones\n- Handle encoding explicitly with `password.encode('utf-8')` rather than relying on default encoding behavior\n- Use type hints consistently (`bytes`, `str`, `Optional[bytes]`) to catch type-related errors early during development\n\n**Error Handling Patterns:**\n- Wrap `hashlib.sha256()` calls in try-except blocks to catch potential system-level failures\n- Validate all inputs at method entry points rather than assuming calling code provides correct data\n- Raise custom exception types (`ValidationError`, `HashComputationError`) rather than generic `Exception` to enable targeted error handling\n- Include descriptive error messages that help developers debug issues without revealing sensitive information\n\n#### Milestone Checkpoint\n\nAfter implementing the `BasicHasher` component, verify correct functionality through these concrete checkpoints:\n\n**Unit Test Execution:**\n```bash\ncd project-root/\npython -m pytest tests/test_basic_hasher.py -v\n```\n\n**Expected Test Output:**\n```\ntests/test_basic_hasher.py::test_hash_password_generates_unique_salts PASSED\ntests/test_basic_hasher.py::test_hash_password_different_passwords_different_hashes PASSED  \ntests/test_basic_hasher.py::test_verify_password_correct_password_returns_true PASSED\ntests/test_basic_hasher.py::test_verify_password_incorrect_password_returns_false PASSED\ntests/test_basic_hasher.py::test_constant_time_comparison PASSED\n==================== 5 passed in 0.12s ====================\n```\n\n**Manual Verification Script:**\n```python\nfrom src.password_hashing.basic_hasher import BasicHasher\n\n# Test basic functionality\nhasher = BasicHasher()\npassword = \"TestPassword123\"\n\n# Hash the password\nhash_result = hasher.hash_password(password)\nprint(f\"Hash computed successfully: {len(hash_result['hash'])} bytes\")\nprint(f\"Salt generated: {len(hash_result['salt'])} bytes\")\n\n# Verify correct password\nverification_result = hasher.verify_password(password, hash_result)\nprint(f\"Correct password verification: {verification_result}\")  # Should be True\n\n# Verify incorrect password\nwrong_verification = hasher.verify_password(\"WrongPassword\", hash_result)  \nprint(f\"Incorrect password verification: {wrong_verification}\")  # Should be False\n```\n\n**Security Property Verification:**\n- **Salt Uniqueness**: Hash the same password 100 times and verify all salts are different\n- **Hash Uniqueness**: Verify that identical passwords with different salts produce different hashes  \n- **Timing Consistency**: Use the provided `verify_timing_safety` function to confirm verification timing is consistent\n- **Round-Trip Consistency**: Ensure any password that hashes successfully can be verified correctly\n\n**Signs of Implementation Issues:**\n\n| Symptom | Likely Cause | Diagnostic Check | Fix |\n|---------|--------------|------------------|-----|\n| Same hash for same password | Salt not being generated or used | Check if salt varies between calls | Ensure fresh salt generation per hash |\n| Verification always returns False | Encoding inconsistency | Print byte values during hash/verify | Use consistent UTF-8 encoding |\n| Timing attack test fails | Using built-in comparison | Time multiple verification calls | Implement constant_time_compare correctly |\n| Hash record missing fields | Incomplete record construction | Check PasswordHashRecord contents | Include all required metadata fields |\n| Import errors | Missing dependencies | Check module structure | Verify all files in correct locations |\n\n\n## Key Stretching Component\n\n> **Milestone(s):** Milestone 2 (Key Stretching)\n\n### Mental Model: The Time Lock Vault Analogy\n\nThink of key stretching like a bank's time lock vault mechanism. A traditional safe might take a few seconds for someone with the combination to open, but a skilled safecracker could potentially break it in hours using specialized tools. A time lock vault, however, has a built-in delay mechanism—even with the correct combination, the vault takes exactly 10 minutes to open, no matter what. This delay doesn't inconvenience legitimate bank employees (10 minutes is acceptable), but it makes a brute force attack completely impractical—trying 10,000 combinations would take over 69 days of continuous attempts.\n\nKey stretching works the same way for passwords. While a simple hash like SHA-256 takes microseconds to compute, key stretching algorithms like PBKDF2 intentionally take hundreds of milliseconds by performing thousands of internal hash operations. This delay is barely noticeable to a legitimate user logging in once, but transforms a brute force attack that might take hours into one requiring decades. The \"time lock\" is implemented through iteration counts—performing the same cryptographic operation thousands of times in sequence, with each round depending on the previous one, making parallel computation impossible.\n\n### PBKDF2 Algorithm Implementation\n\n**PBKDF2 (Password-Based Key Derivation Function 2)** represents a fundamental shift from simple hashing to intentionally slow key derivation. Unlike basic hashing where the goal is computational efficiency, PBKDF2's primary purpose is controlled computational expense. The algorithm transforms a password and salt into a derived key through thousands of iterative HMAC operations, creating what cryptographers call a \"computational bottleneck\" that equally affects both legitimate users and attackers.\n\n#### Core PBKDF2 Architecture\n\nThe PBKDF2 algorithm operates through a carefully designed iteration structure that builds upon the cryptographic properties of HMAC (Hash-based Message Authentication Code). The fundamental architecture consists of multiple rounds of HMAC computation, where each round takes the output of the previous round as input, creating a sequential dependency chain that cannot be parallelized or short-circuited.\n\n| Component | Purpose | Security Property | Performance Impact |\n|-----------|---------|------------------|-------------------|\n| HMAC-SHA256 Core | Provides pseudorandom function for each iteration | Cryptographic strength via proven hash function | Constant time per iteration |\n| Iteration Counter | Tracks current round number in derivation process | Ensures exact iteration count is performed | Linear scaling with count |\n| Block Generator | Produces multiple output blocks for longer keys | Enables configurable output key length | Scales with desired key length |\n| XOR Accumulator | Combines intermediate values across iterations | Prevents intermediate value attacks | Minimal overhead |\n\nThe iteration structure creates what cryptographers term \"memory-hard\" properties at the algorithmic level—while PBKDF2 doesn't require significant memory like Argon2, it requires significant time that scales linearly with the iteration count. This time-cost scaling is the crucial security property that makes brute force attacks computationally prohibitive.\n\n> **Decision: HMAC-SHA256 as PBKDF2 Pseudorandom Function**\n> - **Context**: PBKDF2 requires a pseudorandom function (PRF) for its iterative operations, with SHA-1, SHA-256, and other hash functions as options\n> - **Options Considered**: \n>   1. HMAC-SHA1 (original PBKDF2 standard)\n>   2. HMAC-SHA256 (stronger hash function)\n>   3. HMAC-SHA512 (maximum strength but slower)\n> - **Decision**: Use HMAC-SHA256 as the pseudorandom function\n> - **Rationale**: SHA-256 provides significantly stronger cryptographic security than SHA-1 without the performance penalty of SHA-512, and is widely supported across platforms\n> - **Consequences**: Each iteration takes approximately 2x longer than SHA-1 but provides quantum-resistant security properties and compatibility with modern cryptographic standards\n\n#### PBKDF2 Internal Algorithm Flow\n\nThe PBKDF2 derivation process follows a precise mathematical specification (RFC 2898) that ensures consistent results across implementations while maintaining the desired security properties. Understanding this internal flow is crucial for both implementation and security analysis.\n\n![PBKDF2 Key Derivation Process](./diagrams/pbkdf2-process.svg)\n\nThe algorithm operates through the following detailed steps:\n\n1. **Input Validation and Preprocessing**: The function receives the password (as bytes), salt (minimum 16 bytes), iteration count (minimum 100,000), and desired output key length. Input validation ensures the salt meets minimum entropy requirements and the iteration count provides adequate security.\n\n2. **Block Count Calculation**: PBKDF2 divides the desired output length into blocks, where each block produces exactly 32 bytes (for SHA-256). The number of blocks required equals `ceil(desired_length / 32)`, enabling the generation of arbitrarily long derived keys.\n\n3. **Block Generation Loop**: For each required block, PBKDF2 performs the complete iteration process independently. This block-wise generation enables parallel computation of different blocks while maintaining the sequential dependency within each block.\n\n4. **Initial HMAC Computation**: The first iteration computes `HMAC-SHA256(password, salt || block_number)` where `block_number` is a 4-byte big-endian integer. This initial computation incorporates both the salt and block identifier into the derivation process.\n\n5. **Iterative HMAC Chain**: For iterations 2 through N, the algorithm computes `HMAC-SHA256(password, previous_iteration_result)`. This creates a sequential chain where each iteration depends on the complete result of the previous iteration, preventing any computational shortcuts.\n\n6. **XOR Accumulation**: Throughout the iteration process, PBKDF2 maintains an accumulator that XORs together the results of every iteration. This accumulation ensures that an attacker cannot skip intermediate iterations—the final result depends on every single iteration being computed correctly.\n\n7. **Block Concatenation**: After completing all iterations for all required blocks, the algorithm concatenates the block results and truncates to the exact desired output length.\n\n| Step | Input | Operation | Output | Security Property |\n|------|-------|-----------|---------|------------------|\n| 1 | Password, Salt | Validate inputs meet minimum requirements | Validated parameters | Prevents weak inputs |\n| 2 | Desired length | Calculate required blocks (ceil(length/32)) | Block count | Enables arbitrary key lengths |\n| 3 | Password, Salt, Block# | HMAC-SHA256(password, salt\\|\\|block#) | Initial block value | Incorporates salt and position |\n| 4-N | Password, Previous | HMAC-SHA256(password, previous_result) | Iteration result | Creates computational dependency |\n| Accumulate | All iterations | XOR all iteration results | Final block value | Requires complete computation |\n| Final | All blocks | Concatenate and truncate blocks | Derived key | Produces final key material |\n\n#### Cryptographic Security Properties\n\nPBKDF2's security effectiveness stems from several carefully designed cryptographic properties that work together to resist various attack vectors. These properties distinguish PBKDF2 from simple iterative hashing approaches that might seem similar but lack crucial security guarantees.\n\nThe **computational amplification** property ensures that password verification requires exactly N HMAC operations, where N is the iteration count. Unlike simple loop constructions, PBKDF2's sequential dependency prevents attackers from reducing computational costs through parallelization, specialized hardware optimization, or algorithmic shortcuts. Each HMAC operation requires the complete result of the previous operation, creating an unavoidable computational bottleneck.\n\nThe **uniform difficulty scaling** property means that the computational cost increases linearly with iteration count for both legitimate users and attackers. Doubling the iteration count exactly doubles the computation time for password verification, providing predictable security scaling. This linear scaling enables precise tuning of the security-performance trade-off based on available hardware and security requirements.\n\n> The critical insight is that PBKDF2's sequential structure creates \"proof of work\" requirements—there is no way to verify a password without performing exactly the same computational work required for derivation, making offline attacks computationally equivalent to online attacks in terms of per-attempt cost.\n\nThe **avalanche resistance** property ensures that small changes in password, salt, or iteration count produce completely different derived keys. This property prevents attackers from using partial computation results or finding computational shortcuts based on input similarities. The HMAC construction provides this avalanche effect throughout the iteration chain.\n\n#### Implementation Architecture Decisions\n\nThe key stretching component requires careful architectural decisions that balance security, performance, and implementation complexity. These decisions affect both the immediate functionality and long-term maintainability of the password hashing system.\n\n> **Decision: Configurable vs Fixed Iteration Counts**\n> - **Context**: Systems can either use fixed iteration counts for all passwords or allow configuration per password record\n> - **Options Considered**:\n>   1. Fixed global iteration count (simpler implementation)\n>   2. Per-record configurable counts (flexible but complex)\n>   3. Time-based adaptive counts (automatic but unpredictable)\n> - **Decision**: Use per-record configurable iteration counts with sensible defaults\n> - **Rationale**: Different passwords may have different security requirements, and iteration counts must increase over time as hardware improves\n> - **Consequences**: Requires storing iteration count with each password hash but enables security evolution and customization\n\n| Implementation Approach | Pros | Cons | Complexity |\n|-------------------------|------|------|------------|\n| Fixed Global Count | Simple configuration, consistent performance | Cannot evolve security over time | Low |\n| Per-Record Configuration | Flexible security levels, future-proof | Complex parameter management | Medium |\n| Adaptive Time-Based | Automatic hardware scaling | Unpredictable performance, complex | High |\n\nThe per-record approach enables **algorithm agility** at the parameter level—newer password hashes can use higher iteration counts without requiring migration of existing hashes. This approach also supports different security contexts where some passwords require stronger protection than others.\n\n> **Decision: Memory-Efficient vs Memory-Hard Implementation**\n> - **Context**: PBKDF2 can be implemented to use minimal memory or to deliberately consume significant memory\n> - **Options Considered**:\n>   1. Memory-efficient implementation (minimal RAM usage)\n>   2. Memory-hard variant (deliberate memory consumption)\n>   3. Configurable memory usage (complexity increase)\n> - **Decision**: Implement memory-efficient PBKDF2 as specified in RFC 2898\n> - **Rationale**: Standard PBKDF2 provides time-based security, and memory-hard requirements are better addressed by dedicated algorithms like Argon2\n> - **Consequences**: Lower memory requirements but potential vulnerability to custom hardware attacks\n\nThe memory-efficient approach maintains compatibility with standard PBKDF2 implementations while keeping resource requirements predictable. Memory-hard properties are intentionally deferred to Milestone 3's Argon2 implementation, maintaining clear separation of algorithmic concerns.\n\n### Iteration Count Tuning\n\n**Iteration count tuning** represents one of the most critical security decisions in key stretching implementation. Unlike cryptographic key lengths where \"more is always better,\" iteration counts require careful balancing between security effectiveness and system usability. The optimal iteration count changes continuously as hardware capabilities improve, requiring systematic approaches to parameter selection and evolution.\n\n#### Performance-Security Trade-off Analysis\n\nThe fundamental challenge in iteration count tuning lies in the competing requirements of security and usability. From a security perspective, higher iteration counts provide exponentially better protection against brute force attacks. However, from a usability perspective, longer password verification times can degrade user experience and system responsiveness.\n\n| Iteration Count | Hash Time | Brute Force Cost (1M attempts) | User Experience Impact | Recommendation |\n|----------------|-----------|--------------------------------|------------------------|----------------|\n| 100,000 | ~100ms | ~28 hours | Barely noticeable | Minimum acceptable |\n| 200,000 | ~200ms | ~56 hours | Acceptable for web | Recommended default |\n| 500,000 | ~500ms | ~140 hours | Acceptable for desktop | High security |\n| 1,000,000 | ~1000ms | ~280 hours | Noticeable delay | Maximum for interactive |\n| 10,000,000 | ~10 seconds | ~2800 hours | Unusable for web | Batch processing only |\n\nThe **computational cost scaling** follows predictable mathematical relationships that enable precise trade-off analysis. Each doubling of iteration count exactly doubles both legitimate authentication time and attacker brute force cost. This linear scaling allows administrators to make informed decisions about acceptable delays versus security improvements.\n\nThe **attack cost analysis** reveals why iteration count tuning is crucial for effective security. Consider a password with 40 bits of entropy (approximately 6-7 random characters). Without key stretching, an attacker with commodity hardware could exhaustively search this space in minutes. With 200,000 PBKDF2 iterations, the same attack requires months of computation, transforming a practical attack into an impractical one.\n\n> The key insight is that iteration counts must be chosen based on the weakest passwords in the system, not the strongest ones. A user with a 12-character random password has inherent security regardless of iteration count, but a user with \"password123\" relies entirely on key stretching for protection.\n\n#### Hardware-Based Tuning Methodology\n\nEffective iteration count tuning requires systematic measurement of computational performance across the target deployment environment. Different server configurations, cloud instance types, and client devices will exhibit dramatically different PBKDF2 performance characteristics, necessitating measurement-based parameter selection rather than arbitrary defaults.\n\nThe **benchmark-driven approach** provides the most reliable foundation for iteration count selection. This methodology involves measuring actual PBKDF2 performance on target hardware with representative workloads, then selecting iteration counts that achieve specific timing targets.\n\n| Timing Target | Use Case | Rationale | Typical Iteration Count |\n|--------------|----------|-----------|------------------------|\n| 100ms | High-volume web services | Minimal impact on request latency | 100,000-150,000 |\n| 250ms | Standard web applications | Acceptable delay for security | 200,000-300,000 |\n| 500ms | Desktop applications | Users expect brief delays | 400,000-600,000 |\n| 1000ms | Administrative systems | Security over convenience | 800,000-1,200,000 |\n\nThe tuning methodology follows these systematic steps:\n\n1. **Baseline Performance Measurement**: Execute PBKDF2 with known iteration counts on target hardware, measuring both average and 95th percentile timing. This measurement must occur under realistic load conditions to account for CPU contention and thermal throttling.\n\n2. **Scaling Factor Calculation**: Determine the linear relationship between iteration count and execution time on the specific hardware configuration. This scaling factor enables accurate prediction of performance for any iteration count.\n\n3. **Security Requirement Analysis**: Assess the threat model and determine minimum computational cost requirements for password attacks. Consider both current attack capabilities and projected hardware improvements over the password lifetime.\n\n4. **Tolerance Testing**: Validate that selected iteration counts provide acceptable user experience under various load conditions, including peak usage periods and degraded hardware performance.\n\n5. **Evolution Planning**: Establish procedures for increasing iteration counts over time as hardware capabilities improve, ensuring long-term security effectiveness.\n\n> **Decision: Target-Time vs Fixed-Count Parameter Selection**\n> - **Context**: Systems can choose iteration counts based on achieving target timing or using predetermined fixed counts\n> - **Options Considered**:\n>   1. Fixed iteration counts (simple but hardware-dependent)\n>   2. Target timing with measurement (complex but adaptive)\n>   3. Hybrid approach with ranges (balanced complexity)\n> - **Decision**: Implement target-timing approach with fallback to safe defaults\n> - **Rationale**: Hardware performance varies dramatically across deployments, requiring adaptive parameter selection for consistent security\n> - **Consequences**: Requires runtime performance measurement but provides consistent security across diverse hardware\n\n#### Dynamic Iteration Count Management\n\nProduction password hashing systems must evolve their security parameters over time to maintain effectiveness against improving attack capabilities. Moore's Law and specialized hardware development continuously reduce the computational cost of password attacks, requiring corresponding increases in iteration counts to maintain equivalent security levels.\n\nThe **security decay problem** represents a fundamental challenge in long-lived password systems. An iteration count that provided strong security in 2020 may offer inadequate protection by 2025 due to hardware improvements. Without systematic parameter evolution, password systems experience gradual security degradation even without explicit vulnerabilities.\n\n**Algorithm agility** at the parameter level provides a solution to security decay through systematic iteration count increases. New password hashes use current recommended iteration counts, while existing hashes remain valid with their original parameters. This approach avoids forced password resets while ensuring new passwords receive optimal protection.\n\n| Parameter Evolution Strategy | Implementation | Pros | Cons |\n|----------------------------|----------------|------|------|\n| Immediate Global Update | Change all future hashes to new parameters | Simple, consistent security | Sudden performance impact |\n| Gradual Migration | Increase iteration counts over time | Smooth transition | Complex scheduling |\n| User-Triggered Upgrade | Update parameters on password change | Natural evolution | Slow adoption |\n| Background Rehashing | Upgrade hashes during low-traffic periods | Transparent to users | Complex implementation |\n\nThe **user-triggered upgrade** approach provides the most practical balance between security improvement and implementation complexity. When users change passwords or successfully authenticate, the system generates new hashes with current iteration count recommendations. This approach ensures active accounts receive updated security while avoiding forced migrations.\n\n#### Security Monitoring and Validation\n\nEffective iteration count tuning requires continuous monitoring of both security effectiveness and performance characteristics. Security parameters that seemed adequate during initial deployment may prove insufficient as attack capabilities evolve or system requirements change.\n\n**Security effectiveness monitoring** involves tracking metrics that indicate whether current iteration counts provide adequate protection against realistic attack scenarios. These metrics include computational cost analysis, comparative security assessment, and threat intelligence integration.\n\n| Monitoring Metric | Measurement Method | Alert Threshold | Response Action |\n|-------------------|-------------------|----------------|----------------|\n| Hash Computation Time | Server-side timing measurement | >150% of baseline | Performance investigation |\n| Attack Cost Estimate | Theoretical brute force calculation | <1 week for common passwords | Iteration count increase |\n| Hardware Benchmark | Periodic performance testing | 50% performance improvement | Parameter review |\n| Security Standard Compliance | Comparison to current recommendations | Below industry minimums | Immediate update |\n\n**Performance impact assessment** ensures that security improvements don't compromise system usability or availability. Regular measurement of authentication latency, resource consumption, and user experience metrics provides early warning of parameter selections that may require adjustment.\n\n> The fundamental principle is that iteration count tuning is not a one-time decision but an ongoing security practice requiring regular review and adjustment based on evolving threat landscapes and hardware capabilities.\n\n### Common Pitfalls\n\n⚠️ **Pitfall: Using Insufficient Iteration Counts**\n\nMany implementations use iteration counts that provide inadequate security against modern attack capabilities. Developers often choose round numbers like 10,000 or 50,000 iterations without understanding the actual security implications, or use outdated recommendations from early PBKDF2 documentation.\n\nThe problem occurs because iteration count requirements have increased dramatically as hardware has improved. An iteration count that provided strong security in 2010 may be completely inadequate today. Additionally, developers sometimes optimize for perceived performance concerns without understanding the security trade-offs.\n\nTo avoid this pitfall, always use current security recommendations as minimums (100,000+ iterations for PBKDF2-SHA256), measure actual performance on target hardware rather than assuming iteration counts are \"too slow,\" and implement systematic processes for increasing iteration counts over time as hardware improves.\n\n⚠️ **Pitfall: Not Storing Iteration Count with Password Hash**\n\nSome implementations use fixed global iteration counts and fail to store the iteration count with each password hash record. This creates serious problems when iteration counts need to be increased—existing password hashes become unverifiable because the system doesn't know which iteration count was used during hash creation.\n\nThe issue manifests as authentication failures after security parameter updates, inability to evolve security over time, and forced password resets for all users when iteration counts change. This violates the principle of algorithm agility and creates operational difficulties in production systems.\n\nThe solution requires storing iteration count as part of each `PasswordHashRecord`, implementing parameter evolution that allows different iteration counts for different password records, and using default iteration counts that can change over time without breaking existing authentications.\n\n⚠️ **Pitfall: Implementing PBKDF2 with Variable-Time Operations**\n\nSubtle timing vulnerabilities can occur in PBKDF2 implementations that don't maintain constant execution time. These vulnerabilities might arise from optimizations that skip operations under certain conditions, different code paths based on input values, or comparison operations that fail faster for incorrect passwords.\n\nVariable timing can leak information about password correctness, salt values, or internal algorithm state. While timing attacks against PBKDF2 are more difficult due to the inherent computational delay, they remain possible if implementations contain timing side channels.\n\nPrevent timing attacks by ensuring all code paths take the same execution time regardless of input values, using constant-time comparison functions for all password verification steps, and avoiding optimizations that create conditional execution based on secret values.\n\n⚠️ **Pitfall: Not Validating PBKDF2 Parameters**\n\nImplementations sometimes fail to validate PBKDF2 parameters, accepting dangerously low iteration counts, excessively short salts, or malformed input data. This can lead to security vulnerabilities if attackers can influence parameter selection or if configuration errors result in weak security.\n\nParameter validation must enforce minimum security requirements including minimum iteration counts (100,000+), minimum salt lengths (16+ bytes), reasonable maximum values to prevent denial-of-service attacks, and proper input format validation to prevent parsing errors.\n\nImplement comprehensive parameter validation in the `ParameterValidator` component, reject requests with insufficient security parameters even if they would execute faster, and use safe defaults when parameters are not explicitly specified.\n\n⚠️ **Pitfall: Ignoring Memory and CPU Resource Constraints**\n\nPBKDF2 with high iteration counts can consume significant CPU resources, potentially creating denial-of-service vulnerabilities if not properly managed. Implementations that don't consider resource constraints may become unavailable under high authentication loads or targeted resource exhaustion attacks.\n\nThe problem occurs when systems don't limit concurrent PBKDF2 operations, fail to account for CPU usage in capacity planning, or don't implement proper resource monitoring and alerting. High iteration counts that work fine for single authentications can overwhelm servers under load.\n\nAddress resource constraints by implementing concurrency limits for password hashing operations, monitoring CPU usage and authentication latency during load testing, and designing systems that can gracefully degrade performance rather than failing completely under high loads.\n\n### Implementation Guidance\n\nThe key stretching component builds upon the basic hashing foundation to implement PBKDF2 key derivation with configurable security parameters. This implementation focuses on providing both educational clarity and production-ready security.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| PBKDF2 Implementation | Python's `hashlib.pbkdf2_hmac()` (built-in) | Custom PBKDF2 with detailed controls |\n| Parameter Storage | JSON serialization with validation | Binary format with version headers |\n| Performance Measurement | Simple timing with `time.time()` | Statistical timing analysis with `timeit` |\n| Constant-Time Comparison | `hmac.compare_digest()` (built-in) | Custom constant-time implementation |\n\n#### Recommended File Structure\n\n```\nproject-root/\n  src/\n    password_security/\n      key_stretching/\n        __init__.py              ← exports main classes\n        pbkdf2_hasher.py         ← PBKDF2 implementation\n        iteration_tuner.py       ← performance measurement and tuning\n        key_stretching_errors.py ← specific exception types\n      basic_hashing/\n        basic_hasher.py          ← from previous milestone\n        salt_generator.py        ← from previous milestone\n      data_model/\n        hash_record.py           ← from previous milestone\n        parameters.py            ← algorithm parameters\n  tests/\n    test_key_stretching/\n      test_pbkdf2_hasher.py      ← PBKDF2 functionality tests\n      test_iteration_tuning.py   ← performance tuning tests\n      test_timing_safety.py      ← timing attack resistance tests\n```\n\n#### Infrastructure Starter Code\n\n**Complete Parameter Validation Infrastructure** (`key_stretching_errors.py`):\n\n```python\n\"\"\"\nKey stretching specific exception types and validation utilities.\nProvides comprehensive error handling for PBKDF2 parameter validation.\n\"\"\"\n\nclass KeyStretchingError(Exception):\n    \"\"\"Base exception for all key stretching operations.\"\"\"\n    pass\n\nclass IterationCountError(KeyStretchingError):\n    \"\"\"Raised when iteration count is invalid or insufficient.\"\"\"\n    def __init__(self, count, minimum_required):\n        self.count = count\n        self.minimum_required = minimum_required\n        super().__init__(f\"Iteration count {count} below minimum {minimum_required}\")\n\nclass DerivationLengthError(KeyStretchingError):\n    \"\"\"Raised when derived key length is invalid.\"\"\"\n    def __init__(self, length, maximum_allowed):\n        self.length = length\n        self.maximum_allowed = maximum_allowed\n        super().__init__(f\"Derived key length {length} exceeds maximum {maximum_allowed}\")\n\nclass ParameterValidationError(KeyStretchingError):\n    \"\"\"Raised when PBKDF2 parameters fail validation.\"\"\"\n    def __init__(self, parameter_name, value, constraint):\n        self.parameter_name = parameter_name\n        self.value = value\n        self.constraint = constraint\n        super().__init__(f\"Parameter {parameter_name}={value} violates {constraint}\")\n\ndef validate_iteration_count(count):\n    \"\"\"Validate PBKDF2 iteration count meets security requirements.\"\"\"\n    if not isinstance(count, int):\n        raise ParameterValidationError(\"iteration_count\", count, \"must be integer\")\n    if count < 100000:\n        raise IterationCountError(count, 100000)\n    if count > 10000000:\n        raise ParameterValidationError(\"iteration_count\", count, \"exceeds reasonable maximum\")\n    return True\n\ndef validate_derived_key_length(length):\n    \"\"\"Validate derived key length is reasonable and secure.\"\"\"\n    if not isinstance(length, int):\n        raise ParameterValidationError(\"derived_key_length\", length, \"must be integer\")\n    if length < 16:\n        raise ParameterValidationError(\"derived_key_length\", length, \"minimum 16 bytes\")\n    if length > 256:\n        raise DerivationLengthError(length, 256)\n    return True\n```\n\n**Complete Performance Measurement Infrastructure** (`iteration_tuner.py`):\n\n```python\n\"\"\"\nPerformance measurement and iteration count tuning for PBKDF2.\nProvides comprehensive timing analysis and parameter recommendations.\n\"\"\"\n\nimport time\nimport statistics\nimport hashlib\nfrom typing import Dict, List, Tuple\n\nclass PerformanceGoalTuner:\n    \"\"\"Measures PBKDF2 performance and recommends iteration counts.\"\"\"\n    \n    def __init__(self):\n        self.measurements = {}\n        self.test_password = b\"test_password_for_timing\"\n        self.test_salt = b\"test_salt_16_bytes_long\"\n    \n    def benchmark_algorithm(self, algorithm: str, test_password: bytes) -> Dict:\n        \"\"\"Measure algorithm performance with statistical analysis.\"\"\"\n        if algorithm != \"pbkdf2_hmac_sha256\":\n            return {\"error\": f\"Unsupported algorithm: {algorithm}\"}\n        \n        # Measure baseline performance with known iteration counts\n        iteration_counts = [50000, 100000, 200000, 500000]\n        timing_results = {}\n        \n        for count in iteration_counts:\n            times = []\n            for _ in range(5):  # Multiple measurements for statistical accuracy\n                start_time = time.perf_counter()\n                hashlib.pbkdf2_hmac('sha256', test_password, self.test_salt, count, 32)\n                end_time = time.perf_counter()\n                times.append(end_time - start_time)\n            \n            timing_results[count] = {\n                'mean': statistics.mean(times),\n                'median': statistics.median(times),\n                'stdev': statistics.stdev(times) if len(times) > 1 else 0,\n                'min': min(times),\n                'max': max(times)\n            }\n        \n        # Calculate scaling factor (time per iteration)\n        scaling_factors = []\n        for count, timing in timing_results.items():\n            scaling_factors.append(timing['mean'] / count)\n        \n        avg_scaling_factor = statistics.mean(scaling_factors)\n        \n        return {\n            'algorithm': algorithm,\n            'timing_results': timing_results,\n            'scaling_factor': avg_scaling_factor,\n            'measurement_count': len(timing_results)\n        }\n    \n    def recommend_iteration_count(self, target_time_ms: int) -> Dict:\n        \"\"\"Recommend iteration count to achieve target timing.\"\"\"\n        target_time_seconds = target_time_ms / 1000.0\n        \n        # Measure current performance\n        benchmark = self.benchmark_algorithm(\"pbkdf2_hmac_sha256\", self.test_password)\n        if 'error' in benchmark:\n            return benchmark\n        \n        scaling_factor = benchmark['scaling_factor']\n        recommended_count = int(target_time_seconds / scaling_factor)\n        \n        # Ensure minimum security requirements\n        minimum_count = 100000\n        if recommended_count < minimum_count:\n            recommended_count = minimum_count\n            actual_time = recommended_count * scaling_factor * 1000\n            return {\n                'recommended_iterations': recommended_count,\n                'target_time_ms': target_time_ms,\n                'actual_time_ms': actual_time,\n                'warning': f\"Hardware too fast for target time, using minimum {minimum_count} iterations\"\n            }\n        \n        # Verify recommendation with actual measurement\n        start_time = time.perf_counter()\n        hashlib.pbkdf2_hmac('sha256', self.test_password, self.test_salt, recommended_count, 32)\n        end_time = time.perf_counter()\n        actual_time = (end_time - start_time) * 1000\n        \n        return {\n            'recommended_iterations': recommended_count,\n            'target_time_ms': target_time_ms,\n            'actual_time_ms': actual_time,\n            'scaling_factor': scaling_factor,\n            'accuracy_percentage': (target_time_ms / actual_time) * 100\n        }\n```\n\n#### Core Logic Skeleton Code\n\n**PBKDF2 Key Stretching Implementation** (`pbkdf2_hasher.py`):\n\n```python\n\"\"\"\nPBKDF2-based password hashing with configurable iteration counts.\nImplements secure key stretching for password protection.\n\"\"\"\n\nimport hashlib\nimport hmac\nfrom typing import Dict, Optional\nfrom ..data_model.hash_record import PasswordHashRecord\nfrom ..basic_hashing.salt_generator import SaltGenerator\nfrom .key_stretching_errors import validate_iteration_count, validate_derived_key_length\n\nclass KeyStretchingHasher:\n    \"\"\"Implements PBKDF2 key stretching for password security.\"\"\"\n    \n    def __init__(self, default_iterations: int = 200000, default_key_length: int = 32):\n        # TODO 1: Validate default_iterations meets minimum security requirements (100,000+)\n        # TODO 2: Validate default_key_length provides adequate security (32+ bytes)\n        # TODO 3: Initialize salt_generator for secure random salt generation\n        # TODO 4: Store algorithm identifier for hash record metadata\n        pass\n    \n    def hash_password_with_stretching(self, password: str, \n                                    iterations: Optional[int] = None,\n                                    key_length: Optional[int] = None) -> PasswordHashRecord:\n        \"\"\"\n        Generate PBKDF2 hash with configurable iteration count and key length.\n        Uses default values if parameters not specified.\n        \"\"\"\n        # TODO 1: Convert password string to bytes using UTF-8 encoding\n        # TODO 2: Use provided iterations or fall back to default, validate against minimum\n        # TODO 3: Use provided key_length or fall back to default, validate range\n        # TODO 4: Generate cryptographically random salt using salt_generator\n        # TODO 5: Call hashlib.pbkdf2_hmac('sha256', password_bytes, salt, iterations, key_length)\n        # TODO 6: Create PasswordHashRecord with algorithm='pbkdf2_hmac_sha256'\n        # TODO 7: Store iterations and key_length in parameters dict for verification\n        # TODO 8: Return complete hash record with all metadata\n        # Hint: parameters = {'iterations': iterations, 'key_length': key_length}\n        pass\n    \n    def verify_password_with_stretching(self, password: str, hash_record: PasswordHashRecord) -> bool:\n        \"\"\"\n        Verify password against PBKDF2 hash using stored parameters.\n        Implements constant-time comparison to prevent timing attacks.\n        \"\"\"\n        # TODO 1: Validate hash_record.algorithm == 'pbkdf2_hmac_sha256'\n        # TODO 2: Extract iterations from hash_record.parameters dict\n        # TODO 3: Extract key_length from hash_record.parameters dict\n        # TODO 4: Convert password to bytes using UTF-8 encoding\n        # TODO 5: Recompute PBKDF2 hash using stored salt and parameters\n        # TODO 6: Compare recomputed hash with stored hash using hmac.compare_digest()\n        # TODO 7: Return boolean result (True if passwords match, False otherwise)\n        # Hint: Use hmac.compare_digest(computed_hash, hash_record.hash) for timing safety\n        pass\n    \n    def upgrade_iteration_count(self, password: str, old_record: PasswordHashRecord, \n                               new_iterations: int) -> PasswordHashRecord:\n        \"\"\"\n        Create new hash record with increased iteration count.\n        Used for transparent security upgrades during authentication.\n        \"\"\"\n        # TODO 1: Validate new_iterations > old_record.parameters['iterations']\n        # TODO 2: Verify password against old_record to ensure correctness\n        # TODO 3: If verification succeeds, create new hash with new_iterations\n        # TODO 4: Use same key_length as original record for compatibility\n        # TODO 5: Generate new salt for the upgraded hash record\n        # TODO 6: Return new PasswordHashRecord with upgraded parameters\n        # TODO 7: If verification fails, raise authentication error\n        # Hint: This enables transparent security upgrades during login\n        pass\n\n    def benchmark_iterations(self, target_time_ms: int) -> Dict:\n        \"\"\"\n        Measure PBKDF2 performance and recommend iteration count for target timing.\n        Returns performance analysis and recommended parameters.\n        \"\"\"\n        # TODO 1: Create test password and salt for benchmarking\n        # TODO 2: Measure execution time for various iteration counts (50k, 100k, 200k, 500k)\n        # TODO 3: Calculate linear scaling factor (time per iteration)\n        # TODO 4: Recommend iteration count to achieve target_time_ms\n        # TODO 5: Ensure recommended count meets minimum security requirements\n        # TODO 6: Return dict with recommended_iterations, actual_time, scaling_factor\n        # TODO 7: Include warning if hardware is too fast for reasonable target time\n        # Hint: Use time.perf_counter() for accurate timing measurements\n        pass\n```\n\n**Integration with Algorithm Parameters** (`parameters.py` additions):\n\n```python\n\"\"\"\nAlgorithm parameters management for key stretching algorithms.\nExtends base parameter system with PBKDF2-specific configurations.\n\"\"\"\n\nclass AlgorithmParameters:\n    \"\"\"Manages algorithm parameters with validation and defaults.\"\"\"\n    \n    def get_pbkdf2_defaults(self) -> Dict:\n        \"\"\"Get default PBKDF2 parameters for current security standards.\"\"\"\n        # TODO 1: Return dict with default iterations (200,000)\n        # TODO 2: Include default key_length (32 bytes)\n        # TODO 3: Include algorithm identifier ('pbkdf2_hmac_sha256')\n        # TODO 4: Include version number for parameter evolution\n        # Hint: These defaults should meet current security recommendations\n        pass\n    \n    def validate_pbkdf2_parameters(self, parameters: Dict) -> bool:\n        \"\"\"Validate PBKDF2 parameters meet security requirements.\"\"\"\n        # TODO 1: Check iterations >= 100,000 (security minimum)\n        # TODO 2: Check key_length >= 16 bytes (adequate key material)\n        # TODO 3: Check iterations <= 10,000,000 (DoS prevention)\n        # TODO 4: Check key_length <= 256 bytes (reasonable maximum)\n        # TODO 5: Raise ParameterValidationError for invalid values\n        # TODO 6: Return True if all validations pass\n        # Hint: Use validation functions from key_stretching_errors module\n        pass\n    \n    def evolve_security_parameters(self, current_params: Dict, target_year: int) -> Dict:\n        \"\"\"\n        Recommend parameter updates based on projected security requirements.\n        Accounts for hardware improvements and attack capability evolution.\n        \"\"\"\n        # TODO 1: Calculate years from present to target_year\n        # TODO 2: Estimate hardware improvement factor (assume 2x every 3 years)\n        # TODO 3: Scale iteration count proportionally to maintain security level\n        # TODO 4: Ensure scaled parameters meet future minimum requirements\n        # TODO 5: Return updated parameters dict with evolution metadata\n        # TODO 6: Include rationale for recommended changes\n        # Hint: Moore's law suggests doubling iteration count every 3 years\n        pass\n```\n\n#### Milestone Checkpoint\n\nAfter implementing the key stretching component, verify functionality with these specific tests:\n\n**Performance Verification:**\n```bash\npython -m pytest tests/test_key_stretching/test_iteration_tuning.py -v\n```\n\nExpected output should show:\n- Iteration count recommendations within 10% of target timing\n- Minimum iteration count enforcement (100,000+)\n- Linear scaling factor calculation accuracy\n- Performance measurement statistical stability\n\n**Security Property Verification:**\n```bash\npython -m pytest tests/test_key_stretching/test_pbkdf2_hasher.py::test_timing_attack_resistance -v\n```\n\nExpected behavior:\n- All password verifications take similar time regardless of password correctness\n- Constant-time comparison prevents early termination\n- No timing information leaks through execution patterns\n\n**Manual Integration Test:**\n```python\nfrom password_security.key_stretching.pbkdf2_hasher import KeyStretchingHasher\n\nhasher = KeyStretchingHasher(default_iterations=150000)\nhash_record = hasher.hash_password_with_stretching(\"test_password\")\nprint(f\"Hash time: {hash_record.created_at}\")\nprint(f\"Iterations: {hash_record.parameters['iterations']}\")\nprint(f\"Verification: {hasher.verify_password_with_stretching('test_password', hash_record)}\")\n```\n\nYou should see:\n- Hash creation taking 100-500ms depending on hardware\n- Successful password verification returning True\n- Identical parameters stored and retrieved from hash record\n- Failed verification (wrong password) also taking similar time\n\n**Signs of Implementation Problems:**\n\n| Symptom | Likely Cause | Diagnostic Command | Fix |\n|---------|--------------|-------------------|-----|\n| Hashing takes >2 seconds | Iteration count too high | Check `hash_record.parameters['iterations']` | Reduce to 200,000-500,000 range |\n| Verification fails for correct passwords | Parameter extraction error | Print `hash_record.parameters` | Fix parameter dictionary key names |\n| Timing varies significantly | Not using constant-time comparison | Time multiple verifications | Use `hmac.compare_digest()` |\n| Import errors | Missing dependencies | `python -c \"import hashlib, hmac\"` | Check Python standard library |\n\n\n## Modern Hashing Component\n\n> **Milestone(s):** Milestone 3 (Modern Password Hashing)\n\n### Mental Model: The Bank Vault Evolution System\n\nThink of the modern hashing component like a bank's vault evolution over decades. Early banks used simple mechanical locks (basic SHA-256 hashing), which worked until lock picking became widespread. Then banks adopted time-locked mechanisms (key stretching with PBKDF2), which delayed thieves but could still be overcome with enough time and determination. Modern banks use sophisticated multi-layered vault systems with biometric scanners, time delays, and specialized materials that require enormous resources to breach (bcrypt and Argon2).\n\nJust like banks must periodically upgrade their vault technology as new attack methods emerge, password systems need **algorithm agility** — the ability to migrate from older methods to newer, more secure approaches without disrupting existing users. The vault manufacturer (our modern hashing component) must support multiple vault generations simultaneously during transition periods, ensuring that customers with older vaults can still access their deposits while new customers get the latest protection.\n\nThe crucial insight is that **security decay** affects all cryptographic systems over time. What seems computationally infeasible today becomes trivial with tomorrow's hardware and attack techniques. A well-designed system anticipates this evolution and provides seamless upgrade paths.\n\n### Bcrypt Integration: Using Bcrypt's Built-in Salt Generation and Cost Factor Management\n\n**Bcrypt** represents the first widely-adopted **memory-hard** password hashing algorithm specifically designed for password storage. Unlike PBKDF2, which performs many simple operations quickly, bcrypt incorporates the expensive Blowfish key setup that requires significant memory and resists optimization on specialized hardware like GPUs and ASICs.\n\nThe bcrypt algorithm follows a carefully engineered process that combines multiple security mechanisms into a single operation. First, it generates a cryptographically random salt internally, eliminating the need for external salt management. Second, it applies the computationally expensive Blowfish key setup algorithm multiple times, with the iteration count determined by a **cost factor** parameter. This cost factor uses logarithmic scaling — cost 12 means 2^12 = 4,096 iterations, while cost 13 doubles the computation time to 8,192 iterations.\n\nThe elegant aspect of bcrypt lies in its self-contained hash format that embeds all verification parameters directly in the output string. A typical bcrypt hash looks like `$2b$12$R9h/cIPz0gi.URNNX3kh2OUXGWU6CDQFU4rIpSJqX3gLJPkkR1ueS`, where the format breaks down into distinct components that preserve all necessary information for future verification.\n\n> **Decision: Adopt Bcrypt for Production Password Hashing**\n> - **Context**: Need production-grade password hashing that balances security, performance, and hardware resistance\n> - **Options Considered**: Continue with PBKDF2, implement bcrypt, implement Argon2\n> - **Decision**: Use bcrypt as the primary modern hashing algorithm with optional Argon2 support\n> - **Rationale**: Bcrypt provides proven security with 25+ years of cryptanalysis, widespread library support, and excellent hardware attack resistance. The logarithmic cost factor provides clear upgrade paths as hardware improves.\n> - **Consequences**: Adds external library dependency but eliminates custom cryptographic implementation risks. Provides industry-standard security with straightforward parameter tuning.\n\n| Bcrypt Hash Component | Example Value | Purpose | Security Property |\n|----------------------|---------------|---------|------------------|\n| Algorithm Identifier | `$2b$` | Specifies bcrypt variant and version | Prevents algorithm confusion attacks |\n| Cost Factor | `12` | Logarithmic work factor (2^12 iterations) | Configurable computational bottleneck |\n| Salt | `R9h/cIPz0gi.URNNX3kh2O` | 128-bit random value (base64 encoded) | Prevents rainbow table attacks |\n| Hash | `UXGWU6CDQFU4rIpSJqX3gLJPkkR1ueS` | 184-bit derived key (base64 encoded) | Password-dependent verification value |\n\nThe **cost factor tuning** process requires careful measurement of actual hardware performance rather than theoretical calculations. The goal is selecting a cost that imposes acceptable delays on legitimate authentication (typically 100-500 milliseconds) while creating prohibitive costs for brute force attacks. Since bcrypt's cost factor uses logarithmic scaling, each increment doubles the computation time, providing precise control over the security-performance trade-off.\n\n> The critical insight with bcrypt cost factors is that they must be tuned for your specific hardware and gradually increased over time. A cost factor appropriate for 2020 hardware becomes insufficient by 2025 due to Moore's Law improvements.\n\n**Cost Factor Selection Algorithm:**\n\n1. Start with the industry minimum cost factor (`BCRYPT_MIN_COST` = 12)\n2. Measure actual hash computation time on production hardware using representative test passwords\n3. Increase cost factor incrementally until hash computation reaches target latency (200-300ms recommended)\n4. Document the selected cost factor with hardware specifications and measurement date\n5. Schedule periodic reviews (annually) to reassess cost factor adequacy\n6. Plan migration strategy for upgrading existing password hashes with higher cost factors\n\nThe bcrypt integration architecture separates **algorithm mechanics** from **parameter management** to support long-term maintainability. The core bcrypt wrapper handles the cryptographic operations and format parsing, while a separate parameter management system tracks cost factor evolution and supports gradual migration of existing password databases.\n\n| Bcrypt Integration Method | Parameters | Returns | Description |\n|---------------------------|------------|---------|-------------|\n| `hash_password_bcrypt` | `password: bytes, cost: int` | `PasswordHashRecord` | Generate bcrypt hash with specified cost factor |\n| `verify_password_bcrypt` | `password: bytes, hash_record: PasswordHashRecord` | `bool` | Verify password against stored bcrypt hash |\n| `parse_bcrypt_hash` | `bcrypt_string: str` | `dict` | Extract algorithm, cost, salt, and hash from bcrypt format |\n| `format_bcrypt_hash` | `cost: int, salt: bytes, hash: bytes` | `str` | Construct standard bcrypt format string |\n| `benchmark_bcrypt_cost` | `target_time_ms: int` | `dict` | Measure performance and recommend cost factor |\n| `upgrade_bcrypt_cost` | `password: bytes, old_record: PasswordHashRecord, new_cost: int` | `PasswordHashRecord` | Re-hash password with higher cost factor |\n\n### Argon2 Support: Memory-Hard Hashing for Enhanced Security Against Specialized Hardware\n\n**Argon2** represents the state-of-the-art in password hashing, winning the Password Hashing Competition in 2015 and becoming the recommended algorithm for new applications. Unlike bcrypt, which focuses primarily on time-based computational cost, Argon2 introduces **memory-hardness** — requiring substantial memory allocation that resists optimization on specialized hardware like GPUs, FPGAs, and ASICs.\n\nThe Argon2 algorithm family includes three variants designed for different threat models. **Argon2d** maximizes resistance against GPU-based attacks by using data-dependent memory access patterns, but becomes vulnerable to side-channel attacks in shared environments. **Argon2i** uses data-independent memory access to prevent side-channel attacks, making it suitable for password hashing in multi-tenant systems. **Argon2id** combines both approaches, using data-independent access for the first half of iterations and data-dependent access for the second half, providing the best overall security properties.\n\nThe memory-hard property fundamentally changes the economics of password cracking. Traditional attacks could use thousands of lightweight GPU cores to parallelize hash computations, but Argon2's memory requirements limit the parallelization factor. An attacker who previously could run 10,000 parallel bcrypt computations might only manage 100 parallel Argon2 computations due to memory constraints.\n\n> **Decision: Support Argon2id as Advanced Option**\n> - **Context**: Need maximum security for high-value applications and defense against specialized hardware attacks\n> - **Options Considered**: Bcrypt only, Argon2d, Argon2i, Argon2id\n> - **Decision**: Implement Argon2id support as an advanced option alongside bcrypt\n> - **Rationale**: Argon2id provides the best balance of side-channel resistance and GPU attack resistance. Memory-hardness provides superior protection against well-funded attackers with specialized hardware.\n> - **Consequences**: Increases memory usage and implementation complexity but provides maximum security for applications that require it.\n\n| Argon2 Parameter | Typical Value | Purpose | Security Impact |\n|------------------|---------------|---------|-----------------|\n| Memory Cost (m) | 65536 (64 MB) | Memory allocation in KB | Higher values resist parallel attacks |\n| Time Cost (t) | 3 | Number of iterations | Higher values increase computation time |\n| Parallelism (p) | 4 | Number of parallel threads | Must match available CPU cores |\n| Hash Length | 32 bytes | Output key length | Standard 256-bit security level |\n| Salt Length | 16 bytes | Random salt length | Prevents precomputed attacks |\n\nThe **memory cost parameter** requires careful tuning based on available system memory and concurrent authentication load. Unlike bcrypt's logarithmic cost factor, Argon2's memory cost scales linearly — doubling the memory parameter doubles the memory usage. For web applications, memory costs between 32 MB and 128 MB provide good security while remaining feasible for typical server hardware.\n\n**Argon2 Parameter Selection Algorithm:**\n\n1. Determine maximum acceptable memory per hash operation based on concurrent user load\n2. Set memory cost to use 50-75% of available per-operation memory budget\n3. Configure parallelism to match available CPU cores (typically 2-8)\n4. Adjust time cost to achieve target verification latency (100-500ms)\n5. Measure actual memory usage and verification time under realistic load\n6. Document parameter choices with hardware specifications and load assumptions\n\nThe Argon2 integration must handle the increased complexity of multi-parameter tuning compared to bcrypt's single cost factor. The parameter validation system ensures that configurations remain within secure boundaries and provides warnings when parameter combinations might create resource exhaustion risks.\n\n| Argon2 Integration Method | Parameters | Returns | Description |\n|---------------------------|------------|---------|-------------|\n| `hash_password_argon2` | `password: bytes, memory_cost: int, time_cost: int, parallelism: int` | `PasswordHashRecord` | Generate Argon2id hash with specified parameters |\n| `verify_password_argon2` | `password: bytes, hash_record: PasswordHashRecord` | `bool` | Verify password against stored Argon2 hash |\n| `parse_argon2_hash` | `argon2_string: str` | `dict` | Extract parameters and hash from Argon2 format |\n| `format_argon2_hash` | `memory_cost: int, time_cost: int, parallelism: int, salt: bytes, hash: bytes` | `str` | Construct standard Argon2 format string |\n| `benchmark_argon2_parameters` | `target_time_ms: int, max_memory_mb: int` | `dict` | Recommend parameters for performance and memory constraints |\n| `validate_argon2_parameters` | `memory_cost: int, time_cost: int, parallelism: int` | `ValidationResult` | Validate parameter combinations for security and feasibility |\n\n### Algorithm Agility Design: Supporting Multiple Algorithms and Migration Paths for Future Upgrades\n\n**Algorithm agility** represents one of the most critical architectural decisions in cryptographic systems. The fundamental challenge is that all cryptographic algorithms eventually become obsolete due to advances in mathematics, computing hardware, or attack techniques. A well-designed password hashing system must anticipate this evolution and provide seamless migration paths that preserve existing user accounts while adopting stronger security measures.\n\nThe algorithm agility architecture separates **algorithm implementation** from **algorithm selection** and **migration management**. The core insight is that password hash records must be **immutable archives** that preserve exact creation-time parameters while supporting verification across multiple algorithm generations. This design prevents **temporal coupling** where verification depends on current system configuration rather than the original hash parameters.\n\n![Algorithm Evolution State Machine](./diagrams/algorithm-evolution.svg)\n\nThe migration strategy addresses the fundamental constraint that password hashes are one-way operations — upgrading security requires user cooperation to provide their plaintext password during authentication. The system must support **lazy migration** where password hashes upgrade opportunistically during successful login attempts, allowing gradual improvement of the password database security profile over time.\n\n> **Decision: Implement Algorithm-Agnostic Hash Record Format**\n> - **Context**: Need to support multiple hashing algorithms and enable future migrations without breaking existing authentication\n> - **Options Considered**: Algorithm-specific storage, unified hash record format, external migration utility\n> - **Decision**: Use unified `PasswordHashRecord` format with embedded algorithm identification and parameters\n> - **Rationale**: Self-contained records eliminate external dependencies and support verification across system upgrades. Algorithm identification prevents confusion attacks and enables automatic dispatch to appropriate verification logic.\n> - **Consequences**: Increases storage overhead slightly but provides complete algorithm agility and eliminates migration complexity.\n\n| Algorithm Agility Component | Responsibility | Design Pattern | Benefits |\n|------------------------------|----------------|----------------|----------|\n| `AlgorithmRegistry` | Maps algorithm names to implementation classes | Registry pattern | Extensible algorithm support |\n| `MigrationManager` | Orchestrates lazy password hash upgrades | Strategy pattern | Gradual security improvements |\n| `VersioningSystem` | Tracks algorithm security levels and recommendations | Observer pattern | Automated migration triggers |\n| `BackwardCompatibility` | Maintains verification for legacy hash formats | Adapter pattern | Seamless system upgrades |\n\nThe **algorithm selection strategy** must balance security, performance, and operational constraints. The system provides sensible defaults while allowing explicit algorithm selection for specialized requirements. High-security applications might mandate Argon2id, while high-throughput systems might prefer bcrypt with carefully tuned cost factors.\n\n**Algorithm Selection Decision Matrix:**\n\n| Use Case | Primary Algorithm | Fallback Algorithm | Cost Factor/Parameters |\n|----------|------------------|-------------------|------------------------|\n| General Web Application | bcrypt | PBKDF2 | Cost 12-14 |\n| High-Security System | Argon2id | bcrypt | 64MB memory, cost 13+ |\n| High-Throughput API | bcrypt | PBKDF2 | Cost 10-12 |\n| Mobile Application | bcrypt | PBKDF2 | Cost 10-12 |\n| Legacy System Migration | PBKDF2 → bcrypt | PBKDF2 | Gradual upgrade |\n\nThe **migration workflow** handles the complex orchestration of upgrading password hashes without disrupting user experience. The system identifies candidates for migration based on algorithm age, security level, and user activity patterns, then performs upgrades transparently during successful authentication attempts.\n\n**Migration Process Algorithm:**\n\n1. User attempts authentication with current password\n2. System retrieves stored `PasswordHashRecord` and identifies algorithm version\n3. Verification proceeds using the original algorithm and parameters\n4. If verification succeeds and hash qualifies for upgrade, system checks migration policy\n5. Migration manager selects target algorithm based on current security recommendations\n6. System computes new hash using target algorithm and current password\n7. Database transaction updates user record with new hash while preserving backup of original\n8. System logs migration event for security auditing and rollback capabilities\n\nThe migration system maintains **migration metadata** to track upgrade progress and support rollback scenarios. This metadata includes migration timestamps, source and target algorithms, and verification that the migration preserved authentication functionality.\n\n| Migration Management Method | Parameters | Returns | Description |\n|------------------------------|------------|---------|-------------|\n| `assess_migration_candidate` | `hash_record: PasswordHashRecord` | `MigrationAssessment` | Evaluate whether hash should be upgraded |\n| `execute_lazy_migration` | `password: bytes, old_record: PasswordHashRecord` | `PasswordHashRecord` | Upgrade hash during successful verification |\n| `batch_migration_analysis` | `user_records: list` | `MigrationReport` | Analyze entire user database for migration opportunities |\n| `rollback_migration` | `user_id: str, backup_record: PasswordHashRecord` | `bool` | Restore previous hash format if migration causes issues |\n| `migration_progress_report` | `date_range: tuple` | `dict` | Generate statistics on migration completion rates |\n| `schedule_migration_campaign` | `target_algorithm: str, completion_deadline: datetime` | `MigrationPlan` | Plan systematic migration of user base |\n\n### Common Pitfalls in Modern Hashing Implementation\n\n⚠️ **Pitfall: Implementing Cryptographic Algorithms from Scratch**\n\nMany developers attempt to implement bcrypt or Argon2 algorithms themselves rather than using established cryptographic libraries. This approach introduces severe security vulnerabilities because cryptographic implementations require extensive expertise in side-channel resistance, constant-time operations, and secure memory management. Even minor implementation errors can completely compromise the security properties that make these algorithms effective.\n\n**Why it's wrong:** Cryptographic algorithms contain subtle implementation requirements that aren't obvious from reading algorithm specifications. For example, bcrypt requires specific memory clearing patterns and constant-time comparison operations that prevent timing attacks. These details are often omitted from academic papers but are critical for security.\n\n**How to fix:** Always use well-established cryptographic libraries that have undergone extensive peer review and security auditing. In Python, use the `bcrypt` and `argon2-cffi` libraries. In Go, use `golang.org/x/crypto/bcrypt` and `github.com/argon2-cffi/argon2-cffi`. These libraries handle all low-level implementation details correctly.\n\n⚠️ **Pitfall: Using Insufficient Cost Factors or Parameters**\n\nDevelopers often select cost factors or parameters based on development machine performance rather than production hardware and security requirements. This leads to password hashes that provide inadequate protection against modern attack techniques and specialized hardware.\n\n**Why it's wrong:** Password cracking hardware improves rapidly, and attackers use specialized equipment like GPU clusters and ASICs that far exceed typical development hardware capabilities. A cost factor that seems adequate during development may provide minimal protection against real-world attacks.\n\n**How to fix:** Measure performance on production hardware under realistic load conditions. Use industry minimum recommendations as starting points: bcrypt cost factor 12+ for new systems, Argon2 with 64MB+ memory cost. Implement regular security reviews that reassess parameter adequacy as hardware evolves.\n\n⚠️ **Pitfall: Ignoring Algorithm Migration Planning**\n\nMany systems implement modern hashing algorithms but fail to plan migration strategies for future algorithm upgrades. This creates **technical debt** that becomes increasingly expensive to resolve as the user base grows and security requirements evolve.\n\n**Why it's wrong:** All cryptographic algorithms eventually become obsolete. Systems without migration capabilities face expensive emergency upgrades when security vulnerabilities emerge or compliance requirements change. Users may lose access to accounts if migration isn't handled properly.\n\n**How to fix:** Design algorithm-agnostic hash storage from the beginning using formats like `PasswordHashRecord` that embed algorithm identification and parameters. Implement lazy migration workflows that upgrade hashes opportunistically during user authentication. Plan migration testing and rollback procedures before they're needed.\n\n### Implementation Guidance\n\n**Technology Recommendations:**\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Bcrypt Library | `bcrypt` (pip install bcrypt) | `passlib` with bcrypt backend |\n| Argon2 Library | `argon2-cffi` (pip install argon2-cffi) | `passlib` with Argon2 backend |\n| Parameter Storage | JSON configuration files | Database-backed parameter management |\n| Migration Management | Manual upgrade scripts | Automated migration workflows |\n| Performance Monitoring | Simple timing measurements | Statistical analysis with confidence intervals |\n\n**Recommended File Structure:**\n\n```\nproject-root/\n  password_hashing/\n    __init__.py\n    modern_hasher.py          ← ModernPasswordHasher implementation\n    bcrypt_integration.py     ← Bcrypt-specific functionality\n    argon2_integration.py     ← Argon2-specific functionality\n    algorithm_registry.py     ← Algorithm selection and dispatch\n    migration_manager.py      ← Migration workflows and policies\n    parameter_tuning.py       ← Performance benchmarking utilities\n  tests/\n    test_modern_hashing.py    ← Comprehensive algorithm testing\n    test_migration.py         ← Migration workflow testing\n    benchmark_performance.py  ← Performance measurement scripts\n  config/\n    algorithm_defaults.json   ← Default parameters for each algorithm\n    migration_policies.json   ← Migration rules and triggers\n```\n\n**Infrastructure Starter Code (Complete Implementation):**\n\n```python\n# algorithm_registry.py - Complete algorithm registry system\nimport importlib\nfrom typing import Dict, Type, Optional, List\nfrom abc import ABC, abstractmethod\nfrom .data_model import PasswordHashRecord\n\nclass PasswordHashingAlgorithm(ABC):\n    \"\"\"Abstract base class for password hashing algorithm implementations.\"\"\"\n    \n    @abstractmethod\n    def hash_password(self, password: bytes, **kwargs) -> PasswordHashRecord:\n        \"\"\"Generate password hash with algorithm-specific parameters.\"\"\"\n        pass\n    \n    @abstractmethod\n    def verify_password(self, password: bytes, hash_record: PasswordHashRecord) -> bool:\n        \"\"\"Verify password against stored hash record.\"\"\"\n        pass\n    \n    @abstractmethod\n    def get_default_parameters(self) -> Dict:\n        \"\"\"Return recommended default parameters for this algorithm.\"\"\"\n        pass\n    \n    @abstractmethod\n    def benchmark_parameters(self, target_time_ms: int) -> Dict:\n        \"\"\"Recommend parameters for target performance characteristics.\"\"\"\n        pass\n\nclass AlgorithmRegistry:\n    \"\"\"Registry for managing multiple password hashing algorithm implementations.\"\"\"\n    \n    def __init__(self):\n        self._algorithms: Dict[str, Type[PasswordHashingAlgorithm]] = {}\n        self._default_algorithm: Optional[str] = None\n        self._migration_preferences: List[str] = []\n    \n    def register_algorithm(self, name: str, algorithm_class: Type[PasswordHashingAlgorithm]) -> None:\n        \"\"\"Register a password hashing algorithm implementation.\"\"\"\n        if not issubclass(algorithm_class, PasswordHashingAlgorithm):\n            raise ValueError(f\"Algorithm class must inherit from PasswordHashingAlgorithm\")\n        \n        self._algorithms[name] = algorithm_class\n    \n    def get_algorithm(self, name: str) -> PasswordHashingAlgorithm:\n        \"\"\"Retrieve algorithm implementation by name.\"\"\"\n        if name not in self._algorithms:\n            raise ValueError(f\"Unknown algorithm: {name}\")\n        \n        return self._algorithms[name]()\n    \n    def set_default_algorithm(self, name: str) -> None:\n        \"\"\"Set the default algorithm for new password hashes.\"\"\"\n        if name not in self._algorithms:\n            raise ValueError(f\"Cannot set unknown algorithm as default: {name}\")\n        \n        self._default_algorithm = name\n    \n    def get_default_algorithm(self) -> PasswordHashingAlgorithm:\n        \"\"\"Get the current default algorithm implementation.\"\"\"\n        if self._default_algorithm is None:\n            raise RuntimeError(\"No default algorithm configured\")\n        \n        return self.get_algorithm(self._default_algorithm)\n    \n    def list_available_algorithms(self) -> List[str]:\n        \"\"\"Return list of registered algorithm names.\"\"\"\n        return list(self._algorithms.keys())\n    \n    def set_migration_preferences(self, preferences: List[str]) -> None:\n        \"\"\"Set preferred migration path ordering (most preferred first).\"\"\"\n        # Validate all algorithms are registered\n        for algorithm in preferences:\n            if algorithm not in self._algorithms:\n                raise ValueError(f\"Migration preference includes unknown algorithm: {algorithm}\")\n        \n        self._migration_preferences = preferences.copy()\n    \n    def get_migration_target(self, current_algorithm: str) -> Optional[str]:\n        \"\"\"Determine target algorithm for migrating from current algorithm.\"\"\"\n        if not self._migration_preferences:\n            return self._default_algorithm\n        \n        # Find current algorithm in preference list\n        try:\n            current_index = self._migration_preferences.index(current_algorithm)\n            # If not the most preferred, return the most preferred\n            if current_index > 0:\n                return self._migration_preferences[0]\n        except ValueError:\n            # Current algorithm not in preferences, return most preferred\n            return self._migration_preferences[0]\n        \n        # Already using most preferred algorithm\n        return None\n\n# Global algorithm registry instance\nalgorithm_registry = AlgorithmRegistry()\n```\n\n```python\n# parameter_tuning.py - Complete performance benchmarking utilities\nimport time\nimport statistics\nimport gc\nfrom typing import Dict, List, Callable, Any\nfrom dataclasses import dataclass\n\n@dataclass\nclass BenchmarkResult:\n    \"\"\"Results from algorithm performance benchmarking.\"\"\"\n    algorithm: str\n    parameters: Dict[str, Any]\n    mean_time_ms: float\n    median_time_ms: float\n    std_deviation_ms: float\n    min_time_ms: float\n    max_time_ms: float\n    sample_count: int\n    recommended: bool\n\nclass PerformanceBenchmarker:\n    \"\"\"Utility for measuring password hashing algorithm performance.\"\"\"\n    \n    def __init__(self, test_password: bytes = b\"test_password_for_benchmarking\"):\n        self.test_password = test_password\n        self.warmup_iterations = 3\n        self.measurement_iterations = 10\n    \n    def benchmark_function(self, func: Callable, *args, **kwargs) -> Dict[str, float]:\n        \"\"\"Measure function execution time with statistical analysis.\"\"\"\n        # Warmup runs to stabilize performance\n        for _ in range(self.warmup_iterations):\n            func(*args, **kwargs)\n            gc.collect()\n        \n        # Measurement runs\n        times = []\n        for _ in range(self.measurement_iterations):\n            start_time = time.perf_counter()\n            func(*args, **kwargs)\n            end_time = time.perf_counter()\n            times.append((end_time - start_time) * 1000)  # Convert to milliseconds\n            gc.collect()\n        \n        return {\n            'mean_ms': statistics.mean(times),\n            'median_ms': statistics.median(times),\n            'std_dev_ms': statistics.stdev(times) if len(times) > 1 else 0.0,\n            'min_ms': min(times),\n            'max_ms': max(times),\n            'sample_count': len(times)\n        }\n    \n    def find_target_parameters(self, algorithm_name: str, target_time_ms: float, \n                             tolerance_ms: float = 50.0) -> Dict[str, Any]:\n        \"\"\"Find algorithm parameters that achieve target execution time.\"\"\"\n        from .algorithm_registry import algorithm_registry\n        \n        algorithm = algorithm_registry.get_algorithm(algorithm_name)\n        \n        if algorithm_name.lower() == 'bcrypt':\n            return self._tune_bcrypt_cost(algorithm, target_time_ms, tolerance_ms)\n        elif algorithm_name.lower().startswith('argon2'):\n            return self._tune_argon2_parameters(algorithm, target_time_ms, tolerance_ms)\n        else:\n            raise ValueError(f\"Parameter tuning not implemented for algorithm: {algorithm_name}\")\n    \n    def _tune_bcrypt_cost(self, algorithm, target_time_ms: float, tolerance_ms: float) -> Dict[str, Any]:\n        \"\"\"Binary search to find optimal bcrypt cost factor.\"\"\"\n        from .constants import BCRYPT_MIN_COST\n        \n        min_cost = BCRYPT_MIN_COST\n        max_cost = 20  # Reasonable upper bound\n        best_cost = min_cost\n        best_time = float('inf')\n        \n        while min_cost <= max_cost:\n            test_cost = (min_cost + max_cost) // 2\n            \n            # Measure performance at this cost level\n            timing_result = self.benchmark_function(\n                algorithm.hash_password, \n                self.test_password, \n                cost=test_cost\n            )\n            \n            mean_time = timing_result['mean_ms']\n            \n            # Check if this is within acceptable range\n            if abs(mean_time - target_time_ms) <= tolerance_ms:\n                return {'cost': test_cost, 'measured_time_ms': mean_time}\n            \n            # Track best option found so far\n            if abs(mean_time - target_time_ms) < abs(best_time - target_time_ms):\n                best_cost = test_cost\n                best_time = mean_time\n            \n            # Adjust search range\n            if mean_time < target_time_ms:\n                min_cost = test_cost + 1\n            else:\n                max_cost = test_cost - 1\n        \n        return {'cost': best_cost, 'measured_time_ms': best_time}\n    \n    def _tune_argon2_parameters(self, algorithm, target_time_ms: float, tolerance_ms: float) -> Dict[str, Any]:\n        \"\"\"Find optimal Argon2 parameters through systematic search.\"\"\"\n        # Start with reasonable defaults and adjust\n        base_params = {\n            'memory_cost': 65536,  # 64 MB\n            'time_cost': 3,\n            'parallelism': 4\n        }\n        \n        # Test base parameters\n        timing_result = self.benchmark_function(\n            algorithm.hash_password,\n            self.test_password,\n            **base_params\n        )\n        \n        current_time = timing_result['mean_ms']\n        \n        # Adjust time_cost to get closer to target\n        if current_time < target_time_ms:\n            # Need more iterations\n            while current_time < target_time_ms - tolerance_ms and base_params['time_cost'] < 10:\n                base_params['time_cost'] += 1\n                timing_result = self.benchmark_function(\n                    algorithm.hash_password,\n                    self.test_password,\n                    **base_params\n                )\n                current_time = timing_result['mean_ms']\n        else:\n            # Need fewer iterations\n            while current_time > target_time_ms + tolerance_ms and base_params['time_cost'] > 1:\n                base_params['time_cost'] -= 1\n                timing_result = self.benchmark_function(\n                    algorithm.hash_password,\n                    self.test_password,\n                    **base_params\n                )\n                current_time = timing_result['mean_ms']\n        \n        base_params['measured_time_ms'] = current_time\n        return base_params\n```\n\n**Core Logic Skeleton Code (for learner implementation):**\n\n```python\n# modern_hasher.py - Core modern hashing component (skeleton for learner implementation)\n\nfrom typing import Dict, Optional, Union, List\nfrom datetime import datetime\nimport json\nfrom .data_model import PasswordHashRecord, AlgorithmParameters\nfrom .algorithm_registry import algorithm_registry\nfrom .migration_manager import MigrationManager\n\nclass ModernPasswordHasher:\n    \"\"\"\n    Modern password hashing component supporting multiple algorithms with migration capabilities.\n    \n    This component provides the main interface for password hashing using bcrypt, Argon2, and other\n    modern algorithms. It handles algorithm selection, parameter management, and migration workflows.\n    \"\"\"\n    \n    def __init__(self, default_algorithm: str = \"bcrypt\"):\n        self.default_algorithm = default_algorithm\n        self.migration_manager = MigrationManager()\n        \n        # TODO 1: Initialize algorithm registry with bcrypt and Argon2 implementations\n        # TODO 2: Set up default algorithm configuration\n        # TODO 3: Load algorithm parameters from configuration files\n        # Hint: Use algorithm_registry.register_algorithm() for each supported algorithm\n        pass\n    \n    def hash_password(self, password: Union[str, bytes], \n                     algorithm: Optional[str] = None,\n                     **algorithm_params) -> PasswordHashRecord:\n        \"\"\"\n        Generate secure password hash using specified or default algorithm.\n        \n        Args:\n            password: The password to hash (string or bytes)\n            algorithm: Algorithm name (bcrypt, argon2id) or None for default\n            **algorithm_params: Algorithm-specific parameters (cost, memory_cost, etc.)\n        \n        Returns:\n            PasswordHashRecord with all verification information\n        \"\"\"\n        # TODO 1: Validate password input (check for None, empty, convert to bytes)\n        # TODO 2: Select algorithm (use provided algorithm or fall back to default)\n        # TODO 3: Get algorithm implementation from registry\n        # TODO 4: Merge provided parameters with algorithm defaults\n        # TODO 5: Generate password hash using selected algorithm\n        # TODO 6: Create PasswordHashRecord with all necessary metadata\n        # TODO 7: Validate the generated hash record before returning\n        # Hint: Use algorithm_registry.get_algorithm() to get implementation\n        # Hint: Call algorithm.get_default_parameters() and merge with algorithm_params\n        pass\n    \n    def verify_password(self, password: Union[str, bytes], \n                       hash_record: PasswordHashRecord,\n                       enable_migration: bool = True) -> bool:\n        \"\"\"\n        Verify password against stored hash with optional migration.\n        \n        Args:\n            password: The password to verify\n            hash_record: Stored password hash record\n            enable_migration: Whether to perform lazy migration if hash is outdated\n        \n        Returns:\n            True if password matches, False otherwise\n            \n        Side Effects:\n            May update hash_record with migrated hash if enable_migration=True\n        \"\"\"\n        # TODO 1: Validate inputs (password not None/empty, hash_record valid)\n        # TODO 2: Convert password to bytes if necessary\n        # TODO 3: Get algorithm implementation for the stored hash algorithm\n        # TODO 4: Perform password verification using original algorithm and parameters\n        # TODO 5: If verification succeeds and enable_migration=True, check if migration needed\n        # TODO 6: If migration needed, generate new hash with current algorithm/parameters\n        # TODO 7: Update hash_record with migrated hash (preserve original as backup)\n        # TODO 8: Return verification result\n        # Hint: Use self.migration_manager.assess_migration_candidate() to check migration need\n        # Hint: Use algorithm_registry.get_algorithm(hash_record.algorithm) for verification\n        pass\n    \n    def assess_hash_strength(self, hash_record: PasswordHashRecord) -> Dict[str, any]:\n        \"\"\"\n        Analyze the security strength of a password hash record.\n        \n        Args:\n            hash_record: The hash record to analyze\n            \n        Returns:\n            Dictionary with strength assessment including recommendations\n        \"\"\"\n        # TODO 1: Extract algorithm and parameters from hash record\n        # TODO 2: Check algorithm against current security recommendations\n        # TODO 3: Validate parameters meet minimum security requirements\n        # TODO 4: Calculate estimated attack cost based on current hardware\n        # TODO 5: Determine if migration is recommended\n        # TODO 6: Generate strength score and recommendations\n        # TODO 7: Return comprehensive analysis dictionary\n        # Hint: Compare against constants like BCRYPT_MIN_COST, PBKDF2_MIN_ITERATIONS\n        # Hint: Include fields: strength_score, algorithm_current, parameters_adequate, migration_recommended\n        pass\n    \n    def batch_migration_analysis(self, hash_records: List[PasswordHashRecord]) -> Dict[str, any]:\n        \"\"\"\n        Analyze a collection of password hashes for migration opportunities.\n        \n        Args:\n            hash_records: List of hash records to analyze\n            \n        Returns:\n            Migration analysis report with statistics and recommendations\n        \"\"\"\n        # TODO 1: Initialize analysis counters and categorization\n        # TODO 2: Iterate through all hash records\n        # TODO 3: Categorize each record by algorithm and security level\n        # TODO 4: Count records needing migration vs. adequate records\n        # TODO 5: Calculate migration effort estimates\n        # TODO 6: Generate prioritized migration recommendations\n        # TODO 7: Return comprehensive migration report\n        # Hint: Use self.assess_hash_strength() for each record\n        # Hint: Group results by algorithm and create migration priority levels\n        pass\n    \n    def benchmark_algorithm(self, algorithm: str, **parameters) -> Dict[str, float]:\n        \"\"\"\n        Benchmark algorithm performance with specified parameters.\n        \n        Args:\n            algorithm: Algorithm name to benchmark\n            **parameters: Algorithm-specific parameters to test\n            \n        Returns:\n            Performance statistics including timing measurements\n        \"\"\"\n        # TODO 1: Get algorithm implementation from registry\n        # TODO 2: Create test password for consistent benchmarking\n        # TODO 3: Set up performance measurement (warmup runs, timing)\n        # TODO 4: Execute multiple hash operations with timing\n        # TODO 5: Calculate statistical measures (mean, median, std dev)\n        # TODO 6: Generate performance report with recommendations\n        # TODO 7: Return timing statistics and parameter recommendations\n        # Hint: Use time.perf_counter() for high-precision timing\n        # Hint: Include warmup runs to stabilize performance measurements\n        pass\n```\n\n```python\n# bcrypt_integration.py - Bcrypt algorithm implementation (skeleton)\n\nimport bcrypt\nfrom typing import Dict, Any\nfrom .data_model import PasswordHashRecord\nfrom .algorithm_registry import PasswordHashingAlgorithm\nfrom .constants import BCRYPT_MIN_COST\n\nclass BcryptAlgorithm(PasswordHashingAlgorithm):\n    \"\"\"Bcrypt password hashing algorithm implementation.\"\"\"\n    \n    def hash_password(self, password: bytes, cost: int = 12, **kwargs) -> PasswordHashRecord:\n        \"\"\"Generate bcrypt hash with specified cost factor.\"\"\"\n        # TODO 1: Validate cost factor meets minimum security requirements\n        # TODO 2: Generate bcrypt hash using library (bcrypt.hashpw)\n        # TODO 3: Parse bcrypt output to extract algorithm version, cost, salt, and hash\n        # TODO 4: Create PasswordHashRecord with extracted components\n        # TODO 5: Set appropriate algorithm identifier and version\n        # TODO 6: Return completed hash record\n        # Hint: Use bcrypt.hashpw(password, bcrypt.gensalt(rounds=cost))\n        # Hint: Bcrypt output format: $2b$cost$salt+hash (base64 encoded)\n        pass\n    \n    def verify_password(self, password: bytes, hash_record: PasswordHashRecord) -> bool:\n        \"\"\"Verify password against stored bcrypt hash.\"\"\"\n        # TODO 1: Extract bcrypt hash string from hash_record\n        # TODO 2: Use bcrypt.checkpw to verify password\n        # TODO 3: Handle any bcrypt library exceptions\n        # TODO 4: Return verification result\n        # Hint: bcrypt.checkpw(password, stored_hash.encode()) returns boolean\n        pass\n    \n    def get_default_parameters(self) -> Dict:\n        \"\"\"Return recommended bcrypt parameters.\"\"\"\n        # TODO 1: Return dictionary with default cost factor\n        # TODO 2: Include parameter descriptions and security rationale\n        # Hint: Use BCRYPT_MIN_COST as minimum, recommend 12-14 for most applications\n        pass\n    \n    def benchmark_parameters(self, target_time_ms: int) -> Dict:\n        \"\"\"Find optimal bcrypt cost factor for target timing.\"\"\"\n        # TODO 1: Start with minimum cost factor\n        # TODO 2: Measure hash computation time at current cost\n        # TODO 3: Adjust cost factor based on measured vs. target time\n        # TODO 4: Use binary search to efficiently find optimal cost\n        # TODO 5: Return recommended parameters with measured performance\n        # Hint: Each cost increment doubles computation time\n        pass\n```\n\n**Language-Specific Hints:**\n\n- **Library Installation**: Use `pip install bcrypt argon2-cffi` for cryptographic libraries\n- **Memory Management**: Both bcrypt and Argon2 libraries handle secure memory clearing automatically\n- **Threading Safety**: bcrypt and argon2-cffi are thread-safe for concurrent operations\n- **Error Handling**: Wrap cryptographic operations in try-catch blocks for library-specific exceptions\n- **Parameter Validation**: Validate cost factors and memory parameters before passing to libraries\n- **Performance Monitoring**: Use `time.perf_counter()` for high-precision benchmarking measurements\n\n**Milestone Checkpoint:**\n\nAfter implementing the modern hashing component, verify functionality:\n\n1. **Algorithm Integration Test**:\n   ```bash\n   python -m pytest tests/test_modern_hashing.py::test_bcrypt_integration -v\n   python -m pytest tests/test_modern_hashing.py::test_argon2_integration -v\n   ```\n\n2. **Expected Behavior**: \n   - Bcrypt hashes should start with `$2b$` and include cost factor in format\n   - Argon2 hashes should start with `$argon2id$` and include all parameters\n   - Parameter tuning should recommend cost factors based on measured performance\n   - Migration assessment should identify outdated hashes and recommend upgrades\n\n3. **Manual Verification**:\n   - Generate bcrypt hash with cost 12, verify timing is 100-500ms on your hardware\n   - Generate Argon2 hash with 64MB memory, verify memory usage during operation\n   - Test migration workflow by creating PBKDF2 hash then upgrading to bcrypt\n   - Verify hash records contain all necessary parameters for future verification\n\n4. **Performance Validation**:\n   - Run benchmark suite: `python benchmark_performance.py --algorithms bcrypt,argon2id`\n   - Verify cost factor recommendations scale appropriately with target timing\n   - Test concurrent authentication load doesn't cause memory exhaustion with Argon2\n\n**Debugging Tips:**\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| `ValueError: Invalid rounds` | Cost factor too low for bcrypt | Check cost < BCRYPT_MIN_COST | Increase cost factor to 12+ |\n| `MemoryError` with Argon2 | Memory cost too high for system | Monitor system memory during hash | Reduce memory_cost parameter |\n| Hash verification always fails | Algorithm mismatch or corrupted hash | Print algorithm from hash_record | Verify algorithm registration and hash format |\n| Performance much slower than expected | Wrong algorithm or excessive parameters | Time individual hash operations | Tune parameters with benchmark_algorithm() |\n| Migration not triggering | Migration policies too restrictive | Check migration_manager.assess_migration_candidate() | Adjust migration thresholds in configuration |\n\n\n## Interactions and Data Flow\n\n> **Milestone(s):** All milestones (complete data flow spans all implementation phases)\n\n### Mental Model: The Airport Security Processing Pipeline\n\nThink of password processing like an airport security checkpoint system. When passengers arrive at security, they follow a standardized processing pipeline: they present their ID, remove items for scanning, pass through detection equipment, and receive clearance to proceed. The system handles two distinct flows - initial passenger enrollment (when someone first registers for TSA PreCheck) and routine verification (daily security screening).\n\nSimilarly, our password hashing system orchestrates two critical data flows. During **password registration**, a new user's plain password enters our security pipeline, gets processed through salt generation and hashing components, and emerges as a secure hash record ready for storage. During **password verification**, a stored hash record and incoming password attempt flow through verification components that reconstruct the original hashing process and perform constant-time comparison.\n\nJust as airport security maintains detailed logs of every passenger interaction and follows strict protocols regardless of passenger status, our system maintains comprehensive audit trails and follows identical processing steps whether handling a brand new password or verifying an existing one. The pipeline architecture ensures that every password receives the same rigorous security treatment while maintaining clear separation between the registration and verification flows.\n\n![Password Registration Sequence](./diagrams/registration-sequence.svg)\n\n![Password Verification Sequence](./diagrams/verification-sequence.svg)\n\n### Password Registration Flow\n\nThe password registration flow represents the complete journey from user password input through cryptographic processing to secure storage. This flow must execute identically regardless of which hashing algorithm the system employs, ensuring consistent security properties across all implementation milestones.\n\n#### Registration Flow Architecture\n\nThe registration flow follows a strict sequential processing model where each component performs its specialized function and passes validated output to the next stage. This pipeline architecture prevents bypassing security steps and ensures complete audit trails for every password registration attempt.\n\n> **Decision: Sequential Pipeline Architecture**\n> - **Context**: Password registration involves multiple independent cryptographic operations (salt generation, hashing, parameter validation) that must execute in correct order\n> - **Options Considered**: \n>   - Monolithic registration function handling all steps internally\n>   - Sequential pipeline with clear component boundaries\n>   - Event-driven asynchronous processing with message queues\n> - **Decision**: Sequential pipeline with synchronous component interactions\n> - **Rationale**: Cryptographic operations require deterministic ordering and error handling. Sequential processing provides clear failure points and simplifies debugging. Asynchronous processing introduces timing attack vectors and complicates constant-time guarantees.\n> - **Consequences**: Enables component-level testing and validation. Requires careful error propagation design. Provides clear audit trail for security analysis.\n\n| Registration Stage | Component Responsible | Input Data | Output Data | Validation Performed |\n|-------------------|---------------------|------------|-------------|-------------------|\n| Input Validation | PasswordHashingService | Raw password string | Validated password | Length, character set, encoding |\n| Salt Generation | SaltGenerator | Validation success | Cryptographic salt bytes | Entropy verification, length check |\n| Algorithm Selection | AlgorithmRegistry | User preferences, policy | Algorithm instance | Availability check, parameter validation |\n| Hash Computation | Selected Algorithm | Password + salt + parameters | Hash bytes | Computation success, output length |\n| Record Assembly | PasswordHashingService | All components | PasswordHashRecord | Completeness, consistency |\n| Storage Preparation | PasswordHashingService | Complete record | Serialized format | Serialization integrity |\n\n#### Detailed Registration Process\n\nThe registration process follows these precise steps, with each step including comprehensive error handling and security validation:\n\n1. **Password Input Validation**: The system receives the raw password string and validates it meets basic requirements. This includes checking for null values, empty strings, and character encoding issues. The validation does not enforce password strength policies (that responsibility belongs to application-level components), but ensures the input is processable by cryptographic functions.\n\n2. **Algorithm Selection and Configuration**: Based on system configuration and user preferences, the `AlgorithmRegistry` selects the appropriate hashing algorithm. For Milestone 1, this defaults to `BasicHasher` with SHA-256. For Milestone 2, `KeyStretchingHasher` with PBKDF2 becomes available. For Milestone 3, `ModernPasswordHasher` provides bcrypt and Argon2 options. The registry validates that the selected algorithm is available and properly configured.\n\n3. **Parameter Validation and Tuning**: The selected algorithm validates its parameters meet security requirements. For basic hashing, this verifies salt length meets `MINIMUM_SALT_LENGTH`. For key stretching, this ensures iteration count exceeds `PBKDF2_MIN_ITERATIONS`. For modern algorithms, this validates cost factors and memory parameters. The `ParameterValidator` component performs these checks and raises `ParameterValidationError` for invalid configurations.\n\n4. **Cryptographic Salt Generation**: The `SaltGenerator` component produces a cryptographically secure random salt. This process accesses the system's entropy source (typically `/dev/urandom` on Unix systems or `CryptGenRandom` on Windows) and verifies sufficient entropy is available. If entropy is exhausted, the system raises `EntropyExhaustionError` rather than proceeding with predictable randomness.\n\n5. **Hash Computation**: The selected algorithm combines the validated password, generated salt, and configured parameters to compute the cryptographic hash. For basic hashing, this involves SHA-256 computation over concatenated password and salt. For PBKDF2, this involves iterative HMAC-SHA256 rounds. For bcrypt/Argon2, this delegates to the respective library implementations. Computation failures raise `HashComputationError`.\n\n6. **Hash Record Assembly**: The system constructs a complete `PasswordHashRecord` containing the algorithm identifier, salt bytes, hash bytes, algorithm parameters, version number, and creation timestamp. This record is self-contained and includes all information necessary for future password verification without relying on external configuration.\n\n7. **Record Validation**: Before finalizing the registration, the system validates the assembled record by calling `validate()` on the `PasswordHashRecord`. This ensures all required fields are populated, parameter dictionaries contain valid values, and the record structure is internally consistent.\n\n8. **Storage Serialization**: The validated record undergoes serialization using either `to_json()` for structured storage systems or `to_string_format()` for compact string-based storage. The serialization process includes integrity checks to verify the serialized data can be correctly deserialized.\n\n#### Registration Data Flow Example\n\nConsider a concrete example of registering the password `\"secure123\"` using PBKDF2 with 150,000 iterations:\n\n**Input Phase**: The application calls `hash_password(\"secure123\", \"pbkdf2\", iterations=150000)`. The system validates the password string is valid UTF-8 and non-empty.\n\n**Algorithm Selection**: The `AlgorithmRegistry` locates the `KeyStretchingHasher` algorithm and validates PBKDF2 is available. It creates an `AlgorithmParameters` instance with the requested 150,000 iterations and default 32-byte key length.\n\n**Parameter Validation**: The `ParameterValidator` confirms 150,000 exceeds `PBKDF2_MIN_ITERATIONS` (100,000) and the 32-byte key length is within acceptable bounds. Validation passes.\n\n**Salt Generation**: The `SaltGenerator` requests 32 bytes of random data from the system entropy source. It receives bytes like `b'\\x8f\\x3a\\x7b...[32 bytes total]'` and verifies the entropy pool is not exhausted.\n\n**Hash Computation**: The `KeyStretchingHasher` invokes `hash_password_with_stretching()` with the password, salt, and 150,000 iterations. PBKDF2-HMAC-SHA256 executes 150,000 rounds, producing a 32-byte derived key.\n\n**Record Assembly**: The system creates a `PasswordHashRecord` with:\n- `algorithm`: `\"pbkdf2\"`\n- `salt`: The 32-byte random salt\n- `hash`: The 32-byte derived key\n- `parameters`: `{\"iterations\": 150000, \"key_length\": 32, \"hash_function\": \"sha256\"}`\n- `version`: `1`\n- `created_at`: Current timestamp\n\n**Validation and Storage**: The record passes validation checks. Serialization produces a JSON string containing all fields, ready for database storage.\n\n#### Registration Error Handling\n\nThe registration flow implements comprehensive error handling with specific recovery strategies for each failure mode:\n\n| Error Type | Failure Scenario | Detection Method | Recovery Action | Security Implication |\n|------------|------------------|------------------|-----------------|-------------------|\n| Input Validation | Null/empty password | Length check | Return validation error | Prevents processing invalid input |\n| Entropy Exhaustion | `/dev/urandom` unavailable | OS error on read | Retry with backoff, then fail | Prevents predictable salt generation |\n| Algorithm Unavailable | Requested algorithm not installed | Registry lookup failure | Fall back to default algorithm | Maintains service availability |\n| Parameter Invalid | Iteration count too low | Parameter validation | Use secure defaults | Prevents weak configuration |\n| Hash Computation | Cryptographic library error | Exception during hashing | Log error and fail | Prevents corrupted hash storage |\n| Serialization Failure | Record too large for storage | Serialization exception | Optimize parameters and retry | Prevents storage system errors |\n\n> ⚠️ **Pitfall: Partial Registration Recovery**\n> A common mistake is attempting to recover from mid-pipeline failures by reusing already-generated components (like keeping the salt but regenerating the hash). This creates timing-dependent behavior that can leak information through side channels. Always restart the entire registration process from input validation when any component fails.\n\n#### Registration Performance Monitoring\n\nThe registration flow includes performance monitoring to detect security parameter tuning needs and system capacity planning:\n\n| Monitoring Metric | Measurement Method | Normal Range | Alert Threshold | Response Action |\n|-------------------|-------------------|--------------|-----------------|-----------------|\n| Salt Generation Time | Timestamp before/after generation | < 1ms | > 10ms | Check entropy source |\n| Hash Computation Time | Algorithm-specific benchmarking | Varies by algorithm | 2x expected | Reduce parameters |\n| Total Registration Time | End-to-end measurement | < 500ms typical | > 2 seconds | System capacity review |\n| Success Rate | Registration completion ratio | > 99.9% | < 99% | Investigate failures |\n| Parameter Distribution | Algorithm/parameter usage | Expected distribution | Skew > 20% | Review defaults |\n\n### Password Verification Flow\n\nThe password verification flow reconstructs the original registration process using stored hash record information and compares the result against the stored hash using constant-time comparison. This flow must resist timing attacks and provide identical execution patterns regardless of password correctness.\n\n#### Verification Flow Architecture\n\nThe verification flow implements a **reconstruction and comparison** model where the system recreates the exact hashing process used during registration and performs cryptographically secure comparison of results. This approach ensures verification succeeds only when the input password produces identical cryptographic output through identical processing steps.\n\n> **Decision: Reconstruction-Based Verification**\n> - **Context**: Password verification must confirm an input password produces the same hash as originally stored, while preventing timing attacks and maintaining algorithm agility\n> - **Options Considered**:\n>   - Direct hash comparison after re-hashing with stored parameters\n>   - Database query-based verification with hash comparison in database\n>   - Token-based verification avoiding password re-hashing\n> - **Decision**: Reconstruct original hashing process and use constant-time comparison\n> - **Rationale**: Reconstruction ensures identical cryptographic operations regardless of algorithm evolution. Constant-time comparison prevents timing side channels. Database-level comparison leaks timing information and reduces algorithm flexibility.\n> - **Consequences**: Provides strong timing attack resistance. Requires careful constant-time implementation. Enables seamless algorithm migration during verification.\n\n| Verification Stage | Component Responsible | Input Data | Processing Action | Security Property |\n|-------------------|---------------------|------------|------------------|------------------|\n| Record Retrieval | Storage Interface | User identifier | Deserialize hash record | Data integrity verification |\n| Record Validation | PasswordHashRecord | Stored record | Field completeness check | Prevents corrupted data processing |\n| Algorithm Resolution | AlgorithmRegistry | Algorithm identifier | Locate algorithm instance | Ensures algorithm availability |\n| Parameter Extraction | PasswordHashRecord | Parameter dictionary | Extract algorithm configuration | Preserves original settings |\n| Hash Reconstruction | Selected Algorithm | Password + stored salt + parameters | Re-execute hashing process | Identical cryptographic computation |\n| Constant-Time Comparison | Security utilities | Computed hash + stored hash | Byte-by-byte timing-safe comparison | Prevents timing side channels |\n| Migration Assessment | MigrationManager | Hash record age/strength | Evaluate upgrade necessity | Opportunistic security improvements |\n\n#### Detailed Verification Process\n\nThe verification process executes these steps with careful attention to timing consistency and side-channel resistance:\n\n1. **Hash Record Retrieval and Deserialization**: The system retrieves the stored hash record using the user identifier and deserializes it from JSON or string format. The deserialization process validates the record structure and raises `ValidationError` if required fields are missing or corrupted. This step must complete in consistent time regardless of record contents to prevent user enumeration attacks.\n\n2. **Record Integrity Validation**: The system calls `validate()` on the deserialized `PasswordHashRecord` to verify internal consistency. This checks that the algorithm identifier is recognized, salt and hash lengths are appropriate for the algorithm, and parameter dictionaries contain required values. Invalid records indicate either corruption or attempted tampering.\n\n3. **Algorithm Instance Resolution**: Using the `algorithm` field from the hash record, the `AlgorithmRegistry` locates the appropriate algorithm implementation. For records created in Milestone 1, this resolves to `BasicHasher`. For PBKDF2 records, this resolves to `KeyStretchingHasher`. For modern algorithm records, this resolves to the specific `BcryptAlgorithm` or `Argon2Algorithm` implementation.\n\n4. **Parameter Reconstruction**: The verification process extracts algorithm parameters from the stored record's `parameters` dictionary. This ensures the re-hashing process uses identical settings to the original registration, including iteration counts, key lengths, memory costs, and algorithm variants. Parameter extraction preserves the exact configuration active at registration time.\n\n5. **Salt and Password Preparation**: The system extracts the stored salt bytes from the hash record and combines them with the input password according to the algorithm's requirements. For basic hashing, this involves simple concatenation. For PBKDF2, this provides the salt parameter to the key derivation function. For bcrypt/Argon2, this follows the algorithm-specific salt incorporation mechanisms.\n\n6. **Hash Reconstruction**: The selected algorithm re-executes the complete hashing process using the input password, stored salt, and stored parameters. This produces a fresh hash that should be identical to the stored hash if the input password is correct. The reconstruction must use identical computational steps to prevent timing differences based on password correctness.\n\n7. **Constant-Time Comparison**: The system compares the reconstructed hash against the stored hash using `constant_time_compare()`. This function compares every byte regardless of early mismatches, ensuring execution time depends only on hash length, not on password correctness or mismatch location. The comparison result is a boolean indicating password validity.\n\n8. **Migration Assessment and Execution**: If verification succeeds and the hash record indicates outdated security parameters, the `MigrationManager` assesses whether lazy migration should occur. This involves creating a new hash record with current security parameters and replacing the stored record transparently during the verification process.\n\n#### Verification Data Flow Example\n\nConsider verifying the password `\"secure123\"` against a stored PBKDF2 hash record:\n\n**Record Retrieval**: The system retrieves a hash record containing algorithm `\"pbkdf2\"`, 32-byte salt, 32-byte hash, and parameters `{\"iterations\": 150000, \"key_length\": 32, \"hash_function\": \"sha256\"}`.\n\n**Validation**: The record passes integrity validation with all required fields present and parameter values within acceptable ranges.\n\n**Algorithm Resolution**: The `AlgorithmRegistry` locates the `KeyStretchingHasher` and confirms PBKDF2 support is available.\n\n**Hash Reconstruction**: The system calls `hash_password_with_stretching(\"secure123\", 150000, 32)` using the stored salt. PBKDF2 executes 150,000 iterations of HMAC-SHA256, producing a 32-byte derived key.\n\n**Comparison**: `constant_time_compare()` compares the reconstructed 32-byte key against the stored 32-byte hash. The function examines all 32 bytes regardless of match/mismatch status, taking identical time for correct and incorrect passwords.\n\n**Result**: If the reconstructed hash matches the stored hash exactly, verification returns `True`. Otherwise, it returns `False` without indicating where the mismatch occurred.\n\n#### Verification Timing Attack Prevention\n\nThe verification flow implements multiple layers of timing attack resistance to prevent password-related information leakage:\n\n| Timing Attack Vector | Vulnerable Implementation | Secure Implementation | Timing Consistency Mechanism |\n|---------------------|-------------------------|---------------------|---------------------------|\n| Early Comparison Exit | Stop comparing on first byte mismatch | Compare all bytes regardless | Fixed-time loop over full hash length |\n| Branch-Based Timing | Different code paths for match/mismatch | Identical operations both cases | Branchless comparison using bitwise operations |\n| Hash Length Variation | Different comparison times for different algorithms | Normalize to maximum hash length | Pad comparison to consistent length |\n| Record Lookup Timing | Fast failure for non-existent users | Consistent processing time | Dummy processing for missing records |\n| Algorithm Dispatch | Different timing for different algorithms | Equalize algorithm selection time | Consistent algorithm resolution overhead |\n\n> ⚠️ **Pitfall: Timing Attack Through Error Messages**\n> Returning different error messages for \"user not found\" versus \"invalid password\" creates a timing side channel even with constant-time comparison. Always return identical generic error messages like \"authentication failed\" regardless of the specific failure reason.\n\n#### Verification Error Handling and Recovery\n\nThe verification flow implements defensive error handling that maintains security properties even during failure scenarios:\n\n| Error Condition | Detection Method | Secure Response | Security Rationale |\n|-----------------|------------------|-----------------|-------------------|\n| User Not Found | Database lookup failure | Execute dummy hash computation | Prevents user enumeration timing |\n| Corrupted Hash Record | Deserialization exception | Return authentication failure | Prevents oracle attacks on storage |\n| Algorithm Unavailable | Registry lookup failure | Return authentication failure | Prevents downgrade attacks |\n| Hash Reconstruction Failure | Algorithm exception | Return authentication failure | Prevents partial verification bypass |\n| Migration Failure | Migration exception | Allow verification success, log error | Maintains availability during upgrades |\n\n#### Lazy Migration During Verification\n\nWhen verification succeeds but the hash record indicates outdated security parameters, the system can perform **lazy migration** to upgrade the hash transparently:\n\n1. **Migration Assessment**: The `MigrationManager` evaluates the current hash record against current security standards. Factors include algorithm age, parameter strength, and organizational security policies.\n\n2. **Migration Decision**: If migration is recommended, the system generates a new hash record using current algorithms and parameters while preserving the successful password verification result.\n\n3. **Atomic Replacement**: The system atomically replaces the stored hash record with the upgraded version, ensuring no data loss if the replacement fails.\n\n4. **Migration Logging**: Successful migrations are logged for security audit purposes, including the old and new algorithm details and migration timestamp.\n\n> **Migration triggers include**:\n> - Algorithm age exceeding policy thresholds (e.g., SHA-256 records older than 2 years)\n> - Parameter weakness below current minimums (e.g., PBKDF2 with < 100,000 iterations)\n> - Algorithm deprecation announcements (e.g., bcrypt cost factor < 12)\n> - Organizational policy changes requiring stronger protection\n\n### Implementation Guidance\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Flow Orchestration | Single service class with method calls | Event-driven pipeline with message passing |\n| Error Handling | Exception-based with try/catch blocks | Result types with explicit error propagation |\n| Timing Attack Prevention | Manual constant-time implementation | Cryptographic library timing-safe functions |\n| Performance Monitoring | Simple logging with timestamps | Metrics collection with statistical analysis |\n| Migration Management | Database triggers with stored procedures | Application-level lazy migration with audit trail |\n\n#### Recommended File Structure\n\n```\npassword-hashing/\n  src/\n    core/\n      password_service.py       ← Main orchestration service\n      flow_coordinator.py       ← Registration/verification flows\n      timing_security.py        ← Constant-time utilities\n    algorithms/\n      basic_hasher.py          ← From previous sections\n      key_stretching.py        ← From previous sections  \n      modern_hasher.py         ← From previous sections\n    security/\n      migration_manager.py     ← Hash upgrade logic\n      audit_logger.py          ← Security event logging\n    storage/\n      hash_repository.py       ← Storage interface\n      serialization.py         ← Record serialization\n  tests/\n    test_flows.py              ← Registration/verification flow tests\n    test_timing_attacks.py     ← Side-channel resistance tests\n    test_migration.py          ← Lazy migration tests\n```\n\n#### Infrastructure Starter Code\n\n**Timing Security Utilities** (complete implementation):\n\n```python\nimport hmac\nimport time\nfrom typing import Any, Dict, List, Callable\n\nclass TimingSecurity:\n    \"\"\"Utilities for preventing timing-based side channel attacks.\"\"\"\n    \n    @staticmethod\n    def constant_time_compare(a: bytes, b: bytes) -> bool:\n        \"\"\"Compare two byte strings in constant time regardless of content.\n        \n        Uses HMAC-based comparison to prevent timing attacks through\n        branch prediction and memory access patterns.\n        \"\"\"\n        if len(a) != len(b):\n            # Still perform comparison to maintain timing consistency\n            b = b[:len(a)] if len(b) > len(a) else b + b'\\x00' * (len(a) - len(b))\n        \n        return hmac.compare_digest(a, b)\n    \n    @staticmethod\n    def execute_with_minimum_time(func: Callable, min_time_ms: float, *args, **kwargs) -> Any:\n        \"\"\"Execute function with guaranteed minimum execution time.\n        \n        Prevents timing attacks that rely on measuring operation duration.\n        \"\"\"\n        start_time = time.perf_counter()\n        result = func(*args, **kwargs)\n        elapsed_ms = (time.perf_counter() - start_time) * 1000\n        \n        if elapsed_ms < min_time_ms:\n            time.sleep((min_time_ms - elapsed_ms) / 1000)\n        \n        return result\n    \n    @staticmethod\n    def verify_timing_consistency(func: Callable, test_cases: List[tuple], \n                                tolerance_ms: float = 5.0) -> Dict[str, Any]:\n        \"\"\"Verify function execution time is consistent across different inputs.\"\"\"\n        timings = []\n        \n        for case in test_cases:\n            start_time = time.perf_counter()\n            func(*case)\n            elapsed_ms = (time.perf_counter() - start_time) * 1000\n            timings.append(elapsed_ms)\n        \n        avg_time = sum(timings) / len(timings)\n        max_deviation = max(abs(t - avg_time) for t in timings)\n        \n        return {\n            'average_time_ms': avg_time,\n            'max_deviation_ms': max_deviation,\n            'timing_consistent': max_deviation <= tolerance_ms,\n            'individual_timings': timings\n        }\n```\n\n**Storage Repository Interface** (complete implementation):\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Optional, Dict, Any\nimport json\nimport logging\nfrom dataclasses import asdict\n\nfrom core.data_model import PasswordHashRecord\n\nclass HashRepository(ABC):\n    \"\"\"Abstract interface for password hash storage operations.\"\"\"\n    \n    @abstractmethod\n    def store_hash_record(self, user_id: str, record: PasswordHashRecord) -> bool:\n        \"\"\"Store a password hash record for the specified user.\"\"\"\n        pass\n    \n    @abstractmethod\n    def retrieve_hash_record(self, user_id: str) -> Optional[PasswordHashRecord]:\n        \"\"\"Retrieve stored password hash record for the specified user.\"\"\"\n        pass\n    \n    @abstractmethod\n    def update_hash_record(self, user_id: str, record: PasswordHashRecord) -> bool:\n        \"\"\"Update existing hash record (used for lazy migration).\"\"\"\n        pass\n\nclass InMemoryHashRepository(HashRepository):\n    \"\"\"Simple in-memory hash storage for development and testing.\"\"\"\n    \n    def __init__(self):\n        self._storage: Dict[str, str] = {}\n        self._logger = logging.getLogger(__name__)\n    \n    def store_hash_record(self, user_id: str, record: PasswordHashRecord) -> bool:\n        \"\"\"Store hash record as JSON string.\"\"\"\n        try:\n            serialized = record.to_json()\n            self._storage[user_id] = serialized\n            self._logger.info(f\"Stored hash record for user {user_id} using {record.algorithm}\")\n            return True\n        except Exception as e:\n            self._logger.error(f\"Failed to store hash record for user {user_id}: {e}\")\n            return False\n    \n    def retrieve_hash_record(self, user_id: str) -> Optional[PasswordHashRecord]:\n        \"\"\"Retrieve and deserialize hash record.\"\"\"\n        try:\n            if user_id not in self._storage:\n                # Execute timing-consistent dummy processing\n                dummy_data = '{\"algorithm\": \"dummy\", \"version\": 1}'\n                try:\n                    PasswordHashRecord.from_json(dummy_data)\n                except:\n                    pass\n                return None\n            \n            serialized = self._storage[user_id]\n            return PasswordHashRecord.from_json(serialized)\n        except Exception as e:\n            self._logger.error(f\"Failed to retrieve hash record for user {user_id}: {e}\")\n            return None\n    \n    def update_hash_record(self, user_id: str, record: PasswordHashRecord) -> bool:\n        \"\"\"Update existing record (same as store for this implementation).\"\"\"\n        return self.store_hash_record(user_id, record)\n```\n\n#### Core Logic Skeleton Code\n\n**Password Service Orchestration** (signatures + TODOs):\n\n```python\nfrom typing import Optional, Dict, Any\nfrom core.data_model import PasswordHashRecord\nfrom security.timing_security import TimingSecurity\nfrom storage.hash_repository import HashRepository\n\nclass PasswordService:\n    \"\"\"Main service orchestrating password registration and verification flows.\"\"\"\n    \n    def __init__(self, repository: HashRepository, migration_manager=None):\n        self.repository = repository\n        self.migration_manager = migration_manager\n        self.timing_security = TimingSecurity()\n    \n    def register_password(self, user_id: str, password: str, \n                         algorithm: str = \"bcrypt\", **params) -> bool:\n        \"\"\"Execute complete password registration flow.\n        \n        Args:\n            user_id: Unique identifier for the user\n            password: Plain text password to hash\n            algorithm: Hashing algorithm to use\n            **params: Algorithm-specific parameters\n            \n        Returns:\n            True if registration successful, False otherwise\n        \"\"\"\n        # TODO 1: Validate input password meets basic requirements (not null, proper encoding)\n        # TODO 2: Resolve algorithm instance from AlgorithmRegistry\n        # TODO 3: Validate algorithm parameters against security requirements\n        # TODO 4: Generate cryptographically secure salt using SaltGenerator\n        # TODO 5: Execute hash computation using selected algorithm\n        # TODO 6: Assemble complete PasswordHashRecord with metadata\n        # TODO 7: Validate assembled record for completeness and consistency\n        # TODO 8: Store record using repository interface with error handling\n        # TODO 9: Log registration success/failure for security audit\n        # Hint: Wrap entire process in try/except to handle component failures\n        pass\n    \n    def verify_password(self, user_id: str, password: str, \n                       enable_migration: bool = True) -> bool:\n        \"\"\"Execute complete password verification flow with timing attack protection.\n        \n        Args:\n            user_id: Unique identifier for the user\n            password: Plain text password to verify\n            enable_migration: Whether to perform lazy migration on successful verification\n            \n        Returns:\n            True if password is correct, False otherwise\n        \"\"\"\n        # TODO 1: Retrieve hash record from repository (handle user not found)\n        # TODO 2: Validate retrieved record structure and required fields\n        # TODO 3: Resolve algorithm instance from stored algorithm identifier\n        # TODO 4: Extract salt and parameters from stored record\n        # TODO 5: Reconstruct hash using identical process as registration\n        # TODO 6: Compare reconstructed hash with stored hash using constant-time comparison\n        # TODO 7: If verification succeeds and migration enabled, assess migration need\n        # TODO 8: Execute lazy migration if recommended (upgrade hash parameters)\n        # TODO 9: Return verification result without leaking timing information\n        # Hint: Use TimingSecurity.execute_with_minimum_time for consistent timing\n        pass\n    \n    def _execute_dummy_verification(self, password: str) -> bool:\n        \"\"\"Execute realistic verification steps for non-existent users.\n        \n        Prevents timing attacks that distinguish between 'user not found'\n        and 'invalid password' by performing equivalent computational work.\n        \"\"\"\n        # TODO 1: Generate dummy salt of standard length\n        # TODO 2: Execute hash computation using default algorithm\n        # TODO 3: Perform constant-time comparison against dummy hash\n        # TODO 4: Return False after timing-consistent processing\n        # Hint: This should take similar time to real verification\n        pass\n```\n\n**Migration Manager** (signatures + TODOs):\n\n```python\nfrom typing import Dict, Any, Optional\nfrom datetime import datetime, timedelta\nfrom core.data_model import PasswordHashRecord\n\nclass MigrationManager:\n    \"\"\"Manages lazy migration of password hashes to stronger algorithms.\"\"\"\n    \n    def __init__(self, migration_policies: Dict[str, Any]):\n        self.migration_policies = migration_policies\n        self.migration_statistics = {}\n    \n    def assess_migration_need(self, record: PasswordHashRecord) -> Dict[str, Any]:\n        \"\"\"Evaluate whether a hash record should be migrated to stronger parameters.\n        \n        Returns:\n            Dictionary with migration assessment results including:\n            - needs_migration: bool\n            - target_algorithm: str  \n            - security_level: str\n            - migration_reason: str\n        \"\"\"\n        # TODO 1: Check record age against policy maximum ages\n        # TODO 2: Evaluate algorithm strength against current standards\n        # TODO 3: Compare parameters (iterations, cost factors) against minimums\n        # TODO 4: Assess record version compatibility with current system\n        # TODO 5: Determine target algorithm and parameters for migration\n        # TODO 6: Calculate migration priority based on security risk\n        # TODO 7: Return assessment dictionary with migration recommendations\n        # Hint: Consider graceful handling when policies are unavailable\n        pass\n    \n    def execute_lazy_migration(self, user_id: str, password: str, \n                              old_record: PasswordHashRecord) -> Optional[PasswordHashRecord]:\n        \"\"\"Perform opportunistic hash upgrade during successful verification.\n        \n        Creates new hash record with current security parameters while\n        preserving successful authentication result.\n        \"\"\"\n        # TODO 1: Assess migration need using assess_migration_need\n        # TODO 2: If migration not needed, return None\n        # TODO 3: Select target algorithm and parameters for upgrade\n        # TODO 4: Generate new hash using current security standards\n        # TODO 5: Validate new record meets current security requirements\n        # TODO 6: Log migration activity for security audit trail\n        # TODO 7: Update migration statistics for monitoring\n        # TODO 8: Return new PasswordHashRecord for atomic storage update\n        # Hint: Migration failure should not prevent successful authentication\n        pass\n```\n\n#### Language-Specific Hints\n\n**Python-specific implementation guidance**:\n\n- Use `secrets.compare_digest()` for constant-time comparison instead of `==` operator\n- Import `time.perf_counter()` for high-precision timing measurements in benchmarks\n- Use `logging.getLogger(__name__)` for component-specific security audit logging\n- Handle `UnicodeEncodeError` when processing international characters in passwords\n- Use `@dataclass` for PasswordHashRecord to get automatic serialization methods\n- Import `typing.Optional` and `typing.Dict` for clear parameter type hints\n- Use `contextlib.contextmanager` for guaranteed cleanup in error scenarios\n\n**Error handling patterns**:\n```python\ntry:\n    result = hash_function(password, salt, iterations)\nexcept CryptographyError as e:\n    logger.error(f\"Hash computation failed: {e}\")\n    raise HashComputationError(\"Cryptographic operation failed\") from e\n```\n\n**Timing-consistent error responses**:\n```python\n# Always return same error type regardless of failure reason\nif user_not_found or invalid_password or hash_corrupted:\n    return AuthenticationResult(success=False, message=\"Authentication failed\")\n```\n\n#### Milestone Checkpoints\n\n**After implementing registration flow**:\n- Run `python -m pytest tests/test_flows.py::test_registration_flow -v`\n- Expected: All registration tests pass including error handling scenarios\n- Manual verification: Register user with `curl -X POST http://localhost:8000/register -d '{\"username\": \"test\", \"password\": \"secure123\"}'`\n- Expected response: `{\"success\": true, \"algorithm\": \"bcrypt\"}` (or current default)\n- Check database contains hash record with proper structure and non-empty salt/hash fields\n\n**After implementing verification flow**:\n- Run `python -m pytest tests/test_flows.py::test_verification_flow -v` \n- Expected: Verification succeeds for correct passwords, fails for incorrect ones\n- Manual verification: Login with `curl -X POST http://localhost:8000/login -d '{\"username\": \"test\", \"password\": \"secure123\"}'`\n- Expected response: `{\"success\": true}` for correct password, `{\"success\": false}` for wrong password\n- Timing test: Verify similar response times for valid/invalid users and correct/incorrect passwords\n\n**After implementing timing attack resistance**:\n- Run `python -m pytest tests/test_timing_attacks.py -v`\n- Expected: Timing consistency tests pass with <5ms deviation between different scenarios\n- Use timing analysis script: `python scripts/analyze_timing.py --samples 1000`\n- Expected: No statistically significant timing differences between password verification scenarios\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---------|--------------|-----------------|-----|\n| Registration always fails | Parameter validation too strict | Check logs for `ParameterValidationError` | Review parameter minimums in configuration |\n| Verification fails for correct passwords | Salt/hash corruption during storage | Compare stored vs. computed hash in debugger | Check serialization/deserialization integrity |\n| Timing attack tests fail | Branching logic in comparison | Profile verification with different inputs | Use `secrets.compare_digest()` for all comparisons |\n| Migration never triggers | Assessment logic too conservative | Log migration assessment results | Adjust migration policies in configuration |\n| High verification latency | Hash parameters too aggressive | Benchmark individual algorithms | Reduce iteration counts or cost factors |\n| Memory usage growing | Hash records not garbage collected | Monitor object lifecycle | Ensure records released after processing |\n\n**Common debugging commands**:\n```bash\n# Enable debug logging for password operations\nexport PYTHONPATH=. && python -c \"import logging; logging.basicConfig(level=logging.DEBUG); from core.password_service import PasswordService; # your test code\"\n\n# Profile verification timing\npython -m cProfile -s cumulative scripts/benchmark_verification.py\n\n# Analyze timing attack resistance  \npython scripts/timing_analysis.py --algorithm bcrypt --samples 1000 --output timing_report.json\n\n```\n\n\n## Error Handling and Edge Cases\n\n> **Milestone(s):** All milestones (robust error handling is essential across all implementation phases)\n\n### Mental Model: The Airport Security Crisis Management System\n\nThink of error handling in password hashing like an airport security checkpoint's crisis management protocols. Just as airport security must handle everything from broken X-ray machines to suspicious packages to system-wide power outages, a password hashing system must gracefully handle invalid inputs, missing algorithms, corrupted data, and resource exhaustion. The key principle is the same: **maintain security even when things go wrong**. Airport security doesn't abandon all checks when one scanner breaks—they have backup procedures, manual verification protocols, and escalation paths that preserve safety. Similarly, password hashing error handling must ensure that security failures never degrade into vulnerability windows, and that legitimate users aren't locked out by transient technical problems.\n\nThe airport analogy extends further: just as security checkpoints validate passengers, baggage, and credentials according to strict protocols, password systems must validate every input parameter, configuration value, and algorithm availability before proceeding with cryptographic operations. When validation fails, the response must be both secure (no information leakage) and operational (clear guidance for resolution).\n\n### Input Validation\n\n**Input validation** in password hashing serves as the first line of defense against both accidental misuse and deliberate attacks. Unlike typical application validation that focuses on user experience, cryptographic input validation must prioritize **security invariants**—mathematical and operational requirements that, if violated, could compromise the entire security model.\n\nThe validation challenge operates on multiple levels simultaneously. At the data level, we must ensure that passwords, salts, and configuration parameters meet minimum security requirements. At the algorithm level, we must verify that chosen parameters actually provide the intended security properties. At the system level, we must confirm that required cryptographic primitives and entropy sources are available and functioning correctly.\n\n> **Decision: Fail-Fast Input Validation Architecture**\n> - **Context**: Input validation can occur early (before any cryptographic operations) or late (during algorithm execution), and can be strict (reject any questionable input) or permissive (accept reasonable variations)\n> - **Options Considered**: Early strict validation, late permissive validation, hybrid validation with warnings\n> - **Decision**: Early strict validation with detailed error messages for debugging\n> - **Rationale**: Cryptographic systems must be predictable and deterministic. Late failures during hashing operations can create timing side channels or partial state corruption. Strict validation prevents subtle security degradation from parameter drift over time.\n> - **Consequences**: Higher initial complexity but eliminates entire classes of runtime security failures. Clear error messages aid debugging without exposing sensitive information.\n\n| Validation Strategy | Pros | Cons | Security Impact |\n|---|---|---|---|\n| Early strict validation | Predictable failures, no partial state corruption, clear debugging | Higher upfront complexity | Eliminates timing side channels from validation |\n| Late permissive validation | Simple implementation, flexible parameter acceptance | Timing attacks possible, partial failures | Potential information leakage |\n| Hybrid with warnings | Balance flexibility and security | Complex error handling logic | Mixed security properties |\n\n#### Password Input Validation\n\nPassword validation must balance security requirements against usability concerns, while avoiding any validation logic that could leak information about stored passwords or system configuration. The core principle is **statistical validation**—ensuring the input has sufficient entropy and meets minimum security requirements without imposing arbitrary restrictions that reduce actual security.\n\nThe primary validation concerns for password inputs include **length boundaries** (both minimum and maximum), **character encoding validation** (ensuring consistent Unicode handling), and **entropy assessment** (detecting obviously weak patterns). However, password strength validation deliberately falls outside the scope of this hashing system to maintain **component separation** and avoid scope creep into policy enforcement.\n\n| Validation Check | Purpose | Implementation | Failure Behavior |\n|---|---|---|---|\n| Minimum length validation | Prevent trivially short passwords | Length check after UTF-8 decoding | `ValidationError` with minimum requirement |\n| Maximum length validation | Prevent DoS through excessive memory usage | Length check before processing | `ValidationError` with maximum limit |\n| Unicode normalization | Ensure consistent encoding across systems | Apply NFC normalization, validate success | `ValidationError` for invalid sequences |\n| Null byte detection | Prevent C-style string truncation | Scan for embedded null characters | `ValidationError` indicating unsafe content |\n\nThe `_validate_password_input` method implements these checks systematically:\n\n1. **UTF-8 decoding validation**: Attempt to decode the input as valid UTF-8, rejecting byte sequences that don't represent valid Unicode text\n2. **Unicode normalization**: Apply NFC (Canonical Decomposition followed by Canonical Composition) normalization to ensure consistent representation across different systems and input methods\n3. **Length boundary enforcement**: Check that the normalized password length falls within the acceptable range (typically 1-1024 characters for security and DoS prevention)\n4. **Embedded null detection**: Scan for null bytes that could cause truncation in C-based cryptographic libraries\n5. **Memory exhaustion prevention**: Ensure the password doesn't consume excessive memory during processing\n\n⚠️ **Pitfall: Information Leakage Through Validation Errors**\n\nA common mistake is providing validation error messages that leak information about password policies or system configuration. For example, returning \"Password too short, minimum length is 12 characters\" reveals the exact minimum length requirement to attackers. Instead, validation errors should provide enough information for legitimate debugging while avoiding disclosure of specific security parameters. The correct approach is to return generic validation failure indicators with detailed information logged securely for administrators.\n\n#### Algorithm Parameter Validation\n\nAlgorithm parameter validation ensures that cryptographic operations will provide the intended security properties. Unlike password validation, parameter validation must be **mathematically rigorous**—verifying that parameters fall within ranges that provide meaningful security guarantees.\n\nThe validation complexity varies significantly between algorithms. Basic SHA-256 hashing has minimal parameters (salt length), while PBKDF2 requires iteration count and key length validation, and Argon2 demands memory, time, and parallelism parameter coordination. Each algorithm's parameter validation must encode deep cryptographic knowledge about security-performance trade-offs.\n\n| Parameter Category | Validation Requirements | Failure Consequences | Detection Method |\n|---|---|---|---|\n| Salt length | Must meet minimum entropy requirements | Rainbow table vulnerability | Length check against `MINIMUM_SALT_LENGTH` |\n| Iteration count | Must exceed minimum for computational security | Brute force vulnerability | Comparison with `PBKDF2_MIN_ITERATIONS` |\n| Memory parameters | Must balance security and resource constraints | Memory-based attacks or DoS | Range checking with system limits |\n| Parallelism settings | Must align with available CPU resources | Suboptimal performance or failures | CPU detection and capability checking |\n\nThe `ParameterValidator` component centralizes this logic through a **constraint-based validation system**. Each algorithm registers its parameter constraints as **validation rules**, and the validator applies these rules systematically:\n\n1. **Range validation**: Numeric parameters must fall within minimum and maximum bounds that ensure security effectiveness\n2. **Relationship validation**: Some parameters have interdependencies (e.g., Argon2 memory must be at least 8 times the parallelism factor)\n3. **Resource feasibility validation**: Parameters must not exceed system capabilities (available memory, reasonable CPU utilization)\n4. **Security floor enforcement**: Parameters must meet current security recommendations, with warnings for parameters approaching obsolescence\n\n> The critical insight for parameter validation is that **security requirements evolve over time**. What constituted secure iteration counts in 2010 may be inadequate in 2024. The validation system must encode current security knowledge while supporting graceful parameter evolution.\n\n#### Configuration Parameter Validation\n\nConfiguration validation operates at the system level, ensuring that the password hashing system has access to all required resources and capabilities. Unlike input validation which handles external data, configuration validation manages **deployment-time dependencies** and **runtime resource availability**.\n\nThe primary configuration concerns include **algorithm availability** (ensuring required cryptographic libraries are present and functional), **entropy source validation** (confirming that random number generation works correctly), and **performance parameter validation** (verifying that configured parameters are achievable on the target system).\n\n| Configuration Area | Validation Checks | Failure Recovery | Monitoring Requirements |\n|---|---|---|---|\n| Algorithm availability | Library presence, version compatibility | Fallback to available algorithms | Algorithm capability discovery |\n| Entropy sources | Randomness quality, generation speed | Multiple entropy source fallback | Entropy pool monitoring |\n| Performance parameters | Benchmark against target hardware | Auto-tuning based on capabilities | Performance regression detection |\n| Storage configuration | Database connectivity, schema validation | Read-only mode for verification | Storage health monitoring |\n\nThe configuration validation process occurs in multiple phases:\n\n1. **Startup validation**: During system initialization, validate that all configured algorithms are available and functional through test operations\n2. **Runtime validation**: Periodically verify that entropy sources maintain adequate quality and generation speed\n3. **Parameter compatibility validation**: Ensure that configured parameters are achievable on the current hardware within reasonable time bounds\n4. **Dependency validation**: Confirm that required external libraries, databases, and services are accessible and responsive\n\n⚠️ **Pitfall: Silent Configuration Degradation**\n\nA subtle but dangerous error is allowing configuration validation to silently fall back to weaker security parameters when preferred options are unavailable. For example, if bcrypt is unavailable, silently falling back to plain SHA-256 creates a massive security degradation that may go unnoticed. The correct approach is **explicit degradation policies** where fallback behavior is consciously configured and monitored, with clear alerting when security-impacting fallbacks occur.\n\n### Graceful Degradation\n\n**Graceful degradation** in password hashing systems requires careful balance between **operational continuity** and **security preservation**. Unlike typical web applications where graceful degradation might mean showing cached content or reduced functionality, cryptographic systems must never degrade security properties to maintain availability. The challenge is defining **acceptable degradation paths** that preserve essential security while handling various failure modes.\n\nThe degradation strategy operates on the principle of **security-preserving fallbacks**. When preferred algorithms or parameters are unavailable, the system can fall back to alternative approaches that maintain equivalent security properties. However, certain failures—like entropy exhaustion or complete algorithm unavailability—require **fail-secure behavior** where the system refuses to operate rather than compromising security.\n\n> **Decision: Tiered Degradation with Security Floor**\n> - **Context**: System failures can range from minor (preferred algorithm unavailable) to severe (entropy exhaustion), requiring different response strategies\n> - **Options Considered**: Fail-fast (refuse all operations on any failure), Transparent fallback (automatic degradation), Explicit degradation (administrator-configured fallback policies)\n> - **Decision**: Explicit degradation with mandatory security floor enforcement\n> - **Rationale**: Cryptographic systems require predictable behavior. Transparent fallbacks can mask security degradation, while fail-fast approaches may be too rigid for operational environments. Explicit policies ensure conscious security decisions.\n> - **Consequences**: Requires upfront planning for failure modes but eliminates surprise security degradation. Clear audit trail for degraded operations.\n\n![Error Handling Decision Flow](./diagrams/error-handling-flow.svg)\n\n| Degradation Scenario | Security Impact | Acceptable Fallback | Unacceptable Fallback |\n|---|---|---|---|\n| Preferred algorithm unavailable | None if equivalent security | bcrypt → Argon2 or vice versa | bcrypt → SHA-256 |\n| Parameter tuning failure | Minimal if conservative defaults used | Use higher security parameters | Use lower security parameters |\n| Performance degradation | None if security maintained | Slower but secure operations | Faster but weaker operations |\n| Partial entropy exhaustion | Moderate if high-quality backup available | Hardware → Software entropy | Fast → Predictable generation |\n\n#### Handling Missing Algorithms\n\nAlgorithm unavailability can occur for several reasons: **missing libraries** (bcrypt or Argon2 not installed), **version incompatibilities** (library API changes), **platform limitations** (algorithm not supported on target architecture), or **configuration errors** (incorrect library paths or permissions). The degradation strategy must distinguish between **temporary unavailability** (which might resolve) and **permanent unavailability** (requiring alternative approaches).\n\nThe `AlgorithmRegistry` maintains **capability discovery** information, tracking which algorithms are available and functional. During system startup, it attempts to initialize each configured algorithm, recording both success and detailed failure information. This capability map drives **runtime algorithm selection** and **degradation decision-making**.\n\n| Algorithm Failure Type | Detection Method | Degradation Strategy | Recovery Approach |\n|---|---|---|---|\n| Library missing | Import/load failure during initialization | Use equivalent security algorithm | Install missing dependencies |\n| Version incompatibility | API call failure during test operations | Use compatible version or alternative | Update library versions |\n| Configuration error | Permission denied or path not found | Fix configuration or use embedded defaults | Correct system configuration |\n| Runtime failure | Intermittent algorithm failures during operation | Temporary fallback with alerting | Investigate underlying system issues |\n\nThe degradation process follows a **structured algorithm selection hierarchy**:\n\n1. **Primary algorithm selection**: Attempt to use the configured preferred algorithm for the security level\n2. **Equivalent algorithm fallback**: If primary fails, select an alternative algorithm with equivalent or higher security properties\n3. **Conservative algorithm fallback**: If equivalent algorithms fail, select a well-established algorithm with slightly different properties but adequate security\n4. **Emergency algorithm fallback**: If modern algorithms fail, fall back to PBKDF2 with high iteration counts as a security floor\n5. **Operation refusal**: If no algorithms meeting minimum security requirements are available, refuse to process passwords\n\nThe `get_migration_target` method implements this selection logic, consulting the **migration preferences list** to identify appropriate fallback algorithms. The preferences list encodes security relationships between algorithms, ensuring that fallbacks never represent security downgrades.\n\n⚠️ **Pitfall: Cascading Algorithm Failures**\n\nA dangerous scenario occurs when algorithm failures cascade—for example, when a system library update breaks multiple algorithm implementations simultaneously. Systems that assume \"at least one algorithm will work\" can fail catastrophically. The correct approach is **algorithm independence validation** during deployment, ensuring that algorithm failures are isolated and that sufficient fallback diversity exists.\n\n#### Handling Configuration Errors\n\nConfiguration errors in cryptographic systems can be particularly dangerous because they often **fail silently** or produce **misleading error messages**. Unlike application configuration errors that typically cause obvious functional failures, cryptographic configuration errors might result in subtle security degradation that passes functional testing but creates vulnerabilities.\n\nThe configuration error handling strategy focuses on **explicit validation** and **fail-secure defaults**. Rather than attempting to \"fix\" configuration errors automatically, the system provides detailed diagnostic information and refuses to operate with potentially insecure configurations.\n\n| Configuration Error Category | Common Causes | Detection Method | Recovery Strategy |\n|---|---|---|---|\n| Parameter out of range | Manual configuration, copy-paste errors | Validation during system initialization | Reject configuration with specific guidance |\n| Algorithm spelling errors | Typos in configuration files | String matching against known algorithms | Suggest closest match, require explicit correction |\n| Resource constraint violations | Misconfigured memory limits, CPU restrictions | Runtime capability testing | Auto-tune within constraints or fail with explanation |\n| Security policy conflicts | Conflicting minimum requirements | Cross-validation of policy constraints | Highlight conflicts, require resolution |\n\nThe configuration validation process implements **defensive validation** at multiple levels:\n\n1. **Syntax validation**: Ensure configuration files parse correctly and contain expected data types\n2. **Semantic validation**: Verify that configuration values make sense individually (positive numbers, valid algorithm names)\n3. **Constraint validation**: Check that configuration values satisfy security and resource constraints\n4. **Compatibility validation**: Ensure that different configuration sections work together coherently\n5. **Runtime validation**: Confirm that configuration works on the actual deployment environment\n\nThe `ValidationResult` structure provides **structured error reporting** that distinguishes between different severity levels. **Errors** represent configuration problems that prevent secure operation. **Warnings** indicate configuration choices that work but may not be optimal. This distinction allows administrators to make informed decisions about accepting suboptimal but functional configurations.\n\n> The key insight for configuration error handling is that **security misconfiguration is worse than no configuration**. A system that fails to start due to configuration errors is better than a system that runs with insecure parameters.\n\n#### Resource Exhaustion Handling\n\nResource exhaustion in password hashing systems can manifest as **entropy exhaustion** (insufficient randomness for salt generation), **memory exhaustion** (Argon2 parameters exceeding available RAM), **CPU exhaustion** (iteration counts causing unacceptable delays), or **storage exhaustion** (inability to persist hash records). Each type requires different **detection mechanisms** and **recovery strategies**.\n\n**Entropy exhaustion** represents the most critical resource failure because it directly compromises cryptographic security. The `SaltGenerator` must monitor entropy pool status and detect when randomness quality degrades. Modern operating systems provide entropy monitoring interfaces, but the interpretation requires careful analysis of **entropy consumption patterns** and **regeneration rates**.\n\n| Resource Type | Exhaustion Symptoms | Detection Method | Recovery Strategy |\n|---|---|---|---|\n| Entropy | Slow random generation, repeated values | Entropy pool monitoring, statistical testing | Block operations until entropy recovers |\n| Memory | Algorithm failures, system swapping | Memory usage monitoring, allocation testing | Reduce parameters or queue operations |\n| CPU | Excessive hash computation time | Timing measurements, load monitoring | Reduce iteration counts or throttle requests |\n| Storage | Hash record persistence failures | Database monitoring, disk space checks | Cleanup old records or switch to read-only |\n\nThe resource exhaustion handling implements **backpressure mechanisms** that prevent system overload while maintaining security properties:\n\n1. **Entropy backpressure**: When entropy quality drops below acceptable thresholds, block new salt generation until quality recovers\n2. **Memory backpressure**: When memory usage approaches system limits, queue hash operations or reduce algorithm parameters\n3. **CPU backpressure**: When hash computation times exceed thresholds, reduce iteration counts or implement request queuing\n4. **Storage backpressure**: When storage systems approach capacity, implement cleanup policies or switch to verification-only mode\n\nThe `EntropyExhaustionError` exception provides **detailed diagnostic information** about entropy status, including current pool levels, consumption rates, and estimated recovery times. This information enables **intelligent retry strategies** that wait for appropriate recovery periods rather than immediately retrying and further exhausting resources.\n\n⚠️ **Pitfall: Resource Exhaustion Attacks**\n\nMalicious actors can deliberately trigger resource exhaustion through **algorithmic complexity attacks**—submitting requests with parameters that consume excessive resources. For example, requesting password hashes with extremely high iteration counts can cause CPU exhaustion. The correct defense is **resource budgeting** where each operation consumes from a limited resource pool, preventing any single request from exhausting system resources.\n\n### Implementation Guidance\n\nThis error handling implementation provides comprehensive input validation, configuration management, and graceful degradation capabilities that maintain security properties even during failure conditions.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option |\n|---|---|---|\n| Input Validation | Built-in type checking + manual validation | Schema validation library (e.g., Pydantic, marshmallow) |\n| Error Reporting | Standard exceptions with string messages | Structured error objects with error codes and context |\n| Configuration Management | JSON/YAML files with manual parsing | Configuration management framework (e.g., Dynaconf, python-decouple) |\n| Resource Monitoring | Basic system calls for memory/CPU | Full monitoring integration (e.g., psutil, prometheus client) |\n| Logging | Standard logging module | Structured logging with correlation IDs (e.g., structlog) |\n\n#### Recommended File Structure\n\n```\npassword_hashing/\n├── exceptions/\n│   ├── __init__.py              ← Export all exception classes\n│   ├── base.py                  ← PasswordHashingError base class\n│   ├── validation.py            ← ValidationError, ParameterValidationError\n│   ├── salt.py                  ← SaltGenerationError, EntropyExhaustionError\n│   ├── hashing.py               ← HashComputationError, AlgorithmUnavailableError\n│   └── iteration.py             ← IterationCountError, DerivationLengthError\n├── validation/\n│   ├── __init__.py              ← Export validation components\n│   ├── parameters.py            ← ParameterValidator class\n│   ├── inputs.py                ← Password and salt input validation\n│   ├── config.py                ← Configuration validation\n│   └── resources.py             ← Resource availability validation\n├── config/\n│   ├── __init__.py              ← Configuration management\n│   ├── defaults.py              ← Default parameters and constraints\n│   ├── validation_rules.py      ← Parameter validation rules by algorithm\n│   └── degradation_policies.py  ← Graceful degradation configuration\n└── monitoring/\n    ├── __init__.py              ← Resource monitoring components\n    ├── entropy.py               ← Entropy pool monitoring\n    ├── performance.py           ← CPU and memory monitoring\n    └── storage.py               ← Storage capacity monitoring\n```\n\n#### Exception Hierarchy Infrastructure\n\n```python\n\"\"\"\nBase exception classes for password hashing system.\nProvides structured error reporting with context preservation.\n\"\"\"\n\nimport traceback\nfrom datetime import datetime\nfrom typing import Any, Dict, List, Optional\n\n\nclass PasswordHashingError(Exception):\n    \"\"\"\n    Base exception for all password hashing errors.\n    Provides structured error reporting with context preservation.\n    \"\"\"\n    \n    def __init__(\n        self, \n        message: str, \n        error_code: str = None,\n        context: Dict[str, Any] = None,\n        cause: Exception = None\n    ):\n        super().__init__(message)\n        self.message = message\n        self.error_code = error_code or self.__class__.__name__\n        self.context = context or {}\n        self.cause = cause\n        self.timestamp = datetime.utcnow()\n        self.stack_trace = traceback.format_stack()\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert exception to dictionary for logging/serialization.\"\"\"\n        return {\n            'error_type': self.__class__.__name__,\n            'error_code': self.error_code,\n            'message': self.message,\n            'context': self.context,\n            'timestamp': self.timestamp.isoformat(),\n            'cause': str(self.cause) if self.cause else None\n        }\n\n\nclass ValidationError(PasswordHashingError):\n    \"\"\"Password or parameter validation failed.\"\"\"\n    \n    def __init__(self, parameter_name: str, value: Any, constraint: str, **kwargs):\n        self.parameter_name = parameter_name\n        self.value = value\n        self.constraint = constraint\n        \n        message = f\"Validation failed for {parameter_name}: {constraint}\"\n        context = {\n            'parameter_name': parameter_name,\n            'invalid_value': str(value),\n            'constraint': constraint\n        }\n        super().__init__(message, context=context, **kwargs)\n\n\nclass ParameterValidationError(ValidationError):\n    \"\"\"Algorithm parameter validation failed.\"\"\"\n    pass\n\n\nclass SaltGenerationError(PasswordHashingError):\n    \"\"\"Salt generation failed.\"\"\"\n    pass\n\n\nclass EntropyExhaustionError(SaltGenerationError):\n    \"\"\"Insufficient entropy for secure salt generation.\"\"\"\n    \n    def __init__(self, available_entropy: int, required_entropy: int, **kwargs):\n        self.available_entropy = available_entropy\n        self.required_entropy = required_entropy\n        \n        message = f\"Insufficient entropy: {available_entropy} available, {required_entropy} required\"\n        context = {\n            'available_entropy': available_entropy,\n            'required_entropy': required_entropy,\n            'entropy_deficit': required_entropy - available_entropy\n        }\n        super().__init__(message, context=context, **kwargs)\n\n\nclass HashComputationError(PasswordHashingError):\n    \"\"\"Hash computation failed.\"\"\"\n    pass\n\n\nclass IterationCountError(PasswordHashingError):\n    \"\"\"Invalid iteration count for key stretching.\"\"\"\n    \n    def __init__(self, count: int, minimum_required: int, **kwargs):\n        self.count = count\n        self.minimum_required = minimum_required\n        \n        message = f\"Iteration count {count} below minimum {minimum_required}\"\n        context = {\n            'provided_count': count,\n            'minimum_required': minimum_required\n        }\n        super().__init__(message, context=context, **kwargs)\n\n\nclass DerivationLengthError(PasswordHashingError):\n    \"\"\"Invalid key derivation length.\"\"\"\n    \n    def __init__(self, length: int, maximum_allowed: int, **kwargs):\n        self.length = length\n        self.maximum_allowed = maximum_allowed\n        \n        message = f\"Derivation length {length} exceeds maximum {maximum_allowed}\"\n        context = {\n            'requested_length': length,\n            'maximum_allowed': maximum_allowed\n        }\n        super().__init__(message, context=context, **kwargs)\n```\n\n#### Input Validation Implementation\n\n```python\n\"\"\"\nInput validation for passwords and cryptographic parameters.\nImplements security-focused validation with detailed error reporting.\n\"\"\"\n\nimport re\nimport unicodedata\nfrom typing import Any, Dict, List\nfrom .exceptions import ValidationError, ParameterValidationError\n\n# Security constants\nMINIMUM_SALT_LENGTH = 16\nMAXIMUM_SALT_LENGTH = 64\nRECOMMENDED_SALT_LENGTH = 32\nPBKDF2_MIN_ITERATIONS = 100000\nBCRYPT_MIN_COST = 12\n\nclass ValidationResult:\n    \"\"\"Result of parameter validation with errors and warnings.\"\"\"\n    \n    def __init__(self):\n        self.is_valid = True\n        self.errors: List[str] = []\n        self.warnings: List[str] = []\n    \n    def add_error(self, error: str):\n        \"\"\"Add validation error.\"\"\"\n        self.errors.append(error)\n        self.is_valid = False\n    \n    def add_warning(self, warning: str):\n        \"\"\"Add validation warning.\"\"\"\n        self.warnings.append(warning)\n\n\nclass ParameterValidator:\n    \"\"\"Validates algorithm parameters against security constraints.\"\"\"\n    \n    def __init__(self):\n        # TODO: Load validation rules from configuration\n        # TODO: Initialize constraint definitions for each algorithm\n        # TODO: Set up parameter relationship validation rules\n        pass\n    \n    def validate_parameters(self, algorithm: str, parameters: Dict[str, Any]) -> ValidationResult:\n        \"\"\"\n        Validate algorithm parameters meet security requirements.\n        \n        Args:\n            algorithm: Algorithm name (e.g., 'pbkdf2', 'bcrypt', 'argon2')\n            parameters: Parameter dictionary to validate\n            \n        Returns:\n            ValidationResult with errors and warnings\n        \"\"\"\n        result = ValidationResult()\n        \n        # TODO: Look up validation rules for specified algorithm\n        # TODO: Apply range validation for numeric parameters  \n        # TODO: Check parameter relationships and dependencies\n        # TODO: Validate resource feasibility (memory, CPU constraints)\n        # TODO: Check security floor requirements for current year\n        # TODO: Add warnings for parameters approaching obsolescence\n        \n        return result\n    \n    def validate_salt_length(self, length: int) -> ValidationResult:\n        \"\"\"Validate salt length meets security requirements.\"\"\"\n        result = ValidationResult()\n        \n        # TODO: Check minimum salt length for rainbow table resistance\n        # TODO: Check maximum salt length for DoS prevention\n        # TODO: Add warning if length is below recommended value\n        # TODO: Validate length is appropriate for available entropy\n        \n        return result\n    \n    def validate_iteration_count(self, count: int) -> bool:\n        \"\"\"Validate PBKDF2 iteration count meets security requirements.\"\"\"\n        # TODO: Check against current minimum iteration requirements\n        # TODO: Consider current hardware capabilities and attack costs\n        # TODO: Validate count doesn't cause DoS through excessive CPU usage\n        # TODO: Return detailed validation result with recommendations\n        return count >= PBKDF2_MIN_ITERATIONS\n\n\ndef _validate_password_input(password: bytes) -> None:\n    \"\"\"\n    Validate password input meets security and encoding requirements.\n    \n    Args:\n        password: Raw password bytes to validate\n        \n    Raises:\n        ValidationError: If password fails validation checks\n    \"\"\"\n    # TODO: Validate password is valid UTF-8\n    # TODO: Apply Unicode normalization (NFC)\n    # TODO: Check length boundaries (minimum 1, maximum 1024 characters)\n    # TODO: Detect embedded null bytes that could cause truncation\n    # TODO: Validate password doesn't exceed memory limits during processing\n    \n    # Example validation structure:\n    try:\n        password_str = password.decode('utf-8')\n    except UnicodeDecodeError:\n        raise ValidationError(\n            parameter_name='password',\n            value='<binary data>',\n            constraint='Must be valid UTF-8 text'\n        )\n    \n    # Additional validation steps would go here\n    pass\n```\n\n#### Configuration Management Implementation\n\n```python\n\"\"\"\nConfiguration validation and management for password hashing system.\nHandles algorithm availability, parameter constraints, and degradation policies.\n\"\"\"\n\nimport os\nimport json\nfrom typing import Dict, Any, List, Optional\nfrom .exceptions import ValidationError, PasswordHashingError\n\nclass AlgorithmRegistry:\n    \"\"\"Registry of available password hashing algorithms with capability detection.\"\"\"\n    \n    def __init__(self):\n        self._algorithms: Dict[str, Any] = {}\n        self._default_algorithm = 'bcrypt'\n        self._migration_preferences = ['argon2id', 'bcrypt', 'pbkdf2']\n        \n        # TODO: Initialize algorithm capability detection\n        # TODO: Test each algorithm during startup\n        # TODO: Record detailed failure information for diagnostics\n    \n    def register_algorithm(self, name: str, algorithm_class: Any) -> None:\n        \"\"\"Register algorithm implementation with capability testing.\"\"\"\n        # TODO: Instantiate algorithm class and test basic operations\n        # TODO: Record algorithm capabilities and limitations\n        # TODO: Update migration preference order if needed\n        pass\n    \n    def get_algorithm(self, name: str) -> Any:\n        \"\"\"Retrieve algorithm implementation by name.\"\"\"\n        # TODO: Return algorithm if available\n        # TODO: Raise specific exception if algorithm unavailable\n        # TODO: Provide suggestion for available alternatives\n        if name not in self._algorithms:\n            available = list(self._algorithms.keys())\n            raise ValidationError(\n                parameter_name='algorithm',\n                value=name,\n                constraint=f'Must be one of: {available}'\n            )\n        return self._algorithms[name]\n    \n    def get_migration_target(self, current_algorithm: str) -> str:\n        \"\"\"Determine appropriate migration target for current algorithm.\"\"\"\n        # TODO: Consult migration preference order\n        # TODO: Skip unavailable algorithms  \n        # TODO: Ensure migration target has equivalent or better security\n        # TODO: Return best available algorithm or raise exception if none suitable\n        pass\n\n\nclass ConfigurationValidator:\n    \"\"\"Validates system configuration for security and operational requirements.\"\"\"\n    \n    def validate_system_configuration(self) -> ValidationResult:\n        \"\"\"Validate complete system configuration.\"\"\"\n        result = ValidationResult()\n        \n        # TODO: Validate entropy source availability and quality\n        # TODO: Check algorithm library availability and versions\n        # TODO: Validate resource constraints (memory, CPU limits)\n        # TODO: Check storage configuration and connectivity\n        # TODO: Validate security parameter consistency across algorithms\n        \n        return result\n    \n    def validate_entropy_sources(self) -> ValidationResult:\n        \"\"\"Validate random number generation capabilities.\"\"\"\n        result = ValidationResult()\n        \n        # TODO: Test entropy source quality using statistical tests\n        # TODO: Measure entropy generation speed\n        # TODO: Validate multiple entropy sources for redundancy\n        # TODO: Check entropy pool monitoring capabilities\n        \n        return result\n    \n    def validate_algorithm_availability(self) -> ValidationResult:\n        \"\"\"Test all configured algorithms for availability and correctness.\"\"\"\n        result = ValidationResult()\n        \n        # TODO: Attempt to load each configured algorithm library\n        # TODO: Run test hash operations to verify functionality\n        # TODO: Check algorithm parameter ranges and constraints\n        # TODO: Validate algorithm version compatibility\n        \n        return result\n```\n\n#### Graceful Degradation Implementation\n\n```python\n\"\"\"\nGraceful degradation handling for password hashing system failures.\nImplements security-preserving fallback strategies.\n\"\"\"\n\nfrom typing import Dict, Any, Optional, List\nfrom .exceptions import PasswordHashingError, EntropyExhaustionError\n\nclass DegradationManager:\n    \"\"\"Manages graceful degradation policies and fallback strategies.\"\"\"\n    \n    def __init__(self, registry: 'AlgorithmRegistry'):\n        self.registry = registry\n        self.degradation_policies: Dict[str, Dict] = {}\n        self.security_floor_algorithms = ['pbkdf2']  # Last resort algorithms\n        \n        # TODO: Load degradation policies from configuration\n        # TODO: Initialize fallback algorithm hierarchies\n        # TODO: Set up resource monitoring for degradation triggers\n    \n    def handle_algorithm_unavailable(self, requested_algorithm: str) -> str:\n        \"\"\"Handle algorithm unavailability with security-preserving fallback.\"\"\"\n        # TODO: Consult degradation policy for requested algorithm\n        # TODO: Find equivalent-security alternative from available algorithms\n        # TODO: Log degradation event for monitoring and alerting\n        # TODO: Raise exception if no acceptable alternative exists\n        \n        fallback = self.registry.get_migration_target(requested_algorithm)\n        if not fallback:\n            raise PasswordHashingError(\n                f\"No acceptable fallback for unavailable algorithm: {requested_algorithm}\",\n                error_code=\"ALGORITHM_UNAVAILABLE\",\n                context={'requested_algorithm': requested_algorithm}\n            )\n        return fallback\n    \n    def handle_resource_exhaustion(self, resource_type: str, current_usage: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Handle resource exhaustion with appropriate backpressure.\"\"\"\n        # TODO: Implement resource-specific backpressure strategies\n        # TODO: Calculate safe parameter reductions that maintain security\n        # TODO: Implement request queuing for temporary resource constraints\n        # TODO: Return degraded parameters or raise exception for permanent exhaustion\n        \n        if resource_type == 'entropy':\n            # Block operations until entropy recovers\n            raise EntropyExhaustionError(\n                available_entropy=current_usage.get('available', 0),\n                required_entropy=current_usage.get('required', 0)\n            )\n        \n        # Return degraded parameters for other resource types\n        return {}\n    \n    def assess_degradation_impact(self, original_params: Dict, degraded_params: Dict) -> Dict[str, Any]:\n        \"\"\"Assess security impact of parameter degradation.\"\"\"\n        # TODO: Compare security properties between original and degraded parameters\n        # TODO: Calculate attack cost differences\n        # TODO: Determine if degradation is acceptable within policy limits\n        # TODO: Generate detailed impact report for logging and monitoring\n        \n        return {\n            'security_impact': 'minimal',  # Placeholder\n            'acceptable': True,\n            'recommendations': []\n        }\n```\n\n#### Milestone Checkpoints\n\n**After implementing input validation:**\n- Run `python -m pytest tests/test_validation.py -v` to verify parameter validation\n- Test password validation with various Unicode inputs: `python -c \"from password_hashing.validation import _validate_password_input; _validate_password_input('测试密码'.encode('utf-8'))\"`\n- Verify validation rejects dangerous inputs: null bytes, oversized parameters, invalid algorithm names\n- Expected behavior: Clear validation errors with specific constraint information, no silent failures\n\n**After implementing configuration management:**\n- Run algorithm availability detection: `python -c \"from password_hashing.config import AlgorithmRegistry; r = AlgorithmRegistry(); print(r.get_available_algorithms())\"`\n- Test configuration validation: `python -m pytest tests/test_config.py::test_configuration_validation -v`\n- Verify entropy source validation works: Check that entropy exhaustion is detected and reported\n- Expected behavior: Clear reporting of available algorithms, detailed error messages for missing dependencies\n\n**After implementing graceful degradation:**\n- Test algorithm fallback: Disable bcrypt library and verify system falls back to Argon2 or PBKDF2\n- Test resource exhaustion handling: Simulate low memory conditions and verify appropriate parameter reduction\n- Run degradation impact assessment: `python -m pytest tests/test_degradation.py::test_security_impact -v`\n- Expected behavior: Security-preserving fallbacks, clear degradation impact reporting, no silent security downgrades\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | How to Diagnose | Fix |\n|---|---|---|\n| Validation passes but hashing fails | Parameter validation incomplete | Check if algorithm-specific constraints are enforced | Add missing parameter range checks |\n| Silent security degradation | Missing degradation impact assessment | Log all parameter changes and algorithm selections | Implement mandatory degradation reporting |\n| Intermittent entropy errors | Entropy pool exhaustion under load | Monitor `/proc/sys/kernel/random/entropy_avail` on Linux | Implement entropy backpressure and rate limiting |\n| Configuration errors ignored | Exception handling too permissive | Check exception catching in configuration loading | Make configuration validation strict and fail-fast |\n| Algorithm fallback loops | Circular dependencies in migration preferences | Trace algorithm selection logic with detailed logging | Fix migration preference ordering |\n| Resource exhaustion not detected | Missing resource monitoring | Add resource usage logging before operations | Implement proactive resource monitoring |\n\n\n## Testing Strategy\n\n> **Milestone(s):** All milestones (testing strategies evolve across implementation phases from basic salt/hash verification through key stretching validation to modern algorithm compatibility testing)\n\n### Mental Model: The Nuclear Power Plant Safety Testing System\n\nThink of testing a password hashing system like the comprehensive safety testing protocols at a nuclear power plant. Just as a nuclear facility has multiple independent safety systems that must all work perfectly together—radiation detection, cooling systems, containment barriers, emergency shutdown procedures—a password hashing system has multiple security properties that must be rigorously verified. \n\nIn a nuclear plant, you don't just test that the reactor produces power; you test that the cooling system works under extreme load, that radiation containment holds under pressure, that emergency systems activate within precise time windows, and that backup systems seamlessly take over during failures. Each system has its own specialized test protocols, but they're also tested together to ensure the entire facility operates safely under all conditions.\n\nSimilarly, password hashing isn't just about producing a hash value—you must verify that salts are truly random and unique, that timing attacks are impossible, that computational costs meet security requirements, that algorithm migrations preserve security, and that the entire system degrades gracefully under failure conditions. Each component has specialized security tests, but integration testing ensures the complete system maintains cryptographic security properties under all operational scenarios.\n\nThe stakes in both domains are similarly high: a nuclear safety failure can have catastrophic consequences, and a password security failure can compromise thousands of user accounts. This is why both require exhaustive, methodical testing that covers not just normal operation but also adversarial conditions, edge cases, and failure modes.\n\n### Security Test Cases\n\nSecurity testing for password hashing systems requires fundamentally different approaches than functional testing. While functional tests verify that methods return expected outputs, security tests must verify that the system resists specific attack vectors and maintains cryptographic properties that are mathematically measurable but not always intuitively obvious.\n\nThe core challenge is that security properties are often defined by what doesn't happen rather than what does happen. For example, timing attack resistance means that execution time doesn't vary based on input content, and cryptographic randomness means that generated values don't exhibit statistical patterns that could be exploited by attackers.\n\n#### Cryptographic Randomness Verification\n\nSalt generation represents the foundation of password hashing security, making randomness testing the most critical security verification. True cryptographic randomness is not just \"hard to predict\"—it must be mathematically indistinguishable from pure randomness even to an adversary with significant computational resources.\n\nThe **birthday paradox** becomes the primary mathematical tool for randomness verification. For a truly random salt generator producing n-byte salts, the probability of generating duplicate salts follows predictable mathematical distributions. By generating large samples of salts and analyzing collision patterns, we can statistically verify that the generator exhibits true randomness properties.\n\n| Test Category | Test Method | Expected Behavior | Security Property Verified |\n|---------------|-------------|-------------------|----------------------------|\n| Salt Uniqueness | Generate 1,000,000 salts, verify zero duplicates | Zero collisions with high probability | Birthday paradox resistance |\n| Entropy Distribution | Chi-square test on salt byte distribution | Uniform distribution across all possible values | No statistical bias |\n| Sequential Independence | Autocorrelation analysis between consecutive salts | No detectable patterns | Generator state unpredictability |\n| Bit Independence | Hamming distance analysis between adjacent salts | Average 50% bit differences | Individual bit independence |\n| Entropy Pool Depletion | Generate salts after entropy exhaustion simulation | Graceful failure or secure blocking | Entropy exhaustion handling |\n\nThe `SecurityGoalVerifier` implements these statistical tests using established cryptographic testing methodologies:\n\n| Method | Parameters | Returns | Security Property |\n|--------|------------|---------|-------------------|\n| `verify_salt_uniqueness(password_count, sample_size)` | count: int, samples: int | dict with collision analysis | Birthday paradox resistance |\n| `verify_entropy_distribution(salt_list)` | salts: List[bytes] | dict with chi-square results | Uniform distribution |\n| `verify_sequential_independence(salt_list)` | salts: List[bytes] | dict with correlation coefficients | Pattern absence |\n| `analyze_hamming_distances(salt_pairs)` | pairs: List[Tuple[bytes, bytes]] | dict with distance distribution | Bit independence |\n\n> **Critical Security Insight**: Cryptographic randomness testing requires large sample sizes to achieve statistical significance. Testing with only dozens or hundreds of samples can miss subtle biases that become exploitable at scale.\n\n#### Timing Attack Resistance Verification\n\nTiming attacks represent one of the most insidious security vulnerabilities because they exploit computational side effects that are invisible during normal testing. An attacker measures minute variations in execution time to infer information about internal processing, potentially recovering passwords or detecting valid usernames.\n\nThe fundamental principle of timing attack resistance is **constant-time execution**—the computational path through password verification must take identical time regardless of whether the password is correct, incorrect, or the username exists. This requires careful analysis of every conditional branch, memory access pattern, and computational operation.\n\n| Attack Vector | Vulnerability | Test Method | Mitigation Verification |\n|---------------|---------------|-------------|-------------------------|\n| Password Verification | Early termination on mismatch | Measure verification time variance | Constant-time comparison |\n| Username Enumeration | Different paths for valid/invalid users | Compare timing for existing vs. non-existent users | Dummy computation execution |\n| Salt Length Inference | Processing time varies with salt length | Test multiple salt lengths | Consistent processing time |\n| Hash Algorithm Detection | Different algorithms have timing signatures | Compare timing across algorithms | Algorithm-agnostic timing |\n| Memory Access Patterns | Cache timing variations | Cache timing analysis | Cache-independent operations |\n\nThe `TimingSecurity` component provides specialized testing methods for timing attack resistance:\n\n| Method | Parameters | Returns | Security Analysis |\n|--------|------------|---------|-------------------|\n| `verify_timing_consistency(func, test_cases, tolerance_ms)` | function, inputs, threshold | timing analysis | Execution time variance |\n| `measure_verification_timing(username_list, password_list)` | users, passwords | timing distribution | Authentication timing patterns |\n| `detect_early_termination(comparison_func, input_pairs)` | comparator, test data | termination analysis | Comparison function behavior |\n| `analyze_cache_timing(operation_func, memory_patterns)` | operation, patterns | cache behavior | Memory access consistency |\n\n> **Decision: Timing Attack Prevention Strategy**\n> - **Context**: Timing attacks can exploit microsecond differences in execution time to infer sensitive information\n> - **Options Considered**: \n>   1. Ignore timing attacks (assume network latency masks differences)\n>   2. Add random delays to mask timing differences  \n>   3. Implement guaranteed constant-time operations\n> - **Decision**: Implement constant-time operations with guaranteed minimum execution time\n> - **Rationale**: Random delays can be statistically analyzed away by persistent attackers, while constant-time operations provide mathematical guarantees\n> - **Consequences**: Requires careful implementation but provides the strongest timing attack resistance\n\n#### Algorithm Security Property Verification\n\nDifferent password hashing algorithms provide different security properties, and testing must verify that each algorithm meets its security claims. This goes beyond functional correctness to verify computational hardness, memory requirements, and resistance to specialized attacks.\n\nFor **bcrypt** testing, the primary security property is computational cost scaling. The work factor parameter should exponentially increase computation time, making brute force attacks proportionally more expensive. Testing must verify this exponential relationship and ensure that cost factors are appropriately calibrated for current hardware.\n\nFor **Argon2** testing, memory hardness becomes the critical property. The algorithm should require substantial memory resources that cannot be traded off for computational resources, making attacks using specialized hardware (like ASICs) economically infeasible.\n\n| Algorithm | Security Property | Test Method | Expected Behavior |\n|-----------|-------------------|-------------|-------------------|\n| bcrypt | Exponential cost scaling | Time cost factors 10, 11, 12, 13 | Each increment roughly doubles time |\n| bcrypt | Salt integration | Generate multiple hashes of same password | Different outputs with different salts |\n| Argon2id | Memory hardness | Monitor memory usage during hashing | Memory usage matches parameters |\n| Argon2id | Time-memory trade-off resistance | Attempt reduced memory computation | Failure or severe performance penalty |\n| PBKDF2 | Iteration scaling | Test iteration counts 100K, 200K, 500K | Linear time scaling with iterations |\n| SHA-256 | Collision resistance | Hash identical inputs with different salts | Different outputs verify salt integration |\n\nThe `PerformanceGoalTuner` provides specialized benchmarking for security property verification:\n\n| Method | Parameters | Returns | Security Verification |\n|--------|------------|---------|----------------------|\n| `benchmark_cost_scaling(algorithm, cost_range)` | algo, costs | scaling analysis | Exponential cost verification |\n| `measure_memory_hardness(algorithm, memory_params)` | algo, params | memory usage profile | Memory requirement enforcement |\n| `verify_iteration_scaling(iterations_list)` | iteration counts | time scaling analysis | Linear iteration cost |\n| `analyze_salt_integration(password, salt_count)` | password, salts | output diversity analysis | Salt uniqueness verification |\n\n#### Migration Security Testing\n\nAlgorithm migration introduces unique security challenges because the system must maintain security while transitioning between different cryptographic approaches. Migration testing must verify that security never degrades during transitions and that legacy hash formats don't become attack vectors.\n\n**Lazy migration** testing is particularly critical because migration occurs during live authentication attempts. The system must upgrade password hashes without compromising ongoing security, while ensuring that failed migrations don't create denial-of-service vulnerabilities.\n\n| Migration Scenario | Security Risk | Test Method | Verification Criteria |\n|---------------------|---------------|-------------|----------------------|\n| Algorithm Upgrade | Temporary security reduction | Test security during migration | No security degradation |\n| Legacy Hash Support | Weak algorithms remain vulnerable | Analyze legacy hash strength | Clear migration timelines |\n| Migration Failure | System falls back to weak security | Simulate migration failures | Secure failure handling |\n| Concurrent Migration | Race conditions during updates | Multi-threaded migration testing | Atomic migration operations |\n| Migration Rollback | Previous hash becomes invalid | Test rollback scenarios | Reversible migration process |\n\n### Milestone Checkpoints\n\nMilestone checkpoints provide concrete verification criteria for each implementation phase. Unlike functional testing that verifies correct outputs, security milestone testing verifies that implementations resist specific attacks and maintain cryptographic properties under adversarial conditions.\n\nEach checkpoint includes both automated security tests and manual security verification procedures. The automated tests verify measurable security properties, while manual procedures verify implementation details that could introduce subtle security vulnerabilities.\n\n#### Milestone 1: Basic Hashing with Salt Checkpoint\n\nThe fundamental security properties established in Milestone 1 form the foundation for all subsequent security features. Salt uniqueness and timing attack resistance must be mathematically verifiable before proceeding to more advanced algorithms.\n\n**Automated Security Verification**\n\nThe `SecurityGoalVerifier` provides comprehensive automated testing for Milestone 1 security properties:\n\n```python\n# Example automated security verification (not implementation)\ndef verify_milestone_1_security():\n    # Salt uniqueness verification\n    salt_results = verify_salt_uniqueness(password_count=10000, sample_size=100000)\n    assert salt_results['collision_count'] == 0, \"Salt generation must be collision-free\"\n    \n    # Timing attack resistance\n    timing_results = verify_timing_attack_resistance(username=\"testuser\")\n    assert timing_results['timing_variance'] < 0.1, \"Timing variance must be minimal\"\n    \n    # Hash determinism verification\n    hash_results = verify_hash_determinism(password=\"test\", iterations=1000)\n    assert hash_results['consistency'] == True, \"Same inputs must produce same outputs\"\n```\n\n| Security Property | Automated Test | Success Criteria | Failure Investigation |\n|-------------------|----------------|------------------|----------------------|\n| Salt Uniqueness | Generate 100,000 salts | Zero collisions | Check random number generator |\n| Salt Length | Validate salt length compliance | All salts ≥ 16 bytes | Verify length configuration |\n| Timing Consistency | Measure verification timing variance | Variance < 100 microseconds | Profile comparison functions |\n| Hash Determinism | Hash same input multiple times | Identical outputs | Check salt handling |\n| Input Validation | Test invalid inputs | Graceful error handling | Review validation logic |\n\n**Manual Security Verification Procedures**\n\nManual verification focuses on implementation details that automated tests cannot easily detect but that could introduce critical security vulnerabilities.\n\n1. **Salt Storage Verification**: Manually inspect stored password records to verify that salts are stored alongside hashes and are different for identical passwords.\n\n2. **Comparison Function Analysis**: Examine the password comparison implementation to verify that it uses constant-time comparison and doesn't exit early on mismatches.\n\n3. **Error Message Analysis**: Verify that error messages don't leak information about salt generation failures, hash computation errors, or validation failures.\n\n4. **Memory Handling Review**: Check that password and salt values are properly cleared from memory after use and don't persist in swap files or core dumps.\n\n> **Milestone 1 Security Checkpoint Summary**: The system must demonstrate cryptographically secure salt generation, timing attack resistance, and deterministic hash computation. These properties form the security foundation for all advanced features.\n\n#### Milestone 2: Key Stretching Checkpoint\n\nKey stretching introduces computational hardness as a security property, requiring verification that iteration counts provide meaningful protection against brute force attacks while maintaining reasonable authentication performance.\n\n**PBKDF2 Security Property Verification**\n\nKey stretching security depends on the mathematical relationship between iteration count and computation time. Testing must verify that this relationship holds under various conditions and that iteration counts are properly calibrated for security requirements.\n\n| Security Property | Verification Method | Expected Behavior | Security Implication |\n|-------------------|--------------------|--------------------|----------------------|\n| Iteration Scaling | Time iterations 100K, 200K, 500K | Linear time scaling | Predictable brute force cost |\n| Minimum Iterations | Enforce iteration minimums | Reject < 100,000 iterations | Prevent weak configurations |\n| Parameter Storage | Verify iteration count storage | Parameters stored with hash | Enable verification |\n| Backward Compatibility | Test old iteration counts | Support legacy parameters | Enable migration |\n| Performance Tuning | Benchmark target times | Meet performance requirements | Balance security and usability |\n\n**Automated Key Stretching Testing**\n\nThe `KeyStretchingHasher` component includes specialized testing methods for iteration-based security verification:\n\n| Test Method | Purpose | Success Criteria | Investigation Steps |\n|-------------|---------|------------------|-------------------|\n| `benchmark_iterations(target_time_ms)` | Performance calibration | Meet target timing | Adjust iteration count |\n| `verify_iteration_enforcement(count)` | Minimum iteration validation | Reject weak counts | Check validation logic |\n| `test_parameter_persistence(hash_record)` | Parameter storage verification | Iterations stored correctly | Verify serialization |\n| `analyze_computation_scaling(iteration_range)` | Scaling relationship verification | Linear scaling observed | Profile PBKDF2 implementation |\n\n**Manual Key Stretching Verification**\n\n1. **Iteration Count Inspection**: Manually verify that stored hash records contain iteration count parameters and that these parameters are used during verification.\n\n2. **Performance Impact Analysis**: Measure authentication performance with different iteration counts to verify that security tuning doesn't create denial-of-service vulnerabilities.\n\n3. **Migration Path Testing**: Verify that systems can upgrade iteration counts without breaking existing authentication for users who haven't logged in during the migration period.\n\n> **Milestone 2 Security Checkpoint Summary**: The system must demonstrate configurable computational hardness through PBKDF2 key stretching, with iteration counts properly calibrated for security requirements and performance constraints.\n\n#### Milestone 3: Modern Password Hashing Checkpoint\n\nModern password hashing algorithms introduce complex security properties including memory hardness, algorithm agility, and migration management. Testing must verify that these advanced features maintain security while providing operational flexibility.\n\n**Algorithm Integration Security Verification**\n\nModern algorithms like bcrypt and Argon2 provide different security properties that must be individually verified and compared for effectiveness against current attack methods.\n\n| Algorithm | Security Property | Test Method | Verification Criteria |\n|-----------|-------------------|-------------|----------------------|\n| bcrypt | Cost factor scaling | Benchmark costs 10, 12, 14 | Exponential time scaling |\n| bcrypt | Salt integration | Hash same password multiple times | Different outputs |\n| Argon2id | Memory hardness | Monitor memory usage | Usage matches parameters |\n| Argon2id | Parallelism resistance | Test parallel computation | No significant speedup |\n| Algorithm Agility | Migration support | Test algorithm transitions | Seamless migration |\n| Parameter Evolution | Security parameter updates | Test parameter upgrades | Backward compatibility |\n\n**Migration Security Testing**\n\nAlgorithm migration represents the most complex security testing scenario because it involves transitioning between different cryptographic approaches while maintaining continuous security coverage.\n\n| Migration Scenario | Security Test | Expected Behavior | Failure Handling |\n|---------------------|---------------|-------------------|------------------|\n| Lazy Migration | Authenticate with old hash | Upgrade to new algorithm | Preserve security during upgrade |\n| Migration Failure | Simulate upgrade failure | Fall back securely | No security degradation |\n| Concurrent Access | Multiple simultaneous migrations | Atomic operations | No race conditions |\n| Rollback Requirements | Reverse migration | Restore previous state | Maintain authentication |\n| Performance Impact | Migration during peak load | Acceptable performance | No denial-of-service |\n\n**Automated Modern Hashing Testing**\n\nThe `ModernPasswordHasher` provides comprehensive testing for advanced algorithm features:\n\n| Test Category | Method | Purpose | Success Criteria |\n|---------------|--------|---------|------------------|\n| Algorithm Benchmarking | `benchmark_algorithm(algorithm, **parameters)` | Performance measurement | Meet timing targets |\n| Migration Analysis | `assess_migration_need(record)` | Upgrade necessity | Accurate assessment |\n| Security Assessment | `assess_hash_strength(hash_record)` | Security evaluation | Current strength analysis |\n| Batch Migration | `batch_migration_analysis(hash_records)` | Large-scale migration | Efficient processing |\n\n> **Milestone 3 Security Checkpoint Summary**: The system must demonstrate production-grade password hashing with modern algorithms, seamless migration capabilities, and algorithm agility that supports future cryptographic evolution.\n\n### Common Security Testing Pitfalls\n\nPassword hashing security testing involves numerous subtle requirements that are easy to overlook but critical for security. These pitfalls often involve testing methodology rather than implementation, making them particularly dangerous because they can provide false confidence in insecure implementations.\n\n⚠️ **Pitfall: Insufficient Sample Sizes for Statistical Tests**\n\nMany developers test salt uniqueness with small sample sizes (hundreds or thousands of salts) and conclude that their generator is secure. However, statistical significance for cryptographic randomness requires much larger samples—typically hundreds of thousands or millions of values.\n\n**Why this is wrong**: Small sample sizes can miss subtle biases that become exploitable at scale. An attacker processing millions of password hashes can detect patterns that small-scale testing misses.\n\n**How to fix**: Use statistically appropriate sample sizes based on the security property being tested. For salt collision testing, generate at least 100,000 salts. For entropy distribution testing, analyze at least 1 million salt bytes.\n\n⚠️ **Pitfall: Testing Only Happy Path Scenarios**\n\nSecurity testing often focuses on normal operation scenarios (valid passwords, proper algorithm parameters, sufficient system resources) while neglecting edge cases that attackers specifically target.\n\n**Why this is wrong**: Attackers deliberately create abnormal conditions to exploit edge cases. Security vulnerabilities often exist at the boundaries of normal operation.\n\n**How to fix**: Systematically test edge cases including invalid inputs, resource exhaustion, algorithm failures, and concurrent access scenarios. Use the `SecurityEducationDemos` to understand attack vectors.\n\n⚠️ **Pitfall: Timing Attack Testing with Insufficient Precision**\n\nDevelopers often test timing attack resistance using system clocks with millisecond precision, missing microsecond-level timing differences that attackers can exploit.\n\n**Why this is wrong**: Network attackers can perform statistical analysis over thousands of requests to detect timing differences much smaller than individual measurement precision.\n\n**How to fix**: Use high-precision timing measurements (nanosecond resolution) and perform statistical analysis over large sample sizes. Test timing consistency under various system load conditions.\n\n⚠️ **Pitfall: Not Testing Algorithm Migration Security**\n\nMany implementations test individual algorithms thoroughly but fail to test the security properties of migration between algorithms, particularly the transition period when both old and new hashes coexist.\n\n**Why this is wrong**: Migration represents a complex operational scenario with unique security risks. Vulnerabilities during migration can compromise the entire security upgrade process.\n\n**How to fix**: Explicitly test migration scenarios including concurrent migrations, migration failures, and rollback procedures. Verify that security never degrades during algorithm transitions.\n\n### Implementation Guidance\n\nThe testing strategy implementation provides concrete tools for verifying cryptographic security properties throughout the development process. This guidance bridges the conceptual testing framework with practical verification code.\n\n#### Security Testing Technology Stack\n\n| Component | Simple Option | Advanced Option | When to Use |\n|-----------|---------------|-----------------|-------------|\n| Statistical Analysis | Python built-in `statistics` module | SciPy statistical functions | Simple for basic tests, SciPy for cryptographic analysis |\n| Timing Measurement | `time.perf_counter()` for basic timing | `timeit` module with statistical analysis | Basic for functional tests, timeit for security verification |\n| Cryptographic Testing | Custom collision detection | PyCrypto test vectors and NIST test suites | Custom for learning, NIST standards for production |\n| Load Testing | Simple loops with threading | `pytest-benchmark` with concurrent execution | Simple for development, benchmark for performance validation |\n| Memory Analysis | Basic resource monitoring | `memory_profiler` with detailed tracking | Basic for functional tests, profiler for security analysis |\n\n#### Recommended Test File Structure\n\n```\nproject-root/\n  tests/\n    security/                          ← security-specific tests\n      test_salt_security.py           ← cryptographic randomness tests\n      test_timing_attacks.py          ← timing attack resistance tests\n      test_algorithm_security.py      ← algorithm security property tests\n      test_migration_security.py      ← migration security tests\n    integration/                       ← end-to-end testing\n      test_password_flows.py          ← complete authentication flows\n      test_performance_benchmarks.py  ← performance and scalability tests\n    utils/                            ← testing infrastructure\n      security_test_utils.py          ← shared security testing functions\n      attack_simulators.py            ← attack simulation utilities\n      benchmark_tools.py              ← performance measurement tools\n```\n\n#### Security Testing Infrastructure Code\n\nThis infrastructure provides the foundation for security testing across all milestones. Copy this code directly and use it as the base for milestone-specific security tests:\n\n```python\n\"\"\"\nSecurity Testing Infrastructure for Password Hashing System\nProvides statistical analysis and attack simulation capabilities.\n\"\"\"\nimport time\nimport secrets\nimport statistics\nimport threading\nfrom typing import List, Dict, Any, Tuple, Callable\nfrom collections import defaultdict\nimport hashlib\n\nclass SecurityTestFramework:\n    \"\"\"\n    Comprehensive security testing framework for password hashing systems.\n    Provides statistical analysis, timing attack detection, and cryptographic verification.\n    \"\"\"\n    \n    def __init__(self, precision_ns: int = 1000):\n        self.timing_precision_ns = precision_ns\n        self.statistical_samples = defaultdict(list)\n        \n    def measure_execution_time(self, func: Callable, *args, **kwargs) -> Dict[str, float]:\n        \"\"\"\n        High-precision execution time measurement with statistical analysis.\n        Returns timing statistics including mean, median, and variance.\n        \"\"\"\n        measurements = []\n        \n        # Warmup runs to eliminate JIT compilation effects\n        for _ in range(10):\n            func(*args, **kwargs)\n            \n        # Actual measurements\n        for _ in range(100):\n            start_time = time.perf_counter_ns()\n            result = func(*args, **kwargs)\n            end_time = time.perf_counter_ns()\n            measurements.append((end_time - start_time) / 1_000_000)  # Convert to milliseconds\n            \n        return {\n            'mean_ms': statistics.mean(measurements),\n            'median_ms': statistics.median(measurements),\n            'std_dev_ms': statistics.stdev(measurements) if len(measurements) > 1 else 0.0,\n            'min_ms': min(measurements),\n            'max_ms': max(measurements),\n            'sample_count': len(measurements)\n        }\n    \n    def analyze_salt_randomness(self, salt_generator: Callable, sample_count: int = 100000) -> Dict[str, Any]:\n        \"\"\"\n        Comprehensive cryptographic randomness analysis for salt generation.\n        Performs collision detection, entropy analysis, and distribution testing.\n        \"\"\"\n        salts = set()\n        byte_frequencies = defaultdict(int)\n        consecutive_differences = []\n        \n        previous_salt = None\n        collision_count = 0\n        \n        for _ in range(sample_count):\n            salt = salt_generator()\n            \n            # Collision detection\n            if salt in salts:\n                collision_count += 1\n            salts.add(salt)\n            \n            # Byte frequency analysis\n            for byte_val in salt:\n                byte_frequencies[byte_val] += 1\n                \n            # Sequential independence analysis\n            if previous_salt is not None:\n                hamming_distance = sum(a != b for a, b in zip(salt, previous_salt))\n                consecutive_differences.append(hamming_distance)\n            previous_salt = salt\n            \n        # Chi-square test for uniform distribution\n        expected_frequency = sample_count * len(next(iter(salts))) / 256\n        chi_square = sum(\n            (observed - expected_frequency) ** 2 / expected_frequency\n            for observed in byte_frequencies.values()\n        )\n        \n        return {\n            'sample_count': sample_count,\n            'unique_salts': len(salts),\n            'collision_count': collision_count,\n            'collision_rate': collision_count / sample_count,\n            'chi_square_statistic': chi_square,\n            'chi_square_critical_value': 293.25,  # 95% confidence for 255 degrees of freedom\n            'passes_chi_square': chi_square < 293.25,\n            'mean_hamming_distance': statistics.mean(consecutive_differences) if consecutive_differences else 0,\n            'hamming_distance_std': statistics.stdev(consecutive_differences) if len(consecutive_differences) > 1 else 0\n        }\n    \n    def detect_timing_attack_vulnerability(self, \n                                          verification_func: Callable, \n                                          valid_cases: List[Tuple], \n                                          invalid_cases: List[Tuple],\n                                          significance_threshold: float = 0.05) -> Dict[str, Any]:\n        \"\"\"\n        Statistical timing attack vulnerability detection.\n        Compares timing distributions between valid and invalid authentication attempts.\n        \"\"\"\n        valid_timings = []\n        invalid_timings = []\n        \n        # Measure valid case timings\n        for test_case in valid_cases:\n            timing_stats = self.measure_execution_time(verification_func, *test_case)\n            valid_timings.append(timing_stats['mean_ms'])\n            \n        # Measure invalid case timings  \n        for test_case in invalid_cases:\n            timing_stats = self.measure_execution_time(verification_func, *test_case)\n            invalid_timings.append(timing_stats['mean_ms'])\n            \n        # Statistical significance testing\n        valid_mean = statistics.mean(valid_timings)\n        invalid_mean = statistics.mean(invalid_timings)\n        timing_difference = abs(valid_mean - invalid_mean)\n        \n        # Simplified t-test approximation\n        pooled_variance = (\n            statistics.variance(valid_timings) + statistics.variance(invalid_timings)\n        ) / 2\n        t_statistic = timing_difference / (pooled_variance ** 0.5 * (2 / len(valid_timings)) ** 0.5)\n        \n        return {\n            'valid_mean_ms': valid_mean,\n            'invalid_mean_ms': invalid_mean,\n            'timing_difference_ms': timing_difference,\n            't_statistic': t_statistic,\n            'likely_vulnerable': t_statistic > 2.0,  # Rough significance threshold\n            'valid_timing_variance': statistics.variance(valid_timings),\n            'invalid_timing_variance': statistics.variance(invalid_timings),\n            'recommendation': 'Implement constant-time comparison' if t_statistic > 2.0 else 'Timing appears consistent'\n        }\n\nclass AttackSimulationFramework:\n    \"\"\"\n    Framework for simulating various password hash attacks.\n    Used to verify that security measures are effective against real attack methods.\n    \"\"\"\n    \n    @staticmethod\n    def simulate_rainbow_table_attack(target_hashes: List[str], \n                                    dictionary_passwords: List[str],\n                                    salt_list: List[bytes] = None) -> Dict[str, Any]:\n        \"\"\"\n        Simulates rainbow table attack against unsalted hashes.\n        Demonstrates why salting is critical for security.\n        \"\"\"\n        if salt_list is None:\n            # Unsalted hash attack - very effective\n            rainbow_table = {}\n            for password in dictionary_passwords:\n                hash_value = hashlib.sha256(password.encode()).hexdigest()\n                rainbow_table[hash_value] = password\n                \n            cracked_passwords = {}\n            for target_hash in target_hashes:\n                if target_hash in rainbow_table:\n                    cracked_passwords[target_hash] = rainbow_table[target_hash]\n                    \n            return {\n                'attack_type': 'rainbow_table_unsalted',\n                'rainbow_table_size': len(rainbow_table),\n                'target_hashes': len(target_hashes),\n                'cracked_count': len(cracked_passwords),\n                'success_rate': len(cracked_passwords) / len(target_hashes),\n                'cracked_passwords': cracked_passwords,\n                'effectiveness': 'Very High - Salting Required'\n            }\n        else:\n            # Salted hash attack - much less effective\n            attempted_cracks = 0\n            successful_cracks = 0\n            \n            for target_hash, salt in zip(target_hashes, salt_list):\n                for password in dictionary_passwords:\n                    attempted_cracks += 1\n                    test_hash = hashlib.sha256(salt + password.encode()).hexdigest()\n                    if test_hash == target_hash:\n                        successful_cracks += 1\n                        break\n                        \n            return {\n                'attack_type': 'rainbow_table_salted',\n                'attempted_combinations': attempted_cracks,\n                'successful_cracks': successful_cracks,\n                'success_rate': successful_cracks / len(target_hashes),\n                'effectiveness': 'Low - Salting Effective'\n            }\n```\n\n#### Milestone-Specific Testing Skeletons\n\n**Milestone 1 Security Tests (implement these TODOs):**\n\n```python\ndef test_milestone_1_salt_security():\n    \"\"\"\n    Comprehensive security testing for Milestone 1: Basic Hashing with Salt\n    \"\"\"\n    # TODO 1: Create SaltGenerator instance with default parameters\n    # TODO 2: Use SecurityTestFramework.analyze_salt_randomness() with 100,000 samples\n    # TODO 3: Assert collision_count == 0 (no duplicate salts)\n    # TODO 4: Assert passes_chi_square == True (uniform distribution)\n    # TODO 5: Assert mean_hamming_distance is approximately half the salt length\n    # TODO 6: Generate timing attack test cases (valid and invalid passwords)\n    # TODO 7: Use SecurityTestFramework.detect_timing_attack_vulnerability()\n    # TODO 8: Assert likely_vulnerable == False (timing attack resistance)\n    pass\n\ndef test_milestone_1_hash_determinism():\n    \"\"\"\n    Verify that identical inputs produce identical outputs consistently\n    \"\"\"\n    # TODO 1: Create BasicHasher instance\n    # TODO 2: Generate fixed test salt using secrets.token_bytes(32)\n    # TODO 3: Hash same password with same salt 100 times\n    # TODO 4: Assert all hash outputs are identical\n    # TODO 5: Hash same password with different salts\n    # TODO 6: Assert all hash outputs are different\n    pass\n```\n\n**Milestone 2 Security Tests (implement these TODOs):**\n\n```python\ndef test_milestone_2_iteration_scaling():\n    \"\"\"\n    Verify that iteration count scaling provides linear time increase\n    \"\"\"\n    # TODO 1: Create KeyStretchingHasher instance\n    # TODO 2: Test iteration counts: [100000, 200000, 400000]\n    # TODO 3: Measure timing for each iteration count using SecurityTestFramework\n    # TODO 4: Calculate timing ratios between iteration counts\n    # TODO 5: Assert timing scales approximately linearly with iterations\n    # TODO 6: Verify minimum iteration count enforcement\n    # TODO 7: Assert IterationCountError raised for counts < PBKDF2_MIN_ITERATIONS\n    pass\n\ndef test_milestone_2_computational_hardness():\n    \"\"\"\n    Verify that key stretching provides meaningful brute force protection\n    \"\"\"\n    # TODO 1: Benchmark single password verification time\n    # TODO 2: Calculate brute force time for 10^8 password attempts\n    # TODO 3: Assert brute force time > 1 year for reasonable hardware\n    # TODO 4: Test different iteration counts and measure scaling\n    # TODO 5: Verify that higher iteration counts provide proportional protection\n    pass\n```\n\n**Milestone 3 Security Tests (implement these TODOs):**\n\n```python\ndef test_milestone_3_algorithm_security_properties():\n    \"\"\"\n    Verify security properties of modern hashing algorithms\n    \"\"\"\n    # TODO 1: Create ModernPasswordHasher with bcrypt and Argon2\n    # TODO 2: Test bcrypt cost factor scaling (costs 10, 12, 14)\n    # TODO 3: Assert exponential time scaling for bcrypt\n    # TODO 4: Test Argon2 memory usage with different memory parameters\n    # TODO 5: Assert memory usage matches configured parameters\n    # TODO 6: Verify algorithm agility by switching between algorithms\n    # TODO 7: Test migration from weak to strong algorithm parameters\n    pass\n\ndef test_milestone_3_migration_security():\n    \"\"\"\n    Verify that algorithm migration maintains security throughout transition\n    \"\"\"\n    # TODO 1: Create password hashes with legacy algorithm (SHA-256)\n    # TODO 2: Implement lazy migration during authentication\n    # TODO 3: Verify that migration upgrades algorithm without breaking authentication  \n    # TODO 4: Test concurrent migration scenarios with threading\n    # TODO 5: Assert no race conditions during migration\n    # TODO 6: Test migration failure handling and rollback\n    # TODO 7: Verify security never degrades during migration process\n    pass\n```\n\n#### Performance Benchmark Testing\n\nSecurity and performance are interconnected in password hashing systems. These benchmarks verify that security configurations meet performance requirements:\n\n```python\ndef benchmark_security_performance():\n    \"\"\"\n    Benchmark password hashing performance across security configurations.\n    Verifies that security settings meet operational performance requirements.\n    \"\"\"\n    # TODO 1: Define target authentication times (< 500ms for user experience)\n    # TODO 2: Test bcrypt cost factors 10, 11, 12, 13, 14\n    # TODO 3: Test Argon2 memory parameters: 64MB, 128MB, 256MB\n    # TODO 4: Test PBKDF2 iteration counts: 100K, 200K, 500K, 1M\n    # TODO 5: Measure statistical timing distribution (mean, p95, p99)\n    # TODO 6: Identify optimal security/performance balance\n    # TODO 7: Generate recommendation report for production deployment\n    pass\n```\n\n#### Debugging Security Test Failures\n\n| Test Failure Symptom | Likely Cause | Diagnosis Steps | Fix Approach |\n|----------------------|--------------|-----------------|--------------|\n| Salt collisions detected | Weak random number generator | Check entropy source, test generator directly | Use secrets module, verify entropy pool |\n| Timing attack vulnerability | Non-constant-time comparison | Profile comparison function execution | Implement constant_time_compare() |\n| Chi-square test failure | Biased salt generation | Analyze byte distribution patterns | Review random generation algorithm |\n| Performance too slow | Excessive security parameters | Benchmark individual operations | Reduce iteration/memory parameters |\n| Migration test failures | Race conditions in updates | Test concurrent access patterns | Add proper synchronization |\n\n\n## Debugging Guide\n\n> **Milestone(s):** All milestones (debugging strategies are essential across all implementation phases from basic salt/hash verification through key stretching validation to modern algorithm integration)\n\n### Mental Model: The Medical Diagnostic System\n\nThink of debugging password hashing systems like a medical diagnostic process in a specialized cryptographic security clinic. Just as a doctor follows systematic diagnostic procedures to identify the root cause of symptoms—checking vital signs, running specific tests, and comparing results against known patterns—debugging password hashing requires methodical analysis of security symptoms, systematic testing of cryptographic properties, and comparison against known secure implementation patterns.\n\nWhen a patient arrives with chest pain, an experienced physician doesn't immediately assume heart attack—they systematically rule out other causes like muscle strain, anxiety, or digestive issues through specific tests and observations. Similarly, when a password hashing system exhibits security vulnerabilities or functional failures, an experienced security engineer follows systematic diagnostic procedures to isolate the root cause, whether it's inadequate randomness, timing vulnerabilities, or algorithm misconfiguration.\n\nThe diagnostic process involves understanding both the symptoms (what's observable) and the underlying pathophysiology (why the system is behaving incorrectly). This section provides the equivalent of a medical diagnostic manual for password hashing systems—mapping symptoms to likely causes, providing specific diagnostic tests, and prescribing targeted remediation strategies.\n\n### Common Implementation Bugs\n\nPassword hashing implementations frequently exhibit predictable failure patterns that manifest as specific observable symptoms. Understanding these symptom-cause-fix mappings enables rapid diagnosis and remediation of security vulnerabilities before they reach production systems.\n\nThe following diagnostic reference maps observable symptoms to their underlying causes, provides specific diagnostic procedures, and prescribes targeted fixes. Each entry represents a common failure mode discovered through extensive analysis of real-world password hashing implementations.\n\n#### Salt Generation Failures\n\n| Symptom | Underlying Cause | Diagnostic Test | Remediation Strategy |\n|---------|------------------|-----------------|---------------------|\n| Identical salts across multiple password hashes | Using predictable pseudorandom generator instead of cryptographically secure randomness | Generate 1000 salts and check for duplicates; analyze entropy distribution | Replace `random.random()` or `Math.random()` with `os.urandom()`, `secrets.token_bytes()`, or equivalent cryptographically secure source |\n| Salt generation throws entropy exhaustion errors | Insufficient system entropy, particularly in containerized environments | Monitor `/proc/sys/kernel/random/entropy_avail` on Linux; test salt generation under load | Implement entropy pool monitoring; use `secrets` module which handles blocking appropriately; consider hardware random number generators |\n| Salts contain only ASCII characters when binary expected | Incorrectly encoding random bytes as strings | Examine salt bytes directly; verify salt length matches expected binary length | Generate raw bytes with `os.urandom()` or `secrets.token_bytes()` instead of converting to string representations |\n| Salt length varies across password hashes | Dynamic salt length calculation or truncation bugs | Check `len(salt)` across multiple generated salts; verify against `MINIMUM_SALT_LENGTH` constant | Use fixed salt length; validate salt length during generation with `validate_salt_length()` |\n\n⚠️ **Pitfall: Using Time-Based Seeds**\nMany developers initialize pseudorandom generators with current time as seed, believing this provides sufficient randomness. Time-based seeds are highly predictable—an attacker can enumerate possible seed values within a reasonable timeframe. The fix requires using cryptographically secure random sources that derive entropy from hardware noise sources rather than predictable system state.\n\n⚠️ **Pitfall: Salt Reuse Across Applications**\nUsing the same salt generation logic across multiple applications or user accounts creates correlation vulnerabilities. Even with cryptographically secure randomness, correlated salt generation patterns can leak information about password distribution. Each salt must be independently generated using the `SaltGenerator` component with proper isolation.\n\n#### Hash Computation Vulnerabilities\n\n| Symptom | Underlying Cause | Diagnostic Test | Remediation Strategy |\n|---------|------------------|-----------------|---------------------|\n| Password verification succeeds with incorrect passwords | Hash computation concatenating password and salt in wrong order | Test known password/salt pair; verify hash computation matches expected output | Standardize concatenation order in `BasicHasher.hash_password()` as `password || salt` |\n| Hash verification fails for previously stored valid passwords | Character encoding inconsistencies between storage and verification | Test with Unicode passwords containing special characters; verify byte-level hash computation | Ensure consistent UTF-8 encoding using `.encode('utf-8')` before hash computation |\n| Timing attack vulnerability in password comparison | Using standard string comparison instead of constant-time comparison | Measure verification time with correct vs incorrect passwords using `measure_execution_time()` | Replace string comparison with `constant_time_compare()` function |\n| Hash computation crashes with certain password inputs | Input validation missing for password edge cases | Test with empty passwords, very long passwords, and None/null inputs | Implement `_validate_password_input()` to reject invalid inputs before processing |\n\n⚠️ **Pitfall: Hash Algorithm Confusion**\nMixing different hash algorithms during computation and verification creates subtle bugs where hashes appear valid but never match. For example, using SHA-256 during registration but SHA-1 during verification. The `PasswordHashRecord` must store algorithm metadata to ensure verification uses identical hash computation.\n\n⚠️ **Pitfall: Platform-Dependent Hash Computation**\nHash computation that works differently across operating systems or Python versions indicates platform-dependent behavior, usually from encoding or library differences. All hash computation should use explicit byte-level operations with the `hashlib` module to ensure cross-platform consistency.\n\n#### PBKDF2 Implementation Errors\n\n| Symptom | Underlying Cause | Diagnostic Test | Remediation Strategy |\n|---------|------------------|-----------------|---------------------|\n| PBKDF2 verification extremely slow compared to generation | Iteration count not stored with hash, defaulting to maximum during verification | Compare iteration counts between generation and verification; check `PasswordHashRecord.parameters['iterations']` | Store iteration count in hash record parameters; verify `KeyStretchingHasher` retrieves stored iterations |\n| Key stretching provides no security benefit | Iteration count too low or PBKDF2 implementation bypassed | Benchmark hash computation time; verify minimum `PBKDF2_MIN_ITERATIONS` enforcement | Increase iteration count to meet timing targets; implement `validate_iteration_count()` |\n| PBKDF2 crashes with certain parameter combinations | Parameter validation missing or incorrect | Test with edge case parameters: zero iterations, negative key length, None salt | Implement comprehensive parameter validation in `validate_pbkdf2_parameters()` |\n| Derived key length inconsistent across verifications | Dynamic key length calculation or parameter corruption | Verify consistent key length in `PasswordHashRecord.hash` field | Store derived key length in hash record parameters; validate during verification |\n\n⚠️ **Pitfall: Iteration Count Security Decay**\nSetting iteration count once and never updating it creates security decay as hardware performance improves. Iteration counts appropriate in 2020 may provide insufficient protection in 2025. Implement `evolve_security_parameters()` to recommend iteration count increases based on current hardware benchmarks.\n\n⚠️ **Pitfall: PBKDF2 Salt Confusion**\nUsing different salt values for PBKDF2 key derivation versus the stored salt creates verification failures. The identical salt used during hash generation must be used during verification. The `KeyStretchingHasher` must retrieve salt from the `PasswordHashRecord` rather than generating fresh salt.\n\n#### Modern Algorithm Integration Problems\n\n| Symptom | Underlying Cause | Diagnostic Test | Remediation Strategy |\n|---------|------------------|-----------------|---------------------|\n| Bcrypt verification fails with \"invalid hash\" errors | Incorrect bcrypt hash parsing or format corruption | Validate bcrypt hash format using regex; check for truncation or encoding issues | Use standard bcrypt library functions; validate hash format before verification |\n| Argon2 memory consumption exceeds system limits | Memory parameters configured beyond system capabilities | Monitor memory usage during hash computation; test with `ARGON2_DEFAULT_MEMORY` | Implement memory parameter validation; tune parameters for deployment environment |\n| Algorithm migration fails silently | Migration assessment logic incorrect or migration triggers not firing | Test migration with known old hash formats; verify `MigrationAssessment.needs_migration` | Implement comprehensive migration testing; validate algorithm detection logic |\n| Modern hashing performance dramatically slower than expected | Cost parameters configured for different hardware generation | Benchmark algorithm performance with `benchmark_algorithm()`; compare against target timing | Tune algorithm parameters for current hardware using `PerformanceBenchmarker` |\n\n⚠️ **Pitfall: Algorithm Availability Assumptions**\nAssuming bcrypt or Argon2 libraries are always available creates runtime failures in restricted environments. The `DegradationManager` must handle algorithm unavailability gracefully, falling back to available algorithms while maintaining security properties.\n\n⚠️ **Pitfall: Migration Loop Scenarios**\nIncorrect migration logic can create infinite migration loops where hash records are repeatedly \"upgraded\" without actually improving security. Migration assessment must include timestamp checks and algorithm advancement verification to prevent degradation loops.\n\n#### Timing Attack Vulnerabilities\n\n| Symptom | Underlying Cause | Diagnostic Test | Remediation Strategy |\n|---------|------------------|-----------------|---------------------|\n| Password verification time varies significantly with input length | String comparison short-circuiting on first character mismatch | Measure verification time with passwords of different lengths using `detect_timing_attack_vulnerability()` | Implement `constant_time_compare()` for all password-derived comparisons |\n| Verification time differs between valid and invalid usernames | Different code paths for existing vs non-existing users | Time password verification for valid vs invalid usernames | Implement `_execute_dummy_verification()` to normalize timing |\n| Hash computation time leaks information about password content | Variable-time operations in hash preprocessing | Measure hash computation time across different password patterns | Ensure all hash computation uses constant-time operations |\n| Database query time varies with user existence | Database query optimization differences for existing vs missing records | Profile database query performance for user lookup operations | Implement consistent database query patterns; consider caching strategies |\n\n⚠️ **Pitfall: Timing Consistency Testing Inadequate**\nTesting timing attack resistance with artificial delays or insufficient precision measurements fails to detect real timing vulnerabilities. Use high-precision timing measurement with `measure_execution_time()` and statistical analysis to detect timing differences smaller than network jitter.\n\n⚠️ **Pitfall: Side-Channel Information Leakage**\nBeyond timing attacks, password hashing can leak information through memory allocation patterns, CPU cache behavior, or power consumption. While difficult to exploit remotely, these side channels become relevant in shared hosting environments or specialized attack scenarios.\n\n### Debugging Techniques\n\nEffective debugging of password hashing systems requires specialized tools and methodologies that account for the cryptographic nature of the operations. Standard application debugging approaches must be supplemented with cryptographic analysis techniques, security property verification, and performance profiling tailored to authentication workloads.\n\n#### Cryptographic Analysis Toolkit\n\nThe foundation of password hashing debugging involves verifying cryptographic properties that ensure security. These analysis techniques focus on detecting entropy deficiencies, randomness patterns, and cryptographic implementation errors that compromise security.\n\n**Entropy and Randomness Analysis**\n\nSalt generation quality directly impacts security, making randomness analysis critical for debugging. The `SecurityTestFramework` provides statistical tests for detecting entropy deficiencies and randomness pattern violations.\n\n| Analysis Type | Tool Function | Detection Capability | Interpretation Guidance |\n|---------------|---------------|----------------------|-------------------------|\n| Salt uniqueness analysis | `analyze_salt_randomness(salt_generator, sample_count)` | Detects salt collisions and distribution bias | Zero collisions expected in 10,000 samples; Chi-square test should show uniform distribution |\n| Entropy distribution testing | `verify_salt_uniqueness(password_count, sample_size)` | Identifies entropy exhaustion or generator bias | Birthday paradox analysis; collision probability should match theoretical expectations |\n| Pattern detection analysis | Statistical analysis of generated salt sequences | Detects linear congruential generator patterns or seed correlation | Autocorrelation should approach zero; frequency analysis should show uniform byte distribution |\n| Cross-platform consistency | Generate salts on different systems; compare distributions | Identifies platform-dependent randomness sources | Statistical properties should be identical across platforms and Python versions |\n\n**Hash Computation Verification**\n\nHash computation debugging requires verifying that identical inputs produce identical outputs across different execution contexts, while ensuring that timing characteristics don't leak information about input properties.\n\n| Verification Type | Diagnostic Approach | Expected Outcome | Failure Investigation |\n|-------------------|-------------------|------------------|----------------------|\n| Cross-platform hash consistency | Generate hash with identical salt/password on different systems | Identical hash bytes across all platforms | Check encoding, hash algorithm implementation, library versions |\n| Algorithm parameter verification | Compare hash generation with known test vectors | Hash matches published test vectors for algorithm | Verify parameter parsing, algorithm selection, library compatibility |\n| Timing consistency analysis | `verify_timing_consistency(func, test_cases, tolerance_ms)` | Execution time variance within acceptable bounds | Profile timing distribution; identify variable-time operations |\n| Input sanitization testing | Test hash computation with malicious or edge case inputs | Graceful failure or correct processing | Review input validation; test Unicode normalization |\n\n#### Performance and Security Profiling\n\nPassword hashing performance directly relates to security properties, making performance profiling essential for debugging both functional correctness and security adequacy.\n\n**Algorithm Performance Characterization**\n\nUnderstanding algorithm performance characteristics helps debug configuration issues, detect performance regressions, and validate security parameter tuning.\n\n| Profiling Focus | Measurement Technique | Security Implications | Debugging Insights |\n|-----------------|----------------------|----------------------|-------------------|\n| Iteration count scaling | `benchmark_cost_scaling(algorithm, cost_range)` | Higher iteration counts provide exponentially better brute force resistance | Linear scaling indicates implementation problems; step functions suggest caching issues |\n| Memory usage profiling | Monitor memory consumption during Argon2 operations | Memory-hard algorithms should use configured memory amounts | Insufficient memory usage indicates parameter validation failures |\n| Parallel execution analysis | Test algorithm performance with concurrent operations | Some algorithms may have unexpected contention or scaling issues | Lock contention or shared resource bottlenecks affect production performance |\n| Hardware sensitivity testing | Benchmark across different CPU architectures | Algorithm performance varies significantly across hardware generations | Parameter tuning must account for deployment environment characteristics |\n\n**Security Property Verification**\n\nDebugging security properties requires specialized testing that goes beyond functional correctness to verify that the implementation maintains security guarantees under various conditions.\n\n| Security Property | Verification Method | Expected Behavior | Debugging Red Flags |\n|-------------------|-------------------|-------------------|-------------------|\n| Timing attack resistance | `detect_timing_attack_vulnerability(verification_func, valid_cases, invalid_cases, threshold)` | Execution time independent of password correctness | Significant timing differences indicate comparison vulnerabilities |\n| Salt correlation analysis | Generate salts for related passwords; analyze for patterns | No correlation between password similarity and salt patterns | Correlation suggests salt generation depends on password content |\n| Algorithm downgrade resistance | Test system behavior when preferred algorithms unavailable | Graceful degradation to equivalent security alternatives | Automatic downgrade to weaker algorithms indicates configuration problems |\n| Migration security preservation | Verify migrated hashes maintain equivalent security properties | Security level should improve or remain constant during migration | Security degradation during migration suggests migration logic errors |\n\n#### Production Debugging Strategies\n\nDebugging password hashing issues in production environments requires techniques that preserve security while enabling diagnosis of authentication failures and performance problems.\n\n**Safe Production Debugging**\n\nProduction debugging must avoid logging sensitive information while providing sufficient detail for diagnosis.\n\n| Debugging Challenge | Safe Approach | Information Available | Security Boundaries |\n|--------------------|--------------|--------------------|-------------------|\n| Authentication failure diagnosis | Log algorithm metadata, timing information, but never password content | Hash algorithm, parameter values, execution timing, error codes | Never log passwords, salts, or hash values |\n| Performance issue investigation | Sample timing distributions and algorithm usage patterns | Statistical timing data, algorithm distribution, resource utilization | Avoid user correlation or password-dependent measurements |\n| Migration progress monitoring | Track migration completion percentages and algorithm distribution | Migration statistics, algorithm adoption rates, error frequencies | User identifiers and password data remain protected |\n| Configuration validation | Validate algorithm availability and parameter ranges | Algorithm capabilities, parameter validation results, system limits | Configuration details safe to log; avoid user-specific data |\n\n**Error Pattern Analysis**\n\nSystematic analysis of error patterns helps identify configuration issues, deployment problems, and attack patterns without exposing sensitive authentication data.\n\n| Error Pattern | Diagnostic Approach | Root Cause Investigation | Resolution Strategy |\n|---------------|-------------------|-------------------------|-------------------|\n| Sudden authentication failure spikes | Analyze error timing, affected user patterns, deployment correlation | Check for configuration changes, algorithm availability, system resource limits | Roll back configuration changes; verify algorithm dependencies |\n| Performance degradation trends | Monitor authentication timing distributions over time | Hardware changes, algorithm parameter drift, database performance | Benchmark current performance against baselines; retune parameters |\n| Migration failure clusters | Group migration failures by algorithm, timing, user characteristics | Algorithm compatibility, parameter validation, resource constraints | Validate migration logic; test algorithm transitions |\n| Intermittent verification failures | Correlate failures with system load, resource availability, timing | Resource exhaustion, timing threshold violations, concurrency issues | Load test authentication under realistic conditions |\n\n### Implementation Guidance\n\nThis implementation guidance provides concrete debugging tools and diagnostic utilities that enable systematic diagnosis of password hashing implementation issues. The tools focus on security property verification, performance analysis, and production-safe debugging techniques.\n\n#### Technology Recommendations\n\n| Debugging Component | Simple Option | Advanced Option |\n|-------------------|---------------|-----------------|\n| Timing Measurement | `time.time()` with manual statistics | `timeit` module with statistical analysis |\n| Cryptographic Analysis | Manual salt inspection | `scipy.stats` for entropy analysis |\n| Performance Profiling | Basic timing loops | `cProfile` with custom metrics |\n| Test Vector Validation | Hardcoded test cases | External test vector databases |\n| Production Monitoring | File-based logging | Structured logging with metrics |\n\n#### File Structure for Debugging Components\n\n```\npassword_hashing/\n├── debugging/\n│   ├── __init__.py\n│   ├── crypto_analyzer.py      ← cryptographic property analysis\n│   ├── performance_profiler.py ← algorithm performance testing\n│   ├── timing_security.py      ← timing attack detection\n│   ├── migration_validator.py  ← migration logic testing\n│   └── production_monitor.py   ← safe production debugging\n├── test_vectors/\n│   ├── salt_samples.json       ← known good salt test data\n│   ├── hash_test_vectors.json  ← algorithm test vectors\n│   └── timing_baselines.json   ← performance baselines\n└── scripts/\n    ├── validate_implementation.py ← comprehensive validation\n    └── benchmark_algorithms.py    ← parameter tuning utility\n```\n\n#### Cryptographic Analysis Implementation\n\n```python\nimport secrets\nimport hashlib\nimport statistics\nfrom typing import Dict, List, Any\nfrom dataclasses import dataclass\nfrom collections import Counter\n\n@dataclass\nclass RandomnessAnalysis:\n    \"\"\"Analysis results for cryptographic randomness quality.\"\"\"\n    sample_count: int\n    collision_count: int\n    entropy_estimate: float\n    distribution_uniformity: float\n    autocorrelation_coefficient: float\n    passes_statistical_tests: bool\n\nclass CryptographicAnalyzer:\n    \"\"\"Comprehensive cryptographic property analysis for password hashing.\"\"\"\n    \n    def __init__(self, precision_ns: int = 1000):\n        self.precision_ns = precision_ns\n        self.test_samples = []\n    \n    def analyze_salt_randomness(self, salt_generator, sample_count: int = 10000) -> RandomnessAnalysis:\n        \"\"\"\n        Perform comprehensive randomness analysis on salt generation.\n        \n        Generates large sample of salts and performs statistical tests\n        to detect entropy deficiencies, pattern correlations, and\n        distribution bias that could compromise security.\n        \"\"\"\n        # TODO 1: Generate sample_count salts using salt_generator.generate_salt()\n        # TODO 2: Check for exact duplicate salts (should be zero)\n        # TODO 3: Calculate byte distribution uniformity using Chi-square test\n        # TODO 4: Compute autocorrelation coefficient for sequence analysis\n        # TODO 5: Estimate entropy per byte using Shannon entropy formula\n        # TODO 6: Return RandomnessAnalysis with all computed metrics\n        pass\n    \n    def verify_hash_consistency(self, password: str, salt: bytes, \n                              hash_record: 'PasswordHashRecord') -> Dict[str, Any]:\n        \"\"\"\n        Verify hash computation produces consistent results across\n        multiple invocations and different execution contexts.\n        \"\"\"\n        # TODO 1: Re-compute hash using identical password, salt, algorithm\n        # TODO 2: Compare computed hash against hash_record.hash byte-for-byte\n        # TODO 3: Test hash computation 100 times to verify consistency\n        # TODO 4: Measure timing variance to detect timing inconsistencies\n        # TODO 5: Return detailed consistency analysis results\n        pass\n    \n    def detect_timing_vulnerabilities(self, verify_func, test_cases: List[tuple],\n                                    threshold_ms: float = 1.0) -> Dict[str, Any]:\n        \"\"\"\n        Detect timing attack vulnerabilities in password verification.\n        \n        Measures execution time distributions for correct vs incorrect\n        passwords to identify timing side channels that leak information\n        about password correctness.\n        \"\"\"\n        # TODO 1: Execute verify_func for each test case 1000 times\n        # TODO 2: Measure high-precision timing using time.perf_counter_ns()\n        # TODO 3: Group timing measurements by password correctness\n        # TODO 4: Perform statistical t-test to detect timing differences\n        # TODO 5: Return vulnerability assessment with statistical confidence\n        pass\n\ndef measure_execution_time(func, *args, **kwargs) -> Dict[str, float]:\n    \"\"\"\n    High-precision timing measurement for cryptographic operations.\n    \n    Uses performance counter for nanosecond precision and performs\n    multiple measurements to account for system noise and scheduling.\n    \"\"\"\n    import time\n    \n    measurements = []\n    warmup_iterations = 10\n    measurement_iterations = 100\n    \n    # Warmup phase to stabilize CPU caches and memory allocation\n    for _ in range(warmup_iterations):\n        func(*args, **kwargs)\n    \n    # Measurement phase with high-precision timing\n    for _ in range(measurement_iterations):\n        start_time = time.perf_counter_ns()\n        result = func(*args, **kwargs)\n        end_time = time.perf_counter_ns()\n        measurements.append((end_time - start_time) / 1_000_000)  # Convert to milliseconds\n    \n    return {\n        'mean_time_ms': statistics.mean(measurements),\n        'median_time_ms': statistics.median(measurements),\n        'std_deviation_ms': statistics.stdev(measurements) if len(measurements) > 1 else 0.0,\n        'min_time_ms': min(measurements),\n        'max_time_ms': max(measurements),\n        'sample_count': len(measurements),\n        'result': result\n    }\n```\n\n#### Performance Analysis Implementation\n\n```python\nimport time\nimport psutil\nimport threading\nfrom typing import Dict, List, Tuple, Optional\nfrom dataclasses import dataclass, field\nfrom concurrent.futures import ThreadPoolExecutor\n\n@dataclass\nclass PerformanceProfile:\n    \"\"\"Comprehensive performance analysis results.\"\"\"\n    algorithm: str\n    parameters: Dict[str, Any]\n    timing_statistics: Dict[str, float]\n    memory_usage: Dict[str, int]\n    cpu_utilization: float\n    scalability_metrics: Dict[str, float]\n    recommendations: List[str] = field(default_factory=list)\n\nclass PerformanceProfiler:\n    \"\"\"Algorithm performance analysis and parameter tuning.\"\"\"\n    \n    def __init__(self, target_time_ms: float = 500.0):\n        self.target_time_ms = target_time_ms\n        self.baseline_measurements = {}\n    \n    def profile_algorithm_performance(self, algorithm_name: str, \n                                    parameters: Dict[str, Any],\n                                    test_password: str = \"test_password_123\") -> PerformanceProfile:\n        \"\"\"\n        Comprehensive performance profiling of password hashing algorithm.\n        \n        Measures timing, memory usage, CPU utilization, and scalability\n        characteristics under realistic load patterns.\n        \"\"\"\n        # TODO 1: Initialize performance monitoring with psutil\n        # TODO 2: Measure single-threaded hash computation performance\n        # TODO 3: Test concurrent hash operations to measure scalability\n        # TODO 4: Monitor memory allocation during hash computation\n        # TODO 5: Generate performance recommendations based on measurements\n        # TODO 6: Return PerformanceProfile with comprehensive analysis\n        pass\n    \n    def tune_algorithm_parameters(self, algorithm_name: str,\n                                target_time_ms: float) -> Dict[str, Any]:\n        \"\"\"\n        Automatically tune algorithm parameters to meet target timing.\n        \n        Uses binary search approach to find optimal parameter values\n        that achieve target execution time on current hardware.\n        \"\"\"\n        # TODO 1: Define parameter search ranges for algorithm\n        # TODO 2: Implement binary search for iteration count or cost factor\n        # TODO 3: Measure actual performance at each parameter level\n        # TODO 4: Converge on parameters achieving target_time_ms ± 10%\n        # TODO 5: Validate final parameters meet security minimums\n        # TODO 6: Return optimized parameter dictionary\n        pass\n    \n    def benchmark_hardware_capabilities(self) -> Dict[str, Any]:\n        \"\"\"\n        Benchmark current hardware capabilities for password hashing.\n        \n        Establishes performance baselines that can be used to detect\n        performance regressions or validate deployment environments.\n        \"\"\"\n        # TODO 1: Measure CPU single-core and multi-core performance\n        # TODO 2: Test memory bandwidth for memory-hard algorithms\n        # TODO 3: Establish baseline timing for each supported algorithm\n        # TODO 4: Measure system entropy generation rate\n        # TODO 5: Return hardware capability assessment\n        pass\n\ndef validate_implementation_security(hasher_components: Dict[str, Any]) -> Dict[str, bool]:\n    \"\"\"\n    Comprehensive validation of password hashing implementation security.\n    \n    Performs automated testing of security properties across all\n    implementation components to verify cryptographic correctness.\n    \"\"\"\n    validation_results = {}\n    \n    # Salt generation validation\n    salt_generator = hasher_components.get('salt_generator')\n    if salt_generator:\n        # Test salt uniqueness over large sample\n        salts = set()\n        for _ in range(10000):\n            salt = salt_generator.generate_salt()\n            validation_results['salt_no_collisions'] = salt not in salts\n            salts.add(salt)\n        \n        # Test salt length compliance\n        sample_salt = salt_generator.generate_salt()\n        validation_results['salt_minimum_length'] = len(sample_salt) >= 16\n    \n    # Hash computation validation\n    hasher = hasher_components.get('hasher')\n    if hasher:\n        test_password = \"validation_test_password\"\n        test_salt = secrets.token_bytes(32)\n        \n        # Test hash consistency\n        hash1 = hasher.hash_password(test_password, test_salt)\n        hash2 = hasher.hash_password(test_password, test_salt)\n        validation_results['hash_deterministic'] = hash1 == hash2\n        \n        # Test password verification\n        verification_result = hasher.verify_password(test_password, hash1)\n        validation_results['verification_correct'] = verification_result\n        \n        # Test incorrect password rejection\n        wrong_verification = hasher.verify_password(\"wrong_password\", hash1)\n        validation_results['verification_rejects_incorrect'] = not wrong_verification\n    \n    return validation_results\n```\n\n#### Milestone Checkpoints\n\n**After Milestone 1 (Basic Hashing with Salt):**\n- Run: `python -m debugging.crypto_analyzer` to verify salt randomness\n- Expected: Zero salt collisions in 10,000 samples, uniform distribution\n- Manual test: Generate same password hash twice with different salts—results should differ\n- Debug check: Verify `constant_time_compare()` takes consistent time regardless of input\n\n**After Milestone 2 (Key Stretching):**\n- Run: `python -m debugging.performance_profiler --algorithm pbkdf2` to validate iteration count\n- Expected: Hash computation takes 200-500ms with minimum 100,000 iterations\n- Manual test: Increase iteration count 2x, verify timing approximately doubles\n- Debug check: Stored iteration count matches actual PBKDF2 computation\n\n**After Milestone 3 (Modern Password Hashing):**\n- Run: `python scripts/validate_implementation.py --comprehensive` for full validation\n- Expected: All security tests pass, migration logic handles algorithm transitions\n- Manual test: Hash password with bcrypt, verify with Argon2 fails appropriately\n- Debug check: Algorithm parameter tuning achieves target timing within 10%\n\n#### Debugging Red Flags\n\n| Symptom | Immediate Investigation | Critical Check |\n|---------|------------------------|----------------|\n| Authentication randomly fails | Check for race conditions in salt storage | Verify thread safety of hash record access |\n| Performance suddenly degrades | Monitor system entropy availability | Check `/proc/sys/kernel/random/entropy_avail` |\n| Timing measurements inconsistent | Disable CPU frequency scaling during tests | Use `time.perf_counter_ns()` for precision |\n| Migration never triggers | Verify algorithm version detection logic | Test with manually created old hash formats |\n| Memory usage exceeds limits | Check Argon2 memory parameter validation | Monitor actual vs configured memory usage |\n\n\n## Future Extensions\n\n> **Milestone(s):** Post-Milestone 3 (Advanced features building on modern password hashing foundation)\n\n### Mental Model: The Evolving Security Ecosystem Analogy\n\nThink of future extensions like the evolution of a modern security ecosystem around a bank vault. Initially, you have a basic vault with strong locks and time delays (our password hashing system). But over time, the security needs evolve - you add biometric scanners, you integrate with national security databases to check for known threats, you implement policies about who can access what based on their role, and you add monitoring systems that alert you when someone's credentials appear in a data breach. Each extension builds on the solid foundation but adds new capabilities that weren't part of the original requirements. The vault itself remains unchanged, but the ecosystem around it becomes more sophisticated and responsive to emerging threats.\n\nThe key insight is that password hashing is just one component in a broader authentication security ecosystem. While our core hashing implementation provides cryptographic security against offline attacks, real-world applications need additional layers of protection against evolving threat vectors like credential stuffing, password reuse, and social engineering attacks.\n\n> **Design Principle: Extensible Security Architecture**\n> A well-designed password hashing system serves as a stable foundation that can be enhanced with additional security features without requiring changes to the core cryptographic implementation. Extensions should integrate through clean interfaces rather than modifying the fundamental hashing logic.\n\n### Password Policy Integration: Adding Strength Validation and Policy Enforcement\n\nPassword policy integration transforms our password hashing system from a passive cryptographic service into an active security gatekeeper. Think of it like upgrading from a simple door lock to a smart security system that not only secures the door but also evaluates whether visitors should be allowed entry based on various criteria.\n\nThe fundamental challenge in password policy integration is balancing security requirements with user experience while maintaining clear separation of concerns between policy enforcement and cryptographic operations. Our hashing components should remain focused purely on secure storage and verification, while policy components handle the business logic of what constitutes an acceptable password.\n\n#### Architecture Decision: Policy Integration Strategy\n\n> **Decision: Separate Policy Validation from Cryptographic Operations**\n> - **Context**: Password policies involve business logic (minimum length, character requirements, dictionary checks) while hashing involves cryptographic security. These concerns have different update cycles and complexity profiles.\n> - **Options Considered**: \n>   1. Embed policy validation directly in hashing components\n>   2. Create separate policy validation layer that integrates with hashing\n>   3. Make policy validation completely independent with no integration\n> - **Decision**: Create separate policy validation layer with integration points\n> - **Rationale**: Maintains single responsibility principle, allows policy updates without touching cryptographic code, enables different applications to use different policies with same hashing foundation\n> - **Consequences**: Requires additional integration complexity but provides maximum flexibility and maintainability\n\n| Policy Integration Option | Pros | Cons | Maintainability |\n|--------------------------|------|------|----------------|\n| Embedded in Hasher | Simple integration, atomic validation | Violates separation of concerns, hard to update policies | Poor |\n| Separate Layer | Clean separation, flexible policies, testable | Additional integration complexity | Excellent |\n| Completely Independent | Maximum decoupling | No integration benefits, duplicate error handling | Good |\n\nThe policy validation architecture centers around a `PasswordPolicyEngine` that evaluates passwords against configurable rules before they reach the hashing components. This engine maintains a registry of policy rules, each implementing a common interface for password evaluation.\n\n#### Policy Engine Data Structures\n\n| Component | Type | Description |\n|-----------|------|-------------|\n| `PasswordPolicyEngine` | class | Core engine coordinating policy evaluation |\n| `policy_registry` | dict[str, PolicyRule] | Registry mapping rule names to implementations |\n| `active_policies` | list[str] | Currently enabled policy rule names |\n| `policy_configuration` | dict[str, Any] | Configuration parameters for each policy |\n| `evaluation_cache` | LRUCache | Cache for expensive policy evaluations |\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `register_policy(name, rule_class)` | name: str, rule_class: PolicyRule | None | Register new policy rule implementation |\n| `configure_policy(name, **params)` | name: str, params: dict | None | Update configuration for specific policy |\n| `enable_policies(policy_names)` | policy_names: list[str] | None | Activate specified policies for evaluation |\n| `evaluate_password(password, context)` | password: str, context: dict | PolicyEvaluationResult | Run password through all active policies |\n| `get_policy_requirements()` | None | dict | Return human-readable policy requirements |\n\n#### Policy Rule Interface\n\nThe `PolicyRule` abstract base class defines the interface that all password policies must implement. This enables extensibility while maintaining consistent evaluation patterns.\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `evaluate(password, context)` | password: str, context: dict | RuleEvaluationResult | Evaluate password against this specific rule |\n| `get_requirements()` | None | dict | Return human-readable rule requirements |\n| `get_configuration_schema()` | None | dict | Return JSON schema for rule configuration |\n| `estimate_evaluation_cost()` | None | float | Return relative computational cost estimate |\n\n#### Built-in Policy Implementations\n\nThe system provides several common policy rules that address the most frequent password security requirements:\n\n**Length Requirements Policy**\nEnforces minimum and maximum password length constraints with configurable parameters.\n\n| Configuration Parameter | Type | Default | Description |\n|------------------------|------|---------|-------------|\n| `minimum_length` | int | 8 | Minimum acceptable password length |\n| `maximum_length` | int | 128 | Maximum acceptable password length |\n| `encoding` | str | 'utf-8' | Character encoding for length calculation |\n\n**Character Composition Policy**\nRequires passwords to contain specified character types (uppercase, lowercase, digits, symbols).\n\n| Configuration Parameter | Type | Default | Description |\n|------------------------|------|---------|-------------|\n| `require_uppercase` | bool | True | Must contain uppercase letters |\n| `require_lowercase` | bool | True | Must contain lowercase letters |\n| `require_digits` | bool | True | Must contain numeric digits |\n| `require_symbols` | bool | True | Must contain non-alphanumeric symbols |\n| `minimum_character_types` | int | 3 | Minimum distinct character types required |\n\n**Dictionary Attack Prevention Policy**\nPrevents use of common passwords from known dictionaries and breach databases.\n\n| Configuration Parameter | Type | Default | Description |\n|------------------------|------|---------|-------------|\n| `common_passwords_file` | str | None | Path to common passwords dictionary |\n| `maximum_dictionary_size` | int | 100000 | Maximum dictionary entries to load |\n| `case_sensitive` | bool | False | Whether dictionary matching is case sensitive |\n| `allow_dictionary_substrings` | bool | False | Whether dictionary words can appear as substrings |\n\n#### Policy Evaluation Flow\n\nThe password policy evaluation follows a structured process that balances thorough validation with performance:\n\n1. **Pre-evaluation Validation**: The engine first validates that the password meets basic requirements (not None, proper encoding, reasonable length bounds) before proceeding with policy-specific evaluation.\n\n2. **Context Preparation**: The evaluation context is prepared, including user information (if available), previous password history, and any application-specific metadata that policies might need.\n\n3. **Cost-based Rule Ordering**: Policy rules are ordered by their estimated evaluation cost, with cheaper rules (like length checks) executed before expensive rules (like dictionary lookups or entropy calculations).\n\n4. **Short-circuit Evaluation**: If any policy rule fails with a hard rejection, evaluation stops immediately to avoid unnecessary computation. Warnings are accumulated but don't stop evaluation.\n\n5. **Result Aggregation**: All policy evaluation results are combined into a comprehensive result that includes pass/fail status, warning messages, and specific requirement violations.\n\n6. **Caching Strategy**: Results for expensive evaluations (like dictionary lookups) are cached based on password hash to avoid repeated computation, with appropriate cache invalidation when dictionaries are updated.\n\n#### Integration with Password Registration Flow\n\nThe policy engine integrates with the password registration flow at the validation stage, before any cryptographic operations occur:\n\n```\nPassword Input → Policy Validation → Hash Generation → Storage\n     ↓                    ↓                 ↓           ↓\nRaw Password → PolicyEvaluationResult → PasswordHashRecord → Database\n```\n\nThe integration maintains clear error handling boundaries. Policy validation failures result in user-friendly error messages that explain specific requirements, while cryptographic failures result in technical error messages appropriate for logging and debugging.\n\n#### Advanced Policy Features\n\n**Password History Integration**\nAdvanced implementations can integrate with user password history to prevent password reuse:\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `check_password_history(user_id, new_password, history_depth)` | user_id: str, new_password: str, history_depth: int | HistoryCheckResult | Verify new password against previous passwords |\n| `store_password_history(user_id, password_hash)` | user_id: str, password_hash: str | None | Add password to user's history |\n| `clean_expired_history(retention_days)` | retention_days: int | int | Remove old password history entries |\n\n**Entropy-based Strength Assessment**\nSophisticated policies can calculate password entropy to assess true randomness rather than relying only on character composition:\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `calculate_password_entropy(password)` | password: str | float | Calculate estimated password entropy in bits |\n| `assess_character_patterns(password)` | password: str | PatternAnalysis | Identify common patterns that reduce entropy |\n| `estimate_crack_time(password, attack_scenario)` | password: str, attack_scenario: str | TimingEstimate | Estimate time to crack under different attack models |\n\n#### Common Pitfalls in Policy Integration\n\n⚠️ **Pitfall: Validating Passwords After Hashing**\nValidating password policies after the password has already been hashed makes it impossible to analyze the actual password content. Policy validation must occur before any one-way cryptographic transformations.\n\n⚠️ **Pitfall: Storing Policy Configuration in Hash Records**\nEmbedding policy configuration in individual hash records creates consistency problems when policies need to be updated globally. Policy configuration should be maintained separately from individual password hashes.\n\n⚠️ **Pitfall: Synchronous Dictionary Lookups in Request Path**\nLoading large password dictionaries or making network calls during password validation can create performance bottlenecks. Use asynchronous loading, caching, and background updates for expensive policy operations.\n\n⚠️ **Pitfall: Revealing Information Through Policy Messages**\nDetailed policy violation messages can reveal information about existing passwords or system configuration to attackers. Balance helpfulness with security in error message design.\n\n### Breach Monitoring: Integration with HaveIBeenPwned and Similar Services\n\nBreach monitoring extends our password hashing system with real-world threat intelligence by checking whether passwords appear in known data breaches. Think of it like adding a security alert system that monitors global threat databases and warns you when credentials in your system might be compromised, similar to how credit monitoring services alert you when your personal information appears in data breaches.\n\nThe architectural challenge in breach monitoring is integrating external threat intelligence services while maintaining privacy, performance, and reliability. Users' passwords should never be transmitted in plain text to external services, and the system must gracefully handle service unavailability without blocking legitimate authentication.\n\n#### Architecture Decision: Privacy-Preserving Breach Checking\n\n> **Decision: Use k-Anonymity with Hash Prefixes for Breach Checking**\n> - **Context**: Direct password submission to breach services violates privacy. Hash submission reveals password hashes to third parties. Need balance between security checking and privacy preservation.\n> - **Options Considered**:\n>   1. Submit full password hashes to breach services\n>   2. Use k-anonymity with hash prefixes (HaveIBeenPwned model)\n>   3. Download full breach databases locally\n>   4. Skip breach checking entirely\n> - **Decision**: Use k-anonymity with hash prefixes\n> - **Rationale**: Provides meaningful security checking while preserving privacy. Hash prefixes (first 5 characters) create anonymity sets of thousands of hashes. No full passwords or complete hashes transmitted.\n> - **Consequences**: Requires careful implementation of prefix matching and local verification. Adds network dependency but with privacy protection.\n\n| Breach Checking Option | Privacy Level | Security Effectiveness | Operational Complexity | Network Dependency |\n|-----------------------|---------------|----------------------|------------------------|-------------------|\n| Full Hash Submission | Poor | Excellent | Low | High |\n| k-Anonymity Prefixes | Excellent | Very Good | Medium | High |\n| Local Database | Excellent | Good | Very High | Low |\n| No Breach Checking | N/A | Poor | None | None |\n\nThe breach monitoring architecture centers around a `BreachMonitoringService` that integrates with external threat intelligence APIs while maintaining strict privacy and performance requirements.\n\n#### Breach Monitoring Service Architecture\n\n| Component | Type | Description |\n|-----------|------|-------------|\n| `BreachMonitoringService` | class | Main service coordinating breach checking operations |\n| `api_clients` | dict[str, BreachAPIClient] | Registry of breach checking service clients |\n| `cache_manager` | BreachCacheManager | Local caching for breach check results |\n| `privacy_manager` | PrivacyPreservingHasher | Handles k-anonymity and prefix generation |\n| `monitoring_config` | BreachMonitoringConfig | Configuration for breach checking behavior |\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `register_breach_service(name, client)` | name: str, client: BreachAPIClient | None | Register new breach checking service |\n| `check_password_breach(password, services)` | password: str, services: list[str] | BreachCheckResult | Check password against specified breach services |\n| `check_hash_breach(password_hash, services)` | password_hash: str, services: list[str] | BreachCheckResult | Check existing hash against breach services |\n| `enable_continuous_monitoring(user_id)` | user_id: str | None | Enable ongoing breach monitoring for user |\n| `get_breach_statistics()` | None | dict | Return monitoring statistics and health metrics |\n\n#### k-Anonymity Implementation\n\nThe k-anonymity approach for privacy-preserving breach checking works by submitting only a prefix of the password hash to external services, then performing local verification of the complete hash against the returned dataset.\n\n**Hash Prefix Generation Process:**\n1. **Password Hashing**: The input password is hashed using SHA-1 (the standard for breach databases) to produce a 40-character hexadecimal hash\n2. **Prefix Extraction**: The first 5 characters of the hash are extracted as the anonymity prefix\n3. **API Request**: Only the 5-character prefix is submitted to the breach service\n4. **Response Processing**: The service returns all breach hashes that share the same prefix (typically 800-1000 hashes)\n5. **Local Verification**: The complete hash is checked locally against the returned set to determine breach status\n\n| Step | Input | Process | Output | Privacy Impact |\n|------|-------|---------|--------|----------------|\n| 1 | Password: \"password123\" | SHA-1 Hash | \"482c811da5d5b4bc6d497ffa98491e38\" | Full password protected |\n| 2 | Full Hash | Extract Prefix | \"482c8\" | Hash anonymized in set of ~1000 |\n| 3 | Prefix Only | API Request | List of ~1000 hashes starting with \"482c8\" | No individual identification possible |\n| 4 | Full Hash + Response | Local Matching | Match Found: True/False | Full privacy maintained |\n\n#### Breach API Client Interface\n\nThe `BreachAPIClient` abstract base class enables integration with multiple breach checking services while maintaining consistent behavior patterns.\n\n| Method | Parameters | Returns | Description |\n|--------|------------|---------|-------------|\n| `check_hash_prefix(hash_prefix)` | hash_prefix: str | PrefixCheckResult | Query service for hashes matching prefix |\n| `get_service_metadata()` | None | ServiceMetadata | Return service capabilities and update frequency |\n| `estimate_request_cost(hash_prefix)` | hash_prefix: str | RequestCostEstimate | Estimate API cost and timing for request |\n| `validate_service_health()` | None | HealthCheckResult | Verify service availability and response quality |\n\n#### HaveIBeenPwned Client Implementation\n\nThe HaveIBeenPwned service client implements the most widely-used breach checking API:\n\n| Configuration Parameter | Type | Default | Description |\n|------------------------|------|---------|-------------|\n| `api_endpoint` | str | \"https://api.pwnedpasswords.com/range/\" | Base URL for API requests |\n| `request_timeout_seconds` | int | 5 | Maximum time to wait for API response |\n| `rate_limit_requests_per_minute` | int | 100 | Maximum requests per minute to avoid throttling |\n| `retry_attempts` | int | 3 | Number of retry attempts for failed requests |\n| `user_agent` | str | Application-specific | User agent string for API requests |\n\nThe client handles the specific response format from HaveIBeenPwned, which returns data in the format:\n```\nHASH_SUFFIX:OCCURRENCE_COUNT\nHASH_SUFFIX:OCCURRENCE_COUNT\n...\n```\n\nWhere HASH_SUFFIX is the remaining 35 characters of each hash that shares the requested prefix, and OCCURRENCE_COUNT is the number of times that password appeared in breach databases.\n\n#### Caching Strategy for Breach Results\n\nBreach checking results are cached locally to improve performance and reduce API dependency:\n\n| Cache Type | Duration | Invalidation Strategy | Storage Location |\n|------------|----------|----------------------|------------------|\n| Prefix Results | 24 hours | Time-based expiration | Memory + Disk |\n| Negative Results | 7 days | Manual invalidation on breach updates | Disk only |\n| Service Health | 1 hour | Error-based invalidation | Memory only |\n| Rate Limit State | 1 minute | Rolling window reset | Memory only |\n\nThe caching system must balance performance with security effectiveness. Cached negative results (passwords not found in breaches) can be stored longer than positive results, since new breach databases are published relatively infrequently.\n\n#### Integration with Password Registration and Verification\n\nBreach monitoring integrates with both password registration (preventing use of known breached passwords) and ongoing monitoring (alerting users when their existing passwords appear in new breaches).\n\n**Registration-Time Breach Checking:**\n```\nPassword Input → Policy Validation → Breach Check → Hash Generation → Storage\n     ↓                    ↓              ↓              ↓           ↓\nRaw Password → PolicyResult → BreachResult → HashRecord → Database\n```\n\n**Ongoing Breach Monitoring:**\n```\nPeriodic Job → Retrieve User Hashes → Check Against New Breaches → Alert Users\n     ↓                ↓                        ↓                      ↓\nScheduler → Hash Database → Breach Services → Notification System\n```\n\n#### Asynchronous Monitoring Implementation\n\nContinuous breach monitoring requires background processing that doesn't block user authentication:\n\n| Component | Responsibility | Execution Pattern | Failure Handling |\n|-----------|----------------|-------------------|------------------|\n| `BreachMonitoringScheduler` | Schedule periodic breach checks | Cron-like scheduling | Exponential backoff on failures |\n| `BatchBreachChecker` | Process multiple hashes efficiently | Batch API requests | Individual hash retry on batch failure |\n| `NotificationManager` | Alert users of breached passwords | Async message queuing | Dead letter queue for failed notifications |\n| `MonitoringMetrics` | Track monitoring effectiveness | Real-time metrics collection | Graceful degradation on metrics failure |\n\n#### Privacy and Security Considerations\n\nBreach monitoring introduces several privacy and security considerations that must be carefully managed:\n\n**Data Minimization**: Only hash prefixes are transmitted to external services, and full hashes are processed locally. No plain text passwords ever leave the system.\n\n**Service Provider Trust**: While hash prefixes provide k-anonymity, there's still trust required in external breach checking services. The system should support multiple providers and allow organizations to choose their preferred services.\n\n**Network Security**: All communications with breach checking services must use TLS encryption and certificate validation to prevent man-in-the-middle attacks.\n\n**Rate Limiting and Abuse Prevention**: Breach checking services have rate limits that must be respected to maintain service availability. The system implements request queuing and backoff strategies.\n\n#### Advanced Monitoring Features\n\n**Breach Severity Assessment**: Not all breaches are equal in terms of risk. The system can evaluate breach severity based on factors like the quality of original hashing, breach size, and data sensitivity.\n\n| Severity Factor | Weight | Assessment Criteria | Impact on User Notification |\n|----------------|--------|-------------------|---------------------------|\n| Original Hash Quality | 0.4 | MD5/SHA-1 (high risk) vs bcrypt/Argon2 (lower risk) | Immediate vs delayed notification |\n| Breach Size | 0.3 | Number of affected accounts | Priority level in notification queue |\n| Data Sensitivity | 0.2 | Financial vs social media accounts | Notification urgency and content |\n| Breach Recency | 0.1 | How recently breach was discovered | Notification timing |\n\n**User Response Automation**: When breached passwords are detected, the system can automatically trigger security responses:\n\n| Response Type | Trigger Condition | Automation Level | User Impact |\n|---------------|-------------------|------------------|-------------|\n| Force Password Reset | High severity breach | Automatic | Immediate login block |\n| Recommend Password Change | Medium severity breach | User choice | Dashboard notification |\n| Security Audit Log | Any breach detection | Automatic | Background logging |\n| Account Monitoring | Repeated breach exposure | Enhanced | Additional security checks |\n\n#### Common Pitfalls in Breach Monitoring\n\n⚠️ **Pitfall: Submitting Full Hashes to External Services**\nTransmitting complete password hashes to breach checking services creates privacy risks and potential attack vectors. Always use k-anonymity techniques with hash prefixes to protect user privacy while maintaining security effectiveness.\n\n⚠️ **Pitfall: Blocking Authentication on Breach Service Failures**\nMaking breach checking a hard requirement for authentication can create denial-of-service vulnerabilities when external services are unavailable. Implement graceful degradation where breach checking failures log warnings but don't prevent legitimate authentication.\n\n⚠️ **Pitfall: Ignoring Rate Limits and Service Terms**\nBreach checking services have usage limits and terms of service that must be respected. Implement proper rate limiting, request queuing, and exponential backoff to avoid service disruption and potential API key revocation.\n\n⚠️ **Pitfall: Storing Breach Results Without Expiration**\nCached breach checking results can become stale as new breach databases are published. Implement appropriate cache expiration policies and invalidation strategies to ensure breach checking remains effective over time.\n\n⚠️ **Pitfall: Revealing Breach Status in Error Messages**\nExposing whether specific passwords have been breached in API error messages or logs can reveal sensitive information. Design error handling and logging to protect breach status information while still providing useful debugging information.\n\n### Implementation Guidance\n\nThis implementation guidance provides the foundational code structures and integration patterns needed to extend the password hashing system with policy validation and breach monitoring capabilities.\n\n#### Technology Recommendations\n\n| Component | Simple Option | Advanced Option | Production Considerations |\n|-----------|---------------|----------------|--------------------------|\n| HTTP Client | `requests` library | `aiohttp` with async/await | Connection pooling, timeout handling |\n| Caching | In-memory dictionary | `Redis` with expiration | Distributed caching, persistence |\n| Background Jobs | `threading.Timer` | `Celery` with Redis broker | Scalability, failure recovery |\n| Configuration | JSON/YAML files | `pydantic` with environment variables | Validation, type safety |\n| Logging | Python `logging` module | Structured logging with `structlog` | Log aggregation, correlation IDs |\n\n#### Recommended File Structure\n\n```\npassword_hashing/\n  extensions/\n    __init__.py\n    policy/\n      __init__.py\n      engine.py              ← PasswordPolicyEngine\n      rules/\n        __init__.py\n        base.py             ← PolicyRule abstract base\n        length.py           ← LengthRequirementsPolicy  \n        composition.py      ← CharacterCompositionPolicy\n        dictionary.py       ← DictionaryAttackPreventionPolicy\n        entropy.py          ← EntropyBasedStrengthPolicy\n      integration.py        ← Integration with main hashing system\n    breach_monitoring/\n      __init__.py\n      service.py           ← BreachMonitoringService\n      clients/\n        __init__.py\n        base.py            ← BreachAPIClient abstract base\n        haveibeenpwned.py  ← HaveIBeenPwned client implementation\n        custom.py          ← Custom breach service clients\n      cache.py             ← BreachCacheManager\n      privacy.py           ← Privacy-preserving hash operations\n      monitoring.py        ← Continuous monitoring and alerting\n  tests/\n    extensions/\n      test_policy_engine.py\n      test_breach_monitoring.py\n      test_integration.py\n```\n\n#### Password Policy Engine Infrastructure Code\n\nComplete implementation of the policy validation framework:\n\n```python\n\"\"\"\nPassword Policy Engine - Complete Infrastructure\nProvides extensible framework for password validation rules.\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, List, Any, Optional, Set\nfrom dataclasses import dataclass\nfrom enum import Enum\nimport re\nimport hashlib\nfrom datetime import datetime, timedelta\n\nclass PolicySeverity(Enum):\n    \"\"\"Severity levels for policy violations.\"\"\"\n    INFO = \"info\"\n    WARNING = \"warning\" \n    ERROR = \"error\"\n    CRITICAL = \"critical\"\n\n@dataclass\nclass RuleEvaluationResult:\n    \"\"\"Result from evaluating a single policy rule.\"\"\"\n    rule_name: str\n    passed: bool\n    severity: PolicySeverity\n    message: str\n    details: Dict[str, Any]\n    evaluation_time_ms: float\n\n@dataclass  \nclass PolicyEvaluationResult:\n    \"\"\"Complete result from policy engine evaluation.\"\"\"\n    overall_passed: bool\n    rule_results: List[RuleEvaluationResult]\n    warnings: List[str]\n    errors: List[str]\n    evaluation_metadata: Dict[str, Any]\n\nclass PolicyRule(ABC):\n    \"\"\"Abstract base class for all password policy rules.\"\"\"\n    \n    def __init__(self, config: Dict[str, Any]):\n        self.config = config\n        self.validate_config()\n    \n    @abstractmethod\n    def evaluate(self, password: str, context: Dict[str, Any]) -> RuleEvaluationResult:\n        \"\"\"Evaluate password against this rule.\"\"\"\n        pass\n    \n    @abstractmethod\n    def get_requirements(self) -> Dict[str, Any]:\n        \"\"\"Return human-readable requirements description.\"\"\"\n        pass\n    \n    @abstractmethod\n    def get_configuration_schema(self) -> Dict[str, Any]:\n        \"\"\"Return JSON schema for configuration validation.\"\"\"\n        pass\n    \n    def validate_config(self) -> None:\n        \"\"\"Validate configuration against schema.\"\"\"\n        # Implementation would use jsonschema library\n        pass\n    \n    def estimate_evaluation_cost(self) -> float:\n        \"\"\"Return relative computational cost (1.0 = baseline).\"\"\"\n        return 1.0\n\nclass PasswordPolicyEngine:\n    \"\"\"Main engine for coordinating password policy evaluation.\"\"\"\n    \n    def __init__(self):\n        self.policy_registry: Dict[str, type] = {}\n        self.active_policies: List[str] = []\n        self.policy_configurations: Dict[str, Dict[str, Any]] = {}\n        self.policy_instances: Dict[str, PolicyRule] = {}\n        \n    def register_policy(self, name: str, rule_class: type) -> None:\n        \"\"\"Register a new policy rule class.\"\"\"\n        if not issubclass(rule_class, PolicyRule):\n            raise ValueError(f\"Policy {name} must inherit from PolicyRule\")\n        self.policy_registry[name] = rule_class\n        \n    def configure_policy(self, name: str, **params) -> None:\n        \"\"\"Configure parameters for a specific policy.\"\"\"\n        if name not in self.policy_registry:\n            raise ValueError(f\"Unknown policy: {name}\")\n        self.policy_configurations[name] = params\n        # Recreate instance with new configuration\n        if name in self.policy_instances:\n            self.policy_instances[name] = self.policy_registry[name](params)\n    \n    def enable_policies(self, policy_names: List[str]) -> None:\n        \"\"\"Enable specified policies for evaluation.\"\"\"\n        for name in policy_names:\n            if name not in self.policy_registry:\n                raise ValueError(f\"Unknown policy: {name}\")\n        \n        self.active_policies = policy_names\n        # Create policy instances\n        for name in policy_names:\n            config = self.policy_configurations.get(name, {})\n            self.policy_instances[name] = self.policy_registry[name](config)\n    \n    def evaluate_password(self, password: str, context: Optional[Dict[str, Any]] = None) -> PolicyEvaluationResult:\n        \"\"\"Evaluate password against all active policies.\"\"\"\n        if context is None:\n            context = {}\n            \n        rule_results = []\n        warnings = []\n        errors = []\n        overall_passed = True\n        \n        # Sort policies by evaluation cost (cheapest first)\n        sorted_policies = sorted(\n            self.active_policies,\n            key=lambda name: self.policy_instances[name].estimate_evaluation_cost()\n        )\n        \n        start_time = datetime.now()\n        \n        for policy_name in sorted_policies:\n            policy = self.policy_instances[policy_name]\n            \n            try:\n                result = policy.evaluate(password, context)\n                rule_results.append(result)\n                \n                if not result.passed:\n                    if result.severity in [PolicySeverity.ERROR, PolicySeverity.CRITICAL]:\n                        errors.append(result.message)\n                        overall_passed = False\n                    else:\n                        warnings.append(result.message)\n                        \n            except Exception as e:\n                # Policy evaluation should never crash the system\n                error_result = RuleEvaluationResult(\n                    rule_name=policy_name,\n                    passed=False,\n                    severity=PolicySeverity.CRITICAL,\n                    message=f\"Policy evaluation failed: {str(e)}\",\n                    details={\"exception_type\": type(e).__name__},\n                    evaluation_time_ms=0.0\n                )\n                rule_results.append(error_result)\n                errors.append(error_result.message)\n                overall_passed = False\n        \n        total_time = (datetime.now() - start_time).total_seconds() * 1000\n        \n        return PolicyEvaluationResult(\n            overall_passed=overall_passed,\n            rule_results=rule_results,\n            warnings=warnings,\n            errors=errors,\n            evaluation_metadata={\n                \"total_evaluation_time_ms\": total_time,\n                \"policies_evaluated\": len(sorted_policies),\n                \"context_provided\": bool(context)\n            }\n        )\n```\n\n#### Breach Monitoring Service Infrastructure Code\n\nComplete implementation of the breach monitoring framework:\n\n```python\n\"\"\"\nBreach Monitoring Service - Complete Infrastructure\nProvides privacy-preserving password breach checking capabilities.\n\"\"\"\n\nimport hashlib\nimport time\nimport asyncio\nfrom typing import Dict, List, Optional, Set, Tuple\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nfrom abc import ABC, abstractmethod\nimport requests\nfrom urllib.parse import urljoin\n\n@dataclass\nclass BreachCheckResult:\n    \"\"\"Result from checking password against breach databases.\"\"\"\n    is_breached: bool\n    breach_count: int\n    services_checked: List[str]\n    check_timestamp: datetime\n    privacy_preserved: bool\n    cache_hit: bool\n    response_time_ms: float\n\n@dataclass\nclass ServiceMetadata:\n    \"\"\"Metadata about a breach checking service.\"\"\"\n    service_name: str\n    last_updated: datetime\n    database_size_estimate: int\n    api_version: str\n    rate_limit_per_minute: int\n    supports_batch: bool\n\nclass BreachAPIClient(ABC):\n    \"\"\"Abstract base class for breach checking service clients.\"\"\"\n    \n    @abstractmethod\n    async def check_hash_prefix(self, hash_prefix: str) -> Tuple[List[str], int]:\n        \"\"\"Check hash prefix against service. Returns (hash_suffixes, breach_counts).\"\"\"\n        pass\n    \n    @abstractmethod\n    def get_service_metadata(self) -> ServiceMetadata:\n        \"\"\"Return metadata about this service.\"\"\"\n        pass\n    \n    @abstractmethod\n    def validate_service_health(self) -> bool:\n        \"\"\"Check if service is available and responding correctly.\"\"\"\n        pass\n\nclass HaveIBeenPwnedClient(BreachAPIClient):\n    \"\"\"Client for HaveIBeenPwned Pwned Passwords API.\"\"\"\n    \n    def __init__(self, \n                 api_endpoint: str = \"https://api.pwnedpasswords.com/range/\",\n                 request_timeout: int = 5,\n                 rate_limit_per_minute: int = 100,\n                 user_agent: str = \"PasswordHashingSystem/1.0\"):\n        self.api_endpoint = api_endpoint\n        self.request_timeout = request_timeout\n        self.rate_limit_per_minute = rate_limit_per_minute\n        self.user_agent = user_agent\n        self.last_request_time = 0.0\n        \n    async def check_hash_prefix(self, hash_prefix: str) -> Tuple[List[str], List[int]]:\n        \"\"\"Check 5-character hash prefix against HaveIBeenPwned.\"\"\"\n        if len(hash_prefix) != 5:\n            raise ValueError(\"Hash prefix must be exactly 5 characters\")\n            \n        # Enforce rate limiting\n        await self._enforce_rate_limit()\n        \n        url = urljoin(self.api_endpoint, hash_prefix.upper())\n        headers = {\"User-Agent\": self.user_agent}\n        \n        start_time = time.time()\n        try:\n            response = requests.get(url, headers=headers, timeout=self.request_timeout)\n            response.raise_for_status()\n            \n            # Parse response format: SUFFIX:COUNT\\nSUFFIX:COUNT\\n...\n            hash_suffixes = []\n            breach_counts = []\n            \n            for line in response.text.strip().split('\\n'):\n                if ':' in line:\n                    suffix, count_str = line.split(':', 1)\n                    hash_suffixes.append(suffix)\n                    breach_counts.append(int(count_str))\n            \n            return hash_suffixes, breach_counts\n            \n        except requests.RequestException as e:\n            raise Exception(f\"HaveIBeenPwned API request failed: {str(e)}\")\n        finally:\n            self.last_request_time = time.time()\n    \n    def get_service_metadata(self) -> ServiceMetadata:\n        \"\"\"Return HaveIBeenPwned service metadata.\"\"\"\n        return ServiceMetadata(\n            service_name=\"HaveIBeenPwned\",\n            last_updated=datetime.now() - timedelta(days=1),  # Approximate\n            database_size_estimate=847000000,  # Approximate as of 2024\n            api_version=\"3\",\n            rate_limit_per_minute=self.rate_limit_per_minute,\n            supports_batch=False\n        )\n    \n    def validate_service_health(self) -> bool:\n        \"\"\"Test service health with known hash prefix.\"\"\"\n        try:\n            # Use known hash prefix that should always return results\n            test_prefix = \"5e884\"  # Prefix of SHA-1(\"hello\")\n            suffixes, counts = asyncio.run(self.check_hash_prefix(test_prefix))\n            return len(suffixes) > 0\n        except:\n            return False\n    \n    async def _enforce_rate_limit(self) -> None:\n        \"\"\"Enforce rate limiting between requests.\"\"\"\n        min_interval = 60.0 / self.rate_limit_per_minute\n        time_since_last = time.time() - self.last_request_time\n        if time_since_last < min_interval:\n            await asyncio.sleep(min_interval - time_since_last)\n\nclass BreachCacheManager:\n    \"\"\"Manages caching of breach checking results.\"\"\"\n    \n    def __init__(self, \n                 prefix_cache_ttl_hours: int = 24,\n                 negative_cache_ttl_days: int = 7):\n        self.prefix_cache: Dict[str, Tuple[List[str], List[int], datetime]] = {}\n        self.negative_cache: Set[str] = set()  # Hashes known to not be breached\n        self.prefix_cache_ttl = timedelta(hours=prefix_cache_ttl_hours)\n        self.negative_cache_ttl = timedelta(days=negative_cache_ttl_days)\n        \n    def get_prefix_result(self, hash_prefix: str) -> Optional[Tuple[List[str], List[int]]]:\n        \"\"\"Get cached result for hash prefix.\"\"\"\n        if hash_prefix in self.prefix_cache:\n            suffixes, counts, timestamp = self.prefix_cache[hash_prefix]\n            if datetime.now() - timestamp < self.prefix_cache_ttl:\n                return suffixes, counts\n            else:\n                # Cache expired\n                del self.prefix_cache[hash_prefix]\n        return None\n    \n    def cache_prefix_result(self, hash_prefix: str, suffixes: List[str], counts: List[int]) -> None:\n        \"\"\"Cache result for hash prefix.\"\"\"\n        self.prefix_cache[hash_prefix] = (suffixes, counts, datetime.now())\n    \n    def is_known_clean(self, full_hash: str) -> bool:\n        \"\"\"Check if hash is in negative cache (known not breached).\"\"\"\n        return full_hash in self.negative_cache\n    \n    def mark_clean(self, full_hash: str) -> None:\n        \"\"\"Add hash to negative cache.\"\"\"\n        self.negative_cache.add(full_hash)\n    \n    def clear_expired_cache(self) -> None:\n        \"\"\"Remove expired cache entries.\"\"\"\n        now = datetime.now()\n        \n        # Clear expired prefix cache\n        expired_prefixes = [\n            prefix for prefix, (_, _, timestamp) in self.prefix_cache.items()\n            if now - timestamp >= self.prefix_cache_ttl\n        ]\n        for prefix in expired_prefixes:\n            del self.prefix_cache[prefix]\n\nclass BreachMonitoringService:\n    \"\"\"Main service for coordinating breach checking operations.\"\"\"\n    \n    def __init__(self):\n        self.api_clients: Dict[str, BreachAPIClient] = {}\n        self.cache_manager = BreachCacheManager()\n        self.default_services = []\n        \n    def register_breach_service(self, name: str, client: BreachAPIClient) -> None:\n        \"\"\"Register a new breach checking service client.\"\"\"\n        self.api_clients[name] = client\n        \n    async def check_password_breach(self, \n                                  password: str, \n                                  services: Optional[List[str]] = None) -> BreachCheckResult:\n        \"\"\"Check password against breach databases using k-anonymity.\"\"\"\n        if services is None:\n            services = self.default_services\n            \n        # Generate SHA-1 hash (standard for breach databases)\n        password_hash = hashlib.sha1(password.encode('utf-8')).hexdigest().upper()\n        return await self.check_hash_breach(password_hash, services)\n    \n    async def check_hash_breach(self, \n                               password_hash: str, \n                               services: Optional[List[str]] = None) -> BreachCheckResult:\n        \"\"\"Check existing hash against breach databases.\"\"\"\n        start_time = time.time()\n        \n        if services is None:\n            services = self.default_services\n            \n        # Check negative cache first\n        if self.cache_manager.is_known_clean(password_hash):\n            return BreachCheckResult(\n                is_breached=False,\n                breach_count=0,\n                services_checked=services,\n                check_timestamp=datetime.now(),\n                privacy_preserved=True,\n                cache_hit=True,\n                response_time_ms=(time.time() - start_time) * 1000\n            )\n        \n        # Extract 5-character prefix for k-anonymity\n        hash_prefix = password_hash[:5]\n        hash_suffix = password_hash[5:]\n        \n        is_breached = False\n        total_breach_count = 0\n        services_checked = []\n        cache_hit = False\n        \n        for service_name in services:\n            if service_name not in self.api_clients:\n                continue\n                \n            client = self.api_clients[service_name]\n            \n            try:\n                # Check cache first\n                cached_result = self.cache_manager.get_prefix_result(hash_prefix)\n                if cached_result:\n                    suffixes, counts = cached_result\n                    cache_hit = True\n                else:\n                    # Make API request\n                    suffixes, counts = await client.check_hash_prefix(hash_prefix)\n                    self.cache_manager.cache_prefix_result(hash_prefix, suffixes, counts)\n                \n                # Check if our hash suffix is in the results\n                for suffix, count in zip(suffixes, counts):\n                    if suffix.upper() == hash_suffix:\n                        is_breached = True\n                        total_breach_count += count\n                        break\n                \n                services_checked.append(service_name)\n                \n            except Exception as e:\n                # Log error but continue with other services\n                print(f\"Breach check failed for service {service_name}: {str(e)}\")\n        \n        # Cache negative results\n        if not is_breached:\n            self.cache_manager.mark_clean(password_hash)\n        \n        return BreachCheckResult(\n            is_breached=is_breached,\n            breach_count=total_breach_count,\n            services_checked=services_checked,\n            check_timestamp=datetime.now(),\n            privacy_preserved=True,\n            cache_hit=cache_hit,\n            response_time_ms=(time.time() - start_time) * 1000\n        )\n```\n\n#### Core Logic Skeleton: Policy Rule Implementation\n\n```python\nclass LengthRequirementsPolicy(PolicyRule):\n    \"\"\"Validates password meets length requirements.\"\"\"\n    \n    def evaluate(self, password: str, context: Dict[str, Any]) -> RuleEvaluationResult:\n        start_time = time.time()\n        \n        # TODO 1: Extract configuration parameters (minimum_length, maximum_length)\n        # TODO 2: Calculate password length considering Unicode encoding\n        # TODO 3: Check against minimum length requirement\n        # TODO 4: Check against maximum length requirement  \n        # TODO 5: Generate appropriate error messages for violations\n        # TODO 6: Return RuleEvaluationResult with timing information\n        \n        # Hint: Use len(password.encode('utf-8')) for byte length\n        # Hint: Consider both character count and byte count depending on requirements\n        pass\n    \n    def get_requirements(self) -> Dict[str, Any]:\n        # TODO 1: Return human-readable description of length requirements\n        # TODO 2: Include both minimum and maximum in description\n        # TODO 3: Specify whether requirement is characters or bytes\n        pass\n    \n    def get_configuration_schema(self) -> Dict[str, Any]:\n        # TODO 1: Return JSON schema defining valid configuration\n        # TODO 2: Include type constraints and value ranges\n        # TODO 3: Mark required vs optional parameters\n        pass\n```\n\n#### Core Logic Skeleton: Integration Layer\n\n```python\nclass PasswordServiceWithExtensions:\n    \"\"\"Enhanced password service with policy and breach checking.\"\"\"\n    \n    def __init__(self, hasher: ModernPasswordHasher):\n        self.hasher = hasher\n        self.policy_engine = PasswordPolicyEngine()\n        self.breach_monitor = BreachMonitoringService()\n        self._setup_default_policies()\n        self._setup_default_breach_services()\n    \n    async def register_password_with_validation(self, \n                                              user_id: str, \n                                              password: str,\n                                              enable_breach_check: bool = True) -> Dict[str, Any]:\n        \"\"\"Register password with full policy and breach validation.\"\"\"\n        \n        # TODO 1: Run password through policy validation\n        # TODO 2: If breach checking enabled, check against breach databases\n        # TODO 3: If all validations pass, generate hash using existing hasher\n        # TODO 4: Store hash record and validation metadata\n        # TODO 5: Return comprehensive result with all validation details\n        \n        # Hint: Use asyncio.gather() to run breach check in parallel with other operations\n        # Hint: Aggregate all validation results into single response structure\n        pass\n    \n    def _setup_default_policies(self) -> None:\n        \"\"\"Configure standard password policies.\"\"\"\n        \n        # TODO 1: Register length requirements policy\n        # TODO 2: Register character composition policy  \n        # TODO 3: Register dictionary attack prevention policy\n        # TODO 4: Configure reasonable defaults for each policy\n        # TODO 5: Enable all registered policies\n        \n        pass\n    \n    def _setup_default_breach_services(self) -> None:\n        \"\"\"Configure breach monitoring services.\"\"\"\n        \n        # TODO 1: Register HaveIBeenPwned client\n        # TODO 2: Configure rate limiting and caching\n        # TODO 3: Set as default service for breach checking\n        # TODO 4: Initialize background monitoring if configured\n        \n        pass\n```\n\n#### Milestone Checkpoint\n\nAfter implementing the extensions framework:\n\n**Policy Engine Validation:**\n```bash\npython -m pytest tests/extensions/test_policy_engine.py -v\n```\n\nExpected output should show:\n- All policy rules evaluate correctly with various password inputs\n- Configuration validation catches invalid parameters\n- Policy engine handles rule failures gracefully\n- Performance is acceptable for typical password validation flows\n\n**Breach Monitoring Validation:**\n```bash  \npython -c \"\nimport asyncio\nfrom extensions.breach_monitoring.service import BreachMonitoringService\nfrom extensions.breach_monitoring.clients.haveibeenpwned import HaveIBeenPwnedClient\n\nasync def test_breach_check():\n    service = BreachMonitoringService()\n    service.register_breach_service('hibp', HaveIBeenPwnedClient())\n    \n    # Test known breached password\n    result = await service.check_password_breach('password123', ['hibp'])\n    print(f'Breached: {result.is_breached}, Count: {result.breach_count}')\n    \n    # Test likely clean password  \n    result = await service.check_password_breach('MyVeryUniquePassword2024!', ['hibp'])\n    print(f'Breached: {result.is_breached}, Privacy preserved: {result.privacy_preserved}')\n\nasyncio.run(test_breach_check())\n\"\n```\n\nExpected behavior:\n- Known weak passwords return `is_breached=True` with breach count\n- Strong unique passwords return `is_breached=False` \n- All requests preserve privacy using k-anonymity\n- Caching improves performance on subsequent requests\n- Service gracefully handles API failures and rate limiting\n\n#### Debugging Tips\n\n| Symptom | Likely Cause | Diagnosis | Fix |\n|---------|--------------|-----------|-----|\n| Policy validation always fails | Configuration not loaded correctly | Check policy_configurations dict | Verify config loading and policy registration order |\n| Breach checking times out | Rate limiting or network issues | Check request timing and API limits | Implement proper rate limiting and timeout handling |\n| Cache not improving performance | Cache keys not matching properly | Log cache hits/misses | Ensure consistent hash formatting and key generation |\n| Privacy concerns with breach checking | Full hashes being transmitted | Review API client implementation | Verify only 5-character prefixes are sent to external services |\n| Background monitoring consuming too much CPU | Inefficient batch processing | Profile monitoring job performance | Implement proper batching and sleep intervals |\n\n\n## Glossary\n\n> **Milestone(s):** All milestones (cryptographic and security terminology is essential across all implementation phases from basic salt/hash verification through key stretching validation to modern algorithm integration)\n\n### Mental Model: The Technical Reference Library\n\nThink of this glossary like a specialized technical reference library in a cryptography research institute. Just as researchers need precise definitions for mathematical concepts, security properties, and algorithmic terminology to communicate effectively and avoid dangerous misunderstandings, developers implementing password hashing systems need exact definitions of cryptographic terms, algorithm names, and security concepts. Each term in this library has been carefully defined with its specific meaning in the context of password security, preventing the kind of ambiguous interpretations that lead to security vulnerabilities.\n\nThe library is organized into sections - cryptographic algorithms, security properties, attack techniques, and implementation concepts - allowing developers to quickly locate the precise meaning of terms they encounter while building secure password storage systems. Understanding these definitions is crucial because in cryptography, small misunderstandings about terminology often lead to implementation mistakes that completely compromise security.\n\n### Cryptographic Algorithms and Standards\n\nThe following table defines the specific cryptographic algorithms and standards referenced throughout this password hashing system design:\n\n| Term | Definition | Context in Password Hashing |\n|------|------------|----------------------------|\n| **SHA-256** | Secure Hash Algorithm producing 256-bit digest from arbitrary input data using cryptographic one-way function | Used in Milestone 1 for basic password hashing with salt, providing collision resistance and preimage resistance |\n| **PBKDF2** | Password-Based Key Derivation Function 2, applying iterative HMAC to derive keys from passwords with configurable cost | Core algorithm in Milestone 2 for key stretching, using HMAC-SHA256 with minimum 100,000 iterations |\n| **HMAC** | Hash-based Message Authentication Code combining cryptographic hash with secret key for integrity and authenticity | Internal primitive within PBKDF2 implementation, using SHA-256 as underlying hash function |\n| **bcrypt** | Blowfish-based password hashing algorithm with built-in salt generation and adaptive cost factor | Primary modern algorithm in Milestone 3, with minimum cost factor 12 for current hardware capabilities |\n| **Argon2** | Memory-hard password hashing algorithm designed to resist GPU and ASIC attacks through high memory usage | Advanced modern algorithm option in Milestone 3, specifically Argon2id variant balancing side-channel resistance |\n| **scrypt** | Memory-hard key derivation function using sequential memory access patterns to increase attack cost | Alternative modern algorithm mentioned for comparison, though not implemented in core milestones |\n| **PBKDF2-HMAC-SHA256** | Specific PBKDF2 variant using HMAC with SHA-256 as pseudorandom function | Exact specification used in Milestone 2 implementation |\n| **Argon2id** | Argon2 variant combining data-independent and data-dependent memory access for balanced security | Recommended Argon2 variant preventing both timing attacks and memory reduction attacks |\n| **Base64** | Binary-to-text encoding representing binary data using 64-character alphabet | Used for encoding salt and hash values in string representations |\n| **Hexadecimal** | Base-16 encoding representing binary data using digits 0-9 and letters A-F | Alternative encoding for displaying binary hash and salt values |\n\n### Security Properties and Concepts\n\nSecurity properties define the mathematical and cryptographic guarantees that password hashing algorithms must provide to protect against various attack techniques:\n\n| Term | Definition | Importance for Password Security |\n|------|------------|--------------------------------|\n| **cryptographic security** | Protection using mathematical algorithms and randomness with computational hardness assumptions | Foundation ensuring password hashes cannot be reversed through mathematical analysis |\n| **preimage resistance** | Cryptographic property making it computationally infeasible to find input producing specific hash output | Prevents attackers from working backward from stolen hash to discover original password |\n| **collision resistance** | Cryptographic property making it computationally infeasible to find two different inputs producing same hash | Prevents attackers from finding alternative passwords that hash to same value |\n| **one-way function** | Mathematical function easy to compute forward but computationally infeasible to reverse | Fundamental property ensuring hashed passwords cannot be mathematically inverted |\n| **entropy** | Measure of randomness or unpredictability in data, typically expressed in bits | Critical for salt generation - insufficient entropy makes salt values predictable |\n| **cryptographic randomness** | Mathematically unpredictable value generation using entropy sources and cryptographic algorithms | Required for generating unique salts that resist statistical analysis and prediction |\n| **side-channel resistance** | Protection against information leakage through execution patterns, timing, or resource usage | Essential for preventing timing attacks during password verification comparisons |\n| **computational hardness** | Mathematical assumption that certain problems require significant computational resources to solve | Basis for security claims - breaking hash requires more computation than attacker can afford |\n| **perfect forward secrecy** | Security property ensuring compromise of long-term keys doesn't reveal past session data | Not directly applicable to password hashing but influences key derivation design |\n\n### Attack Techniques and Vulnerabilities\n\nUnderstanding attack techniques helps developers recognize what their password hashing implementation must defend against:\n\n| Term | Definition | How Password Hashing Defends |\n|------|------------|----------------------------|\n| **rainbow table** | Precomputed hash-to-password lookup database covering common passwords and hash functions | Defeated by unique salt values making precomputation infeasible |\n| **brute force attack** | Systematic attempt to guess passwords by trying all possible combinations | Slowed by key stretching algorithms requiring significant computation per guess |\n| **dictionary attack** | Password guessing using common passwords, words, and known patterns | Combined with salting and key stretching to increase attack cost |\n| **timing attack** | Side-channel attack exploiting execution time differences to extract secret information | Prevented by constant-time comparison functions during password verification |\n| **birthday paradox** | Collision probability analysis showing surprising frequency of duplicates in random data | Considered when choosing salt length to ensure negligible collision probability |\n| **birthday attack** | Cryptographic attack exploiting birthday paradox to find hash collisions more efficiently | Mitigated by using collision-resistant hash functions and sufficient output length |\n| **GPU acceleration** | Using graphics processing units to parallelize password cracking operations | Countered by memory-hard algorithms like Argon2 that don't parallelize efficiently |\n| **ASIC acceleration** | Custom hardware designed specifically for password cracking operations | Resisted by algorithms requiring large memory or irregular access patterns |\n| **offline attack** | Password cracking performed on stolen database without interacting with target system | Primary threat model - assumes attacker has unlimited time with stolen password hashes |\n\n### Salt-Related Terminology\n\nSalt generation and usage involves specific terminology critical for understanding protection against precomputed attacks:\n\n| Term | Definition | Implementation Requirements |\n|------|------------|----------------------------|\n| **salt** | Unique random value preventing precomputed attacks by making each hash computation unique | Must be cryptographically random, at least 16 bytes, stored alongside hash |\n| **salting** | Process of combining random salt value with password before hash computation | Applied before hashing to ensure identical passwords produce different hash values |\n| **salt uniqueness** | Property ensuring each password hash uses different salt value | Achieved through cryptographically secure random generation for each hash operation |\n| **salt length** | Number of bytes in salt value, affecting collision probability and storage requirements | Minimum 16 bytes recommended, 32 bytes provides excellent security margin |\n| **salt format** | Encoding method for representing binary salt data as text | Supports binary, Base64, and hexadecimal formats for different storage systems |\n| **salt concatenation** | Method of combining salt and password data before hash computation | Order and method affect hash output - must be consistent across hash and verification |\n| **pepper** | Secret value stored separately from database and applied during hash computation | Not implemented in core milestones but mentioned as advanced security technique |\n\n### Key Stretching and Iteration Terminology\n\nKey stretching involves specific concepts around making hash computation intentionally expensive:\n\n| Term | Definition | Performance and Security Impact |\n|------|------------|-------------------------------|\n| **key stretching** | Iterative hashing to slow brute force attacks by increasing computation time per password guess | Core security technique making offline attacks computationally expensive |\n| **iteration count** | Number of internal hash rounds in key stretching algorithms | Must be at least 100,000 for PBKDF2, tuned to achieve target computation time |\n| **cost factor** | Algorithm parameter controlling computational expense, typically logarithmic scale | bcrypt uses cost factor 12+ to achieve several hundred millisecond computation time |\n| **time cost** | Argon2 parameter controlling number of iterations through memory | Balanced with memory cost to achieve target computation time |\n| **memory cost** | Argon2 parameter controlling memory usage during hash computation | Measured in kilobytes, typically 64MB+ to resist GPU acceleration |\n| **parallelism** | Number of parallel threads used in Argon2 computation | Usually set to number of CPU cores, affects memory layout and timing |\n| **derived key length** | Length of final key output from key derivation function | Typically 32 bytes for password hashing, matches underlying hash function output |\n| **computational bottleneck** | Intentional performance constraint for security purposes | Key stretching creates bottleneck that affects both legitimate users and attackers |\n\n### Algorithm Agility and Migration Terminology\n\nSupporting multiple algorithms and migration paths involves specific terminology around system evolution:\n\n| Term | Definition | System Design Implications |\n|------|------------|---------------------------|\n| **algorithm agility** | Supporting multiple algorithms with migration between them as security requirements evolve | Requires versioned hash records and migration assessment capabilities |\n| **lazy migration** | Opportunistic hash upgrades during authentication without requiring password reset | Executed when user provides password during normal login process |\n| **migration assessment** | Evaluation of hash upgrade necessity based on algorithm strength and age | Compares current hash against modern security standards and hardware capabilities |\n| **backward compatibility** | Supporting verification of legacy hashes while preferring modern algorithms | Maintains system functionality during gradual migration to stronger algorithms |\n| **version metadata** | Information identifying algorithm and parameters used for specific hash | Stored in hash record to enable correct verification and migration decisions |\n| **deprecation timeline** | Schedule for phasing out legacy algorithms and requiring migration | Balances security improvements against operational disruption |\n| **security decay** | Gradual weakening of protection over time due to hardware improvements | Motivates proactive migration to stronger algorithms and parameters |\n\n### Constant-Time Operations and Timing Security\n\nPreventing timing attacks requires specific implementation techniques and terminology:\n\n| Term | Definition | Security Requirement |\n|------|------------|---------------------|\n| **constant-time comparison** | Comparison taking same execution duration regardless of input values or differences | Essential for password verification to prevent timing-based password recovery |\n| **timing consistency** | Uniform execution duration regardless of input characteristics or code paths | Applied to entire verification process, not just final comparison |\n| **timing attack** | Side-channel attack exploiting execution time differences to extract secret information | Prevented through careful implementation ensuring consistent timing |\n| **side-channel resistance** | Protection against information leakage through execution patterns, timing, or resource usage | Broader concept including timing attacks, power analysis, and electromagnetic emanations |\n| **temporal coupling** | Dependency on external state that may change over time, affecting timing consistency | Avoided by self-contained hash records including all verification parameters |\n| **execution pattern** | Sequence of operations and conditional branches during algorithm execution | Must be independent of secret data to prevent side-channel information leakage |\n\n### Data Format and Storage Terminology\n\nPassword hash storage and serialization involves specific format and encoding concepts:\n\n| Term | Definition | Storage and Interoperability Requirements |\n|------|------------|-------------------------------------------|\n| **hash record** | Complete data structure containing algorithm, salt, hash, parameters, and metadata for password verification | Self-contained unit storing all information needed for verification |\n| **serialization** | Converting hash record data structure to string or binary format for storage | Supports JSON and compact string formats for different storage systems |\n| **self-contained verification** | Hash record contains all information needed for verification without external dependencies | Prevents temporal coupling and ensures verification consistency over time |\n| **immutable archives** | Hash records preserve exact creation-time configuration preventing modification | Maintains verification integrity and supports forensic analysis |\n| **parameter encoding** | Method for storing algorithm-specific configuration within hash record | Enables correct verification and supports algorithm-specific requirements |\n| **version tagging** | Including algorithm version information in hash record for compatibility tracking | Supports migration decisions and backward compatibility requirements |\n\n### Error Handling and Validation Terminology\n\nRobust password hashing systems require comprehensive error handling with specific terminology:\n\n| Term | Definition | Error Handling Strategy |\n|------|------------|------------------------|\n| **graceful degradation** | Maintaining security while handling failures by reducing functionality rather than compromising protection | Refuses operation rather than proceeding with weakened security |\n| **fail-secure behavior** | Security design principle ensuring system fails to secure state rather than insecure state | Critical for password hashing - never store weak hashes due to errors |\n| **input validation** | Checking parameters meet security requirements before proceeding with operations | Validates passwords, iteration counts, salt lengths, and algorithm parameters |\n| **parameter validation** | Checking algorithm parameters meet security requirements and system constraints | Enforces minimum iteration counts, appropriate memory costs, and valid configurations |\n| **entropy exhaustion** | Insufficient randomness available for secure operations requiring high-quality random numbers | Detected and handled by refusing to generate predictable salt values |\n| **resource exhaustion** | System resources insufficient for secure operations within acceptable time limits | Handled through parameter adjustment or operational fallback procedures |\n| **configuration validation** | Verifying system configuration meets security requirements before enabling password operations | Ensures algorithms are properly configured and security parameters are appropriate |\n\n### Performance and Benchmarking Terminology\n\nPassword hashing performance measurement and tuning involves specific terminology around timing and resource usage:\n\n| Term | Definition | Performance Tuning Application |\n|------|------------|-------------------------------|\n| **adaptive security tuning** | Adjusting security parameters based on hardware capabilities to maintain consistent security level | Automatically configures iteration counts and memory costs for current hardware |\n| **performance profiling** | Systematic measurement of algorithm execution characteristics including timing and resource usage | Guides parameter selection and identifies performance bottlenecks |\n| **benchmark calibration** | Process of measuring algorithm performance to determine appropriate security parameters | Ensures consistent computation time across different hardware configurations |\n| **target timing** | Desired computation duration for password hashing operations balancing security and usability | Typically 250-500ms for interactive authentication, longer for high-security applications |\n| **scalability metrics** | Measurements of how algorithm performance changes with increased load or parallel operations | Important for server applications handling multiple concurrent authentications |\n| **hardware capabilities** | Computational and memory resources available for password hashing operations | Influences algorithm selection and parameter configuration |\n\n### Privacy and Data Protection Terminology\n\nModern password security includes privacy-preserving techniques and data protection concepts:\n\n| Term | Definition | Privacy Protection Application |\n|------|------------|-------------------------------|\n| **k-anonymity** | Privacy technique ensuring individual cannot be distinguished within group of k individuals | Applied in breach checking using hash prefixes to maintain user privacy |\n| **hash prefix** | First few characters of password hash used for privacy-preserving breach checking | Typically 5 characters creating large anonymity set while enabling breach detection |\n| **privacy-preserving** | Techniques protecting user data while enabling security checking and analysis | Enables breach monitoring without revealing specific passwords to external services |\n| **breach monitoring** | Checking passwords against known data breach databases to identify compromised credentials | Integrated with privacy-preserving techniques to protect user confidentiality |\n| **data minimization** | Privacy principle limiting data collection and retention to minimum necessary for function | Applied to breach checking by using hash prefixes rather than complete hashes |\n\n### Extension and Integration Terminology\n\nFuture system extensions and integrations involve specific terminology around modular design:\n\n| Term | Definition | System Architecture Impact |\n|------|------------|---------------------------|\n| **extension architecture** | System design supporting additional features without modifying core password hashing functionality | Enables policy engines, breach monitoring, and other advanced features |\n| **policy engine** | System for coordinating password validation rules beyond cryptographic security | Supports password complexity requirements, dictionary checking, and organizational policies |\n| **plugin architecture** | Design pattern allowing modular addition of functionality through well-defined interfaces | Enables algorithm plugins, storage backends, and monitoring integrations |\n| **integration boundaries** | Defined interfaces between password hashing system and external components | Maintains security isolation while enabling necessary interactions |\n| **rate limiting** | Controlling request frequency to prevent service abuse and resource exhaustion | Applied to authentication attempts and external service queries |\n\n### Mathematical and Cryptographic Foundations\n\nUnderstanding the mathematical foundations underlying password hashing security:\n\n| Term | Definition | Mathematical Security Basis |\n|------|------------|----------------------------|\n| **discrete logarithm problem** | Mathematical problem underlying many cryptographic security assumptions | Not directly used in password hashing but influences overall cryptographic security |\n| **proof of work** | Cryptographic requirement to demonstrate computational effort through solving mathematical puzzle | Conceptual foundation for key stretching - proving computational expense |\n| **memory-hard** | Algorithm requiring significant memory resources that cannot be efficiently reduced | Argon2 property making parallel attacks using specialized hardware more difficult |\n| **time-memory tradeoff** | Attack technique trading computation time against memory storage in cryptographic attacks | Considered in algorithm design to ensure no efficient shortcuts exist |\n| **cryptographic primitive** | Basic cryptographic operation used as building block for more complex algorithms | Includes hash functions, HMAC, and random number generation |\n\n### Implementation and Development Terminology\n\nPractical terminology for implementing password hashing systems:\n\n| Term | Definition | Development Considerations |\n|------|------------|---------------------------|\n| **component architecture** | System design with focused single-responsibility components having clear interfaces | Separates salt generation, hashing, verification, and migration concerns |\n| **defense in depth** | Multiple independent security barriers providing layered protection | Combines salting, key stretching, algorithm agility, and timing attack protection |\n| **vulnerability demonstration** | Showing security weaknesses through concrete examples and attack simulations | Educational technique helping developers understand threat models |\n| **scope creep** | Expanding project requirements beyond defined boundaries | Avoided by focusing on password hashing rather than broader authentication systems |\n| **milestone progression** | Incremental development approach building complexity through defined stages | Progresses from basic hashing through key stretching to modern algorithms |\n\n### Implementation Guidance\n\nThis section provides practical guidance for understanding and using cryptographic terminology while implementing password hashing systems.\n\n#### Technology Recommendations for Cryptographic Operations\n\n| Operation | Simple Option | Advanced Option |\n|-----------|---------------|-----------------|\n| Random Generation | `secrets.token_bytes()` (Python built-in) | Custom entropy pooling with `os.urandom()` |\n| Hash Computation | `hashlib.sha256()` (Python built-in) | Hardware-accelerated cryptographic libraries |\n| Base64 Encoding | `base64.b64encode()` (Python built-in) | URL-safe variants with custom alphabet |\n| Constant-Time Comparison | `hmac.compare_digest()` (Python built-in) | Custom implementation with explicit timing control |\n| PBKDF2 Implementation | `hashlib.pbkdf2_hmac()` (Python built-in) | Dedicated cryptographic libraries like `cryptography` |\n| bcrypt Integration | `bcrypt` package (external dependency) | `passlib` for algorithm abstraction |\n| JSON Serialization | `json` module (Python built-in) | `orjson` for performance-critical applications |\n\n#### Recommended Project Structure for Glossary Integration\n\n```\nproject-root/\n  docs/\n    glossary.md                    ← this comprehensive glossary\n    algorithm-comparison.md        ← algorithm selection guidance\n  src/password_hashing/\n    core/\n      __init__.py                 ← core exports and terminology constants\n      terminology.py              ← programmatic access to definitions\n    algorithms/\n      __init__.py                 ← algorithm registry\n      basic_hasher.py            ← SHA-256 with terminology documentation\n      key_stretching.py          ← PBKDF2 with terminology documentation  \n      modern_hasher.py           ← bcrypt/Argon2 with terminology documentation\n    utils/\n      constants.py               ← cryptographic constants with definitions\n      validation.py              ← parameter validation with terminology\n  tests/\n    test_terminology.py          ← verify terminology usage consistency\n    test_documentation.py        ← validate documentation accuracy\n```\n\n#### Terminology Constants Implementation\n\n```python\n\"\"\"\nCryptographic constants with precise terminology definitions.\nEach constant includes comprehensive documentation explaining its purpose,\nsecurity implications, and relationship to industry standards.\n\"\"\"\n\n# Salt generation constants with security rationale\nMINIMUM_SALT_LENGTH = 16  # bytes - sufficient to prevent birthday attacks\nRECOMMENDED_SALT_LENGTH = 32  # bytes - provides excellent security margin\nMAXIMUM_SALT_LENGTH = 64  # bytes - practical upper limit for storage efficiency\n\n# Key stretching parameters with performance guidance  \nPBKDF2_MIN_ITERATIONS = 100_000  # minimum iterations for current hardware\nBCRYPT_MIN_COST = 12  # minimum cost factor achieving ~250ms computation time\n\n# Algorithm identifiers using standard terminology\nclass AlgorithmNames:\n    \"\"\"Standard algorithm names matching cryptographic literature.\"\"\"\n    SHA256_BASIC = \"sha256-basic\"\n    PBKDF2_HMAC_SHA256 = \"pbkdf2-hmac-sha256\" \n    BCRYPT = \"bcrypt\"\n    ARGON2ID = \"argon2id\"\n\n# Error codes using precise terminology\nclass ErrorCodes:\n    \"\"\"Error classification using standard cryptographic terminology.\"\"\"\n    ENTROPY_EXHAUSTION = \"entropy-exhaustion\"\n    PARAMETER_VALIDATION = \"parameter-validation\"\n    ALGORITHM_UNAVAILABLE = \"algorithm-unavailable\"\n    TIMING_ATTACK_DETECTED = \"timing-attack-detected\"\n```\n\n#### Glossary Integration Helper Functions\n\n```python\ndef get_algorithm_terminology(algorithm_name: str) -> dict:\n    \"\"\"\n    Return comprehensive terminology and definitions for specified algorithm.\n    Helps developers understand precise meaning of algorithm-specific concepts.\n    \n    TODO 1: Validate algorithm_name against known algorithms\n    TODO 2: Return dictionary with algorithm-specific terminology\n    TODO 3: Include security properties, parameters, and usage guidelines\n    TODO 4: Add references to relevant standards and specifications\n    \"\"\"\n    \ndef validate_terminology_usage(code_text: str) -> list:\n    \"\"\"\n    Analyze code for consistent terminology usage matching glossary definitions.\n    Helps maintain precise language throughout implementation.\n    \n    TODO 1: Parse code for cryptographic terminology usage\n    TODO 2: Check against glossary definitions for consistency\n    TODO 3: Identify deprecated or imprecise terminology\n    TODO 4: Return list of terminology issues with suggestions\n    \"\"\"\n\ndef generate_documentation_template(component_name: str) -> str:\n    \"\"\"\n    Generate documentation template with appropriate terminology sections.\n    Ensures comprehensive coverage of cryptographic concepts.\n    \n    TODO 1: Identify relevant terminology categories for component\n    TODO 2: Generate template with terminology definition sections  \n    TODO 3: Include placeholder text with proper terminology usage\n    TODO 4: Add cross-references to related glossary entries\n    \"\"\"\n```\n\n#### Common Terminology Usage Patterns\n\n```python\nclass TerminologyPatterns:\n    \"\"\"\n    Common patterns for using cryptographic terminology consistently\n    throughout password hashing implementation.\n    \"\"\"\n    \n    def describe_security_property(self, property_name: str, context: str) -> str:\n        \"\"\"\n        Generate standardized description of security property in context.\n        \n        TODO 1: Look up property definition in glossary\n        TODO 2: Adapt description for specific context\n        TODO 3: Include relevant threat model information\n        TODO 4: Add implementation guidance references\n        \"\"\"\n        \n    def explain_algorithm_choice(self, algorithm: str, rationale: str) -> str:\n        \"\"\"\n        Generate explanation of algorithm selection using precise terminology.\n        \n        TODO 1: Include algorithm-specific security properties\n        TODO 2: Compare against alternative algorithms\n        TODO 3: Explain security/performance tradeoffs\n        TODO 4: Reference industry standards and recommendations\n        \"\"\"\n```\n\n#### Milestone Checkpoints for Terminology Understanding\n\nAfter implementing each milestone, verify terminology understanding:\n\n**Milestone 1 Checkpoint:**\n- [ ] Can explain difference between \"salt\" and \"pepper\" terminology\n- [ ] Understands \"rainbow table\" attack and defense mechanisms  \n- [ ] Uses \"cryptographic security\" vs \"computational security\" appropriately\n- [ ] Correctly describes \"timing attack\" vulnerability and prevention\n\n**Milestone 2 Checkpoint:**\n- [ ] Explains \"key stretching\" vs \"key derivation\" terminology distinction\n- [ ] Understands \"iteration count\" vs \"cost factor\" in different algorithms\n- [ ] Uses \"computational hardness\" terminology correctly in security analysis\n- [ ] Describes \"side-channel resistance\" requirements accurately\n\n**Milestone 3 Checkpoint:**\n- [ ] Distinguishes \"algorithm agility\" from simple algorithm support\n- [ ] Explains \"memory-hard\" properties and their security implications\n- [ ] Uses \"lazy migration\" terminology in upgrade strategy discussions\n- [ ] Correctly describes \"fail-secure behavior\" in error handling\n\n#### Debugging Terminology Confusion\n\n| Symptom | Terminology Issue | Diagnosis | Fix |\n|---------|------------------|-----------|-----|\n| Code comments use \"encryption\" for hashing | Confusing reversible vs irreversible operations | Review cryptographic operation types | Use \"hashing\" for one-way operations, \"encryption\" for reversible |\n| Documentation mentions \"decrypting passwords\" | Fundamental misunderstanding of password storage | Check understanding of one-way functions | Passwords are verified, not decrypted - hashing is irreversible |\n| Variable names like `password_key` | Mixing password and key terminology | Review terminology for derived values | Use `derived_key` for PBKDF2 output, `password_hash` for storage |\n| Comments refer to \"salted encryption\" | Combining unrelated cryptographic concepts | Clarify salting vs encryption purposes | Salting prevents precomputation, encryption provides confidentiality |\n| Error messages mention \"hash decryption failed\" | Incorrect mental model of verification process | Review verification algorithm steps | Verification re-computes hash, doesn't \"decrypt\" anything |\n"}